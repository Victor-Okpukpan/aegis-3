{
  "category": "Options",
  "total_findings": 10,
  "fetched_at": "2026-01-29T13:45:35Z",
  "findings": [
    {
      "id": "64690",
      "title": "[L-05] Unbounded Fee Parameters Allow Abusive Fees and Redemption DoS",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`PawnShop` charges a fee (in basis points) on top of the borrowed principal when a borrower redeems their NFT via `redeem(...)` (context).\n\nHowever, `setFees(...)` allows `MANAGER_ROLE` to set `fee7Days` and `fee30Days` to any `uint16` value, with no upper bound (e.g., `<= BASIS_POINTS`) and no sanity checks (problem).\n\nThis means a manager can set fees to values that make redemption economically impossible (or unexpectedly expensive), effectively trapping users or extracting arbitrary value at repayment time (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L111-L115](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L111-L115)\n\n```solidity\nfunction setFees(uint16 _fee7Days, uint16 _fee30Days) external onlyRole(MANAGER_ROLE) {\n    // @audit No bounds checks (e.g., <= BASIS_POINTS)\n    fee7Days = _fee7Days;\n    fee30Days = _fee30Days;\n    emit FeesUpdated(_fee7Days, _fee30Days);\n}\n```\n\n## Impact\n\n- **Redemption DoS**: Fees can be set so high that borrowers cannot (or will not) repay.\n- **Unexpected user loss**: Borrowers who expected fixed or bounded fees can be forced into paying excessive fees to redeem collateral.\n\n## Proof of Concept\n\n1. User pawns an NFT.\n2. Manager calls `setFees(65_535, 65_535)`.\n3. `redeem(...)` now requires paying principal + ~655.35% fee, which will likely be infeasible for most borrowers.\n\n## Recommendation\n\nEnforce bounds (example):\n\n- `require(_fee7Days <= BASIS_POINTS && _fee30Days <= BASIS_POINTS)`\n\n## Team Response\n\nFixed.\n\n## [I-01] Burned UUIDs Can Be Re-Minted\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe `RWA.mint(...)` assigns a `uuid` to each token and enforces uniqueness by tracking `_usedUUIDs[uuid]` (context).\n\nHowever, all burn paths (`burn(...)`, `burnForRedemption(...)`, `burnForSellback(...)`) delete `_usedUUIDs[uuid]`, making the UUID available for reuse (problem).\n\nThis means the on-chain guarantee is “no two _currently existing_ tokens share a UUID”, not “a UUID is unique forever”. If off-chain systems treat `uuid` as a permanent physical-asset identifier, UUID reuse can lead to confusion or allow re-issuance of previously redeemed assets without an explicit re-deposit workflow (impact).\n\n## Location of Affected Code\n\nFile: [sRWA.sol#L140-L152](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L140-L152)\n\n```solidity\nfunction mint(address to, string calldata uuid) external onlyRole(MINTER_ROLE) nonReentrant whenNotPaused {\n    // code\n    if (_usedUUIDs[uuid]) revert UUIDAlreadyExists();\n    // code\n    _tokenUUID[tokenId] = uuid;\n    _usedUUIDs[uuid] = true;\n    _safeMint(to, tokenId);\n}\n```\n\nFile: [sRWA.sol#L200-L207](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L200-L207)\n\n```solidity\nfunction burnForRedemption(uint256 tokenId) external onlyTokenOwner(tokenId) whenNotPaused {\n    string memory uuid = _tokenUUID[tokenId];\n    // @audit UUID becomes reusable after burn\n    delete _usedUUIDs[uuid];\n    delete _tokenUUID[tokenId];\n    _burn(tokenId);\n}\n```\n\n## Impact\n\nUUID uniqueness is not permanent.\n\n## Proof of Concept\n\n1. Admin mints a token with `uuid = \"UUID-123\"`.\n2. Owner calls `burnForRedemption(tokenId)`.\n3. Admin mints a new token again with `uuid = \"UUID-123\"`; the mint succeeds because `_usedUUIDs[\"UUID-123\"]` was deleted.\n\n## Recommendation\n\nDecide which uniqueness guarantee is required:\n\n- If UUID must be globally unique forever, **do not delete** `_usedUUIDs[uuid]` on burn.\n\n## Team Response\n\nAcknowledged.\n\n## [I-02] Redundant `usedSignatures` Tracking Alongside Nonce-Based Replay Protection\n\n## Severity\n\nInformational Risk\n\n## Description\n\n`PawnShop` and `RWA` apply two replay protections to EIP-712 signatures:\n\n- Per-user `nonces[user]` included in the signed payload and incremented on success.\n- A global `usedSignatures[digest]` mapping.\n\nFor these flows, the nonce already prevents replay for the same sender: after a successful call, the contract computes the digest using `nonce + 1`, so the old signature no longer verifies. As a result, `usedSignatures` is largely redundant and adds an extra storage write.\n\nNote: `Treasury.transferWithSignature(...)` does not include a nonce, so `usedSignatures` (or adding a nonce/salt) is required there to prevent replay until `validUntil`.\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n- `usedSignatures[digest]` check + write in signature validation paths\n- `nonces[msg.sender]++` performed after successful validation\n\nFile: [Treasury.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol)\n\n- Signature payload lacks a nonce; `usedSignatures` provides replay protection until `validUntil`\n\n## Impact\n\nEach successful signature-based call in `PawnShop`/`RWA` incurs an extra `SSTORE` for `usedSignatures[digest]`.\n\n## Recommendation\n\nIn `PawnShop` and `RWA`, remove `usedSignatures` and rely on nonces for replay protection.\n\n## Team Response\n\nFixed.\n\n## [I-03] Configuration Mismatch Risk Across `backendSigner` and `treasury` Addresses\n\n## Severity\n\nInformational Risk\n\n## Description\n\nThe system relies on coordinated configuration across three separate contracts:\n\n- `PawnShop` validates a backend signature (`pawnSignature`) using its own `backendSigner`.\n- `RWA` validates a backend signature (`sellbackSignature`) using its own `backendSigner`.\n- `Treasury` validates a backend signature (`treasurySignature`) using _its_ `backendSigner`, and also requires the caller to be allowlisted.\n\nThese settings are each managed independently via admin setters (context).\n\nHowever, there is no on-chain enforcement that these configuration values remain consistent (problem).\n\nThis means a simple operational misconfiguration (e.g., updating `PawnShop.backendSigner` but not `Treasury.backendSigner`, or pointing `PawnShop.treasury` at the wrong address) can halt core flows like `pawn(...)` and `burnForSellback(...)` (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n```solidity\naddress public treasury;\naddress public backendSigner;\n\nfunction setTreasury(address _treasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    treasury = _treasury;\n}\n\nfunction setBackendSigner(address _signer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    backendSigner = _signer;\n}\n```\n\nFile: [Treasure.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol)\n\n```solidity\naddress public backendSigner;\n\nfunction setBackendSigner(address _signer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    backendSigner = _signer;\n}\n```\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n```solidity\naddress public treasury;\naddress public backendSigner;\n\nfunction setTreasury(address _treasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    treasury = _treasury;\n}\n\nfunction setBackendSigner(address _signer) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    // code\n    backendSigner = _signer;\n}\n```\n\n## Impact\n\nMismatched signers or wrong treasury addresses cause signature checks or external calls to revert, halting user actions.\n\n## Proof of Concept\n\n1. Admin updates `PawnShop.backendSigner` to a new key.\n2. Admin forgets to update `Treasury.backendSigner`.\n3. Users can no longer successfully call `pawn(...)` because the pawn signature and treasury signature are validated against different signer keys across contracts.\n\n## Recommendation\n\nUse a **single configuration source of truth**, e.g. a registry contract that stores `backendSigner`/`treasury` addresses read by all modules.\n\n## Team Response\n\nAcknowledged.\n\n## [I-04] PawnShop `MAX_LOAN_AMOUNT` Can Exceed Treasury\n\n## Severity\n\nInformational Risk\n\n## Description\n\n`PawnShop` validates offers up to its hard cap `MAX_LOAN_AMOUNT = 1_000_000 * 10**6`, but the funding path `Treasury.transferWithSignature(...)` applies a per-call limit from `contractTransferLimits[msg.sender]` (defaulting to `maxTransferPerCall = 100_000 * 10**6` when unset).\n\nAs a result, `PawnShop` can accept and sign offers up to 1,000,000 USDC that will deterministically revert in Treasury for amounts above 100,000 USDC unless the transfer limit is explicitly raised.\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L62](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L62)\n\n```solidity\n// max loan is 1 million usdc\nuint256 public constant MAX_LOAN_AMOUNT = 1_000_000 * 10**6;\n```\n\nFile: [Treasure.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol)\n\n```solidity\nmapping(address => uint256) public contractTransferLimits;\nuint256 public maxTransferPerCall = 100_000 * 10**6;\n\nfunction transferWithSignature(address recipient, uint256 amount, uint256 validUntil, bytes32 operationHash, bytes calldata signature) external nonReentrant whenNotPaused {\n    // code\n    uint256 limit = contractTransferLimits[msg.sender];\n    if (limit == type(uint256).max) limit = maxTransferPerCall;\n\n    if (amount > limit) revert AmountExceedsMaxTransfer();\n    if (amount > usdc.balanceOf(address(this))) revert InsufficientBalance();\n    // code\n}\n```\n\n## Impact\n\nUsers can waste gas on offers that pass `PawnShop` checks but fail funding.\n\n## Recommendation\n\nAlign the constraints:\n\n- Either lower `PawnShop.MAX_LOAN_AMOUNT` to match the effective Treasury limit, or\n- Raise/configure `Treasury.maxTransferPerCall` / `contractTransferLimits[PawnShop]` to support the intended max loan.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64689",
      "title": "[L-04] Admin Can Drain Treasury Reserves via `withdrawUSDC()`",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nThe `Treasury` contract is the central pool of USDC that the system uses to fund `PawnShop.pawn(...)` loans and `RWA.burnForSellback(...)` buybacks (context).\n\nHowever, `Treasury.withdrawUSDC(...)` allows `DEFAULT_ADMIN_ROLE` to transfer arbitrary amounts of USDC to an arbitrary address, with no on-chain constraints.\n\nThis means an admin can fully drain user/protocol reserves and render core flows insolvent, effectively enabling a rug pull where the admin can steal all Treasury funds while users have NFTs locked in active pawn positions.\n\n## Location of Affected Code\n\nFile: [Treasure.sol#L167-L174](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Treasure.sol#L167-L174)\n\n```solidity\nfunction withdrawUSDC(address to, uint256 amount) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n    // @audit Admin can withdraw the entire USDC reserve at any time\n    if (to == address(0)) revert InvalidAddress();\n    if (amount == 0) revert InvalidAmount();\n    if (amount > usdc.balanceOf(address(this))) revert InsufficientBalance();\n\n    usdc.safeTransfer(to, amount);\n    emit USDCWithdrawn(to, amount);\n}\n```\n\n## Impact\n\nThe vulnerability enables direct fund loss as the admin can transfer all USDC out of the Treasury, leading to protocol insolvency where drained reserves cause signature-authorized payouts to fail due to insufficient balance, halting both `pawn(...)` and sellback flows. This effectively creates a rug pull scenario where the admin can drain all Treasury reserves while users have NFTs locked in active pawn positions, leaving users unable to access new loans and completely compromising the protocol's solvency.\n\n## Proof of Concept\n\n1. `Treasury` holds USDC reserves for loans and buybacks.\n2. Admin calls `withdrawUSDC(admin, usdc.balanceOf(address(treasury)))`.\n3. `Treasury` becomes empty; future payouts revert due to `InsufficientBalance()`.\n\n## Recommendation\n\nAllow a rescue token functionality with no USDC withdrawal or keep a track of the protocol's funds and only allow to sweep the dust.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64688",
      "title": "[L-04] Unbounded Fee Parameters Allow Abusive Fees and Redemption DoS",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`PawnShop` charges a fee (in basis points) on top of the borrowed principal when a borrower redeems their NFT via `redeem(...)` (context).\n\nHowever, `setFees(...)` allows `MANAGER_ROLE` to set `fee7Days` and `fee30Days` to any `uint16` value, with no upper bound (e.g., `<= BASIS_POINTS`) and no sanity checks (problem).\n\nThis means a manager can set fees to values that make redemption economically impossible (or unexpectedly expensive), effectively trapping users or extracting arbitrary value at repayment time (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L111-L115](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L111-L115)\n\n```solidity\nfunction setFees(uint16 _fee7Days, uint16 _fee30Days) external onlyRole(MANAGER_ROLE) {\n    // @audit No bounds checks (e.g., <= BASIS_POINTS)\n    fee7Days = _fee7Days;\n    fee30Days = _fee30Days;\n    emit FeesUpdated(_fee7Days, _fee30Days);\n}\n```\n\n## Impact\n\n- **Redemption DoS**: Fees can be set so high that borrowers cannot (or will not) repay.\n- **Unexpected user loss**: Borrowers who expected fixed or bounded fees can be forced into paying excessive fees to redeem collateral.\n\n## Proof of Concept\n\n1. User pawns an NFT.\n2. Manager calls `setFees(65_535, 65_535)`.\n3. `redeem(...)` now requires paying principal + ~655.35% fee, which will likely be infeasible for most borrowers.\n\n## Recommendation\n\nEnforce bounds (example):\n\n- `require(_fee7Days <= BASIS_POINTS && _fee30Days <= BASIS_POINTS)`\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64687",
      "title": "[L-03] `permit()` Can Approve a Blacklisted Spender (Missing Blacklist Check) But approve() Does Not Allow",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`RWA` enforces blacklist restrictions in `approve()` / `setApprovalForAll()` by reverting when the target operator/spender is blacklisted.\n\nHowever, the gasless approval path `permit()` does **not** validate `_isBlacklisted[spender]` and directly calls `_approve(spender, ...)`.\nAs a result, a blacklisted address can become the current `getApproved(tokenId)` via `permit()`, even though `approve()` would revert.\n\nNote: the blacklisted spender still cannot execute `transferFrom()` while blacklisted because `_update()` reverts when `auth` (caller) is blacklisted.\nSo this is primarily a **policy bypass / inconsistency** (and potential UX/integration/compliance confusion), not an immediate theft vector by itself.\n\n## Location of Affected Code\n\nFile: [Audit_Submission/src/sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nfunction permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n  // code\n   _approve(spender, tokenId, owner); // missing: if (_isBlacklisted[spender]) revert Blacklisted();\n}\n\nfunction approve(address to, uint256 tokenId) public virtual override {\n   if (_isBlacklisted[to]) revert Blacklisted(); // blacklist enforced here\n   super.approve(to, tokenId);\n}\n```\n\n## Impact\n\nA blacklisted address can still appear as the approved spender for a token (`getApproved(tokenId)`), despite the blacklist policy.\n\n## Proof of Concept\n\nRun in `test/System.t.sol`\n\n```solidity\nfunction test_POC_Permit_Allows_BlacklistedSpender_ToBeApproved() public {\n    /**\n     * POC: `RWA.permit()` does NOT check `_isBlacklisted[spender]`, unlike `approve()`.\n     *\n     * Expected blacklist policy (as implemented in approve()):\n     * - You should NOT be able to approve a blacklisted spender.\n     *\n     * Actual behavior:\n     * - `approve(blacklisted, tokenId)` reverts,\n     * - but `permit(blacklisted, tokenId, ...)` succeeds and sets `getApproved(tokenId) == blacklisted`.\n     *\n     * Note: the blacklisted spender still cannot transfer (blocked by `_update()`'s `auth` blacklist check),\n     * so the impact is mainly \"policy bypass / inconsistent approval state\".\n     */\n    address blacklistedSpender = makeAddr(\"blacklistedSpender\");\n    address relayer = makeAddr(\"relayer\");\n    address receiver = makeAddr(\"receiver\");\n\n    // Mint a fresh token to `owner` (we have ownerPk so we can sign permits).\n    vm.startPrank(owner);\n    rwa.mint(owner, \"PERMIT-BLACKLIST\");\n    uint256 tokenId = rwa.nextTokenId() - 1;\n\n    // Admin blacklists the spender.\n    rwa.blacklistContract(blacklistedSpender);\n    assertTrue(rwa.isBlacklisted(blacklistedSpender));\n\n    // Baseline: normal approve() respects blacklist and reverts.\n    vm.expectRevert(RWA.Blacklisted.selector);\n    rwa.approve(blacklistedSpender, tokenId);\n    vm.stopPrank();\n\n    // Build an EIP-712 permit approving the blacklisted spender.\n    uint256 nonce = rwa.nonces(owner);\n    uint256 deadline = block.timestamp + 1 hours;\n    (uint8 v, bytes32 r, bytes32 s) = _signPermit(ownerPk, blacklistedSpender, tokenId, nonce, deadline);\n\n    // Anyone can submit the permit (gasless approval). Use a relayer for clarity.\n    vm.prank(relayer);\n    rwa.permit(blacklistedSpender, tokenId, deadline, v, r, s);\n\n    // Approval state is now set to a blacklisted address (policy bypass).\n    assertEq(rwa.getApproved(tokenId), blacklistedSpender);\n\n    // Even though approved, the blacklisted spender cannot transfer due to `_update()` reverting on `auth` blacklist.\n    vm.prank(blacklistedSpender);\n    vm.expectRevert(RWA.Blacklisted.selector);\n    rwa.transferFrom(owner, receiver, tokenId);\n}\n```\n\n## Recommendation\n\nConsider adding the same blacklist enforcement to `permit()` as `approve()`:\n\n- `if (spender != address(0) && _isBlacklisted[spender]) revert Blacklisted();`\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64686",
      "title": "[L-02] Hardcoded 6-decimal Stablecoin Assumptions Brick Protocol on 18-decimal Deployments",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\nNote: this issue is valid if the protocol deploys in chains like BSC\n\n1. In the BSC chain, a stable coin with $8B in circulation has 18 decimals: [address](https://bscscan.com/token/0x55d398326f99059ff775485246999027b3197955)\n2. Search other stablecoins, here at https://bscscan.com/tokens. They are mostly of 18 decimals\n\nMultiple core parameters are hardcoded as if the payment token (\"USDC\") always uses **6 decimals** (multiplying by `10**6`).\nIf the deployed payment token uses **18 decimals** (common for stables on some chains), these constants become off by 10^12,\ncausing critical functionality to revert or enforce meaningless limits.\n\nSpecifically:\n\n- `PawnShop.MAX_LOAN_AMOUNT` is expressed in 6-decimal units, so any realistic 18-decimal loan amount becomes “too high” and reverts.\n- `RWA.MIN_SELLBACK_AMOUNT` is intended to represent “1 USDC”, but on 18 decimals, it becomes dust, so the minimum sellback policy is not enforced.\n- `Treasury.maxTransferPerCall` defaults to a 6-decimal unit limit, so `transferWithSignature()` reverts for normal 18-decimal amounts until an admin updates the value.\n\n## Location of Affected Code\n\nFile: [Audit_Submission/src/Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nuint256 public constant MAX_LOAN_AMOUNT = 1_000_000 * 10**6;\n\nif (offerAmount == 0 || offerAmount > MAX_LOAN_AMOUNT) revert InvalidAmount();\n```\n\nFile: [Audit_Submission/src/sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nuint256 public constant MIN_SELLBACK_AMOUNT = 1 * 10**6;\n\nif (usdcAmount < MIN_SELLBACK_AMOUNT) revert InvalidAmount();\n```\n\nFile: [Audit_Submission/src/Treasury.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\nuint256 public maxTransferPerCall = 100_000 * 10**6;\n\nif (limit == type(uint256).max) limit = maxTransferPerCall;\nif (amount > limit) revert AmountExceedsMaxTransfer();\n```\n\n## Impact\n\n- **Protocol bricking on 18-decimals deployments**: borrowers cannot take “normal” loans because `pawn()` reverts with `InvalidAmount()` for realistic values.\n- **Broken economic constraint**: `MIN_SELLBACK_AMOUNT` no longer enforces “minimum 1 token”; users can sell back for dust amounts if the backend signs it.\n- **Operational failure risk**: Treasury payouts revert with `AmountExceedsMaxTransfer()` until `maxTransferPerCall` is manually updated.\n\n## Proof of Concept\n\nRun it in `test/System.t.sol`\n\n```solidity\nfunction test_POC_18DecimalsStable_Hardcoded1e6_Assumptions_BrickOrBreakLimits() public {\n    /**\n     * This POC demonstrates a real deployment hazard:\n     * the protocol hardcodes several \"USDC has 6 decimals\" constants (x * 10**6),\n     * but many chains/tokens (e.g. BSC stables) use 18 decimals.\n     *\n     * In THIS test suite, `MockUSDC` inherits OpenZeppelin `ERC20`, which uses 18 decimals by default.\n     * So amounts like 1e18 represent \"1 whole token\", while 1e6 represents \"0.000000000001 token\".\n     *\n     * We prove all 3 issues in one flow:\n     *  (1) PawnShop.MAX_LOAN_AMOUNT is set to 1_000_000 * 1e6 (6-decimal units).\n     *      With an 18-decimal token, even a 1-token loan (1e18) is > MAX_LOAN_AMOUNT and reverts.\n     *  (2) RWA.MIN_SELLBACK_AMOUNT is set to 1 * 1e6, intended to mean \"1 USDC\".\n     *      With an 18-decimal token, this is dust (1e-12 token), so the \"min 1 token\" policy is not enforced.\n     *  (3) Treasury.maxTransferPerCall defaults to 100_000 * 1e6, also 6-decimals units.\n     *      With an 18-decimal token, even a 1-token payout exceeds the limit until the admin updates it.\n     */\n    assertEq(usdc.decimals(), 18);\n\n    // 1 whole token in base units for an 18-decimal ERC20.\n    uint256 oneToken = 1e18;\n\n    /* =============================================================\n     * (1) PawnShop MAX_LOAN_AMOUNT bricks normal loans on 18-decimals.\n     * ============================================================= */\n    {\n        uint256 tokenId = 1;\n\n        // MAX_LOAN_AMOUNT is 1_000_000 * 1e6 = 1e12 base units.\n        // On an 18-decimal token, 1e12 base units is only 0.000001 token.\n        assertEq(pawnShop.MAX_LOAN_AMOUNT(), 1_000_000 * 10**6);\n        assertGt(oneToken, pawnShop.MAX_LOAN_AMOUNT());\n\n        // Even with valid signatures, the call reverts before signature verification due to the hardcoded max amount.\n        PawnCall memory c = _buildPawnCall(user, tokenId, 7, oneToken, block.timestamp + 1 hours);\n\n        // Approve first (this should succeed). Then prove the pawn() itself is bricked by the hardcoded MAX_LOAN_AMOUNT.\n        vm.prank(user);\n        rwa.approve(address(pawnShop), tokenId);\n\n        vm.expectRevert(PawnShop.InvalidAmount.selector);\n        _pawnWithCall(user, c, false);\n\n        // Sanity: pawn reverted, so the NFT was not transferred.\n        assertEq(rwa.ownerOf(tokenId), user);\n    }\n\n    /* =============================================================\n     * (2) RWA MIN_SELLBACK_AMOUNT becomes dust on 18-decimal tokens.\n     * ============================================================= */\n    uint256 userBalBeforeSell = usdc.balanceOf(user);\n    {\n        uint256 tokenId = 1;\n        uint256 sellAmount = rwa.MIN_SELLBACK_AMOUNT(); // 1 * 1e6 base units\n        assertEq(sellAmount, 1 * 10**6);\n\n        // On 18 decimals, this is far less than 1 whole token, so the intended \"min 1 token\" policy is not enforced.\n        assertLt(sellAmount, oneToken);\n\n        uint256 validUntil = block.timestamp + 1 hours;\n        uint256 nonce = rwa.nonces(user);\n        bytes memory sellSig = _signSellback(backendPk, tokenId, sellAmount, validUntil, nonce);\n        bytes32 opHash = keccak256(abi.encode(\"SELLBACK\", tokenId, sellAmount, nonce, user));\n        bytes memory treasSig = _signTreasury(backendPk, user, sellAmount, validUntil, opHash);\n\n        // This succeeds because `sellAmount` >= MIN_SELLBACK_AMOUNT (even though it's dust in 18-decimal terms).\n        vm.prank(user);\n        rwa.burnForSellback(tokenId, sellAmount, validUntil, sellSig, treasSig);\n\n        assertEq(usdc.balanceOf(user), userBalBeforeSell + sellAmount);\n        vm.expectRevert();\n        rwa.ownerOf(tokenId); // tokenId 1 is burned\n    }\n\n    /* =============================================================\n     * (3) Treasury maxTransferPerCall is also 6-decimals by default.\n     * ============================================================= */\n    {\n        // Create a new approved contract so we can call `transferWithSignature` from an authorized sender.\n        TreasurySigReplayer replayer;\n        vm.startPrank(owner);\n        replayer = new TreasurySigReplayer(treasury);\n        treasury.approveContractForTransfers(address(replayer));\n        vm.stopPrank();\n\n        // Try a \"normal\" 1-token payout.\n        uint256 validUntil = block.timestamp + 1 hours;\n        bytes32 opHash = keccak256(\"POC_TREASURY_LIMIT_18_DECIMALS\");\n        bytes memory sig = _signTreasury(backendPk, user, oneToken, validUntil, opHash);\n\n        // This fails because Treasury defaults to maxTransferPerCall = 100_000 * 1e6 (6-decimals units).\n        // In 18-decimal terms, that limit is tiny, so even 1 token exceeds it.\n        assertEq(treasury.maxTransferPerCall(), 100_000 * 10**6);\n        assertGt(oneToken, treasury.maxTransferPerCall());\n\n        vm.expectRevert(Treasury.AmountExceedsMaxTransfer.selector);\n        replayer.replayTreasurySignature(user, oneToken, validUntil, opHash, sig);\n\n        // Admin can \"fix\" this after deployment by updating the limit to 18-decimal units,\n        // e.g. 100_000 tokens = 100_000 * 1e18.\n        vm.startPrank(owner);\n        treasury.setMaxTransferPerCall(100_000 * oneToken);\n        // Fund Treasury so the post-fix payout doesn't fail the balance check.\n        usdc.mint(address(treasury), oneToken);\n        vm.stopPrank();\n\n        uint256 userBalBeforePayout = usdc.balanceOf(user);\n        replayer.replayTreasurySignature(user, oneToken, validUntil, opHash, sig);\n        assertEq(usdc.balanceOf(user), userBalBeforePayout + oneToken);\n    }\n}\n```\n\n## Recommendation\n\n- Remove `10**6` hardcoding for the payment token.\n- Make thresholds **decimals-aware** by :\n  - **Passing `tokenDecimals` / `unit` as a constructor parameter**\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64685",
      "title": "[L-01] Pawn Duration Not Bound to Signed Quote Allows 7↔30-day Term Tampering",
      "impact": "LOW",
      "content": "\n## Severity\n\nLow Risk\n\n## Description\n\n`PawnShop` verifies an EIP-712 signature over `(tokenId, offerAmount, validUntil, nonce)` but `pawn()` accepts a user-supplied `durationDays` that is **not signed**.\nThis lets a borrower reuse the _same_ backend+treasury signatures while swapping duration terms:\n\n#### (Case 1): The backend intended a 7-day loan, but the borrower executed it as a 30-day loan.\n\nImpact (max severity scenario):\n\n- If your backend/risk engine prices or approves offers differently per duration (common),\n  a borrower can bypass that policy by choosing the more favourable term on-chain.\n\n#### (Case 2): The backend intended a 30-day loan, but the borrower executed it as a 7-day loan.\n\nImpact:\n\n- Direct protocol revenue loss: borrower pays the 7-day fee schedule instead of the 30-day fee schedule.\n- If your backend applies different approvals/limits per duration, this is also a term-tampering bypass.\n\n## Location of Affected Code\n\nFile: [Audit_Submission/src/Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Audit_Submission.zip)\n\n```solidity\n// durationDays is NOT part of the signed struct\nbytes32 private constant PAWN_TYPEHASH =\n    keccak256(\"Pawn(uint256 tokenId,uint256 offerAmount,uint256 validUntil,uint256 nonce)\");\n\nbytes32 structHash = keccak256(\n   abi.encode(\n       PAWN_TYPEHASH,\n       tokenId,\n       offerAmount,\n       validUntil,\n       usedNonce\n   )\n);\n\nfunction pawn(uint256 tokenId, uint8 durationDays, uint256 offerAmount, uint256 validUntil, bytes calldata, bytes calldata) external {\n    // durationDays controls fee + deadline, but is not authenticated by signatures\n    uint16 fee = durationDays == 7 ? fee7Days : fee30Days;\n    uint256 deadline = block.timestamp + (durationDays * 1 days);\n\n    // Treasury signature is also not bound to durationDays\n    bytes32 operationHash = keccak256(abi.encode(\"PAWN\", tokenId, offerAmount, currentNonce, msg.sender));\n}\n```\n\n## Impact\n\n- **7 → 30**: borrower can extend repayment window / delay liquidation from 7 to 30 days while using a quote intended for 7 days (bypasses duration-based risk approval; increases exposure + liquidity risk).\n- **30 → 7**: borrower can execute as 7 days to pay the lower fee schedule (protocol revenue loss + bypasses duration-based pricing).\n\n## Proof of Concept\n\nRun in `test/System.t.sol`\n\n```solidity\nfunction test_POC_Pawn_DurationNotSigned_AllowsExtending7DayQuoteTo30Days() public {\n    /**\n     * POC (Case 1): The backend intended a 7-day loan, but the borrower executed it as a 30-day loan.\n     *\n     * Root cause:\n     * - `PawnShop`'s EIP-712 signature (`PAWN_TYPEHASH`) does NOT commit to `durationDays` (or `deadline`).\n     * - The Treasury `operationHash` also does NOT commit to `durationDays`.\n     * Therefore, the exact same signatures are valid for BOTH `durationDays=7` and `durationDays=30`.\n     *\n     * Impact (max severity scenario):\n     * - If your backend/risk engine prices or approves offers differently per duration (common),\n     *   A borrower can bypass that policy by choosing the more favourable term on-chain.\n     * - Here we demonstrate the most dangerous direction: a borrower can EXTEND the repayment window\n     *   (and liquidation delay) from 7 days to 30 days while using the same signed quote.\n     */\n    uint256 tokenId = 1;\n    uint256 amount = 500 * 10**6;\n    uint256 validUntil = block.timestamp + 1 hours;\n\n    uint256 pawnTime = block.timestamp;\n\n    // \"Backend quote\" is represented by building signatures while expecting `durationDays=7`.\n    PawnCall memory c = _buildPawnCall(user, tokenId, 7, amount, validUntil);\n    bytes32 digest = _pawnDigest(tokenId, amount, validUntil, c.nonce);\n\n    // Borrower flips ONLY the duration parameter (not covered by the signature) to extend the loan term.\n    c.durationDays = 30;\n\n    _pawnWithCall(user, c, true);\n\n    // The loan is now a 30-day loan on-chain, despite being signed as a \"7-day quote\" off-chain.\n    (,, uint256 deadline, uint16 feeBP, bool active) = pawnShop.pawns(tokenId);\n    assertTrue(active);\n    assertEq(deadline, pawnTime + 30 days);\n    assertEq(feeBP, pawnShop.fee30Days());\n    assertTrue(pawnShop.usedSignatures(digest));\n\n    // Demonstrate the practical consequence: borrower can wait past 7 days and still redeem.\n    // A correctly-bound 7-day loan would have expired at this point (redeem would revert).\n    vm.warp(pawnTime + 8 days);\n    (uint256 totalDue, uint256 fee) = pawnShop.calculateRepayment(tokenId);\n\n    // Borrower already received `amount` during `pawn()`. Mint only the fee so the redemption can succeed.\n    usdc.mint(user, fee);\n\n    vm.startPrank(user);\n    usdc.approve(address(pawnShop), totalDue);\n    pawnShop.redeem(tokenId);\n    vm.stopPrank();\n\n    assertEq(rwa.ownerOf(tokenId), user);\n}\n\nfunction test_POC_Pawn_DurationNotSigned_AllowsUsing30DayQuoteAs7Days_ToPayLowerFee() public {\n    /**\n     * POC (Case 2): backend intended a 30-day loan, but borrower executes it as a 7-day loan.\n     *\n     * Impact:\n     * - Direct protocol revenue loss: borrower pays the 7-day fee schedule instead of the 30-day fee schedule.\n     * - If your backend applies different approvals/limits per duration, this is also a term-tampering bypass.\n     */\n    uint256 tokenId = 1;\n    uint256 amount = 500 * 10**6;\n    uint256 pawnTime = block.timestamp;\n    uint256 validUntil = pawnTime + 1 hours;\n    uint256 treasuryBal0 = usdc.balanceOf(address(treasury));\n\n    // Build signatures while the backend expects `durationDays=30`.\n    PawnCall memory c = _buildPawnCall(user, tokenId, 30, amount, validUntil);\n    // Borrower flips ONLY the duration parameter to reduce the fee schedule to the 7-day rate.\n    c.durationDays = 7;\n\n    _pawnWithCall(user, c, true);\n\n    {\n        (,, uint256 deadline, uint16 feeBP, bool active) = pawnShop.pawns(tokenId);\n        assertTrue(active);\n        assertEq(deadline, pawnTime + 7 days);\n        assertEq(feeBP, pawnShop.fee7Days());\n    }\n    assertTrue(pawnShop.usedSignatures(_pawnDigest(tokenId, amount, validUntil, c.nonce)));\n\n    // Fee difference: 30-day fee basis points are higher than 7-day fee basis points.\n    vm.warp(pawnTime + 1 days);\n    {\n        (uint256 totalDue, uint256 fee) = pawnShop.calculateRepayment(tokenId);\n\n        uint256 expectedFee7 = (amount * pawnShop.fee7Days()) / 10_000;\n        assertEq(fee, expectedFee7);\n        assertTrue(((amount * pawnShop.fee30Days()) / 10_000) > expectedFee7);\n\n        // Redeem and verify Treasury only collected the lower (7-day) fee.\n        usdc.mint(user, fee);\n\n        vm.startPrank(user);\n        usdc.approve(address(pawnShop), totalDue);\n        pawnShop.redeem(tokenId);\n        vm.stopPrank();\n\n        assertEq(usdc.balanceOf(address(treasury)), treasuryBal0 + expectedFee7);\n    }\n    assertEq(rwa.ownerOf(tokenId), user);\n}\n```\n\n## Recommendation\n\nBind the loan term to signatures by including `durationDays` (or the derived `deadline`) in the `pawn()` EIP-712 signed struct.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64684",
      "title": "[M-02] Liquidation Can Be Blocked By Pausing or Blacklisting the NFT Contract, Permanently Trapping Expired Loans",
      "impact": "MEDIUM",
      "content": "\n## Severity\n\nMedium Risk\n\n## Description\n\nWhen a pawn expires, `PawnShop.liquidate(...)` closes the position by burning the escrowed NFT collateral through the NFT’s `burn(...)` function (context).\n\nHowever, in this system, the NFT is `RWA`, whose burn path is gated by `whenNotPaused`, and whose transfer/burn internals revert if the caller (`auth`) is blacklisted. This means an admin action on `RWA` (pause or blacklist) can cause `PawnShop.liquidate(...)` to revert (problem).\n\nThis traps the loan in an unrecoverable state: the borrower cannot redeem after the `deadline`, and the manager cannot liquidate, so the collateral remains stuck in `PawnShop` indefinitely (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol#L262-L271](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol#L262-L271)\n\n```solidity\nfunction liquidate(uint256 tokenId) external nonReentrant whenNotPaused onlyRole(MANAGER_ROLE) {\n    Pawn memory pawning = pawns[tokenId];\n    if (!pawning.active) revert TokenNotPawned();\n    if (block.timestamp < pawning.deadline) revert DeadlineNotPassed();\n\n    pawns[tokenId].active = false;\n\n    // @audit Depends on external NFT burn rules\n    IERC721Burnable(address(nftToken)).burn(tokenId);\n}\n```\n\nFile: [sRWA.sol#L189-L197](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L189-L197)\n\n```solidity\nfunction burn(uint256 tokenId) external onlyTokenOwner(tokenId) whenNotPaused {\n    // code\n    _burn(tokenId);\n}\n```\n\nFile: [sRWA.sol#L270-L277](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L270-L277)\n\n```solidity\nfunction _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {\n    // code\n    if (auth != address(0) && _isBlacklisted[auth]) revert Blacklisted();\n    // code\n}\n```\n\n## Impact\n\n- Expired loans may become impossible to close if `RWA` is paused or if `PawnShop` is blacklisted.\n- Borrowers cannot redeem after `deadline`, so collateral can remain trapped without a clean resolution path.\n\n## Proof of Concept\n\n1. User opens a pawn via `PawnShop.pawn(...)`.\n2. Time passes beyond `deadline`.\n3. Admin pauses `RWA` (or blacklists `PawnShop` in `RWA`).\n4. Manager calls `PawnShop.liquidate(tokenId)`.\n5. The call reverts when it reaches `RWA.burn(...)`, leaving the loan stuck.\n\n## Recommendation\n\n- **Decouple liquidation from `RWA` pause/blacklist**:\n  - Allow `PawnShop` to liquidate by transferring the NFT to a protocol-controlled address if burning is blocked, or\n  - Give `PawnShop` a special role in `RWA` that can burn even when paused / not subject to blacklist, or\n  - Modify `RWA` so that pausing does not block burns initiated by the protocol liquidator.\n- Consider allowing **borrower redemption at/after deadline until liquidation occurs** to avoid “stuck forever” states.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "\nThe report describes a problem where a loan cannot be closed if the collateral used is a type of NFT called RWA and it is paused or blacklisted. This means that the borrower cannot get their collateral back and the manager cannot sell it, leaving it stuck in the system. The affected code is in the Pawn.sol and sRWA.sol files and the impact is that loans can become impossible to close and borrowers cannot get their collateral back. A proof of concept is provided and recommendations are given to decouple liquidation from RWA and to allow borrower redemption until liquidation occurs. The team has responded that the issue has been fixed.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64683",
      "title": "[M-01] Admin Can Seize Pawn Collateral via `emergencyWithdrawNFT()`",
      "impact": "MEDIUM",
      "content": "\n## Severity\n\nMedium Risk\n\n## Description\n\nThe `pawn(...)` flow escrows a user’s NFT inside `PawnShop` as collateral until the user repays via `redeem(...)` or the position is closed via `liquidate(...)` (context).\n\nHowever, `PawnShop` also exposes an `emergencyWithdrawNFT(...)` function that lets `DEFAULT_ADMIN_ROLE` transfer _any_ NFT held by the contract to an arbitrary address, with no restriction that the loan is inactive and no state cleanup (problem).\n\nThis means an admin can directly steal user collateral (even for active loans) and can also permanently break the loan’s lifecycle because `redeem(...)`/`liquidate(...)` expect the contract to still own the NFT (impact).\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n```solidity\nfunction emergencyWithdrawNFT(uint256 tokenId, address to) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {\n    // @audit Can transfer active collateral to an arbitrary address\n    if (to == address(0)) revert InvalidAddress();\n    nftToken.safeTransferFrom(address(this), to, tokenId);\n    emit EmergencyNFTWithdrawn(tokenId, to);\n}\n```\n\n## Impact\n\n- **User collateral theft**: An admin can move escrowed NFTs to themselves (or any address), bypassing borrower repayment rules.\n- **Protocol/loan state corruption**: Once the NFT is moved out, `redeem(...)` cannot return collateral and `liquidate(...)` cannot burn it, leaving the `pawns[tokenId]` state effectively unresolvable.\n\n## Proof of Concept\n\n1. Alice calls `pawn(...)` and `PawnShop` escrows Alice’s NFT.\n2. Admin calls `emergencyWithdrawNFT(tokenId, admin)`.\n3. Alice can no longer redeem her NFT, and the protocol cannot liquidate it on-chain because the NFT is no longer owned by `PawnShop`.\n\n## Recommendation\n\nConsider applying the following changes:\n\n- **Restrict scope**: Only allow emergency withdrawal for NFTs that are _not_ backing an active pawn:\n  - Require `!pawns[tokenId].active`, or\n  - Only allow withdrawal to `pawns[tokenId].borrower`.\n- **Add safeguards**: Use a timelock + multisig for `DEFAULT_ADMIN_ROLE`, and consider an on-chain guardian/emergency procedure that cannot seize active collateral.\n- **Maintain invariants**: If a forced withdrawal is ever allowed, update or clear the pawn state in a way that preserves a consistent resolution path.\n\n## Team Response\n\nFixed.\n\n",
      "summary": "\nThe report describes a bug in the `pawn()` function of the `PawnShop` contract. This function allows users to use their NFTs as collateral for a loan. However, the contract also has an `emergencyWithdrawNFT()` function that can be used by the admin to transfer any NFT held by the contract to an arbitrary address, even if the loan is still active. This means that the admin can steal user collateral and break the loan's lifecycle. The affected code can be found in the `Pawn.sol` file. The impact of this bug includes user collateral theft and protocol/loan state corruption. The report also provides a proof of concept and recommendations for fixing the bug, which the team has already addressed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64682",
      "title": "[H-02] Blacklisted Operators Can Not Be Revoked from Being an Operator",
      "impact": "HIGH",
      "content": "\n## Severity\n\nHigh Risk\n\n## Description\n\nNFTs can be stolen by the blacklisted operators. They can then burn/sell afterwards.\nImpact is high, as the victim NFT owner cannot revoke the approval from this balcaklisted operator because of this line below\n\nRoot cause :\n\n- `sRWA::setApprovalForAll(account, false)` reverts if account is blacklisted\n- `sRWA::approve()` can be called by blacklisted operators.\n\nFile: [sRWA.sol#L280](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol#L280)\n\n```solidity\n function setApprovalForAll(address operator, bool approved) public virtual override {\n>>>  if (_isBlacklisted[operator]) revert Blacklisted();\n     super.setApprovalForAll(operator, approved);\n }\n```\n\nIn `sRWA.sol`:\n\n1. A router exists, and a user who owns 10 NFTs sets it as his operator by calling `setApprovalForAll(router, true)`.\n2. The admin decides to blacklist this operator address (router) by calling `blacklistContract(router)` (e.g., due to OFAC/rogue).\n3. The user attempts to revoke the operator by calling `setApprovalForAll(router, false)`, but it reverts in line 301 below. (Issue 1)\n4. The rogue (now blacklisted) operator calls `approve(rogue operator's new unblacklisted account, victim owner's tokenId)`.\n5. Once approved, the attacker pulls those tokens via `transferFrom(victim owner, new unblacklisted account, victim owner's tokenId)`, and now the attacker owns them.\n6. Check line 389 of ERC721 below. It allows operators to assign new approvals for each token id\n\n## Location of Affected Code\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n```solidity\n function setApprovalForAll(address operator, bool approved) public virtual override {\n     if (_isBlacklisted[operator]) revert Blacklisted();\n     super.setApprovalForAll(operator, approved);\n }\n\n function approve(address to, uint256 tokenId) public virtual override {\n     if (_isBlacklisted[to]) revert Blacklisted();\n     super.approve(to, tokenId);\n }\n```\n\nFile: [contracts/token/ERC721/ERC721.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol)\n\n```solidity\nfunction _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n   // Avoid reading the owner unless necessary\n   if (emitEvent || auth != address(0)) {\n       address owner = _requireOwned(tokenId);\n\n       // We do not use _isAuthorized because single-token approvals should not be able to call approve\n>>>    if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n           revert ERC721InvalidApprover(auth);\n       }\n\n       if (emitEvent) {\n           emit Approval(owner, to, tokenId);\n       }\n   }\n\n   _tokenApprovals[tokenId] = to;\n}\n```\n\n## Impact\n\nUsers who previously granted `setApprovalForAll(router, true)` can have their NFTs stolen after the router is blacklisted, because:\n\n- The user cannot revoke the operator approval.\n- The blacklisted operator can still delegate approvals to an unblacklisted attacker, who can then transfer the NFTs.\n\n## Proof of Concept\n\nRun it in `test/System.t.sol`\n\n```solidity\nfunction test_POC_BlacklistedOperator_CannotBeRevoked_AndCanStealViaApprove() public {\n    address router = makeAddr(\"router\");\n    address attacker = makeAddr(\"attacker\");\n\n    // Mint 9 more tokens so `user` owns 10 NFTs total (tokenIds 1..10)\n    vm.startPrank(owner);\n    rwa.mint(user, \"UUID-124\");\n    rwa.mint(user, \"UUID-125\");\n    rwa.mint(user, \"UUID-126\");\n    rwa.mint(user, \"UUID-127\");\n    rwa.mint(user, \"UUID-128\");\n    rwa.mint(user, \"UUID-129\");\n    rwa.mint(user, \"UUID-130\");\n    rwa.mint(user, \"UUID-131\");\n    rwa.mint(user, \"UUID-132\");\n    vm.stopPrank();\n\n    // 1) user makes router an operator\n    vm.prank(user);\n    rwa.setApprovalForAll(router, true);\n    assertTrue(rwa.isApprovedForAll(user, router));\n\n    // 2) admin blacklists the operator/router address\n    vm.prank(owner);\n    rwa.blacklistContract(router);\n    assertTrue(rwa.isBlacklisted(router));\n\n    // 3) user attempts to revoke operator approval, but it reverts\n    vm.prank(user);\n    vm.expectRevert(RWA.Blacklisted.selector);\n    rwa.setApprovalForAll(router, false);\n\n    // 4) blacklisted router approves an unblacklisted attacker for each tokenId\n    for (uint256 tokenId = 1; tokenId <= 10; tokenId++) {\n        vm.prank(router);\n        rwa.approve(attacker, tokenId);\n        assertEq(rwa.getApproved(tokenId), attacker);\n    }\n\n    // 5) attacker pulls the tokens and becomes the owner\n    for (uint256 tokenId = 1; tokenId <= 10; tokenId++) {\n        vm.prank(attacker);\n        rwa.transferFrom(user, attacker, tokenId);\n        assertEq(rwa.ownerOf(tokenId), attacker);\n    }\n}\n```\n\n## Recommendation\n\n1. Allow revocation even if the operator is blacklisted (only block when setting `approved == true`).\n2. Block blacklisted callers from managing approvals (e.g., revert in `approve()` and `setApprovalForAll()` when `msg.sender` is blacklisted), so a blacklisted operator cannot delegate approvals to an unblacklisted attacker.\n\nFile: [sRWA.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/sRWA.sol)\n\n```diff\nfunction approve(address to, uint256 tokenId) public virtual override {\n+  if (_isBlacklisted[msg.sender]) revert Blacklisted();\n   if (_isBlacklisted[to]) revert Blacklisted();\n      super.approve(to, tokenId);\n   }\n}\n\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n-     if (_isBlacklisted[operator]) revert Blacklisted();\n+     if (_isBlacklisted[operator] && approved == true) revert Blacklisted();\n         super.setApprovalForAll(operator, approved);\n      }\n}\n```\n\n## Team Response\n\nFixed.\n\n",
      "summary": "\nThis bug report discusses a problem with NFTs (non-fungible tokens) being stolen by blacklisted operators. These operators are able to burn or sell the NFTs after stealing them. The severity of this issue is high as the victim NFT owner cannot revoke the approval from the blacklisted operator. The root cause of this issue is that the code does not allow for revocation if the operator is blacklisted. Additionally, the blacklisted operator is able to call a function that allows them to delegate approvals to an unblacklisted attacker, who can then steal the NFTs. The affected code can be found in the files sRWA.sol and ERC721.sol. A proof of concept has been provided to demonstrate how this bug can be exploited. The recommendation is to allow for revocation even if the operator is blacklisted and to block blacklisted callers from managing approvals. The team has responded that they have fixed the issue. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    },
    {
      "id": "64681",
      "title": "[H-01] Protocol Insolvency Risk Due to Lack of On-Chain Oracle",
      "impact": "HIGH",
      "content": "\n## Severity\n\nHigh Risk\n\n## Description\n\nThe protocol’s solvency relies on an off-chain `backendSigner` to determine the loan principal (`offerAmount`) without any on-chain verification of collateral value or an on-chain “unhealthy position” liquidation path. As a result, the protocol can become undercollateralized during the loan term (or even at origination if the signed offer is incorrect), while liquidation is only possible after a time-based deadline.\n\nIn volatile markets, this design can systematically create bad debt and drain protocol reserves.\n\n### Technical Details\n\n1. `offerAmount` is trusted without on-chain valuation checks\n\n`Pawn.pawn()` accepts `offerAmount` from a signature and stores it as the pawn principal. There is no on-chain mechanism to validate that the loan-to-value (LTV) is within safe limits at the time of origination. Protocol takes care of it off-chain.\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n```solidity\nfunction pawn(uint256 tokenId, uint8 durationDays, uint256 offerAmount, uint256 validUntil, bytes calldata pawnSignature, bytes calldata treasurySignature) external nonReentrant whenNotPaused {\n    // code\n    (bytes32 digest, uint256 currentNonce) = _validatePawnSignature(\n        tokenId,\n        offerAmount,\n        validUntil,\n        pawnSignature\n    );\n    // code\n    pawns[tokenId] = Pawn({\n        borrower: msg.sender,\n        amount: offerAmount,\n        deadline: deadline,\n        feeBasisPoints: fee,\n        active: true\n    });\n    // code\n}\n```\n\n2. Liquidation is strictly time-based (no health-factor liquidation)\n\n`Pawn.liquidate()` can only be executed after the pawn deadline. Even if the collateral value collapses during the term, the protocol cannot liquidate early to preserve solvency.\n\n```solidity\nfunction liquidate(uint256 tokenId) external nonReentrant whenNotPaused onlyRole(MANAGER_ROLE) {\n    Pawn memory pawning = pawns[tokenId];\n    if (!pawning.active) revert TokenNotPawned();\n\n    // Liquidation is only possible after the time-based deadline\n    if (block.timestamp < pawning.deadline) revert DeadlineNotPassed();\n\n    pawns[tokenId].active = false;\n\n    IERC721Burnable(address(nftToken)).burn(tokenId);\n    emit TokenLiquidated(tokenId, msg.sender);\n}\n```\n\n## Location of Affected Code\n\nFile: [Pawn.sol](https://github.com/ShinyUrban/SmartContracts/blob/f49b5db73b297552666783ed587cf0818ef86b75/Pawn.sol)\n\n## Impact\n\nIf the collateral value drops below the loan principal during the loan term, rational borrowers are incentivized to default. The protocol then realizes a loss equal to:\n\n`Bad Debt = (Principal + Accrued Fees) - Collateral Value at recovery`\n\nPractical consequences:\n\n- **Protocol insolvency / reserve depletion:** USDC can be paid out against collateral that later becomes insufficient.\n- **Systemic bad debt:** The issue is not limited to one position; it is a structural failure mode whenever the signed `offerAmount` exceeds safe LTV or market prices fall during the term.\n- **Limited mitigation after the fact:** Because liquidation burns the token (claiming the underlying asset), the protocol is effectively forced to “take delivery” at an unfavourable valuation, crystallising losses.\n\n## Proof of Concept\n\n1. An RWA token represents a physical gold bar worth 2,000 USDC.\n2. The backend signs a loan offer for 1,800 USDC (90% LTV) due to error, stale pricing, or sudden market movement.\n3. The next day, gold drops 20% and the collateral value becomes 1,600 USDC.\n4. The protocol cannot liquidate because `block.timestamp < deadline`.\n5. The borrower rationally defaults because repayment exceeds collateral value.\n6. At `deadline`, the protocol liquidates and ends up recovering an asset worth ~1,600 USDC after having lent 1,800 USDC (excluding fees).\n7. Net loss is ~200 USDC (plus any additional loss due to fees/realization costs).\n\n## Recommendations\n\n### A) Enforce origination LTV on-chain\n\nIntegrate an on-chain pricing source for the underlying collateral and enforce a maximum LTV at pawn creation.\n\n```solidity\nuint256 collateralValue = oracle.getPrice(tokenId); // must define units + decimals\nrequire(offerAmount <= (collateralValue * MAX_LTV_BPS) / 10_000, \"LTV too high\");\n```\n\nMinimum requirements for a robust Oracle integration:\n\n- Staleness checks (e.g., revert if price is older than a configured threshold).\n- Consistent units/decimals normalization.\n- Clear fallback behavior when the oracle is unavailable.\n\n### B) Add health-factor-based liquidation during the term\n\nImplement a liquidation condition that triggers when the position becomes undercollateralized (e.g., collateral value falls below a liquidation threshold). This can allow liquidation before the `deadline` and materially reduce bad debt.\n\n### C) If an oracle is not feasible, reduce trust in the backend signer\n\nIf on-chain pricing is not currently possible, consider compensating controls (still weaker than an oracle), such as:\n\n- Very conservative LTV caps hard-coded on-chain per asset class.\n- Shorter maximum loan durations.\n- Emergency controls to halt new pawns when pricing is uncertain.\n\n## Team Response\n\nAcknowledged.\n\n",
      "summary": "\nThe bug report identifies a high-risk issue in a protocol that could lead to insolvency and bad debt. The protocol relies on an off-chain `backendSigner` to determine the loan amount without any on-chain verification, which can result in undercollateralization. Additionally, liquidation is only possible after a time-based deadline, which could lead to losses in volatile markets. The affected code is located in the `Pawn.sol` file. The impact of this bug includes protocol insolvency, systemic bad debt, and limited mitigation options. A proof of concept is presented, and recommendations are made to address the issue, including enforcing on-chain verification of collateral value, implementing health-factor-based liquidation, or reducing trust in the backend signer. The team has acknowledged the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Shieldify",
      "protocol_name": "Shiny",
      "source_link": "https://github.com/shieldify-security/audits-portfolio-md/blob/main/Shiny-Security-Review.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Shieldify Security"
      ]
    }
  ]
}